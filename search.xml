<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux调试之崩溃</title>
      <link href="/posts/3b8c.html"/>
      <url>/posts/3b8c.html</url>
      
        <content type="html"><![CDATA[<h2 id="Linux内核panic后查看dmesg"><a href="#Linux内核panic后查看dmesg" class="headerlink" title="Linux内核panic后查看dmesg"></a>Linux内核panic后查看dmesg</h2><p>由于panic后内核不能再将dmesg写入到存储介质中去，所以重启之后dmesg就丢失了。但是kdump可以在内核panic后启用一个小内核来将dmesg和一些内存信息写进存储介质。使用kdump配合crash查看崩溃信息的。</p><h3 id="Kdump简介"><a href="#Kdump简介" class="headerlink" title="Kdump简介"></a>Kdump简介</h3><p>kdump是一种基于kexec的内核崩溃转储技术。kdump需要两个内核，分别是生产内核和捕获内核，生产内核是捕获内核服务的对象，且保留了内存的一部分给捕获内核启动使用。当系统崩溃时，kdump使用kexec启动捕获内核，以相应的ramdisk一起组建一个微环境，用于对生产内核下的内存进行收集和转存。</p><h3 id="安装kdump"><a href="#安装kdump" class="headerlink" title="安装kdump"></a>安装kdump</h3><h4 id="ubuntu上kdump安装配置："><a href="#ubuntu上kdump安装配置：" class="headerlink" title="ubuntu上kdump安装配置："></a>ubuntu上kdump安装配置：</h4><p>参考；<a href="https://www.cnblogs.com/zhangmingda/p/12566534.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangmingda/p/12566534.html</a></p><h4 id="centos下安装配置："><a href="#centos下安装配置：" class="headerlink" title="centos下安装配置："></a>centos下安装配置：</h4><h5 id="安装kexec-tools"><a href="#安装kexec-tools" class="headerlink" title="安装kexec-tools"></a>安装kexec-tools</h5><p>  使用kdump服务，必须要用到kexec-tools工具包。</p><pre><code>sudo yum updatesudo yum install kexec-tools</code></pre><p>  安装完成之后可以通过kexec -version查看kexec的版本。</p><h5 id="配置kdump-kernel"><a href="#配置kdump-kernel" class="headerlink" title="配置kdump kernel"></a>配置kdump kernel</h5><p>  需要为kdump kernel配置内存区域，kdump要求系统正常使用时，不能使用kdump kernel所占用的内存。</p><p> <strong>1.修改grub文件</strong></p><pre><code>vim /etc/default/grub</code></pre><p>  需要将GRUB_CMDLINE_LINUX=”crashkernel=auto…”中的auto修改为128M。一般设为128M或256M。</p><p> <strong>2.更新grub配置</strong></p><p> 只要更改了grub文件，都需要更改grub配置。</p><pre><code>sudo grub2-mkconfig -o /boot/grub2/grub.cfg</code></pre><p>  <strong>3.重启系统</strong></p><pre><code>reboot</code></pre><h5 id="修改kdump默认配置"><a href="#修改kdump默认配置" class="headerlink" title="修改kdump默认配置"></a>修改kdump默认配置</h5><pre><code>vim /etc/kdump.conf</code></pre><p>  其中，需要注意的三行内容是</p><pre><code>path /var/crash            #指定coredump文件放在/var/crash文件夹中core_collector makedumpfile -c -l --message-level 1 -d 31   #加上-c表示压缩，原文件中没有default reboot         #生成coredump后，重启系统</code></pre><p>开启kdump服务</p><pre><code>systemctl start kdump.service     //启动kdumpsystemctl enable kdump.service    //设置开机启动</code></pre><h5 id="测试kdump是否开启"><a href="#测试kdump是否开启" class="headerlink" title="测试kdump是否开启"></a>测试kdump是否开启</h5><p>  <strong>1.检查kdump开启成功</strong></p><pre><code>service kdump status</code></pre><p>  如下所示，表示开启成功    </p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MWM4YTU0ZjhiYThjZWMzODE4ZWU4NTVhZDUyNTQzMzBfVTFudGNOMGJZM09VZ2d1QVJOQm1oTm9FR0c1cE9tcW9fVG9rZW46Ym94Y25HbllLdzg3bDBLdUJXS1NuRXNXdmNmXzE2MjcxNDg5NDQ6MTYyNzE1MjU0NF9WNA" alt="img"></p><p>关闭kdump服务</p><pre><code>service kdump stop</code></pre><p>禁止开机启动</p><pre><code>chkconfig kdump off</code></pre><p> <strong>2.手动触发crash</strong></p><pre><code>#echo 1 &gt; /proc/sys/kernel/sysrq#echo c &gt; /proc/sysrq-trigger</code></pre><p>  如果配置成功，系统将自动重启，重新进入系统，可以看到/var/crash文件夹下生成了相应文件，是一个以生成coredump日期为文件名的文件,如图所示：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzcwNWM4NWNiZDg0ZmU3ZDhiN2M3N2VjMjRmNDY2MWVfWFBhckNQeUdDS0dpWmd1bHRZekxJWklOa0hRYVF4dDlfVG9rZW46Ym94Y24xdDBTa3R3aVc2aXpWQ3VZdG1KSHM5XzE2MjcxNDg5NDQ6MTYyNzE1MjU0NF9WNA" alt="img"></p><h3 id="减少dump文件的大小"><a href="#减少dump文件的大小" class="headerlink" title="减少dump文件的大小"></a>减少dump文件的大小</h3><pre><code>man makedumpfile</code></pre><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzU3NDI0MmVlMGIzNWRjNzU1Y2I3MWI2OWVkZjQwNThfSzBqdGRGU1BXTldBZkFJNDdqWlNhZlNBdlVZRkVYeUhfVG9rZW46Ym94Y24wY0daZzlKVGtUMGZySGRBeGRLZjVnXzE2MjcxNDg5NDQ6MTYyNzE1MjU0NF9WNA" alt="img"></p><p>可以看到默认的消息等级（打星星的7）会打印common message，生成的dump文件很大。所以我们把它改成1，只打印process indicator：编辑/etc/default/kdump-tools，在里面加上</p><pre><code>MAKEDUMP_ARGS="-c --message-level 1 -d 31"</code></pre><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjNhZTFhZGEzY2IzYjgwY2M5ZDM5N2IyMzAwZmY4MDBfamF1b2lISlZrSGxiU2xoaTQwbkZRWWZIUW5SMVZYdGhfVG9rZW46Ym94Y25WcnR0SEdJdU1ROHhmMlhDWlNqMzZkXzE2MjcxNDg5NDQ6MTYyNzE1MjU0NF9WNA" alt="img"></p><p>现在dump文件只有17MB了。</p><h3 id="禁止生成vmcore"><a href="#禁止生成vmcore" class="headerlink" title="禁止生成vmcore"></a>禁止生成vmcore</h3><p>vmcore文件很大，生成要花费大量时间。我们这里只需要dmesg，所以可以禁止生成vmcore。</p><p>编辑/etc/default/kdump-tools</p><pre><code>MAKEDUMP_ARGS="-c -d 31 --message-level 0 --dump-dmesg"</code></pre><p>其中–dump-dmesg表示直接把dmesg抽出来，而不生成vmcore。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGY1ZDU5ZmQ3Y2E2YzRjMDhiZTZiYjM1ODA3MjhiZWNfZTJWS3U0MTE0WE10NldLMklnWDJId01MdEF2M0N5UmhfVG9rZW46Ym94Y25QT0VuUU5kUkFNV21oZHVFZjc4emNkXzE2MjcxNDg5NDQ6MTYyNzE1MjU0NF9WNA" alt="img"></p><p>现在生成的文件都很小了，重启也非常快。</p><h2 id="Linux运行C程序crash掉的分析"><a href="#Linux运行C程序crash掉的分析" class="headerlink" title="Linux运行C程序crash掉的分析"></a>Linux运行C程序crash掉的分析</h2><h3 id="一、程序运行崩溃的原因"><a href="#一、程序运行崩溃的原因" class="headerlink" title="一、程序运行崩溃的原因"></a><strong>一、程序运行崩溃的原因</strong></h3><p>Linux下c/c++开发程序崩溃(Segment fault)通常都是指针错误引起的.</p><p>比如：</p><p>(1)访问了不存在的内存地址</p><p>(2)访问了只读的内存地址</p><p>(3)访问了系统保护的内存地址int <em>p=0;</em>p=100;</p><p>(4)栈溢出，无限递归</p><p>(5)内存溢出</p><h3 id="二、内核转储文件作用"><a href="#二、内核转储文件作用" class="headerlink" title="二、内核转储文件作用"></a><strong>二、内核转储文件作用</strong></h3><p>发生Segment fault时，内核转储文件(core dump)作用</p><p>(1) 内核转储的最大好处是能够保存问题发生时的状态。</p><p>(2) 只要有可执行文件和内核转储，就可以知道进程当时的状态。</p><p>(3) 只要获取内核转储，那么即使没有复现环境，也能调试。</p><h3 id="三、配置操作系统的内核转储功能"><a href="#三、配置操作系统的内核转储功能" class="headerlink" title="三、配置操作系统的内核转储功能"></a><strong>三、配置操作系统的内核转储功能</strong></h3><p>可以参考《高并发服务器开发与配置》中，用户能打开的最大文件数的设置方法。</p><p>启动系统的内核转储功能，需要做如下配置:</p><p>(1)查看当前转储文件大小</p><p>&gt;&gt; ulimit -c</p><p>0  为0，表示当前转储文件大小为0，没有启动内核转储</p><p>&gt;&gt;ulimit -c unlimited      #设置coredump 大小为无限大</p><p>这些需要有root权限, 在ubuntu下每次重新打开中断都需要重新输入上面的第一条命令, 来设置core大小为无限.</p><h3 id="四、gdb使用内核转储文件再现崩溃时的状态"><a href="#四、gdb使用内核转储文件再现崩溃时的状态" class="headerlink" title="四、gdb使用内核转储文件再现崩溃时的状态"></a><strong>四、gdb使用内核转储文件再现崩溃时的状态</strong></h3><p>&gt;&gt;./test  -&gt;运行test崩溃，在当前目录下将产生一个core文件</p><p>&gt;&gt;gdb -c ./corefile ./test  使用gdb再现崩溃状态</p><p>在进入gdb后, 用bt命令查看backtrace以检查发生程序运行到哪里, 来定位core dump的文件-&gt;行.</p><h3 id="五、System-Dump和Core-Dump的区别"><a href="#五、System-Dump和Core-Dump的区别" class="headerlink" title="五、System Dump和Core Dump的区别"></a><strong>五、System Dump和Core Dump的区别</strong></h3><p>\1) 系统Dump（System Dump）</p><p>所有开放式操作系统，都存在系统DUMP问题。</p><p>产生原因：</p><p>由于系统关键/核心进程，产生严重的无法恢复的错误，为了避免系统相关资源受到更大损害，操作系统都会强行停止运行，并将当前内存中的各种结构,核心进程出错位置及其代码状态，保存下来，以便以后分析。最常见的原因是指令走飞，或者缓冲区溢出，或者内存访问越界。走飞就是说代码流有问题，导致执行到某一步指令混乱，跳转到一些不属于它的指令位置去执行一些莫名其妙的东西（没人知道那些地方本来是代码还是数据，而且是不是正确的代码开始位置），或者调用到不属于此进程的内存空间。写过C程序及汇编程序的人士，对这些现象应当是很清楚的。</p><p>系统DUMP生成过程的特点：</p><p>在生成DUMP过程中，为了避免过多的操作结构，导致问题所在位置正好也在生成DUMP过程所涉及的资源中，造成DUMP不能正常生成，操作系统都用尽量简单的代码来完成，所以避开了一切复杂的管理结构，如文件系统）LVM等等，所以这就是为什么几乎所有开放系统，都要求DUMP设备空间是物理连续的——不用定位一个个数据块，从DUMP设备开头一直写直到完成，这个过程可以只用BIOS级别的操作就可以。这也是为什么在企业级UNIX普遍使用LVM的现状下，DUMP设备只可能是裸设备而不可能是文件系统文件，而且[b]只[/b]用作DUMP的设备，做 LVM镜像是无用的——系统此时根本没有LVM操作，它不会管什么镜像不镜像，就用第一份连续写下去。</p><p>所以UNIX系统也不例外，它会将DUMP写到一个裸设或磁带设备。在重启的时候，如果设置的DUMP转存目录（文件系统中的目录）有足够空间，它将会转存成一个文件系统文件，缺省情况下，对于AIX</p><p>来说是/var/adm/ras/下的vmcore*这样的文件，对于HPUX来说是 /var/adm/crash下的目录及文件。当然，也可以选择将其转存到磁带设备。会造成系统DUMP的原因主要是：系统补丁级别不一致或缺少）系统内核扩展有BUG（例如Oracle就会安装系统内核扩展））驱动程序有 BUG（因为设备驱动程序一般是工作在内核级别的），等等。所以一旦经常发生类似的系统DUMP，可以考虑将系统补丁包打到最新并一致化）升级微码）升级设备驱动程序（包括FC多路冗余软件））升级安装了内核扩展的软件的补丁包等等。</p><p>\2) 进程Core Dump</p><p>进程Core Dump产生的技术原因，基本等同于系统DUMP，就是说从程序原理上来说是基本一致的。但进程是运行在低一级的优先级上（此优先级不同于系统中对进程定义的优先级，而是指CPU代码指令的优先级），被操作系统所控制，所以操作系统可以在一个进程出问题时，不影响其他进程的情况下，中止此进程的运行，并将相关环境保存下来，这就是core dump文件，可供分析。</p><p>如果进程是用高级语言编写并编译的，且用户有源程序，那么可以通过在编译时带上诊断用符号表（所有高级语言编译程序都有这种功能），通过系统提供的分析工具，加上core文件，能够分析到哪一个源程序语句造成的问题，进而比较容易地修正问题，当然，要做到这样，除非一开始就带上了符号表进行编译，否则只能重新编译程序，并重新运行程序，重现错误，才能显示出源程序出错位置。</p><p>如果用户没有源程序，那么只能分析到汇编指令的级别，难于查找问题所在并作出修正，所以这种情况下就不必多费心了，找到出问题的地方也没有办法。</p><p>进程Core Dump的时候，操作系统会将进程异常终止掉并释放其占用的资源，不可能对系统本身的运行造成危害。这是与系统DUMP根本区别的一点，系统DUMP产生时，一定伴随着系统崩溃和停机，进程</p><p>Core Dump时，只会造成相应的进程被终止，系统本身不可能崩溃。当然如果此进程与其他进程有关联，其他进程也会受到影响，至于后果是什么，就看相关进程对这种异常情况（与自己相关的进程突然</p><p>终止）的处理机制是什么了，没有一概的定论。</p><h3 id="六、内核转储文件-core-dump-永久生效的办法"><a href="#六、内核转储文件-core-dump-永久生效的办法" class="headerlink" title="六、内核转储文件(core dump)永久生效的办法"></a><strong>六、内核转储文件(core dump)永久生效的办法</strong></h3><p>在终端中输入以下命令，查看内核转储是否有效。</p><pre><code>#ulimit -c0</code></pre><p>-c 表示内核转储文件的大小限制，现在显示为0，表示不能用。</p><p>永久生效的办法是：</p><pre><code>#vi /etc/profile 然后，在profile中添加：ulimit -c 1073741824     --1G大小</code></pre><p>(但是，若将产生的转储文件大小大于该数字时，将不会产生转储文件)或者</p><pre><code>ulimit -c unlimited</code></pre><p>这样重启机器后生效了。 或者， 使用source命令使之马上生效。</p><pre><code>#source /etc/profile</code></pre><h3 id="七、指定内核转储的文件名和目录"><a href="#七、指定内核转储的文件名和目录" class="headerlink" title="七、指定内核转储的文件名和目录"></a><strong>七、指定内核转储的文件名和目录</strong></h3><p>缺省情况下，内核在coredump时所产生的core文件放在与该程序相同的目录中，并且文件名固定为core。很显然，如果有多个程序产生core文件，或者同一个程序多次崩溃，就会重复覆盖同一个core文</p><p>件。可以通过修改kernel的参数，指定内核转储所生成的core文件的路径和文件名。</p><p>可以通过在/etc/sysctl.conf文件中，对sysctl变量kernel.core_pattern的设置。</p><pre><code>&gt;&gt;vi /etc/sysctl.conf</code></pre><p>然后，在sysctl.conf文件中添加下面两句话：</p><pre><code>kernel.core_pattern = /var/core/core_%e_%pkernel.core_uses_pid = 0</code></pre><p>需要说明的是， /proc/sys/kernel/core_uses_pid。如果这个文件的内容被配置成1，即使core_pattern中没有设置%p，最后生成的core dump文件名仍会加上进程ID。</p><p>这里%e, %p分别表示：</p><p>%c 转储文件的大小上限</p><p>%e 所dump的文件名</p><p>%g 所dump的进程的实际组ID</p><p>%h 主机名</p><p>%p 所dump的进程PID</p><p>%s 导致本次coredump的信号</p><p>%t 转储时刻(由1970年1月1日起计的秒数)</p><p>%u 所dump进程的实际用户ID</p><p>可以使用以下命令，使修改结果马上生效。</p><pre><code>&gt;&gt;sysctl –p /etc/sysctl.conf</code></pre><p>请在/var目录下先建立core文件夹，然后执行a.out程序，就会在/var/core/下产生以指定格式命名的内核转储文件。查看转储文件的情况：</p><pre><code>#ls /var/corecore_a.out_2834</code></pre><p><strong>八、例子</strong></p><p>Linux下c/c++开发之程序崩溃(Segment fault)时内核转储文件(coredump)生成举例说明</p><p>例子的源代码：</p><pre><code>#include &lt;stdio.h&gt;int main(void){int *a = NULL;*a = 0x1;return 0;}</code></pre><p>把以上源代码，写成一个a.c文件后，编译a.c文件产生一个a.out的可执行文件：</p><pre><code>#gcc -g a.c -o a.out</code></pre><p>修改a.out文件的权限后，执行它：</p><pre><code>#./a.out</code></pre><p>就会显示：</p><pre><code>Segmentation fault(core dump)</code></pre><p>这表示在当前目录下, 已经生成了a.out对应的内核转储文件。</p><p>注意：后面带有(core dump), 才说明转储文件成功生成了。</p><pre><code>#file core*core:ELF 64-bit LSB core file x86-64, version 1(SYSV), SVR4-style, from './a.out'coreDump: UTF-8 Unicode C program text</code></pre><p>要用GDB调试内核转储文件，应该使用以下方式启动GDB:</p><pre><code>#gdb -c ./core ./a.outGNU gdb (GDB) 7.1-Ubuntu...Core was generated by './a.out'.Program terminated with signal 11, Segmentation fault.#0 0x00000000004004dc in main() at a.c:66 *a =0x1;</code></pre><p>a.c的第6行收到了11号信号。用GDB的list命令可以查看附近的源代码。</p><pre><code>(gdb) l 51           #include &lt;stdio.h&gt;2     3           int main(void)4           {5                  int *a = NULL;6                  *a = 0x1;7                  return 0;8           }</code></pre><p>这里默认都是当前目录，也可以给core 和a.out 指定路径。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dump | Linux Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB简介</title>
      <link href="/posts/5bd5.html"/>
      <url>/posts/5bd5.html</url>
      
        <content type="html"><![CDATA[<h3 id="gcc常见命令"><a href="#gcc常见命令" class="headerlink" title="gcc常见命令"></a>gcc常见命令</h3><p>1.gcc -E source_file.c</p><p>-E，只执行到预编译。直接输出预编译结果。</p><p>\2. gcc -S source_file.c </p><p>-S，只执行到源代码到汇编代码的转换，输出汇编代码。</p><p>\3. gcc -c source_file.c</p><p>-c，只执行到编译，输出目标文件。</p><p>\4. gcc (-E/S/c/) source_file.c -o output_filename</p><p>-o, 指定输出文件名，可以配合以上三种标签使用。</p><p>-o 参数可以被省略。这种情况下编译器将使用以下默认名称输出：</p><p>-E：预编译结果将被输出到标准输出端口（通常是显示器）</p><p>-S：生成名为source_file.s的汇编代码</p><p>-c：生成名为source_file.o的目标文件。</p><p>无标签情况：生成名为a.out的可执行文件。</p><p>\5. gcc -g source_file.c </p><p>-g，生成供调试用的可执行文件，可以在gdb中运行。由于文件中包含了调试信息因此运行效率很低，且文件也大不少。</p><p>这里可以用strip命令重新将文件中debug信息删除。这是会发现生成的文件甚至比正常编译的输出更小了，这是因为strip把原先正常编译中的一些额外信息（如函数名之类）也删除了。用法为 strip a.out</p><p>\6. gcc -s source_file.c</p><p>-s, 直接生成与运用strip同样效果的可执行文件（删除了所有符号信息）。</p><p>\7. gcc -O source_file.c</p><p>-O（大写的字母O），编译器对代码进行自动优化编译，输出效率更高的可执行文件。</p><p>-O 后面还可以跟上数字指定优化级别，如：</p><p>gcc -O2 source_file.c</p><p>数字越大，越加优化。但是通常情况下，自动的东西都不是太聪明，太大的优化级别可能会使生成的文件产生一系列的bug。一般可选择2；3会有一定风险。</p><p>\8. gcc -Wall source_file.c</p><p>-W，在编译中开启一些额外的警告（warning）信息。-Wall，将所有的警告信息全开。</p><p>\9. gcc source_file.c -L/path/to/lib -lxxx -I/path/to/include</p><p>-l, 指定所使用到的函数库，本例中链接器会尝试链接名为libxxx.a的函数库。</p><p>-L，指定函数库所在的文件夹，本例中链接器会尝试搜索/path/to/lib文件夹。</p><p>-I, 指定头文件所在的文件夹，本例中预编译器会尝试搜索/path/to/include文件夹。</p><h3 id="gdb命令"><a href="#gdb命令" class="headerlink" title="gdb命令"></a>gdb命令</h3><h4 id="使用规则及高频选项"><a href="#使用规则及高频选项" class="headerlink" title="使用规则及高频选项"></a>使用规则及高频选项</h4><pre><code>gdb [选项] 程序名称-p #指定一个pid，调试正在运行的程序</code></pre><h4 id="高频调试指令"><a href="#高频调试指令" class="headerlink" title="高频调试指令"></a>高频调试指令</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2E4ODFiNjNkOGMwM2E4ZGYyZjI5NDgxMzdmMmZmNmZfd0RUaHpEVFNlYlI2UVRBZDdXWXBqcUtPeE5SODFJYWlfVG9rZW46Ym94Y25uVGZtMlhMS2JFTVBrM3JXU0Fna1hiXzE2MjcxNDg4Njg6MTYyNzE1MjQ2OF9WNA" alt="img"></p><h4 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h4><pre><code>#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int gval = 100;int mycopy(char *buf){ strcpy(buf, "我爱我的祖国"); return gval;}int main(){ int i = 0;printf("gval:%d\n", gval);for (i = 0; i &amp;lt; 10; i++) {    gval += i;    printf("gval:%d\n", gval);}   char *buf = "我爱我家";printf("%s\n", buf);buf = NULL;mycopy(buf);printf("%s\n", buf);return 0;}</code></pre><h4 id="gdb-调试之调试前提"><a href="#gdb-调试之调试前提" class="headerlink" title="gdb 调试之调试前提"></a>gdb 调试之调试前提</h4><p>并非所有的程序都可以直接调试，gdb 程序的前提是即将调试的程序中必须包含有调试符号信息。因此在程序编译生成时必须指定生成debug版本的程序，因为只有debug版本的程序在编译生成的时候才会加入程序的调试符号信息。</p><pre><code>[san@San doc]$ ls -l test.c-rw-rw-r-- 1 san san 460 Apr 20 15:40 test.c[san@San doc]$ gcc -g test.c -o test[san@San doc]$</code></pre><p>注意： gcc -g 选项的功能为在编译生成可执行程序时，向程序中添加调试符号信息。</p><h4 id="加载程序"><a href="#加载程序" class="headerlink" title="加载程序"></a>加载程序</h4><p>直接运行gdb，将可执行程序文件名称以空格间隔，紧跟其后即可</p><pre><code>[san@San doc]$ gdb ./testGNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-114.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type "show copying"and "show warranty" for details.This GDB was configured as "x86_64-redhat-linux-gnu".For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;…Reading symbols from /home/san/doc/test…done.(gdb) </code></pre><p>若要调试正在运行中的程序，则使用 gdb -p 选项指定进程id来连接到这个程序</p><pre><code>[san@San doc]$ sleep 60[san@San ~]$ ps -ef|grep sleepUID PID PPID C STIME TTY TIME CMDsan 8712 29712 0 16:04 pts/2 00:00:00 sleep 60san 8746 8717 0 16:04 pts/1 00:00:00 grep --color=auto sleep[san@San ~]$ gdb -p 8712</code></pre><p>注意： 这里的ps -ef|grep sleep 为查看进程信息，并过滤出名称为 sleep 的进程。</p><h4 id="开始调试：run、start"><a href="#开始调试：run、start" class="headerlink" title="开始调试：run、start"></a>开始调试：run、start</h4><pre><code>[san@San doc]$ gdb ./testReading symbols from /home/san/doc/test…done.(gdb) runStarting program: /home/san/doc/./test gval:100gval:100gval:101</code></pre><p>注意： 这里run 命令敲击后，则直接开始运行程序，直到断点位置停下或者程序结束。</p><pre><code>(gdb) start The program being debugged has been started already.Start it from the beginning? (y or n) yTemporary breakpoint 1 at 0x4005a7: file test.c, line 13.Starting program: /home/san/doc/./test Temporary breakpoint 1, main () at test.c:1313 int i = 0;</code></pre><p>注意： 这里start 命令敲击后，则程序从main函数的起始位置停下，开始逐步调试。</p><h4 id="查看调试行附近代码-list"><a href="#查看调试行附近代码-list" class="headerlink" title="查看调试行附近代码: list"></a>查看调试行附近代码: list</h4><p>(gdb) list</p><pre><code>8 strcpy(buf, "我爱我的祖国");9 return gval;10 }11 int main()12 {13 int i = 0;14 15 printf("gval:%d\n", gval);16 for (i = 0; i &lt; 10; i++) {17 gval += i;</code></pre><p>注意： 这里list 命令敲击后，查看的是调试行上下五行内的代码</p><pre><code>(gdb) list test.c:2015 printf("gval:%d\n", gval);16 for (i = 0; i &lt; 10; i++) {17 gval += i;18 printf("gval:%d\n", gval);19 }20 char *buf = "我爱我家";21 printf("%s\n", buf);22 buf = NULL;23 mycopy(buf);24 printf("%s\n", buf);</code></pre><p>注意： 这里list test.c:20 命令敲击后，表示查看test.c文件的第20行附近代码</p><h4 id="逐步调试之-step"><a href="#逐步调试之-step" class="headerlink" title="逐步调试之 step"></a>逐步调试之 step</h4><pre><code>(gdb) step15 printf("gval:%d\n", gval);(gdb) stepgval:10016 for (i = 0; i &lt; 10; i++) {(gdb) step17 gval += i;23 mycopy(buf);(gdb) stepmycopy (buf=0x0) at test.c:88 strcpy(buf, "我爱我的祖国");(gdb) list3 #include &lt;stdlib.h&gt;4 #include &lt;string.h&gt;5 int gval = 100;6 int mycopy(char *buf)7 {8 strcpy(buf, "我爱我的祖国");9 return gval;10 }</code></pre><h4 id="逐步调试之-next"><a href="#逐步调试之-next" class="headerlink" title="逐步调试之 next"></a>逐步调试之 next</h4><pre><code>(gdb) next18 printf("gval:%d\n", gval);(gdb) nextgval:10016 for (i = 0; i &lt; 10; i++) {(gdb) next17 gval += i;</code></pre><p>注意： 这里示例中step 和 next 命令敲击后都是运行当前行代码，进入下一行。</p><pre><code>main () at test.c:2323 mycopy(buf);(gdb) nextProgram received signal SIGSEGV, Segmentation fault.</code></pre><p>注意： 从示例中可以看出step 和 next 命令的区别在于，当调试行为函数时，step会进入函数内部继续逐步调试，而next则是直接将函数运行完毕（我这里的代码函数的运行直接出错了）。</p><h4 id="逐步调试之-until"><a href="#逐步调试之-until" class="headerlink" title="逐步调试之 until"></a>逐步调试之 until</h4><pre><code>(gdb) startThe program being debugged has been started already.Start it from the beginning? (y or n) yTemporary breakpoint 3 at 0x4005a7: file test.c, line 13.Starting program: /home/san/doc/./test Temporary breakpoint 3, main () at test.c:1313 int i = 0;(gdb) until test.c:23gval:100gval:100gval:101gval:103gval:106gval:110gval:115gval:121gval:128gval:136gval:145我爱我家main () at test.c:2323 mycopy(buf);</code></pre><p>注意： 从示例中可以看出until test.c:23 这一步的指令的功能为直接运行到test.c文件的第23行。</p><h4 id="逐步调试之-continue"><a href="#逐步调试之-continue" class="headerlink" title="逐步调试之 continue"></a>逐步调试之 continue</h4><pre><code>(gdb) ngval:10016 for (i = 0; i &lt; 10; i++) {(gdb) n17 gval += i;(gdb) continueContinuing.gval:100gval:101gval:103</code></pre><p>注意： continue 的功能是从当前位置开始运行，直到遇到下一个断点或者程序运行结束。</p><h4 id="断点添加之break"><a href="#断点添加之break" class="headerlink" title="断点添加之break"></a>断点添加之break</h4><pre><code>(gdb) break test.c:21Breakpoint 6 at 0x400608: file test.c, line 21.(gdb) runThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /home/san/doc/./test gval:100gval:100gval:101gval:103…Breakpoint 6, main () at test.c:2121 printf("%s\n", buf);</code></pre><p>注意： break test.c:21 的功能是给test.c文件的第21行打断点，程序运行至第21行就会停下来。</p><h4 id="查看并删除断点之info-breeak和delete"><a href="#查看并删除断点之info-breeak和delete" class="headerlink" title="查看并删除断点之info breeak和delete"></a>查看并删除断点之info breeak和delete</h4><pre><code>(gdb) info breakNum Type Disp Enb Address What6 breakpoint keep y 0x0000000000400608 in main at test.c:21 breakpoint already hit 1 time(gdb) deleteDelete all breakpoints? (y or n) n(gdb) delete 6(gdb) info breakNo breakpoints or watchpoints.(gdb) </code></pre><p>注意： info break 用于查看断点信息， 能够看到示例中有一个断点ID为6的断点信息； 使用delete删除断点时，默认为删除所有断点信息，可以使用y 或 n 决定是否删除。同时也可以直接使用delete删除断点的时候直接通过断点ID删除指定的断点。</p><p>查看程序中函数调用栈信息之backtrace</p><pre><code>(gdb) runThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /home/san/doc/./test gval:100gval:100….Program received signal SIGSEGV, Segmentation fault.0x000000000040057c in mycopy (buf=0x0) at test.c:88 strcpy(buf, "我爱我的祖国");(gdb) backtrace#0 0x000000000040057c in mycopy (buf=0x0) at test.c:8#1 0x0000000000400628 in main () at test.c:23</code></pre><p>注意： backtrace 用于查看调用栈信息，从示例中可以看出在程序因为异常错误退出时，调用栈顶函数为mycopy 函数，则可以认为程序退出是在mycopy 函数中出现了某个错误（因为程序运行在这个函数中的时候还没有来得及运行完函数然后出栈函数，就退出了）。</p><h4 id="查看并设置变量数据"><a href="#查看并设置变量数据" class="headerlink" title="查看并设置变量数据"></a>查看并设置变量数据</h4><pre><code>(gdb) list3 #include &lt;stdlib.h&gt;4 #include &lt;string.h&gt;5 int gval = 100;6 int mycopy(char *buf)7 {8 strcpy(buf, "我爱我的祖国");9 return gval;10 }11 int main()12 {(gdb) print gval$1 = 145(gdb) print gval=300$2 = 300(gdb) print gval$3 = 300(gdb) </code></pre><p>注意： print 用于查看变量的数据内容以及可以设置变量的数据，这在我们调试程序的时候非常的实用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB | Linux Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EBPF（Berkeley Packet Filter）学习记录</title>
      <link href="/posts/2ea0.html"/>
      <url>/posts/2ea0.html</url>
      
        <content type="html"><![CDATA[<h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a><strong>相关资料</strong></h2><ul><li><p><a href="https://blog.csdn.net/21cnbao/article/details/95585483" target="_blank" rel="noopener">深入理解 Linux eBPF：阅读清单</a></p></li><li><p><a href="https://github.com/DavadDi/bpf_study" target="_blank" rel="noopener">BPF内核观测技术学习</a></p></li></ul><h2 id="EBPF相关要点介绍"><a href="#EBPF相关要点介绍" class="headerlink" title="EBPF相关要点介绍"></a>EBPF相关要点介绍</h2><h4 id="在内核中的-BPF-代码"><a href="#在内核中的-BPF-代码" class="headerlink" title="在内核中的 BPF 代码"></a>在内核中的 BPF 代码</h4><ul><li><p>文件 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/bpf.h" target="_blank" rel="noopener">linux/include/linux/bpf.h</a>及其相对的 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/bpf.h" target="_blank" rel="noopener">linux/include/uapi/bpf.h</a>包含有关 eBPF 的 <strong>定义</strong>，它们分别用在内核中和用户空间程序的接口。</p><p><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/bpf.h" target="_blank" rel="noopener">linux/include/uapi/bpf.h</a>  bpf虚拟机参数</p></li><li><p>寄存器：</p></li></ul><pre><code>/* Register numbers */enum {        BPF_REG_0 = 0,        BPF_REG_1,        BPF_REG_2,        BPF_REG_3,        BPF_REG_4,        BPF_REG_5,        BPF_REG_6,        BPF_REG_7,        BPF_REG_8,        BPF_REG_9,        BPF_REG_10,        __MAX_BPF_REG,};</code></pre><ul><li>指令格式：</li></ul><pre><code>struct bpf_insn {        __u8        code;                /* opcode */        __u8        dst_reg:4;        /* dest register */        __u8        src_reg:4;        /* source register */        __s16        off;                /* signed offset */        __s32        imm;                /* signed immediate constant */};</code></pre><ul><li>指令宏：</li></ul><pre><code>/* instruction classes */#define BPF_JMP32        0x06        /* jmp mode in word width */#define BPF_ALU64        0x07        /* alu mode in double word width *//* ld/ldx fields */#define BPF_DW                0x18        /* double word (64-bit) */#define BPF_ATOMIC        0xc0        /* atomic memory ops - op type in immediate */#define BPF_XADD        0xc0        /* exclusive add - legacy name *//* alu/jmp fields */#define BPF_MOV                0xb0        /* mov reg to reg */#define BPF_ARSH        0xc0        /* sign extending arithmetic shift right *//* change endianness of a register */#define BPF_END                0xd0        /* flags for endianness conversion: */#define BPF_TO_LE        0x00        /* convert to little-endian */#define BPF_TO_BE        0x08        /* convert to big-endian */#define BPF_FROM_LE        BPF_TO_LE#define BPF_FROM_BE        BPF_TO_BE/* jmp encodings */#define BPF_JNE                0x50        /* jump != */#define BPF_JLT                0xa0        /* LT is unsigned, '&lt;' */#define BPF_JLE                0xb0        /* LE is unsigned, '&lt;=' */#define BPF_JSGT        0x60        /* SGT is signed '&gt;', GT in x86 */#define BPF_JSGE        0x70        /* SGE is signed '&gt;=', GE in x86 */#define BPF_JSLT        0xc0        /* SLT is signed, '&lt;' */#define BPF_JSLE        0xd0        /* SLE is signed, '&lt;=' */#define BPF_CALL        0x80        /* function call */#define BPF_EXIT        0x90        /* function return *//* atomic op type fields (stored in immediate) */#define BPF_FETCH        0x01        /* not an opcode on its own, used to build others */#define BPF_XCHG        (0xe0 | BPF_FETCH)        /* atomic exchange */#define BPF_CMPXCHG        (0xf0 | BPF_FETCH)        /* atomic compare-and-write */</code></pre><ul><li>指令码：</li></ul><p>64-bit</p><p>Opcode 操作码Mnemonic 助记符Pseudocode 伪代码0x07add dst, immdst += imm0x0fadd dst, srcdst += src0x17sub dst, immdst -= imm0x1fsub dst, srcdst -= src0x27mul dst, immdst *= imm0x2fmul dst, srcdst *= src0x37div dst, immdst /= imm0x3fdiv dst, srcdst /= src0x47or dst, immdst |= imm0x4for dst, srcdst |= src0x57and dst, immdst &amp;= imm0x5fand dst, srcdst &amp;= src0x67lsh dst, immdst &lt;&lt;= imm0x6flsh dst, srcdst &lt;&lt;= src0x77rsh dst, immdst &gt;&gt;= imm (logical)0x7frsh dst, srcdst &gt;&gt;= src (logical)0x87neg dstdst = -dst0x97mod dst, immdst %= imm0x9fmod dst, srcdst %= src0xa7xor dst, immdst ^= imm0xafxor dst, srcdst ^= src0xb7mov dst, immdst = imm0xbfmov dst, srcdst = src0xc7arsh dst, immdst &gt;&gt;= imm (arithmetic)0xcfarsh dst, srcdst &gt;&gt;= src (arithmetic)</p><p>32-bit</p><p>这些指令只对low 32位有效，会把high 32位清空</p><p>OpcodeMnemonicPseudocode0x04add32 dst, immdst += imm0x0cadd32 dst, srcdst += src0x14sub32 dst, immdst -= imm0x1csub32 dst, srcdst -= src0x24mul32 dst, immdst *= imm0x2cmul32 dst, srcdst *= src0x34div32 dst, immdst /= imm0x3cdiv32 dst, srcdst /= src0x44or32 dst, immdst |= imm0x4cor32 dst, srcdst |= src0x54and32 dst, immdst &amp;= imm0x5cand32 dst, srcdst &amp;= src0x64lsh32 dst, immdst &lt;&lt;= imm0x6clsh32 dst, srcdst &lt;&lt;= src0x74rsh32 dst, immdst &gt;&gt;= imm (logical)0x7crsh32 dst, srcdst &gt;&gt;= src (logical)0x84neg32 dstdst = -dst0x94mod32 dst, immdst %= imm0x9cmod32 dst, srcdst %= src0xa4xor32 dst, immdst ^= imm0xacxor32 dst, srcdst ^= src0xb4mov32 dst, immdst = imm0xbcmov32 dst, srcdst = src0xc4arsh32 dst, immdst &gt;&gt;= imm (arithmetic)0xccarsh32 dst, srcdst &gt;&gt;= src (arithmetic)</p><p>Byteswap instructions</p><p>无法复制加载中的内容</p><p>Memory Instructions</p><p>无法复制加载中的内容</p><p>Branch Instructions</p><p>无法复制加载中的内容</p><ul><li><p>相同的方式，文件 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/filter.h" target="_blank" rel="noopener">linux/include/linux/filter.h</a>和 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/filter.h" target="_blank" rel="noopener">linux/include/uapi/filter.h</a>包含了用于 <strong>运行 BPF 程序</strong> 的信息。</p><p><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/filter.h" target="_blank" rel="noopener">linux/include/linux/filter.h</a> 内核run bpf程序</p></li><li><p>Bpf_prog_run宏:</p></li></ul><pre><code>#define __BPF_PROG_RUN(prog, ctx, dfunc)        ({                        \        u32 __ret;                                                        \        cant_migrate();                                                        \        if (static_branch_unlikely(&amp;bpf_stats_enabled_key)) {                \                struct bpf_prog_stats *__stats;                                \                u64 __start = sched_clock();                                \                __ret = dfunc(ctx, (prog)-&gt;insnsi, (prog)-&gt;bpf_func);        \                __stats = this_cpu_ptr(prog-&gt;stats);                        \                u64_stats_update_begin(&amp;__stats-&gt;syncp);                \                __stats-&gt;cnt++;                                                \                __stats-&gt;nsecs += sched_clock() - __start;                \                u64_stats_update_end(&amp;__stats-&gt;syncp);                        \        } else {                                                        \                __ret = dfunc(ctx, (prog)-&gt;insnsi, (prog)-&gt;bpf_func);        \        }                                                                \        __ret; })#define BPF_PROG_RUN(prog, ctx)                                                \        __BPF_PROG_RUN(prog, ctx, bpf_dispatcher_nop_func)</code></pre><ul><li>BPF 相关的 <strong>主要的代码片断</strong> 在 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/bpf" target="_blank" rel="noopener">linux/kernel/bpf/</a>目录下面。<strong>系统调用的不同操作许可</strong>，比如，程序加载或者映射管理是在文件 <code>syscall.c</code> 中实现，而 <code>core.c</code> 包含了 <strong>解析器</strong>。其它文件的命名显而易见：<code>verifier.c</code> 包含 <strong>校验器</strong>，<code>arraymap.c</code> 的代码用于与数组类型的 <strong>映射</strong> 交互，等等。</li></ul><p><code>syscall.c</code>：</p><pre><code>static int bpf_prog_load(union bpf_attr *attr, union bpf_attr __user *uattr)SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)</code></pre><ul><li><p>有几个与网络（及 tc、XDP ）相关的函数和 <strong>helpers</strong> 是用户可用，其实现在 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/net/core/filter.c" target="_blank" rel="noopener">linux/net/core/filter.c</a>中。它也包含了移植 cBPF 字节码到 eBPF 的代码（因为在运行之前，内核中的所有的 cBPF 程序被转换成 eBPF）。</p></li><li><p>相关于 <strong>事件跟踪</strong> 的函数和 <strong>helpers</strong> 都在 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/trace/bpf_trace.c" target="_blank" rel="noopener">linux/kernel/trace/bpf_trace.c</a> 中。</p></li></ul><pre><code>/** * trace_call_bpf - invoke BPF program * @call: tracepoint event * @ctx: opaque context pointer * * kprobe handlers execute BPF programs via this helper. * Can be used from static tracepoints in the future. * * Return: BPF programs always return an integer which is interpreted by * kprobe handler as: * 0 - return from kprobe (event is filtered out) * 1 - store kprobe event into ring buffer * Other values are reserved and currently alias to 1 */unsigned int trace_call_bpf(struct trace_event_call *call, void *ctx){        unsigned int ret;        cant_sleep();        if (unlikely(__this_cpu_inc_return(bpf_prog_active) != 1)) {                /*                 * since some bpf program is already running on this cpu,                 * don't call into another bpf program (same or different)                 * and don't send kprobe event into ring-buffer,                 * so return zero here                 */                ret = 0;                goto out;        }        /*         * Instead of moving rcu_read_lock/rcu_dereference/rcu_read_unlock         * to all call sites, we did a bpf_prog_array_valid() there to check         * whether call-&gt;prog_array is empty or not, which is         * a heuristic to speed up execution.         *         * If bpf_prog_array_valid() fetched prog_array was         * non-NULL, we go into trace_call_bpf() and do the actual         * proper rcu_dereference() under RCU lock.         * If it turns out that prog_array is NULL then, we bail out.         * For the opposite, if the bpf_prog_array_valid() fetched pointer         * was NULL, you'll skip the prog_array with the risk of missing         * out of events when it was updated in between this and the         * rcu_dereference() which is accepted risk.         */        ret = BPF_PROG_RUN_ARRAY_CHECK(call-&gt;prog_array, ctx, BPF_PROG_RUN); out:        __this_cpu_dec(bpf_prog_active);        return ret;}bpf_tracing_func_proto(enum bpf_func_id func_id, const struct bpf_prog *prog)</code></pre><ul><li><p><strong>JIT 编译器</strong> 在它们各自的架构目录下面，比如，x86 架构的在 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/arch/x86/net/bpf_jit_comp.c" target="_blank" rel="noopener">linux/arch/x86/net/bpf</a><em><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/arch/x86/net/bpf_jit_comp.c" target="_blank" rel="noopener">jit</a></em><a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/arch/x86/net/bpf_jit_comp.c" target="_blank" rel="noopener">comp.c</a>中。例外是用于硬件卸载的 JIT 编译器，它们放在它们的驱动程序下，例如 Netronome NFP 网卡的就放在 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/drivers/net/ethernet/netronome/nfp/bpf/jit.c" target="_blank" rel="noopener">linux/drivers/net/ethernet/netronome/nfp/bpf/jit.c</a> 。</p></li><li><p>在 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/net/sched" target="_blank" rel="noopener">linux/net/sched/</a>目录下，你可以找到 <strong>tc 的 BPF 组件</strong> 相关的代码，尤其是在文件 <code>act_bpf.c</code> （action）和 <code>cls_bpf.c</code>（filter）中。</p></li><li><p>我并没有在 BPF 上深入到 <strong>事件跟踪</strong> 中，因此，我并不真正了解这些程序的钩子。在 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/trace/bpf_trace.c" target="_blank" rel="noopener">linux/kernel/trace/bpf_trace.c</a>那里有一些东西。如果你对它感兴趣，并且想去了解更多，你可以在 Brendan Gregg 的演示或者博客文章上去深入挖掘。</p></li><li><p>我也没有使用过 <strong>seccomp-BPF</strong>，不过你能在 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/seccomp.c" target="_blank" rel="noopener">linux/kernel/seccomp.c</a>找到它的代码，并且可以在 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/tools/testing/selftests/seccomp/seccomp_bpf.c" target="_blank" rel="noopener">linux/tools/testing/selftests/seccomp/seccomp_bpf.c</a>中找到一些它的使用示例。</p></li></ul><h4 id="XDP-钩子代码"><a href="#XDP-钩子代码" class="headerlink" title="XDP 钩子代码"></a>XDP 钩子代码</h4><p>一旦装载进内核的 BPF 虚拟机，由一个 Netlink 命令将 <strong>XDP</strong> 程序从用户空间钩入到内核网络路径中。接收它的是在 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/net/core/dev.c" target="_blank" rel="noopener">linux/net/core/dev.c</a> 文件中的 <code>dev_change_xdp_fd()</code> 函数，它被调用并设置一个 XDP 钩子。钩子被放在支持的网卡的驱动程序中。例如，用于 Netronome 硬件钩子的 ntp 驱动程序实现放在 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/drivers/net/ethernet/netronome/nfp/" target="_blank" rel="noopener">drivers/net/ethernet/netronome/nfp/</a> 中。文件 <code>nfp_net_common.c</code> 接受 Netlink 命令，并调用 <code>nfp_net_xdp_setup()</code>，它会转而调用 <code>nfp_net_xdp_setup_drv()</code> 实例来安装该程序。</p><h4 id="在-bcc-中的-BPF-逻辑"><a href="#在-bcc-中的-BPF-逻辑" class="headerlink" title="在 bcc 中的 BPF 逻辑"></a>在 bcc 中的 BPF 逻辑</h4><p><a href="https://github.com/iovisor/bcc/" target="_blank" rel="noopener">在 bcc 的 GitHub 仓库</a>能找到的 <strong>bcc</strong> 工具集的代码。其 <strong>Python 代码</strong>，包含在 <code>BPF</code> 类中，最初它在文件 <a href="https://github.com/iovisor/bcc/blob/master/src/python/bcc/__init__.py" target="_blank" rel="noopener">bcc/src/python/bcc/<strong>init</strong>.py</a> 中。但是许多我觉得有意思的东西，比如，加载 BPF 程序到内核中，出现在 <a href="https://github.com/iovisor/bcc/blob/master/src/cc/libbpf.c" target="_blank" rel="noopener">libbcc 的 C 库</a>中。</p><h4 id="使用-tc-去管理-BPF-的代码"><a href="#使用-tc-去管理-BPF-的代码" class="headerlink" title="使用 tc 去管理 BPF 的代码"></a>使用 tc 去管理 BPF 的代码</h4><p>当然，这些代码与 iproute2 包中的 <strong>tc 中的</strong> BPF 相关。其中的一些在 <a href="https://git.kernel.org/cgit/linux/kernel/git/shemminger/iproute2.git/tree/tc" target="_blank" rel="noopener">iproute2/tc/</a> 目录中。文件 <code>f_bpf.c</code> 和 <code>m_bpf.c</code>（和 <code>e_bpf.c</code>）各自用于处理 BPF 的过滤器和动作的（和 tc <code>exec</code> 命令，等等）。文件 <code>q_clsact.c</code> 定义了为 BPF 特别创建的 <code>clsact</code> qdisc。但是，<strong>大多数的 BPF 用户空间逻辑</strong> 是在 <a href="https://git.kernel.org/cgit/linux/kernel/git/shemminger/iproute2.git/tree/lib/bpf.c" target="_blank" rel="noopener">iproute2/lib/bpf.c</a>库中实现的，因此，如果你想去使用 BPF 和 tc，这里可能是会将你搞混乱的地方（它是从文件 iproute2/tc/tc_bpf.c 中移动而来的，你也可以在旧版本的包中找到相同的代码）。</p><h4 id="BPF-实用工具"><a href="#BPF-实用工具" class="headerlink" title="BPF 实用工具"></a>BPF 实用工具</h4><p>内核中也带有 BPF 相关的三个工具的源代码（<code>bpf_asm.c</code>、 <code>bpf_dbg.c</code>、 <code>bpf_jit_disasm.c</code>），根据你的版本不同，在 <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/tools/net" target="_blank" rel="noopener">linux/tools/net/</a>（直到 Linux 4.14）或者 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next.git/tree/tools/bpf" target="_blank" rel="noopener">linux/tools/bpf/</a>目录下面：</p><ul><li><p><code>bpf_asm</code> 是一个极小的 cBPF 汇编程序。</p></li><li><p><code>bpf_dbg</code> 是一个很小的 cBPF 程序调试器。</p></li><li><p><code>bpf_jit_disasm</code> 对于两种 BPF 都是通用的，并且对于 JIT 调试来说非常有用。</p></li><li><p><code>bpftool</code> 是由 Jakub Kicinski 写的通用工具，它可以与 eBPF 程序交互并从用户空间的映射，例如，去展示、转储、pin 程序、或者去展示、创建、pin、更新、删除映射。</p></li></ul><p>阅读在源文件顶部的注释可以得到一个它们使用方法的概述。</p><p>与 eBPF 一起工作的其它必需的文件是来自内核树的两个<strong>用户空间库</strong>，它们可以用于管理 eBPF 程序或者映射来自外部的程序。这个函数可以通过 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next.git/tree/tools/lib/bpf" target="_blank" rel="noopener">linux/tools/lib/bpf/</a>[145] 目录中的头文件 <code>bpf.h</code> 和 <code>libbpf.h</code>（更高层面封装）来访问。比如，工具 <code>bpftool</code> 主要依赖这些库。</p><h4 id="eBPF程序类型"><a href="#eBPF程序类型" class="headerlink" title="eBPF程序类型"></a>eBPF程序类型</h4><p>加载BPF_PROG_LOAD的程序的类型决定了四件事：可以在何处附加程序，可以调用验证程序的内核内辅助函数，是否可以直接访问网络数据包数据，以及作为第一个传递的对象的类型该程序的参数。实际上，程序类型本质上定义了一个API。甚至纯粹是创建新程序类型来区分允许的可调用函数的不同列表（例如，BPF_PROG_TYPE_CGROUP_SKB与 BPF_PROG_TYPE_SOCKET_FILTER）。</p><p>内核支持的当前eBPF程序类型集为：</p><ul><li><p>BPF_PROG_TYPE_SOCKET_FILTER：网络数据包过滤器</p></li><li><p>BPF_PROG_TYPE_KPROBE：确定是否应触发kprobe</p></li><li><p>BPF_PROG_TYPE_SCHED_CLS：网络流量控制分类器</p></li><li><p>BPF_PROG_TYPE_SCHED_ACT：网络流量控制操作</p></li><li><p>BPF_PROG_TYPE_TRACEPOINT：确定是否应触发跟踪点</p></li><li><p>BPF_PROG_TYPE_XDP：从设备驱动程序接收路径运行的网络数据包筛选器</p></li><li><p>BPF_PROG_TYPE_PERF_EVENT：确定是否应该触发性能事件处理程序</p></li><li><p>BPF_PROG_TYPE_CGROUP_SKB：用于控制组的网络数据包过滤器</p></li><li><p>BPF_PROG_TYPE_CGROUP_SOCK：用于控制组的网络数据包筛选器，允许修改套接字选项</p></li><li><p>BPF_PROG_TYPE_LWT_ *：用于轻型隧道的网络数据包过滤器</p></li><li><p>BPF_PROG_TYPE_SOCK_OPS：用于设置套接字参数的程序</p></li><li><p>BPF_PROG_TYPE_SK_SKB：网络数据包过滤器，用于在套接字之间转发数据包</p></li><li><p>BPF_PROG_CGROUP_DEVICE：确定是否应该允许设备操作</p></li></ul><p>随着添加了新的程序类型，内核开发人员也发现也需要添加新的数据结构。</p><h4 id="eBPF数据结构"><a href="#eBPF数据结构" class="headerlink" title="eBPF数据结构"></a>eBPF数据结构</h4><p>eBPF程序使用的主要数据结构是eBPF映射，eBPF映射是一种通用数据结构，它允许在内核内或内核与用户空间之间来回传递数据。顾名思义，“map”使用键存储和检索数据。</p><p>使用bpf（）系统调用创建和处理map。成功创建映射后，将返回与该映射关联的文件描述符。通常，通过关闭关联的文件描述符来销毁map。每个映射由四个值定义：类型，最大元素数，值大小（以字节为单位）和键大小（以字节为单位）。有不同的map类型，每种map类型提供不同的行为和权衡方案：</p><ul><li><p>BPF_MAP_TYPE_HASH：哈希表</p></li><li><p>BPF_MAP_TYPE_ARRAY：数组映射，已针对快速查找速度进行了优化，通常用于计数器</p></li><li><p>BPF_MAP_TYPE_PROG_ARRAY：对应于eBPF程序的文件描述符数组；用于实现跳转表和子程序以处理特定的数据包协议</p></li><li><p>BPF_MAP_TYPE_PERCPU_ARRAY：每个CPU的阵列，用于实现延迟的直方图</p></li><li><p>BPF_MAP_TYPE_PERF_EVENT_ARRAY：存储指向struct perf_event的指针，用于读取和存储perf事件计数器</p></li><li><p>BPF_MAP_TYPE_CGROUP_ARRAY：存储指向控制组的指针</p></li><li><p>BPF_MAP_TYPE_PERCPU_HASH：每个CPU的哈希表</p></li><li><p>BPF_MAP_TYPE_LRU_HASH：仅保留最近使用项目的哈希表</p></li><li><p>BPF_MAP_TYPE_LRU_PERCPU_HASH：每个CPU的哈希表，仅保留最近使用的项目</p></li><li><p>BPF_MAP_TYPE_LPM_TRIE：最长前缀匹配树，适用于将IP地址匹配到某个范围</p></li><li><p>BPF_MAP_TYPE_STACK_TRACE：存储堆栈跟踪</p></li><li><p>BPF_MAP_TYPE_ARRAY_OF_MAPS：map中map数据结构</p></li><li><p>BPF_MAP_TYPE_HASH_OF_MAPS：map中map数据结构</p></li><li><p>BPF_MAP_TYPE_DEVICE_MAP：用于存储和查找网络设备引用</p></li><li><p>BPF_MAP_TYPE_SOCKET_MAP：存储和查找套接字，并允许使用BPF帮助函数进行套接字重定向</p></li></ul><p>可以使用bpf_map_lookup_elem（）和 bpf_map_update_elem（）函数从eBPF或用户空间程序访问所有map 。某些映射类型（例如套接字映射）可以与执行特殊任务的其他eBPF帮助器功能一起使用。</p><h4 id="如何编写eBPF程序"><a href="#如何编写eBPF程序" class="headerlink" title="如何编写eBPF程序"></a>如何编写eBPF程序</h4><p>从历史上看，有必要手动编写eBPF汇编并使用内核的bpf_asm汇编器生成BPF字节码。幸运的是，LLVM Clang编译器已经增加了对eBPF后端的支持，该后端将C编译为字节码。然后可以使用bpf（）系统调用和 BPF_PROG_LOAD命令直接加载包含该字节码的目标文件。</p><p>您可以使用-march = bpf参数与Clang一起编译，从而用C编写自己的eBPF程序。内核的<a href="http://elixir.free-electrons.com/linux/v4.14.2/source/samples/bpf" target="_blank" rel="noopener">samples / bpf /</a> 目录中有许多eBPF程序示例；大多数文件名的后缀为“ _kern.c ”。Clang发出的目标文件（eBPF字节码）需要由计算机上本地运行的程序加载（这些示例的文件名通常带有“ _user.c ”）。为了使编写eBPF程序更容易，内核提供了libbpf库，该库包括用于加载程序以及创建和操作eBPF对象的帮助程序函数。例如，使用libbpf的eBPF程序和用户程序的高级流程 可能会像这样：</p><ul><li><p>将eBPF字节码读取到用户应用程序的缓冲区中，并将其传递给bpf_load_program（）。</p></li><li><p>eBPF程序在由内核运行时，将调用 bpf_map_lookup_elem（）在地图中查找元素并将其存储新值。</p></li><li><p>用户应用程序调用bpf_map_lookup_elem（）来读取eBPF程序存储在内核中的值。</p></li></ul><p>但是，所有示例代码都有一个主要缺点：您需要从内核源代码树中编译eBPF程序。幸运的是，创建了BCC项目来解决此问题。它包括一个完整的工具链，用于编写eBPF程序并加载它们，而无需链接内核源代码树。</p><h2 id="《BPF内核观测技术》笔录"><a href="#《BPF内核观测技术》笔录" class="headerlink" title="《BPF内核观测技术》笔录"></a>《BPF内核观测技术》笔录</h2><h3 id="BPF跟踪"><a href="#BPF跟踪" class="headerlink" title="BPF跟踪"></a>BPF跟踪</h3><h4 id="探针"><a href="#探针" class="headerlink" title="探针"></a>探针</h4><p>内核探针：提供内核中内部组件的动态访问</p><p>跟踪点：提供内核中内部组件的静态访问</p><p>用户空间探针：提供用户空间运行的程序的动态访问</p><p>用户静态定义跟踪点：提供用户空间运行的程序的静态访问</p><h5 id="内核探针"><a href="#内核探针" class="headerlink" title="内核探针"></a>内核探针</h5><p>kprobes–允许执行任何内核指令之前插入BPF程序</p><p>kretprobes–在内核指令有返回值时插入BPF程序</p><p>kprobes 探针在内核函数入口被调用，示例程序如下：</p><pre><code>from bcc import BPF bpf_source = """ #include &lt;uapi/linux/ptrace.h&gt;                                                                                                                                               int do_sys_execve(struct pt_regs *ctx) {  char comm[16];  bpf_get_current_comm(&amp;comm, sizeof(comm));  bpf_trace_printk("executing program: %s\\n", comm);  return 0;}"""bpf = BPF(text=bpf_source)execve_function = bpf.get_syscall_fnname("execve")bpf.attach_kprobe(event=execve_function, fn_name="do_sys_execve")bpf.trace_print() [longyu@debian-10:17:12:19] kprobes $ sudo python example.py [sudo] longyu 的密码：           guake-21900 [003] .... 19913.271490: 0: executing program: guake           guake-21901 [001] .... 19913.273462: 0: executing program: guake            bash-21902 [000] .... 19913.274109: 0: executing program: bash            bash-21903 [005] .... 19913.277194: 0: executing program: bash            bash-21906 [002] .... 19913.279022: 0: executing </code></pre><p>kretprobes 探测点在内核函数返回的时候被调用，示例程序如下：</p><pre><code>from bcc import BPFbpf_source = """#include &lt;uapi/linux/ptrace.h&gt;int ret_sys_execve(struct pt_regs *ctx) {  int return_value;  char comm[16];  bpf_get_current_comm(&amp;comm, sizeof(comm));  return_value = PT_REGS_RC(ctx);  bpf_trace_printk("program: %s, return: %d\\n", comm, return_value);  return 0;}"""bpf = BPF(text=bpf_source)execve_function = bpf.get_syscall_fnname("execve")bpf.attach_kretprobe(event=execve_function, fn_name="ret_sys_execve")bpf.trace_print()[longyu@debian-10:17:15:35] kretprobes $ sudo python example.py             bash-22471 [007] d... 20099.730870: 0: program: bash, return: 0              id-22472 [005] d... 20099.732045: 0: program: id, return: 0        utempter-22473 [004] d... 20099.732546: 0: program: utempter, return: 0       dircolors-22474 [005] d... 20099.733757: 0: program: dircolors, return: 0       dircolors-22475 [005] d... 20099.735221: 0: program: dircolors, return: 0             lua-22476 [005] d... 20099.736689: 0: program: lua, return: 0</code></pre><h5 id="跟踪点"><a href="#跟踪点" class="headerlink" title="跟踪点"></a>跟踪点</h5><p>tracepoints 跟踪点是内核代码的静态标记，用于将代码附加到运行内核中，它由内核开发人员在内核中编写与修改，内核探针与跟踪点都提供了在用户空间的完全访问</p><p>查看 <strong>/sys/kernel/debug/tracing/events</strong> 目录下的内容可以获取系统中所有可用的跟踪点。</p><h5 id="用户空间探针"><a href="#用户空间探针" class="headerlink" title="用户空间探针"></a>用户空间探针</h5><p>uprobes–内核在程序特定指令执行之前插入该指令集的钩子</p><p>uretprobes–与kretprobes并行探针，适用于用户空间使用，在将bpf程序附加到指令返回值之上，允许通过bpf代码从寄存器中访问返回值</p><p>一个示例 patch 内容如下：</p><pre><code>diff --git a/code/chapter-4/uprobes/example.py b/code/chapter-4/uprobes/example.pyold mode 100644new mode 100755index 4f2c76f..c0a93de--- a/code/chapter-4/uprobes/example.py+++ b/code/chapter-4/uprobes/example.py@@ -9,5 +9,5 @@ int trace_go_main(struct pt_regs *ctx) { """ bpf = BPF(text = bpf_source)-bpf.attach_uprobe(name = "hello-bpf", sym = "main.main", fn_name = "trace_go_main")+bpf.attach_uprobe(name = "/home/longyu/linux-observability-with-bpf/code/chapter-4/uprobes/hello-bpf", sym = "main.main", fn_name = "trace_go_main") bpf.trace_print()[longyu@debian-10:17:52:59] uprobes $ sudo python ./example.py        hello-bpf-25911 [005] .... 22341.336969: 0: New hello-bpf process running with PID: 25911       hello-bpf-25927 [001] .... 22354.651541: 0: New hello-bpf process running with PID: 25927</code></pre><h5 id="用户静态定义跟踪点"><a href="#用户静态定义跟踪点" class="headerlink" title="用户静态定义跟踪点"></a>用户静态定义跟踪点</h5><p>USDT为用户应用程序提供静态跟踪点，是检测应用程序的便捷方法</p><p>USDT 是用户态程序静态定义的跟踪点，类似于内核中的 tracepoint，它需要在程序的源代码中添加代码</p><p>示例 demo 源码如下：</p><pre><code>#include &lt;sys/sdt.h&gt;int main(int argc, char const *argv[]) {    DTRACE_PROBE("hello-usdt", "probe-main");    return 0;}</code></pre><p>直接编译，发现会报 sys/sdt.h 头文件不存在的问题。可以通过执行如下命令来解决：</p><pre><code>sudo apt-get install systemtap-sdt-dev</code></pre><p>修改 example.py 后执行有如下信息：</p><pre><code>[longyu@debian-10:18:36:53] usdt $ sudo python example.py /virtual/main.c:7:1: warning: control reaches end of non-void function [-Wreturn-type]}^1 warning generated. </code></pre><h4 id="跟踪数据可视化"><a href="#跟踪数据可视化" class="headerlink" title="跟踪数据可视化"></a>跟踪数据可视化</h4><h5 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h5><p>对系统耗时进行可视化的图表</p><h5 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h5><h5 id="Perf事件"><a href="#Perf事件" class="headerlink" title="Perf事件"></a>Perf事件</h5><p>Perf事件的数组映射，允许将数据放入环形缓存区，以便实现用户空间实时同步</p><h3 id="BPF运行时的体系架构"><a href="#BPF运行时的体系架构" class="headerlink" title="BPF运行时的体系架构"></a>BPF运行时的体系架构</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODdiMGE4N2Y3Y2E2ZmVhM2JhYjI4OGMzNTVmZGFmZjVfTEJGV041Wkw5cG1kMWU3bmdXOVlKSUpyS0ljazVkT3lfVG9rZW46Ym94Y241UEIyTUczRDhlOU03dGJwdFIwbmdoXzE2MjcxNDg3NzA6MTYyNzE1MjM3MF9WNA" alt="img"></p><h3 id="BPF-API"><a href="#BPF-API" class="headerlink" title="BPF API"></a>BPF API</h3><p>include/uapi/linux/bpf.h</p><h4 id="Some-Graph"><a href="#Some-Graph" class="headerlink" title="Some Graph"></a>Some Graph</h4><h5 id="BPF-helper-function："><a href="#BPF-helper-function：" class="headerlink" title="BPF helper function："></a>BPF helper function：</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjMyODNmMjU0N2VjOWZlZTU3ZGI5NzQyNmJkMjYwNWVfUjRUUDFGZmFscklZMUxET0hUWGN3UkF3bnBlaUJRa1hfVG9rZW46Ym94Y25KY1c4WnVjUlA0d084VVYwdGJkbkpjXzE2MjcxNDg3NzA6MTYyNzE1MjM3MF9WNA" alt="img"></p><h5 id="BPF-Syscall"><a href="#BPF-Syscall" class="headerlink" title="BPF Syscall"></a>BPF Syscall</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzliOTkzNGQwN2M2ZDg0MmZiODlmYjc1ODg3MjgzMmNfaWowVURLQnlpMlAwbUFsek5uZDF3TTZrc21uWlFwMlZfVG9rZW46Ym94Y25KQ2pNUkh2RXBZT1RWeTR3c1Z5dnpmXzE2MjcxNDg3NzA6MTYyNzE1MjM3MF9WNA" alt="img"></p><p>BPF tracing program types</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODFmN2ZlZmY4NmE5OGFiNDM1YTc3MWEwYzk4YmRlY2RfWWd1QnZmR2xMTXZHN3hZaUNtSFJCN1h1b2dxdDAyWDNfVG9rZW46Ym94Y25zTm5jakRsU0M1ODdFZWNjbXl6TXloXzE2MjcxNDg3NzA6MTYyNzE1MjM3MF9WNA" alt="img"></p><p>注：BPF Type Format (BTF)</p><h2 id="EBPF程序运行流程案例分析"><a href="#EBPF程序运行流程案例分析" class="headerlink" title="EBPF程序运行流程案例分析"></a>EBPF程序运行流程案例分析</h2><h3 id="EBPF程序运行"><a href="#EBPF程序运行" class="headerlink" title="EBPF程序运行"></a>EBPF程序运行</h3><p>eBPF 在 Linux 内核中将 C 代码编译成 BPF 字节码，挂在 <code>kprobe/tracepoint</code> 等 hook 上，当 <code>hook</code> 触发时，Linux 内核运行字节码来追踪性能。</p><h3 id="EBPF框架"><a href="#EBPF框架" class="headerlink" title="EBPF框架"></a>EBPF框架</h3><p>在 Linux 内核中的 <code>sample/bpf</code> 目录存在许多 bpf 程序的样例，以 <code>tracex4_kern.c</code> 和 <code>tracex4_user.c</code> 为例。</p><p>下图是 eBPF 程序的框架，分为程序执行流和数据通信流。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGY3YzBlMWFhZmUyOWNiZjM0Y2FiOTg3N2FiNDc3OWRfeTByZVc1eDFERjBuUVp2b2pocXFmV21kVGdrb0VhZ3NfVG9rZW46Ym94Y25pWHhrazBSdk1vamtZUXFGVzRpMDRlXzE2MjcxNDg3NzA6MTYyNzE1MjM3MF9WNA" alt="img"></p><p>对于程序执行流来说，</p><ul><li><p><code>trace_kern.c</code> 是分配 slab，释放 slab 时调用的代码，其中申明了 hook 处理函数和数据 map，数据 map 用于内核态和用户态之间的数据通信，使用 LLVM/clang 编译器编译成 bpf 字节码</p></li><li><p><code>trace_user.c</code> 用来加载 bpf 字节码，陷入内核态，通过 JIT(just in time) 编译器将 bpf 字节码转换成机器汇编码，当 kprobe 或 tracepoint 追踪到某类事件时执行上述申明的 hook 处理函数并获取数据 map，将数据传到 userspace</p></li></ul><h4 id="tracex4-kern-c"><a href="#tracex4-kern-c" class="headerlink" title="tracex4_kern.c"></a>tracex4_kern.c</h4><p>其中定义了 “my_map” 的一个数据 map，数据 map 由 <code>key/value</code> 键值对组成，这里的 value 是一个结构体的变量，用于获得当前运行时间和 ip 寄存器，数据 map 由<code>__attribute__</code> 声明，是一个单独的 section，编译成 ELF 格式的文件时该结构体变量存在 “maps” 段中。</p><p>接下来申明的是分配 slab（内存分配），释放 slab 的钩子处理函数，并单独放在 <code>kprobe/kmem_cache_free</code>，<code>kretprobe/kmem_cache_alloc_node</code> 两个代码段中。</p><pre><code>#include &lt;linux/version.h&gt;#include &lt;uapi/linux/bpf.h&gt;#include "bpf_helpers.h"struct pair {        u64 val;        u64 ip;};struct bpf_map_def SEC("maps") my_map = {        .type = BPF_MAP_TYPE_HASH,        .key_size = sizeof(long),        .value_size = sizeof(struct pair),        .max_entries = 1000000,};SEC("kprobe/kmem_cache_free")int bpf_prog1(struct pt_regs *ctx){        long ptr = PT_REGS_PARM2(ctx);        bpf_map_delete_elem(&amp;my_map, &amp;ptr);        return 0;}SEC("kretprobe/kmem_cache_alloc_node")int bpf_prog2(struct pt_regs *ctx){        long ptr = PT_REGS_RC(ctx);        long ip = 0;        /* get ip address of kmem_cache_alloc_node() caller */        BPF_KRETPROBE_READ_RET_IP(ip, ctx);        struct pair v = {                .val = bpf_ktime_get_ns(),                .ip = ip,        };        bpf_map_update_elem(&amp;my_map, &amp;ptr, &amp;v, BPF_ANY);        return 0;}char _license[] SEC("license") = "GPL";u32 _version SEC("version") = LINUX_VERSION_CODE;</code></pre><p>使用 clang 编译出 <code>.o</code> 文件，同样属于 ELF 文件，可以使用 llvm dump 出各个 section table，如上述自定义的几个段，用 <code>SEC</code> 就可自定义一个 section：</p><pre><code>#define SEC(NAME) __attribute__((section(NAME), used))</code></pre><h4 id="tracex4-user-c"><a href="#tracex4-user-c" class="headerlink" title="tracex4_user.c"></a>tracex4_user.c</h4><p>其中定义了一个 pair 结构体用来接受 hook 处理函数的数据，首先加载 <code>tracex4_kern.o</code>，然后在死循环中轮询获取数据，然后用 <code>printf</code> 打印出来：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;stdbool.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;linux/bpf.h&gt;#include &lt;sys/resource.h&gt;#include &lt;bpf/bpf.h&gt;#include "bpf_load.h"struct pair {        long long val;        __u64 ip;};static __u64 time_get_ns(void){        struct timespec ts;        clock_gettime(CLOCK_MONOTONIC, &amp;ts);        return ts.tv_sec * 1000000000ull + ts.tv_nsec;}static void print_old_objects(int fd){        long long val = time_get_ns();        __u64 key, next_key;        struct pair v;        key = write(1, "\e[1;1H\e[2J", 12); /* clear screen */        key = -1;        while (bpf_map_get_next_key(map_fd[0], &amp;key, &amp;next_key) == 0) {                bpf_map_lookup_elem(map_fd[0], &amp;next_key, &amp;v);                key = next_key;                if (val - v.val &lt; 1000000000ll)                        /* object was allocated more then 1 sec ago */                        continue;                printf("obj 0x%llx is %2lldsec old was allocated at ip %llx\n",                       next_key, (val - v.val) / 1000000000ll, v.ip);        }}int main(int ac, char **argv){        struct rlimit r = {RLIM_INFINITY, RLIM_INFINITY};        char filename[256];        int i;        snprintf(filename, sizeof(filename), "%s_kern.o", argv[0]);        if (setrlimit(RLIMIT_MEMLOCK, &amp;r)) {                perror("setrlimit(RLIMIT_MEMLOCK, RLIM_INFINITY)");                return 1;        }        if (load_bpf_file(filename)) {                printf("%s", bpf_log_buf);                return 1;        }        for (i = 0; ; i++) {                print_old_objects(map_fd[1]);                sleep(1);        }}</code></pre><h4 id="通过-readelf-和-llvm-objdump-解析目标文件"><a href="#通过-readelf-和-llvm-objdump-解析目标文件" class="headerlink" title="通过 readelf 和 llvm-objdump 解析目标文件"></a>通过 readelf 和 llvm-objdump 解析目标文件</h4><h5 id="读取-ELF-文件头"><a href="#读取-ELF-文件头" class="headerlink" title="读取 ELF 文件头"></a>读取 ELF 文件头</h5><pre><code>wu@ubuntu:~/linux/samples/bpf$ readelf -h tracex4_kern.oELF Header:  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  Class:                             ELF64  Data:                              2's complement, little endianVersion: 1 (current)OS/ABI: UNIX - System VABI Version: 0Type: REL (Relocatable file)Machine: Linux BPFVersion: 0x1Entry point address: 0x0Start of program headers: 0 (bytes into file)Start of section headers: 8344 (bytes into file)Flags: 0x0Size of this header: 64 (bytes)Size of program headers: 0 (bytes)Number of program headers: 0Size of section headers: 64 (bytes)Number of section headers: 27Section header string table index: 1</code></pre><p>在 readelf 的输出中：</p><p>第 1 行，ELF Header: 指名 ELF 文件头开始。 第 2 行，Magic 魔数，用来指名该文件是一个 ELF 目标文件。第一个字节 7F 是个固定的数；后面的 3 个字节正是 E, L, F 三个字母的 ASCII 形式。 第 3 行，CLASS 表示文件类型，这里是 64位的 ELF 格式。 第 4 行，Data 表示文件中的数据是按照什么格式组织(大端或小端)的，不同处理器平台数据组织格式可能就不同，如x86平台为小端存储格式。 第 5 行，当前 ELF 文件头版本号，这里版本号为 1 。 第 6 行，OS/ABI ，指出操作系统类型，ABI 是 Application Binary Interface 的缩写。 第 7 行，ABI 版本号，当前为 0 。 第 8 行，Type 表示文件类型。ELF 文件有 3 种类型，一种是如上所示的 Relocatable file 可重定位目标文件，一种是可执行文件(Executable)，另外一种是共享库(Shared Library) 。 第 9 行，机器平台类型。 这里是bpf虚拟机 第 10 行，当前目标文件的版本号。 第 11 行，程序的虚拟地址入口点，因为这还不是可运行的程序，故而这里为零。 第 12 行，与 11 行同理，这个目标文件没有 Program Headers。 第 13 行，sections 头开始处，这里 8344 是十进制，表示从地址偏移 0x2098 处开始。 第 14 行，是一个与处理器相关联的标志，x86 平台上该处为 0 。 第 15 行，ELF 文件头的字节数。 第 16 行，因为这个不是可执行程序，故此处大小为 0 第 19 行，一共有多少个 section 头，这里是 27个。</p><h5 id="打印各个段的内容"><a href="#打印各个段的内容" class="headerlink" title="打印各个段的内容"></a>打印各个段的内容</h5><pre><code>wu@ubuntu:~/linux/samples/bpf$ readelf -S tracex4_kern.oThere are 27 section headers, starting at offset 0x2098:Section Headers:  [Nr] Name                 Type                  Address            Offset       Size                 EntSize          Flags  Link  Info  Align  [ 0]                         NULL                  0000000000000000  00000000       0000000000000000  0000000000000000            0          0        0  [ 1] .strtab                 STRTAB           0000000000000000  00001f80       0000000000000115  0000000000000000            0          0        1  [ 2] .text                 PROGBITS          0000000000000000  00000040       0000000000000000  0000000000000000  AX            0          0        4  [ 3] kprobe/kmem_cache PROGBITS          0000000000000000  00000040       0000000000000048  0000000000000000  AX            0          0        8  [ 4] .relkprobe/kmem_c REL                  0000000000000000  00001870       0000000000000010  0000000000000010           26          3        8  [ 5] kretprobe/kmem_ca PROGBITS          0000000000000000  00000088       00000000000000c0  0000000000000000  AX            0          0        8  [ 6] .relkretprobe/kme REL                  0000000000000000  00001880       0000000000000010  0000000000000010           26          5        8  [ 7] maps                 PROGBITS          0000000000000000  00000148       000000000000001c  0000000000000000  WA            0          0        4  [ 8] license                 PROGBITS          0000000000000000  00000164       0000000000000004  0000000000000000  WA            0          0        1  [ 9] version                 PROGBITS          0000000000000000  00000168       0000000000000004  0000000000000000  WA            0          0        4  [10] .debug_str         PROGBITS          0000000000000000  0000016c       00000000000001e9  0000000000000001  MS            0          0        1  [11] .debug_loc         PROGBITS          0000000000000000  00000355       0000000000000150  0000000000000000            0          0        1  [12] .rel.debug_loc         REL                  0000000000000000  00001890       0000000000000050  0000000000000010           26         11        8  [13] .debug_abbrev         PROGBITS          0000000000000000  000004a5       0000000000000101  0000000000000000            0          0        1  [14] .debug_info         PROGBITS          0000000000000000  000005a6       0000000000000376  0000000000000000            0          0        1  [15] .rel.debug_info         REL                  0000000000000000  000018e0       00000000000004b0  0000000000000010           26         14        8  [16] .debug_ranges         PROGBITS          0000000000000000  0000091c       0000000000000030  0000000000000000            0          0        1  [17] .rel.debug_ranges REL                  0000000000000000  00001d90       0000000000000040  0000000000000010           26         16        8  [18] .BTF                 PROGBITS          0000000000000000  0000094c       0000000000000569  0000000000000000            0          0        1  [19] .rel.BTF          REL                  0000000000000000  00001dd0       0000000000000030  0000000000000010           26         18        8  [20] .BTF.ext          PROGBITS          0000000000000000  00000eb5       0000000000000178  0000000000000000            0          0        1  [21] .rel.BTF.ext         REL                  0000000000000000  00001e00       0000000000000140  0000000000000010           26         20        8  [22] .eh_frame         PROGBITS          0000000000000000  00001030       0000000000000050  0000000000000000   A            0          0        8  [23] .rel.eh_frame         REL                  0000000000000000  00001f40       0000000000000020  0000000000000010           26         22        8  [24] .debug_line         PROGBITS          0000000000000000  00001080       0000000000000147  0000000000000000            0          0        1  [25] .rel.debug_line         REL                  0000000000000000  00001f60       0000000000000020  0000000000000010           26         24        8  [26] .symtab                 SYMTAB           0000000000000000  000011c8       00000000000006a8  0000000000000018            1         66        8</code></pre><p>其中，第三列代表类型（Type）：</p><ul><li><p>”NULL”：未使用，如段表的第一个空段</p></li><li><p>“PROGBITS”：程序数据，如 .text、.data、.rodata;</p></li><li><p>“REL”：重定位表，如 .rel.text;</p></li><li><p>“NOBITS”：暂时没有数据的程序空间，如 .bss;</p></li><li><p>“STRTAB”：字符串表，如 .strtab、.shstrtab;</p></li><li><p>“SYMTAB”：符号表，如 .symtab，包括所有用到的相关符号信息，如函数名、变量名。</p></li></ul><h5 id="通过-llvm-objdump-解析-BPF-ELF-格式文件"><a href="#通过-llvm-objdump-解析-BPF-ELF-格式文件" class="headerlink" title="通过 llvm-objdump 解析 BPF ELF 格式文件"></a>通过 llvm-objdump 解析 BPF ELF 格式文件</h5><pre><code>wu@ubuntu:~/linux/samples/bpf$ llvm-objdump -h tracex4_kern.otracex4_kern.o: file format ELF64-BPFSections:Idx Name                                Size         VMA                  Type  0                                        00000000 0000000000000000  1 .strtab                                00000115 0000000000000000  2 .text                                00000000 0000000000000000 TEXT  3 kprobe/kmem_cache_free                00000048 0000000000000000 TEXT  4 .relkprobe/kmem_cache_free                00000010 0000000000000000  5 kretprobe/kmem_cache_alloc_node        000000c0 0000000000000000 TEXT  6 .relkretprobe/kmem_cache_alloc_node 00000010 0000000000000000  7 maps                                0000001c 0000000000000000 DATA  8 license                                00000004 0000000000000000 DATA  9 version                                00000004 0000000000000000 DATA... ...</code></pre><p>可以使用 llvm 工具为 eBPF 程序进行反编译，<code>tracex4_kern.o</code> 是 ELF 格式的文件，分为两个代码段，如下所示 ：</p><pre><code>wu@ubuntu:~/linux/samples/bpf$ llvm-objdump -d -r -print-imm-hex tracex4_kern.otracex4_kern.o: file format ELF64-BPFDisassembly of section kprobe/kmem_cache_free:0000000000000000 bpf_prog1:       0:        79 11 68 00 00 00 00 00 r1 = *(u64 *)(r1 + 0x68)       1:        7b 1a f8 ff 00 00 00 00 *(u64 *)(r10 - 0x8) = r1       2:        bf a2 00 00 00 00 00 00 r2 = r10       3:        07 02 00 00 f8 ff ff ff r2 += -0x8       4:        18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r1 = 0x0 ll                0000000000000020:  R_BPF_64_64        my_map       6:        85 00 00 00 03 00 00 00 call 0x3       7:        b7 00 00 00 00 00 00 00 r0 = 0x0       8:        95 00 00 00 00 00 00 00 exitDisassembly of section kretprobe/kmem_cache_alloc_node:0000000000000000 bpf_prog2:       0:        79 12 50 00 00 00 00 00 r2 = *(u64 *)(r1 + 0x50)       1:        7b 2a f8 ff 00 00 00 00 *(u64 *)(r10 - 0x8) = r2       2:        b7 02 00 00 00 00 00 00 r2 = 0x0       3:        7b 2a f0 ff 00 00 00 00 *(u64 *)(r10 - 0x10) = r2       4:        79 13 20 00 00 00 00 00 r3 = *(u64 *)(r1 + 0x20)       5:        07 03 00 00 08 00 00 00 r3 += 0x8       6:        bf a1 00 00 00 00 00 00 r1 = r10       7:        07 01 00 00 f0 ff ff ff r1 += -0x10       8:        b7 02 00 00 08 00 00 00 r2 = 0x8       9:        85 00 00 00 04 00 00 00 call 0x4      10:        85 00 00 00 05 00 00 00 call 0x5      11:        7b 0a e0 ff 00 00 00 00 *(u64 *)(r10 - 0x20) = r0      12:        79 a1 f0 ff 00 00 00 00 r1 = *(u64 *)(r10 - 0x10)      13:        7b 1a e8 ff 00 00 00 00 *(u64 *)(r10 - 0x18) = r1      14:        bf a2 00 00 00 00 00 00 r2 = r10      15:        07 02 00 00 f8 ff ff ff r2 += -0x8      16:        bf a3 00 00 00 00 00 00 r3 = r10      17:        07 03 00 00 e0 ff ff ff r3 += -0x20      18:        18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r1 = 0x0 ll                0000000000000090:  R_BPF_64_64        my_map      20:        b7 04 00 00 00 00 00 00 r4 = 0x0      21:        85 00 00 00 02 00 00 00 call 0x2      22:        b7 00 00 00 00 00 00 00 r0 = 0x0      23:        95 00 00 00 00 00 00 00 exit             ........</code></pre><p>接下来查看其他段的内容,比如 maps 段和 license 段：</p><pre><code>wu@ubuntu:~/linux/samples/bpf$ llvm-objdump --section=maps  -s tracex4_kern.otracex4_kern.o: file format ELF64-BPFContents of section maps: 0000 01000000 08000000 10000000 40420f00  ............@B.. 0010 00000000 00000000 00000000           ............wu@ubuntu:~/linux/samples/bpf$ llvm-objdump --section=license  -s tracex4_kern.otracex4_kern.o: file format ELF64-BPFContents of section license: 0000 47504c00                                   GPL.</code></pre><p>上述 bpf 程序的字节码，是不能在 x86_64 平台上直接执行的，当加载 bpf 程序时需要使用 JIT(just in time) 编译器将 bpf 字节码翻译成主机能识别的汇编码，然而对于大多数操作码，eBPF 指令集可以和 x86 或 aarch64 指令集一一映射。</p><p>bpf 程序自定义了一套指令，有别于 x86，ARM64 等，而且指令集没这两者丰富，没有浮点计算等。但寄存器功能大同小异， 功能如下所示：</p><p>无法复制加载中的内容</p><h4 id="通过-strace-工具追踪分析-eBPF-程序行为"><a href="#通过-strace-工具追踪分析-eBPF-程序行为" class="headerlink" title="通过 strace 工具追踪分析 eBPF 程序行为"></a>通过 strace 工具追踪分析 eBPF 程序行为</h4><p>执行如下命令可以看到 slab 对象的分配地址以及分配时间：</p><pre><code>wu@ubuntu:~/linux/samples/bpf$ sudo strace -v -f -s 128 -o tracex4.txt ./tracex4obj 0xffff9637e3175cc0 is  1sec old was allocated at ip ffffffff99679a9aobj 0xffff9637e31750c0 is  1sec old was allocated at ip ffffffff99679a9aobj 0xffff9637e3175e00 is  1sec old was allocated at ip ffffffff99679a9aobj 0xffff9637e3175780 is  1sec old was allocated at ip ffffffff99679a9a... ...</code></pre><p>strace 追踪到的关键系统调用如下：</p><pre><code>execve("./tracex4", ["./tracex4"], ["LANG=en_US.UTF-8", "LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca"..., "TERM=xterm", "DISPLAY=localhost:12.0", "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin", "MAIL=/var/mail/root", "LOGNAME=root", "USER=root", "HOME=/root", "SHELL=/bin/bash", "SUDO_COMMAND=/usr/bin/strace -v -f -s 128 -o tracex4.txt ./tracex4", "SUDO_USER=wu", "SUDO_UID=1000", "SUDO_GID=1000"]) = 0... ...bpf(BPF_MAP_CREATE, {map_type=BPF_MAP_TYPE_HASH, key_size=8, value_size=16, max_entries=1000000, map_flags=0, inner_map_fd=0, map_name="my_map", map_ifindex=0, btf_fd=0, btf_key_type_id=0, btf_value_type_id=0}, 112) = 4bpf(BPF_PROG_LOAD, {prog_type=BPF_PROG_TYPE_KPROBE, insn_cnt=9, insns=[{code=BPF_LDX|BPF_DW|BPF_MEM, dst_reg=BPF_REG_1, src_reg=BPF_REG_1, off=104, imm=0}, {code=BPF_STX|BPF_DW|BPF_MEM, dst_reg=BPF_REG_10, src_reg=BPF_REG_1, off=-8, imm=0}, {code=BPF_ALU64|BPF_X|BPF_MOV, dst_reg=BPF_REG_2, src_reg=BPF_REG_10, off=0, imm=0}, {code=BPF_ALU64|BPF_K|BPF_ADD, dst_reg=BPF_REG_2, src_reg=BPF_REG_0, off=0, imm=0xfffffff8}, {code=BPF_LD|BPF_DW|BPF_IMM, dst_reg=BPF_REG_1, src_reg=BPF_REG_1, off=0, imm=0x4}, {code=BPF_LD|BPF_W|BPF_IMM, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0}, {code=BPF_JMP|BPF_K|BPF_CALL, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0x3}, {code=BPF_ALU64|BPF_K|BPF_MOV, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0}, {code=BPF_JMP|BPF_K|BPF_EXIT, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0}], license="GPL", log_level=0, log_size=0, log_buf=NULL, kern_version=KERNEL_VERSION(5, 4, 0), prog_flags=0, prog_name="", prog_ifindex=0, expected_attach_type=BPF_CGROUP_INET_INGRESS, prog_btf_fd=0, func_info_rec_size=0, func_info=NULL, func_info_cnt=0, line_info_rec_size=0, line_info=NULL, line_info_cnt=0, attach_btf_id=0}, 112) = 5openat(AT_FDCWD, "/sys/kernel/debug/tracing/kprobe_events", O_WRONLY|O_APPEND) = 6write(6, "p:kmem_cache_free kmem_cache_free", 33) = 33close(6)openat(AT_FDCWD, "/sys/kernel/debug/tracing/events/kprobes/kmem_cache_free/id", O_RDONLY) = 6read(6, "2145\n", 256)                 = 5close(6)perf_event_open({type=PERF_TYPE_TRACEPOINT, size=0 /* PERF_ATTR_SIZE_??? */, config=2145, sample_period=1, sample_type=PERF_SAMPLE_RAW, read_format=0, disabled=0, inherit=0, pinned=0, exclusive=0, exclusive_user=0, exclude_kernel=0, exclude_hv=0, exclude_idle=0, mmap=0, comm=0, freq=0, inherit_stat=0, enable_on_exec=0, task=0, watermark=0, precise_ip=0 /* arbitrary skid */, mmap_data=0, sample_id_all=0, exclude_host=0, exclude_guest=0, exclude_callchain_kernel=0, exclude_callchain_user=0, mmap2=0, comm_exec=0, use_clockid=0, context_switch=0, write_backward=0, namespaces=0, wakeup_events=1, config1=0}, -1, 0, -1, 0) = 6... ...openat(AT_FDCWD, "/sys/kernel/debug/tracing/kprobe_events", O_WRONLY|O_APPEND) = 8write(8, "r:kmem_cache_alloc_node kmem_cache_alloc_node", 45) = 45openat(AT_FDCWD, "/sys/kernel/debug/tracing/events/kprobes/kmem_cache_alloc_node/id", O_RDONLY) = 8read(8, "2146\n", 256)                 = 5close(8)                         = 0perf_event_open({type=PERF_TYPE_TRACEPOINT, size=0 /* PERF_ATTR_SIZE_??? */, config=2146, sample_period=1, sample_type=PERF_SAMPLE_RAW, read_format=0, disabled=0, inherit=0, pinned=0, exclusive=0, exclusive_user=0, exclude_kernel=0, exclude_hv=0, exclude_idle=0, mmap=0, comm=0, freq=0, inherit_stat=0, enable_on_exec=0, task=0, watermark=0, precise_ip=0 /* arbitrary skid */, mmap_data=0, sample_id_all=0, exclude_host=0, exclude_guest=0, exclude_callchain_kernel=0, exclude_callchain_user=0, mmap2=0, comm_exec=0, use_clockid=0, context_switch=0, write_backward=0, namespaces=0, wakeup_events=1, config1=0}, -1, 0, -1, 0) = 8ioctl(8, PERF_EVENT_IOC_ENABLE, 0) = 0ioctl(8, PERF_EVENT_IOC_SET_BPF, 7) = 0write(1, "\33[1;1H\33[2J\0\0", 12) = 12bpf(BPF_MAP_GET_NEXT_KEY, {map_fd=4, key=0x7ffffaf162b0, next_key=0x7ffffaf162b8}, 112) = 0bpf(BPF_MAP_LOOKUP_ELEM, {map_fd=4, key=0x7ffffaf162b8, value=0x7ffffaf162d0, flags=BPF_ANY}, 112) = 0... ...</code></pre><h5 id="BPF-字节码加载分析"><a href="#BPF-字节码加载分析" class="headerlink" title="BPF 字节码加载分析"></a>BPF 字节码加载分析</h5><p>当 bpf 系统第一个参数 <code>cmds=BPF_PROG_LOAD</code> 时，表示加载 <code>ELF64-BPF</code> 格式的文件，仔细分析下第二个参数 <code>attr</code>，这个结构体的原型如下，发现就是保存了 bpf 字节码：</p><pre><code>struct {    /* Used by BPF_PROG_LOAD */        __u32              prog_type;        __u32              insn_cnt;        __aligned_u64 insns;          /* 'const struct bpf_insn *' */        __aligned_u64 license;          /* 'const char *' */        __u32              log_level;  /* verbosity level of verifier */        __u32              log_size;   /* size of user buffer */        __aligned_u64 log_buf;          /* user supplied 'char *'buffer */        __u32              kern_version;                                /* checked when prog_type=kprobe(since Linux 4.1) */}; __attribute__((aligned(8)));</code></pre><p>当加载 bpf 程序时，<code>BPF_PROG_LOAD</code> 表示的是该程序的具体 bpf 指令，对应 <code>bpf_prog1</code> 这个代码段。</p><p>strace 追踪到的指令如下所示，每条指令的操作码由六部分组成：</p><ul><li><p>code(操作码)</p></li><li><p>dst_reg(目标寄存器)</p></li><li><p>src_reg(源寄存器)</p></li><li><p>off(偏移)</p></li><li><p>imm(立即数)</p></li></ul><p>详见：</p><pre><code>insns=[{code=BPF_LDX|BPF_DW|BPF_MEM, dst_reg=BPF_REG_1, src_reg=BPF_REG_1, off=104, imm=0},{code=BPF_STX|BPF_DW|BPF_MEM, dst_reg=BPF_REG_10, src_reg=BPF_REG_1, off=-8, imm=0},{code=BPF_ALU64|BPF_X|BPF_MOV, dst_reg=BPF_REG_2, src_reg=BPF_REG_10, off=0, imm=0},{code=BPF_ALU64|BPF_K|BPF_ADD, dst_reg=BPF_REG_2, src_reg=BPF_REG_0, off=0, imm=0xfffffff8},{code=BPF_LD|BPF_DW|BPF_IMM, dst_reg=BPF_REG_1, src_reg=BPF_REG_1, off=0, imm=0x4},{code=BPF_LD|BPF_W|BPF_IMM, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0},{code=BPF_JMP|BPF_K|BPF_CALL, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0x3},{code=BPF_ALU64|BPF_K|BPF_MOV, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0},{code=BPF_JMP|BPF_K|BPF_EXIT, dst_reg=BPF_REG_0, src_reg=BPF_REG_0, off=0, imm=0}]</code></pre><p>指令格式如下图所示，BPF 当前拥有 102 个指令，主要包括三大类：</p><ul><li><p>ALU (64bit and 32bit)</p></li><li><p>内存操作</p></li><li><p>分支操作</p></li></ul><p>其中指令的格式主要由下面这几部分组成：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTMwMjNmNmExNTA1NGZhNmEyMzVhNTM2MzQ2ODM5M2VfTGVyZFNjSjNiY2pUc0xDUmVoeHc0T1FEN3dOeGxnZVVfVG9rZW46Ym94Y244NVN0c2Vqa1NWclBObFR0enZJUmZmXzE2MjcxNDg3NzA6MTYyNzE1MjM3MF9WNA" alt="img"></p><p>opcode 的低 3 位表示指令类型，<code>BPF_LDX</code>，<code>BPF_REG_10</code> 等这些宏在 kernel 目录 <code>tools/include/uapi/linux/bpf.h</code> 中定义：</p><pre><code>#define         BPF_LDX         0x01#define         BPF_MEM         0x60#define         BPF_DW                0x18... ...</code></pre><p>以第一条 bpf 指令为例子：</p><pre><code>{code=BPF_LDX|BPF_DW|BPF_MEM, dst_reg=BPF_REG_1, src_reg=BPF_REG_1, off=104, imm=0}</code></pre><p>正好对应 llvm-objdump 解析出来的第一条指令，为内存访问指令：</p><pre><code>0:       79 11 68 00 00 00 00 00 r1 = *(u64 *)(r1 + 0x68)BPF_LDX|BPF_MEM|BPF_DW=0x79</code></pre><p>该条指令在 kernel 中的定义为：</p><pre><code>/* Memory load, dst_reg = *(uint *) (src_reg + off16) */#define BPF_LDX_MEM(SIZE, DST, SRC, OFF)                        \        ((struct bpf_insn) {                                        \                .code  = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM,        \                .dst_reg = DST,                                 \                .src_reg = SRC,                                 \                .off   = OFF,                                        \                .imm   = 0 })</code></pre><h5 id="MAP-数据通信分析"><a href="#MAP-数据通信分析" class="headerlink" title="MAP 数据通信分析"></a>MAP 数据通信分析</h5><p>当 bpf 系统第一个参数 <code>cmds=BPF_MAP_CREATE</code> 时，表示创建一个数据 map，仔细分析下第二个参数 <code>attr</code>，这个结构体的原型包含了 map 类型，key 的大小，valu e大小等：</p><pre><code>union bpf_attr {struct {    /* Used by BPF_MAP_CREATE */        __u32              map_type;        __u32              key_size;    /* size of key in bytes */        __u32              value_size;  /* size of value in bytes */        __u32              max_entries; /* maximum number of entriesin a map */};</code></pre><p>用 strace 抓取的 log 分析来看 map 的类型为 <code>BPF_MAP_TYPE_HASH</code>，key 的大小为 8，value大小为 16，访问 map 是 <code>bpf_prog1</code> 第5条字节码，其中的 imm 立即数为 4 代表 map_fd，这是一条伪指令，这条指令是可重定位指令：</p><pre><code>bpf(BPF_MAP_CREATE, {map_type=BPF_MAP_TYPE_HASH, key_size=8, value_size=16, max_entries=1000000, map_flags=0, inner_map_fd=0, map_name="my_map", map_ifindex=0, btf_fd=0, btf_key_type_id=0, btf_value_type_id=0}, 112) = 4 0000000000000020:  R_BPF_64_64  my_map{code=BPF_LD|BPF_DW|BPF_IMM, dst_reg=BPF_REG_1, src_reg=BPF_REG_1, off=0, imm=0x4}</code></pre><p>bpf 程序访问所有类型的 map 都可以使用 <code>bpf_map_lookup_elem()</code> 和 <code>bpf_map_update_elem()</code> 函数，socket maps 和一些其他额外的 map 当作特殊用途。</p><p>当 bpf 系统第一个参数 <code>cmds=BPF_MAP_GET_NEXT_KEY</code> 或 <code>BPF_MAP_LOOKUP_ELEM</code> 时，表示遍历 map，仔细分析下第二个参数 <code>attr</code>，这个结构体的原型包含了 map_fd，是 bpf 系统调用第一个参数 <code>cmd=BPF_MAP_CREATE</code> 返回值，key 值，value 值等：</p><pre><code>struct {    /* Used by BPF_MAP_*_ELEM and BPF_MAP_GET_NEXT_KEYcommands */        __u32              map_fd;        __aligned_u64 key;        union {        __aligned_u64 value;        __aligned_u64 next_key;        };        __u64              flags;};bpf(BPF_MAP_GET_NEXT_KEY, {map_fd=4, key=0x7ffffaf162b0, next_key=0x7ffffaf162b8}, 112) = 0bpf(BPF_MAP_LOOKUP_ELEM, {map_fd=4, key=0x7ffffaf162b8, value=0x7ffffaf162d0, flags=BPF_ANY}, 112) = 0</code></pre><h4 id="bpftool-用法简介"><a href="#bpftool-用法简介" class="headerlink" title="bpftool 用法简介"></a>bpftool 用法简介</h4><p>bpftool 在内核的 <code>tools/bpf/bpftool/</code> 目录下，使用 make 编译就可使用，查看当前运行的 bpf 程序，如下所示，可以看到当前运行的是 <code>kprobe event</code> 还有 <code>map id</code>：</p><pre><code>wu@ubuntu:~/linux/samples/bpf$ sudo bpftool prog show[sudo] password for wu:... ...205: kprobe  tag a6cfc4a29f52a193  gpl        loaded_at 2021-01-19T11:51:26+0000  uid 0        xlated 72B  jited 62B  memlock 4096B  map_ids 72206: kprobe  tag d16c41919f3b767a  gpl        loaded_at 2021-01-19T11:51:26+0000  uid 0        xlated 192B  jited 119B  memlock 4096B        map_ids 72</code></pre><p>查看 map 的id，可以看到当前使用的是 hash map：</p><pre><code>wu@ubuntu:~/linux$ sudo bpftool map show72: hash  name my_map  flags 0x0        key 8B        value 16B  max_entries 1000000        memlock 88788992B</code></pre><p>查看 map 的所有的内容，并查看对应 key 的value：</p><pre><code>wu@ubuntu:~/linux$ sudo bpftool map dump id 72key: 80 35 43 e5 26 95 ff ff  value: b9 f3 f3 9e 87 6b 00 00  9a 9a c7 86 ff ff ff ffkey: 80 9c 5f f6 25 95 ff ff  value: 98 85 ac c7 8c 6b 00 00  9a 9a c7 86 ff ff ff ffkey: 00 4c 9b e4 25 95 ff ff  value: e6 8d c2 b7 7e 6b 00 00  9a 9a c7 86 ff ff ff ffkey: 80 21 15 f8 26 95 ff ff  value: 60 df 01 fc 5c 6b 00 00  9a 9a c7 86 ff ff ff ffkey: 80 f5 46 5f 26 95 ff ff  value: 5e e1 73 7b 8d 6b 00 00  9a 9a c7 86 ff ff ff ff... ...wu@ubuntu:~/linux$ sudo bpftool map lookup id 72 key 0x80 0x35 0x43 0xe5 0x26 0x95 0xff 0xffkey: 80 35 43 e5 26 95 ff ff  value: b9 f3 f3 9e 87 6b 00 00  9a 9a c7 86 ff ff ff ff</code></pre><h2 id="eBPF-程序装载、翻译与运行过程详解"><a href="#eBPF-程序装载、翻译与运行过程详解" class="headerlink" title="eBPF 程序装载、翻译与运行过程详解"></a>eBPF 程序装载、翻译与运行过程详解</h2><h4 id="BPF-程序格式为-ELF"><a href="#BPF-程序格式为-ELF" class="headerlink" title="BPF 程序格式为 ELF"></a>BPF 程序格式为 ELF</h4><p>加载 bpf 程序实质上是加载 ELF 格式文件，Linux 加载普通 ELF 格式的文件在通过 <code>load_elf_binary</code> 来实现，而 Linux 加载 bpf elf 其实在用户态实现的，使用的是开源的 libelf 库实现的，调用过程不太一样，而且只是把 ELF 格式的指令 dump 出来，接下来还需要 JIT 编译器翻译出机器汇编码才能执行，这个调用过程比 Linux 加载普通 ELF 格式文件简单。</p><p>libelf 库实现的各个 API 可参考如下 <a href="https://www.zybuluo.com/devilogic/note/139554" target="_blank" rel="noopener">链接</a> 以及我们专门为此准备的 <a href="http://tinylab.org/libelf" target="_blank" rel="noopener">libelf 开源库用法详解</a>。</p><p>ELF 格式的详解可参考社区创始人撰写的开源书籍 <a href="https://tinylab.gitbooks.io/cbook" target="_blank" rel="noopener">C 语言编程透视</a> 和配套视频课程<a href="https://www.cctalk.com/m/group/88089283" target="_blank" rel="noopener">《360° 剖析 Linux ELF》</a>。</p><h5 id="ELF-文件大体结构"><a href="#ELF-文件大体结构" class="headerlink" title="ELF 文件大体结构"></a>ELF 文件大体结构</h5><p>ELF 文件大体结构如下所示，包含 ELF 头部，程序头表，各个段和程序段表：</p><pre><code>ELF Header                 #程序头，有该文件的Magic number(参考man magic)，类型等Program Header Table         #对可执行文件和共享库有效，它描述下面各个节(section)组成的段Section1Section2Section3.....Program Section Table        #仅对可重定位目标文件和静态库有效，用于描述各个Section的重定位信息等。</code></pre><h4 id="BPF-程序-Section-解析：get-sec"><a href="#BPF-程序-Section-解析：get-sec" class="headerlink" title="BPF 程序 Section 解析：get_sec"></a>BPF 程序 Section 解析：get_sec</h4><p><code>samples/bpf/bpf_load.c</code> 中通过 <code>get_sec</code> 函数调用 libelf 库的 API 获取 section 内容，其中第四个参数是传入段的名字，最后一个参数获得的是该段的数据：</p><pre><code>static int get_sec(Elf *elf, int i, GElf_Ehdr *ehdr, char **shname,                   GElf_Shdr *shdr, Elf_Data **data){        Elf_Scn *scn;        scn = elf_getscn(elf, i);  //从elf描述符获取按照节索引获取节接口        if (!scn)                return 1;        if (gelf_getshdr(scn, shdr) != shdr) // 通过节结构复制节表头                return 2;        *shname = elf_strptr(elf, ehdr-&gt;e_shstrndx, shdr-&gt;sh_name); // 从指定的字符串表中通过偏移获取字符串        if (!*shname || !shdr-&gt;sh_size)                return 3;        *data = elf_getdata(scn, 0);  //从节中获取节数据（经过了字节序的转换）        if (!*data || elf_getdata(scn, *data) != NULL)                return 4;        return 0;}</code></pre><h4 id="BPF-程序装载与解析：load-bpf-file"><a href="#BPF-程序装载与解析：load-bpf-file" class="headerlink" title="BPF 程序装载与解析：load_bpf_file"></a>BPF 程序装载与解析：load_bpf_file</h4><p><code>tracex4_user.c</code> 通过 <code>load_bpf_file</code> 加载 <code>.o</code> 文件，我们来分析一下。</p><p><code>load_bpf_file</code> 实质是调用 <code>do_load_bpf_file</code>，在这个函数里首先打开 <code>.o</code> 文件，<code>do_load_bpf_file</code> 会将输入的 <code>.o</code> 文件作为 ELF 格式文件，逐个 section 进行分析：</p><ul><li><p>如 section 的名字是特殊的(比如 ‘kprobe’)，那么就会将这个 section 的内容作为 <code>load_and_attach</code> 的参数。</p></li><li><p>如 section 的名字是 “license” 或 “version” 则保存 license 或 version。</p></li><li><p>如 section 是 map 则解析出 map 段</p></li></ul><p><code>samples/bpf/bpfload.c</code> 中的相关代码如下：</p><pre><code>static int do_load_bpf_file(const char *path, fixup_map_cb fixup_map){        int fd, i, ret, maps_shndx = -1, strtabidx = -1;        Elf *elf;        GElf_Ehdr ehdr;        GElf_Shdr shdr, shdr_prog;        Elf_Data *data, *data_prog, *data_maps = NULL, *symbols = NULL;        char *shname, *shname_prog;        int nr_maps = 0;        ... ...        fd = open(path, O_RDONLY, 0);  //打开elf文件        if (fd &lt; 0)                return 1;        elf = elf_begin(fd, ELF_C_READ, NULL);//获取elf描述符,使用‘读取’的方式        ... ...        if (gelf_getehdr(elf, &amp;ehdr) != &amp;ehdr)        //获取elf文件头副本                return 1;        ... ...        /* scan over all elf sections to get license and map info */        for (i = 1; i &lt; ehdr.e_shnum; i++) {                       //遍历各个section                if (get_sec(elf, i, &amp;ehdr, &amp;shname, &amp;shdr, &amp;data))  // shname 为"section"的名字                        continue;                if (0) /* helpful for llvm debugging */        //打印各个section 对应的数据保存在data-&gt;d_buf中                        printf("section %d:%s data %p size %zd link %d flags %d\n",                        i, shname, data-&gt;d_buf, data-&gt;d_size,                        shdr.sh_link, (int) shdr.sh_flags);                if (strcmp(shname, "license") == 0) {             //如果是"license"段                        processed_sec[i] = true;                        memcpy(license, data-&gt;d_buf, data-&gt;d_size); //把 data-&gt;d_buf 拷贝到license数组                } else if (strcmp(shname, "version") == 0) { //如果是"version"段                        processed_sec[i] = true;                        if (data-&gt;d_size != sizeof(int)) {                                printf("invalid size of version section %zd\n",                                data-&gt;d_size);                                return 1;                }                memcpy(&amp;kern_version, data-&gt;d_buf, sizeof(int));//把 data-&gt;d_buf 拷贝到kern_version变量        } else if (strcmp(shname, "maps") == 0) {      //如果是map 段                int j;                maps_shndx = i;                data_maps = data;                for (j = 0; j &lt; MAX_MAPS; j++)                        map_data[j].fd = -1;        } else if (shdr.sh_type == SHT_SYMTAB) {                strtabidx = shdr.sh_link;                symbols = data;        }        ... ...        if (data_maps) {     //对map段的处理                nr_maps = load_elf_maps_section(map_data, maps_shndx,elf, symbols, strtabidx);         //获取map段内容                if (nr_maps &lt; 0) {                        printf("Error: Failed loading ELF maps (errno:%d):%s\n",                        nr_maps, strerror(-nr_maps));                        goto done;                }                if (load_maps(map_data, nr_maps, fixup_map))  //这里加载map                        goto done;                map_data_count = nr_maps;                processed_sec[maps_shndx] = true;        }        /* process all relo sections, and rewrite bpf insns for maps */        for (i = 1; i &lt; ehdr.e_shnum; i++) {  //遍历所有的重定向段，                if (processed_sec[i])  ////flag 置位表示已经是处理了的段 ，跳过去                        continue;                if (get_sec(elf, i, &amp;ehdr, &amp;shname, &amp;shdr, &amp;data))                        continue;                if (shdr.sh_type == SHT_REL) {                        struct bpf_insn *insns;                        /* locate prog sec that need map fixup (relocations) */                        if (get_sec(elf, shdr.sh_info, &amp;ehdr, &amp;shname_prog,                                &amp;shdr_prog, &amp;data_prog))  //该段保存到data_prog                                continue;                        if (shdr_prog.sh_type != SHT_PROGBITS ||                        !(shdr_prog.sh_flags &amp; SHF_EXECINSTR))                                continue;                        insns = (struct bpf_insn *) data_prog-&gt;d_buf;  //得到bpf字节码对应的结构体                        processed_sec[i] = true; /* relo section */                        if (parse_relo_and_apply(data, symbols, &amp;shdr, insns,                                                map_data, nr_maps))                                continue;                }        }        /* load programs */        for (i = 1; i &lt; ehdr.e_shnum; i++) {                if (processed_sec[i])  //flag 置位表示已经是处理了的段 ，跳过去                        continue;                if (get_sec(elf, i, &amp;ehdr, &amp;shname, &amp;shdr, &amp;data))                        continue;                if (memcmp(shname, "kprobe/", 7) == 0 ||                        memcmp(shname, "kretprobe/", 10) == 0 ||                        memcmp(shname, "tracepoint/", 11) == 0 ||                        memcmp(shname, "raw_tracepoint/", 15) == 0 ||                        memcmp(shname, "xdp", 3) == 0 ||                        memcmp(shname, "perf_event", 10) == 0 ||                        memcmp(shname, "socket", 6) == 0 ||                        memcmp(shname, "cgroup/", 7) == 0 ||                        memcmp(shname, "sockops", 7) == 0 ||                        memcmp(shname, "sk_skb", 6) == 0 ||                        memcmp(shname, "sk_msg", 6) == 0) {                        ret = load_and_attach(shname, data-&gt;d_buf,                                        data-&gt;d_size);  //事件类型 字节码 字节码大小                        if (ret != 0)                                goto done;                }        }done:        close(fd);        return ret;}</code></pre><p>打开 ELF 调试 log，可以得到该 ELF 文件各个段的内容首地址，大小，属性等信息。</p><pre><code>wu@ubuntu:~/linux/samples/bpf$ sudo ./tracex4[sudo] password for wu:section 1:.strtab data 0x556034a3d070 size 277 link 0 flags 0section 3:kprobe/kmem_cache_free data 0x556034a3d5a0 size 72 link 0 flags 6section 4:.relkprobe/kmem_cache_free data 0x556034a3d5f0 size 16 link 26 flags 0section 5:kretprobe/kmem_cache_alloc_node data 0x556034a3d610 size 192 link 0 flags 6section 6:.relkretprobe/kmem_cache_alloc_node data 0x556034a3d6e0 size 16 link 26 flags 0section 7:maps data 0x556034a3d700 size 28 link 0 flags 3section 8:license data 0x556034a3d730 size 4 link 0 flags 3section 9:version data 0x556034a3d750 size 4 link 0 flags 3section 10:.debug_str data 0x556034a3d770 size 489 link 0 flags 48section 11:.debug_loc data 0x556034a3d970 size 336 link 0 flags 0section 12:.rel.debug_loc data 0x556034a3dad0 size 80 link 26 flags 0section 13:.debug_abbrev data 0x556034a3db30 size 257 link 0 flags 0section 14:.debug_info data 0x556034a3dc40 size 886 link 0 flags 0section 15:.rel.debug_info data 0x556034a3dfc0 size 1200 link 26 flags 0section 16:.debug_ranges data 0x556034a3e480 size 48 link 0 flags 0section 17:.rel.debug_ranges data 0x556034a3e4c0 size 64 link 26 flags 0section 18:.BTF data 0x556034a3e510 size 1384 link 0 flags 0section 19:.rel.BTF data 0x556034a3ea80 size 48 link 26 flags 0section 20:.BTF.ext data 0x556034a3eac0 size 376 link 0 flags 0section 21:.rel.BTF.ext data 0x556034a3ec40 size 320 link 26 flags 0section 22:.eh_frame data 0x556034a3ed90 size 80 link 0 flags 2section 23:.rel.eh_frame data 0x556034a3edf0 size 32 link 26 flags 0section 24:.debug_line data 0x556034a3ee20 size 327 link 0 flags 0section 25:.rel.debug_line data 0x556034a3ef70 size 32 link 26 flags 0section 26:.symtab data 0x556034a3efa0 size 1704 link 1 flags 0</code></pre><h4 id="BPF-字节码加载过程"><a href="#BPF-字节码加载过程" class="headerlink" title="BPF 字节码加载过程"></a>BPF 字节码加载过程</h4><p>接下来调用 <code>load_and_attach</code>，第一个参数是 event，本例就是 “kprobe/” ，第二个参数是 bpf 字节码，第三个参数是字节码大小。</p><h5 id="BPF-指令结构"><a href="#BPF-指令结构" class="headerlink" title="BPF 指令结构"></a>BPF 指令结构</h5><p><code>bpf_insn</code> 是一个结构体，代表一条 eBPF 指令，包含 5 个字段组成：</p><pre><code>struct bpf_insn {    __u8    code;         /* opcode */    __u8    dst_reg:4;          /* dest register */    __u8    src_reg:4;          /* source register */    __s16    off;         /* signed offset */    __s32    imm;         /* signed immediate constant */};</code></pre><p>每一个 eBPF 程序都是由若干个 bpf 指令构成，就是一个一个 <code>bpf_insn</code> 数组，使用 bpf 系统调用将其载入内核。</p><h5 id="把-BPF-字节码装载到内核空间"><a href="#把-BPF-字节码装载到内核空间" class="headerlink" title="把 BPF 字节码装载到内核空间"></a>把 BPF 字节码装载到内核空间</h5><p>接着调用 <code>bpf_load_program</code>，填入的参数为程序类型 <code>prog_type</code>, 和虚拟机指令 <code>insns_cnt</code> 等。</p><p>如果判断 events 是 <code>kprobe/kretprobe</code>，那么填充 buf 为 debugfs 相关路径。打开该路径，然后调用 <code>sys_perf_event_open ioctl</code> 设置等，这个和 strace 追踪到的调用过程基本一致。</p><pre><code>static int load_and_attach(const char *event, struct bpf_insn *prog, int size){    bool is_socket = strncmp(event, "socket", 6) == 0;    ......    fd = bpf_load_program(prog_type, prog, insns_cnt, license, kern_version,                            bpf_log_buf, BPF_LOG_BUF_SIZE);    ......           if (is_kprobe || is_kretprobe) {                bool need_normal_check = true;                const char *event_prefix = "";                if (is_kprobe)                        event += 7;                else                        event += 10;                if (*event == 0) {                        printf("event name cannot be empty\n");                        return -1;                }                if (isdigit(*event))                        return populate_prog_array(event, fd);#ifdef __x86_64__                if (strncmp(event, "sys_", 4) == 0) {                        snprintf(buf, sizeof(buf), "%c:__x64_%s __x64_%s",                                is_kprobe ? 'p' : 'r', event, event);                        err = write_kprobe_events(buf);                        if (err &gt;= 0) {                                need_normal_check = false;                                event_prefix = "__x64_";                        }                }#endif                if (need_normal_check) {                        snprintf(buf, sizeof(buf), "%c:%s %s",                                is_kprobe ? 'p' : 'r', event, event);                        err = write_kprobe_events(buf);                        if (err &lt; 0) {                                printf("failed to create kprobe '%s' error '%s'\n",                                       event, strerror(errno));                                return -1;                        }                }                strcpy(buf, DEBUGFS);                strcat(buf, "events/kprobes/");                strcat(buf, event_prefix);                strcat(buf, event);                strcat(buf, "/id");        }        efd = open(buf, O_RDONLY, 0);        if (efd &lt; 0) {                printf("failed to open event %s\n", event);                return -1;        }        err = read(efd, buf, sizeof(buf));        if (err &lt; 0 || err &gt;= sizeof(buf)) {                printf("read from '%s' failed '%s'\n", event, strerror(errno));                return -1;        }        close(efd);        buf[err] = 0;        id = atoi(buf);        attr.config = id;        efd = sys_perf_event_open(&amp;attr, -1/*pid*/, 0/*cpu*/, -1/*group_fd*/, 0);        ... ...        event_fd[prog_cnt - 1] = efd;        err = ioctl(efd, PERF_EVENT_IOC_ENABLE, 0);        ... ...        err = ioctl(efd, PERF_EVENT_IOC_SET_BPF, fd);        ... ...        return 0;}</code></pre><p>其中 <code>bpf_load_program</code> 会通过 <code>BPF_PROG_LOAD</code> 系统调用，将字节码传入内核，返回一个文件描述符 <code>fd</code>，<code>attr-&gt;insns</code> 就是下面这种 bpf 字节码：</p><pre><code>code=BPF_ALU64|BPF_X|BPF_MOV, dst_reg=BPF_REG_6, src_reg=BPF_REG_1, off=0, imm=0</code></pre><p><code>kernel/bpf/syscall.c</code> 中定义的相应系统调用如下：</p><pre><code>SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size){    ......        case BPF_MAP_CREATE:                err = map_create(&amp;attr);                break;    case BPF_PROG_LOAD:        err = bpf_prog_load(&amp;attr);  //attr包含字节码    ... ...}</code></pre><p>而 <code>bpf_prog_load</code> 真正的加载 bpf 字节码，首先从 bpf 字节码中获得 license，判断是不是 GPL license。</p><p>然后分配内核 <code>bpf_prog</code> 程序数据结构空间，将 bpf 虚拟机指令从用户空间拷贝到内核空间，把指令保存在 <code>struct bpf_prog</code> 结构体中。</p><p>然后运行 <code>bpf_check</code> 验证 bpf 指令在注入内核是否安全，比如检查栈是否会溢出，除数是否为零，否则不检测安不安全容易造成内核 panic 等严重问题，这一部分内容很多，就暂时不分析了。</p><h4 id="把-BPF-字节码翻译为机器码"><a href="#把-BPF-字节码翻译为机器码" class="headerlink" title="把 BPF 字节码翻译为机器码"></a>把 BPF 字节码翻译为机器码</h4><p>验证通过之后，核心调用是运行 <code>bpf_prog_select_runtime</code> 里的 <code>do_jit</code> 把 bpf 字节码转换成机器汇编码，最后运行 <code>bpf_prog_kallsyms_add</code> 将机器汇编码添加到 <code>kallsyms</code>，在 <code>/proc/kallsyms</code> 中会看到 bpf 程序的符号表：</p><pre><code>static int bpf_prog_load(union bpf_attr *attr){        enum bpf_prog_type type = attr-&gt;prog_type;        struct bpf_prog *prog;        int err;        char license[128];        bool is_gpl;        ... ...        /* copy eBPF program license from user space */        if (strncpy_from_user(license, u64_to_user_ptr(attr-&gt;license),                        sizeof(license) - 1) &lt; 0)  //拷贝license attr-&gt;license                return -EFAULT;        license[sizeof(license) - 1] = 0;  //最后一位设空字符        /* eBPF programs must be GPL compatible to use GPL-ed functions */        is_gpl = license_is_gpl_compatible(license);        /* plain bpf_prog allocation */        prog = bpf_prog_alloc(bpf_prog_size(attr-&gt;insn_cnt), GFP_USER); /* 分配内核 bpf_prog 程序数据结构空间 */        if (!prog)                return -ENOMEM;        prog-&gt;expected_attach_type = attr-&gt;expected_attach_type;        prog-&gt;aux-&gt;offload_requested = !!attr-&gt;prog_ifindex;        err = security_bpf_prog_alloc(prog-&gt;aux);        if (err)                goto free_prog_nouncharge;        err = bpf_prog_charge_memlock(prog);        if (err)                goto free_prog_sec;        prog-&gt;len = attr-&gt;insn_cnt;        err = -EFAULT;        if (copy_from_user(prog-&gt;insns, u64_to_user_ptr(attr-&gt;insns),                        bpf_prog_insn_size(prog)) != 0)  //将若干指令从用户态拷贝到内核态                goto free_prog;        prog-&gt;orig_prog = NULL;        prog-&gt;jited = 0;        atomic_set(&amp;prog-&gt;aux-&gt;refcnt, 1);        prog-&gt;gpl_compatible = is_gpl ? 1 : 0;        //设置gpl_compatible字段        ... ...        /* run eBPF verifier */        err = bpf_check(&amp;prog, attr);  //运行verifier 检查字节码安全性        if (err &lt; 0)                goto free_used_maps;        prog = bpf_prog_select_runtime(prog, &amp;err); //这里调用do_jit 将bpf字节码转换成汇编码        if (err &lt; 0)                goto free_used_maps;        err = bpf_prog_alloc_id(prog);        if (err)                goto free_used_maps;        bpf_prog_kallsyms_add(prog);  //添加kallsyms        err = bpf_prog_new_fd(prog);        if (err &lt; 0)                bpf_prog_put(prog);        return err;        ... ...}</code></pre><h4 id="运行-BPF-机器码"><a href="#运行-BPF-机器码" class="headerlink" title="运行 BPF 机器码"></a>运行 BPF 机器码</h4><p>JIT 编译器将机器汇编码的首地址转换成一个函数指针，保存到 <code>prog-&gt;bpf_func</code>，再看看哪里调用 <code>prog-&gt;bpf_func</code> 这个函数指针的呢？</p><p>在 debugfs 中创建 kprobe events，执行 <code>init_kprobe_trace</code> 加载 BPF 字节码的时候就调用了 <code>trace_kprobe_create</code> 继而调用 <code>kprobe_dispatcher</code>，因为定义了 <code>CONFIG_PERF_EVENTS</code> 而后调用 kprobe_perf_func，相关代码如下：</p><pre><code>static struct dyn_event_operations trace_kprobe_ops = {        .create = trace_kprobe_create,        .show = trace_kprobe_show,        .is_busy = trace_kprobe_is_busy,        .free = trace_kprobe_release,        .match = trace_kprobe_match,};/* Make a tracefs interface for controlling probe points */static __init int init_kprobe_trace(void){        ... ...        ret = dyn_event_register(&amp;trace_kprobe_ops);        if (ret)                return ret;        if (register_module_notifier(&amp;trace_kprobe_module_nb))                return -EINVAL;        d_tracer = tracing_init_dentry();        if (IS_ERR(d_tracer))                return 0;        entry = tracefs_create_file("kprobe_events", 0644, d_tracer,                                NULL, &amp;kprobe_events_ops);        ... ...        return 0;}fs_initcall(init_kprobe_trace);trace_kprobe_create{   ... ...   kprobe_dispatcher   ... ...}static int kprobe_dispatcher(struct kprobe *kp, struct pt_regs *regs){        struct trace_kprobe *tk = container_of(kp, struct trace_kprobe, rp.kp);        int ret = 0;        raw_cpu_inc(*tk-&gt;nhit);        if (trace_probe_test_flag(&amp;tk-&gt;tp, TP_FLAG_TRACE))                kprobe_trace_func(tk, regs);        #ifdef CONFIG_PERF_EVENTS        if (trace_probe_test_flag(&amp;tk-&gt;tp, TP_FLAG_PROFILE))                ret = kprobe_perf_func(tk, regs);        #endif        return ret;}</code></pre><p><code>kprobe_perf_func</code> 会调用 <code>trace_call_bpf</code>，在这里会执行 bpf 程序。<code>BPF_PROG_RUN_ARRAY_CHECK</code> 是一个宏，其实质上执行 <code>BPF_PROG_RUN</code> 里的一个函数：</p><pre><code>/* Kprobe profile handler */static intkprobe_perf_func(struct trace_kprobe *tk, struct pt_regs *regs){        if (bpf_prog_array_valid(call)) {                unsigned long orig_ip = instruction_pointer(regs);                int ret;                ret = trace_call_bpf(call, regs);                /** We need to check and see if we modified the pc of the* pt_regs, and if so return 1 so that we don't do the* single stepping.*/                if (orig_ip != instruction_pointer(regs))                        return 1;                if (!ret)                        return 0;        }        return 0;}/ * trace_call_bpf - invoke BPF program * @call: tracepoint event * @ctx: opaque context pointer * * kprobe handlers execute BPF programs via this helper. * Can be used from static tracepoints in the future. * * Return: BPF programs always return an integer which is interpreted by * kprobe handler as: * 0 - return from kprobe (event is filtered out) * 1 - store kprobe event into ring buffer * Other values are reserved and currently alias to 1 */unsigned int trace_call_bpf(struct trace_event_call *call, void *ctx){        unsigned int ret;        ... ...        ret = BPF_PROG_RUN_ARRAY_CHECK(call-&gt;prog_array, ctx, BPF_PROG_RUN);  //运行bpf程序out:        __this_cpu_dec(bpf_prog_active);        preempt_enable();        return ret;}</code></pre><p>其中的 <code>trace_event_call</code> 结构体定义了 <code>bpf_prog_array</code>，该结构体数组中包含了要执行的函数指针：</p><pre><code>struct trace_event_call {        struct list_head        list;        struct trace_event_class *class;        union {                char                        *name;                /* Set TRACE_EVENT_FL_TRACEPOINT flag when using "tp" */                struct tracepoint        *tp;        };        ... ...#ifdef CONFIG_PERF_EVENTS        int                                perf_refcount;        struct hlist_head __percpu        *perf_events;        struct bpf_prog_array __rcu        *prog_array;        int        (*perf_perm)(struct trace_event_call *,                                struct perf_event *);#endif};struct bpf_prog_array {        struct rcu_head rcu;        struct bpf_prog_array_item items[0];};struct bpf_prog_array_item {        struct bpf_prog *prog;        struct bpf_cgroup_storage *cgroup_storage[MAX_BPF_CGROUP_STORAGE_TYPE];};</code></pre><p><code>BPF_PROG_RUN_ARRAY_CHECK</code>， <code>BPF_PROG_RUN</code> 宏展开如下所示，实质是在 <code>BPF_PROG_RUN</code> 中调用 <code>ret = (*(prog)-&gt;bpf_func)(ctx, (prog)-&gt;insnsi)</code> 这个函数指针来执行 bpf 指令：</p><pre><code>#define BPF_PROG_RUN_ARRAY_CHECK(array, ctx, func)        \        __BPF_PROG_RUN_ARRAY(array, ctx, func, true)#define __BPF_PROG_RUN_ARRAY(array, ctx, func, check_non_null)        \        ({                                                \                struct bpf_prog_array_item *_item;        \                struct bpf_prog *_prog;                 \                struct bpf_prog_array *_array;                \                u32 _ret = 1;                                \                preempt_disable();                        \                rcu_read_lock();                        \                _array = rcu_dereference(array);        \                if (unlikely(check_non_null &amp;&amp; !_array))\                        goto _out;                        \                _item = &amp;_array-&gt;items[0];                \                while ((_prog = READ_ONCE(_item-&gt;prog))) {                \                        bpf_cgroup_storage_set(_item-&gt;cgroup_storage);        \                        _ret &amp;= func(_prog, ctx);        \                        _item++;                        \                }                                        \_out:                                                        \                rcu_read_unlock();                        \                preempt_enable();                        \                _ret;                                        \         })#define BPF_PROG_RUN(prog, ctx) ({                                \        u32 ret;                                                \        cant_sleep();                                                \        if (static_branch_unlikely(&amp;bpf_stats_enabled_key)) {        \                struct bpf_prog_stats *stats;                        \                u64 start = sched_clock();                        \                ret = (*(prog)-&gt;bpf_func)(ctx, (prog)-&gt;insnsi); \                stats = this_cpu_ptr(prog-&gt;aux-&gt;stats);         \                u64_stats_update_begin(&amp;stats-&gt;syncp);                \                stats-&gt;cnt++;                                        \                stats-&gt;nsecs += sched_clock() - start;                \                u64_stats_update_end(&amp;stats-&gt;syncp);                \        } else {                                                \                ret = (*(prog)-&gt;bpf_func)(ctx, (prog)-&gt;insnsi); \        }                                                        \        ret; })</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux Kernel | EBPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核开发环境配置</title>
      <link href="/posts/d672.html"/>
      <url>/posts/d672.html</url>
      
        <content type="html"><![CDATA[<h3 id="Linux不同版本内核安装"><a href="#Linux不同版本内核安装" class="headerlink" title="Linux不同版本内核安装"></a>Linux不同版本内核安装</h3><p>查看Linux版本</p><pre><code>cat /etc/redhat-release</code></pre><p>查看内核版本</p><pre><code>uname -r</code></pre><p>解压内核压缩包</p><pre><code>tar xf linux-2.6.30.tar.gz</code></pre><p>Linux内核源码安装流程</p><pre><code>1，安装依赖yum -y install gccyum -y install gcc-c++ yum install make -- 或者yum groupinstall "Development Tools" -- 或者yum install gcc gcc-c++ kernel-devel--安装ncursesyum install gcc make ncurses ncurses-devel perlyum update2，下载源码包cd /tmpwget https://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.32.26.tar.bz2bzip2 -d linux-2.6.32.26.tar.bz2tar -xvf linux-2.6.32.26.tar -C /usr/src/3，安装前配置cd /usr/src/linux-2.6.32.26/make menuconfig  """ 此命令运行将弹出"kernel configuration"界面 """  """ 按"ESC",点"YES"退出即可 """  """ 如需定制内核，请按提示进行选择 """make oldconfig  """ 如果定制内核，则不需要此步 """  """ 为要编译的内核源码使用当前系统内核配置文件 """  """ 当前目录下将会创建 ".config" 文件 """4，编译安装make [-jn]  """ n 为数字，如：make -j4 拆分 4 个作业任务并行编译，加快编译速度 """  """ 使用 make -j 则不限制并行编译的任务数，但是出错率可能会高一些 """  """ 如果不使用任何编译参数，一两个小时也是很常见的 """make modules_install  --安装内核模块make install  --安装内核reboot5，验证并测试uname -a </code></pre><h3 id="VSCode远程连接开发配置"><a href="#VSCode远程连接开发配置" class="headerlink" title="VSCode远程连接开发配置"></a>VSCode远程连接开发配置</h3><p>Mac安装homebrew</p><pre><code>/bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)"</code></pre><p>启动ssh的服务：</p><pre><code>systemctl start sshd.service</code></pre><p>设置开机自动启动ssh服务</p><pre><code>systemctl enable sshd.service</code></pre><p>配置远程ssh</p><p><a href="https://blog.csdn.net/qq_38834590/article/details/113105067" target="_blank" rel="noopener">参考文章 ssh安装配置</a></p><pre><code>在本地创建密钥ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa-remote-ssh将公钥上传到服务器将ssh key放到服务器上scp ~/.ssh/id_rsa.pub 用户名@ip:/home/id_rsa.pub此处将用户名和ip换成你的服务器账户和服务器ip。pbcopy &lt; ~/.ssh/id_rsa-remote-ssh.pub登录服务器并将公钥放到服务器ssh认证文件中cat /home/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys </code></pre><h3 id="Centos7上源码编译安装llvm-11-0-0"><a href="#Centos7上源码编译安装llvm-11-0-0" class="headerlink" title="Centos7上源码编译安装llvm 11.0.0"></a>Centos7上源码编译安装llvm 11.0.0</h3><h4 id="1-下载llvm-project"><a href="#1-下载llvm-project" class="headerlink" title="1. 下载llvm-project"></a>1. 下载llvm-project</h4><p>直接通过git clone，由于项目文件非常多，所以size很大。试了几次一直超时失败，无奈只能下载压缩包。</p><p>报错：</p><p>error: RPC failed; curl 18 transfer closed with outstanding read data remaining</p><p>​    fatal: The remote end hung up unexpectedly</p><p>​    fatal: early EOF</p><p>​    fatal: index-pack failed </p><p>解决：<a href="https://blog.csdn.net/it_liuchengli/article/details/77040806" target="_blank" rel="noopener">https://blog.csdn.net/it_liuchengli/article/details/77040806</a></p><p>下载压缩包 llvm-project-11.0.0.tar.xz，这个xz文件大小约80M。</p><pre><code>解压：xz -d llvm-project-11.0.0.tar.xz，生成了一个 802M 的tar包。再解：tar -xvf llvm-project-11.0.0.tar ，生成一个 ./llvm-project-11.0.0 目录cd llvm-project-11.0.0</code></pre><h4 id="2-升级gcc版本"><a href="#2-升级gcc版本" class="headerlink" title="2. 升级gcc版本"></a>2. 升级gcc版本</h4><p>编译llvm，需要gcc至少为 5.1版本，centos默认安装的是 gcc 4.8.5。</p><p>按照如下步骤升级了 gcc 到 7.3.1。</p><pre><code>yum install centos-release-sclyum install devtoolset-7当前登陆session生效scl enable devtoolset-7 bashsource /opt/rh/devtoolset-7/enable</code></pre><p>执行下列命令，永久生效</p><pre><code>echo "source /opt/rh/devtoolset-7/enable" &gt;&gt; ~/.bash_profile source /opt/rh/devtoolset-7/enable</code></pre><p>查看版本，已经是 7.3.1 了</p><pre><code>[root@localhost Downloads]# gcc --versiongcc (GCC) 7.3.1 20180303 (Red Hat 7.3.1-5)Copyright (C) 2017 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></pre><h4 id="3-编译安装llvm"><a href="#3-编译安装llvm" class="headerlink" title="3. 编译安装llvm"></a>3. 编译安装llvm</h4><p>在 llvm-project-11.0.0 目录中创建一个build目录</p><pre><code>mkdir buildcd build</code></pre><p>然后开始编译：</p><blockquote><p><strong><em>其中 -DLLVM_ENABLE_RTTI=ON 这个选项需要重点说明一下。由于我的目的是为了研究bpf技术，所以不可避免的会涉及到编译安装bpftrace这个工具。在编译bpftrace工程的时候如果没有打开 LLVM 的RTTI，会导致编译失败。而这个编译选项默认是关闭的，所以这里必须明确打开这个功能。</em></strong></p></blockquote><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzUyNGJjMjg3OTZjNGYyODQxMjI3NzQwOWE1YWZmZjFfeU12UkZhMWFsRlFqcTRJQWFlUVVZaDVMc2dCancySWxfVG9rZW46Ym94Y25VSVlOOTZFbEc4V0RXMTQ0SWhYOTBjXzE2MjcxNDg2Njk6MTYyNzE1MjI2OV9WNA" alt="img"></p><p>此命令用于检测 llvm 是否包含 rtti 特性</p><pre><code>cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_ENABLE_RTTI=ON -DLLVM_ENABLE_PROJECTS="clang;libcxx;libcxxabi" -G "Unix Makefiles" ../llvm</code></pre><p>然后 make，这个过程需要很长时间。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTgyM2RhY2U5NzYyZTNhMWVmMDAwMTZlYTRlY2Q1MGVfcm5LZWJudWZuaEZTMWxYUVZVZEZLTnNURGh3aGhScGlfVG9rZW46Ym94Y24xT0N4REU0a2d3d3NPc1VpZzFUQnFoXzE2MjcxNDg2Njk6MTYyNzE1MjI2OV9WNA" alt="img"></p><p>make成功，然后再 make install</p><p>报错可能需要 sudo make install</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDBiYjA5ODFkMTNiMzkxMDlkOGUzNDlmYzYxNGNhNjFfZjF5dUdqYlhQR1Y3OVBHUkhMTDBYalVRSnBpTXR2bklfVG9rZW46Ym94Y25pZEJwRkhPUXc0dXhXdG54eThleExRXzE2MjcxNDg2Njk6MTYyNzE1MjI2OV9WNA" alt="img"></p><p>clang 11.0.0，安装成功</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjFiZmFlNzYwYTdlNTNkNThhMmY5Y2FkZTk2NzYyZDVfdnNuWnpXbnQ3NmZPTkg1V0NEdG80RzBTcE1VSmR4Y2tfVG9rZW46Ym94Y25nNnE4alpuSkdRYlpoeTh0TXQyNXVmXzE2MjcxNDg2Njk6MTYyNzE1MjI2OV9WNA" alt="img"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统学习笔记</title>
      <link href="/posts/7537.html"/>
      <url>/posts/7537.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmRlZjU5OTllM2Y4NDg1MTJhY2I5MGY2YWNiZmE1MjlfQmFGeG1ydzhkRW9zNXd4ZWxZMjRmRzBHSUtKR1k1Y1RfVG9rZW46Ym94Y25Eakkzb3NxWVE3ejN1a3BGZkwxVTdnXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><h2 id="What-is-an-operating-system"><a href="#What-is-an-operating-system" class="headerlink" title="What is an operating system?"></a>What is an operating system?</h2><p>Layer between application and hardware</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmEwMjM0MWRkYmUzNzI2OGFlYjEyNTEwM2I5NDQ1YmFfSkplaEgxTThYT3VkV2pESzBwdmxQcHNRZkJlbURwR2hfVG9rZW46Ym94Y243ODhzMW91NTdHVG5aTFhWbThpc29mXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><h3 id="Primitive-Operating-Systems"><a href="#Primitive-Operating-Systems" class="headerlink" title="Primitive Operating Systems"></a>Primitive Operating Systems</h3><ul><li>Just a library of standard services</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTY1MDNiYzIxMDdhZmYwOTBlZGNlMDllZmVlMjZiMjhfaHJvVHZDdFExNDJmdUlocWVGWVhWTFdtR1hNazVrb1pfVG9rZW46Ym94Y25OYXlUMndOZTlkd1ZreEVxWTViUUd3XzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><h3 id="Multitasking"><a href="#Multitasking" class="headerlink" title="Multitasking"></a>Multitasking</h3><p>想法：当一个进程阻塞（等待磁盘、网络、用户输入等）运行另一个进程时，可以同时运行多个进程</p><p>问题：行为不良的进程能做什么？</p><p>操作系统提供了抢占机制来解决这些问题，使CPU远离循环进程；保护进程彼此的内存</p><h3 id="Multi-user-OSes"><a href="#Multi-user-OSes" class="headerlink" title="Multi-user OSes"></a>Multi-user OSes</h3><h3 id="Protection"><a href="#Protection" class="headerlink" title="Protection"></a>Protection</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTVmYjEyYTU2ZmIzNzQxOWQ3MWE5OWE4YTNiNTU2MjZfeWRSSEg2Tks4V1FRWmFZc01rc05pZUtDTENoek16dU9fVG9rZW46Ym94Y25XODQ0RFJNS25iUUJhZHdqVFQ1S0tnXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><h3 id="Typical-OS-structure"><a href="#Typical-OS-structure" class="headerlink" title="Typical OS structure"></a>Typical OS structure</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODZkMzVhMjc5OThiMTZjYTk4NzU1YTI1Y2E1ODk4OGNfZE1VZGsydlJ6TGJKQ1o2VUdmN2Y1ZHR1a3FaZ2RMVThfVG9rZW46Ym94Y245dUlzaWRra1pLVHVTR1NSclNkcG9mXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><h3 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGFlZWRlYzMxOWM3MGRlNjBkNDY2MGQ1Y2IwNGI4OTJfV2J5TWEzOVRwSnBUUXMzM25ZVVJjektkVUJKcWZhUGFfVG9rZW46Ym94Y25CUFFtQTZZb0FZbXF0OTlOakxlanNnXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><p>Example</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTE0NDlkMTJjMDJmNGNlZTExMzhjMGU1ZDU3MGQxZmVfZ1p4UThuaDYydG1KeVI1RnBUNmxlanJCV2MwMER2MDlfVG9rZW46Ym94Y25oRFo5WTdTZWtTNzZsNnJIRjk2Q01nXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><h3 id="UNIX-file-system-calls"><a href="#UNIX-file-system-calls" class="headerlink" title="UNIX file system calls"></a>UNIX file system calls</h3><h3 id="Error-returns"><a href="#Error-returns" class="headerlink" title="Error returns"></a>Error returns</h3><h3 id="Operations-on-file-descriptors"><a href="#Operations-on-file-descriptors" class="headerlink" title="Operations on file descriptors"></a>Operations on file descriptors</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjcyM2NhNmUxZmFjN2NkMWMzMTA2YmNkZGQ5ZTRlMDlfRm1xalI3Um51NkZSdmRFSFVBYm9GSm5wMGdPSWN0SVhfVG9rZW46Ym94Y25ZVVBBV2dOY1NpalRUcU1wNmRzNERlXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><h3 id="File-descriptor-numbers"><a href="#File-descriptor-numbers" class="headerlink" title="File descriptor numbers"></a>File descriptor numbers</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODU0OTlmOTcwMzNlZjRiNTZmZTllMWM2ZTBjNjBhNTBfY1pBcHg3VmpvSzZNMk5tQXpxSUhzTlpDbjk3SWNyeTNfVG9rZW46Ym94Y25mT1kxZnVMQUVjVUJ4NDZ6QVZYSUlkXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDhjNTdlZDg1NTYxZTMyYzE2YzAxYTg5YjliZjRmMjRfdE9idVBobkdpRzM2Rktablp5N3dPZFFFR0JBSVJhVGpfVG9rZW46Ym94Y25RR1Exbzg5RWlNQWptaFh0NW1WbVFiXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><h3 id="Protection-example-CPU-preemption"><a href="#Protection-example-CPU-preemption" class="headerlink" title="Protection example: CPU preemption"></a>Protection example: CPU preemption</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTY3YWNmMzE5YjkyZjE3N2FiMjYxZWFlNzQ3MjQ3MTZfbHFIWEN4ZlFYQW4xNXJzSThhWWtkQ04wWk5qcjdjeURfVG9rZW46Ym94Y25nenE2cTJrWXRuOVp6RkVtMllGTUZlXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><h3 id="Address-translation"><a href="#Address-translation" class="headerlink" title="Address translation"></a>Address translation</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODI1ZWNmMjFiNDFjOWNhNGI3NGZmNDg3OWE4N2NmNjVfY2FLcTVXVjdwak9LN2RVa3dac1g3RlFhVDFMSXJqWU1fVG9rZW46Ym94Y25GRldmSDJObmZOaHVHTVBDdmEwZk5lXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><h3 id="More-memory-protection"><a href="#More-memory-protection" class="headerlink" title="More memory protection"></a>More memory protection</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2YzZTYwYjRiYmU3NDI2MmM3MTJhNDUyMWUwMjc4MTRfM0lZbUZTRFV3ZnhORWppU0c5MUMwQlRDUGpvOTdIdzJfVG9rZW46Ym94Y25OOGNhQWRTREd6b2xXN2F2QWtwTDZiXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><h2 id="Threads-amp-Processes"><a href="#Threads-amp-Processes" class="headerlink" title="Threads &amp; Processes"></a>Threads &amp; Processes</h2><h3 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h3><p>A processis an instance of a program running</p><p>Why processes?</p><ul><li>Simplicity of programming</li><li>Speed: Higher throughput, lower latency</li></ul><h4 id="Speed"><a href="#Speed" class="headerlink" title="Speed"></a>Speed</h4><p>Multiple processes can increase CPU utilization</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTRmNzFjMTAzNjBkYmFkNDQ1MzQxMDdkYThkNmQwYjBfdW1BSXFMdktNWUo0UHZER2RnbGtDYWRCME9xcGhnQ0FfVG9rZW46Ym94Y25hQ2U1ak1md3lCWk9KMloyR2RJMVJSXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><p>Multiple processes can reduce latency</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzUzYzcyMTZhODM4NmIyNTgyZGI1MjdmYmU4ZTgxMWNfYjVrVzFrWjZXaWJhemluSzdsZ0M3bkJzemRnSXJZQTJfVG9rZW46Ym94Y251ajlxVnN5SzZRSkt3ZG5nb252NTNnXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><p>A process’s view of the world</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzE2NmFhNzIxMGQ5NzVjOWE3NTk1MDhjNTcwNjQzOGNfWTR0aGs5dzV3S2g2M0Z4T3hrd25yZHp3Sk9lZDVwZlhfVG9rZW46Ym94Y252c05GNGh5MVA3eElGNnoyZXFCNnBiXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><p>How can processes interact in real time?</p><ul><li>By passing messages through the kernel</li><li>By sharing a region of physical memory</li><li>Through asynchronous signals or alerts</li></ul><h3 id="UNIX-centric-User-view-of-processes"><a href="#UNIX-centric-User-view-of-processes" class="headerlink" title="(UNIX-centric) User view of processes"></a>(UNIX-centric) User view of processes</h3><p>Creating processes</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDQ5YzFjYjY2OGVlY2FlYTYzYzM0MmNjNTQ4ODQ3MGRfUkR6dmZ0RkpveWo2N0UzaTF1azJBZUVsRDZ2TjZtc3pfVG9rZW46Ym94Y250UDJrbVVucWhHblAzUTg3N3czcmpoXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><p>Deleting processes</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTVjNzI2ZmY1ZjA0NTk3ZTlhZjUxNDc2OWU0MjAyNTVfN0E4bzlkQWVyOU1QMmg3Yk9qZWRTNzdES21mRHl0a05fVG9rZW46Ym94Y242UVlUWGdFNWM1bjJ6aG4xeXlzdzZjXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><p>Running programs</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTBlMDExMWVhZmI4Y2FjZjhiMjNhMTdjNzg5NGI3MzRfV3p1TG44RVlaNkVMMUpoek1saDFmcERLWU9BODlWNktfVG9rZW46Ym94Y24xb3RWaHprakMzeHJSWW1mYlJla2liXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><p>Manipulating file descriptors</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTA0NDFmNDJmNDE5MTI5YmU1OTdjMjAxYmFkOWY4ODlfZmJ1d3ZvcmVablFIcUtHaFVXTHZOdjNCdE05NHd3eFJfVG9rZW46Ym94Y25jajBYcEplT0RyYndGU1hnaFlvTlFkXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><p>Pipes</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTZjNWQzMTJmYWQyNjU2N2MwNTIxN2QzMTU2M2UzM2VfMDBMdVNPOFFYcXR1MDNiT05XakdTV21GbnRGcGtHc2VfVG9rZW46Ym94Y25QYzBnd0ZjcnNvdEJaVFNuZ1VQbHRkXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><h3 id="Kernel-view-of-processes"><a href="#Kernel-view-of-processes" class="headerlink" title="Kernel view of processes"></a>Kernel view of processes</h3><h4 id="Implementing-processes"><a href="#Implementing-processes" class="headerlink" title="Implementing processes"></a>Implementing processes</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmVjNDYxODk5YzczN2Q1OTNjMjI3MzcwZTA3MThkODJfdTFCZFRyRk1Hekt5S3BDQ2R3ZzZHM3FkeWltejVDM1RfVG9rZW46Ym94Y25QTlpSd0M0Z0tuSXF1eVZIclhEMjNiXzE2MjcxNDg0OTY6MTYyNzE1MjA5Nl9WNA" alt="img"></p><h3 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h3><h3 id="Thread-implementation-details"><a href="#Thread-implementation-details" class="headerlink" title="Thread implementation details"></a>Thread implementation details</h3><h2 id="Concurrency-amp-Synchronization（并发与同步）"><a href="#Concurrency-amp-Synchronization（并发与同步）" class="headerlink" title="Concurrency &amp; Synchronization（并发与同步）"></a>Concurrency &amp; Synchronization（并发与同步）</h2><h2 id="Scheduling（调度）"><a href="#Scheduling（调度）" class="headerlink" title="Scheduling（调度）"></a>Scheduling（调度）</h2><h2 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h2><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h2 id="Disks-File-systems"><a href="#Disks-File-systems" class="headerlink" title="Disks, File systems"></a>Disks, File systems</h2><h2 id="Protection-amp-Security"><a href="#Protection-amp-Security" class="headerlink" title="Protection &amp; Security"></a>Protection &amp; Security</h2><h2 id="Virtual-machines"><a href="#Virtual-machines" class="headerlink" title="Virtual machines"></a>Virtual machines</h2><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1 绪论"></a>1 绪论</h2><h3 id="1-1-操作系统概述"><a href="#1-1-操作系统概述" class="headerlink" title="1.1 操作系统概述"></a>1.1 操作系统概述</h3><h4 id="1-1-1-计算机系统构成的认识"><a href="#1-1-1-计算机系统构成的认识" class="headerlink" title="1.1.1 计算机系统构成的认识"></a>1.1.1 计算机系统构成的认识</h4><p>计算机系统 = 硬件系统 + 软件系统。</p><p>硬件资源：中央处理器、存储器、输入输出设备（通道和控制器）。</p><p>软件资源：文件（系统软件 应用软件 均以文件方式存放）。</p><p>微型机的硬件组织：总线结构。</p><p>大中小型计算机的硬件结构：非总线结构。</p><h4 id="1-1-2-命令、任务、进程、作业"><a href="#1-1-2-命令、任务、进程、作业" class="headerlink" title="1.1.2 命令、任务、进程、作业"></a>1.1.2 命令、任务、进程、作业</h4><p>命令：从命令窗口发给系统的指示。</p><p>任务：系统中的应用程序做的事情。</p><p>进程：程序的一次执行过程。</p><p>作业：用户提交给计算机进行加工处理的一个完整的任务。</p><h4 id="1-1-3-操作系统的定义和地位"><a href="#1-1-3-操作系统的定义和地位" class="headerlink" title="1.1.3 操作系统的定义和地位"></a>1.1.3 操作系统的定义和地位</h4><p>操作系统：管理系统资源并向用户提供服务接口的程序集合，是最基本的系统软件。</p><p>操作系统的目标：方便用户、提高资源利用率、改善系统性能。</p><p>另一种定义：计算机系统中的一个系统软件，是一些程序模块的集合——它管理和控制计算机系统的软硬件资源，合理的组织计算机的工作流程，以便有效利用这些资源为用户提供一个功能强大、使用方便和可扩展的工作环境，在计算机和其用户之间起到接口作用。</p><p>简要定义：用于控制和管理系统资源，方便用户使用计算机的程序的集合。</p><h4 id="1-1-4-研究操作系统的四种观点"><a href="#1-1-4-研究操作系统的四种观点" class="headerlink" title="1.1.4 研究操作系统的四种观点"></a>1.1.4 研究操作系统的四种观点</h4><p>资源管理的观点（静态观点）。</p><p>操作系统是由对系统资源进行管理的四个内核模块（进程管理、存储管理、设备管理、文件管理）和向用户提供服务接口的一个外壳模块（作业管理或其命令处理）组成。</p><p>资源管理包括三个方面：资源使用情况记录、资源的分配策略、资源的分配与回收等。</p><p>用户（界面）观点。</p><p>操作系统是用户和计算机之间的接口。用户不必关心操作系统的内部结构，只关心如何利用其功能使用计算机，因此，提供什么样的界面成为关键问题。</p><p>命令级的接口：联机命令接口（交互式用户接口）、脱机命令接口（批处理用户接口）。</p><p>程序级的接口（系统调用）：程序通过系统调用来调用操作系统的功能，这种调用由特殊的机器指令实现，执行时将引起中断，称为软中断。汇编语言级别上提供全部的系统调用，其它语言以自己的形式全部或部分的提供。</p><p>进程观点（动态观点）。</p><p>操作系统是由若干个可以同时独立运行的进程和一个对它们进行管理、协调的系统核心组成。</p><p>进程：一个具有独立功能的程序对某个数据集在处理机上的运行过程。</p><p>进程的构成：程序、数据、进程控制块。</p><p>进程控制块：简称PCB。是包含进程描述信息和控制信息的数据结构，是进程动态特性的集中反映，是进程存在的唯一标志。</p><p>进程构成的物理表示：程序和数据混合、程序和数据分离、基本共享模式。</p><p>▲ 进程基本状态转换图。</p><p>分层观点（虚拟机观点）。</p><p>通过一层层软件扩充，操作系统把裸机扩展为功能更强大使用更方便的虚拟机。</p><h3 id="1-2-操作系统的发展历程"><a href="#1-2-操作系统的发展历程" class="headerlink" title="1.2 操作系统的发展历程"></a>1.2 操作系统的发展历程</h3><h4 id="1-2-1-操作系统的形成"><a href="#1-2-1-操作系统的形成" class="headerlink" title="1.2.1 操作系统的形成"></a>1.2.1 操作系统的形成</h4><p> 手工操作阶段、批处理阶段、执行系统阶段。</p><h4 id="1-2-2-手工操作阶段"><a href="#1-2-2-手工操作阶段" class="headerlink" title="1.2.2 手工操作阶段"></a>1.2.2 手工操作阶段</h4><p>操作过程：用户将程序和数据纸带装上输入机，启动输入机，通过控制开关启动程序运行。</p><p>特点：用户直接与计算机硬件打交道，靠控制台面板来控制主机和外设；用户独占全机资源；用户既是程序员又是操作员 。</p><p>主要缺点：慢速设备输入输出是联机的，浪费CPU时间；作业之间的转接有由手工操作，浪费时间。</p><h4 id="1-2-3-早期批处理阶段"><a href="#1-2-3-早期批处理阶段" class="headerlink" title="1.2.3 早期批处理阶段"></a>1.2.3 早期批处理阶段</h4><p>作业处理步骤：操作员把若干纸带合成一批，通过输入设备将它们存入磁带；监督程序读一个系统资源能满足其要求的作业进入内存；将程序编译；装配成可执行程序；执行程序 ；善后处理程序输出计算结果；处理下一个作业。</p><p>特点：配备专门的操作员；进行批处理，每一批作业由专门编制的监督程序自动一次处理；多个步骤之间的转接自动完成不需要人工干预。</p><p>联机批处理：CPU直接控制慢速输入输出设备。</p><p>脱机批处理：慢速输入输出设备由外围处理机控制。</p><h4 id="1-2-4-多道批处理系统"><a href="#1-2-4-多道批处理系统" class="headerlink" title="1.2.4 多道批处理系统"></a>1.2.4 多道批处理系统</h4><p>多道批处理系统的特征</p><p>多道：内存中同时存放多个作业或者程序。</p><p>宏观上并行 ：内存中的多个程序都处于运行状态。</p><p>微观上串行：各道程序轮流使用CPU，交替执行。</p><p>在当前运行的程序需作I/O处理时，CPU转而执行另一个程序。</p><p>多道程序系统必备的硬件基础是中断技术。</p><h4 id="1-2-5-分时系统操作"><a href="#1-2-5-分时系统操作" class="headerlink" title="1.2.5 分时系统操作"></a>1.2.5 分时系统操作</h4><p>批处理系统的显著缺点：没有交互能力，用户无法干预自己作业的运行，使用起来不方便；用户作业可能需要等待很长时间才能得到运行。</p><p>分时系统的主要特征：</p><p>多路性/同时性：宏观上同时有多个用户在运行。</p><p>交互性：在终端上编辑、运行程序，或其它操作。</p><p>独占性：每个用户一个终端，独立操作，互不干扰。</p><h4 id="1-2-6-实时操作系统"><a href="#1-2-6-实时操作系统" class="headerlink" title="1.2.6 实时操作系统"></a>1.2.6 实时操作系统</h4><p>能对随机发生的外部事件作出及时响应和处理。</p><p>对响应事件和可靠性有很高要求和严格限度的系统。</p><h4 id="1-2-7-通用操作系统"><a href="#1-2-7-通用操作系统" class="headerlink" title="1.2.7 通用操作系统"></a>1.2.7 通用操作系统</h4><p>是在实时系统之后，为使系统应用范围更广泛，处理能力更强，有些系统兼有实时、分时和批处理的两种，或三种处理能力，从而形成通用操作系统。</p><p>当代同时具备两种以上功能的系统有很多，例如：</p><p>UNIX操作系统：SUN公司的Solaris。</p><p>Microsoft公司的Windows系列。</p><p>Linux操作系统：Redhat，红旗Linux等。</p><h3 id="1-4-操作系统的特性"><a href="#1-4-操作系统的特性" class="headerlink" title="1.4 操作系统的特性"></a>1.4 操作系统的特性</h3><p>并发性：存在许多同时或并行的活动。</p><p>CPU与外设之间。</p><p>内存中的多道程序在宏观上并行。</p><p>外设之间。</p><p>共享性：并发的程序共同使用系统的软硬件资源。</p><p>虚拟性：把一个物理上的实体变成了若干个逻辑上的对应物。</p><p>不确定性：系统中同时存在的多个程序的执行次序及每个程序的执行所花费的时间一般是不可再现的。</p><h3 id="1-5-操作系统的性能"><a href="#1-5-操作系统的性能" class="headerlink" title="1.5 操作系统的性能"></a>1.5 操作系统的性能</h3><p>可靠性：平均无故障时间长 MTBF。</p><p>可修复性：平均故障修复时间段 MTRF。</p><p>可用性：正常使用率高 A=MTBF/(MTBF+MTRF)A=MTBF/(MTBF+MTRF)。</p><p>效率</p><p>吞吐量：单位时间内所处理的平均类型作业数量。</p><p>响应时间：从给定系统输入到开始输出这段时间间隔平均作业周转时间。</p><p>系统资源利用率。</p><p>可维护性：排除故障、改进和扩充功能。</p><p>方便性（友好的用户界面）：操作使用简单易学，给出尽可能多的提示信息。</p><h2 id="2-用户界面和作业管理"><a href="#2-用户界面和作业管理" class="headerlink" title="2 用户界面和作业管理"></a>2 用户界面和作业管理</h2><h3 id="2-1-作业的基本概念"><a href="#2-1-作业的基本概念" class="headerlink" title="2.1 作业的基本概念"></a>2.1 作业的基本概念</h3><h4 id="2-1-1-作业的定义"><a href="#2-1-1-作业的定义" class="headerlink" title="2.1.1 作业的定义"></a>2.1.1 作业的定义</h4><p>作业：用户要求计算机完成的一次业务处理的全部工作。</p><p>作业步：作业处理的一个步骤，通常是执行一条操作系统的简单命令。</p><p>”编译——链接——执行“是一个典型的作业。</p><p>早期DOS系统下一个扩展名为bat的批处理文件的内容，相当于一个作业说明书。</p><h4 id="2-1-2-作业的组织"><a href="#2-1-2-作业的组织" class="headerlink" title="2.1.2 作业的组织"></a>2.1.2 作业的组织</h4><p>作业的组成：一批程序、一批数据、一个作业说明书。</p><p>作业说明书的核心内容是作业步的操作顺序（类似于.bat文件）。</p><h4 id="2-1-3-作业的状态及其转换"><a href="#2-1-3-作业的状态及其转换" class="headerlink" title="2.1.3 作业的状态及其转换"></a>2.1.3 作业的状态及其转换</h4><p>进入状态：从作业输入请求到进入输入井并建立作业控制块JCB。</p><p>后备状态：从建立作业控制块到被作业调度选中。</p><p>运行状态：从被作业调度选中进入内存到作业运行结束。</p><p>完成状态：从作业运行结束到作业被撤销。</p><h3 id="2-2-作业的建立"><a href="#2-2-作业的建立" class="headerlink" title="2.2 作业的建立"></a>2.2 作业的建立</h3><p>作业的建立包括作业的输入和作业控制块的建立。</p><p>作业的输入：作业的程序、数据和作业说明书从输入设备输入到外存。</p><h4 id="2-2-1-作业的输入方式"><a href="#2-2-1-作业的输入方式" class="headerlink" title="2.2.1 作业的输入方式"></a>2.2.1 作业的输入方式</h4><p>联机输入方式：由慢速输入设备输入作业到主机外设 ，该设备由主机控制。</p><p>脱机输入方式：在低档的个人计算机上把作业输入到磁盘或磁带上，然后把盘或带放在主机上输入到主机外存上。</p><p>直接耦合输入方式：在外围处理机上把作业直接输入到主机直接相连的外存上。</p><p>Spooling输入方式：由一个进程通过执行Spooling的预输入程序控制通道来模拟外围处理机负责作业输入工作。</p><p>由通道控制外设的输入输出，很大程度上达到了“脱机”的效果，但通道受主机控制，这与脱机方式下的外围处理机独立工作不同，所以Spooling技术又称为假脱机输入输出技术。</p><p>网络输入方式：一台主机上输入的信息通过网络传输到另一台主机上。</p><h4 id="2-2-2-作业控制块的建立"><a href="#2-2-2-作业控制块的建立" class="headerlink" title="2.2.2 作业控制块的建立"></a>2.2.2 作业控制块的建立</h4><p>作业控制块：JCB（Job Control Block）。</p><p>JCB是内存中的一个数据结构，与作业一一对应，包含了系统对作业进行管理所必须的信息。</p><h3 id="2-3-作业的建立"><a href="#2-3-作业的建立" class="headerlink" title="2.3 作业的建立"></a>2.3 作业的建立</h3><p>JCB通常包含下列信息：</p><p>用户名：作业所属的用户作业名称。</p><p>作业建立时间：为作业调度算法提供参数。</p><p>作业估计运行时间：为作业调度算法提供参数同时避免作业死循环时无限占用CPU。</p><p>优先数：表示作业的紧迫程度，它可以由用户给出，也可以由系统根据某种原则设定。</p><p>作业说明书文件：作业说明书是控制作业执行的依据。</p><p>程序语言类型：为了更有效地调用有关子系统。</p><p>作业状态：进入、后备、运行、完成。</p><p>资源要求：用户可在作业说明书中提出资源要求，也可由作业执行时在程序中提出。</p><p>作业类型：I/O型、CPU型、均衡型。</p><h3 id="2-4-Spooling技术"><a href="#2-4-Spooling技术" class="headerlink" title="2.4 Spooling技术"></a>2.4 Spooling技术</h3><p>Spooling通常包含下列程序：预输入、取输入、存输出、缓输出、井管理。</p><p>预输入：预先把作业（数据）从慢速输入设备传输到输入井。</p><p>取输入：作业调度时或运行时从输入井中取作业（数据）。</p><p>存输出：作业运行中把向慢速输出设备的输出存入输出井。</p><p>缓输出：作业终止后把作业在输出井的输出结果集中输出。</p><p>虚拟设备：利用某种技术（例如SPOOLing 技术）把一台独享的物理设备变换成若干台逻辑上的对应物，称这些对应物为虚拟设备。</p><p>被虚拟化的设备：经过SPOOLing技术处理的设备。</p><h3 id="2-5-作业调度"><a href="#2-5-作业调度" class="headerlink" title="2.5 作业调度"></a>2.5 作业调度</h3><p>作业调度也叫高级调度，其任务是选择后备作业将其调入内存。</p><p>作业调度的关键是选择适当的算法。</p><h4 id="2-5-1-工作过程"><a href="#2-5-1-工作过程" class="headerlink" title="2.5.1 工作过程"></a>2.5.1 工作过程</h4><p>按调度算法从后备作业队列中选择一个作业。</p><p>为选中作业分配必要的资源，创建相应的作业控制过程。</p><p>内存：用于装载作业说明书。</p><p>外设（静态分配）：作业说明书中申请的独享设备。</p><p>将该作业的状态从后备改为运行，相应作业控制进程就绪。</p><h4 id="2-5-2-调度算法的选择"><a href="#2-5-2-调度算法的选择" class="headerlink" title="2.5.2 调度算法的选择"></a>2.5.2 调度算法的选择</h4><p>选择的调度算法要与系统的整个目标一致。</p><p>注意系统资源的均衡使用（I/O型、CPU型作业搭配）。</p><p>应保证提交的作业在规定的截止时间完成。</p><h4 id="2-5-3-单道批处理系统的作业调度算法"><a href="#2-5-3-单道批处理系统的作业调度算法" class="headerlink" title="2.5.3 单道批处理系统的作业调度算法"></a>2.5.3 单道批处理系统的作业调度算法</h4><p>先来先服务 FCFS。</p><p>最短作业优先 SJF。</p><p>优先级高者优先。</p><p>相应比高者优先 HRN。</p><p>响应比=作业相应时间/作业估计运行时间=（作业后备等待时间+作业估计运行时间）/作业估计运行时间响应比=作业相应时间/作业估计运行时间=（作业后备等待时间+作业估计运行时间）/作业估计运行时间</p><h3 id="2-6-作业控制"><a href="#2-6-作业控制" class="headerlink" title="2.6 作业控制"></a>2.6 作业控制</h3><p>作业控制就是控制作业的运行，由作业控制程序完成。</p><p>作业控制程序——通过解释执行作业说明书来控制作业的运转过程的程序。又可称为作业控制语言解释程序。</p><p>作业说明书——用 JCL 语言编写的程序，是比一般用户程序高一级的程序。</p><h3 id="2-7-作业终止和作业撤销"><a href="#2-7-作业终止和作业撤销" class="headerlink" title="2.7 作业终止和作业撤销"></a>2.7 作业终止和作业撤销</h3><p>作业终止：当作业控制程序解释执行完作业说明书后，调用作业终止程序，该程序回收作业调度时分给作业的资源，并把其状态改为完成。</p><p>作业撤销：当作业的所有输出结果从输出井向输出设备输出完成后，作业撤销程序被调用，它通过释放作业控制块等来撤销作业。</p><h3 id="2-8-分时作业的管理"><a href="#2-8-分时作业的管理" class="headerlink" title="2.8 分时作业的管理"></a>2.8 分时作业的管理</h3><p> 可以说，分时系统中作业的概念已很淡化了，对分时作业的管理也很简化。分时作业JCB与分时进程的PCB表合而为一了，对分时作业的管理已简化为对终端进程的管理，对分时作业的控制是靠命令语言解释程序实施的。</p><h3 id="2-9-操作系统与用户之间的接口"><a href="#2-9-操作系统与用户之间的接口" class="headerlink" title="2.9 操作系统与用户之间的接口"></a>2.9 操作系统与用户之间的接口</h3><h4 id="2-9-1-命令级接口"><a href="#2-9-1-命令级接口" class="headerlink" title="2.9.1 命令级接口"></a>2.9.1 命令级接口</h4><p>联机命令接口（交互式用户接口）</p><p>联机命令接口由联机命令（终端命令）、终端字符处理程序和命令处理程序组成。</p><p>用户键入的终端命令由命令处理程序解释执行，其相应的程序代码，可以包含在命令处理程序，也可以放在一个可执行文件。</p><p>按照终端命令对应的程序代码的所属分类：内部命令、外部命令、批处理命令。</p><p>按命令的功能分类：系统访问命令、文件管理命令、编辑编译链接和执行命令、调试命令、其它。</p><p>DOS系统中的命令的优先顺序为内部命令、外部命令、批处理命令。</p><p>脱机命令接口（批处理用户接口）</p><p>操作系统的用户看到的脱机命令接口就是JCL。</p><h4 id="2-9-2-程序级接口（系统调用）"><a href="#2-9-2-程序级接口（系统调用）" class="headerlink" title="2.9.2 程序级接口（系统调用）"></a>2.9.2 程序级接口（系统调用）</h4><p>在程序级上调用操作系统功能。</p><p>系统调用：与文件有关的系统调用、与I/O设备有关的系统调用、与进程有关的系统调用、其它系统调用。</p><h2 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3 进程管理"></a>3 进程管理</h2><h3 id="3-1-顺序程序和并发程序"><a href="#3-1-顺序程序和并发程序" class="headerlink" title="3.1 顺序程序和并发程序"></a>3.1 顺序程序和并发程序</h3><p>顺序程序的特性：</p><p>顺序性：每一个操作都在前一个操作执行完后才能开始。处理机的操作是严格按照程序所规定的次序进行的。</p><p>封闭性：程序执行得到的最终结果由给定的初始条件决定，不受外界因素的影响。</p><p>可再现性：程序执行得到的最终结果与执行速度无关。只要输入的初始条件相同，则无论何时重复执行该程序都会得到相同的结果。</p><p>并发程序的特性：</p><p>非可再现性：并发程序的执行结果与它们的相对速度有关。</p><p>共享性：共享同一段程序；共享系统资源。</p><p>通信性：并发程序之间相互依赖和制约。</p><h3 id="3-2-进程及其状态变化"><a href="#3-2-进程及其状态变化" class="headerlink" title="3.2 进程及其状态变化"></a>3.2 进程及其状态变化</h3><h4 id="3-2-1-进程的定义及其特征"><a href="#3-2-1-进程的定义及其特征" class="headerlink" title="3.2.1 进程的定义及其特征"></a>3.2.1 进程的定义及其特征</h4><p>进程：一个具有独立功能的程序对某个数据集在处理机上的一次运行过程。</p><p>进程具有两个基本特征：动态性、并发性。</p><h3 id="3-3-进程构成及进程控制块"><a href="#3-3-进程构成及进程控制块" class="headerlink" title="3.3 进程构成及进程控制块"></a>3.3 进程构成及进程控制块</h3><h4 id="3-3-1-进程的构成"><a href="#3-3-1-进程的构成" class="headerlink" title="3.3.1 进程的构成"></a>3.3.1 进程的构成</h4><p>进程构成：程序、数据、进程控制块。</p><p>进程控制块（PCB）：是包含进程的描述信息和控制信息的数据结构，是进程动态特性的集中反映，是进程存在的唯一标志。</p><p>每一个进程都有一个进程控制块，进程与进程控制块一一对应。</p><p>所有进程的控制块构成了系统的进程控制块表。</p><p>进程控制表可以定义为一个结构数组，系统初始时均为空闲。</p><p>每当创建一个进程，操作系统就为此进程分配一个空闲的进程控制块并填写相应信息。</p><p>每当撤销一个进程，操作系统就释放此进程占用的进程控制块并把其置为空闲。</p><h3 id="3-4-进程调度"><a href="#3-4-进程调度" class="headerlink" title="3.4 进程调度"></a>3.4 进程调度</h3><h4 id="3-4-1-调度的基本概念"><a href="#3-4-1-调度的基本概念" class="headerlink" title="3.4.1 调度的基本概念"></a>3.4.1 调度的基本概念</h4><p>高级调度（作业调度）：从后备作业中选取若干个作业到内存投入运行。</p><p>中级调度（交换调度）：将进程的程序和数据在内存和外存交换区之间的调入调出。</p><p>低级调度（进程调度、线程调度）：按照某种策略和方法选取一个处于就绪状态的进程或线程占用处理机。</p><h4 id="3-4-2-进程调度算法"><a href="#3-4-2-进程调度算法" class="headerlink" title="3.4.2 进程调度算法"></a>3.4.2 进程调度算法</h4><p>先进先出（FIFO）调度算法。</p><p>最高优先权（FPF）调度算法。</p><p>静态优先级算法：进程的优先级在被创建时确定，在整个运行期间不再改变。</p><p>动态优先级算法：基于某种原则，使进程的优先级随着时间而改变。</p><p>时间片轮转算法。</p><p>多级队列算法。</p><h3 id="3-5-进程互斥"><a href="#3-5-进程互斥" class="headerlink" title="3.5 进程互斥"></a>3.5 进程互斥</h3><p>系统中本来没有逻辑关系的多个进程因为竞争使用资源而产生的间接制约关系。</p><p>临界资源：只允许进程依次地（互斥地）使用的资源。</p><p>临界区：只允许进程依次地（互斥地）进入的程序段，其中含有对共享的变量、表格、队列等临界资源的访问操作。</p><p>同类临界区：含有对同一临界资源进行访问操作的不同程序段。</p><h4 id="3-5-1-实现临界区互斥的几种方法"><a href="#3-5-1-实现临界区互斥的几种方法" class="headerlink" title="3.5.1 实现临界区互斥的几种方法"></a>3.5.1 实现临界区互斥的几种方法</h4><p>开关中断法：关中断、临界区、开中断。</p><p>锁操作法 ：Lock w、临界区、Unlock w。</p><p>PV操作法：P(m)、临界区、V (m)。</p><h4 id="3-5-2-PV操作及其原理"><a href="#3-5-2-PV操作及其原理" class="headerlink" title="3.5.2 PV操作及其原理"></a>3.5.2 PV操作及其原理</h4><h3 id="3-7-死锁及其对策"><a href="#3-7-死锁及其对策" class="headerlink" title="3.7 死锁及其对策"></a>3.7 死锁及其对策</h3><h4 id="3-7-1-死锁及其产生条件"><a href="#3-7-1-死锁及其产生条件" class="headerlink" title="3.7.1 死锁及其产生条件"></a>3.7.1 死锁及其产生条件</h4><p>死锁：若干进程循环等待对方所占资源，并且无休止地等待下去。</p><p>产生死锁的四个必要条件：</p><p>互斥条件：即每一个资源每次只能分配给一个进程。</p><p>非剥夺式分配：即只能由获得资源进程自己释放所占用的资源。</p><p>部分分配：即进程每次只申请其最大资源需求量的一部分。</p><p>循环等待：发生死锁时，必然存在一个进程—资源的循环链。</p><h4 id="3-7-2-死锁的对策"><a href="#3-7-2-死锁的对策" class="headerlink" title="3.7.2 死锁的对策"></a>3.7.2 死锁的对策</h4><p>死锁的预防：系统设计时的对策。</p><p>资源的先释放再分配法（破坏第二个必要条件）。</p><p>资源的静态分配法（破坏第三个必要条件）。</p><p>资源的顺序使用法（破坏第四个必要条件）。</p><p>死锁的避免：系统运行过程中避免死锁的发生。</p><p>每次系统处理进程申请资源的请求时，都根据一定的算法（死锁避免算法）判断是否许可这次申请，使得在以后一段时间内不会因本次资源分配而产生死锁。</p><p>死锁的检测与恢复：定期检测有无死锁发生，如发现死锁则恢复之。</p><p>银行家算法：</p><p>银行家拥有一笔周转资金。</p><p>客户要求分期贷款，如果客户能够得到各期贷款，就一定能够归还贷款，否则就一定不能归还贷款。</p><p>银行家应谨慎的贷款，防止出现坏帐。</p><p>用银行家算法避免死锁</p><p>操作系统（银行家）。</p><p>操作系统管理的资源(周转资金)。</p><p>进程（要求贷款的客户）</p><h4 id="3-7-3-死锁的对策"><a href="#3-7-3-死锁的对策" class="headerlink" title="3.7.3 死锁的对策"></a>3.7.3 死锁的对策</h4><p>死锁的检测与恢复</p><p>系统不对资源的分配和使用进行限制，允许死锁的发生（可能性很小），系统定期检测有无死锁的发生，若有则恢复之。</p><p>死锁的几种解除方法</p><p>终止所有死锁的进程。</p><p>依次终止死锁的进程，直至死锁不存在。</p><p>依次强迫释放死锁的进程所占用的资源，直至死锁不存在。</p><p><a href="https://blog.csdn.net/qq_39326472/article/details/88828361" target="_blank" rel="noopener">一篇不错的操作系统笔记</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS | Computer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理学习笔记</title>
      <link href="/posts/87a4.html"/>
      <url>/posts/87a4.html</url>
      
        <content type="html"><![CDATA[<h3 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h3><h4 id="计算机系统的多层次结构"><a href="#计算机系统的多层次结构" class="headerlink" title="计算机系统的多层次结构"></a>计算机系统的多层次结构</h4><p>微程序设计级、一般机器级、操作系统级、汇编语言级、高级语言级。</p><p><strong>硬件：</strong> </p><p>第1级：微程序机器层M0（微指令系统），由硬件直接执行微指令</p><p>第2级：传统机器M1（机器语言机器），用微程序解释机器指令</p><p><strong>软件：</strong> </p><p>第3级：虚拟机器M2（操作系统机器），用机器语言解释操作系统</p><p>第4级：汇编语言M3（汇编语言机器），用汇编程序翻译成机器语言程序</p><p>第5级：虚拟机器M4（高级语言机器），用编译程序翻译成汇编语言程序</p><h4 id="冯·诺依曼机"><a href="#冯·诺依曼机" class="headerlink" title="冯·诺依曼机"></a>冯·诺依曼机</h4><ul><li>基本工作方式：控制流驱动方式；</li><li>最根本的特征：采用“存储程序”原理，即按地址访问并顺序执行指令；</li><li>指令和数据均以二进制形式存放在存储器中；</li><li>CPU区分依据是：指令周期的不同阶段。</li><li>冯·诺依曼计算机：以运算器为中心</li><li>现代的计算器：以存储器为中心</li><li>5大部件：存储器、运算器、控制器、输入设备、输出设备（适配器）</li><li>三大部分：CPU（运算器、控制器）、I/O设备（输入设备、输出设备）、主存储器</li></ul><h4 id="哈佛结构"><a href="#哈佛结构" class="headerlink" title="哈佛结构"></a>哈佛结构</h4><ul><li>将指令和数据放在两个独立的存储器，允许在一个机器周期内同时获得指令和操作数，提高了执行速度。</li></ul><h4 id="计算机性能指标"><a href="#计算机性能指标" class="headerlink" title="计算机性能指标"></a>计算机性能指标</h4><p><strong>机器字长</strong>：</p><ol><li>CPU一次能处理数据的位数。</li></ol><p>通常与CPU的寄存器位数有关。字长越长，精度越高。</p><ol><li>机器的字长也会影响机器的运算速度。</li></ol><p>字长较短，运算位数多，可能需要多次运算才能完成。</p><ol><li>对硬件造价有影响。</li></ol><p>直接影响ALU、数据总线以及存储字长的位数。</p><p><strong>存储容量：</strong></p><p>主存容量、辅存容量</p><p><strong>运算速度：</strong></p><ul><li>吞吐量和响应时间</li><li>主频和CPU时钟周期</li><li>CPI：执行一条指令所需的时钟周期数。</li><li>CPU执行时间：指运行一个程序所花费的时间。取决于：1、主频；2、CPI；3、指令条数</li><li>MIPS：每秒执行多少百万条指令。</li><li>MFLOPS：每秒执行多少百万次浮点运算。（标志系统性能最有用参数）</li><li>GFLOPS：每秒执行多少十亿次浮点运算。</li><li>TFLOPS：每秒执行多少万亿次浮点运算。 </li></ul><h3 id="数据的表示与运算"><a href="#数据的表示与运算" class="headerlink" title="数据的表示与运算"></a>数据的表示与运算</h3><h4 id="汉字的编码"><a href="#汉字的编码" class="headerlink" title="汉字的编码"></a>汉字的编码</h4><p>①输入码（外码）：区位码、国际码、拼音码、电报码、表形码等</p><p>②内码：0、1（机器码）</p><p>③输出码：汉字字形码</p><ul><li>汉字编码包括汉字的输入编码、汉字内码、汉字字形。用两个字节表示一个汉字，每个字节用七位码。区位码是4位十进制数，前2位是区码，后2位是位码。</li><li>国标码是将十进制的区位码转换为十六进制后，再在每个字节上加上20H。为了方便计算机区分中文字符和英文字符，将国标码两个字节的最高位都改为“1”，这就是汉字内码（十六进制）。</li></ul><h4 id="字符串的存放"><a href="#字符串的存放" class="headerlink" title="字符串的存放"></a>字符串的存放</h4><ul><li>小端模式：按先存储低位字节、后存储高位字节的顺序存放字符串的内容。</li><li>大端模式：按先存储高位字节、后存储低位字节的顺序存放字符串的内容。</li></ul><h4 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h4><p>①奇偶校验码：只能检出一位错误，不能确定出错的位置；只能检验出奇数位错误，不能检测出偶数位错误。</p><ul><li>奇校验码：整个校验码中“1”的个数为奇数。</li><li>偶校验码：整个校验码中“1”的个数为偶数。</li></ul><p>②海明（汉明）检验码：可检出错位位置</p><p>③循环冗余校验（CRC）码：可检出错误位置（通过除法运算）</p><h4 id="原码、反码、补码、移码"><a href="#原码、反码、补码、移码" class="headerlink" title="原码、反码、补码、移码"></a>原码、反码、补码、移码</h4><ol><li>原码、补码、反码三种机器数的最高位均是符号位。</li><li>当真值为正时，原码、补码、反码的表示形式均相同，即符号位用“0”表示，数值部分与真值相同。当真值为负时，原码、补码、反码的表示形式不同，但其符号位都用“1”表示，而数值部分补码是原码的“求反加1”，反码是原码的“每位求反”。</li><li>同一个真值的移码和补码仅差一个符号位。</li><li>不同机器数表示±0时，其形式不同。[+0]原≠[-0]原， [+0]反≠[-0]反，[+0]补=[-0]补，[+0]移=[-0]移</li><li>当机器字长确定后，补码比原码、反码能多表示一个负数。</li><li>移码只能表示整数，用它表示浮点数的阶码时，能方便地判断阶码的大小。</li></ol><h4 id="补码定点数的加-减运算"><a href="#补码定点数的加-减运算" class="headerlink" title="补码定点数的加/减运算"></a>补码定点数的加/减运算</h4><p><strong>基本公式：</strong>（将符号位和数值部分一起参加运算，并且将符号位产生的进位自然丢掉即可）</p><p>加法：[A]补+[B]补=[A+B]补</p><p>减法：[A-B]补=[A]补+[-B]补（[-B]补由[B]补连同符号位在内，每位取反，末尾加1）</p><p><strong>溢出判断：</strong></p><p>①用一位符号判断溢出：实际参加操作的两个数符号相同，结果又与原操作数的符号不同，即为溢出。</p><p>②用两位符号位判断溢出：当2位符号位不同时，表示溢出，否则，无溢出。不论是否发生溢出，高位（第1位）符号永远代表真正的符号。（变形补码，运算时多一位）01正溢出（上溢）；10负溢出（下溢）</p><p>③采用一位符号位根据数据位的进位情况判断溢出。如果符号位的进位与最高数位的进位不同，则表示结果溢出。</p><h4 id="浮点数的加-减运算"><a href="#浮点数的加-减运算" class="headerlink" title="浮点数的加/减运算"></a>浮点数的加/减运算</h4><ol><li>对阶：两个数的小数点位置对齐（使阶码相等），两个数的阶码相减求阶差，使小阶的尾数向右移位，每右移一位，阶码加1。</li><li>尾数求和：将对阶后的两个尾数按定点加（减）运算规则进行运算。</li><li>规格化：补码规格化形式为[S]补 00.1××××；[S]补 11.0××××。</li></ol><p>①左规：尾数出现00.0××××或11.1××××时，需左规。尾数左移一位，阶码减1。</p><p>②右规：尾数出现01.××××或10.××××时，表示尾数溢出，但在浮点运算中不算溢出，可通过右规处理。尾数右移一位，阶码加1。</p><ol><li>舍入：在对阶和右规的过程中，可能会将尾数的低位丢失，引起误差，影响精度，用舍入法来提高尾数的精度。</li></ol><p>①“0舍1入”法：被移去的最高位数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1。又溢出时，再右规……</p><p>②“恒置1”法：不论丢掉的最高数位是“1”还是“0”，都使尾数末位恒置“1”。</p><p>两种方法同样都有使尾数变大和变小两种可能。</p><ol><li>溢出判断（是否溢出由阶码的符号决定）</li></ol><p>①上溢：阶码[j]补=01，×××，作溢出处理</p><p>②下溢：阶码[j]补=10，×××，按机器零处理</p><p>注：浮点数的计算原理需要多动手去计算理解</p><h4 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="浮点数的表示范围"></a>浮点数的表示范围</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjZmMzRlMjM1YjFlYTA4NmRiYTQwMTBhZGVmNzgyOWZfeHNtSmtWTDMzcjhJUFNFR0JLT0lhTUNEM0lDVE03bVdfVG9rZW46Ym94Y25ZREs4VjhxSXVqTWhSVkdHQmJGYXdoXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><p>上溢：当浮点数阶码大于最大阶码时，上溢，机器停止运算，进行中断溢出处理。</p><p>下溢：当浮点数阶码小于最小阶码时，下溢，溢出的数绝对值很小，通常将位数各位强制为0，按机器零处理，机器可以继续运行。</p><h4 id="8位二进制整数范围"><a href="#8位二进制整数范围" class="headerlink" title="8位二进制整数范围"></a>8位二进制整数范围</h4><p>原码、反码：-127—+127</p><p>补码、移码：-128—+127</p><h4 id="标准IEEE-754标准"><a href="#标准IEEE-754标准" class="headerlink" title="标准IEEE 754标准"></a>标准IEEE 754标准</h4><p>现代计算机中，浮点数一般采用IEEE制定的国际标准： </p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQyM2M4ZTM0YjM4Y2FiNTVhYjY1ZDJhZDc0NjJhZmVfUndhWW02N0NsWmM0cXQzNGw4Y0VvRThNRHo1U3l4UlJfVG9rZW46Ym94Y25Ld2NORTJ6UUExVW95S0VoZTBBUG1lXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><p>常见的浮点数有三种：</p><p>阶码用移码表示，短实数、长实数、临时实数的偏移量用十六进制数表示分别为7FH（127）、3FFH、3FFFH。</p><p>尾数部分通常是用原码、规格化表示，即非“0”的有效位最高位总是“1”，但在IEEE标准中，有效位呈如下形式：1▲ff…ffff，其中▲表示假想的二进制小数点。在实际表示中，对短实数和长实数，这个整数位的1省略，称隐藏位；对于临时实数不采用隐藏位方案。</p><p>规格化的短浮点数真值： </p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2U1MTJhOGFhMzc0MzZhZTA1OTZiZGFkZDhkYzI0MWNfQU9rMGhOaXFSMlhIOWZicDlQaWgzVW5teHc2cmxHRzBfVG9rZW46Ym94Y25sZVl0dFNubWxoWFpNTm1KVEQ2SEhkXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><h3 id="存储器的存储结构"><a href="#存储器的存储结构" class="headerlink" title="存储器的存储结构"></a>存储器的存储结构</h3><h4 id="存储器的层次化结构"><a href="#存储器的层次化结构" class="headerlink" title="存储器的层次化结构"></a>存储器的层次化结构</h4><p>存储器主要性能指标：速度、容量、每位价格（位价）</p><p>一般来说，速度越高，位价越高；容量越大，位价越低；容量越大，速度越低。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDUzYWNiNDZmN2I3YWJiNGYyOGNkMzFkMjg5MGJhYzBfSk9YSUpVdGc0UE5zR3NscFhDMTdLemtnNjY4aU1WS1RfVG9rZW46Ym94Y25VblVSR0VTUGN6dEJ1ZTNkbzRwRFBlXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><p>层次结构主要体现在缓存-主存和主存-辅存这两个层次上。</p><p>①<strong>缓存-主存</strong>：主要解决CPU和主存<strong>速度</strong>不匹配问题</p><p>（由硬件自动完成）数据调动对任何程序员透明。</p><p>②<strong>主存-辅存</strong>：主要解决存储系统的<strong>容量</strong>问题</p><p>（由硬件和操作系统共同完成）数据调动对应用程序员透明。</p><h4 id="动态RAM的刷新"><a href="#动态RAM的刷新" class="headerlink" title="动态RAM的刷新"></a>动态RAM的刷新</h4><p>一般取2ms，对动态RAM的全部基本单元电路必作一次刷新，称为刷新周期，又称再生周期。刷新的单位是行，仅需要行地址。</p><p>①<strong>集中刷新</strong>：在规定的一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作，称“死时间”或“死区”。（全部一起刷）</p><p>②<strong>分散刷新</strong>：对每行存储单元的刷新分到每个存取周期内完成。优点：没有死区。缺点：存取周期加长，整个系统速度降低。（一个个刷）</p><p>③<strong>异步刷新</strong>：是前两种方式的结合，既缩短“死时间”，又充分利用最大刷新时间间隔为2ms的特点。（一行行刷）</p><p>一行行刷的平均刷新时间：</p><p>行数 = 芯片容量 / 每行存储单元个数</p><p>平均刷新时间 = 间隔最长 / 行数</p><h4 id="动态RAM与静态RAM的比较"><a href="#动态RAM与静态RAM的比较" class="headerlink" title="动态RAM与静态RAM的比较"></a>动态RAM与静态RAM的比较</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWFhZTA2N2NkNzdjMzYwMDRkZmI1NTk0MTU0NzZiZjNfZVF6MkRLdHliZ1BVSXI5a1pxUW5IUHlLdVdRRFlid3lfVG9rZW46Ym94Y25YajZWQmR1VjlEM2hBd2pZTzhDRGFnXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><h4 id="存储容量的扩展"><a href="#存储容量的扩展" class="headerlink" title="存储容量的扩展"></a>存储容量的扩展</h4><ol><li>位扩展</li></ol><p>增加存储字长。例如：2片1K4位的存储芯片可组成1K8位的存储器。</p><p>注意：其中一片的数据线作为高4位D7-D4，另一片的数据线作为低4位D3-D0。</p><ol><li>字扩展</li></ol><p>增加存储器字的数量。例如：2片1K8位的存储芯片可组成一个2K8位的存储器。</p><p>注意：两片都连地址线A0-A9。（从低位连起）</p><ol><li>字、位扩展</li></ol><p>既增加存储字的数量又增加存储字长。</p><h4 id="双口RAM和多模块存储器"><a href="#双口RAM和多模块存储器" class="headerlink" title="双口RAM和多模块存储器"></a>双口RAM和多模块存储器</h4><p>为了提高CPU访问存储器的速度，可以采用双端口存储器（空间并行）、多模块存储器（时间并行）等技术，都属于并行技术。</p><h4 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h4><p>为了提高访存速度。（CPU速度比存储器快，同时从存储器中取出n条指令，可以充分利用CPU资源，提高运行速度）</p><ol><li>单体多字系统</li></ol><p>在一个存取周期内，从同一地址取出n条指令，然后逐条将指令送至CPU执行，即每隔1/n存取周期，主存向CPU送一条指令，增大了存储器的带宽，提高了存储器的工作速度。</p><p>例如：从同一地址取出4条指令，为单体四字结构，每字W位。按地址在一个存取周期内可读出4*W位的指令或数据，使主存带宽提高到4倍。</p><p>缺点：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，这种方法的效果就不明显。</p><ol><li>多体并行系统</li></ol><p>采用多提模块组成的存储器。每个模块可以并行工作，也可以交叉工作。</p><p>①低位交叉编址</p><p>程序连续存放在相邻体中（交叉存储）。低位地址表示体号，高位地址表示体内地址。</p><p>地址的低n为片选。</p><p>优点：相邻地址单元的数据放在不同组，各组可以并行工作，能较好提高存储器的带宽。</p><p>缺点：某一组出现故障，会影响整个存储器的正常工作。</p><p>②高位交叉编址</p><p>按体内地址顺序存放（顺序存储）。高位地址表示体号，低位地址表示体内地址。</p><p>地址的高n位片选。</p><p>优点： 某一组的故障不影响其他组，且容易通过添加模块来扩充容量。</p><p>缺点：相邻地址单元的数据放在同一组存储单元，各组间串行工作，不利于提升存储器的带宽。 </p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjkyN2JmNmFhMGM1YzIwNzdjNjU0NTQ5ZDdmZjVhMmRfSDJxQ3VFWTkwUXFjbE9mY0Y1eFJMS1pEY0hHY2F6RGZfVG9rZW46Ym94Y25OSnp3SUtoOGRiTzh1VElRNE9aTmloXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><h4 id="Cache计算"><a href="#Cache计算" class="headerlink" title="Cache计算"></a>Cache计算</h4><p>（h越接近1越好，ta越接近tc越好）</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2NkODU5NTA2NzljODg5ZDBmZTEyNWNjNmFjYjY0YmNfSVRsUjJnM09iQjllZ1VxUkxwdzVibXpHY2g3dDlKY2NfVG9rZW46Ym94Y243dlJLb1YyWFBqaEFLZzU0S3hibFZlXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><h4 id="Cache中主存块之间的映射方式"><a href="#Cache中主存块之间的映射方式" class="headerlink" title="Cache中主存块之间的映射方式"></a>Cache中主存块之间的映射方式</h4><p>由主存地址映射到Cache地址称为地址映射。</p><ol><li>直接映射</li></ol><p>主存数据只能装入Cache中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无需使用替换算法）。</p><p><strong>映射关系：</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjc2YzdiM2JlN2QxYTM4ZGQxMDdmZjU3NTA1YjViOWFfOVVNREo5TUxKUnhvc2NtZDg4TTZXRmd3bkc2dnl1bm9fVG9rZW46Ym94Y25ieEYyQktXajVhcDJtWXBlUHlxNURiXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><p><strong>地址结构：</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzU3YjE5Yjc1MmJmNTgxMjZmNDM5YjlhMzdhYzRkYTlfaDJpOGlPeHVLY3RPMFluVEZRODdBNUZxNjJSNElwUkhfVG9rZW46Ym94Y25oZHkxa3EwaDhIMTUzT3l6NnhjZk02XzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><p>优点：实现简单，只需利用主存地址的某些位直接判断，即可确定所需字块是否在缓存中。</p><p>缺点：不够灵活，降低命中率。</p><ol><li>全相联映射</li></ol><p>允许主存中每一字块映射到Cache中的任何一块位置上。可以从已被占满的Cache中替换出任一旧字块。</p><p>通常采用昂贵的“按内容寻址”的相联存储器来完成。</p><p><strong>地址结构：</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDk5MGQ2ODVjZDBlYjQ0MWEwZjQxNTA2ZDNjNGI5NjFfVkVuYUUxeWJRZHpERmtuT0NYU3N6VGVnQXFENTVtQ2ZfVG9rZW46Ym94Y25HaUJmQlFJRXN2ZkJmWWdGdnB2aURoXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><p>优点：灵活，命中率高，缩小了块冲突率，空间利用率高。</p><p>缺点：地址变换速度慢，实现成本高</p><ol><li>组相联映射（上述两种映射的折中）</li></ol><p>将Cache空间分成大小相同的组，主存的一个数据块可以装入到一组内的任何一个位置（组间采取直接映射，组内采取全相联映射）。</p><p><strong>映射关系：</strong>i=j mod Q （i是缓存的组号，j是主存的块号，Q是Cache的组数）Q=1是变为全相联映射</p><p><strong>地址结构：</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjhiNDA5Y2UzNjJkMjk1MmE3NWY3MzAzMmViYjFmNGNfUTJBamdMVkN6TkxyZ3FEbkZodm9Ic3NuSk43TDM2VHBfVG9rZW46Ym94Y25nb3c4cW9wMWZmMHZQMUp5c1BBUHpoXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><h4 id="Cache中主存块的替换算法"><a href="#Cache中主存块的替换算法" class="headerlink" title="Cache中主存块的替换算法"></a>Cache中主存块的替换算法</h4><ol><li>先进先出（First-In-First-Out，FIFO）算法</li><li>近期最少使用（Least Recently Used，LRU）算法</li><li>随机法</li></ol><h4 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h4><ul><li>磁盘寻址的最小单位是扇区。</li><li>道密度：沿磁盘半径方向单位长度的磁道数。</li><li>位密度：单位长度磁道上记录二进制的位数。</li><li>平均寻道时间：从一个磁道转移到另一个磁道的平均时间。（全部寻道时间的一半）</li><li>平均等待时间：旋转等待的平均时间。（转一周时间的一半）</li><li>一扇区的传送时间：T=1 / (转速×扇区数)</li><li>存取一个扇区的时间：T=每个扇区位数 / (转速×扇区数)</li><li>平均存取时间=平均寻道时间 + 平均等待时间 + 传输时间</li><li>每个记录面的磁道数：K=[(外直径-内直径)/2]*磁道密度</li><li>盘组格式化容量：C = 记录面数 * K * 每个扇区字节数 * 扇区数</li><li>盘组非格式化容量：CN = 记录面数 * K * 最内圈磁道周长 * 内层位密度</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>WE 为写允许信号：低电平0为写，高电平1为读</li><li>CS为片选信号：低电平0有效</li><li>借位/进位C：1=结果的最高位发生了进位，0=结果的最高位未发生进位</li><li>溢出标志位V：1=溢出，0=没有溢出</li></ul><h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><h4 id="指令的寻址方式"><a href="#指令的寻址方式" class="headerlink" title="指令的寻址方式"></a>指令的寻址方式</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGNjMjcxNjljOTFjZTM3NDk4MWUzNDRjYzU5YjM2NGZfck1tWTZkMFlkMXE4RFhJTzg1dnFnalpVVVhCU0xkTVZfVG9rZW46Ym94Y25XSTNLUzZSRllQZThsdmdrYndVb0xjXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjA0YzNhYTVmZGY1MTRiYTc2MGNmY2UwODI1YTNkMjFfdnFVOHFSWGRFYVVkYWJITXFVR3lNRERZTEEwRVJpbUxfVG9rZW46Ym94Y25takphc0QyczU0ejkzYVZ3V0huWmpjXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><h4 id="CISC和RISE"><a href="#CISC和RISE" class="headerlink" title="CISC和RISE"></a>CISC和RISE</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODI1ZDA0NWU3YWVhZTk5NzE3YjU1ODNjZDA4OGFiOWFfT25uZDRhb2F3b1VJR1VGT0ZTbWNmNXBLVUdNcnRRM3VfVG9rZW46Ym94Y242QjhJYURsaVQwM3NaMGJyVDQySThjXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><h4 id="二地址指令操作数物理位置的三种形式"><a href="#二地址指令操作数物理位置的三种形式" class="headerlink" title="二地址指令操作数物理位置的三种形式"></a>二地址指令操作数物理位置的三种形式</h4><ul><li>寄存器——寄存器型（RR型）；</li><li>寄存器——存储器型指令（RS型）；</li><li>存储器——存储器型（SS型）。</li></ul><h3 id="中央处理器CPU"><a href="#中央处理器CPU" class="headerlink" title="中央处理器CPU"></a>中央处理器CPU</h3><h4 id="CPU基本结构"><a href="#CPU基本结构" class="headerlink" title="CPU基本结构"></a>CPU基本结构</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDZmYzBjZjRlZGM2ODVmNjZmMzI5M2I2N2Y2NGU3MDlfeGZ3aFdUZDVwZzJsWkVEN2NxSTJzOWJvNm1sMkU1ZDhfVG9rZW46Ym94Y25QeEpPR2UxSld5aW5DSVBLTDg4dTJiXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><h4 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h4><ol><li>单指令周期</li></ol><p>对所有指令都选用相同的执行时间来完成。</p><p>下一条指令只能在前一条指令执行结束之后才能启动。（串行）</p><p>指令周期取决于执行时间最长的指令的执行时间。</p><ol><li>多指令周期</li></ol><p>对不同类型的指令选用不同的执行步骤来完成。</p><p>下一条指令只能在前一条指令执行结束之后才能启动。（串行）</p><p>可选用不同个数的时钟周期来完成不同指令的执行过程。</p><ol><li>流水线方案</li></ol><p>指令之间可以并行执行的方案。</p><p>追求的目标是力争在每个时钟脉冲周期完成一条指令的执行过程。</p><p>通过在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。</p><ul><li>时钟周期：计算机操作的最小单位，由计算机主频确定，是主频的倒数。</li><li>工作脉冲：控制器的最小时间单位，起定时出发作用，一个时钟周期有一个工作脉冲。</li><li>机器周期：即CPU周期，包含若干个时钟周期。</li><li>指令周期：可由多个CPU周期组成。</li><li>存取周期：存储器进行两次独立的存取器操作（连续两次读或写操作）所需最小间隔时间。</li><li>存储字长：存放在一个存储单元中的二进制代码位数</li><li>机器字长：CPU一次能处理数据的位数。</li><li>指令字长：一般去存储字长的整数倍。</li></ul><h4 id="微指令格式"><a href="#微指令格式" class="headerlink" title="微指令格式"></a>微指令格式</h4><ol><li>水平型微指令：直接编码、字段直接编码、字段间接编码和混合编都是。</li></ol><p>特点：一条水平型微指令定义并执行几种并行的基本操作。 </p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWE5MGNkZmQyZGQzMjQwZjY3MDQyYTFiYmNlMjI0MDZfUWZ3YTRTcWZESkczVDlHdElmOWFyVGNPeGtwQ2xWTXNfVG9rZW46Ym94Y254R0dIT1ZnbUIxaUJmR0pRaEptN0hmXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><ol><li>垂直型微指令：采用类似机器指令操作码的方式，设置操作码字段μOP</li></ol><p>特点：一条垂直型微指令只能定义并执行一种基本操作。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmM2ZThlMmI5YzAzOWViY2QyODI1NWEyODU5OWUxYjBfNDhvUnZ0NmhXWVhiQzNOVWpRT25jN00xZW14QnN3NU9fVG9rZW46Ym94Y24yZEdmR1RkZGtZV0w1V2lhTnVIaFdiXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><ol><li>混合型微指令：在垂直型的基础上增加一些不太复杂的并行操作。指令较短，仍便于编写；微程序也不长，执行速度加快。</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGJmNzU1YjBlYmU4MjI0ODY0MGY5MjVkY2UyMzFhOTdfZXF2bHpsSVdVSTNBSUV0bHhpOFBxakVuS2dURWtjTkVfVG9rZW46Ym94Y25wNE1rMzF1aE1vaE5ldzFjbHdrVWljXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><h4 id="硬布线控制器、微程序控制器"><a href="#硬布线控制器、微程序控制器" class="headerlink" title="硬布线控制器、微程序控制器"></a>硬布线控制器、微程序控制器</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWNlNGE1MDdkNjE5MDFmNGI1ZjM5YzM2NmIzM2RjOGJfcG41dHJBbGVQUkhKMXJUWXdCb2FkbVR6S2tiRGMzRmtfVG9rZW46Ym94Y25FVlp4c2ZCekVTN3Z0c2J0TnEyaEhiXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><h4 id="微指令基本组成"><a href="#微指令基本组成" class="headerlink" title="微指令基本组成"></a>微指令基本组成</h4><ul><li>控制存储器CM：是微程序控制器的核心部件，用于存放微程序，可用ROM构成。</li><li>微指令寄存器CMDR：用于存放从CM中取出的微指令，位数同指令字长相等。</li><li>微地址形成部件：产生初始微地址和后继微地址，以保证微指令的连续执行。</li><li>微地址寄存器CMAR：接受微地址形成部件送来的微地址，为在CM中读取指令作准备。</li><li>地址转移逻辑：在有分支转移时形成新的后继地址。</li></ul><h4 id="机器指令与微指令的关系"><a href="#机器指令与微指令的关系" class="headerlink" title="机器指令与微指令的关系"></a>机器指令与微指令的关系</h4><ul><li>每条机器指令编写成一个微程序；</li><li>每一个微程序包含若干条微指令；</li><li>每一条微指令对应一个或几个微操作命令。</li></ul><h4 id="影响流水线性能的因素"><a href="#影响流水线性能的因素" class="headerlink" title="影响流水线性能的因素"></a>影响流水线性能的因素</h4><ol><li>三种：结构相关、数据相关、控制相关</li><li>数据相关：写后读（RAW）、读后写（WAR）、写后写（WAW）</li><li>若发生数据相关冲突：如果在硬件设计上采用向前传送技术加以改进，则可不延迟。</li></ol><p>流水线性能（吞吐率、加速比、效率）</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTk1MWIwZGExZDQ3NGZhMTZhYjZlNjk5NGVkODIwMWRfRlFoWm9WaktUSmtDaGtQcFVrYzZvendEZkJ6NUVzcEpfVG9rZW46Ym94Y24xcDAwTldXNndmelJGWFJVUzFXdVZkXzE2MjcxNDg0MzA6MTYyNzE1MjAzMF9WNA" alt="img"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的内核ebpf开发之旅</title>
      <link href="/posts/c35a.html"/>
      <url>/posts/c35a.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>内核研究与开发是计算机底层处于与硬件打交道的部位，ebpf可以理解为是内核开发的一个模块。在研究ebpf开发之前需要对计算机的一些基础知识学习了解，懂得计算机的基本组成和操作系统的基本原理和运行机制，了解Linux内核设计的机制和相关源码的阅读与理解，再深入内核模块观察ebpf的设计思路，进而做到对ebpf的开发与实现。</p><p>在此之前，首先需要储备一些基本的计算机知识。</p><h2 id="基础知识储备"><a href="#基础知识储备" class="headerlink" title="基础知识储备"></a>基础知识储备</h2><h3 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h3><p>学习计算机组成原理可以对计算机的基础架构有所理解，了解计算机中常见的术语和概念。</p><p>计算机组成原理知识要点见：<a href="https://starcross.feishu.cn/docs/doccnS4QQYHiGZhIzEchK8SrIun" target="_blank" rel="noopener">计算机组成原理学习笔记</a></p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>操作系统作为人和计算机交互的桥梁，理解其工作原理对后续内核开发有很好的帮助，对操作系统的术语了解知道其背后的道理是开发的基础。</p><p><a href="https://www.bilibili.com/video/BV1uW411f72n" target="_blank" rel="noopener">清华大学操作系统课程入口</a></p><p>操作系统知识要点见：<a href="https://starcross.feishu.cn/docs/doccnaAGNkNcChj02pqY32L7msb" target="_blank" rel="noopener">操作系统学习笔记</a></p><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><p>C语言是Linux内核开发主要使用的编程语言和开发工具，需要熟悉其基本语法和结构。</p><p><a href="http://c.biancheng.net/c/" target="_blank" rel="noopener">C语言中文网入口</a></p><p><a href="https://devdocs.io/c/" target="_blank" rel="noopener">C语言API入口</a></p><h2 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h2><p>了解Linux基本组成和常用的shell命令，熟悉Linux的文件架构。</p><h3 id="FHS-Filesystem-Hierarchy-Standard"><a href="#FHS-Filesystem-Hierarchy-Standard" class="headerlink" title="FHS(Filesystem Hierarchy Standard):"></a>FHS(Filesystem Hierarchy Standard):</h3><p>FHS依据文件系统使用的频繁与否与是否允许使用者随意更动, 而将目录定义成为四种交互作用的形态,用表格来说有点像底下这样：</p><p>无法复制加载中的内容</p><ul><li><p>可分享的：可以分享给其他系统挂载使用的目录,所以包括执行文件与用户的邮件等数据, 是能够分享给网络上其他主机挂载用的目录；</p></li><li><p>不可分享的：自己机器上面运作的装置文件或者是与程序有关的socket文件等, 由于仅与自身机器有关,所以当然就不适合分享给其他主机了.</p></li><li><p>不变的：有些数据是不会经常变动的,跟随着distribution而不变动. 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；</p></li><li><p>可变动的：经常改变的数据,例如登录文件、一般用户可自行收受的新闻组等.</p></li></ul><p>事实上,FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已,分别是底下这三个目录的定义：</p><ol><li>/ (root, 根目录)：与开机系统有关；</li><li>/usr (unix software resource)：与软件安装/执行有关；</li><li>/var (variable)：与系统运作过程有关.</li></ol><h4 id="根目录-的意义与内容："><a href="#根目录-的意义与内容：" class="headerlink" title="根目录 (/) 的意义与内容："></a>根目录 (/) 的意义与内容：</h4><blockquote><p><strong>概要:</strong></p></blockquote><ol><li><blockquote><p>所有的目录都是由根目录衍生出来的(根目录是整个系统最重要的一个目录)</p></blockquote></li><li><blockquote><p>与开机/还原/系统修复等动作有关. (由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据,若系统出现错误时,根目录也必须要包含有能够修复文件系统的程序才行)</p></blockquote></li><li><blockquote><p>FHS标准建议：<strong>根目录(/)所在分割槽应该越小越好, 且应用程序所安装的软件最好不要与根目录放在同一个分割槽内,保持根目录越小越好</strong>.(因为越大的分割槽妳会放入越多的数据,如此一来根目录所在分割槽就可能会有较多发生错误的机会,如此不但效能较佳,根目录所在的文件系统也较不容易发生问题.)</p></blockquote></li></ol><blockquote></blockquote><blockquote><p><strong>根目录(/)底下目录FHS定义的说明：</strong></p></blockquote><blockquote><p>无法复制加载中的内容</p></blockquote><blockquote><p>除上 FHS 中定义的目录说明外, 底下是几个在Linux当中非常重要的目录：</p></blockquote><blockquote><p>无法复制加载中的内容</p></blockquote><blockquote><p>不可与根目录分开的目录(与开机过程有关)：</p></blockquote><blockquote><p>根目录与开机有关,<strong>开机过程中仅有根目录会被挂载</strong>, 其他分割槽则是在开机完成之后才会持续的进行挂载的行为.就是因为如此,因此根目录下与开机过程有关的目录, 就不能够与根目录放到不同的分割槽去！</p></blockquote><ul><li><blockquote><p>/etc：配置文件</p></blockquote></li><li><blockquote><p>/bin：重要执行档</p></blockquote></li><li><blockquote><p>/dev：所需要的装置文件</p></blockquote></li><li><blockquote><p>/lib：执行档所需的函式库与核心所需的模块</p></blockquote></li><li><blockquote><p>/sbin：重要的系统执行文件 </p></blockquote></li></ul><h4 id="usr-的意义与内容："><a href="#usr-的意义与内容：" class="headerlink" title="/usr 的意义与内容："></a>/usr 的意义与内容：</h4><blockquote><p>概要:</p></blockquote><ol><li><blockquote><p>依据FHS的基本定义,/usr里面放置的数据属于可分享的与不可变动的(shareable, static), 如果你知道如何透过网络进行分割槽的挂载,那么/usr确实可以分享给局域网络内的其他主机来使用！</p></blockquote></li><li><blockquote><p>usr(Unix Software Resource 即Unix操作系统软件资源) FHS建议所有软件开发者,应该将他们的数据合理的分别放置到这个目录下的次目录,而不要自行建立该软件自己独立的目录.</p></blockquote></li><li><blockquote><p>所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下,因此这个目录有点类似Windows 系统的『C:\Windows\ + C:\Program files\』这两个目录的综合体,系统刚安装完毕时,这个目录会占用最多的硬盘容量.</p></blockquote></li></ol><blockquote><p>一般来说,/usr的次目录建议有底下这些：</p></blockquote><blockquote><p>无法复制加载中的内容</p></blockquote><h4 id="var-的意义与内容："><a href="#var-的意义与内容：" class="headerlink" title="/var 的意义与内容："></a>/var 的意义与内容：</h4><blockquote><p>概要:</p></blockquote><blockquote><p>/var目录主要针对常态性变动的文件,包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件, 包括程序文件(lock file, run file),或者例如MySQL数据库的文件等等. 所以/var在系统运作后才会渐渐占用硬盘容量的目录</p></blockquote><blockquote><p>常见的次目录有：</p></blockquote><blockquote><p>无法复制加载中的内容</p></blockquote><blockquote><p>针对FHS,各家distributions的异同:</p></blockquote><blockquote><p>由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据, 因此,在其他次目录层级内,就可以随开发者自行来配置了.举例来说,CentOS的网络设定数据放在 /etc/sysconfig/network-scripts/ 目录下,但是SuSE则是将网络放置在 /etc/sysconfig/network/ 目录下,目录名称可是不同的呢！不过只要记住大致的FHS标准,差异性其实有限啦！</p></blockquote><h3 id="Linux-命令大全查询表"><a href="#Linux-命令大全查询表" class="headerlink" title="Linux 命令大全查询表"></a>Linux 命令大全查询表</h3><p>无法复制加载中的内容</p><h2 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h2><h3 id="Linux内核学习策略"><a href="#Linux内核学习策略" class="headerlink" title="Linux内核学习策略"></a>Linux内核学习策略</h3><p>Linux学习建议配套远古版本的Linux内核源码学习，有助于帮助理解内核设计的思路，下载并阅读<a href="http://ftp.sjtu.edu.cn/sites/ftp.kernel.org/pub/linux/kernel/v1.0/" target="_blank" rel="noopener">Linux内核1.0版本</a>的源码去学习，该版本基本包含了内核基本部件，后续的版本都是在此基础上扩充功能，但是基本的内在没有变化。</p><p>内核源码不同版本间的阅读与对比可参考<a href="https://elixir.bootlin.com/linux/1.0/source" target="_blank" rel="noopener">Bootlin</a>，其中1.0源码目录结构如下，其中对主要文件目录进行解释：</p><p>无法复制加载中的内容</p><p>对照着内核设计的源代码进行学习，会从根源上思考这样设计的目的是什么。</p><h3 id="Linux内核开发环境配置"><a href="#Linux内核开发环境配置" class="headerlink" title="Linux内核开发环境配置"></a>Linux内核开发环境配置</h3><p>内核开发环境和源码安装配置：<a href="https://starcross.feishu.cn/docs/doccnVo4HU8TrSWwmJodvpVp8jd" target="_blank" rel="noopener">Linux内核开发环境配置</a></p><h3 id="Linux内核简介"><a href="#Linux内核简介" class="headerlink" title="Linux内核简介"></a>Linux内核简介</h3><h4 id="Linux-内核的用途是什么？"><a href="#Linux-内核的用途是什么？" class="headerlink" title="Linux 内核的用途是什么？"></a>Linux 内核的用途是什么？</h4><p>Linux 内核有 4 项工作：</p><ol><li><strong>内存管理：</strong>追踪记录有多少内存存储了什么以及存储在哪里</li><li><strong>进程管理：</strong>确定哪些进程可以使用中央处理器（CPU）、何时使用以及持续多长时间</li><li><strong>设备驱动程序：</strong>充当硬件与进程之间的调解程序/解释程序</li><li><strong>系统调用和安全防护：</strong>从流程接受服务请求</li></ol><p>在正确实施的情况下，内核对于用户是不可见的，它在自己的小世界（称为内核空间）中工作，并从中分配内存和跟踪所有内容的存储位置。用户所看到的内容（例如 Web 浏览器和文件）则被称为用户空间。这些应用通过系统调用接口（SCI）与内核进行交互。</p><p><em>举例来说，</em>内核就像是一个为高管（硬件）服务的忙碌的个人助理。助理的工作就是将员工和公众（用户）的消息和请求（进程）转交给高管，记住存放的内容和位置（内存），并确定在任何特定的时间谁可以拜访高管、会面时间有多长。</p><h3 id="Linux内核学习路线和框架图"><a href="#Linux内核学习路线和框架图" class="headerlink" title="Linux内核学习路线和框架图"></a>Linux内核学习路线和框架图</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWI3YjczMjI3YjkyZjg2MTZkNzM3OGRiZmI2ODU0NjhfRWh0YnpYUTNYaFo0cU9PMjk3dFB4emhLbzBaa1NjUlNfVG9rZW46Ym94Y25PUEFLTjBOdXVjVFVBdGdCOUVFTjZkXzE2MjcxNDgzMzE6MTYyNzE1MTkzMV9WNA" alt="img"></p><h3 id="Linux-Security-Coaching"><a href="#Linux-Security-Coaching" class="headerlink" title="Linux Security Coaching"></a>Linux Security Coaching</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGIwZDYzMzVmYTI1NzljOWNlMjM0Y2QyYTA5ZDJhOGNfYjQ3RWhNaU9Jcm9WWmxucmJnZTZCb1RzQzV6SW1vZ0tfVG9rZW46Ym94Y25tbGxFekV0cWJaS1gxc1A0aTVvRzVkXzE2MjcxNDgzMzE6MTYyNzE1MTkzMV9WNA" alt="img"></p><h3 id="Linux内核基础学习资料"><a href="#Linux内核基础学习资料" class="headerlink" title="Linux内核基础学习资料"></a>Linux内核基础学习资料</h3><p><a href="https://www.bilibili.com/video/BV1eo4y197tQ?from=search&amp;seid=16735116070729069726" target="_blank" rel="noopener">Linux内核与系统驱动保护入口</a></p><p>该视频资料详细介绍了Linux内核的知识点及其在内核中的实现进行比对，很有参考价值。</p><h2 id="MakeFile详解"><a href="#MakeFile详解" class="headerlink" title="MakeFile详解"></a>MakeFile详解</h2><p>Makefile 可以简单的认为是一个工程文件的编译规则，描述了整个工程的编译和链接等规则。详细介绍如下：</p><p><a href="https://starcross.feishu.cn/docs/doccnokdI6NRWWkV2F6r17Xqw4f" target="_blank" rel="noopener">MakeFile详解</a></p><p>Makefile文件负责编写程序的编译与运行规则，免去命令行使用Clang去逐步编译分析。</p><h2 id="GDB详解"><a href="#GDB详解" class="headerlink" title="GDB详解"></a>GDB详解</h2><p>GDB是一个强大的调试工具，通过它可以实现C程序代码bug的调试。</p><p><a href="https://starcross.feishu.cn/docs/doccnZZYHtJv69P0n0IPwiu7TJg" target="_blank" rel="noopener">GDB详解</a></p><h2 id="Linux崩溃调试"><a href="#Linux崩溃调试" class="headerlink" title="Linux崩溃调试"></a>Linux崩溃调试</h2><p>Linux内核Crash下的问题解决方案：</p><p><a href="https://starcross.feishu.cn/docs/doccnIBwXKozjRqC7qDZJ9m7EVf" target="_blank" rel="noopener">Linux调试之崩溃</a></p><h2 id="EBPF基础"><a href="#EBPF基础" class="headerlink" title="EBPF基础"></a>EBPF基础</h2><h3 id="什么是ebpf？"><a href="#什么是ebpf？" class="headerlink" title="什么是ebpf？"></a>什么是ebpf？</h3><p>Linux 内核一直是实现监控/可观测性、网络和安全功能的理想地方。 不过很多情况下这并非易事，因为这些工作需要修改内核源码或加载内核模块， 最终实现形式是在已有的层层抽象之上叠加新的抽象。 eBPF 是一项革命性技术，它能在内核中运行沙箱程序（sandbox programs）， 而无需修改内核源码或者加载内核模块。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2FjMDEyYWQzNjNhZDFmYWNhMGIxNWRhYjU2YjVlMWFfZUVYWDZXdjl4R0s4c2RidmpJZ1pCMGpMMzR2cDVzNzBfVG9rZW46Ym94Y240Yk1vejNRcnlVYnNFdkVFamlDaWpmXzE2MjcxNDgzMzE6MTYyNzE1MTkzMV9WNA" alt="img"></p><p>eBPF 催生了一种全新的软件开发方式。基于这种方式，我们不仅能对内核行为进行 编程，甚至还能编写跨多个子系统的处理逻辑，而传统上这些子系统是完全独立、 无法用一套逻辑来处理的。</p><p><strong>安全：</strong></p><p>观测和理解所有的系统调用的能力，以及在 packet 层和 socket 层审视所有的网络操作的能力， 这两者相结合，为系统安全提供了革命性的新方法。 以前，系统调用过滤、网络层过滤和进程上下文跟踪是在完全独立的系统中完成的； eBPF 的出现统一了可观测性和各层面的控制能力，使我们有更加丰富的上下文和更精细的控制能力， 因而能创建更加安全的系统。</p><p><strong>网络：</strong></p><p>eBPF 的两大特色 —— 可编程和高性能 —— 使它能满足所有的网络包处理需求。 可编程意味着无需离开内核中的包处理上下文，就能添加额外的协议解析器或任何转发逻辑， 以满足不断变化的需求。高性能的 JIT 编译器使 eBPF 程序能达到几乎与原生编译的内核态代码一样的执行性能。</p><p><strong>跟踪 &amp; 性能分析：</strong></p><p>eBPF 程序能够加载到 trace points、内核及用户空间应用程序中的 probe points， 这种能力使我们对应用程序的运行时行为（runtime behavior）和系统本身 （system itself）提供了史无前例的可观测性。应用端和系统端的这种观测能力相结合， 能在排查系统性能问题时提供强大的能力和独特的信息。BPF 使用了很多高级数据结构， 因此能非常高效地导出有意义的可观测数据，而不是像很多同类系统一样导出海量的原始采样数据。</p><p><strong>观测 &amp; 监控：</strong></p><p>相比于操作系统提供的静态计数器（counters、gauges），eBPF 能在内核中收集和聚合自定义 metric， 并能从不同数据源来生成可观测数据。这既扩展了可观测性的深度，也显著减少了整体系统开销， 因为现在可以选择只收集需要的数据，并且后者是直方图或类似的格式，而非原始采样数据。</p><h3 id="Linux驱动模块开发"><a href="#Linux驱动模块开发" class="headerlink" title="Linux驱动模块开发"></a>Linux驱动模块开发</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Linux 内核的整体结构已经非常庞大,而其包含的组件也非常多。这会导致两个问题,一是生成的内核会很大,二是如果我们要在现有的内核中新增或删除功能,将不得不重新编译内核。Linux 提供了这样的一种机制,这种机制被称为模块(Module)。使得编译出的内核本身并不需要包含所有功能,而在这些功能需要被使用的时候,其对应的代码被动态地加载到内核中。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>先来看一个最简单的内核模块“Hello World”，代码如下：</p><pre><code>#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;static int hello_init(void) /初始化函数/{ printk(KERN_INFO " Hello World enter\n"); return 0;}static void hello_exit(void) /卸载函数/{ printk(KERN_INFO " Hello World exit\n ");}module_init(hello_init); /模块初始化/module_exit(hello_exit); /卸载模块/MODULE_LICENSE("Dual BSD/GPL"); /许可声明/MODULE_AUTHOR("Linux");MODULE_DESCRIPTION("A simple Hello World Module");MODULE_ALIAS("a simplest module");</code></pre><p>这个模块定义了两个函数, 一个在模块加载到内核时被调用( hello_init )以及一个在模块被去除时被调用( hello_exit ). moudle_init 和 module_exit 这几行使用了特别的内核宏来指出这两个函数的角色. 另一个特别的宏 (MODULE_LICENSE) 是用来告知内核, 该模块带有一个自由的许可证.</p><p>注：内核模块中用于输出的函数是内核空间的 printk()而非用户空间的 printf()，具体用法参考附件 printk函数介绍。</p><h4 id="几个常用命令"><a href="#几个常用命令" class="headerlink" title="几个常用命令"></a>几个常用命令</h4><h5 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h5><p>通过“insmod ./hello.ko”命令可以加载，加载时输出“Hello World enter”。</p><h5 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h5><p>通过“rmmod hello”命令可以卸载，卸载时输出“Hello World exit”。</p><h5 id="查看系统中已经加载的模块列表"><a href="#查看系统中已经加载的模块列表" class="headerlink" title="查看系统中已经加载的模块列表"></a>查看系统中已经加载的模块列表</h5><p>在Linux中，使用lsmod命令可以获得系统中加载了的所有模块以及模块间的依赖关系，例如：</p><pre><code>root@imx6:~$ lsmodModule      Size    Used byhello      1568    0 ohci1394     32716   0 ide_scsi     16708   0 ide_cd      39392   0 cdrom      36960   1 ide_cd</code></pre><h5 id="查看某个具体模块的详细信息"><a href="#查看某个具体模块的详细信息" class="headerlink" title="查看某个具体模块的详细信息"></a>查看某个具体模块的详细信息</h5><p>使用modinfo &lt;模块名&gt;命令可以获得模块的信息,包括模块作者、模块的说明、模块所支持 的参数以及 vermagic:</p><pre><code>root@imx6:~$ modinfo hello.kofilename:   hello.kolicense:   Dual BSD/GPLauthor:    Song Baohuadescription: A simple Hello World Modulealias:    a simplest modulevermagic:   2.6.15.5 686 gcc-3.2depends: </code></pre><h4 id="Linux-内核模块程序的结构"><a href="#Linux-内核模块程序的结构" class="headerlink" title="Linux 内核模块程序的结构"></a>Linux 内核模块程序的结构</h4><p>一个Linux内核模块主要由如下几个部分组成：</p><p>1、模块加载函数（一般需要） 当通过insmod或modprobe命令加载内核模块时，模块的加载函数会自动被内核执行，完成本模块的相关初始化工作。</p><p>2、模块卸载函数（一般需要） 当通过rmmod命令卸载某模块时，模块的卸载函数会自动被内核执行，完成与模块卸载函数相反的功能。 </p><p>3、模块许可证声明（必须） 许可证（LICENSE）声明描述内核模块的许可权限，如果不声明LICENSE，模块被加载时，将收到内核被污染 （kernel tainted）的警告。在Linux 2.6内核中，可接受的LICENSE包括“GPL”、“GPL v2”、“GPL and additional rights”、“Dual BSD/GPL”、“Dual MPL/GPL”和“Proprietary”。大多数情况下，内核模块应遵循GPL兼容许可权。Linux 2.6内核模块最常见的是以MODULE_LICENSE( “Dual BSD/GPL” )语句声明模块采BSD/GPL双LICENSE。 </p><p>4、模块参数（可选） 模块参数是模块被加载的时候可以被传递给它的值，它本身对应模块内部的全局变量。</p><p>5、模块导出符号（可选） 内核模块可以导出符号（symbol，对应于函数或变量），这样其它模块可以使用本模块中的变量或函数。 </p><p>6、模块作者等信息声明（可选） 用于申明模块作者的相关信息，一般用于备注作者姓名、邮箱等。</p><h5 id="模块加载函数"><a href="#模块加载函数" class="headerlink" title="模块加载函数"></a>模块加载函数</h5><p>Linux 内核模块加载函数一般以_ _init 标识声明,典型的模块加载函数如下：</p><pre><code>static int _ _init initialization_function(void){/* 初始化代码 */}module_init(initialization_function);</code></pre><p>模块加载函数必须以“module_init(函数名)”的形式被指定。它返回整型值,若初始化成功,应返回 0。而在初始化失败时,应该返回错误编码。在 Linux 内核里,错误编码是一个负值。</p><p>在 Linux 2.6 内核中,可以使用 request_module(const char *fmt, …)函数加载内核模块,驱动开发人员可以通过调用。</p><pre><code>request_module(module_name);/**** 或者 ****/request_module("char-major-%d-%d", MAJOR(dev), MINOR(dev));</code></pre><p>注意：在 Linux 中,所有标识为_ init 的函数在连接的时候都放在.init.text 这个区段内,此外,所有的 init 函数在区段.initcall.init 中还保存了一份函数指针,在初始化时内核会通过这些函数指针调用这些 _init 函数,并在初始化完成后,释放 init 区段(包括.init.text、.initcall.init 等)。</p><h5 id="模块卸载函数"><a href="#模块卸载函数" class="headerlink" title="模块卸载函数"></a>模块卸载函数</h5><pre><code>static void _ _exit cleanup_function(void){/* 释放代码 */}module_exit(cleanup_function);</code></pre><p>模块卸载函数在模块卸载的时候执行,不返回任何值,必须以“module_exit(函数名)”的形式来指定。通常来说,模块卸载函数要完成与模块加载函数相反的功能,如下所示。</p><p>若模块加载函数注册了 XXX,则模块卸载函数应该注销 XXX。</p><p>若模块加载函数动态申请了内存,则模块卸载函数应释放该内存。</p><p>若模块加载函数申请了硬件资源(中断、DMA 通道、I/O 端口和 I/O 内存等)的占用,则模块卸载函数应释放这些硬件资源。</p><p>若模块加载函数开启了硬件,则卸载函数中一般要关闭之。</p><h5 id="模块参数"><a href="#模块参数" class="headerlink" title="模块参数"></a>模块参数</h5><p>用“module_param(参数名,参数类型,参数读/写权限)”为模块定义一个参数,例如下列代码定义了 1 个整型参数和 1 个字符指针参数:</p><pre><code>static char *book_name = " dissecting Linux Device Driver ";static int num = 4 000;module_param(num, int, S_IRUGO);module_param(book_name, charp, S_IRUGO);</code></pre><p>参数类型可以是 byte、short、ushort、int、uint、long、ulong、charp(字符指针)、bool 或 invbool(布尔的反),在模块被编译时会将 module_param 中声明的类型与变量定义的类型进行比较,判断是否一致。</p><p>在装载内核模块时,用户可以向模块传递参数,形式为“insmode(或 modprobe)模块名 参数名=参数值”,如果不传递,参数将使用模块内定义的缺省值。</p><h5 id="内核模块的符号导出"><a href="#内核模块的符号导出" class="headerlink" title="内核模块的符号导出"></a>内核模块的符号导出</h5><p>模块可以使用如下宏导出符号到内核符号表：</p><pre><code>EXPORT_SYMBOL(符号名);EXPORT_SYMBOL_GPL(符号名);</code></pre><p>导出的符号将可以被其他模块使用,使用前声明一下即可。EXPORT_SYMBOL_GPL()只适用于包含 GPL 许可权的模块。</p><h5 id="模块声明与描述"><a href="#模块声明与描述" class="headerlink" title="模块声明与描述"></a>模块声明与描述</h5><p>在Linux内核模块中，我们可以用MODULE_AUTHOR、MODULE_DESCRIPTION、MODULE_VERSION、MODULE_DEVICE_TABLE、MODULE_ALIAS分别声明模块的作者、描述、版本、设备表和别名，例如：</p><pre><code>MODULE_AUTHOR(author);MODULE_DESCRIPTION(description);MODULE_VERSION(version_string);MODULE_DEVICE_TABLE(table_info);MODULE_ALIAS(alternate_name);</code></pre><p>对于USB、PCI等设备驱动，通常会创建一个MODULE_DEVICE_TABLE。</p><h4 id="MakeFile"><a href="#MakeFile" class="headerlink" title="MakeFile"></a>MakeFile</h4><h5 id="Kernel-modules"><a href="#Kernel-modules" class="headerlink" title="Kernel modules"></a>Kernel modules</h5><pre><code>obj-m += hello.o</code></pre><h5 id="Specify-flags-for-the-module-compilation"><a href="#Specify-flags-for-the-module-compilation" class="headerlink" title="Specify flags for the module compilation."></a>Specify flags for the module compilation.</h5><pre><code>#EXTRA_CFLAGS=-g -O0build: kernel_moduleskernel_modules:make -C /lib/modules/$(KVERS)/build M=$(CURDIR) modules #modules表示编译成模块的意思#CURDIR是make的内嵌变量，自动设置为当前目录clean:make -C /lib/modules/$(KVERS)/build M=$(CURDIR) clean该 Makefile 文件应该与源代码 hello.c 位于同一目录,开启其中的 EXTRA_CFLAGS=-g -O0可以得到包含调试信息的 hello.ko 模块。运行 make 命令得到的模块可直接在 PC 上运行。</code></pre><p>注：uname 的更多用法详见附件</p><p>如果一个模块包括多个.c 文件(如 file1.c、file2.c),则应该以如下方式编写 Makefile:</p><pre><code>obj-m := modulename.omodulename-objs := file1.o file2.o</code></pre><p>obj-m是个makefile变量，它的值可以是一串.o文件的表列</p><h3 id="EBPF详解"><a href="#EBPF详解" class="headerlink" title="EBPF详解"></a>EBPF详解</h3><p>ebpf详细学习笔记和记录：</p><p><a href="https://starcross.feishu.cn/docs/doccnZJbiuHUfwNpotNEbD5FhBh" target="_blank" rel="noopener">EBPF（Berkeley Packet Filter）学习记录</a></p><p>在这里不赘述ebpf的历史等没有太多学习意义的信息，主要从实际开发角度需要去展开必要介绍。</p><h2 id="Seccross项目理解"><a href="#Seccross项目理解" class="headerlink" title="Seccross项目理解"></a>Seccross项目理解</h2><p>开发记录及相关源码分析记录：</p><p><a href="https://starcross.feishu.cn/docs/doccnLdElunAoBYEfnCXDyxif5K" target="_blank" rel="noopener">SECCROSS项目解读</a></p><p><a href="https://starcross.feishu.cn/docs/doccn6uncVOKjl08w9zOl9CyAhd" target="_blank" rel="noopener">开发记录</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EBPF | Linux Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ghidra Pcode详解</title>
      <link href="/posts/9e83.html"/>
      <url>/posts/9e83.html</url>
      
        <content type="html"><![CDATA[<p>Pcode</p><p>P-code 是一种为逆向工程应用设计的<em>寄存器传输语言</em>。该语言足够通用，可以对许多不同处理器的行为进行建模。通过这种方式建模，将不同处理器的分析放到一个通用的框架中，促进可重定向分析算法和应用程序的开发。</p><p>从根本上说，p-code 的工作原理是将单个处理器指令转换为一系列<strong>p-code 操作</strong>，这些<strong>操作</strong>将处理器状态的一部分作为输入和输出变量 ( <strong>varnodes</strong> )。一组独特的 p-code 操作（由<strong>opcode</strong>区分）包含一组相当紧密的由通用处理器执行的算术和逻辑操作。将指令直接转换为这些操作称为<strong>原始 Pcode</strong>。原始 Pcode可用于直接模拟指令执行，通常遵循相同的控制流，尽管它可能会添加一些自己的内部控制流。</p><p>Pcode 专门设计用于促进<em>数据流</em>图的构建，以便对反汇编指令进行后续分析。Varnodes 和 p-code 操作符可以被明确地认为是这些图中的节点。生成原始 p-code 是图构建的必要第一步，但需要额外的步骤，这引入了一些新的操作码。其中两个 <strong>MULTIEQUAL</strong>和<strong>INDIRECT</strong>特定于图构建过程，但可以在随后的图分析和转换过程中引入其他操作码，并帮助保持恢复的数据类型关系。所有新的操作码都在原始原始 Pcode翻译中都不会发生。最后，一些 Pcode运算符 <strong>CALL</strong>、 <strong>CALLIND</strong>和<strong>RETURN</strong>可能在分析期间更改了它们的输入和输出变量节点，以便它们不再匹配其<em>原始 Pcode</em>形式。</p><p><strong>p-code的核心概念是：</strong></p><p><strong>Address Space</strong></p><p>Pcode 的<strong>地址空间</strong>是 RAM 的概括。它被简单地定义为可以由 Pcode操作读取和写入的索引字节序列。对于特定字节，标记它的唯一索引是该字节的<strong>地址</strong>。地址空间有一个名称来标识它，一个大小表示空间中不同索引的数量，以及与之关联的<strong>字节顺序</strong>，表示整数和其他多字节值如何编码到空间中。一个典型的处理器将有一个<strong>ram</strong>空间，用于模拟可通过其主数据总线访问的内存，以及一个<strong>寄存器</strong>用于对处理器的通用寄存器进行建模的空间。处理器操作的任何数据都必须在某个地址空间中。处理器的规范可以根据需要自由定义任意数量的地址空间。总是有一个特殊的地址空间，称为<strong>常量</strong>地址空间，用于对 Pcode操作所需的任何常量值进行编码。生成 p-code 的系统通常也使用专用的<strong>临时</strong>空间，可以将其视为临时寄存器的无底源。这些用于在对指令行为建模时保存中间值。</p><p>Pcode规范允许地址空间的可寻址单元大于一个字节。每个地址空间都有一个<strong>wordsize</strong>属性，可以设置该属性来指示一个单元中的字节数。大于 1 的字大小对 Pcode的表示几乎没有影响。地址空间中的所有偏移量在内部仍表示为字节偏移量。唯一的例外是<strong>LOAD</strong>和 <strong>STORE</strong> p-code 操作。这些操作读取一个指针偏移量，当取消引用指针时，该偏移量必须正确缩放以获得正确的字节偏移量。wordsize 属性对任何其他 Pcode操作没有影响。</p><p><strong>Varnode</strong></p><p>一个<strong>varnode</strong>要么是寄存器或存储器位置的概括。它由形式三元组表示：地址空间、空间偏移量和大小。直观地，varnode 是某个地址空间中的连续字节序列，可以将其视为单个值。p-code 操作对数据的所有操作都发生在 varnode 上。</p><p>Varnodes 本身只是一个连续的字节块，由地址和大小标识，并且它们没有类型。然而，Pcode操作可以强制对 varnode进行三种<em>类型</em>解释之一：整数、布尔值和浮点数。</p><ul><li><p>操作整数的操作总是将 varnode 解释为使用与包含 varnode 的地址空间相关联的字节序的二进制补码编码。</p></li><li><p>用作布尔值的 varnode 被假定为单个字节，该字节只能取值 0，表示<em>false</em>，而 1，表示<em>true</em>。</p></li><li><p>浮点运算使用正在建模的处理器预期的编码，这取决于 varnode 的大小。对于大多数处理器，这些编码由 IEEE 754 标准描述，但原则上其他编码也是可能的。</p></li></ul><p>如果将 varnode 指定为<strong>常量</strong>地址空间的偏移量，则在使用该 varnode 的任何 pcode操作中，该偏移量将被解释为常量或立即数。在这种情况下，varnode 的大小可以被视为可用于常量编码的大小或精度。与其他 varnodes 一样，常量只有使用它们的 p 代码操作强制使用的类型。</p><p><strong>P-code Operation</strong></p><p>一个<strong>p-code操作</strong>是机器指令的模拟。所有 p-code操作在内部具有相同的基本格式。它们都将一个或多个 varnode 作为输入，并可选择生成单个输出 varnode。操作的动作由它的<strong>操作码</strong>决定。对于几乎所有的 p-code 操作，只有输出 varnode 可以修改其值；操作没有间接影响。唯一可能的例外是<em>伪</em>操作，当对指令的行为不完全了解时，有时需要伪操作。</p><p>所有 p-code操作都与它们被翻译的原始处理器指令的地址相关联。对于单个指令，从零开始的 计数器用于枚举其转换中涉及的多个 p-code操作。地址和计数器成对称为 p-code操作的唯一<strong>序列号</strong>。p-code操作的控制流通常遵循序列号顺序。当一条指令的所有 p-code执行完成时，如果该指令有<em>失败</em>从语义上讲，p-code 控制流按照对应于 fall-through 地址处的指令的顺序，选择第一个 p-code 操作。类似地，如果 p-code操作导致控制流分支，则按顺序在目标地址执行第一个 p-code操作。</p><p>可能的操作码列表类似于许多基于 RISC 的指令集。每个操作码的作用在下面的章节中详细描述，在名为“语法参考”的章节中给出了一个参考表。通常，特定 p-code 操作的大小或精度由 varnode 输入或输出的大小决定，而不是由操作码决定。</p><h2 id="P-Code-Operation-Reference"><a href="#P-Code-Operation-Reference" class="headerlink" title="P-Code Operation Reference"></a>P-Code Operation Reference</h2><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTU0MjQzZGI0ZGE3YjJmZGQ0YmFmMzM0ZDRmZDQ3MDhfZERzb3ZjRUdwbGFWT1ZLUlBIWVlrUG93amlqendjcE5fVG9rZW46Ym94Y241ZG15WGdOWkRxbUtlQXlqQldvUkRjXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><a href="https://ghidra.re/courses/languages/html/pcodedescription.html" target="_blank" rel="noopener">P-Code Operation Reference</a></p><h3 id="Data-Moving"><a href="#Data-Moving" class="headerlink" title="Data Moving"></a>Data Moving</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjI1NjlhZDA1NDVmNTgyNmZlZGU4YjlhMmIxNjU1NzlfYWNEWG1ENFFId2pBeXJXN3ZuVGRXejhWT1htajdLYjRfVG9rZW46Ym94Y25TSjZNWER1NUxMMnVSdHZWZDJLMUF6XzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGFlNmI4Yzk3N2Q3NzNjZmNhMzNmNGE1YzU0MzFmYTVfZ1RGMm5lOHRxN1FSTm1PNkdzUTZ1cEZCVmltM043aVZfVG9rZW46Ym94Y24xZ1EzWGlIWTJoYkNtY0ljS3ZkVHZoXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzUxNDI2YzM3YmRhMTM3NTY4ZmVkZGQyZTlkODgwNGZfZ0JOajZBOXFsMU1majdPYmpMTGRqOXBDMGRKQW5ZcTdfVG9rZW46Ym94Y25xVjdoM1BidzVRU3g2NkhzdkZWSWJkXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><h3 id="Branching"><a href="#Branching" class="headerlink" title="Branching"></a>Branching</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDVlY2JmZDQyY2MxZWZkOGQ4MjJhNjM4Y2IyOWI4ZGNfSkJ5NHJyM1dZSmVZOHVqZUZ4cFJ3bW1ONUJ1ME5pdVVfVG9rZW46Ym94Y25VYkFXU0JjNUlNTUNkWUwzSzdXc2RnXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTliMmQwOGUzOGRmMmJjNzQzNWFlZGJjZTEzNjdkZmRfYW5LcnF0MjlOS0xhZ3o3bjRXNzY1VXpiRXZvVlNPaEdfVG9rZW46Ym94Y25kUVNLTjZGbDdTRFNDQmROMEZjTUJiXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2I5ZjdlZGVjOTcwZDUyNmFjNjU1MDE4OTlkYWM0Y2RfakZ3RUo3NE1oNTZPS1JJZkJLTUJCenY3bVJvSWRMcmFfVG9rZW46Ym94Y24zY0RCaXprN1FXTm9nNXUxaE5aRVRoXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjczYjhiNzQ3ZTM1NzhmNzI2MzI1MTRiNDFkMTA2ZjdfcjliU096cTBMUEN5UEpZWjhrbVdrZWhwc1NwQXQ4aENfVG9rZW46Ym94Y25GM0tVa2kzR2l3ejVHaTEwZ250SjFnXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGUwZmE1MTU0OTVmY2FjMGI3OWMyOGU3YWRjN2JlY2RfM3pXMUpUV1I0ZWNFeHp6SmtFclJmMjNYR0lYcTBCbUxfVG9rZW46Ym94Y25ra1VGNjVvMDh5cWNNUEFpWXNqQjFIXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGJlN2ViMzBlYzEyNDY1OWExZWU2NGI3NzY1OTc5N2Rfd3lDQW9DSHQyWXNJSzIzOUNzdkg1YzBsZXpSRXRsRm9fVG9rZW46Ym94Y25wV3hEYzNmVGlPRVQ3dHpQclNZQ2RlXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><h3 id="Extension-Truncation"><a href="#Extension-Truncation" class="headerlink" title="Extension/Truncation"></a>Extension/Truncation</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGY2MjZlZDlkMWE5OTIyZThjZDZkYjNjOTZlZTVkOGZfSjhXY25sdk42SGdKSkVVYUxacHRFN2haSTVJMFBFMVJfVG9rZW46Ym94Y25xYndIazByUmRMYkVUYXRWZXhxOUxmXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2RjOWVjYTYyOWIxYmFiODgzMWEwNTNjNTIxMDU5MDlfTHBqaWw5dVJKUXh1MEczdVdNUWw5ZEtIb0VGem1VVExfVG9rZW46Ym94Y25XclFIWmVOTmFBd2NybUFCSEI2RU5iXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODU1NTA2NTAzYjViNWFmNjQ1Y2UxZGRkYTBiNTUzMzVfSTZta3AzdTlVUnptdktxRHFRbVFTMkJlZWhNV2NNb3ZfVG9rZW46Ym94Y25JTm5vaFE1TU9EQ3BMTWYxVkMxdzV3XzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzA5NzA1Y2ZjNTkwMmQ5MzA0ZjBjYmI5OTQyNTU4YWFfb3dZNjJ6aGl0Vms5MjdCTXFuZndWQ3NaY2FvRk9hcENfVG9rZW46Ym94Y25oZUdVZHUxekw2Mk45aU91dUpHWlZjXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><h3 id="Integer-Comparison"><a href="#Integer-Comparison" class="headerlink" title="Integer Comparison"></a>Integer Comparison</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmU0NWEwYWJhOTNhMDY0ZmRhZDJjMDExMjcwOGMyOGFfazRtTE9WMldIeFQzeDlqbGtQeGZ3dGJkNlI3TjQwazJfVG9rZW46Ym94Y25WQ0J3QjNJcWlhRnJ1OHF2Z0s5ZnhkXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDA3MzA3ZWFlNjc0ZTQ5NzQxMzAxMDc4OTAyNzI1MmFfTUpRb0MweGRudWQ0U0VON3pEeUwzVmdvTTlqWk1aT0hfVG9rZW46Ym94Y25IeTJRdDBMV09TNW5QOHAzQXRERWFmXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWUzZmNkNzVlNGVjNDY0YzNiNDJhM2U5YWQ5YmY3M2FfOUxMcE9LNWxTRk1GWFZhTTlPdHl3ZDdhdEFMVWxGclFfVG9rZW46Ym94Y25wNXA0b1hVYmdNZzhpaFJVcHBSRjJlXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmI0NDU3ZTMyYmJiMTRhY2VhMzA1OGIyYTM0YTdkMTlfOWtITDRkdzVPd0JJMlVMc1FZV2thWE5aT2hHdW9DWGxfVG9rZW46Ym94Y25xTnI5ZjlUT043b1pHZmtWNnB6c0ZoXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzkwN2Q1MmRlMzFhNWRjYTc3MTMxMDQwNDFlMzNkZWJfYW1rSWhoUEIweEczWGRMNURHZFgyTXNkVW1MUFN3c1ZfVG9rZW46Ym94Y25JcmROOFJKRUZPM2ZOelRiZ0RqRmxmXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTFhYzgyYjI1MTVjM2E2NzgwYTQ4N2VjODFlZTA3ZDBfN3RraWtMT2x0M2dCREtlYm95TXJiOFNia2pkNVVJbjZfVG9rZW46Ym94Y25ZUHA3eTZDWEdONVNDTzFKczRqU0ZjXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><h3 id="Integer-Arithmetic"><a href="#Integer-Arithmetic" class="headerlink" title="Integer Arithmetic"></a>Integer Arithmetic</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzFhMTg0YjU1OWYxYTBmNTJiNTZlY2EzYWJjZDU2NzFfaFNhdUlibGlPQ0hDS29DZWhZMW4xRENTQUR4eHE4dVJfVG9rZW46Ym94Y25hTVBueEw3R1B4azB6VG1VZXFTU1lkXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGY5YjcxYzkwZDk1MzY1NGFiMTkxMDAxZmZlNTkyMDhfaXlUc1k0R2d4ZndjTVdnT0RpbnExVHNFdHZYOFNSckpfVG9rZW46Ym94Y25Rd2l0MFE0dWxrR0FycktQUmlhWnpkXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTA4OTJlZjE0OGVmNzQ0N2Y2YjJlMjM5MmJkZDUzZGNfM21ZaXp4bUVHWTlmZ3FlSWtvNnVlTEkyVVhPRGpFd2hfVG9rZW46Ym94Y25IZEl1bEpXNnI3TUFKYXk5SnR4ZzdjXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmVjYjI0ZmZjOWY2NDAzYmE5ODFiNjM2YmRiYzNhMGVfZzBOQzA1WEFoWHk0bFllRXdxa05ja1d0UkVBdnVTSzFfVG9rZW46Ym94Y25KY1hOeHloRVBuSFJrZkNZellpR0tnXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MWNjZWNmMWY4Zjk5MTRmMDU2NTEyNjdjMDllN2RiYzlfUld0NUZGbHUyQ1lCcEFLOWNubHZhMkFVV1plbXVKUjdfVG9rZW46Ym94Y256ZzZ1WTc4Q013NnpRZ000SmxJSmVLXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGUzNTZlMTk3YTY4YTcxMDZmNTFkZTBjNmIwOTk3OTdfWWk2ZUFRZElZYWVtRlNCVTFybVg2U0FERDloMWRWU3RfVG9rZW46Ym94Y25zblUzMG90c21najBmNm9VQ3h2WWloXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDc3Yjg5N2VlOGZlMzk0MzU2MWFhZDEzY2E3YTQ4M2NfUGx6TkFDY1VPRmY5Y3lpbXVDT291NW9nNlJWR0NUaXpfVG9rZW46Ym94Y24wcVFRcW9LdXV6WjFVTnpuUDA2QkdnXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQ4MTA0YTNjMmI1NDkyNTg4MzgxODVjNjc3ZjJmZDZfck1kYXlieGFuSTlKYmRrTUdPM2Z3TE53cWF3OWp1THNfVG9rZW46Ym94Y25ZVGNxQUY4d0tsNjd5VHcyUFVVc3hmXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><h3 id="Overflow-Test"><a href="#Overflow-Test" class="headerlink" title="Overflow Test"></a>Overflow Test</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGQ0YWVmMTRmYzVjODczZjI3MTdkN2FhZWYzMjE2YTlfSnY1YlFWeENjTndMYng3WFA1TmhsYXJldGZFZzVLcDRfVG9rZW46Ym94Y241akdRMUM1N01CTDliQk1adERSeFFjXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjM1MTE4OGMxMTZiODVhYmM2MjRjYTEwZjNjZmY4NjNfR01UbHhZMWw0OFNYejFINWtMdUNWNzNYUlNhbjNwM0dfVG9rZW46Ym94Y254Q21yd09Bc0VRRGxqbGpjejlSaExiXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MWEwNjIwYzk1ZjA1ODQ1OTlkYWM0NTg3MDhlN2VmZWFfc2lXSWxJOTBxYkJIbFh0OGxhSm1PUlZZZWl1YzFGYVlfVG9rZW46Ym94Y25ONnBmR1h0MlBuT3F2U0w0cU5Fa25mXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjZmNTE1ZmMzYmNhMjEwMDEzYWIwMTA5YmFmNDZiNTBfR01ybU1ZOTUzOHBvclBKN2IyeEtOZXJKSzQwZUZzOFJfVG9rZW46Ym94Y25FWk1ERTE1SUVFWEQxUERrQ1RsdWNnXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><h3 id="Logical"><a href="#Logical" class="headerlink" title="Logical"></a>Logical</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjM0YmU2ODk3MjEzYjNmYzgyMThjYmQ5MzViZGE3MzFfeDRVYWIyelVjVVhEaEN1T0xGS0h1RzQ4Q0NUa0tNRzdfVG9rZW46Ym94Y240cmF3U29RakZ4YzZtU0VDeUVwSUhlXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmJiM2VhZGY5MjNlNTA5NGY2NzExMWEzZWI5YWRhOTJfM2kxYXE1OTRlSGljRmhpdWMyc25TelV6VVpVcWcwbFdfVG9rZW46Ym94Y253YVN1U3JxTFkzV3NadnVtWUVaT05NXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTIyOWRjYjExMGJlZmE2NDljYzYwMDRhYTVkNjRiNTFfdzRtUkpMcU1pNTlYdXlZTGRvdURZSGcwdWVQU1ZDb09fVG9rZW46Ym94Y25EaTBHQm5DYkhKcURxVU5uZm5VM2ZmXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGNlMDZlZjgzZWJkNjg2N2NhNDU1NzIxN2ExZDQ1NjZfeDFZR2JQbkN3NmtjRHQ5Y1dEVUZPS3FVejg3TUFRTzFfVG9rZW46Ym94Y25NU2VZVG55bEdybTc3N2RoVjM3bFBkXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><h3 id="Integer-Shift"><a href="#Integer-Shift" class="headerlink" title="Integer Shift"></a>Integer Shift</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGRmOWM5NmVmYzNmOGMwZGVkZDQ2ZDk4OGEyYTQwNDFfZThuMEkzWERmeVFsTDRBem1weXlZQlZVVDNGVXZKVzRfVG9rZW46Ym94Y253OW44c3gzcWRJZnpyQkdPaWVReXdaXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWZjYmEyYWIxNjM1NzdlMmQ2N2Q0YmEzY2QzYTA3N2ZfcUFoWWRxV0pVeVNnTlJQUW85TnFVNGVnenBvcVo1MHRfVG9rZW46Ym94Y24yU2hwelZ6UnUwVVN5U3FDTkdDODFkXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTlmNTQ1NTIwYzBiMzE4Mjc1NzZiNzNjZDU5ZWNkZjZfN2NqMHhacDNqbGNacTJST2Q1Q2EwQ2lrSDBnYXk3U2tfVG9rZW46Ym94Y25QYmQ0NWFRODVNOUI2ZmpKOXUwbGpmXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODkwNzA3Zjc3MGEzODFjY2RhNzRmMGFmM2IyNTkyZjdfa3IxeWpzQzFEZG5jTjZwUURsdkhySDVsMG5VQUVpWnRfVG9rZW46Ym94Y25MZ3Rvd2tOWWQwbzZHcWE0bnB5M0lkXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGU1Zjk2NDQyZjI3MjFjMzQ0OWVlYTdlNmMzMzU2MjlfWVhOVWxHOHdiVzFFY0IwVXBFd1hheURxeW5LelNLRk9fVG9rZW46Ym94Y25lOWlKQ0MzdmxsQ1FTQ0FiUWZWRlBlXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWM2ZDhkZmJlYjhlMzg0ZmFjOGNjM2ZlNThmODUyMWZfSWxBbkhNQ1FWWHV4Q1pnSmJqaXBCOXdhMmRId25uSEFfVG9rZW46Ym94Y25tOGczT3hsTFZXbFg2RElzb2JQS3FmXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDc1NjgwODU2MDRjZjJlMjM2YzhiMjBiM2E0ZjkzYTdfOUhJb3pjVWtvVFMzZkVSbWhCdHA4c012SmwyVkdGaERfVG9rZW46Ym94Y25rZHJFbXBoc3JSMlVMbk00cnZhckFoXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><h3 id="Floating-Point-Comparison"><a href="#Floating-Point-Comparison" class="headerlink" title="Floating Point Comparison"></a>Floating Point Comparison</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWRmZmY3ZGI0ZDVlMTI5YWI1NTk0Nzc0ZTlkY2QyNjFfVEhtWXpJS1g2cWpDdmZDTnJaSzhPV3ZpaWJySnBFbTNfVG9rZW46Ym94Y25ENjdmemQ4TWdZWTM0WU5WaWw5NFFMXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2VhODhhOWFhYmM3YTcxNmJkMThkMTY0MTU5YzdmYjRfZE94eWFmRG1pcGxnbnhCU2xzS2xsUW10VjdiQnBoS3ZfVG9rZW46Ym94Y25aZzRURkh3azJWa3RVN3NQbG02eHBnXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MWMzNjRhYjlhMDdiM2FiNDAxZTZjNWM0N2NmMzIxNWNfZzY3SnZybXB4d1F6ZWlJVXNMcWo4dTRLd3lxVXBhbWtfVG9rZW46Ym94Y251VUhEeE5taGJCUGdBdkdrcUlnN0hmXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjhhN2ZmODkwNmNiZDQ4NGI3ZTliNjAyOGYwZDkwYzJfak1lWDdVc0U5WlR4R0pIRlpEcXI1U01YYnVmdnV5UmtfVG9rZW46Ym94Y25YdmdqUFRiQTNxZDdLRVBMV2dGZkVnXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><h3 id="Floating-Point-Arithmetic"><a href="#Floating-Point-Arithmetic" class="headerlink" title="Floating Point Arithmetic"></a>Floating Point Arithmetic</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjNjZmY5MGQ5YTZlNmQ1MzE2Njk1MzUwMDFkMzc0NmNfOUJodmxyM01vYW15TjRSTUhxd2lNbmFiRkI1cFZsNW9fVG9rZW46Ym94Y242WVBsR3VXZ3RMdENrRnhWRmVjR2piXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGQyZTdhNDI3ODFkMDZhZWFhZDNjOGEwOTUzMWM0ZjdfQ3dsOUFqTkd0dUtVTHJzNVZ6SWNqRDJCUmh5alNyMFpfVG9rZW46Ym94Y25NdGFPQW1LT0JQTW15OHlFUEluY09jXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWVhM2MwYTliZmI2ODZkNTFiYjhiYThkZDQ4MDM3ZDhfeG5kZHM5RWZBdmNtZG40UDA1MXNNbDhMMWY2dFVEOFhfVG9rZW46Ym94Y25CdnBqbDVCbFZsT1NNOTFJMGxwZk9kXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmFmM2YwZGJlODljZjViNzA2NWMwZGFhN2UyMTFjM2RfWkhYbzhYamNpajA5eFk0d2FwY1FReEVPUENSU1hPYWtfVG9rZW46Ym94Y245VGFqNGpZcnNYNTAxV3BDYkRKdnlkXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjVkYTI0MmMxMDI5MTQwNjIxNDIxYjAwNDNiODk2NmFfWlBmV3dEZERxOFUyV0ZSRklNOHVIVlYzZTBZOHhwUW9fVG9rZW46Ym94Y250ZEdLdGFjWUJNdDU1UWQydTFiRWtmXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWZkNGNmYTZiNGQ4NmUxMTgxNTVmNTk2NjJlYjg1YWFfN0drd0ZsRDFXZzQ1WVp3NnB3WkVhanNoaXhvWTVJSUdfVG9rZW46Ym94Y25CMVFxYlJQU2FJSE1zN0RlYmtyVHRiXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzZhYmU1MDUzNWQyOTMxNDI5OTNlYWM0ZmJjMGE1ZmNfaGRkY1BZN2sxRVpKcjNnOFFXejlmSXdaSWowb2pLTXVfVG9rZW46Ym94Y254SkZ0SmNlU1RpdUJPVHYzOTdpaXZiXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><h3 id="Floating-Point-Conversion"><a href="#Floating-Point-Conversion" class="headerlink" title="Floating Point Conversion"></a>Floating Point Conversion</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzgxMDJlM2QwMGVhODFlODM2NjIzZWEwYjJhNjVlNDhfRXhVdXFwdm5CZFRQQVpBYTd3OU4wdjAyQ0g2NzBzbWJfVG9rZW46Ym94Y25YOVZyVzUwTTBqcnVGYm83aEl1VFYzXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmIzZGM2ZDMwY2M4NjlmYzI3MWI4YmFhMTAyM2U3M2FfSzFXV1Jua0UxTXZDVkwwWDkySUFBOW1jcnBKbE9JM2xfVG9rZW46Ym94Y252dktzTHVkN0llbTk5SmtVa1BUS3JiXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MWVlYzRkNWFmZmM2NTBlMzcwZmE0Y2M5MDAxYjFjN2NfQURUS1djMU9YeXlCanFhbW81QUNYeWxNT3M5QndCMEFfVG9rZW46Ym94Y25JNmFOTnlMQ2dlSEpmNmtlOWZTY2ZjXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTU2MTk4M2ZjNzZjY2NmN2FmNTU0Y2U2MmYzN2E2ODZfTFhSOTJjeE1keHlwakN5NFU1ZWZFcHJkWHM1aHRyNXFfVG9rZW46Ym94Y25rOWJ1WXZrWU41NjJzTEk3T2ZEczZkXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTI2OTFkNGIzODYwZmExZjBjNjkyMGRhMzJlNmNjNTFfUTZudHdxWFJ2N3p1dWdscVdNNm9NSkczWnJGVW5GbGdfVG9rZW46Ym94Y25xTlNobmZBdXhPd2pnOUNLcHVoVlBmXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2E5NzdlNWYxZDgwZTExMTU5NmNhZDAxNDg4MzM0ZmJfbkRHcnVWcllQTHY1MUR4QjYybFNSaU1hM200N1FwMkdfVG9rZW46Ym94Y25LMHBySHZPa3dwQTZPWWJnSkVtNEs5XzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><h2 id="Pseudo-P-CODE-Operations"><a href="#Pseudo-P-CODE-Operations" class="headerlink" title="Pseudo P-CODE Operations"></a>Pseudo P-CODE Operations</h2><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTNiYTg1OWUyMGJmN2ViNGE5NWM0MmZiMGM3ODg5NGNfUXprcnpzTExkM2V6d21DbDkzUTVRSFQ5dTVTaHAyYURfVG9rZW46Ym94Y25GMW1HYndWTVBrNUY5bDV6Q0JBUHpmXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTYzYjFiN2RjNjViYzk0Nzk1MjlmNWQ1ODY2NzNhZTlfdWRjNjF0bmZ5NHh4M3NxZFFhakRWNUEzNTRLb3IwSHlfVG9rZW46Ym94Y25sT1RDeDY0ZEZGMXpTZ0hROEplbW1mXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzczMDg0YzA5NmYxMzYxMTEzYzQ3ZmQyMDIwNGMzOTlfOXdNWHUxeXlMbWhRUFloVUo1ck55T2pNRnpubER3akpfVG9rZW46Ym94Y25BRmlHeWYycXhVbDFKTm9KYmdvMEtXXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><h2 id="Additional-P-CODE-Operations"><a href="#Additional-P-CODE-Operations" class="headerlink" title="Additional P-CODE Operations"></a>Additional P-CODE Operations</h2><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjhhMmMyMTliNjlmOGVhOGIwNzA5ZTZiODhmNjQwOGFfRlNGZXE4MnYyQ0l6WU1IMzFtcHhwbGJvZjhqN2tWeFhfVG9rZW46Ym94Y25aQkZQMjBqbUdLeko5RnVVeXZnakplXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODllODg0N2FlNjBlY2JmNWUwNThkOTE5YjI0YTVlOWRfZURmdEZ1cERjbzlTUWZCMmI4ZFZqY2Fvd0swenllcDVfVG9rZW46Ym94Y25QZ3VreUVmbE0wRGlKbk9sUnhTc0JmXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDFlNzY2ZTZkNmVjYmMxNDEwYjgxNWI2NWJhYzc2YTlfQlRud2cyWVFZSHpmQ0RDeUdsSFBCdVc1QjJYanJSR1FfVG9rZW46Ym94Y25WbXhiTVdHd2RpSERySEM5eUVKTmNxXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjBmNzE2MjE3ZWQ1ZjY0YjM4YzM5YWM2OTA5Y2U0MzZfazUxUmpuRnY4d1ZYd1RocVcyTmpPQTFPRmVMd2hqM0NfVG9rZW46Ym94Y242aHlBMG1NSjQ1V0d5RkhiQXlxRE1jXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjE2MzMzMTk1MWYyMDQ4MmExODAwNTk5YTUwYjk2ZGFfRmpPaWFRRTRNeGxGVXVmNXR5dXhHUnI0TUp4eERsRGlfVG9rZW46Ym94Y254cTVETkYwOG5QVzVPMUh2MnRjb0tjXzE2MjcxNDgxNzY6MTYyNzE1MTc3Nl9WNA" alt="img"></p><h2 id="Syntax-Reference"><a href="#Syntax-Reference" class="headerlink" title="Syntax Reference"></a>Syntax Reference</h2><p><strong><a href="https://ghidra.re/courses/languages/html/reference.html" target="_blank" rel="noopener">Syntax Reference</a></strong></p><p>无法复制加载中的内容</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Decompile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ghidra | IR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反编译理论基础</title>
      <link href="/posts/3d8e.html"/>
      <url>/posts/3d8e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>参考论文：**</strong><a href="http://www.phatcode.net/res/228/files/decompilation_thesis.pdf" target="_blank" rel="noopener">Decompiling</a>**</p></blockquote><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="The-Phases-of-a-Decompiler"><a href="#The-Phases-of-a-Decompiler" class="headerlink" title="The Phases of a Decompiler"></a>The Phases of a Decompiler</h2><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWY3OTU3OTYwYWViMGFhODAxMzdjZDAzYWJjMmU5N2RfUkZhVnRLclYwOG96U0NpamJVMmhoRFFBTWVBUzU4MjJfVG9rZW46Ym94Y25wNTl4cnBMSTdJeHFDenk1MWRrMkVnXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img">)<img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGQxNWY0NDhiYWZhYjM4MWVlOWY3Y2MwMjQ4OGYxYTNfdFB2UllIY0hYSHdWS1lwcEZkWHp1UWJuUUVQd1lCRzNfVG9rZW46Ym94Y25Jb3AwWlhISlNoZzl0ZmFFMnNNN2RaXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Syntax Analyzer 语法分析</strong></p><p>什么是数据，什么是指令？</p><p><strong>Semantic Analyzer 语义分析</strong></p><p>语义分析阶段检查源程序中指令组的语义，收集类型信息，并在子例程中传播该类型。如果二进制程序是由编译器生成的，则机器语言的语义是正确的，以便程序执行。它实际上是由于编译器生成的代码中的错误而导致二进制程序不能运行的情况。因此，除非语法分析器错误地分析了一条指令，或者分析了数据而不是指令，否则源程序中不会出现语义错误。</p><p><strong>Intermediate Code Generator 中间语言生成器</strong></p><p><strong>Control Flow Graph Generator 控制流图生成器</strong></p><p><strong>Data Flow Analyzer 数据流分析</strong></p><p><strong>Control Flow Analyzer 控制流分析</strong></p><p><strong>Code Generator 代码生成器</strong></p><h2 id="The-Grouping-of-Phases"><a href="#The-Grouping-of-Phases" class="headerlink" title="The Grouping of Phases"></a>The Grouping of Phases</h2><ul><li><strong>前端：</strong>包括那些依赖于机器和机器语言的阶段，这些阶段包括词法、语法和语义分析，以及中间代码和控制流图的生成。作为一个整体，这些阶段产生了一个中间的、独立于机器的程序表示；</li><li><strong>udm：</strong>是一种完全独立于机器和语言的中间模块，它执行反编译分析的核心。该模块包括两个阶段：数据流和控制流分析器。</li><li><strong>后端：</strong>由那些与高级或目标语言无关的阶段组成。此模块是代码生成器。</li></ul><h2 id="The-Context-of-a-Decompiler"><a href="#The-Context-of-a-Decompiler" class="headerlink" title="The Context of a Decompiler"></a>The Context of a Decompiler</h2><p><strong>A Decompilation System：</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MWUwNzkzNzEzMGZiYWY0ZjJmZmZjMDY5OWUxNGZhYzNfajJFQVJCWkRSSFB2TEo1WVc1b1VNWHJwNU5rUWMzUDhfVG9rZW46Ym94Y25CYWtHUHc1RVpFVzAzazdVcWxHTE1iXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Loader</strong></p><p>加载器是一个程序，它将二进制程序加载到内存中，如果机器代码是可重定位的，则重新定位机器代码。在重新定位期间，指令会被更改并放回内存中。</p><p><strong>Signature Generator</strong></p><p>签名生成器是自动确定编译器和签名库性质的程序；唯一标识每个编译器和库子例程的二进制模式。使用这些签名试图反转链接器执行的任务，链接器将库和编译器启动代码链接到程序中。这样，所分析的程序只由用户子程序组成；用户在最初的高级语言程序中编译的那些。</p><p><strong>Prototype Generator</strong></p><p>原型生成器是一个程序，它自动确定库子程序的参数类型，以及函数返回值的类型。这些原型是从库头文件派生的，反编译器使用和来确定库子例程的参数类型和这些参数的数量。</p><p><strong>Disassembler</strong></p><p>反汇编程序是将机器语言转换成汇编语言的程序。一些反编译程序将汇编程序转换为更高的表示形式。在这些情况下，汇编程序是由反汇编程序生成的，是在汇编程序中编写的，或者编译到汇编程序。</p><p><strong>Library Bindings</strong></p><p>每当反编译器的目标语言与编译二进制源程序所用的原始语言不同时，如果生成的目标代码使用库名（即检测到库签名），尽管该程序是正确的，它不能在目标语言中重新编译，因为它不为该语言使用库例程，而是为另一种语言使用库例程。库绑定的引入通过将一种语言的子例程绑定到另一种语言来解决这个问题。</p><p><strong>Postprocessor</strong></p><p>后处理器是将高级语言程序转换为用同一种语言编写的完全等效的高级程序的程序。</p><h1 id="Run-time-Environment"><a href="#Run-time-Environment" class="headerlink" title="Run-time Environment"></a>Run-time Environment</h1><h2 id="Storage-Organization-存储组织"><a href="#Storage-Organization-存储组织" class="headerlink" title="Storage Organization 存储组织"></a>Storage Organization 存储组织</h2><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2NjODM3ZWQwYmM2ZGQ1YzZhN2ExODAyNDc4MjQ2NGVfTGYzMks3ZWRKRDlxVGNmRHBhbHlaT3BZWUVZTTRhQ3pfVG9rZW46Ym94Y25NN21wRmRkM2pOcld0NmwzZjl2dUZlXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>The Stack Frame</strong></p><p>在运行时，每个子例程都与一个堆栈帧相关联。堆栈帧是调用子程序的参数、局部变量和返回地址的集合。堆栈帧中的参数表示子程序特定调用的实际参数：二进制文件中未存储的子程序形式参数信息。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTQ2NDAwZGQyYTlkOTMyYzliZGI3MGZkOTllYjgwZWNfVHlCdmtXUjVWUklVcmJuNVFSUzJTWGRoZmJ6ejFmcWNfVG9rZW46Ym94Y25aam5MUnNVUWZFelVKSGtyejllNGNUXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img">)<img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGMwMjM1M2ZlMDc5NzM5ODdhMWNmNTQxOTgzMWFlZWRfOFZTVVZIdFNnT0Y0YXZoVlZ3OWdJYzhDeVZ2Sm1CazdfVG9rZW46Ym94Y25NcDUxcDhDVk5YRWNNelVHajgzZ25mXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h2 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h2><p>数据对象通常存储在连续的内存位置。基本数据类型（如字符、整数和长整型）可以保存在寄存器中，同时对它们进行操作。聚合数据类型（如数组、字符串和记录）不能全部保存在寄存器中，因为它们的大小通常超出寄存器的大小，因此通过指向它们的起始地址的指针来访问它们更容易。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzNlNDQxMmZhZDg1ZDBiMmVjNjYyYjA0NWU0ZGY4YjZfbW5wc3A2SEphRFlHcnNtQ0Jic0x3M3Zma0RUd1FjZDlfVG9rZW46Ym94Y242NklJYVUydUdCeXU0d0U1MFhIblhkXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Array</strong></p><p>数组是一个连续的内存块，其中包含一个或多个特定类型的项。数组在内存中实现为一系列行或列，具体取决于语言使用的顺序</p><p><strong>String</strong></p><p>字符串是一系列字符。不同语言使用不同的表示形式进行跨距，例如：C语言字符串是以空字符（即0）结尾的字节数组。</p><p><strong>Record</strong></p><p>记录是一个连续的内存块，它保存一个或多个数据类型的相关项；<code>struct in c</code>、<code>record in pascal</code>和<code>user-defined type in Basic</code>。</p><p><strong>Complex Numbers</strong></p><p><strong>Boolean</strong></p><h2 id="High-Level-Language-Interface"><a href="#High-Level-Language-Interface" class="headerlink" title="High-Level Language Interface"></a>High-Level Language Interface</h2><p>高级语言的编译器使用一系列约定来允许混合语言编程，这样一个程序可以有一些用一种语言编写的子程序，而其他子程序则用另一种语言编写，所有这些子程序都链接到同一个程序中。这一系列约定与堆栈的设置方式以及用于调用子例程的调用约定有关。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDI1OWI5YmIxMTRkNWE0ZmVhZDg2OGQwOWNmOGFjNDlfa0Z0WHJ5T0hJQkdCZWxVVFVkTm0zdU83aDdDODBwVzNfVG9rZW46Ym94Y25TeTRaQ2ZmNElmNklyaHQzSjRVUTJkXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h2 id="Symbol-Table"><a href="#Symbol-Table" class="headerlink" title="Symbol Table"></a>Symbol Table</h2><p>反编译器使用符号表来存储整个程序中使用的变量的信息。在二进制程序中，变量由地址标识；没有名字。具有物理内存地址的变量是全局变量；它们的段和偏移量用于访问它们。位于帧指针负偏移量处的变量是相应堆栈帧初始值的局部变量，正偏移量处的变量是子例程的实际参数。由于编译器使用寄存器变量是为了提高效率，所以所有寄存器最初也是考虑变量；对寄存器的进一步分析确定它们是否代表寄存器变量。</p><h4 id="Data-Structures"><a href="#Data-Structures" class="headerlink" title="Data Structures"></a>Data Structures</h4><p><strong>Unordered List</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGJhMjRjNjM0OTU5YjU4YTkyYzVhYzI0ODc0ZjExOWFfMXo0N2pITE9ha2dOckhWTHNsbVN2cHd6R05GNnpIOHRfVG9rZW46Ym94Y250d0dTaU9ONHE1MHJpRE4zckNWNHFjXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Ordered List</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDM1MGFiMmNjYzgyNzYyY2VkNjM5MjM2YmNjNGM2NjZfYXBDdjNqZ2FHdkZVWUdQZ3Fjc2NibkgwbEtYMzNvU1ZfVG9rZW46Ym94Y25PdXNJYjRKNUFFN3JLdlExVUZqeWhoXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Hash Table</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDZmOGJhMTkxY2U3Zjg2MDZhZmJjMDA2N2ZhMmIyZWNfZW9MNzNIM0NVU3VXUFNNamcxVThTaHNDMHhpM1FUcnJfVG9rZW46Ym94Y25iVUVVQmdacjNsSEYzZEh3RFZJTG9nXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Symbol Table Representation for Decompilation</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGQxNjg3NjJlNjY1M2IwNzlmZDNkNTUzZmZhZTA5N2RfZTlFRDMxMHFUWFJJMVNab2czZUwxMEtiQzgwWFV0bzRfVG9rZW46Ym94Y25acUF4dWFJMVJSZnI1YTZ3VTN4b0pnXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h1 id="The-Front-end"><a href="#The-Front-end" class="headerlink" title="The Front-end"></a>The Front-end</h1><p>前端是一个依赖于机器的模块，它以二进制源程序作为输入，对程序进行解析，并产生控制流图和程序的中间语言表示作为输出。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmMxNzk1YzVhMTg3YTNhMzkyZDg1YmQ2NTEwZmUzYTVfZTV5aXhwcEtXZ0tORWcxalV6dkNnN2NvMmJmSlozdTZfVG9rZW46Ym94Y25pMW9rOW5QbXpYZURJWEpMeVJucFFjXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h2 id="Syntax-Analysis-语法分析"><a href="#Syntax-Analysis-语法分析" class="headerlink" title="Syntax Analysis 语法分析"></a>Syntax Analysis 语法分析</h2><p>语法分析器是反编译器的第一阶段。它的作用是将一系列字节组合成一种语言的短语或句子。检查此字节序列的语法结构，即字符串是否属于该语言。有效的字符串由解析树表示，解析树被输入到下一个阶段，即语义分析器。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGE5OTMzNzdiNmIxOGU5ODU0ZmNlMzZjZWU3MDU4MDdfSGFkdTV3NEh6QVhtZzdCN0JVMWI0bGNhWmQ5NElPbmdfVG9rZW46Ym94Y25pS0lVc0xMalpzSUU2N3dpZlp2enpkXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Syntax Error</strong></p><p>在二进制程序中很少发现语法错误，因为编译器会为编译后的程序生成正确的代码以在计算机上运行。但是，考虑到机器体系结构的升级会产生支持所有先前机器的新机器，新体系结构的机器指令集是旧体系结构指令集的扩展。</p><p><strong>Finite State Automaton</strong></p><p>有限状态自动机（FSA）是一种语言识别器。它接受一个字符串作为输入，并回答该字符串是否属于该语言。字符串是给定字母表的符号序列。给定一个任意字符串，FSA可以确定该字符串是否属于该语言。</p><blockquote><p>数学模型：一个FSA的基本组成</p></blockquote><ul><li><blockquote><p>有限状态集S，state</p></blockquote></li><li><blockquote><p>初始状态s0</p></blockquote></li><li><blockquote><p>最终状态或接受状态F</p></blockquote></li><li><blockquote><p>输入符号的字母表∑，symbol</p></blockquote></li><li><blockquote><p>转换函数t:state × symbol → state</p></blockquote></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTk5NmZmOWY2NDk1MTAyZDdmZGE5Nzc2ZDg4M2JlZjVfdGRTeHhGdjZldkozcFk5YktjQzQxYUs5V0N5WXczNlJfVG9rZW46Ym94Y25MS2NKaTRtWW5nd3hSaHdYdmx6akJjXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p>使用了两个元符号“<em>”和“%”。符号“</em>”表示字母表∑中零个或多个符号的任意序列，“%”表示∑中的任意单个符号。</p><ul><li>Non-deterministic Finite State Automaton 非确定性有限状态自动机</li><li>Deterministic Finite State Automaton 确定性有限状态自动机</li></ul><p><strong>Finite State Automatons and Parsers</strong> <strong>有限状态自动机和解析器</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzFkYmNiMGI0NWUxNDY5Y2NjYmEwNzhjYTkyZTc4YzZfa0NOMUFFN1hVeUFtUjViT0tuVzJLMzVjcGNabXdWc3ZfVG9rZW46Ym94Y25ldDdDZVBXMFF6NTFva2dqbFNuS2pDXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Separation of Code and Data</strong> <strong>代码和数据分离</strong></p><p>给定程序的入口点，语法分析器的功能是按照程序的所有可能路径解析机器指令。解析器面临的主要问题是数据和代码在von Neumann机器中是以同样的方式表示的，因此不容易确定一条指令后面的字节是属于另一条指令还是表示数据。</p><p><strong>Indirect Addressing Mode 间接寻址</strong></p><p>间接寻址模式利用寄存器或内存位置的内容来确定使用这种寻址模式的指令的目标地址。间接寻址模式可与无条件跳转（例如，实现索引的事例表）和过程调用指令一起使用。这种寻址方式的主要问题是，在程序执行过程中，内存的内容可能会发生变化，因此，对程序的静态分析将无法提供正确的值，也无法确定内存位置是否已被修改。这同样适用于寄存器内容，除非寄存器的内容正在被仿真，但同样，如果寄存器在循环中使用，寄存器的内容很可能是错误的（除非循环也被仿真）。</p><p><strong>Initial Parser Algorithm</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmE4NzVmODg3NmMyZmU3MTY3OTE1NTBjZjRkOTI3YTlfdVV5VXpyNjNNRzBrTnNlU1h6Y1A3RUNUU2Q0WkwyS2FfVG9rZW46Ym94Y25ObjBtWTRWdnVwRmZKRE1GNWpDUldjXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Final Algorithm</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODA3MDg5ZmY2MTEyOWYyNWM5NzczYTRlZjJkM2JjNTlfWDg1NVVHOTBnZXRId2dGOHJnWVd3SEFaSlA4M2J0Q25fVG9rZW46Ym94Y254MjI4d0FWelY4M245VklFVDkzVEVlXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h2 id="Semantic-Analysis-语义分析"><a href="#Semantic-Analysis-语义分析" class="headerlink" title="Semantic Analysis 语义分析"></a>Semantic Analysis 语义分析</h2><p>语义分析阶段确定一组机器指令的含义，收集关于子例程的单个指令的信息，并在子例程的指令之间传播这些信息。通过这种方式，整数和长整数等基本数据类型会在子例程中传播。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODMzZWE4OWQwZjNjOTRlOWQ1NmViY2FjODU4MTg5NzJfU2M4YWlkR3U2QWg5Z1RaZjZWanNwV1hTcFJEQUd6TGxfVG9rZW46Ym94Y25XT1BoczRhcmlSVUUzalZ2WUtWaHZSXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Idioms</strong></p><p><strong>Idioms</strong>是具有逻辑意义的指令序列，不能从单个指令中推导出来。</p><p><strong>Calling Conventions</strong></p><p>C调用约定也称为C参数传递序列。在这个约定中，调用者按照参数在源代码中出现的相反顺序(即从右到左的顺序)将参数推送到堆栈上，然后调用过程。</p><p><strong>Long Variable Operations</strong></p><p>长变量作为两个连续的内存或堆栈位置存储在内存中。当对这些变量进行简单的加法或减法运算时，通常会识别出这些变量。用于这些操作的习惯用法通常是因为它们的指令数量简单。</p><p><strong>Miscellaneous Idioms</strong></p><p>一个广为人知的机器习惯用法是给变量赋值零。不使用mov指令，而是使用xor:每当一个变量与自身进行xor运算时，结果为零。这个机器习惯用法使用的机器周期和字节比它的对应用法少。</p><p><strong>Simple Type Propagation</strong></p><p>字节和整数等基本数据类型的符号很容易由用于比较操作数的条件跳转类型决定。这种技术也用于确定更复杂的基本数据类型(如long和real)的符号。</p><h2 id="Intermediate-Code-Generation-中间代码生成"><a href="#Intermediate-Code-Generation-中间代码生成" class="headerlink" title="Intermediate Code Generation 中间代码生成"></a>Intermediate Code Generation 中间代码生成</h2><p> 在反编译程序中，前端将机器语言源代码翻译成适合通用反编译机分析的中间表示。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWJhNTg5NzRjY2YyZWIxYTk3NDQ5YWIwMThmZTkwMmVfUTg3dmRRTEVibHlBdlgyVktnSlJKQ014NlMzWHdnaE9fVG9rZW46Ym94Y25tTUN6QXVqSkUzTkc2eEdYV2hCbkNkXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p>反编译采用两步方法:首先使用低级中间表示来表示机器语言程序。习惯用法分析和类型传播可以在这种表示中完成，也可以从中生成汇编代码(即，它是适合反汇编器的中间代码，反汇编器不对代码执行高级分析)。然后，该表示被转换成适合于高级语言生成的高级中间表示。表示需要足够通用，以便为任何高级语言生成代码。</p><p><strong>Low-level Intermediate Code</strong></p><p>低级中间表示以四元组实现，这使得指令中使用的操作数显式，操作码字段保存低级中间操作码，目的字段保存目的操作数(即标识符)，src1和src2字段保存指令的源操作数。有些指令不使用两个源操作数，因此只使用src1字段。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTE1YTdkNTExZWU3MzRlYmY4ZjcwNWRjMmIyMWY2NDVfT1VKTVVvSFBwTGdtbDRqdnJJeFpOcklxeWhWeUdPNDdfVG9rZW46Ym94Y25MSEhiRHlMV1V0aEJsdlFuc1EwWkdkXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>High-level Intermediate Code</strong></p><p>三地址代码是三地址机器的一种通用汇编代码。这种中间代码最适合反编译程序，因为三地址代码是程序抽象语法树(AST)的线性化表示。这样，在数据流分析过程中可以重建程序的完整AST。三地址指令具有一般形式：x := y op z。</p><p>高级中间表示由三元组实现。在三元组中，两个表达式以及指令操作码都是显式的。结果和参数字段是指向表达式的指针，表达式的最小形式是指向符号表的标识符。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGIyMzg0YjMzNDc0YmY2MWY5MGU1MjI4NTY3ODU1YWJfTjNscjhHMXhmUjR2b2JaS0RHTEs0SzNnT1dYUmw1NVlfVG9rZW46Ym94Y245OUxqeHlQR1pYR0dKQXNETkowNkhmXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzdhMGQ4OTEyYjljMGQ5OTI1ZTkyOWY4NjAzYmZkMDBfNU9xaVlKNGtpRWFiUjNybWt1bXZXZkNRbzJvVWUzWkhfVG9rZW46Ym94Y25XUVJKWUJObGN4RFdUdjV0cmlIYVpkXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h2 id="Control-Flow-Graph-Generation-控制流图生成"><a href="#Control-Flow-Graph-Generation-控制流图生成" class="headerlink" title="Control Flow Graph Generation 控制流图生成"></a>Control Flow Graph Generation 控制流图生成</h2><p>控制流图生成阶段构建源程序的调用图，以及程序每个子程序的基本块的控制流图。这些图表用于分析通用反编译机(UDM)模块中的程序。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGRhNWY5MTU0MGJhNjIxZjhhNGMxZGE4YzExNWZiY2VfdUdyVTVPbTFQRGd2MHpwZmZmOXJJNHdJUG5uZUhoS0VfVG9rZW46Ym94Y25EQk83QUZQWlF2TUdJazR4ZkNUY3BnXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Basic Blocks</strong></p><p>基本数学抽象和原理</p><p><strong>Control Flow Graphs</strong></p><ul><li>单向基本块:基本块中的最后一条指令是无条件跳转。这个街区有一条外边。</li><li>双向基本块:最后一条指令是条件跳转，因此，该块有两条外沿。</li><li>n路基本块:最后一条指令是索引跳转。案例表中的n个分支成为该节点的n个外边缘。</li><li>调用基本块:最后一条指令是对子程序的调用。这个块有两个外沿:一个指向子程序调用后的指令(如果子程序返回)，另一个指向被调用的子程序。</li><li>返回基本块:最后一条指令是程序返回或程序结束。这个基本块没有外边缘。</li><li>fall基本块:下一条指令是分支指令的目标地址(即下一条指令有标签)。该节点被视为落入下一个节点的节点，因此，只有一个外边缘。</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWNkMjFiMDI0NzI2NzkyOTAzZmUwZjJhYWVmZmU4YmFfTXlNcGN0YUpSUDY1SldHekRRWDV2SzcxWlZrVmJ6MTlfVG9rZW46Ym94Y25lNjhXclNJZFQwcGRLdGlBejdzUXpoXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Graph Optimization</strong></p><p>一次通过编译器生成的机器代码以跳转到跳转、条件跳转到跳转以及跳转到条件跳转的形式利用冗余或不必要的跳转。这些不必要的跳跃可以通过控制流上的窥视孔优化来消除。不过，这种优化并不总是被使用。窥视孔优化是一种通过检查目标指令的短序列(称为窥视孔)并用更短或更快的指令序列替换这些指令来提高目标程序性能的方法。窥视孔是目标代码的一个移动的小窗口；窥视孔中的代码不需要连续。通过窥视孔优化所做的每一个改进都可能产生额外改进的机会，因此，重复传递代码是必要的。控制流优化是消除冗余跳跃的方法。对于反编译，我们感兴趣的是消除到跳转的所有跳转，以及到跳转的条件跳转，因为目标跳转保存目标分支的地址，并且利用可以从图中移除的中间基本块。删除跳转到条件跳转是不可取的，因为它涉及几个指令的重新排列，而不仅仅是修改一个目标分支地址。</p><p><strong>The Call Graph</strong></p><p>调用图是程序子程序的数学表示。每个节点代表一个子例程，每个边代表对另一个子例程的调用。</p><h1 id="Data-Flow-Analysis"><a href="#Data-Flow-Analysis" class="headerlink" title="Data Flow Analysis"></a>Data Flow Analysis</h1><p>前端生成的低级中间代码是利用寄存器和条件代码的汇编型表示。这种表示可以被转换成不使用这种低级概念的更高级的表示，并再生高级的表达概念。低级到高级中间代码的转换是通过程序转换来完成的，传统上称为优化。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTgzZTRlODMzYTliOWMzNDQyMjI5YTI1NTc2OWZmYTZfa08wdGpHbTVkNW1CdzRNb1NNMlhGNFU4bTEwMFoxeUVfVG9rZW46Ym94Y24zR1FZZU02RFZNdE13cmM1QmhTVGVoXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h2 id="Previous-Work"><a href="#Previous-Work" class="headerlink" title="Previous Work"></a>Previous Work</h2><p><strong>Elimination of Condition Codes</strong></p><p><strong>Elimination of Redundant Loads and Stores</strong></p><h2 id="Types-of-Optimizations"><a href="#Types-of-Optimizations" class="headerlink" title="Types of Optimizations"></a>Types of Optimizations</h2><p>优化的目的是消除条件代码、寄存器和中间指令的低级语言概念，并引入两个以上操作数的表达式的高级概念。为此，需要注意的是，推送指令被当今的编译器以多种方式使用。参数传递是这个指令最常见的用法，它是在子程序调用之前，按照正在使用的调用约定指定的顺序推送它们。每当编译器用完寄存器来计算表达式时，就使用寄存器溢出。push和pop还用于跨过程调用保存寄存器的内容，并将值复制到寄存器中。</p><p><strong>Dead-Register Elimination</strong></p><p>如果一个标识符的值没有按照变量的定义来使用，那么它在程序中的某一点上就是死的。据说定义死标识符的指令是无用的，因此可以从代码中删除。</p><p><strong>Dead-Condition Code Elimination</strong></p><p>与死寄存器消除类似，如果条件代码的值在重定义之前没有被使用，那么它在程序中的某个点上就是死的。在这种情况下，条件代码的定义是无用的，并且不是必需的，但是如果指令定义的标识符不是死的，则定义该条件代码的指令仍然是有用的，因此，指令本身不一定被消除。</p><p><strong>Condition Code Propagation</strong></p><p>条件代码是机器用来发出条件发生信号的标志。一般来说，几条机器指令设置这些标志，一条指令设置1到3个不同的标志，较少的指令使用这些标志，仅使用1或2个标志。在死条件代码消除之后，条件代码的多余定义被消除，因此，所有剩余的标志被后续指令使用。</p><p><strong>Register Arguments</strong></p><p>子程序使用寄存器参数来加速对这些参数的访问，并消除子程序调用前将参数推入堆栈所带来的开销。许多运行时支持例程和使用寄存器调用约定编译的用户例程都使用寄存器参数(在某些编译器中可用)。</p><p><strong>Function Return Register(s)</strong></p><p>返回值的子程序叫做函数。函数通常在寄存器中返回值，然后这些寄存器被调用子例程使用。</p><p><strong>Register Copy Propagation</strong></p><p>如果一条指令定义了一个由唯一后续指令使用的寄存器值，则该指令是中间指令。在机器语言中，中间指令用于将操作数的内容移入寄存器，将指令的操作数移入特定指令使用的寄存器，并将寄存器中的计算结果存储到局部变量中。</p><p><strong>Actual Parameters</strong></p><p>调用子程序之前，子程序调用的实际参数要么放在堆栈上，要么放在寄存器上(用于寄存器参数)。这些参数可以映射到子程序的形式参数列表中，并放在调用指令的实际参数列表中。</p><p><strong>Data Type Propagation Across Procedure Calls</strong></p><p>子例程的实际参数的类型需要与形式参数的类型相同。在库子程序的情况下，形式参数类型是确定的，因此，这些类型需要与实际类型相匹配。如果有任何不同，形式类型将传播到实际参数。</p><p><strong>Register Variable Elimination</strong></p><p>寄存器复制传播优化可以找到高级表达式，并通过消除表达式计算中使用的大多数中间寄存器来消除中间指令。应用这种优化后，中间代码中只剩下几个寄存器(如果有的话)。这些剩余的寄存器代表寄存器变量或公共子表达式，由编译器或优化器用来加快访问时间。这些寄存器相当于高级程序中的局部变量，因此在使用它们的相应子程序中被新的局部变量代替。</p><h2 id="Global-Data-Flow-Analysis"><a href="#Global-Data-Flow-Analysis" class="headerlink" title="Global Data Flow Analysis"></a>Global Data Flow Analysis</h2><p><strong>Data Flow Analysis Definitions</strong></p><ul><li>如果寄存器的内容被修改(即被赋予一个新值)，则定义一个寄存器。以类似的方式，如果一个标志被一条指令修改，它就被<strong>定义（defined）</strong>。</li><li>如果寄存器被<strong>引用（used）</strong>，则使用寄存器(即使用寄存器的值)。类似地，如果一条指令引用了一个标志，则使用该标志。</li><li>基本块Bi中的<strong>局部可用定义（ locally available definition）</strong>d是Bi中d的最后一个定义。</li><li>基本块Bi中<strong>局部向上暴露（locally upwards exposed）</strong>的用法u是一种以前在Bi中没有定义的用法。</li><li>A definition d in basic block Bi <strong>reaches</strong> basic block Bj if：</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGI4Y2E2NjY3NTZjMTc2NzI1OWMwMmNhMjBlZDNhYWZfaGJBZ0xQRGc4SXNhWVJNVU82WjBWRlF5TDM4ZG9qMmhfVG9rZW46Ym94Y25OY05ZbDZJcTVZTnFOb2xpUUd3RjllXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>基本块Bi中寄存器/标志的任何定义都被称为<strong>杀死（kill）</strong>到达Bi的同一寄存器/标志的所有定义。</li><li>如果基本块Bi中的d没有被<strong>重新定义（preserved）</strong>，则该基本块Bi中的定义d被保留。</li><li>基本块Bi中的定义d<strong>很忙</strong>(有时称为非常忙)<strong>（busy）</strong>，如果在从Bi开始的所有路径上重新定义之前使用了d。</li><li>如果基本块Bi中的定义d在从Bi开始的所有路径上被重新定义之前没有被使用(即d不忙或不活动)，则该定义d是死的<strong>（dead）</strong>。</li><li>A <strong>definition-use chain</strong> (du-chain) for a definition d at instruction i is the set of instructions j where d could be used before being redefined (i.e. the instructions which can be affected by d).</li><li>A <strong>use-definition chain</strong> (ud-chain) for a use u at instruction j is the set of instructions i where u was defined (i.e. the statements which can affect u).</li><li>如果一条路径上没有d的定义，那么这条路径就是d-<strong>clear</strong>。</li></ul><p><strong>Taxonomy of Data Flow Problems</strong></p><p>数据流问题通过一系列方程来解决，这些方程使用每个基本块中收集的信息，并在整个控制流图中传播。过程流图中传播的信息称为过程内数据流分析，过程调用中传播的信息称为过程间数据流分析。</p><p>基本块Bi的典型数据流方程具有以下形式：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTMxZGIzZGFiZDQ1ZWNmOTI2M2QzYmY4Y2U2ZDVkZGZfOUJISFV3YmxESks1SDNhNnBHUWRYUjc4akZtaWlVRkxfVG9rZW46Ym94Y253OURzNFBwbzlkQVFjQjBWbng4eVNiXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p> ()中的摘要信息是通过以下形式的等式从图的前一个节点收集的:</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGFmMDAzM2VlY2M0MDJmMzY1OWZiOThjMTY2OTZmNDZfSkFJV3NHcW5qZTYzUHNvdVRkdklMYWdkaHBmMklJVWhfVG9rZW46Ym94Y25RUlpiOVVaVUZuOEh5ZUkwMjFKbUFMXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>A data flow problem is said to be <strong>forward-flow</strong> if</li></ul><ol><li>The out() set is computed in terms of the in() set within the same basic block.</li><li>The in() set is computed from the out() set of predecessor basic blocks.</li></ol><ul><li>A data flow problem is said to be backward-flow if</li></ul><ol><li>The in() set is computed in terms of the out() set within the same basic block.</li><li>The out() set is computed from the in() set of successor basic blocks.</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2JkY2YyM2M4N2U1MjdjZjk2ZmMyYmQ2YmZiOTNlYTBfTHRhWkJZMmV6Qng3WFl3SUpyR2k2WXJ1OG5rSlhZVUFfVG9rZW46Ym94Y24xNDc5SnVvYzBWVlVFZnplU0Q4OEZlXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Data Flow Equations</strong></p><p>一般来说，数据流方程没有唯一的解；但是在数据流问题中，满足方程的最小或最大不动点解是感兴趣的。通过为前向流问题的头部基本块的in(B)集的初始值和反向流问题的出口基本块的out(B)集的值设置边界条件来找到这个解。根据对问题的解释，这些边界条件集被初始化为空集或泛集(即所有可能的值)。</p><ul><li>Let</li></ul><p>• Bi be a basic block</p><p>• ReachIn(Bi) be the set of registers that reach the entrance to Bi</p><p>• ReachOut(Bi) be the set of registers that reach the exit from Bi</p><p>• Kill(Bi) be the set of registers killed in Bi</p><p>• Def(Bi) be the set of registers defined in Bi</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjhjZDMyYTk4YTJjNjAzN2ZiZjY2YjdiZjUxZTNiNzFfY3BNY2htZDAzT2JIdVFWZ0lWbFVkR1BMNXBPcmlLVTlfVG9rZW46Ym94Y25pOWxOTURvRmU1bGJaNDg1dHBUbVViXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>Let</li></ul><p>• Bi be a basic block</p><p>• LiveIn(Bi) be the set of registers that are live on entrance to Bi</p><p>• LiveOut(Bi) be the set of registers that are live on exit from Bi</p><p>• Use(Bi) be the set of registers used in Bi</p><p>• Def(Bi) be the set of registers defined in Bi</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjdmNWRlMDA1ZGQwNjMxNjU3YjQzN2RmNzA0YjI1ZDhfTkQ5NDBwZVlnUlEzQmVER2xpUGhKeHkyQjk4SlVudGVfVG9rZW46Ym94Y25BUHpLajBJSHBLSVJ2Zml4WlVrSlFlXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>Let</li></ul><p>• Bi be a basic block</p><p>• AvailIn(Bi) be the set of the registers that are available on entrance to Bi</p><p>• AvailOut(Bi) be the set of the registers that are available on exit from Bi</p><p>• Compute(Bi) be the set of the registers in Bicomputed and not killed</p><p>• Kill(Bi) be the set of the registers in Bithat are killed due to an assignment</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWRiYjdlZWQ1OGIxN2EyNWI4NmZmNzFjNTNmODk3NDhfU0dxSEVKR2VRdlk2VHFTVVR1b0c4UFhFOTBXNjdSSFlfVG9rZW46Ym94Y24zcHplRXRCamI5RHRYbGVEQXFlYnNlXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>Let</li></ul><p>• Bi be a basic block</p><p>• BusyIn(Bi) be the set of the registers that are busy on entrance to Bi</p><p>• BusyOut(Bi) be the set of the registers that are busy on exit from Bi</p><p>• Use(Bi) be the set of the registers that are used before killed in Bi</p><p>• Kill(Bi) be the set of the registers that are killed before used in Bi</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDY3MjkzMzdkOGU4OWY3MDBlMzdmMjc3ZDdkMDg3OThfVmVjVmVDSFlVa0tPWU1BdEtldWpkYUlhSWtac0w1dnZfVG9rZW46Ym94Y25tOXFvMERlVDBWREFGWXFaaWhQNnpqXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTFmMjUwYjY1ODRiNzNlMjk4NGIxYmI3OWZjMGRhNWNfYTg5Y2lacUhlelBoQVh5dDlrRzQxWExLSWFEa0xQa05fVG9rZW46Ym94Y256dG9BSksxUFpiQTdkeW1XY2VIaW9JXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>Let</li></ul><p>• Bi be a basic block other than call and ret call</p><p>• LiveIn1(Bj) be the set of registers that are live on entrace to Bjduring phase one</p><p>• LiveOut1(Bj) be the set of registers that are live on exit from Bjduring phase one</p><p>• DeadIn(Bj) be the set of registers that have been killed on entrance to Bj</p><p>• DeadOut(Bj) be the set of registers that have been killed on exit from Bj</p><p>• Use(Bj) be the set of registers used in Bj</p><p>• Def(Bj) be the set of registers defined in Bj</p><p>• LiveIn2(Bj) be the set of registers that are live on entrace to Bjduring phase two</p><p>• LiveOut2(Bj) be the set of registers that are live on exit from Bjduring phase two</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzA2MjRjZTVkMWZjOWMwNDUxOWI5MDQ0NWQxN2NmY2RfOXBGcTJUQWZmc3hzS1lwUFdINWU4T3FmMWJaSUd2bEZfVG9rZW46Ym94Y25hbzJQbVhjaU5CUmgzNHo4NHR0dFVkXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGY2YWZmMGViOTQ5ZWJjNTllOGMyMjMxOWQ5YTNlMmJfSnJTVXk1UjlUdWhSbEtNbzViaHRMbEFwSWVTSEJpeEFfVG9rZW46Ym94Y25mNUtHemt6SGdQQjRkU3VTeVNrckNjXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>Let</li></ul><ol><li>Bi be a basic block</li><li>Reach(Bi) be the set of reaching registers to Bi</li><li>Avail(Bi) be the set of available registers from Bi</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjFhNWJjM2I4Yzc2ODY1MGE3MDFjYzBiMDdiZjJhNzVfZGx2VEl2M1JkamtKQm50WXdjcTRqMXNUY25nWXFBV0dfVG9rZW46Ym94Y25GMFg3cTNxOElRRDlCZnFkR3Z1emtoXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>Let</li></ul><ol><li>Bibe a basic block</li><li>Avail(Bi) be the set of available registers from Bi</li><li>Reach(Bi) be the set of reaching registers to Bi</li><li>Propagate(Bi) be the set of the registers that are propagated across Bi</li><li>Def(Bi) be the set of locally available definitions in Bi</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzEwZTU1Nzk2NzI1NjNhYjQ0YzliMGM2MzMwYjNkMmZfVlNYSXhONUpoUTl6WlRINnc4ZWltc05wRFluTnNkdFhfVG9rZW46Ym94Y25Sdms5dWNmUjhjaVd3Y0lhOXpUN0JoXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>Let</li></ul><ol><li>Bi be a basic block</li><li>Live(Bi) be the set of live registers on entrance to Bi</li><li>Reach(Bi) be the set of reaching registers to Bi</li><li>UpwardExp(Bi) be the set of the registers that are upwards exposed in Bi</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDk4YWI3NTBjNjk4NTEzYmY3MTA1NjcyMDY1MWFhMWJfZHJMQWFaT2pPSUhXblRVSU5YTTRnSlBBSnY3Y1NaRlJfVG9rZW46Ym94Y255UmFPYTNhRkRxN0dqMm1FTTA3TUNiXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Solving Data Flow Equations</strong></p><p>给定一个子程序的控制流图，数据流方程可以用两种不同的方法求解:迭代法，重新计算一个解，直到满足一个定点；和区间方法，其中找到一个区间的解，然后在该区间的节点间传播。这些方程没有唯一解，但取最小解作为答案。</p><h2 id="Code-improving-Optimizations"><a href="#Code-improving-Optimizations" class="headerlink" title="Code-improving Optimizations"></a>Code-improving Optimizations</h2><p><strong>Dead-Register Elimination</strong></p><p>如果寄存器是由指令定义的，并且在被后续指令重新定义之前没有被使用，那么它就是死的。如果定义一个死寄存器的指令只定义了这一个寄存器，那么就说这个指令是无用的，因此被消除了。另一方面，如果该指令还定义了其他寄存器，则该指令仍然有用，但不应再定义死寄存器。在这种情况下，指令被修改以反映这一事实。死寄存器分析通过在寄存器上使用定义-使用链来解决，因为定义-使用链说明哪些指令使用定义的寄存器；如果没有使用该寄存器的指令，则寄存器失效。</p><ul><li>Dead Register Elimination Algorithm</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmVlN2ZkMTg3ZTRlMDZmMDVhYzVkYzkwZGY4MjQxMDJfZzFsUnNZYUR2YlhDV00wZkRRUk8zcWhkV2NFd0FtbVNfVG9rZW46Ym94Y243YUxUS005OUU5dU1wNncwdnNWa3ZoXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>Update of du-chains</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODZhMzZhMGViYzE3ODIwNGExYzU2Mjg5ZTgzMzgxN2Rfb29xNUhwbzRzVzJyNGhkSkNGNW1VckVXQlNTZHg1WVpfVG9rZW46Ym94Y25hS0VoallZTUhxMHdGWWYyUlNtTHloXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Dead-Condition Code Elimination</strong></p><p>如果条件代码(或标志)是由指令定义的，并且在重新定义之前没有使用，那么它就是死的。由于条件码的定义是指令的副作用(即指令具有另一个功能)，消除死标志不会使指令冗余，因此，指令不会通过消除死标志而被消除。在这种分析中，一旦条件代码被确定为死代码，就不再需要由指令来定义它，因此从指令中移除该信息。关于条件码的信息以集合的形式保存在指令中:一组定义的条件和一组使用的条件(即位集合)。</p><ul><li>Dead Condition Code Elimination Algorithm</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGExNWM2YjY2MTVjNjI2YmQ2YTY2NWQ5NjAxYzE4NTVfZkpZWUFocWNiOGFlWjkzNVN3YTRVNlk3V1dUWnQweFVfVG9rZW46Ym94Y25sZzZlQzhId3RnWFVMTmpnNkp2dVZmXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Condition Code Propagation</strong></p><ul><li>Condition Code Propagation Algorithm</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTgxMjJhMDE1ZTQ1ZTMyZjYzNTk5NTJhYTNkZmVkM2FfdFhZWG14eEFrZ2Fta1VpdG01T0hZUDlkRlRnNHI0ZldfVG9rZW46Ym94Y245MU5JQ2lMRWNpQWJLWjlqMjh2TzlkXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>BNF for Conditional Expressions</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmE1NGM5Y2U3NzZlMzI1MzRjNDNmOTkwZjFmMGQ3ODRfVmtLelgwajRxckk3NkRMUmtkQjZKNEc2VE5uNnBUM21fVG9rZW46Ym94Y25xUkdJZjFJdUtVU1ZjckkwTjRRdWNjXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Register Arguments</strong></p><p>编译器使用寄存器调用约定来加速子例程的调用。它是大多数当代编译器中可用的选项，也是编译器运行时支持例程使用的选项。给定一个子程序，在子程序中定义寄存器参数之前，寄存器参数被转换为子程序使用的寄存器；即整个子例程中寄存器的向上暴露的使用。</p><ul><li>Register Argument Algorithm</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTNlMzY1OWU4ODE4Y2NkMjAyODk2M2ExM2Y1YWQ5ZjRfRWhJVUJGOVZwQ1JFbndLYldNZ2NzQ2VtUFBVRU5yRVdfVG9rZW46Ym94Y25SalNkdVVqZDNDNnF4S0d3VXBuYWMzXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Function Return Register(s)</strong></p><p>函数在寄存器中返回结果，没有机器指令说明函数正在返回哪些寄存器。在函数返回之后，调用方在重新定义之前使用函数返回的寄存器(即这些寄存器在函数调用之后的基本块入口时是活动的)。该寄存器信息跨子例程边界传播，并通过到达和实时寄存器分析来解决。</p><ul><li>Function Return Register(s)</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjExZTJjYjE2NWFlOTMzNjZlYjkxN2E1NTVhYTYyYTNfSHhOb2hLdWE2NFZkVlRkUDIweE1PSlJ3TlNMY3ZnWmpfVG9rZW46Ym94Y25SRExYdmRueVlwdUFKNUJINjJtaHBjXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Register Copy Propagation</strong></p><p>寄存器复制传播是一种方法，通过这种方法，如果在赋值(即ax和cx都没有被修改)之后，两个寄存器都没有被修改(即被重新定义)。</p><ul><li>Register Copy Propagation Algorithm</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTM2NTNhMzk3MmY1NjVjMDdjZDVlYTY2Mjk2OWVmMmFfOUs5MnNnc1REMFRBcmNWUXRSWkt2bjVNVkRYeFpsUEtfVG9rZW46Ym94Y251ejBZSkFtamRTZnB1VFhvOUVYQXFmXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Actual Parameters</strong></p><p>子程序的实际参数通常在调用子程序之前被推送到堆栈上。由于大多数语言都允许嵌套的子例程调用，因此堆栈上的参数代表两个或多个子例程的参数，因此，有必要确定哪些参数属于哪个子例程。为此，使用了一个表达式堆栈，它存储与推送指令相关联的表达式。每当遇到调用指令时，从堆栈中弹出必要数量的参数。</p><p><strong>Data Type Propagation Across Procedure Calls</strong></p><p>在将实际参数实例化为形式参数的过程中，需要验证这些参数的数据类型，就好像它们不同一样，其中一个数据类型需要修改。</p><p><strong>Register Variable Elimination</strong></p><p>在高级语言程序中，寄存器变量转换为局部变量。这些寄存器被新的局部变量名替换。这种名称替换可以在数据流分析期间完成，也可以由代码生成器完成。</p><p><strong>An Extended Register Copy Propagation Algorithm</strong></p><p>跨过程调用的寄存器复制传播、实际参数检测和数据类型传播的优化可以在将寄存器信息传播到其他指令(包括参数)的一次传递中执行。</p><h2 id="Further-Data-Type-Propagation"><a href="#Further-Data-Type-Propagation" class="headerlink" title="Further Data Type Propagation"></a>Further Data Type Propagation</h2><p>一旦找到所有程序表达式，就可以进行进一步的数据类型确定，因为数据类型(如数组)使用地址计算来引用数组中的对象。这个地址计算是由一个表达式来表示的，为了达到高级语言表达式，这个表达式需要被简化。</p><ul><li>Extended Register Copy Propagation Algorithm</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODZiMDhkNDI4YWQ2MWZjMDQxMjA0MjhiNzdmYWNjNGZfTTRiUFFraWhpUjd3alYzb2xSWmh5RmpWelhaeUt2a2JfVG9rZW46Ym94Y25oWDZJaUMwaUR6MUlDSFB0UDk3cVlxXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h1 id="Control-Flow-Analysis"><a href="#Control-Flow-Analysis" class="headerlink" title="Control Flow Analysis"></a>Control Flow Analysis</h1><p>前端构建的控制流图没有关于高级语言控制结构的信息，例如if..然后..elses和while()循环。这样的图可以通过结构化算法转换成结构化的高级语言图。在图中检测高级控制结构，并且在图中标记控制结构的子图。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTljYmQzYTA2MmNmZjJkZWUyNmMxY2M5NGZiYjVkOWZfb3g1VUt5VHFWVGt0MmR1YUFGTGE3MXNSbEhqaUlrbzNfVG9rZW46Ym94Y253T2p6TG5zS2VaMFJXMkNKM0RTY25kXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h2 id="Graph-Structuring"><a href="#Graph-Structuring" class="headerlink" title="Graph Structuring"></a>Graph Structuring</h2><p><strong>Structuring Loops</strong></p><p><strong>Structuring Loops</strong></p><h2 id="Control-Flow-Analysis-1"><a href="#Control-Flow-Analysis-1" class="headerlink" title="Control Flow Analysis"></a>Control Flow Analysis</h2><p>通过对程序图形的控制流分析，可以获得关于程序控制结构的信息。信息收集在图的不同节点中，无论它们属于循环和/或条件，还是不是任何结构的一部分。</p><p><strong>Control Flow Analysis Definitions</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDRlYTQ2ZjFmN2I0MGI3NmUyNmY1NDllZjdiMTQyYzFfU25uRHI4VkVWcjRrSlNsQlYyclFPdk1ZTEpHTjR2djFfVG9rZW46Ym94Y25xU3FGRmhDVUkweTViZVJiWjRQMjBIXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGRkOGIxOTZlOWM3NGMxZDE4NTUwY2RkMjYwYWM3MTRfdm5INUt2ZXlRTjRwdVJhQUVLY3QyeTV0dEpVaThEdFRfVG9rZW46Ym94Y241QzBMSlVDTVlmRDR1aDNmM0pFd0doXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>Given a node h, an interval I(h) is the maximal, single-entry subgraph in which h is the only entry node and in which all closed paths contain h. The unique interval node h is called the interval head or simply the header node.</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGY5YTkyODRkNDRhN2VhNmRjNzlkYjMxYWQ4NmQ0ODVfYzJxZGhkY2dxRGJrSnpNNjlkTjRVUFpUVkVmdkJjMnpfVG9rZW46Ym94Y25vUktIeEF6SHVrS2pYTFY0OTBvR2pmXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>A latching node is any node in the interval which has the header node as an immediate successor.</li></ul><p><strong>Derived Sequence Construction</strong></p><ul><li>Derived Sequence Algorithm</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTgyY2ZmN2M4NjQxOTRlZjAwOGZkYzM5Zjc1M2I0NDVfQmhobGdFMmduM1Zzd0JFQWIwbFhHMEhRWFRrcVhMUzFfVG9rZW46Ym94Y25iRnpNejNSbTJ3RWZqb3k3S05YaktkXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Irreducible Flow Graphs</strong></p><p>一个流图是不可约的当且仅当它有一个标准型不可约图的子图。</p><h2 id="High-Level-Language-Control-Structures"><a href="#High-Level-Language-Control-Structures" class="headerlink" title="High-Level Language Control Structures"></a>High-Level Language Control Structures</h2><p>不同的高级语言使用不同的控制结构，但是一般来说，没有一种高级语言使用所有不同的可用控制结构。</p><p><strong>Control Structures - Classification</strong></p><ol><li>Action: a single basic block node is an action.</li><li>Composition: a sequence of 2 structures is a composition.</li><li>Conditional: a structure of the form if p then s1 else s2, where p is a predicate and s1,s2 are structures is a conditional structure.</li><li>Pre-tested loop: a loop of the form while p do s, where p is a predicate and s is a structure, is a pre-tested loop structure.</li><li>Single branch conditional: a conditional of the form if p then s, where p is a predicate and s is a structure, is a single branch conditional structure.</li><li>n-way conditional: a conditional of the form</li></ol><pre><code>case p of1 : s12 : s2...n : snend case</code></pre><p>where p is a predicate and s1..sn are structures, is an n-way conditional structure.</p><ol><li><p>Post-tested loop: a loop of the form repeat s until p, where s is a structure and p</p><p>is a predicate, is a post-tested loop structure.</p></li><li><p>Multiexit loop: a loop of the form</p></li></ol><pre><code> while p1 do s1 if p2 then exit s2 if p3 then exit … if pn then exit sn end while</code></pre><p> where s1..sn are structures and p1..pn are predicates, is a multiexit loop structure.Each exit statement branches out of the loop to the first statement/basic block after the loop.</p><ol><li>Endless loop: a loop of the form loop s end, where s is a structure, is an endless loop.</li><li>Multilevel exit: an exit(i) statement causes the termination of i enclosing endless loops.</li><li>Multilevel cycle: a cycle(i) statement causes the i-th enclosing endless loop to be re-executed.</li><li>Goto: a goto statement transfers control to any other basic block, regardless of unique entrance conditions.</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTA4M2NkMTVmYjZmYWM2NjAwYWYxZTM4MGQwZjExNGZfYndKRG5TUFVpMU80OXlQREJFYnhlTWNRV3FkZ0xqdlVfVG9rZW46Ym94Y25iUmU2ZDVTaXFwRGxCQVVWNTNFYktlXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Control Structures in 3rd Generation Languages</strong></p><ul><li>Classes of Control Structures in High-Level Languages</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2JiMDhiODExNWEzYjRiZjc1MDBjMWQ0NTQ3YWEzMzhfMXl5YzNya3FMSDNsazBndngyZ2xjQU9QVDE3dUxyVGVfVG9rZW46Ym94Y25QQlpLdVFjOUFWVk1MZ3RWUzJFVlhjXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Generic Set of Control Structures</strong></p><h2 id="Structured-and-Unstructured-Graphs"><a href="#Structured-and-Unstructured-Graphs" class="headerlink" title="Structured and Unstructured Graphs"></a>Structured and Unstructured Graphs</h2><p>结构化控制流图是从使用高达DRECn类的结构的程序生成的图；即可分解为具有一个入口和一个或多个出口的子图的图。如果goto用于以结构化的方式转移控制(即，将控制转移到结构的开始或结束)，允许使用goto的语言仍然可以生成结构化的图形。非结构化图是通过goto语句的非结构化控制转移生成的，即在结构化图的中间转移控制，这将以前的结构化图分解成非结构化图，因为这个子图中有多个条目。当执行代码运动(即代码被移动)时，编译器的优化阶段也可以引入非结构化。</p><p><strong>Loops</strong></p><p>环是有向子图的任意两个节点之间有路径的强连通区域。这意味着循环的头节点必须至少有一个后沿。</p><p><strong>结构化循环</strong>是一个子图，它有一个入口点、一个后边缘，可能还有一个或多个出口点，将控制转移到同一个节点。结构化循环包括所有自然循环(预测试和后测试循环)、循环和多出口循环。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjUzZDdhYmQ2MzkxOTlmYzA1NGRjOGQ0YTcwNTU4OWNfWlJjdlJidno1bG9scGNPSGxZMktOYjI4Uzl6YlkyanhfVG9rZW46Ym94Y250QkRwMXZUSXJ0cmlWeDRneXRFS1hiXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>非结构化循环</strong>是一个子图，它有一个或多个后边缘、一个或多个入口点以及一个或多个到不同节点的出口点。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzFiNmU4ZjkwY2FkMjRlMDE5ODkyNGY0NzAxNjIxZTZfTzN4T2cwclpZR1Jka0ZrMmgzMFhOQnNLZllxYndPdEVfVG9rZW46Ym94Y253UnJ1TUdsY1M0Z3ZNU2xJaEE1eEFkXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Conditionals</strong></p><p><strong>结构化双向条件图</strong>是一个有向子图，它有一个双向条件头节点、一个入口点、两个或多个分支节点以及两个分支节点到达的公共端节点。这个最终的公共端节点被称为跟随节点，并且具有立即被头节点支配的属性。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzE1NTc0YzViY2YwN2VmYzU2ZWE2YmVmNmI0ODgzMDBfTGVQa0ZBRTN2cWl4ZmxMNTdXdktCU1p3a2tPcFdxTzhfVG9rZW46Ym94Y25zVzByV1k2bFU2TlQwQ2FVdnQ4eWtYXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img">)<img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGU1OGJkNDgyZjg4NmFiYWM0ODY5YmQ5YTMzZjY0Yzlfb0FETWl4SDVjY1FZbkw5ZTVPbW9vUUZVM2pzRWMyeFVfVG9rZW46Ym94Y25hWGhmcEphU0FhdTdXcktjd0J1dG9IXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>非结构化双向</strong>条件是双向节点头子图，两个或多个条目进入头节点的分支，或者两个或多个出口离开头节点的分支。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2QyNTY4ZWFhOTRjZTA2YzE4Njc3Yzk5YjcxYzc1ZDBfeGt6c3pvT0pyejRnMVhnWUJOekpkTm9mb0theVFYZzdfVG9rZW46Ym94Y25OeDJmVjVQb2FOeG15dXZPRGFTS3NkXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Structured Graphs and Reducibility</strong></p><h2 id="Structuring-Algorithms"><a href="#Structuring-Algorithms" class="headerlink" title="Structuring Algorithms"></a>Structuring Algorithms</h2><p>在反编译中，结构化算法的目标是确定任意图的底层控制结构，从而将其转换为函数式和语义式等价图。任意图代表任何控制流图；可约或不可约的，来自结构化或非结构化语言。由于不知道初始程序是用什么语言编写的，使用了什么编译器(例如，启用了什么优化)，所以必须允许使用goto跳转，以防图形不能被构造成一组通用的高级结构。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTk2N2NmZmI4NDhmMDRmYTI2ZTQwODEwMzBjOTE5YzVfYlZYTVdhaDFaVmN0UlM0Y1N1U0Rya1k2YmJ0dnNjNFFfVG9rZW46Ym94Y25ScG1nOVRvQ3hSTmk3a3Q4YzJST3BoXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Structuring Loops</strong></p><p>为了构造循环，需要根据图形表示来定义循环。这种表示必须不仅能够确定循环的范围，而且能够为循环提供嵌套顺序。</p><p><strong>Finding the Nodes that Belong to a Loop</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGFiMjJhM2U1NDNlM2U2ODM5MmZjZGQ0NGM1ZWZkMTJfbmczalZOblhkUVhLM2huOUxQOTdiczRkNUV3eG9nOTJfVG9rZW46Ym94Y24zQWZCWmhPUWp3U1llZjJJRkU1am9kXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Determining the Type of Loop</strong></p><p>循环的类型由循环的头和锁存节点决定。在预先测试的循环中，双向头节点确定循环是否被执行，单向锁存节点将控制转移回头节点。经过测试的循环的特征在于双向锁存节点，其分支回到循环的头部或循环之外，以及任何类型的头部节点。最后，一个无限循环有一个单向锁存节点，它将控制转移回头节点和任何类型的头节点。</p><ul><li>Algorithm to Mark all Nodes that belong to a Loop induced by (y, x)</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDBmOGY1Y2IzMTE5ZTYzMjgxZDNjOTljYjNmNzg4MDJfTlcxOEsxenlJRFd4MEdlVDA4ZjdrY1hYdU9BUmtEYWpfVG9rZW46Ym94Y25XWHpTTFNFMkRuc1BFUTgzY2xSZkNoXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>Finding the Loop Follow Node</li></ul><p>循环跟随节点是循环终止后到达的第一个节点。在自然循环的情况下，只有一个节点在循环终止后到达，但是在多出口和多级出口循环的情况下，可以有多个出口，因此，在循环后可以到达多个节点。由于结构化算法只结构化自然循环，所以所有的多出口循环都由一个“真实”出口和一个或多个异常出口构成。在循环中间有出口的情况下，在不同的出口之后可以到达几个节点。该算法的目的是只找到一个跟随节点。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzBiZGY1YjFkMWYwZDk5NTdmNWVmYzJiNzVhY2MwMjZfcmk2dzN0cVNnNmxKcTFZa2ZHRU5qMGhibVpvVHFHbzFfVG9rZW46Ym94Y25yQnBOeDk0NHRLbTFSTk9nRnViTUhrXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Structuring 2-way Conditionals</strong></p><p>单个分支条件(即如果..然后)和条件(即如果..然后..else)子图有一个公共的结束节点，从这里开始称为跟随节点，它具有立即被双向头节点支配的属性。</p><ul><li>Algorithm to Determine the Follow of a Loop</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjcxZjU4YmYxNDNjNjQzYjk1NDFjNzdhY2QzN2M0YjdfallOWmpMMXJkZ2FhNFJIbExrMzVtYk5FbkxLWkFycWhfVG9rZW46Ym94Y25oemdkMHRWZmpoMUQ5d3gweTFGUUViXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>2-way Conditional Structuring Algorithm</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzZjZmVmMjA0ZDU3ZWI1MTRhODQ0NzIyYzFhZTk5MjVfTVZ6cGRvbmlKWjVMSFRucVR2bHdiQ3lUNDFPUVRzQlhfVG9rZW46Ym94Y25EZE9ZYVpxb0wyVkhUVjFScndhN3FoXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Compound Conditions</strong></p><p>在反编译中构造图时，不仅要考虑底层结构的结构，还要考虑底层中间指令信息。大多数高级语言允许对复合布尔条件(即包含and和or的条件)进行短路评估。在这些语言中，为这些条件表达式生成的控制流图变得非结构化，因为一旦检查到足够的条件并确定表达式整体为真或假，就可以执行退出。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzZmM2Q1ZTZjNmVjZWI0MzMxZWQ4NzVjZmVjMjFiNzJfNlU3R1ZNZFlVYTJFeWRneFdJUTd3cWxIbWJkQUxtR1dfVG9rZW46Ym94Y25Wcm1Pa0JBQVV5cXRrSzVwTFRNT1VoXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>Compound Condition Structuring Algorithm</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWM5MGUzMjM2YjBkYjU2Y2M3YTM0M2UyMDI0MTliNTBfVUFLTklXN0xwQ3RlTE9VNkFibFNZQUF0OTNtOVZUSkxfVG9rZW46Ym94Y25ZTlpWU3VkUzZWOHg2akJVMzh4T3doXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Structuring n-way Conditionals</strong></p><ul><li>n-way Conditional Structuring Algorithm</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGI1OWM0MDFmZjBlOWFlZmZkMGUwNTI3ZjVmZGFjNmVfU0xmdnF2WHZTN0FqNlpPU3dlalBJQ29pWTVOWVN1cVZfVG9rZW46Ym94Y251b216NVdtNmh0Y1RKNkJoeWtSZGhhXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Application Order</strong></p><p><strong>The Case of Irreducible Graphs</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmMzMGIzZGJkNTM4ZjU3NzRjYjk3ZGZlNDc3NDQzZWVfU1FnT3RxOGpMb0pjRlozMEJjVjI4RkpJWVhhRGJmV1ZfVG9rZW46Ym94Y255ZXhoS1JKQXBxazR6UFUyaE85a2ZlXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h1 id="The-Back-end"><a href="#The-Back-end" class="headerlink" title="The Back-end"></a>The Back-end</h1><p>数据流分析器生成的高级中间代码和控制流分析器生成的结构化控制流图是后端的输入。这个模块整体上由代码生成器组成，它为目标高级语言生成代码。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjBlNjJhMThjNTIzMjRiNjRmYmE2ZWE2ZjNmZWU3OGFfcVlzckRhcVRWeG1CVlp0eUpxQ2hDYUFTYUdDT3NsSkpfVG9rZW46Ym94Y24zNUJvMG1tclpLMUxYZ05ycU5LbEZiXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h2 id="Code-Generation"><a href="#Code-Generation" class="headerlink" title="Code Generation"></a>Code Generation</h2><h3 id="Generating-Code-for-a-Basic-Block-为基本块生成代码"><a href="#Generating-Code-for-a-Basic-Block-为基本块生成代码" class="headerlink" title="Generating Code for a Basic Block  为基本块生成代码"></a>Generating Code for a Basic Block  为基本块生成代码</h3><p>数据流分析后，一个基本块中的中间指令都是高级指令；在此之前，伪高级指令必须已经从代码中消除。</p><p><strong>Generating Code for asgn Instructions 为asgn指令生成代码</strong></p><ul><li>Algorithm to Generate Code from an Expression Tree</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjdhMzE2NTZlNzY3MTkyMTQzMGM3NjFlYWJiY2ZmMzBfakpuRU1wUTRKc2FZMHZyaUpMY1FkS2EzeDJ5aFpiMFNfVG9rZW46Ym94Y251akdhUFBJOWlTTzZ0QnBwdWpwOXVnXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Generating Code for call Instructions 为call指令生成代码</strong></p><p><strong>Generating Code for ret Instructions  为ret指令生成代码</strong></p><ul><li>Algorithm to Generate Code from a Basic Block</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjVkMWIxZTNkMzY1MTMyM2Y4OTNjYTFjOTYyMDJhOTZfdlZJdGt0WHBTM2RmTnNKS1R0cml6ZkRwb0U2d2Z6am1fVG9rZW46Ym94Y25hV1FqYTh5RFI1ZnMyZWlSbzZrcm5nXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h3 id="Generating-Code-from-Control-Flow-Graphs-从控制流图生成代码"><a href="#Generating-Code-from-Control-Flow-Graphs-从控制流图生成代码" class="headerlink" title="Generating Code from Control Flow Graphs 从控制流图生成代码"></a>Generating Code from Control Flow Graphs 从控制流图生成代码</h3><p><strong>Generating Code for Loops 为循环生成代码</strong></p><p>给定以循环头节点为根的子图，基于循环的类型生成该循环的代码。无论循环类型如何，所有循环都具有相同的结构:循环头、循环体和循环尾。循环头和循环尾都是根据循环的类型生成的，循环体是通过为以循环体的第一个节点为根的子图生成代码来生成的。</p><ul><li>Algorithm to Generate Code for a Loop Header Rooted Graph</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2Q0YTVjOGFlYWQ4NGE1M2Q5MDM1NDQ5MTVkZGFkODVfZHNISnJIYXBLOWJlUklSMmxseUdmNE44anRXRjJrSWZfVG9rZW46Ym94Y241UVprTnNXYVZ4T01yRXZZTVY1cHhnXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Generating Code for 2-way Rooted Graphs  生成双向有根图的代码</strong></p><ul><li>Algorithm to Generate Code for a 2-way Rooted Graph</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjIyY2JkZDhkNDVkNmI1MTJlMWRjMzc3NDYzNDcyOTlfN3VaRjRjd2JiRzg4bHZ4a1EyNW5WZjlveVNNR0JlMDVfVG9rZW46Ym94Y25XUEx1SlRNemdUUVBvNmJabXRMNkZoXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Generating Code for n-way Rooted Graphs 生成n路有根图的代码</strong></p><ul><li>Algorithm to Generate Code for an n-way Rooted Graph</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDEyOGRmNzJjNDQ2YWFmN2U3NWU0MDU3ZTdhYTI0M2VfZUtndE9qOUE5TkQ0NEVTQ1ZIM3FNT2FOTDhHUTdDc0tfVG9rZW46Ym94Y25KNWt6WGlTQ3pvSVZ2RFhFdTVnNlloXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Generating Code for 1-way, Fall, and Call Rooted Graphs 为单向图、落图和调用根图生成代码</strong></p><ul><li>Algorithm to Generate Code for 1-way, Call, and Fall Rooted Graphs</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmNjNWQ0MTc4MzIzZjQ0NmY4ZmRiMjNmZWJhNGUxZGNfVm45VHdzbTQ2UTBOdVR0OTEzNjNKUkpPOXFEZmU4dDFfVG9rZW46Ym94Y242Tmg1OGlhVmVQN1ltVmFONlZVQnZjXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>A Complete Algorithm</strong></p><ul><li>Algorithm to Generate Code from a Control Flow Graph</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmVjNGY1ODQyMDgzMWRmNmUxZDQ5YjZjNDE5MzI3MWFfcW1TRU5jWTlnY3R1ZnFiZnpybzZpSGFOY2pObDRPSmNfVG9rZW46Ym94Y255WXdma2ZNVDZMQVpYVG9RUVVMWmpnXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><ul><li>Algorithm to Generate Code from a Call Graph</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzdlODM1ZmUzODk5MjE2YjRjMmE0MzU2YjI3ZTVkM2JfZ2pDbjdnMzkxcDdTTDY2VnZ6aVZMUHRlNmYxV3laeE5fVG9rZW46Ym94Y25mU0ZDcGpGd0ZacmxJOTd0bTRLU2dkXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h3 id="The-Case-of-Irreducible-Graphs"><a href="#The-Case-of-Irreducible-Graphs" class="headerlink" title="The Case of Irreducible Graphs"></a><strong>The Case of Irreducible Graphs</strong></h3><h1 id="Decompilation-Tools"><a href="#Decompilation-Tools" class="headerlink" title="Decompilation Tools"></a>Decompilation Tools</h1><p>反编译工具是一系列帮助反编译程序生成目标高级语言程序的程序。给定一个二进制文件，加载程序确定二进制映像从哪里开始，以及文件是否有任何位置调整信息。一旦二进制映像被加载到内存中(并且可能被重新定位)，反汇编器就可以用来解析二进制映像并生成程序的汇编形式。解析过程可以受益于编译器和库签名识别器的使用，后者根据另一个程序生成的一组预定义签名来确定一个子例程是否是库子例程。这样，只有用户编写的原始代码被分解和反编译。反汇编器可以被认为是反汇编器的一部分，因为它只解析二进制图像(即它是前端模块的一个阶段)。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTAzZGQ0YTJhZGU1MDYzNjk2ZDljNDRjYWE5MTM1NzFfdXdHTTlOTzV0cmpZRUNzWGZEbGtPYjZuMzg0ZkFmdjRfVG9rZW46Ym94Y25jb2lGVjRWYXF5ZHB1M0NOa0FFaGlnXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h2 id="The-Loader"><a href="#The-Loader" class="headerlink" title="The Loader"></a>The Loader</h2><p>加载程序是一种操作系统程序，如果有足够的空闲内存供程序加载和运行，它会将可执行程序或二进制程序加载到内存中。大多数二进制程序包含运行程序所需的内存量、重定位地址和初始段寄存器值等信息。一旦程序被加载到内存中，加载程序通过设置代码和指令段将控制权转移给二进制程序。</p><ul><li>Loader Algorithm</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjEzOTIzNDEyZWM0YjMwMGJjOWQ3NGMwNmUyNTg4NzhfZ0xUbWhuVlF4Q1RMQzk0b1ZITmJmUDZMdk5yVFRnV2hfVG9rZW46Ym94Y256WWZxSGY1bW1ySDdOYXdTbFZqVlpvXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h2 id="Signature-Generator"><a href="#Signature-Generator" class="headerlink" title="Signature Generator"></a>Signature Generator</h2><p>签名生成器是为输入文件自动生成签名的程序。签名是用于识别病毒、编译器和库子程序的二进制模式。反编译中签名的目的是撤销链接器执行的过程，即确定哪些子程序是库和编译器启动代码，并用它们的名称替换它们(在前一种情况下)或从目标输出代码中删除它们(在后一种情况下)。这是不共享库的操作系统的情况，因此将库子例程的目标代码绑定到程序的二进制映像中。二进制程序中没有关于子程序名称或参数的信息，因此，如果没有一种方法将它们与用户编写的子程序区分开，就不可能将它们与其他子程序区分开。在共享库子程序的操作系统的情况下，子程序不构成二进制程序的一部分，并且在程序中引用子程序，因此，子程序的名称作为二进制文件的一部分存储(很可能在标题部分)。</p><h3 id="Library-Subroutine-Signatures"><a href="#Library-Subroutine-Signatures" class="headerlink" title="Library Subroutine Signatures"></a><strong>Library Subroutine Signatures</strong></h3><p>标准库文件是一个可重定位的目标文件，它实现特定语言/编译器中可用的不同子程序。库子例程签名是一种二进制模式，它唯一地将库中的子例程与同一库中的任何其他子例程区分开来。由于所有子程序执行不同的功能，一个包含子程序的完整二进制模式的签名将唯一地识别子程序和任何其他子程序。</p><ul><li>Signature Algorithm</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGM0ZDkyNTRkN2JmM2U2MmQyOThmMDZjNDNkOGQ4MDBfTThCOXlUN1labTl1cUFMUnh1bnZmSkVDOWRvR085MENfVG9rZW46Ym94Y25LMnJLbFFXZlpRcldxWE40OXBuVldQXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p><strong>Integration of Library Signatures and the Decompiler</strong></p><p>给定一个子例程的入口点，解析器从入口点沿着所有路径反汇编指令。如果知道某个特定的编译器被用来编译当前正在分析的源二进制程序，解析器可以检查该子例程是否属于某个库(对于该特定的编译器)。如果有，代码不需要被解析，因为它知道调用了哪个子例程，因此使用了子例程的名称。由于库中存在大量的子程序，线性搜索对于检查文件中所有可能的签名是非常低效的。在这种情况下，散列是一种很好的技术，更好的是，可以使用完美的散列，因为签名对于给定库中的每个子例程都是唯一的，并且具有固定的大小。完美的散列信息可以存储在库签名文件的头部，解析器可以在需要确定一个子例程是否属于该库时使用。</p><h3 id="Compiler-Signature"><a href="#Compiler-Signature" class="headerlink" title="Compiler Signature"></a>Compiler Signature</h3><p><strong>Determining the Main Program  确定主程序</strong></p><p><strong>Integration of Compiler Signatures with the Decompiler 编译器签名与反编译程序的集成</strong></p><h3 id="Manual-Generation-of-Signatures"><a href="#Manual-Generation-of-Signatures" class="headerlink" title="Manual Generation of Signatures"></a>Manual Generation of Signatures</h3><h2 id="Library-Prototype-Generator"><a href="#Library-Prototype-Generator" class="headerlink" title="Library Prototype Generator"></a><strong>Library Prototype Generator</strong></h2><p>库原型生成器是一个自动生成库子程序原型信息的程序；也就是子例程使用的参数类型，以及函数返回值的类型。确定库子例程的原型信息有助于反编译程序检查参数的正确类型和数量，并传播由于分析中缺乏信息而被错误地认为是另一种类型的任何类型信息。</p><p><strong>Comment on Runtime Support Routines 运行时支持例程评论</strong></p><p><strong>Integration of the Library Prototypes and the Decompiler  库原型和反编译程序的集成</strong></p><h2 id="Disassembler"><a href="#Disassembler" class="headerlink" title="Disassembler"></a>Disassembler</h2><p>反汇编程序是将源二进制程序转换成目标汇编程序的程序。汇编代码使用代表机器操作码的助记符。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTA0MzMyZDcxMjYxZDQ4ODIzNGM4MThhZTg5YTJjZjBfR0t1MjN5OVB6QXJJY28wdXR3b00wOEt1WVpoV2FWM0tfVG9rZW46Ym94Y25YUVJmeElKMnh0VFVUS0FTVDgzNW9lXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><h2 id="Language-Independent-Bindings"><a href="#Language-Independent-Bindings" class="headerlink" title="Language Independent Bindings"></a>Language Independent Bindings</h2><p>反编译程序为特定的目标语言生成代码。借助编译器和库签名反编译的二进制程序产生目标语言程序，这些程序使用库签名文件中定义的库例程的名称。如果二进制程序最初使用的语言与反编译程序的目标语言不同，则目标程序不能针对这种语言重新编译，因为它使用了在另一种语言/编译器中定义的库例程。</p><h2 id="Postprocessor"><a href="#Postprocessor" class="headerlink" title="Postprocessor"></a>Postprocessor</h2><p>反编译程序生成的目标高级语言程序的质量可以通过后处理器阶段来提高，该后处理器阶段用语言特定的结构来替换通用控制结构。</p><h1 id="dcc"><a href="#dcc" class="headerlink" title="dcc"></a>dcc</h1><p>dcc是用C语言为DOS操作系统编写的原型反编译程序。dcc最初是在运行Ultrix的DecStation 3000上开发的，在DOS下移植到PC架构上。dcc将作为输入.exe和.com文件，并生成目标C和汇编程序。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDI4OWI1MmViNGM2OGNiMmU2MzZiMWRlMTU2YTgzZjZfZDY2STlZeGY0VWQ2dmRMSXZCQzNMNTRWZUtFOHNRSndfVG9rZW46Ym94Y25RNEFxS1NKaEs0U01LQVluaGNuUWJyXzE2MjcxNDgwNDA6MTYyNzE1MTY0MF9WNA" alt="img"></p><p>利用前几章节的理论知识实现的反编译程序。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Decompile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Decompiling | Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科普：计算机时间</title>
      <link href="/posts/95b9.html"/>
      <url>/posts/95b9.html</url>
      
        <content type="html"><![CDATA[<p>时间总是在不经意间流逝，我们在写代码时，也经常会调用「时间 API」，你有思考过这背后的原理吗？</p><p>关于时间的问题还有很多，例如：</p><ul><li><p>为什么计算机的时间有时候「走不准」？</p></li><li><p>计算机究竟是怎么「自动校准」时间的？</p></li><li><p>我们经常看到的 UTC 时间，到底是什么？</p></li><li><p>我们在新闻上看到的「北京时间」，真的来自北京吗？</p></li></ul><p>这篇文章，我们就来揭秘时间背后的秘密。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWJiNjc2YTQ3NTRlZDQwMmIxMTJhODU2NjY2ZDE0ZmJfcHRBQWxFMTdLakFqdnRLWWwwaEdMZzl3VnNGQWZHYTVfVG9rZW46Ym94Y25TNDFUc1R3M0xTNUVuRjcxekFCWEJkXzE2MjcxNDc5MTk6MTYyNzE1MTUxOV9WNA" alt="img"></p><h1 id="时间为什么总是走“不准”？"><a href="#时间为什么总是走“不准”？" class="headerlink" title="时间为什么总是走“不准”？"></a><strong>时间为什么总是走“不准”？</strong></h1><p>你肯定遇到过这样的场景，家里买了一个钟表，时间一长，就会发现它走得「不准」了。</p><p>又或者，一台长时间不使用的电脑，它的时间也会发生偏差。</p><p>遇到这些情况，你可能会不以为然。时间不准，那我们就「人工」调准它。</p><p>但你有没有停下来想一想，为什么它们的时间会越走越不准呢？</p><p>要回答这个问题其实不难，我们只需要搞清楚，它们的时间是怎么来的。</p><p>钟表和计算机内部都有一个叫做「晶体振荡器」的东西，给它加上电压，它就会以固定的频率振动。但这个振动频率的「稳定性」，取决于它的制造工艺，以及外界环境的影响。</p><p>出于成本的考虑，钟表的制作工艺没那么高，所以它更容易有误差。而电脑制造工艺虽然比较高，但它内部的晶体振荡器也会受到「温度」变化带来的影响，在工作过程中，也会有产生误差。</p><p>虽然它们的误差很小，但日积月累下来，误差就越来越明显。</p><p>因此，我们现在使用的计算机，都有「自动校准」时间的功能。但是如何校准呢？</p><h1 id="如何校准时间？"><a href="#如何校准时间？" class="headerlink" title="如何校准时间？"></a><strong>如何校准时间？</strong></h1><p>很简单，只要你把电脑连上了「网络」，你会发现，它会自动与「网络时间」保持同步。</p><p>可问题是，这个「网络时间」哪儿来的？</p><p>我猜你大脑的第一反应是，每台电脑肯定配置了一个「时间服务器」，之后这台电脑会与服务器定时同步，自动校准。</p><p>没错，确实是这样，不光是电脑，我们平时使用的手机、平板、智能手表等电子设备，只要能连接网络，都会自动同步网络时间。</p><p>那继续追问，这个「时间服务器」的时间就一定是准的吗？</p><p>理论来讲，它应该也是一台计算机，难道它不会遇到我们前面说的问题吗？</p><p>此外，这个网络时间究竟是怎么「同步」到我们的电脑上的？</p><p>你可能会说，那肯定是通过网络数据包。</p><p>问题又来了，网络传输数据也是有「延迟」的，同步服务器时间，不还是存在误差吗？</p><p>环环相扣，像一个俄罗斯套娃，很难解释清楚。</p><p>要想彻底搞清楚这些问题，就要深入到时间的「源头」来寻找答案。</p><h1 id="时间是怎么来的？"><a href="#时间是怎么来的？" class="headerlink" title="时间是怎么来的？"></a><strong>时间是怎么来的？</strong></h1><p>时间是一个非常抽象的概念，多少年来，吸引着无数科学家、物理学家、甚至哲学家花费毕生精力去解释时间的本质是什么，从宇宙大爆炸到时空相对论，从黑洞到量子力学，都能看到关于时间这个问题的身影。</p><p>这里我们不探讨高深莫测的学术知识，只把目光放聚焦在计算机这个很小的范畴内。但要想清楚解释这个问题，也并非想的那么简单。</p><p>我们从最简单的开始说起。</p><p>想要知道时间是怎么被定义的，首先要知道「天」是怎么来的？</p><p>答案是：<strong>观察太阳</strong>。</p><p>由于地球的「自转」，人们可以看到日出日落，人们日出而作，日落而息，所以就把这一周期现象定义为「天」。</p><p>地球除了自转，还在围绕太阳公转，所以公转一周就被定义为一「年」。</p><p>从这些现象就能看出来，很早之前的人们，是以「天文现象」来确定时间的。</p><p>再后来，人们为了把时间定义得更「精确」，就把一天平均划分为 24 等份，这就是「时」。</p><p>同样地，把 1 小时划分 60「分钟」，1 分钟划分为 60「秒」。</p><p>这样，时间的基本单位「秒」就被定义出来了。</p><p>所以，秒与天的关系就是这样的：</p><p><strong>1 秒 = 1 / 24 * 60 * 60 = 1 / 86400 天</strong>。</p><p>这些定义，都与「地球自转」和「太阳」息息相关。</p><p>但是，后来人们发现，地球的公转轨道并不是一个正圆，而是一个「椭圆」，也就是说公转速度是「不均匀」的，这意味着什么呢？</p><p>这意味着每天的时间不是等长的，那根据天推算出的秒，自然也不是「等长」的。</p><p>很明显，这里的计算存在误差。这怎么办？</p><p>聪明的人们就想到，把一年内所有天的时长加起来，然后求「平均」，得到相对固定的「天」，然后再计算得出「相对平均」的秒，这样就减小了误差。</p><p>确定了天文规律，人们开始制造「钟表」，把时间表示出来。</p><p>从摆钟到机械钟，再到现代广泛使用的石英钟，钟表的制作工艺越来越高，时间精度也越来越高，现代石英钟每天的计时误差只有「千分之一秒」。</p><p>所以，在 1927 年，<strong>人们以基于「天文现象」+「钟表计时」，确立了第一套时间标准：世界时（Universal Time，简称 UT）。</strong></p><p>但是，随着科技的发展，人类对太阳的观测越来越精准，有意思的事情发生了。</p><p>人们发现，地球每天的自转速度也「不是匀速」的，地球的自转受到潮汐、地壳运动、冰川融化、地震等自然现象的影响，越来越慢！</p><p>这会导致什么问题呢？</p><p>这会导致之前规定的，每年平均下来一天的时间，现在来看，也是不一样长的。</p><p>例如，第 1 年算出来平均一天的时间是 23.9997 小时，第 2 年可能是 23.998 小时，第 3 年可能是 23.999 小时…</p><p>那按照 1 秒 = 1 / 86400 天的定义，每一年的「秒」，也是不一样长的。</p><p>这就比较尴尬了，人们以地球自转为依据，定义出来的时间，还是不准！</p><p>你可能会想，时间有误差会有什么问题吗？人们依赖不准确的天文现象，不也生活了几个世纪么？</p><p>确实，对于人们的基本生活影响其实并不大。但随着人类活动的发展，人们对于高精度的时间场景开始变得越来越多。</p><p>例如，体育赛事中百分之一秒的差距就能决定胜负，炮弹的发射要精确在千分之一秒内发生，雷达技术甚至需要精确到百万分之一秒…</p><p>尤其是卫星发射、火箭试验等航天领域，对高精度的时间系统也提出了越来越高的要求！</p><p>怎么办？怎么彻底解决时间不准的问题？</p><p>聪明的科学家们开始思考，既然观测天文现象无法解决这个问题，那在微观层面能否找到比较好的解决方案吗？</p><p>这时，他们开始把目光投向了「微观世界」。</p><h1 id="一秒到底有多长？"><a href="#一秒到底有多长？" class="headerlink" title="一秒到底有多长？"></a><strong>一秒到底有多长？</strong></h1><p>让我们梳理一下我们的需求。</p><p>一直以来，我们对于「秒」的定义需求，从本质上讲，就是想要一个「完全稳定」的周期，也就是说，期望每一秒都是固定「等长」的。</p><p>而以天文观测、地球自转为基础的时间测量，做不到这一点。</p><p>那在微观世界层面，是否存在一种元素，它的运动周期是「高度稳定」，不受外界环境影响的呢？</p><p>科学家们沿着这个思路开始探索…</p><p>好，现在让我们把视角下放，来到原子世界。</p><p>一个原子虽然很小，但它内部却是一个很复杂的世界。</p><p>每个原子都有一个原子核，核外分层排布着高速运转的电子，当原子受电磁辐射时，它的轨道电子可以从一个位置「跳」到另一个位置，物理学上称此为「跃迁」。</p><p>人们发现，原子内的电子发生跃迁时，原子会吸收或放出一定能量的「电磁波」，这类电磁波就是一种「周期运动」，我们也可以把它看成原子内部的「振荡」。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2M4YWIwZDRhODlhMWRlMDc4NDQwZGM0ODJhYWIwNGFfejFxVXhmSTBKYUEwNVNON0pEeWZlS1ZQOFVSRUduSDhfVG9rZW46Ym94Y244SE9JMnNVbEhYbTVHRFFlQUFKMGhlXzE2MjcxNDc5MTk6MTYyNzE1MTUxOV9WNA" alt="img"></p><p>基于这个原理，科学家们开始不断地试验、研究，尝试寻找一种运动「周期短、高度稳定」的原子。</p><p>终于，科学家们发现确实存在这样一种原子：<strong>铯原子</strong>，它内部的振荡周期比其它原子都要<strong>更短、更稳定</strong>，而且，这个过程基本不受环境因素的干扰。</p><p>经过层层试验，科学家们认为这是目前人类在地球上可测量到的，运动周期最短、周期最稳定的元素！</p><p>之后，科学家们就以之前定义的「秒」为基础，去测量一秒内这个铯原子内部电子周期运动的「次数」，测量出来的结果为 9192631770 次（91 亿+次）。</p><p>基于此，科学家们决定「抛弃」原来基于天文测量的秒，重新定义「秒」的时长，就是这个高度稳定的运动周期。</p><p>因此，在 1967 年，国际度量衡大会决定采用，<strong>以铯原子跃迁 9192631770 个周期，所持续的时间长度定义为 1 秒！</strong></p><blockquote><p>注：这个测量原理和测量过程比较复杂，这里把这些物理细节简化了。不用太过纠结这个数值是怎么测量出来的，你只需要理解，这个微观原子内部的振荡周期是非常稳定的，它比之前根据天文现象测量出来的秒，要精确多得多。</p></blockquote><p>而基于这个铯原子振荡制造出来的时钟，我们就把它称之为「原子钟」。</p><p>有了原子钟，这就意味着，原子钟输出的每一秒，都是绝对「等长」的，非常稳定，这样一来，就实现了「精准计时」！</p><p>这个精确程度可以达到多高呢？</p><p>2000 万年不差 1 秒！可见其精准程度之高。</p><blockquote><p>科研技术还在发展，精密设备和测量能力也越来越高，最新的原子钟甚至可以达到 1 亿年不差 1 秒！</p></blockquote><p>有了原子钟，<strong>人们基于原子钟又确立了一套新的时间标准，叫做「国际原子时」（International Atomic Time，简称 TAI）。</strong></p><p>科学家们规定，从 1958-01-01 00:00:00 起，用原子时开始计时，它每走的一秒，都是非常精确的一秒（固定等长），实打实的一秒，完全稳定的一秒。</p><p>这个方案非常棒，至此终于解决了秒不固定长的问题。</p><p>那有了这个国际原子时，可否让它直接取代掉前面说的——以天文现象计时的「世界时」呢？</p><p>答案是否定的，这个问题远比想象的复杂得多，这是为什么呢？</p><h1 id="世界标准时间是怎么来的？"><a href="#世界标准时间是怎么来的？" class="headerlink" title="世界标准时间是怎么来的？"></a><strong>世界标准时间是怎么来的？</strong></h1><p>现在，科学家制定出了两套时间标准：</p><ol><li><strong>世界时</strong>：基于天文现象 + 钟表计时，永远与地球自转时间相匹配</li><li><strong>国际原子时</strong>：基于原子钟计时，每一秒的周期完全等长且固定</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2JiNDRjZWQ0YTA5NDhjYmEwZDU3ZGFjN2EwNGRlMmJfQ3JlbUxqeFd4Z1RWR1VvN3RSa0FtM09uRzFucHpRcEdfVG9rZW46Ym94Y25pelJQOGpBZTZhbm1HaTExT3VKYnJmXzE2MjcxNDc5MTk6MTYyNzE1MTUxOV9WNA" alt="img"></p><p>假设我们以<strong>国际原子时</strong>为时间标准，那会发生什么现象呢？</p><p>因为原子时非常稳定，但世界时随着地球自转变慢，会越来越慢，就会发生这种现象：</p><ul><li><p>原子时走得快，世界时走得慢，时间越久，两者差距越来越大</p></li><li><p>日复一日，几百年后，世界时的正午 12 点是太阳高照的时刻，而原子时可能已经走到了下午 2 点了</p></li><li><p>几千年后，太阳高照的时刻，原子时可能已经走到了<strong>晚上 8 点</strong>！</p></li></ul><p>晚上 8 点是太阳高照的时刻，你能想象这种情况吗？</p><p>这太颠覆我们的生活认知了…</p><p>基于天文测算的世界时，已经指导我们人类生活了上千年，人类早已习惯了这种时间标准，直接被原子时取代，肯定是不能接受的。</p><p>但我们又需要原子时这种高度稳定的计时标准，来发展科学研究，两者发生矛盾，这怎么办？</p><p>科学家们又开始思考，终于想到一个互相兼容的解决方案。</p><p>既然两套时间标准都很重要，那两者都保留，不会互相取代。</p><p>我们可以再建立一套「新的时间标准」，这套时间以「原子时为基准」，开始计时，走的每一秒都是稳定、精确的。</p><p>同时，为了兼顾基于天文测量的世界时，人类会「持续观测」世界时与这个新时钟的差距。</p><p>如果发现两者相差过大时，我们就「人为」地调整一下这个时钟（加一秒或减一秒），让两者相差不超过 0.9 秒。</p><p>例如，这个时钟本身比世界时走得快，经过一段时间后，如果发现两者相差越来越大，那就给这个时钟「加一秒」，让这个时钟在 23:59:59 的下一秒变为 23:59:60 秒，让它与世界时差距控制在 0.9 秒以内，这个操作过程，相当于让快的时钟稍微「等」一下走得慢的世界时。</p><p><strong>而加的这一秒，科学家把它定义为「闰秒」。</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTA0YWNmNDEyYWE2NzhkMWY4YzlkZTY2NTAxMzBhMWFfMVcyNDI0emsyZ2VoNzlzYzZFTjV1N0VUVEduYVNmVkVfVG9rZW46Ym94Y25POTdXTEtUeUZBMnFmaVM5czVJMURmXzE2MjcxNDc5MTk6MTYyNzE1MTUxOV9WNA" alt="img"></p><p>是不是挺有意思？听说过闰年，没想到还有闰秒！</p><blockquote><p>当然，当地球自转速度变快时，这里也有可能是减一秒，即从 23:59:58 直接跳到 00:00:00。但这种情况比较少，大部分情况下，地球自转速度是越来越慢的。</p></blockquote><p>这么做的好处在于，这个时钟的每一秒的计时依旧是精确的，而且还兼顾了日常生活使用的世界时，一举两得！</p><p><strong>由于这个时钟是基于原子时 + 世界时「协调」得出的，所以科学家们把它定义为协调世界时（Coordinated Universal Time，简称 UTC）。</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2U5ZjFhOTdlMGY3ZmU1ZWJhM2IyMTJiOWI5NDk3NDJfNXN3dDdjREY1S2d2YnlNb1ExbjBGem5lS2FBRGJFUWlfVG9rZW46Ym94Y243cXFzS1ljTVJyZ1VpSFc0M3hxWU5kXzE2MjcxNDc5MTk6MTYyNzE1MTUxOV9WNA" alt="img"></p><blockquote><p>看到了么？我们在开发时经常看到的 UTC，原来是这样来的！</p></blockquote><p>有了这个研究成果，有技术能力的国家都纷纷制造自己的原子钟，然后计算协调世界时。</p><p>同时，为了进一步降低原子钟的测量误差，每个国家会在每个月，统一上报自己计算的世界协调时到一个权威机构，然后这个权威机构会根据各国实验室的精度，进行加权计算，算出「最终」的协调世界时。</p><p>之后，再把这个最终的时间下发到各个国家，让各个国家进行「对表」校准，保证全世界的时间误差在 <strong>100 纳秒</strong>以内。</p><p>至此，科学家们建立的这套时间标准，就是我们现在沿用至今的「<strong>标 准 时 间</strong>」！</p><p>值得一提的是，配合计算世界协调时的国家，也有中国，这个实验室就是「中国科学院国家授时中心」，它位于中国的陕西省渭南市蒲城县，持续维护中国的标准时间。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDZlOTc2MTBlOWJkZjE4MGU2ZGY2ZmY4YTEyZmZiZTRfRnlRVHgwSE9tY3FYS3hDTGVrNEtqdUh1M1dvMWJ1ekxfVG9rZW46Ym94Y25jeWFXQWlaajc1VEFKa1JQakt3Z1ljXzE2MjcxNDc5MTk6MTYyNzE1MTUxOV9WNA" alt="img"></p><blockquote><p>为什么国家授时中心会设立在陕西省？因为陕西省的地理位置处于中国的中部，从这个位置向各地广播时间时，对全国每个地区距离都是相对平均的。</p></blockquote><p>之后，中国会在自己算出的世界协调时的基础上，再加 8 个小时（中国在东八区），最终得出来的时间，就是「<strong>北 京 时 间</strong>」！</p><p>没错，就是我们经常在新闻播报上听到的，北京时间。</p><blockquote><p>是不是挺有意思？北京时间并不是在北京产生的，而是在陕西省，并与参与世界时间的制定和校准。</p></blockquote><p>至此，全新的世界标准时间确立了，这套时间标准于 1972 年正式确定，一致沿用至今。</p><p>有了标准时间，那么接下来的问题就是，这个标准时间到底是如何同步到我们的电脑、手机、电子设备上的呢？</p><p>这就是下面要讲的「<strong>授时</strong>」。</p><h1 id="计算机如何同步时间？"><a href="#计算机如何同步时间？" class="headerlink" title="计算机如何同步时间？"></a><strong>计算机如何同步时间？</strong></h1><p>到现在我们知道，世界标准时间和北京时间是怎么来的，但北京时间的产生是在陕西省，难道校准一次时间需要跑到这里吗？</p><p>很显然是不需要的。</p><p>位于陕西省的中国科学院国家授时中心，产生北京时间后，会通过一系列方式，把这个时间广播出去，这个过程，就叫做「授时」。</p><p>具体怎么做呢？</p><p>国家授时中心提供很多授时方式，例如<strong>无线电波、网络、电话</strong>，都可以把时间广播出去。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDBkMmJjOWMyOTdhNWZiMWFiYWI2NDMxOGViYTJkY2FfVnJNdEU4a1BMQ3dLSVh5Q3JOaTJCSjI1dnBweDVJeFZfVG9rZW46Ym94Y25lNm9OVTlWaHZxWHNOdFpqYVpNWGdSXzE2MjcxNDc5MTk6MTYyNzE1MTUxOV9WNA" alt="img"></p><p>通常来说，无线电波的传播速度更快、传播误差小，所以授时中心会通过这种方式，把时间发送给全国各地的「时间服务器」。</p><p>时间服务器有了准确的时间后，再通过其它方式（例如网络）广播到下一层的终端用户使用。</p><p>经过这么一番研究，到这里我们就可以解释文章开头的问题了。</p><p>一个时间服务器，原来是通过国家授时中心同步时间，然后再给其它终端提供时间同步服务的。</p><p>那我们的计算机如何和它保持同步呢？</p><p>你可能会想，最简单的方式就是，客户端向服务端「请求获取」标准时间，服务端响应时间数据，客户端修改自己的「本机时间」即可。</p><p>但事情没你想的这么简单。</p><p>因为数据在网络传输过程中，也是需要时间的，这个时间也会影响到时间的准确性。</p><p>这怎么办呢？</p><p>于是人们想了一种方案，当计算机在做时间校准时，也需要把网络延迟计算进去，最后「修正」这个同步过来的时间，降低误差。</p><p>现在，已经有个软件已经把这一切都做好了，如果你了解一些运维相关的工作，就会知道，我们部署应用程序的服务器上，都会启动一个「自动校准」时间的服务，这个服务就是 NTP（Network Time Protocol），它可以保证每台机器的时间与时间服务器保持同步。</p><p>那 NTP 是怎么同步服务器时间的呢？</p><p>这里就涉及到 2 个重点：</p><ol><li>NTP 如何同步时间？</li><li>同步时间时，对正在运行的程序有没有影响？</li></ol><p>先来看第一个问题：<strong>NTP 如何同步时间？</strong></p><p>简单来讲，它是通过在网络报文上打「时间戳」的方式，然后配合计算网络延迟，从而修正本机的时间。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTE1ZTY4NWM2MjY1YWY3OGNiMWJkNmY3M2E2YzdmMmFfU1JUMHp1eVNLSmZNRU14UlllRHFXTnhEVEEyUk82MG5fVG9rZW46Ym94Y245ZVp1alhXY0RSR0JhV3gxb0JNVUFnXzE2MjcxNDc5MTk6MTYyNzE1MTUxOV9WNA" alt="img"></p><p>根据图示可以计算出网络「传输延迟」，以及客户端与服务端的「时间差」：</p><ul><li><p>网络延时 = (t4 - t1) - (t3 - t2)</p></li><li><p>时间差 = t2 - t1 - 网络延时 / 2 = ((t2 - t1) + (t3 - t4)) / 2</p></li></ul><blockquote><p>这个计算过程假设网络来回路径是对称的，并且时延相同。</p></blockquote><p>这样一来，客户端就可以「校准」自己的本机时间了，与服务端保持同步，这个时间误差在广域网下是 10ms - 500ms，在局域网下通常可以小于 1ms。</p><p>再来看第二个问题：<strong>同步时间时，对正在运行的程序有没有影响？</strong></p><p>例如，我们很多时候写的程序代码是这样的：</p><pre><code>t1 = time.now()// 时间发生校准t2 = time.now()// t2比t1小怎么办？elapsed = t2 - t1</code></pre><p>t2 的时间真的会比 t1 小吗？</p><p>这里就牵涉出 2 个概念：墙上时钟、单调时钟，它们之间有什么区别呢？</p><ul><li><p><strong>墙上时钟</strong>：通常就是指前面讲到的世界协调时 UTC，校准时间后，可能发生回拨</p></li><li><p><strong>单调时钟</strong>：计算机自启动以后经历的纳秒数，不会回拨</p></li></ul><p>一般我们写的代码，像上面程序调用的「时间 API」，通常获取的时间是<strong>墙上时钟</strong>，所以，如果时间发生校准，就可能会发生「时光倒流」的情况。</p><p>这必然对程序产生很大的影响，怎么解决这个问题呢？</p><p>幸运的是，NTP 在校准时间时，提供了 2 种方式：</p><ol><li><strong>ntpdate</strong>：一切以服务端时间为准，「强制修改」本机时间</li><li><strong>ntpd</strong>：采用「润物细无声」的方式修改本机时间，把时间差均摊到每次小的调整上</li></ol><p>也就是说，ntpd 当接收到需要「回拨」的时间时，会让本机时间走得「慢」一点，小步调整，逐渐与服务端的时钟「对齐」，这样一来，本机时间依旧是递增的，避免发生「倒流」。</p><p>当我们在配置 ntp 服务时，需要格外注意这种情况。另外，在编写程序时，也要注意调用的时间 API 获取的是哪个时间，避免业务逻辑发生异常。</p><p>至此，我们从看似简单的时间问题，一步步深挖到时间的定义，再到时间是如何同步到计算机和终端设备的，怎么样，有没有解答了你心中的很多疑惑？</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>好了，总结一下。</p><p>这篇文章我们讲了非常多的概念，这里我们再重新梳理一遍。</p><p>1、人类的早期生活，依靠观测「天文现象」来测量时间，基于地球自转规律，定义了一套时间标准：「世界时」。</p><p>2、后来人们发现，由于地球公转轨道是一个椭圆，并且地球自转还受到地球内部的影响，自转速度越来越慢，人们发现世界时测算出的时间「不准」。</p><p>3、科学家们开始从「微观世界」寻找更稳定的周期运动，最终确定以「铯原子」的振动频率为基准，制造出了「原子钟」，确立了「世界原子时」，并重新定义了「秒」长度，时长高度精确。</p><p>4、但由于人类社会活动已高度依赖「世界时」，所以科学家们基于「原子时」和「世界时」，最终确立出新的时间标准：「世界协调时」，把它定义成了全球的时间标准，至此，世界标准时间诞生。</p><p>5、中国基于「世界协调时」再加上 8 小时时区之差，确立了「北京时间」，并广播给整个中国大地使用。</p><p>6、「国家授时中心」把北京时间广播给全国的「时间服务器」，我们生活中使用的时间，例如计算机，就是通过时间服务器自动同步校准的。</p><p>7、计算机通过 NTP 完成和时间服务器的「自动校准」，我们的应用程序基于此，才得以获取到准确的时间。</p><p>8、NTP 服务应该采用润物细无声的方式同步时间，避免时间发生「倒流」。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a><strong>后记</strong></h1><p>这篇文章是我有史以来，最难写的一篇，因为其中有大量科普类知识，涉及范围之广远超我的想象。</p><p>在写这篇文章时，我至少阅读了 30 篇以上的资料，很多时候会因为一个很小的细节，又深挖出更多相关的领域的知识，让我目不暇接。</p><p>例如，铯原子的振动频率是怎么测量的？为什么能测量得这么精确？各个国家的原子钟为什么会有差异？计算机是如何处理闰秒的？时区是怎么来的？本初子午线是什么？…</p><p>很多细节我其实并没有展开来讲，我已尽力避开讲那些晦涩难懂的物理知识，只保留了重要的理论概念，希望你理解了这其中的原理。如果有些细节你没有读懂，可以先尝试多读几遍，也可以与我进一步交流。</p><p>同时，在查阅资料过程中，真切地感叹人类研究成果之伟大，能把时间的误差，缩小到几亿年的精度，敬佩之情无以言表。</p><p>我们在写代码时，看似调用了一个简单的时间 API，可曾想过，背后却是人类多少年来的智慧结晶。希望这篇文章能解答你对时间的种种疑惑。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer | Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ghidra色彩重构</title>
      <link href="/posts/d537.html"/>
      <url>/posts/d537.html</url>
      
        <content type="html"><![CDATA[<h2 id="Ghidra-色彩重构V1-0"><a href="#Ghidra-色彩重构V1-0" class="headerlink" title="Ghidra 色彩重构V1.0"></a>Ghidra 色彩重构V1.0</h2><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><p>原生软件各处的色彩通过直接调用Java 默认<a href="https://www.apiref.com/java11-zh/java.desktop/java/awt/Color.html" target="_blank" rel="noopener">Color类</a>调用，色彩被“写死”在各个地方，对颜色的修改或主题切换的管理十分复杂。</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>通过将使用的色彩写入配置文件中，将软件UI使用的色彩统一通过配置文件加载与管理，目前主流的配置文件使用<code>json，xml，properties</code>等，通过在配置文件中以Key-Value形式或字典形式存储16进制色彩，通过构建处理配置文件的Class，实现读写配置文件的基本函数、字符与色彩对象转换函数等功能，最终将软件所有的色彩替换或添加到配置文件中，实现色彩重构！</p><h3 id="色彩工具"><a href="#色彩工具" class="headerlink" title="色彩工具"></a>色彩工具</h3><p><a href="https://www.qtccolor.com/findColor.aspx" target="_blank" rel="noopener">千通彩</a></p><p><a href="https://color.uisdc.com/" target="_blank" rel="noopener">传统配色</a></p><p><a href="https://www.qianbo.com.cn/Tool/Rgba/" target="_blank" rel="noopener">RGB色彩对照表</a></p><h3 id="具体方案"><a href="#具体方案" class="headerlink" title="具体方案"></a>具体方案</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>依据Java原生的<a href="https://www.apiref.com/java11-zh/java.base/java/util/Properties.html" target="_blank" rel="noopener">Properties类</a>，使用<code>.propertise</code>配置文件来实现色彩重构的存储对象。</p><p>配置文件放在Docking目录下：</p><pre><code>Ghidra/Framework/Docking/src/main/resources/config/Color.properties</code></pre><h4 id="解决Properties嵌套问题"><a href="#解决Properties嵌套问题" class="headerlink" title="解决Properties嵌套问题"></a>解决Properties嵌套问题</h4><p>在构建PropertiesHandle.class之前，发现Java原生的Properties.class无法处理属性嵌套（Nested Properties），举个例子：对于各类组件的背景色假如是黑色（#ff000000），如果把每个组件的背景色都写死，显得十分的蠢，例如：</p><pre><code>button.background = #ff000000Table.background = #ff000000Panel.background = #ff000000……</code></pre><p>我们可以通过引入嵌套，通过<code>${}</code>来调用配置文件的其他Key，上述配置改为：</p><pre><code>BLACK = #ff000000button.background = ${BLACK}Table.background = ${BLACK}Panel.background = ${BLACK}……</code></pre><p>这样，对于一些类似的色彩属性可以统一管理。</p><p>因此，需要对Java 的Properties.class进行改写，利用正则表达式匹配，从而实现嵌套，构建PropertiesEnhance.class:</p><pre><code>package ghidra.util.config;import java.util.Properties;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * Let Properties be Nested * by using ${} * */public class PropertiesEnhance extends Properties {    @Override    public String getProperty(String key) {        String str = super.getProperty(key);        String pattern = "\\$\\{.*?}";        Pattern r = Pattern.compile(pattern);        Matcher m = r.matcher(str);        while (m.find()) {            String findKey = m.group();            String fixKey = findKey.replaceAll("[${}]", "");            String findValue = super.getProperty(fixKey);            str = str.replaceAll(escapeExprSpecialWord(findKey), findValue);        }        return str;    }    /**     * 转义正则特殊字符 （$()*+.[]?\^{},|）     */    public String escapeExprSpecialWord(String keyword) {        if (keyword != null &amp;&amp; keyword.length() &gt; 0) {            String[] fbsArr = { "\\", "$", "(", ")", "*", "+", ".", "[", "]", "?", "^", "{", "}", "|" };            for (String key : fbsArr) {                if (keyword.contains(key)) {                    keyword = keyword.replace(key, "\\" + key);                }            }        }        return keyword;    }}</code></pre><h4 id="PropertiesHandle实现"><a href="#PropertiesHandle实现" class="headerlink" title="PropertiesHandle实现"></a>PropertiesHandle实现</h4><p>该类通过实现三个基本函数：</p><p>GetValueByKey：通过给定的Key获取Properties文件中对应的Value</p><p>GetAllProperties：获取Properties配置文件中所有的Value</p><p>WriteProperties：向指定的Properties文件中写入键值对（key-value）</p><pre><code>package ghidra.util.config;import java.io.*;import java.util.Enumeration;public class PropertiesHandle {    /**     * Find the value according to Key     * @param filePath Filepath String     * @param key String     * @return Value String     * */    public static String GetValueByKey(String filePath, String key) {        PropertiesEnhance pps = new PropertiesEnhance();        try {            InputStream in = new BufferedInputStream(new FileInputStream(filePath));            pps.load(in);            String value = pps.getProperty(key);            return value;        }catch (IOException e) {            e.printStackTrace();            return null;        }    }    public static String GetValueByKey(InputStream fileStream, String key) {        PropertiesEnhance pps = new PropertiesEnhance();        try {            InputStream in = fileStream;            pps.load(in);            String value = pps.getProperty(key);            return value;        }catch (IOException e) {            e.printStackTrace();            return null;        }    }    /**     * Read all value from properties file     * @param filePath Filepath String     * @return Value String     * */    public static void GetAllProperties(String filePath) throws IOException {        PropertiesEnhance pps = new PropertiesEnhance();        InputStream in = new BufferedInputStream(new FileInputStream(filePath));        pps.load(in);        Enumeration en = pps.propertyNames();        while(en.hasMoreElements()) {            String strKey = (String) en.nextElement();            String strValue = pps.getProperty(strKey);        }    }    /**     * Write value to properties file     * @param filePath Filepath String     * @param pKey String     * @param pValue Sting     * */    public static void WriteProperties (String filePath, String pKey, String pValue) throws IOException {        PropertiesEnhance pps = new PropertiesEnhance();        InputStream in = new FileInputStream(filePath);        pps.load(in);        OutputStream out = new FileOutputStream(filePath);        pps.setProperty(pKey, pValue);        pps.store(out, "Update " + pKey + " name");    }}</code></pre><h4 id="色彩转换实现"><a href="#色彩转换实现" class="headerlink" title="色彩转换实现"></a>色彩转换实现</h4><p>实现色彩的十六进制字符表示与Color Object的相互转换：</p><p>toHexFromColor：色彩对象转十六进制色彩</p><p>toColorFromString：十六进制色彩转色彩对象</p><p>实现了读取配置文件中色彩的RGB表示或RGBA表示。</p><p>例如：#ffffffff（前两位是透明度信息）和#ffffff（透明度默认100%，不透明）</p><pre><code>package ghidra.util.config;import java.awt.*;public class ColorHexConvert {    public static Color color;    /**     * Color Object converts to String     * @param color Color Object     * @return Hex Color String     * */    private static String toHexFromColor(Color color){        String r,g,b;        StringBuilder su = new StringBuilder();        r = Integer.toHexString(color.getRed());        g = Integer.toHexString(color.getGreen());        b = Integer.toHexString(color.getBlue());        r = r.length() == 1 ? "0" + r : r;        g = g.length() ==1 ? "0" +g : g;        b = b.length() == 1 ? "0" + b : b;        r = r.toUpperCase();        g = g.toUpperCase();        b = b.toUpperCase();        su.append("0xFF");        su.append(r);        su.append(g);        su.append(b);        return su.toString();    }    /**     * String converts to Color Object     * @param colorStr Hex Color String     * @return Color Object     * */    public static Color toColorFromString(String colorStr){        if (colorStr.length() == 7){            colorStr = colorStr.replace("#","0xff");            color = toColorFromString0(colorStr);        }        else if (colorStr.length() == 9){            colorStr = colorStr.replace("#","0x");            color = toColorFromString0(colorStr);        }        else{            colorStr = "0xff000000";            color = toColorFromString0(colorStr);        }        return color;    }    public static Color toColorFromString0(String colorStr){        String str_a = colorStr.substring(2, 4);        String str_r = colorStr.substring(4, 6);        String str_g = colorStr.substring(6, 8);        String str_b = colorStr.substring(8, 10);        int a = Integer.parseInt(str_a, 16);        int r = Integer.parseInt(str_r, 16);        int g = Integer.parseInt(str_g, 16);        int b = Integer.parseInt(str_b, 16);        Color color =  new Color(r, g ,b , a);        return color;    }}</code></pre><h4 id="色彩调用封装"><a href="#色彩调用封装" class="headerlink" title="色彩调用封装"></a>色彩调用封装</h4><p>实现直接调用从配置文件中色彩属性的封装</p><pre><code>package ghidra.util.config;import resources.ResourceManager;import java.awt.*;import java.io.InputStream;import static ghidra.util.config.ColorHexConvert.toColorFromString;import static ghidra.util.config.PropertiesHandle.GetValueByKey;/** * Get Color from Config file * */public class ReadColorFromConfig {    public static Color findColor(String key){        return ReadColorFromProperties(key);    }    /**     * ReadColorFromProperties     * @param key String     * @return Color Object     * */    private static Color ReadColorFromProperties(String key) {        InputStream ColorConfigFile = ResourceManager.getResourceAsStream("config/Color.properties");        Color color = toColorFromString(GetValueByKey(ColorConfigFile, key));        return color;    }}</code></pre><h4 id="色彩替换"><a href="#色彩替换" class="headerlink" title="色彩替换"></a>色彩替换</h4><p>通过调用函数<code>findColor(key)</code>可以从配置文件中直接读取色彩，赋值给Color对象。</p><p>例如：</p><pre><code>Color DEFAULT_COLOR_REGISTER_MARKERS = findColor("Debugger.default.register.markers");setBackground(findColor("Button.background.pressed"));</code></pre><p>目前配置文件添加了Java原生基础色彩的16进制Key-Value，完全可以实现基础色彩的替换，对于一些自定义色彩，需要后续的替换和添加，主要就是色彩替换工作。</p><pre><code># Color Config File# Using to Set UI Color# ---- Java Base Color ----Pink = #FFC0CBCrimson = #DC143CLavenderBlush = #FFF0F5PaleVioletRed = #DB7093HotPink = #FF69B4DeepPink = #FF1493MediumVioletRed = #C71585Orchid = #DA70D6Thistle = #D8BFD8Plum = #DDA0DDViolet = #EE82EEMagenta = #FF00FFFuchsia = #FF00FFDarkMagenta = #8B008BPurple = #800080MediumOrchid = #BA55D3DarkVoilet = #9400D3DarkOrchid = #9932CCIndigo = #4B0082BlueViolet = #8A2BE2MediumPurple = #9370DBMediumSlateBlue = #7B68EESlateBlue = #6A5ACDDarkSlateBlue = #483D8BLavender = #E6E6FAGhostWhite = #F8F8FFBlue = #0000FFMediumBlue = #0000CDMidnightBlue = #191970DarkBlue = #00008BNavy = #000080RoyalBlue = #4169E1CornflowerBlue = #6495EDLightSteelBlue = #B0C4DELightSlateGray = #778899SlateGray = #708090DoderBlue = #1E90FFAliceBlue = #F0F8FFSteelBlue = #4682B4LightSkyBlue = #87CEFASkyBlue = #87CEEBDeepSkyBlue = #00BFFFLightBLue = #ADD8E6PowDerBlue = #B0E0E6CadetBlue = #5F9EA0Azure = #F0FFFFLightCyan = #E1FFFFPaleTurquoise = #AFEEEECyan = #00FFFFAqua = #00FFFFDarkTurquoise = #00CED1DarkSlateGray = #2F4F4FDarkCyan = #008B8BTeal = #008080MediumTurquoise = #48D1CCLightSeaGreen = #20B2AATurquoise = #40E0D0Auqamarin = #7FFFAAMediumAquamarine = #00FA9AMediumSpringGreen = #F5FFFAMintCream = #00FF7FSpringGreen = #3CB371SeaGreen = #2E8B57Honeydew = #F0FFF0LightGreen = #90EE90PaleGreen = #98FB98DarkSeaGreen = #8FBC8FLimeGreen = #32CD32Lime = #00FF00ForestGreen = #228B22Green = #008000DarkGreen = #006400Chartreuse = #7FFF00LawnGreen = #7CFC00GreenYellow = #ADFF2FOliveDrab = #556B2FBeige = #6B8E23LightGoldenrodYellow = #FAFAD2Ivory = #FFFFF0LightYellow = #FFFFE0Yellow = #FFFF00Olive = #808000DarkKhaki = #BDB76BLemonChiffon = #FFFACDPaleGodenrod = #EEE8AAKhaki = #F0E68CGold = #FFD700Cornislk = #FFF8DCGoldEnrod = #DAA520FloralWhite = #FFFAF0OldLace = #FDF5E6Wheat = #F5DEB3Moccasin = #FFE4B5Orange = #FFA500PapayaWhip = #FFEFD5BlanchedAlmond = #FFEBCDNavajoWhite = #FFDEADAntiqueWhite = #FAEBD7Tan = #D2B48CBrulyWood = #DEB887Bisque = #FFE4C4DarkOrange = #FF8C00Linen = #FAF0E6Peru = #CD853FPeachPuff = #FFDAB9SandyBrown = #F4A460Chocolate = #D2691ESaddleBrown = #8B4513SeaShell = #FFF5EESienna = #A0522DLightSalmon = #FFA07ACoral = #FF7F50OrangeRed = #FF4500DarkSalmon = #E9967ATomato = #FF6347MistyRose = #FFE4E1Salmon = #FA8072Snow = #FFFAFALightCoral = #F08080RosyBrown = #BC8F8FIndianRed = #CD5C5CRed = #FF0000Brown = #A52A2AFireBrick = #B22222DarkRed = #8B0000Maroon = #800000White = #FFFFFFWhiteSmoke = #F5F5F5Gainsboro = #DCDCDCLightGrey = #D3D3D3Silver = #C0C0C0DarkGray = #A9A9A9Gray = #808080DimGray = #696969Black = #000000# ==== Page｜Module ====# ---- Debugger ----Debugger.default.background.stale = ${LightGrey}Debugger.default.background.error = #FFBFBFDebugger.default.register.markers = #BFDFBFDebugger.default.register.stale = ${Gray}Debugger.default.register.stale.select = ${LightGrey}Debugger.default.register.changed = ${Red}Debugger.default.register.changed.select = #7D0000Debugger.default.watch.stale = ${Gray}Debugger.default.watch.stale.select = ${LightGrey}Debugger.default.watch.changed = ${Red}Debugger.default.watch.changed.select = #7D0000Debugger.default.pcode.counter = #BFDFBF# ==== Components ====# ---- Button ----Button.background = #ff404040# eventButton.background.focus = #0D7A7A7AButton.background.pressed = #0D9E9E9E……</code></pre><h3 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h3><p>Ghidra build后资源被封装成jar包，暂时无法面向用户去修改，对开发者提供色彩设置接口。</p><h1 id="Ghidra-色彩重构V2-0"><a href="#Ghidra-色彩重构V2-0" class="headerlink" title="Ghidra 色彩重构V2.0"></a>Ghidra 色彩重构V2.0</h1><p>根据V1.0版本的设计，存在无法为用户提供设置色彩的接口（即用户无法自己配置想要的色彩）</p><p>针对V1.0版本的问题，提出了V2.0的版本的设计。</p><h3 id="改进要点"><a href="#改进要点" class="headerlink" title="改进要点"></a>改进要点</h3><ul><li>Ghidra启动时动态加载配置文件</li><li>配置文件不封装进jar包，作为单独配置文件供用户修改使用</li></ul><h3 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h3><p>Ghidra的启动流程加载GUI过程中：首先需要加载软件布局<code>GhidraApplicationLayout()</code>，具体加载需要先找到软件项目的根目录，根据根目录加载软件属性<code>applicationProperties</code>，其中加载需要属性依据<code>application.properties</code>文件和<code>applicationProperties</code>类来实现（load），最后进行调用软件属性来继续后续流程，那么在加载软件属性后，即可加载配置文件，因此在这里需要实现配置文件加载获取，通过一个<code>ResourceFile</code>变量去存储属性，最后在需要使用色彩的地方从其中读取色彩。</p><p><strong>ghidra启动流程</strong></p><p>见附录：Ghidra启动分析。</p><h3 id="具体方案-1"><a href="#具体方案-1" class="headerlink" title="具体方案"></a>具体方案</h3><h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><p>根据ghidra build的过程，在<code>Ghidra/RuntimeScripts/Common/</code>目录下的文件不回被打包成jar包，同事目录下有<code>Ghidra/RuntimeScripts/Common/support/</code> 和<code>Ghidra/RuntimeScripts/Common/server</code>目录，在<code>build</code>之后会直接生成<code>support</code>和<code>server</code>目录，并不会打包成jar包，因此，将色彩重构的配置文件转移到<code>Ghidra/RuntimeScripts/Common/support/Color.properties</code>位置。</p><p>同时，在<code>Ghidra/RuntimeScripts/certification.manifest</code>文件中添加一条：</p><pre><code>Common/support/Color.properties||GHIDRA||||END|</code></pre><h4 id="配置文件类ConfigurationProperties实现"><a href="#配置文件类ConfigurationProperties实现" class="headerlink" title="配置文件类ConfigurationProperties实现"></a>配置文件类ConfigurationProperties实现</h4><p><em>之所以创建取名叫<em>`</em>ConfigurationProperties<em>`</em>而不是<em>`</em>ColorProperties<em>`</em>，为后面可能需要添加其他配置文件提供统一的入口，例如设置组件尺寸等等。</em></p><p>由于启动相关的代码在<code>Ghidra/Framework/Utility/</code>目录下，因此在<code>Ghidra/Framework/Utility/src/main/java/ghidra/framework/ConfigurationProperties.java</code>位置创建配置属性类，用于加载配置文件。</p><p>ConfigurationProperties实现如下：通过设置面向开发者的配置文件目录和面向用户的配置文件目录，通过添加开发模式判断来选择配置文件加载路径。并提供了从配置文件中读取色彩的接口<code>ReadColorFromProperties</code>。</p><pre><code>package ghidra.framework;import generic.jar.ResourceFile;import ghidra.util.SystemUtilities;import ghidra.util.config.PropertiesEnhance;import java.awt.*;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.util.Collection;import static ghidra.util.config.ColorHexConvert.toColorFromString;public class ConfigurationProperties extends PropertiesEnhance {    /**     * The name of the Color properties file.     */    public static final String COLOR_PROPERTY_NAME = "Color.properties";    public static final String COLOR_PROPERTY_FILE = "/RuntimeScripts/Common/support/Color.properties";    public static final String COLOR_PROPERTY_FILE_INS = "/support/Color.properties";    /**     * Creates a new configuration properties from the given config properties file.     *     * @param configPropertiesFile The application properties file.     * @throws IOException If there was a problem loading/reading a discovered properties file.     */    public ConfigurationProperties(ResourceFile configPropertiesFile) throws IOException {        if (!configPropertiesFile.exists()) {            throw new FileNotFoundException(                    COLOR_PROPERTY_NAME + " file does not exist: " + configPropertiesFile);        }        try (InputStream in = configPropertiesFile.getInputStream()) {            load(in);        }    }    /**     * Creates a new configuration properties from the configuration properties files found     * in the given application root directories.  If multiple configuration properties files     * are found, the properties from the files will be combined.  If duplicate keys exist,     * the newest key encountered will overwrite the existing key.     *     * @param applicationRootDirs The application root directories to look for the properties files in.     * @throws IOException If there was a problem loading/reading a discovered properties file.     */    public ConfigurationProperties(Collection&lt;ResourceFile&gt; applicationRootDirs) throws IOException {        boolean found = false;        // Application installation directory        ResourceFile applicationInstallationDir = applicationRootDirs.iterator().next().getParentFile();        if (SystemUtilities.isInDevelopmentMode()) {            for (ResourceFile appRoot : applicationRootDirs) {                ResourceFile configPropertiesFile = new ResourceFile(appRoot, COLOR_PROPERTY_FILE);                if (configPropertiesFile.exists()) {                    try (InputStream in = configPropertiesFile.getInputStream()) {                        load(in);                        found = true;                    }                }            }        }        else {            ResourceFile configPropertiesFile = new ResourceFile(applicationInstallationDir, COLOR_PROPERTY_FILE_INS);            if (configPropertiesFile.exists()) {                try (InputStream in = configPropertiesFile.getInputStream()) {                    load(in);                    found = true;                }            }        }        if (!found) {            throw new IOException(COLOR_PROPERTY_NAME + " was not found!");        }    }    /**     * Get Properties from Color.properties by key     *      * @param key Color.properties key     * @return Color Object     * */   public Color ReadColorFromProperties(String key) {      Color color = toColorFromString(getProperty(key));      return color;   }}</code></pre><p>其中<code>ConfigurationProperties</code>继承自<code>PropertiesEnhance</code>，具体见Ghidra 色彩重构V1.0中，将工具类位置改变到<code>Ghidra/Framework/Utility/src/main/java/ghidra/util/config/</code>目录下：</p><pre><code>import java.util.Properties;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * Let Properties be Nested * by using ${} * */public class PropertiesEnhance extends Properties {    @Override    public String getProperty(String key) {        String str = super.getProperty(key);        String pattern = "\\$\\{.*?}";        Pattern r = Pattern.compile(pattern);        Matcher m = r.matcher(str);        while (m.find()) {            String findKey = m.group();            String fixKey = findKey.replaceAll("[${}]", "");            String findValue = super.getProperty(fixKey);            str = str.replaceAll(escapeExprSpecialWord(findKey), findValue);        }        return str;    }    /**     * 转义正则特殊字符 （$()*+.[]?\^{},|）     */    public String escapeExprSpecialWord(String keyword) {        if (keyword != null &amp;&amp; keyword.length() &gt; 0) {            String[] fbsArr = { "\\", "$", "(", ")", "*", "+", ".", "[", "]", "?", "^", "{", "}", "|" };            for (String key : fbsArr) {                if (keyword.contains(key)) {                    keyword = keyword.replace(key, "\\" + key);                }            }        }        return keyword;    }}</code></pre><p>除此之外，将色彩转换<code>ColorHexConvert.class</code>也加到该目录下：</p><pre><code>package ghidra.util.config;import java.awt.*;public class ColorHexConvert {    public static Color color;    /**     * Color Object converts to String     * @param color Color Object     * @return Hex Color String     * */    private static String toHexFromColor(Color color){        String r,g,b;        StringBuilder su = new StringBuilder();        r = Integer.toHexString(color.getRed());        g = Integer.toHexString(color.getGreen());        b = Integer.toHexString(color.getBlue());        r = r.length() == 1 ? "0" + r : r;        g = g.length() ==1 ? "0" +g : g;        b = b.length() == 1 ? "0" + b : b;        r = r.toUpperCase();        g = g.toUpperCase();        b = b.toUpperCase();        su.append("0xFF");        su.append(r);        su.append(g);        su.append(b);        return su.toString();    }    /**     * String converts to Color Object     * @param colorStr Hex Color String     * @return Color Object     * */    public static Color toColorFromString(String colorStr){        if (colorStr.length() == 7){            colorStr = colorStr.replace("#","0xff");            color = toColorFromString0(colorStr);        }        else if (colorStr.length() == 9){            colorStr = colorStr.replace("#","0x");            color = toColorFromString0(colorStr);        }        else{            colorStr = "0xff000000";            color = toColorFromString0(colorStr);        }        return color;    }    public static Color toColorFromString0(String colorStr){        String str_a = colorStr.substring(2, 4);        String str_r = colorStr.substring(4, 6);        String str_g = colorStr.substring(6, 8);        String str_b = colorStr.substring(8, 10);        int a = Integer.parseInt(str_a, 16);        int r = Integer.parseInt(str_r, 16);        int g = Integer.parseInt(str_g, 16);        int b = Integer.parseInt(str_b, 16);        Color color =  new Color(r, g ,b , a);        return color;    }}</code></pre><p>同时，重新封装配置读取类<code>ReadConfigProperties</code>，同样通过<code>findColor()</code>函数读取配置文件中的色彩。</p><pre><code>package ghidra.util.config;import ghidra.framework.ConfigurationProperties;import utility.application.ApplicationLayout;import java.awt.*;import static utility.application.ApplicationLayout.getConfigurationProperties;public class ReadConfigProperties {//    static ConfigurationProperties configurationProperties = ApplicationLayout.configurationProperties;    static ConfigurationProperties configurationProperties = getConfigurationProperties();    public static Color findColor(String key){        Color color = configurationProperties.ReadColorFromProperties(key);        return color;    }}</code></pre><h4 id="动态加载配置文件类"><a href="#动态加载配置文件类" class="headerlink" title="动态加载配置文件类"></a>动态加载配置文件类</h4><p>首先在<code>Ghidra/Framework/Utility/src/main/java/ghidra/GhidraApplicationLayout.java</code></p><p>类中的构造函数<code>GhidraApplicationLayout()</code>和重载版本<code>GhidraApplicationLayout(File applicationInstallationDir)</code>中添加：</p><pre><code>// Configuration propertiesconfigurationProperties = new ConfigurationProperties(applicationRootDirs);</code></pre><p>在<code>Ghidra/Framework/Utility/src/main/java/utility/application/ApplicationLayout.java</code>中添加成员：</p><pre><code>protected static ConfigurationProperties configurationProperties;</code></pre><p>添加Get函数：</p><pre><code>/** * Gets the configuration properties from the application layout * * @return The configuration properties.  Should never be null. */public static final ConfigurationProperties getConfigurationProperties() {   return configurationProperties;}</code></pre><h3 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h3><ul><li>利用findColor替换软件中写死的色彩，在配置文件中添加色彩的键值。或者选择用户可设置的部分色彩进行替换（字体等），替换方式如下：</li></ul><pre><code>Color DEFAULT_COLOR_REGISTER_MARKERS = findColor("Debugger.default.register.markers");setBackground(findColor("Button.background.pressed"));</code></pre><ul><li>细节优化与修改</li></ul><p>最终实现：<a href="https://github.com/StarCrossPortal/ghidracraft/pull/33" target="_blank" rel="noopener">https://github.com/StarCrossPortal/ghidracraft/pull/33</a></p><h1 id="附录：Ghidra启动分析"><a href="#附录：Ghidra启动分析" class="headerlink" title="附录：Ghidra启动分析"></a>附录：Ghidra启动分析</h1><h2 id="GhidraLauncher-class"><a href="#GhidraLauncher-class" class="headerlink" title="GhidraLauncher.class"></a><strong><em>GhidraLauncher.class</em></strong></h2><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><h4 id="判断加载类是否实例化"><a href="#判断加载类是否实例化" class="headerlink" title="判断加载类是否实例化"></a>判断加载类是否实例化</h4><pre><code>// Make sure our class loader is being usedif (!(ClassLoader.getSystemClassLoader() instanceof GhidraClassLoader)) {   throw new ClassNotFoundException("ERROR: Ghidra class loader not in use.  " +      "Confirm JVM argument \"-Djava.system.class.loader argument=" +      GhidraClassLoader.class.getName() + "\" is set.");}</code></pre><ul><li><strong>Instanceof：</strong> Java 的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</li><li><strong><a href="https://devdocs.io/openjdk~11/java.base/java/lang/classloader" target="_blank" rel="noopener">ClassLoader</a>**</strong>：**</li></ul><h5 id="什么是ClassLoader"><a href="#什么是ClassLoader" class="headerlink" title="什么是ClassLoader"></a><strong>什么是ClassLoader</strong></h5><p>我们写好一个Java程序之后，不是管是CS还是BS应用，都是由若干个.class文件组织而成的一个完整的Java应用程序，当程序在运行时，即会调用该程序的一个入口函数来调用系统的相关功能，而这些功能都被封装在不同的class文件当中，所以经常要从这个class文件中要调用另外一个class文件中的方法，如果另外一个文件不存在的，则会引发系统异常。而程序在启动的时候，并不会一次性加载程序所要用的所有class文件，而是根据程序的需要，通过Java的类加载机制（ClassLoader）来动态加载某个class文件到内存当中的，从而只有class文件被载入到了内存之后，才能被其它class所引用。所以ClassLoader就是用来动态加载class文件到内存当中用的。</p><h5 id="Java默认提供的三个ClassLoader"><a href="#Java默认提供的三个ClassLoader" class="headerlink" title="Java默认提供的三个ClassLoader"></a><strong>Java默认提供的三个ClassLoader</strong></h5><ol><li><strong><em>BootStrap ClassLoader</em></strong>：称为启动类加载器，是Java类加载层次中最顶层的类加载器，<strong>负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等</strong>，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件：</li></ol><pre><code>URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();for (int i = 0; i &lt; urls.length; i++) {        System.out.println(urls[i].toExternalForm());}</code></pre><p>以下内容是上述程序从本机JDK环境所获得的结果：</p><blockquote><p>file:/C:/Program%20Files/Java/jdk1.6.0_22/jre/lib/resources.jar</p></blockquote><blockquote><p>file:/C:/Program%20Files/Java/jdk1.6.0_22/jre/lib/rt.jar</p></blockquote><blockquote><p>file:/C:/Program%20Files/Java/jdk1.6.0_22/jre/lib/sunrsasign.jar</p></blockquote><blockquote><p>file:/C:/Program%20Files/Java/jdk1.6.0_22/jre/lib/jsse.jar</p></blockquote><blockquote><p>file:/C:/Program%20Files/Java/jdk1.6.0_22/jre/lib/jce.jar</p></blockquote><blockquote><p>file:/C:/Program%20Files/Java/jdk1.6.0_22/jre/lib/charsets.jar</p></blockquote><blockquote><p>file:/C:/Program%20Files/Java/jdk1.6.0_22/jre/classes/</p></blockquote><p>其实上述结果也是通过查找sun.boot.class.path这个系统属性所得知的。</p><pre><code>System.out.println(System.getProperty("sun.boot.class.path"));</code></pre><p><strong>打印结果：</strong>C:\Program Files\Java\jdk1.6.0_22\jre\lib\resources.jar;C:\Program Files\Java\jdk1.6.0_22\jre\lib\rt.jar;C:\Program Files\Java\jdk1.6.0_22\jre\lib\sunrsasign.jar;C:\Program Files\Java\jdk1.6.0_22\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.6.0_22\jre\lib\jce.jar;C:\Program Files\Java\jdk1.6.0_22\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.6.0_22\jre\classes</p><ol><li><strong>Extension ClassLoader</strong>：称为扩展类加载器，负责加载Java的扩展类库，默认加载<strong>JAVA_HOME/jre/lib/ext/目下的所有jar</strong>。</li><li><strong>App ClassLoader</strong>：称为系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。</li></ol><blockquote><p><strong>注意：</strong> 除了Java默认提供的三个ClassLoader之外，用户还可以根据需要定义自已的ClassLoader，而这些自定义的ClassLoader都必须继承自java.lang.ClassLoader类，也包括Java提供的另外二个ClassLoader（Extension ClassLoader和App ClassLoader）在内，但是Bootstrap ClassLoader不继承自ClassLoader，因为它不是一个普通的Java类，底层由C++编写，已嵌入到了JVM内核当中，当JVM启动后，Bootstrap ClassLoader也随着启动，负责加载完核心类库后，并构造Extension ClassLoader和App ClassLoader类加载器。</p></blockquote><h5 id="ClassLoader加载类的原理"><a href="#ClassLoader加载类的原理" class="headerlink" title="ClassLoader加载类的原理"></a><strong>ClassLoader加载类的原理</strong></h5><p>ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTFjNTNjZjE2ZWI1MDkyZGFiZDIwYWU3ZjZiNzY5NmVfNVVrSkNWSU5kRUhZQ0xLWGNBR3psTk9NTVJRRHRkYUtfVG9rZW46Ym94Y24zbUlMRVVPWDN6R20xc1FIaGVKUWdDXzE2MjcxNDc2Njk6MTYyNzE1MTI2OV9WNA" alt="img"></p><h5 id="定义自已的ClassLoader"><a href="#定义自已的ClassLoader" class="headerlink" title="定义自已的ClassLoader"></a><strong>定义自已的ClassLoader</strong></h5><p>既然JVM已经提供了默认的类加载器，为什么还要定义自已的类加载器呢？</p><p>因为Java中提供的默认ClassLoader，只加载指定目录下的jar和class，如果我们想加载其它位置的类或jar时，比如：我要加载网络上的一个class文件，通过动态加载到内存之后，要调用这个类中的方法实现我的业务逻辑。在这样的情况下，默认的ClassLoader就不能满足我们的需求了，所以需要定义自己的ClassLoader。</p><p>定义自已的类加载器分为两步：</p><p>1、继承java.lang.ClassLoader</p><p>2、重写父类的findClass方法</p><p>读者可能在这里有疑问，父类有那么多方法，为什么偏偏只重写findClass方法？</p><p>因为JDK已经在loadClass方法中帮我们实现了ClassLoader搜索类的算法，当在loadClass方法中搜索不到类时，loadClass方法就会调用findClass方法来搜索类，所以我们只需重写该方法即可。如没有特殊的要求，一般不建议重写loadClass搜索类的算法。下图是API中ClassLoader的loadClass方法：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjNmNGNjZjIzZGMzMmZhNWU4OTJmYWRhNzQzNGU3NjFfeDVjZEpMcEhjT1FVcTRZUDRtSjdDVWVsOFowRmJIdWNfVG9rZW46Ym94Y25xSkhwMndDOUpPY2N0T05yUFFZYlFkXzE2MjcxNDc2Njk6MTYyNzE1MTI2OV9WNA" alt="img"></p><h4 id="获取软件布局"><a href="#获取软件布局" class="headerlink" title="获取软件布局"></a>获取软件布局</h4><pre><code>// Get application layoutGhidraApplicationLayout layout = new GhidraApplicationLayout();GhidraClassLoader loader = (GhidraClassLoader) ClassLoader.getSystemClassLoader();</code></pre><ul><li><strong>GhidraApplicationLayout</strong>: -&gt; ApplicationLayout</li></ul><h5 id="System-getProperty-“java-class-path”"><a href="#System-getProperty-“java-class-path”" class="headerlink" title="System.getProperty(“java.class.path”)"></a>System.getProperty(“java.class.path”)</h5><p>Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。</p><p>一个属性列表可包含另一个属性列表作为它的“默认值”；如果未能在原有的属性列表中搜索到属性键，则搜索第二个属性列表。</p><p>因为 Properties 继承于 Hashtable，所以可对 Properties 对象应用 put 和 putAll 方法。但不建议使用这两个方法，因为它们允许调用者插入其键或值不是 String 的项。相反，应该使用 setProperty 方法。如果在“不安全”的 Properties 对象（即包含非 String 的键或值）上调用 store 或 save 方法，则该调用将失败。类似地，如果在“不安全”的 Properties 对象（即包含非 String 的键）上调用 propertyNames 或 list 方法，则该调用将失败。</p><p>将 getProperty(String) 方法使用的当前系统属性集合作为 Properties 对象返回。如果没有当前系统属性集合，则先创建并初始化一个系统属性集合。这个系统属性集合总是包含以下键的值：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTY4YTZiMmFiY2FmZDQxNjhkMGQ2OTVkZGE3MDhkMmVfVVNmalg0dGpCdjlKQjNTT3J2NVBvUmhpblpWbndDN2tfVG9rZW46Ym94Y25pTU92T1NtUVBYMXo3ZVB0TVNnaUNoXzE2MjcxNDc2Njk6MTYyNzE1MTI2OV9WNA" alt="img"></p><p>系统属性值中的多个路径是用平台的路径分隔符分隔的。</p><p>注意，即使安全管理器不允许执行 <code>getProperties</code> 操作，它可能也会选择允许执行 <code>getProperty(String)</code> 操作。</p><p><strong>File.pathSeparator与File.separator的区别：</strong></p><blockquote><p>File.pathSeparator指的是分隔连续多个路径字符串的分隔符，例如:</p></blockquote><blockquote><p>java   -cp   test.jar;abc.jar   HelloWorld</p></blockquote><blockquote><p>就是指“;”</p></blockquote><blockquote><p>File.separator才是用来分隔同一个路径字符串中的目录的，例如：</p></blockquote><blockquote><p>C:/Program Files/Common Files</p></blockquote><blockquote><p>就是指“/”</p></blockquote><blockquote><p>与系统有关的默认名称分隔符。此字段被初始化为包含系统属性 file.separator 值的第一个字符。在 UNIX 系统上，此字段的值为 ‘/‘；在 Microsoft Windows 系统上，它为 ‘/‘。</p></blockquote><pre><code>public GhidraApplicationLayout() throws FileNotFoundException, IOException {   // Application root directories   applicationRootDirs = findGhidraApplicationRootDirs();   // Application properties   applicationProperties = new ApplicationProperties(applicationRootDirs);   // Application installation directory   applicationInstallationDir = findGhidraApplicationInstallationDir();   // User directories   userTempDir = ApplicationUtilities.getDefaultUserTempDir(getApplicationProperties());   userCacheDir = ApplicationUtilities.getDefaultUserCacheDir(getApplicationProperties());   userSettingsDir = ApplicationUtilities.getDefaultUserSettingsDir(getApplicationProperties(),      getApplicationInstallationDir());   // Extensions   extensionInstallationDirs = findExtensionInstallationDirectories();   extensionArchiveDir = findExtensionArchiveDirectory();   // Patch directory   patchDir = findPatchDirectory();   // Modules   modules = findGhidraModules();}</code></pre><ul><li><strong>GhidraClassLoader</strong>：-&gt; URLClassLoader -&gt; SecureClassLoader -&gt; ClassLoader</li></ul><h4 id="路径构建"><a href="#路径构建" class="headerlink" title="路径构建"></a>路径构建</h4><pre><code>// Build the classpathList&lt;String&gt; classpathList = new ArrayList&lt;&gt;();Map&lt;String, GModule&gt; modules = getOrderedModules(layout);</code></pre><ul><li><strong><em>getOrderedModules</em></strong></li></ul><pre><code>/** * Gets the modules ordered by "class-loader priority".  This ensures that core modules (things  * in Framework/Features/Processors, etc) come before user modules (Extensions).  It also * guarantees a consistent module order from run to run. *  * @param layout The layout * @return the modules mapped by name, ordered by priority */private static Map&lt;String, GModule&gt; getOrderedModules(ApplicationLayout layout) {   Comparator&lt;GModule&gt; comparator = (module1, module2) -&gt; {      int nameComparison = module1.getName().compareTo(module2.getName());      // First handle modules that are external to the Ghidra installation.      // These should be put at the end of the list.      boolean external1 = ModuleUtilities.isExternalModule(module1, layout);      boolean external2 = ModuleUtilities.isExternalModule(module2, layout);      if (external1 &amp;&amp; external2) {         return nameComparison;      }      if (external1) {         return -1;      }      if (external2) {         return 1;      }      // Now handle modules that are internal to the Ghidra installation.      // We will primarily order them by "type" and secondarily by name.      Map&lt;String, Integer&gt; typePriorityMap = new HashMap&lt;&gt;();      typePriorityMap.put("Framework", 0);      typePriorityMap.put("Configurations", 1);      typePriorityMap.put("Features", 2);      typePriorityMap.put("Processors", 3);      typePriorityMap.put("GPL", 4);      typePriorityMap.put("Extensions", 5);      typePriorityMap.put("Test", 6);      String type1 = module1.getModuleRoot().getParentFile().getName();      String type2 = module2.getModuleRoot().getParentFile().getName();      int priority1 = typePriorityMap.getOrDefault(type1, typePriorityMap.size());      int priority2 = typePriorityMap.getOrDefault(type2, typePriorityMap.size());      if (priority1 != priority2) {         return Integer.compare(priority1, priority2);      }      return nameComparison;   };   List&lt;GModule&gt; moduleList = new ArrayList&lt;&gt;(layout.getModules().values());   Collections.sort(moduleList, comparator);   Map&lt;String, GModule&gt; moduleMap = new LinkedHashMap&lt;&gt;();   for (GModule module : moduleList) {      moduleMap.put(module.getName(), module);   }   return moduleMap;}</code></pre><h4 id="开发者模式与其他模式路径添加加载"><a href="#开发者模式与其他模式路径添加加载" class="headerlink" title="开发者模式与其他模式路径添加加载"></a>开发者模式与其他模式路径添加加载</h4><pre><code>if (SystemUtilities.isInDevelopmentMode()) {   addModuleBinPaths(classpathList, modules);   addExternalJarPaths(classpathList, layout.getApplicationRootDirs());}else {   addPatchPaths(classpathList, layout.getPatchDir());   addModuleJarPaths(classpathList, modules);}</code></pre><h4 id="需要加载的路径添加到Loader中"><a href="#需要加载的路径添加到Loader中" class="headerlink" title="需要加载的路径添加到Loader中"></a>需要加载的路径添加到Loader中</h4><pre><code>classpathList = orderClasspath(classpathList, modules);// Add the classpath to the class loaderclasspathList.forEach(entry -&gt; loader.addPath(entry));</code></pre><h4 id="GhidraLaunchable"><a href="#GhidraLaunchable" class="headerlink" title="GhidraLaunchable"></a>GhidraLaunchable</h4><pre><code>// Make sure the thing to launch is a GhidraLaunchableClass&lt;?&gt; cls = ClassLoader.getSystemClassLoader().loadClass(args[0]);if (!GhidraLaunchable.class.isAssignableFrom(cls)) {   throw new IllegalArgumentException(      "ERROR: \"" + args[0] + "\" is not a launchable class");}// Launch the target class, which is the first argument.  Strip off the first argument// and pass the rest through to the target class's launch method.GhidraLaunchable launchable = (GhidraLaunchable) cls.getConstructor().newInstance();launchable.launch(layout, Arrays.copyOfRange(args, 1, args.length));</code></pre><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><pre><code>package ghidra;import java.io.*;import java.util.*;import java.util.stream.Collectors;import generic.jar.ResourceFile;import ghidra.framework.GModule;import ghidra.util.SystemUtilities;import utility.application.ApplicationLayout;import utility.module.ModuleUtilities;/** * Class to build the Ghidra classpath, add it to the {@link GhidraClassLoader}, and start the  * desired {@link GhidraLaunchable} that's passed in as a command line argument. */public class GhidraLauncher {   /**    * Launches the given {@link GhidraLaunchable}, passing through the args to it.    *     * @param args The first argument is the name of the class to launch.  The remaining args    *     get passed through to the class's {@link GhidraLaunchable#launch} method.    * @throws Exception If there was a problem launching.  See the exception's message for more    *     details on what went wrong.      */   public static void main(String[] args) throws Exception {      // Make sure our class loader is being used      if (!(ClassLoader.getSystemClassLoader() instanceof GhidraClassLoader)) {         throw new ClassNotFoundException("ERROR: Ghidra class loader not in use.  " +            "Confirm JVM argument \"-Djava.system.class.loader argument=" +            GhidraClassLoader.class.getName() + "\" is set.");      }      // Get application layout      GhidraApplicationLayout layout = new GhidraApplicationLayout();      GhidraClassLoader loader = (GhidraClassLoader) ClassLoader.getSystemClassLoader();      // Build the classpath      List&lt;String&gt; classpathList = new ArrayList&lt;&gt;();      Map&lt;String, GModule&gt; modules = getOrderedModules(layout);      if (SystemUtilities.isInDevelopmentMode()) {         addModuleBinPaths(classpathList, modules);         addExternalJarPaths(classpathList, layout.getApplicationRootDirs());      }      else {         addPatchPaths(classpathList, layout.getPatchDir());         addModuleJarPaths(classpathList, modules);      }      classpathList = orderClasspath(classpathList, modules);      // Add the classpath to the class loader      classpathList.forEach(entry -&gt; loader.addPath(entry));      // Make sure the thing to launch is a GhidraLaunchable      Class&lt;?&gt; cls = ClassLoader.getSystemClassLoader().loadClass(args[0]);      if (!GhidraLaunchable.class.isAssignableFrom(cls)) {         throw new IllegalArgumentException(            "ERROR: \"" + args[0] + "\" is not a launchable class");      }      // Launch the target class, which is the first argument.  Strip off the first argument      // and pass the rest through to the target class's launch method.      GhidraLaunchable launchable = (GhidraLaunchable) cls.getConstructor().newInstance();      launchable.launch(layout, Arrays.copyOfRange(args, 1, args.length));   }   /**    * Add patch jars to the given path list.  This should be done first so they take precedence in     * the classpath.    *     * @param pathList The list of paths to add to    * @param patchDir The application installation directory; may be null    */   private static void addPatchPaths(List&lt;String&gt; pathList, ResourceFile patchDir) {      if (patchDir == null || !patchDir.exists()) {         return;      }      // this will allow for unbundled class files      pathList.add(patchDir.getAbsolutePath());      // this is each jar file, sorted for loading consistency      List&lt;String&gt; jars = findJarsInDir(patchDir);      Collections.sort(jars);      pathList.addAll(jars);   }   /**    * Add module bin directories to the given path list.    *     * @param pathList The list of paths to add to.    * @param modules The modules to get the bin directories of.    */   private static void addModuleBinPaths(List&lt;String&gt; pathList, Map&lt;String, GModule&gt; modules) {      Collection&lt;ResourceFile&gt; dirs = ModuleUtilities.getModuleBinDirectories(modules);      dirs.forEach(d -&gt; pathList.add(d.getAbsolutePath()));   }   /**    * Add module lib jars to the given path list.    *     * @param pathList The list of paths to add to.    * @param modules The modules to get the jars of.    */   private static void addModuleJarPaths(List&lt;String&gt; pathList, Map&lt;String, GModule&gt; modules) {      Collection&lt;ResourceFile&gt; dirs = ModuleUtilities.getModuleLibDirectories(modules);      dirs.forEach(d -&gt; pathList.addAll(findJarsInDir(d)));   }   /**    * Add external runtime lib jars to the given path list.  The external jars are discovered by    * parsing the build/libraryDependencies.txt file that results from a prepDev.    *     * @param pathList The list of paths to add to.    * @param appRootDirs The application root directories to search.    * @throws IOException if a required file or directory was not found.    */   private static void addExternalJarPaths(List&lt;String&gt; pathList,         Collection&lt;ResourceFile&gt; appRootDirs) throws IOException {      final String LIBDEPS = "build/libraryDependencies.txt";      // Get "libraryDependencies.txt" file      ResourceFile libraryDependenciesFile = null;      for (ResourceFile root : appRootDirs) {         if (libraryDependenciesFile == null) {            ResourceFile f = new ResourceFile(root.getParentFile(), LIBDEPS);            if (f.isFile()) {               libraryDependenciesFile = f;            }         }      }      // Make sure we found everything      if (libraryDependenciesFile == null) {         throw new FileNotFoundException(LIBDEPS + " file was not found!  Please do a prepDev.");      }      // Add the jars to the path list (don't add duplicates)      Set&lt;String&gt; pathSet = new HashSet&lt;&gt;();      try (BufferedReader reader =         new BufferedReader(new FileReader(libraryDependenciesFile.getFile(false)))) {         String line;         while ((line = reader.readLine()) != null) {            String path = line.trim();            if (!path.startsWith("Module:") &amp;&amp; path.endsWith(".jar")) {               ResourceFile jarFile = new ResourceFile(path);               if (!jarFile.isFile()) {                  System.err.println("Failed to find required jar file: " + jarFile);                  continue;               }               pathSet.add(jarFile.getAbsolutePath());            }         }      }      if (pathSet.isEmpty()) {         throw new IllegalStateException(            "Files listed in '" + LIBDEPS + "' are incorrect--rebuild this file");      }      pathList.addAll(pathSet);   }   /**    * Searches the given directory (non-recursively) for jars and returns their paths in a list.    *     * @param dir The directory to search for jars in.    * @return A list of discovered jar paths.    */   public static List&lt;String&gt; findJarsInDir(ResourceFile dir) {      List&lt;String&gt; list = new ArrayList&lt;&gt;();      ResourceFile[] names = dir.listFiles();      if (names != null) {         for (ResourceFile file : names) {            if (file.getName().endsWith(".jar")) {               list.add(file.getAbsolutePath());            }         }      }      return list;   }   /**    * Gets the modules ordered by "class-loader priority".  This ensures that core modules (things     * in Framework/Features/Processors, etc) come before user modules (Extensions).  It also    * guarantees a consistent module order from run to run.    *     * @param layout The layout    * @return the modules mapped by name, ordered by priority    */   private static Map&lt;String, GModule&gt; getOrderedModules(ApplicationLayout layout) {      Comparator&lt;GModule&gt; comparator = (module1, module2) -&gt; {         int nameComparison = module1.getName().compareTo(module2.getName());         // First handle modules that are external to the Ghidra installation.         // These should be put at the end of the list.         boolean external1 = ModuleUtilities.isExternalModule(module1, layout);         boolean external2 = ModuleUtilities.isExternalModule(module2, layout);         if (external1 &amp;&amp; external2) {            return nameComparison;         }         if (external1) {            return -1;         }         if (external2) {            return 1;         }         // Now handle modules that are internal to the Ghidra installation.         // We will primarily order them by "type" and secondarily by name.         Map&lt;String, Integer&gt; typePriorityMap = new HashMap&lt;&gt;();         typePriorityMap.put("Framework", 0);         typePriorityMap.put("Configurations", 1);         typePriorityMap.put("Features", 2);         typePriorityMap.put("Processors", 3);         typePriorityMap.put("GPL", 4);         typePriorityMap.put("Extensions", 5);         typePriorityMap.put("Test", 6);         String type1 = module1.getModuleRoot().getParentFile().getName();         String type2 = module2.getModuleRoot().getParentFile().getName();         int priority1 = typePriorityMap.getOrDefault(type1, typePriorityMap.size());         int priority2 = typePriorityMap.getOrDefault(type2, typePriorityMap.size());         if (priority1 != priority2) {            return Integer.compare(priority1, priority2);         }         return nameComparison;      };      List&lt;GModule&gt; moduleList = new ArrayList&lt;&gt;(layout.getModules().values());      Collections.sort(moduleList, comparator);      Map&lt;String, GModule&gt; moduleMap = new LinkedHashMap&lt;&gt;();      for (GModule module : moduleList) {         moduleMap.put(module.getName(), module);      }      return moduleMap;   }   /**    * Updates the list of paths to make sure the order is correct for any class-loading dependencies.    *      * @param pathList The list of paths to order.    * @param modules The modules on the classpath.    * @return A new list with the elements of the original list re-ordered as needed.    */   private static List&lt;String&gt; orderClasspath(List&lt;String&gt; pathList,         Map&lt;String, GModule&gt; modules) {      Set&lt;String&gt; fatJars = modules            .values()            .stream()            .flatMap(m -&gt; m.getFatJars().stream())            .collect(Collectors.toSet());      List&lt;String&gt; orderedList = new ArrayList&lt;&gt;(pathList);      for (String path : pathList) {         if (fatJars.contains(new File(path).getName())) {            orderedList.remove(path);            orderedList.add(path);         }      }      return orderedList;   }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Decompile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ghidra | GUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASM汇编详解</title>
      <link href="/posts/d18.html"/>
      <url>/posts/d18.html</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言简介"><a href="#汇编语言简介" class="headerlink" title="汇编语言简介"></a>汇编语言简介</h1><h2 id="学习汇编的常见问题"><a href="#学习汇编的常见问题" class="headerlink" title="学习汇编的常见问题"></a>学习汇编的常见问题</h2><h4 id="需要怎样的背景知识？"><a href="#需要怎样的背景知识？" class="headerlink" title="需要怎样的背景知识？"></a>需要怎样的背景知识？</h4><p>在学习本教程之前，至少使用过一种结构化高级语言进行编程，如 Java、C、Python 或 C++。需要了解如何使用 IF 语句、数组和函数来解决编程问题。</p><h4 id="什么是汇编器和链接器？"><a href="#什么是汇编器和链接器？" class="headerlink" title="什么是汇编器和链接器？"></a>什么是汇编器和链接器？</h4><p>汇编器（assembler）是一种工具程序，用于将汇编语言源程序转换为机器语言。链接器（linker）也是一种工具程序，它把汇编器生成的单个文件组合为一个可执行程序。还有一个相关的工具，称为调试器（debugger），使程序员可以在程序运行时，单步执行程序并检查寄存器和内存状态。</p><h4 id="需要哪些硬件和软件？"><a href="#需要哪些硬件和软件？" class="headerlink" title="需要哪些硬件和软件？"></a>需要哪些硬件和软件？</h4><p>一台运行 32 位或 64 位 Microsoft Windows 系统的计算机，并已安装了近期版本的 Microsoft Visual Studio。</p><h4 id="MASM-能创建哪些类型的程序？"><a href="#MASM-能创建哪些类型的程序？" class="headerlink" title="MASM 能创建哪些类型的程序？"></a>MASM 能创建哪些类型的程序？</h4><p>32 位保护模式（32-Bit Protected Mode）：32 位保护模式程序运行于所有的 32 位和 64 位版本的 Microsoft Windows 系统。它们通常比实模式程序更容易编写和理解。从现在开始，将其简称为 32 位模式。</p><p>64 位模式（64-Bit Mode）：64 位程序运行于所有的 64 位版本 Microsoft Windows 系统。</p><p>16 位实地址模式（16-Bit Real-Address Mode）：16 位程序运行于 32 位版本 Windows 和嵌入式系统。 64 位 Windows 不支持这类程序。</p><h4 id="汇编语言与机器语言有什么关系？"><a href="#汇编语言与机器语言有什么关系？" class="headerlink" title="汇编语言与机器语言有什么关系？"></a>汇编语言与机器语言有什么关系？</h4><p>机器语言（machine language）是一种数字语言， 专门设计成能被计算机处理器（CPU）理解。所有 x86 处理器都理解共同的机器语言。</p><p>汇编语言（assembly language）包含用短助记符如 ADD、MOV、SUB 和 CALL 书写的语句。汇编语言与机器语言是一对一（one-to-one）的关系：每一条汇编语言指令对应一条机器语言指令。</p><h4 id="C-和-Java-与汇编语言有什么关系？"><a href="#C-和-Java-与汇编语言有什么关系？" class="headerlink" title="C++ 和 Java 与汇编语言有什么关系？"></a>C++ 和 Java 与汇编语言有什么关系？</h4><p>高级语言如 Python、C++ 和 Java 与汇编语言和机器语言的关系是一对多（one-to-many）。比如，C++ 的一条语句就会扩展为多条汇编指令或机器指令。</p><p>大多数人无法阅读原始机器代码，因此，这里探讨的是与之最接近的汇编语言。例如，下面的 C++ 代码进行了两个算术操作，并将结果赋给一个变量。假设 X 和 Y 是 整数：</p><pre><code>int Y;int X = ( Y + 4 ) * 3;</code></pre><p>与之等价的汇编语言程序如下所示。这种转换需要多条语句，因为每条汇编语句只对应一条机器指令：</p><pre><code>mov eax,Y  ;Y 送入 EAX 寄存器add eax,4  ;EAX 寄存器内容加 4mov ebx,3  ;3 送入 EBX 寄存器imul ebx   ;EAX 与 EBX 相乘mov x,eax  ;EAX 的值送入 X</code></pre><p>寄存器（register）是 CPU 中被命名的存储位置，用于保存操作的中间结果。这个例子的重点不是说明 C++ 与汇编语言哪个更好，而是展示它们的关系。</p><h4 id="汇编语言可移植吗？"><a href="#汇编语言可移植吗？" class="headerlink" title="汇编语言可移植吗？"></a>汇编语言可移植吗？</h4><p>一种语言，如果它的源程序能够在各种各样的计算机系统中进行编译和运行，那么这种语言被称为是可移植的（portable）。</p><p>例如，一个 C++ 程序，除非需要特别引用某种操作系统的库函数，否则它就几乎可以在任何一台计算机上编译和运行。Java 语言的一大特点就是，其编译好的程序几乎能在所有计算机系统中运行。</p><p>汇编语言不是可移植的，因为它是为特定处理器系列设计的。目前广泛使用的有多种不同的汇编语言，每一种都基于一个处理器系列。</p><p>对于一些广为人知的处理器系列如 Motorola 68x00、x86、SUN Sparc、Vax 和 IBM-370，汇编语言指令会直接与该计算机体系结构相匹配，或者在执行时用一种被称为微代码解释器（microcode interpreter）的处理器内置程序来进行转换。</p><h4 id="为什么要学习汇编语言？"><a href="#为什么要学习汇编语言？" class="headerlink" title="为什么要学习汇编语言？"></a>为什么要学习汇编语言？</h4><p>如果对学习汇编语言还心存疑虑，考虑一下这些观点：</p><ul><li><p>如果是学习计算机工程，那么很可能会被要求写嵌入式（embedded）程序。嵌入式程序是指一些存放在专用设备中小容量存储器内的短程序，这些专用设备包括：电话、汽车燃油和点火系统、空调控制系统、安全系统、数据采集仪器、显卡、声卡、硬盘驱动器、调制解调器和打印机。由于汇编语言占用内存少，因此它是编写嵌入式程序的理想工具。</p></li><li><p>处理仿真和硬件监控的实时应用程序要求精确定时和响应。高级语言不会让程序员对编译器生成的机器代码进行精确控制。汇编语言则允许程序员精确指定程序的可执行代码。</p></li><li><p>电脑游戏要求软件在减少代码大小和加快执行速度方面进行高度优化。就针对一个目标系统编写能够充分利用其硬件特性的代码而言，游戏程序员都是专家。他们经常选择汇编语言作为工具，因为汇编语言允许直接访问计算机硬件，所以，为了提高速度可以对代码进行手工优化。</p></li><li><p>汇编语言有助于形成对计算机硬件、操作系统和应用程序之间交互的全面理解。使用汇编语言，可以运用并检验从计算机体系结构和操作系统课程中获得的理论知识。</p></li><li><p>一些高级语言对其数据表示进行了抽象，这使得它们在执行底层任务时显得有些不方便，如位控制。在这种情况下，程序员常常会调用使用汇编语言编写的子程序来完成他们的任务。</p></li><li><p>硬件制造商为其销售的设备创建设备驱动程序。设备驱动程序（device driver）是一种程序，它把通用操作系统指令转换为对硬件细节的具体引用。比如，打印机制造商就为他们销售的每一种型号都创建了一种不同的 MS-Windows 设备驱动程序。通常，这些设备驱动程序包含了大量的汇编语言代码。</p></li></ul><h4 id="汇编语言有规则吗？"><a href="#汇编语言有规则吗？" class="headerlink" title="汇编语言有规则吗？"></a>汇编语言有规则吗？</h4><p>大多数汇编语言规则都是以目标处理器及其机器语言的物理局限性为基础的。比如，CPU 要求两个指令操作数的大小相同。与C++ 或 Java 相比，汇编语言的规则较少，因为，前者是用语法规则来减少意外的逻辑错误，而这是以限制底层数据访问为代价的。</p><p>汇编语言程序员可以很容易地绕过高级语言的限制性特征。例如，Java 就不允许访问特定的内存地址。程序员可以使用 JNI（Java Native Interface）类来调用 C 函数绕过这个限制，可结果程序不容易维护。</p><p>反之，汇编语言可以访问所有的内存地址。但这种自由的代价也很高：汇编语言程序员需要花费大量的时间进行调试。</p><h2 id="汇编语言的应用（用途）"><a href="#汇编语言的应用（用途）" class="headerlink" title="汇编语言的应用（用途）"></a>汇编语言的应用（用途）</h2><p>早期在编程时，大多数应用程序部分或全部用汇编语言编写。它们不得不适应小内存，并尽可能在慢速处理器上有效运行。随着内存容量越来越大，以及处理器速度急速提高，程序变得越来越复杂。</p><p>程序员也转向高级语言如 C语言、FORTRAN COBOL，这些语言具有很多结构化能力。最近，Python、C++、C# 和 Java 等面向对象语言已经能够编写含数百万行代码的复杂程序了。</p><p>很少能看到完全用汇编语言编写的大型应用程序，因为它们需要花费大量的时间进行编写和维护。不过，汇编语言可以用于优化应用程序的部分代码来提升速度，或用于访问计算机硬件。</p><p>下表比较了汇编语言和高级语言对各种应用类型的适应性。</p><table><thead><tr><th>应用类型</th><th>高级语言</th><th>汇编语言</th></tr></thead><tbody><tr><td>商业或科学应用程序，为单一的中型或大型平台编写</td><td>规范结构使其易于组织和维护大量代码</td><td>最小规范结构，因此必须由具有不同程度经验的程序员来维护结构。这导致对已有代码的维护困难</td></tr><tr><td>硬件设备驱动程序</td><td>语言不一定提供对硬件的直接访问。 即使提供了，可能也需要难以控制的编码技术，这导致维护困难</td><td>对硬件的访问直接且简单。当程序较短且文档良好时易于维护</td></tr><tr><td>为多个平台（不同的操作系统）编写的商业或科学应用程序</td><td>通常可移植。在每个目标操作系统上， 源程序只做少量修改就能重新编译</td><td>需要为每个平台单独重新编写代码， 每个汇编器都使用不同的语法。维护困难</td></tr><tr><td>需要直接访问硬件的嵌入式系统和电脑游戏</td><td>可能生成很大的可执行文件，以至于超出设备的内存容量</td><td>理想，因为可执行代码小，运行速度快</td></tr></tbody></table><p>C 和 C++ 语言具有一个独特的特性，能够在高级结构和底层细节之间进行平衡。直接访问硬件是可能的，但是完全不可移植。大多数 C 和 C++ 编译器都允许在其代码中嵌入汇编语句，以提供对硬件细节的访问。</p><h2 id="虚拟机是什么？"><a href="#虚拟机是什么？" class="headerlink" title="虚拟机是什么？"></a>虚拟机是什么？</h2><p>虚拟机概念（virtual machine machine）是一种说明计算机硬件和软件关系的有效方法。</p><p>在安德鲁 · 塔嫩鲍姆（Andrew Tanenbaum）的书《结构化计算机组织》（Structured Computer Organization）中可以找到对这个模型广为人知的解释。要说明这个概念，先从计算机的最基本功能开始，即执行程序。</p><p>计算机通常可以执行用其原生机器语言编写的程序。这种语言中的每一条指令都简单到可以用相对少量的电子电路来执行。为了简便，称这种语言为 L0。</p><p>由于 L0 极其详细，并且只由数字组成，因此，程序员用其编写程序就非常困难。如果能够构造一种较易使用的新语言 L1，那么就可以用 L1 编写程序。有两种实现方法：</p><ul><li><p>解释（Interpretation）：运行 L1 程序时，它的每一条指令都由一个用 L0 语言编写的程序进行译码和执行。L1 程序可以立即开始运行，但是在执行之前，必须对每条指令进行译码。</p></li><li><p>翻译（Translation）：由一个专门设计的 L0 程序将整个 L1 程序转换为 L0 程序。然后，得到的 L0 程序就可以直接在计算机硬件上执行。</p></li></ul><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>与只使用语言描述相比，把每一层都想象成有一台假设的计算机或者虚拟机会更容易一些。通俗地说，虚拟机可以定义为一个软件程序，用来模拟一些其他的物理或虚拟计算机的功能。</p><p>虚拟机，将其称为 VM1，可以执行 L1 语言编写的指令。虚拟机 VM0 可以执行 L0 语言编写的指令：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-16272219001411" alt="img"></p><p>每一个虚拟机既可以用硬件构成也可以用软件构成。程序员可以为虚拟机 VM1 编写程序，如果能把 VM1 当作真实计算机予以实现，那么，程序就能直接在这个硬件上执行。否则，用 VM1 写出的程序就被翻译 / 解释为 VM0 程序，并在机器 VM0 上执行。</p><p>机器 VM1 与 VM0 之间的差异不能太大，否则，翻译或解释花费的时间就会非常多。如果 VM1 语言对程序员来说还不够友好到足以用于应用程序的开发呢？</p><p>可以为此设计另一个更加易于理解的虚拟机 VM2。这个过程能够不断重复，直到虚拟机 VMn 足够支持功能强大、使用方便的语言。</p><p>Java 编程语言就是以虚拟机概念为基础的。Java 编译器把用 Java 语言编写的程序翻译为 Java 字节码（Java byte code）。</p><p>后者是一种低级语言，能够在运行时由 Java 虚拟机（JVM）程序快速执行。JVM 已经在许多不同的计算机系统上实现了，这使得 Java 程序相对而言独立于系统。</p><h3 id="特定的机器"><a href="#特定的机器" class="headerlink" title="特定的机器"></a>特定的机器</h3><p>与实际机器和语言相对，用 Level 2 表示 VM2，Level 1 表示 VM1，如下图所示。计算机数字逻辑硬件表示为 Level 1 机器。其上是 Level 2，称为指令集架构（ISA, Instruction Set Architecture） 。通常，这是用户可以编程的第一个层次，尽管这种程序包含的是被称为机器语言的二进制数值。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-16272219537003" alt="img"></p><p>指令集架构（Level 2）计算机芯片制造商在处理器内部设计一个指令集来实现基本操作，如传送、加法或乘法。这个指令集也被称为机器语言。每一个机器语言指令或者直接在机器硬件上执行，或者由嵌入到微处理器芯片的程序来执行，该程序被称为微程序。</p><p>汇编语言（Level 3）在 ISA 层，编程语言提供了一个翻译层，来实践大规模软件开发。汇编语言出现在 Level 3，使用短助记符，如 ADD、SUB 和 MOV，易于转换到 ISA 层。汇编语言程序在执行之前要全部翻译（汇编）为机器语言。</p><p>高级语言（Level 4）Level 4 是高级编程语言，如 C、C++ 和 Java。这些语言程序所包含的语句功能强大，并翻译为多条汇编语言指令。比如，查看 C++ 编译器生成的列表文件输出，就可以看到这样的翻译。汇编语言代码由编译器自动汇编为机器语言。</p><h2 id="汇编语言的数据表示"><a href="#汇编语言的数据表示" class="headerlink" title="汇编语言的数据表示"></a>汇编语言的数据表示</h2><p>汇编语言程序员处理的是物理级数据，因此他们必须善于检查内存和寄存器。通常，二进制数被用于描述计算机内存的内容；有时也使用十进制和十六进制数。所以必须熟练掌握数字格式，以便快速地进行数字的格式转换。</p><p>每一种数制格式或系统，都有一个基数（base），也就是可以分配给单一数字的最大符号数。下表给出了数制系统内可能的数字，这些系统是硬件和软件手册中最常使用的。</p><table><thead><tr><th>系统</th><th>基数</th><th>可能的数字</th></tr></thead><tbody><tr><td>二进制</td><td>2</td><td>1</td></tr><tr><td>八进制</td><td>8</td><td>1234567</td></tr><tr><td>十进制</td><td>10</td><td>123456789</td></tr><tr><td>十六进制</td><td>16</td><td>0123456789ABCDEF</td></tr></tbody></table><p>在表的最后一行，十六进制使用的是数字 0 到 9，然后字母 A 到 F 表示十进制数 10 到 15。在展示计算机内存的内容和机器级指令时，使用十六进制是相当常见的。</p><h2 id="二进制（bit）整数"><a href="#二进制（bit）整数" class="headerlink" title="二进制（bit）整数"></a>二进制（bit）整数</h2><p>计算机以电子电荷集合的形式在内存中保存指令和数据。用数字来表示这些内容就需要系统能够适应开 / 关（on/off）或真 / 假（true/false）的概念。二进制数（binary number）用 2 个数字作基础，其中每一个二进制数字（称为位，bit）不是 0 就是 1。</p><p>位自右向左，从 0 开始顺序增量编号。左边的位称为最高有效位（Most Significant Bit, MSB）右边的位称为最低有效位（LSB, least significant bit）。一个 16 位的二进制数，其 MSB 和 LSB 如下图所示：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-16272220126975" alt="img"></p><p>二进制整数可以是有符号的，也可以是无符号的。有符号整数又分为正数和负数，无符号整数默认为正数，零也被看作是正数。</p><p>在书写较大的二进制数时，有些人喜欢每 4 位或 8 位插入一个点号，以增加数字的易读性。比如，1101.1110.0011.1000.0000 和 11001010.10101100</p><h3 id="无符号二进制整数"><a href="#无符号二进制整数" class="headerlink" title="无符号二进制整数"></a>无符号二进制整数</h3><p>从 LSB 开始，无符号二进制整数中的每一个位代表的是 2 的加 1 次幂。下图展示的是对一个 8 位的二进制数来说，2 的幂是如何从右到左增加的：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-16272221594749" alt="img"></p><p>下表列出了从 20 到 215 的十进制值。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722218147911" alt="img"></p><h3 id="无符号二进制整数到十进制数的转换"><a href="#无符号二进制整数到十进制数的转换" class="headerlink" title="无符号二进制整数到十进制数的转换"></a>无符号二进制整数到十进制数的转换</h3><p>对于一个包含 n 个数字的无符号二进制整数来说，加权位记数法（weighted positional notation）提供了一种简便的方法来计算其十进制值：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722222134213" alt="img"></p><p>D 表示一个二进制数字。比如，二进制数 00001001 就等于 9。计算该值时，剔除了数字等于 0 的位：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722223019115" alt="img"></p><p>下图表示了同样的计算过程：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722223913617" alt="img"></p><h3 id="无符号十进制整数到二进制数的转换"><a href="#无符号十进制整数到二进制数的转换" class="headerlink" title="无符号十进制整数到二进制数的转换"></a>无符号十进制整数到二进制数的转换</h3><p>将无符号十进制整数转换为二进制，方法是不断将这个整数除以 2，并将每个余数记录为一个二进制数字。下表展示的是十进制数 37 转换为二进制数的步骤。余数的数字，从第二行开始，分别表示的是二进制数字D0</p><p>D1、D2、D3、D4 和 D5：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722227976919" alt="img"></p><p>将表中余数列的二进制位逆序连接（D5，D4，…），就得到了该整数的二进制值 100101。由于计算机总是按照 8 的倍数来组织二进制数字，因此在该二进制数的左边增加两个 0，形成 00100101。</p><p>提示：有多少位呢？设无符号十进制值为 n，其对应的二进制数的位数为 b，用一个简单的公式就可以计算出 b : b = (log2n) 的上限。比如，如果 n=17，则 log217 = 4.087 463，取其上限的最小整数 5。大多数计数器没有以 2 为底的对数运算，但是有些网页可以帮助实现这种计算。</p><h2 id="二进制加法运算"><a href="#二进制加法运算" class="headerlink" title="二进制加法运算"></a>二进制加法运算</h2><p>两个二进制整数相加时，是位对位处理的，从最低的一对位（右边）开始，依序将每一对位进行加法运算。两个二进制数字相加，有四种结果，如下所示：</p><table><thead><tr><th>0 + 0 = 0</th><th>0 + 1 = 1</th></tr></thead><tbody><tr><td>1 + 0 = 1</td><td>1 + 1 = 10</td></tr></tbody></table><p>1 与 1 相加的结果是二进制的 10（等于十进制的 2）。多出来的数字向更高位产生一个进位。如下图所示，两个二进制数 0000 0100 和 0000 0111 相加：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722229549021" alt="img"></p><p>从两个数的最低位（位 0）开始，计算 0+1，得到底行对应位上的 1。然后计算次低位（位 1）。在位 2 上，计算 1+1，结果是 0，并产生一个进位 1。然后计算位 3，0+0，还要加上位 2 的进位，结果是 1。</p><p>其余的位都是 0。上图右边是等价的十进制数值加法（4 + 7 = 11），可以用于验证左边的二进制加法。</p><p>有些情况下，最高有效位会产生进位。这时，预留存储区的大小就显得很重要。比如，如果计算 1111 1111 加 0000 0001，就会在最高有效位之外产生一个 1，而和数的低 8 位则为全 0。</p><p>如果和数的存储大小最少有 9 位，那么就可以将和数表示为 1 0000 0000。但是，如果和数只能保存 8 位，那么它就等于 0000 0000，也就是计算结果的低 8 位。</p><h2 id="字节（byte）简介"><a href="#字节（byte）简介" class="headerlink" title="字节（byte）简介"></a>字节（byte）简介</h2><p>在 x86 计算机中，所有数据存储的基本单位都是字节（byte），一个字节有 8 位。其他的存储单位还有字（word）（2 个字节），双字（doubleword）（4 个字节）和四字（quadword）（8 个字节）。</p><p>下图展示了每个存储单位所包含的位的个数：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722230924923" alt="img"></p><p>下表列出了所有无符号整数可能的取值范围。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722232780327" alt="img"></p><p>大的度量单位对内存和磁盘空间而言，还可以使用大的度量单位：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722232270025" alt="img"></p><h2 id="十六进制整数"><a href="#十六进制整数" class="headerlink" title="十六进制整数"></a>十六进制整数</h2><p>大的二进制数读起来很麻烦，因此十六进制数字就提供了一种简便的方式来表示二进制数据。十六进制整数中的 1 个数字就表示了 4 位二进制位，两个十六进制数字就能表示一个字节。</p><p>一个十六进制数字表示的范围是十进制数 0 到 15，所以，用字母 A 到 F 来代表十进制数 10 到 15。</p><p> 下表列出了每个 4 位二进制序列如何转换为十进制和十六进制数值。</p><table><thead><tr><th>二进制</th><th>十进制</th><th>十六进制</th><th>二进制</th><th>十进制</th><th>十六进制</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>1000</td><td>8</td><td>8</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1001</td><td>9</td><td>9</td></tr><tr><td>10</td><td>2</td><td>2</td><td>1010</td><td>10</td><td>A</td></tr><tr><td>11</td><td>3</td><td>3</td><td>1011</td><td>11</td><td>B</td></tr><tr><td>100</td><td>4</td><td>4</td><td>1100</td><td>12</td><td>C</td></tr><tr><td>101</td><td>5</td><td>5</td><td>1101</td><td>13</td><td>D</td></tr><tr><td>110</td><td>6</td><td>6</td><td>1110</td><td>14</td><td>E</td></tr><tr><td>111</td><td>7</td><td>7</td><td>1111</td><td>15</td><td>F</td></tr></tbody></table><p>下面的例子说明了二进制数 0001 0110 1010 0111 1001 0100 是如何与十六进制数 16A794 等价的。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722234243629" alt="img"></p><h3 id="无符号十六进制数到十进制的转换"><a href="#无符号十六进制数到十进制的转换" class="headerlink" title="无符号十六进制数到十进制的转换"></a>无符号十六进制数到十进制的转换</h3><p>十六进制数中，每一个数字位都代表了 16 的幂。这有助于计算一个十六进制整数的十进制值。假设用下标来对一个包含 4 个数字的十六进制数编号 D3D2D1D0。</p><p>下式计算了这个 整数的十进制值：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722268617931" alt="img"></p><p>这个表达式可以推广到任意n位数的十六进制整数：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722269570233" alt="img"></p><p>一般情况下，可以通过公式把基数为B的任何n位整数转换为十进制数：</p><p>下图演示了第二个数转换的计算过程:</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722270366535" alt="img"></p><p>下表列出了 16 的幂从160 到167 的十进制数值。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722272650237" alt="img"></p><h3 id="无符号十进制数到十六进制的转换"><a href="#无符号十进制数到十六进制的转换" class="headerlink" title="无符号十进制数到十六进制的转换"></a>无符号十进制数到十六进制的转换</h3><p>无符号十进制整数转换到十六进制数的过程是，把这个十进制数反复除以16，每次取余数作为一个十六进制数字。例如，下表列出了十进制数 422 转换为十六进制的步骤：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722275404039" alt="img"></p><p>表中，余数列的数字按照最后一行到第一行的顺序，组合为十六进制的结果。因此本例中，十六进制结果就表示为1A6。同样的算法也适用于《二进制整数》一节中的二进制整数。如果要将十进制数转换为其他进制数，就在计算时把除数（16）换成相应的基数。</p><h2 id="补码及进制转换"><a href="#补码及进制转换" class="headerlink" title="补码及进制转换"></a>补码及进制转换</h2><p>有符号二进制整数有正数和负数。在 x86 处理器中，MSB 表示的是符号位：0 表示正数，1 表示负数。下图展示了 8 位的正数和负数：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722277900841" alt="img"></p><h3 id="补码表示"><a href="#补码表示" class="headerlink" title="补码表示"></a>补码表示</h3><p>负整数用补码（two`s-complement）表示时，使用的数学原理是：一个整数的补码是其加法逆元。（如果将一个数与其加法逆元相加，结果为 0。）</p><p>补码表示法对处理器设计者来说很有用，因为有了它就不需要用两套独立的电路来处理加法和减法。例如，如果表达式为 A-B，则处理器就可以很方便地将其转换为加法表达式：A+(-B)。</p><p>将一个二进制整数按位取反（求补）再加 1，就形成了它的补码。以 8 位二进制数 0000 0001 为例，求其补码为 1111 1111，过程如下所示：</p><table><thead><tr><th>初始值</th><th>1</th></tr></thead><tbody><tr><td>第一步：按位取反</td><td>11111110</td></tr><tr><td>第二步：将上一步得到的结果加 1</td><td>11111110 +00000001</td></tr><tr><td>和值：补码表示</td><td>11111111</td></tr></tbody></table><p>1111 1111 是 -1 的补码。补码操作是可逆的，因此，11111111 的补码就是 0000 0001。</p><h4 id="十六进制数的补码"><a href="#十六进制数的补码" class="headerlink" title="十六进制数的补码"></a>十六进制数的补码</h4><p>将一个十六进制整数按位取反并加 1，就生成了它的补码。一个简单的十六进制数字取反方法就是用 15 减去该数字。下面是一些十六进制数求补码的例子：</p><p>6A3D –&gt; 95C2 + 1 –&gt; 95C3</p><p>95C3 –&gt; 6A3C + 1 –&gt; 6A3D</p><h4 id="有符号二进制数到十进制的转换"><a href="#有符号二进制数到十进制的转换" class="headerlink" title="有符号二进制数到十进制的转换"></a>有符号二进制数到十进制的转换</h4><p>用下面的算法计算一个有符号二进制整数的十进制数值：</p><ul><li><p>如果最高位是 1，则该数是补码。再次对其求补，得到其正数值。然后把这个数值看作是一个无符号二进制整数，并求它的十进制数值。</p></li><li><p>如果最高位是 0，就将其视为无符号二进制整数，并转换为十进制数。</p></li></ul><p>例如，有符号二进制数 1111 0000 的最高有效位是 1，这意味着它是一个负数，首先要求它的补码，然后再将结果转换为十进制。过程如下所示：</p><table><thead><tr><th>初始值</th><th>11110000</th></tr></thead><tbody><tr><td>第一步：按位取反</td><td>1111</td></tr><tr><td>第二步：将上一步得到的结果加 1</td><td>00001111 + 1</td></tr><tr><td>第三步：生成补码</td><td>10000</td></tr><tr><td>第四步：转换为十进制</td><td>16</td></tr></tbody></table><p>由于初始值（1111 0000）是负数，因此其十进制数值为 -16。</p><h4 id="有符号十进制数到二进制的转换"><a href="#有符号十进制数到二进制的转换" class="headerlink" title="有符号十进制数到二进制的转换"></a>有符号十进制数到二进制的转换</h4><p>有符号十进制整数转换为二进制的步骤如下：</p><ul><li><p>把十进制整数的绝对值转换为二进制数。</p></li><li><p>如果初始十进制数是负数，则在第 1 步的基础上，求该二进制数的补码。</p></li></ul><p>比如，十进制数 -43 转换为二进制的过程为：</p><p>\1) 无符号数 43 的二进制表示为 0010 1011。</p><p>\2) 由于初始数值是负数，因此，求出 0010 1011 的补码 1101 0101 这就是十进制数 -43 的二进制表示。</p><h4 id="有符号十进制数到十六进制的转换"><a href="#有符号十进制数到十六进制的转换" class="headerlink" title="有符号十进制数到十六进制的转换"></a>有符号十进制数到十六进制的转换</h4><p>有符号十进制整数转换为十六进制的步骤如下：</p><ul><li><p>把十进制整数的绝对值转换为十六进制数。</p></li><li><p>如果初始十进制数是负数，则在第 1 步的基础上，求该十六进制数的补码。</p></li></ul><h4 id="有符号十六进制数到十进制的转换"><a href="#有符号十六进制数到十进制的转换" class="headerlink" title="有符号十六进制数到十进制的转换"></a>有符号十六进制数到十进制的转换</h4><p>有符号十六进制整数转换为十进制的步骤如下：</p><ul><li><p>如果十六进制整数是负数，求其补码，否则保持该数不变。</p></li><li><p>把第 1 步得到的整数转换为十进制。如果初始值是负数，则在该十进制整数的前面加负号。</p></li></ul><p>通过检查十六进制数的最高有效（最高）位，就可以知道该数是正数还是负数。如果最高位 ≥ 8，该数是负数；如果最高位 ≤ 7，该数是正数。比如，十六进制数 8A20 是负数，而 7FD9 是正数。</p><h3 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h3><p>n 位有符号整数只用 n-1 来表示该数的范围。下表列出了有符号单字节、字、双字、四字和八字的最大值与最小值。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722280605643" alt="img"></p><h2 id="二进制减法运算"><a href="#二进制减法运算" class="headerlink" title="二进制减法运算"></a>二进制减法运算</h2><p>如果采用与十进制减法相同的方法，那么从一个较大的二进制数中减去一个较小的无符号二进制数就很容易了。示例如下：</p><blockquote><p>  01101   （十进制数 13）</p></blockquote><blockquote><p>-  00111   （十进制数 7）</p></blockquote><blockquote><p>-———</p></blockquote><p>位 0 上的减法非常简单：</p><blockquote><p>   01101</p></blockquote><blockquote><p>-   00111</p></blockquote><blockquote><p>-———</p></blockquote><blockquote><pre><code>       0</code></pre></blockquote><p>下一个位置上执行（0-1），要向左边的相邻位借1，其结果是从 2 中减去 1：</p><blockquote><p>   01001</p></blockquote><blockquote><p>-   00111</p></blockquote><blockquote><p>-———</p></blockquote><blockquote><pre><code>     10</code></pre></blockquote><p>再下一位上，又要向左边的相邻位借一位，并从 2 中减去 1：</p><blockquote><p>   00011</p></blockquote><blockquote><p>-   00111</p></blockquote><blockquote><p>-———</p></blockquote><blockquote><pre><code>   110</code></pre></blockquote><p>最后，最高两位都执行的是零减去零:</p><blockquote><p>   00011</p></blockquote><blockquote><p>-   00111</p></blockquote><blockquote><p>-———</p></blockquote><blockquote><p>   00110           （十进制数 6）</p></blockquote><p>执行二进制减法还有更简单的方法，即将被减去数的符号位取反，然后将两数相加。这个方法要求用一个额外的位来保存数的符号。</p><p>现在以刚才计算的（01101-00111）为例来试一下这个方法。首先，将 00111 按位取反 11000 加 1，得到 11001。然后，把两个二进制数值相加，并忽略最高位的进位：</p><blockquote><p>01101   (+13)</p></blockquote><blockquote><p>11001   (-7)</p></blockquote><blockquote><p>-——</p></blockquote><blockquote><p>00110   (+6)</p></blockquote><p>结果正是我们预期的 +6。</p><h2 id="字符在计算机中是如何表示的？"><a href="#字符在计算机中是如何表示的？" class="headerlink" title="字符在计算机中是如何表示的？"></a>字符在计算机中是如何表示的？</h2><p>如果计算机只存储二进制数据，那么它如何表示字符呢？计算机使用的是字符集，将字符映射为整数。早期，字符集只用 8 位表示。即使是现在，在字符模式（如 MS-DOS）下运行时，IBM 兼容微机使用的还是 ASCII（读为“askey”）字符集。</p><p>ASCII 是美国标准信息交换码（AmeTican Standard Code for Information Interchange）的首字母缩写。在 ASCII 中，每个字符都被分配了一个独一无二的 7 位整数。</p><p>由于 ASCII 只用字节中的低 7 位，因此最高位在不同计算机上被用于创建其专有字符集。比如，IBM 兼容微机就用数值 128〜255 来表示图形符号和希腊字符。</p><h3 id="ANSI-字符集"><a href="#ANSI-字符集" class="headerlink" title="ANSI 字符集"></a>ANSI 字符集</h3><p>美国国家标准协会（ANSI）定义了 8 位字符集来表示多达 256 个字符。前 128 个字符对应标准美国键盘上的字母和符号。后 128 个字符表示特殊字符，诸如国际字母表、重音符号、货币符号和分数。</p><p>Microsoft Windows 早期版本使用 ANSI 字符集。</p><h3 id="Unicode-标准"><a href="#Unicode-标准" class="headerlink" title="Unicode 标准"></a>Unicode 标准</h3><p>当前，计算机必须能表示计算机软件中世界上各种各样的语言。因此，Unicode 被创建出来，用于提供一种定义文字和符号的通用方法。</p><p>Unicode 定义了数字代码（称为代码点（code point）），定义的对象为文字、符号以及所有主要语言中使用的标点符号，包括欧洲字母文字、中东的从右到左书写的文字和很多亚洲文字。代码点转换为可显示字符的格式有三种：</p><ul><li><p>UTF-8 用于 HTML，与 ASCII 有相同的字节数值。</p></li><li><p>UTF-16 用于节约使用内存与高效访问字符相互平衡的环境中。比如，Microsoft Windows 近期版本使用了 UTF-16，其中的每个字符都有一个 16 位的编码。</p></li><li><p>UTF-32 用于不考虑空间，但需要固定宽度字符的环境中。每个字符都有一个 32 位的编码。</p></li></ul><h3 id="ASCII-字符串"><a href="#ASCII-字符串" class="headerlink" title="ASCII 字符串"></a>ASCII 字符串</h3><p>有一个或多个字符的序列被称为字符串（string）。更具体地说，一个 ASCII 字符串是保存在内存中的，包含了 ASCII 代码的连续字节。比如，字符串“ABC123”的数字代码是 41h、42h、43h、31h、32h 和 33h。</p><p>以空字节结束（null-terminated）的字符串是指，在字符串的结尾处有一个为 0 的字节。C 和 C++ 语言使用的是以空字节结束的字符串，一些 Windows 操作系统函数也要求字符串使用这种格式。</p><h3 id="使用-ASCII-表"><a href="#使用-ASCII-表" class="headerlink" title="使用 ASCII 表"></a>使用 ASCII 表</h3><p>下图中列出了在 Windows 控制台模式下运行时使用的 ASCII 码。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722287278845" alt="img"></p><p>在查找字符的十六进制 ASCII 码时，先沿着表格最上面一行，再找到包含要转换字符的列即可。表格第二行是该十六进制数值的最高位；左起第二列是最低位。</p><p>例如，要查找字母 a 的 ASCII 码，先找到包含该字母的列，在这一列第二行中找到第一个十六进制数字 6。然后，找到包含 a 的行的左起第二列，其数字为 1。因此，a 的 ASCII 码是十六进制数 61。</p><p>下图用简单的形式说明了这个过程：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722289801247" alt="img"></p><h3 id="ASCII-控制字符"><a href="#ASCII-控制字符" class="headerlink" title="ASCII 控制字符"></a>ASCII 控制字符</h3><p>0〜31 的字符代码被称为 ASCII 控制字符。若程序用这些代码编写标准输出（比如 C++ 中），控制字符就会执行预先定义的动作。下表列出了该范围内最常用的字符。</p><table><thead><tr><th>ASCII码（十进制）</th><th>说明</th><th>ASCII码（十进制）</th><th>说明</th></tr></thead><tbody><tr><td>8</td><td>回退符（向左移动一列）</td><td>12</td><td>换页符（移动到下一个打印页）</td></tr><tr><td>9</td><td>水平制表符（向前跳过 n 列）</td><td>13</td><td>回车符（移动到最左边的输出列）</td></tr><tr><td>10</td><td>换行符（移动到下一个输出行）</td><td>27</td><td>换码符</td></tr></tbody></table><h3 id="数字数据表示术语"><a href="#数字数据表示术语" class="headerlink" title="数字数据表示术语"></a>数字数据表示术语</h3><p>用精确的术语描述内存中和显示屏上的数字及字符是非常重要的。比如，在内存中用单字节保存十进制数 65，形式为 0100 0001。调试程序可能会将该字节显示为“41”，这个数字的十六进制形式。</p><p>如果这个字节复制到显存中，则显示屏上可能显示字母“A”，因为在 ASCII 码中，0100 0001 代表的是字母 A。由于数字的解释可以依赖于它的上下文，因此，下面为每个数据表示类型分配一个特定的名称，以便将来的讨论更加清晰：</p><p>二进制整数是指，以其原始格式保存在内存中的整数，以备用于计算。二进制整数保存形式为 8 位的倍数（如 8、16、32 或 64）。</p><p>数字字符串是一串 ASCII 字符，例如“123”或“65”。这是一种简单的数字表示法，下表以十进制数 65 为例，列出了这种表示法能使用的各种形式。</p><table><thead><tr><th>格式</th><th>数值</th><th>格式</th><th>数值</th></tr></thead><tbody><tr><td>二进制数字字符串</td><td>“01000001”</td><td>十六进制数字字符串</td><td>“41”</td></tr><tr><td>十进制数字字符串</td><td>“65”</td><td>八进制数字字符串</td><td>“101”</td></tr></tbody></table><h2 id="汇编语言布尔表达式（NOT、AND、OR）"><a href="#汇编语言布尔表达式（NOT、AND、OR）" class="headerlink" title="汇编语言布尔表达式（NOT、AND、OR）"></a>汇编语言布尔表达式（NOT、AND、OR）</h2><p>布尔代数（boolean algebra）定义了一组操作，其值为真（true）或假（false）。它的发明者是十九世纪中叶的数学家乔治・布尔（George Boole）。</p><p>在数字计算机发明的早期，人们发现布尔代数可以用来描述数字电路的设计。同时，在计算机程序中，布尔表达式被用来表示逻辑操作。</p><p>一个布尔表达式（boolean expression）包括一个布尔运算符以及一个或多个操作数。每个布尔表达式都意味着一个为真或假的值。以下为运算符集合：</p><ul><li><p>非（NOT）：标记为 ¬ 或 ~ 或 ‘</p></li><li><p>与（AND）：标记为^或 ·</p></li><li><p>或（OR）：标记为 ∨ 或 +</p></li></ul><p>NOT 是一元运算符，其他运算符都是二元的。布尔表达式的操作数也可以是布尔表达式。示例如下：</p><table><thead><tr><th>达式</th><th>说明</th><th>表达式</th><th>说明</th></tr></thead><tbody><tr><td>¬X</td><td>NOT X</td><td>¬X∨Y</td><td>(NOT X) OR Y</td></tr><tr><td>X^Y</td><td>X AND Y</td><td>¬(X^Y)</td><td>NOT (X AND Y)</td></tr><tr><td>X∨Y</td><td>X OR Y</td><td>X^¬Y</td><td>X AND (NOT Y)</td></tr></tbody></table><h3 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h3><p>NOT 运算符将布尔值取反。用数学符号书写为 ¬X，其中，X 是一个变量（或表达式），其值为真（T）或假（F）。下表列出了对变量 X 进行 NOT 运算后所有可能的输岀。 左边为输入，右边（阴影部分）为输出：</p><table><thead><tr><th>X</th><th>¬X</th></tr></thead><tbody><tr><td>F</td><td>T</td></tr><tr><td>T</td><td>F</td></tr></tbody></table><p>真值表中，0 表示假，1 表示真。</p><h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><p>布尔运算符 AND 需要两个操作数，用符号表示为 X ^ Y。下表列出了对变量 X 和 Y 进行 AND 运算后，所有可能的输出（阴影部分）：</p><table><thead><tr><th>X</th><th>Y</th><th>X^Y</th></tr></thead><tbody><tr><td>F</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>F</td></tr><tr><td>T</td><td>F</td><td>F</td></tr><tr><td>T</td><td>T</td><td>T</td></tr></tbody></table><p>当两个输入都是真时，输出才为真。这与 C++ 和 Java 的复合布尔表达式中的逻辑 AND 是相对应的。</p><p>汇编语言中 AND 运算符是按位操作的。如下例所示，X 中的每一位都与 Y 中的相应位进行 AND 运算：</p><p>X :    11111111</p><p>Y :    00011100</p><p>X ^ Y : 00011100</p><p>如下图所示，结果值 0001 1100 中的每一位表示的是 X 和 Y 相应位的 AND 运算结果。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722292045249" alt="img"></p><h3 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h3><p>布尔运算符 OR 需要两个操作数，用符号表示为 X∨Y。下表列出了对变量 X 和 Y 进行 OR 运算后，所有可能的输出：</p><table><thead><tr><th>X</th><th>Y</th><th>X∨Y</th></tr></thead><tbody><tr><td>F</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>T</td></tr><tr><td>T</td><td>T</td><td>T</td></tr></tbody></table><p>当两个输入都是假时，输出才为假。这个真值表与 C++ 和 Java 的复合布尔表达式中的逻辑 OR 对应。</p><p>OR 运算符也是按位操作。在下例中，X 的每一位与 Y 的对应位进行 OR 运算，结果为 1111 1100：</p><p>X :   11101100</p><p>Y :   00011100</p><p>X∨Y : 11111100</p><p>如下图所示，每一位都独立进行 OR 运算，生成结果中的对应位。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722296890351" alt="img"></p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>运算符优先级原则（operator precedence rule）用于指示在多运算符表达式中，先执行哪个运算。在包含多运算符的布尔表达式中，优先级是非常重要的。</p><p>如下表所示，NOT 运算符具有最高优先级，然后是 AND 和 OR 运算符。可以使用括号来强制指定表达式的求值顺序：</p><table><thead><tr><th>表达式</th><th>运算符顺序</th></tr></thead><tbody><tr><td>¬X∨Y</td><td>NOT，然后 OR</td></tr><tr><td>¬(X^Y)</td><td>OR，然后 NOT</td></tr><tr><td>X∨(X^Y)</td><td>AND，然后 OR</td></tr></tbody></table><h3 id="布尔函数真值表"><a href="#布尔函数真值表" class="headerlink" title="布尔函数真值表"></a>布尔函数真值表</h3><p>布尔函数（Boolean function）接收布尔输入，生成布尔输出。所有布尔函数都可以构造一个真值表来展示全部可能的输入和输出。下面的这些真值表都表示包含两个输入变量 X 和 Y 的布尔函数。右侧的阴影部分是函数输出</p><p>示例 1：¬X∨Y</p><table><thead><tr><th>X</th><th>¬X</th><th>Y</th><th>¬X∨Y</th></tr></thead><tbody><tr><td>F</td><td>T</td><td>F</td><td>T</td></tr><tr><td>F</td><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td><td>F</td></tr><tr><td>T</td><td>F</td><td>T</td><td>T</td></tr></tbody></table><p>示例 2：X^¬Y</p><table><thead><tr><th>X</th><th>Y</th><th>¬Y</th><th>X^¬Y</th></tr></thead><tbody><tr><td>F</td><td>F</td><td>T</td><td>F</td></tr><tr><td>F</td><td>T</td><td>F</td><td>F</td></tr><tr><td>T</td><td>F</td><td>T</td><td>T</td></tr><tr><td>T</td><td>T</td><td>F</td><td>F</td></tr></tbody></table><p>示例3： (Y^S)∨(X^¬S)</p><table><thead><tr><th>X</th><th>Y</th><th>S</th><th>Y^S</th><th>¬S</th><th>X^¬S</th><th>(Y^S)∨(X^¬S)</th></tr></thead><tbody><tr><td>F</td><td>F</td><td>F</td><td>F</td><td>T</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>F</td><td>F</td><td>T</td><td>F</td><td>F</td></tr><tr><td>T</td><td>F</td><td>F</td><td>F</td><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>T</td><td>F</td><td>F</td><td>T</td><td>T</td><td>T</td></tr><tr><td>F</td><td>F</td><td>T</td><td>F</td><td>F</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>T</td><td>T</td><td>F</td><td>F</td><td>T</td></tr><tr><td>T</td><td>F</td><td>T</td><td>F</td><td>F</td><td>F</td><td>F</td></tr><tr><td>T</td><td>T</td><td>T</td><td>T</td><td>F</td><td>F</td><td>T</td></tr></tbody></table><p>示例 3 的布尔函数描述了一个多路选择器（multiplexer），一种数字组件，利用一个选择位（S）在两个输出（X 和 Y）中选择一个。如果 S 为假，函数输出（Z）就和 X 相同；如果 S 为真，函数输出就和 Y 相同。下面是多路选择器的框图：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722299316953" alt="img"></p><h1 id="x86处理器架构"><a href="#x86处理器架构" class="headerlink" title="x86处理器架构"></a>x86处理器架构</h1><h2 id="CPU处理器架构和工作原理浅析"><a href="#CPU处理器架构和工作原理浅析" class="headerlink" title="CPU处理器架构和工作原理浅析"></a>CPU处理器架构和工作原理浅析</h2><h3 id="基本微机设计"><a href="#基本微机设计" class="headerlink" title="基本微机设计"></a>基本微机设计</h3><p>下图给出了假想机的基本设计。中央处理单元（CPU）是进行算术和逻辑操作的部件，包含了有限数量的存储位置——寄存器（register），一个高频时钟、一个控制单元和一个算术逻辑单元。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722300320055" alt="img"></p><p>其中：</p><ul><li><p>时钟 (clock) 对 CPU 内部操作与系统其他组件进行同步。</p></li><li><p>控制单元 (control unit, CU) 协调参与机器指令执行的步骤序列。</p></li><li><p>算术逻辑单元 (arithmetic logic unit, ALU) 执行算术运算，如加法和减法，以及逻辑运算，如 AND（与）、OR（或）和 NOT（非）。</p></li></ul><p>CPU 通过主板上 CPU 插座的引脚与计算机其他部分相连。大部分引脚连接的是数据总线、控制总线和地址总线。</p><p>内存存储单元 (memory storage unit) 用于在程序运行时保存指令与数据。它接受来自 CPU 的数据请求，将数据从随机存储器 (RAM) 传输到 CPU，并从 CPU 传输到内存。</p><p>由于所有的数据处理都在 CPU 内进行，因此保存在内存中的程序在执行前需要被复制到 CPU 中。程序指令在复制到 CPU 时，可以一次复制一条，也可以一次复制多条。</p><p>总线 (bus) 是一组并行线，用于将数据从计算机一个部分传送到另一个部分。一个计算机系统通常包含四类总线：数据类、I/O 类、控制类和地址类。</p><p>数据总线 (data bus) 在 CPU 和内存之间传输指令和数据。I/O 总线在 CPU 和系统输入 / 输出设备之间传输数据。控制总线 (control bus) 用二进制信号对所有连接在系统总线上设备的行为进行同步。当前执行指令在 CPU 和内存之间传输数据时，地址总线 (address bus) 用于保持指令和数据的地址。</p><p>时钟与 CPU 和系统总线相关的每一个操作都是由一个恒定速率的内部时钟脉冲来进行同步。机器指令的基本时间单位是机器周期 (machine cycle) 或时钟周期 (clock cycle)。</p><p>一个时钟周期的时长是一个完整时钟脉冲所需要的时间。下图中，一个时钟周期被描绘为两个相邻下降沿之间的时间：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722303747359" alt="img"></p><p>时钟周期持续时间用时钟速度的倒数来计算，而时钟速度则用每秒振荡数来衡量。例如，一个每秒振荡 10 亿次 (1GHz) 的时钟，其时钟周期为 10 亿分之 1 秒 (1 纳秒 )。</p><p>执行一条机器指令最少需要 1 个时钟周期，有几个需要的时钟则超过了 50 个（比如 8088 处理器中的乘法指令）。由于在 CPU、系统总线和内存电路之间存在速度差异，因此，需要访问内存的指令常常需要空时钟周期，也被称为等待状态 (wait states)。</p><h3 id="指令执行周期"><a href="#指令执行周期" class="headerlink" title="指令执行周期"></a>指令执行周期</h3><p>一条机器指令不会神奇地一下就执行完成。CPU 在执行一条机器指令时，需要经过一系列预先定义好的步骤，这些步骤被称为指令执行周期 (instruction execution cycle)。</p><p>假设现在指令指针寄存器中已经有了想要执行指令的地址，下面就是执行步骤：</p><p>\1) CPU 从被称为指令队列 (instruction queue) 的内存区域取得指令，之后立即增加指令指针的值。</p><p>\2) CPU 对指令的二进制位模式进行译码。这种位模式可能会表示该指令有操作数（输入值）。</p><p>\3) 如果有操作数，CPU 就从寄存器和内存中取得操作数。有时，这步还包括了地址计算。</p><p>\4) 使用步骤 3 得到的操作数，CPU 执行该指令。同时更新部分状态标志位，如零标志 (Zero)、进位标志 (Carry) 和溢出标志 (Overflow)。</p><p>\5) 如果输出操作数也是该指令的一部分，则 CPU 还需要存放其执行结果。</p><p>通常将上述听起来很复杂的过程简化为三个步骤：取指 (Fetch)、译码 (Decode) 和执行 (Execute)。操作数 (operand) 是指操作过程中输入或输出的值。例如，表达式 Z=X+Y 有两个输入操作数 (X 和 Y)，—个输岀操作数 (Z)。</p><p>下图是一个典型 CPU 中的数据流框图。该图表现了在指令执行周期中相互交互部件之间的关系。在从内存读取程序指令之前，将其地址放到地址总线上。然后，内存控制器将所需代码送到数据总线上，存入代码高速缓存 (code cache)。指令指针的值决定下一条将要执行的指令。指令由指令译码器分析，并产生相应的数值信号送往控制单元，其协调 ALU 和浮点单元。虽然图中没有画出控制总线，但是其上传输的信号用系统时钟协调不同 CPU 部件之间的数据传输。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722307277861" alt="img"></p><h3 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h3><p>作为一个常见现象，计算机从内存读取数据比从内部寄存器读取速度要慢很多。这是因为从内存读取一个值，需要经过下述步骤：</p><ul><li><p>将想要读取的值的地址放到地址总线上。</p></li><li><p>设置处理器 RD（读取）引脚（改变 RD 的值）。</p></li><li><p>等待一个时钟周期给存储器芯片进行响应。</p></li><li><p>将数据从数据总线复制到目标操作数。</p></li></ul><p>上述每一步常常只需要一个时钟周期，时钟周期是基于处理器内固定速率时钟节拍的一种时间测量方法。计算机的 CPU 通常是用其时钟速率来描述。例如，速率为 1.2GHz 意味着时钟节拍或振荡为每秒 12 亿次。</p><p>因此，考虑到每个时钟周期仅为 1/1 200 000 000 秒，4 个时钟周期也是非常快的。但是，与 CPU 寄存器相比，这个速度还是慢了，因为访问寄存器一般只需要 1 个时钟周期。</p><p>幸运的是，CPU 设计者很早之前就已经指出，因为绝大多数程序都需要访问变量，计算机内存成为了速度瓶颈。他们想出了一个聪明的方法来减少读写内存的时间一一将大部分近期使用过的指令和数据存放在高速存储器 cache 中。</p><p>其思想是，程序更可能希望反复访问相同的内存和指令，因此，cache 保存这些值就能使它们能被快速访问到。此外，当 CPU 开始执行一个程序时，它会预先将后续（比如）一千条指令加载到 cache 中，这个行为是基于这样一种假设，即这些指令很快就会被用到。</p><p>如果这种情况重复发生在一个代码块中，则 cache 中就会有相同的指令。当处理器能够在 cache 存储器中发现想要的数据，则称为 cache 命中 (cache hit)。反之，如果 CPU 在 cache 中没有找到数据，则称为 cache 未命中 (cache miss)。</p><p>x86 系列中的 cache 存储器有两种类型：一级 cache（或主 cache）位于 CPU 上；二级 cache （或次 cache）速度略慢，通过高速数据总线与 CPU 相连。这两种 cache 以最佳方式一 起工作。</p><p>还有一个原因使得 cache 存储器比传统 RAM 速度快，cache 存储器是由一种被称为静态 RAM (static RAM) 的特殊存储器芯片构成的。这种芯片比较贵，但是不需要为了保持其内容进行不断地刷新。另一方面，传统存储器，即动态 RAM (dynamic RAM)，就需要持续刷新。它速度慢一些，但是价格更便宜。</p><h3 id="加载并执行程序"><a href="#加载并执行程序" class="headerlink" title="加载并执行程序"></a>加载并执行程序</h3><p>在程序执行之前，需要用一种工具程序将其加载到内存，这种工具程序称为程序加载器 (program loader)。加载后，操作系统必须将 CPU 向程序的入口，即程序开始执行的地址。以下步骤是对这一过程的详细分解。</p><p>\1) 操作系统（OS）在当前磁盘目录下搜索程序的文件名。如果找不到，则在预定目录列表（称为路径（path））下搜索文件名。当 OS 无法检索到文件名时，它会发出一个出错信息。</p><p>\2) 如果程序文件被找到，OS 就访问磁盘目录中的程序文件基本信息，包括文件大小，及其在磁盘驱动器上的物理位置。</p><p>\3) OS 确定内存中下一个可使用的位置，将程序文件加载到内存。为该程序分配内存块，并将程序大小和位置信息加入表中（有时称为描述符表（descriptor table））。另外，OS 可能调整程序内指针的值，使得它们包括程序数据地址。</p><p>\4) OS 开始执行程序的第一条机器指令（程序入口）。当程序开始执行后，就成为一个进程（process）。OS 为这个进程分配一个标识号（进程 ID），用于在执行期间对其进行追踪。</p><p>\5) 进程自动运行。OS 的工作是追踪进程的执行，并响应系统资源的请求。这些资源包括内存、磁盘文件和输入输出设备等。</p><p>\6) 进程结束后，就会从内存中移除。 </p><p>不论使用哪个版本的 Microsoft Windows，按下 Ctrl-Alt-Delete 组合键，可以选择任务管理器（task manager）选项。在任务管理器窗口可以查看应用程序和进程列表。</p><p>应用程序列表中列出了当前正在运行的完整程序名称，比如，Windows 浏览器，或者 Microsoft Visual C++。如果选择进程列表，则会看见一长串进程名。其中的每个进程都是一个独立于其他进程的，并处于运行中的小程序。</p><p>可以连续追踪每个进程使用的 CPU 时间和内存容量。在某些情况下，选定一个进程名称后，按下 Delete 键就可以关闭该进程。</p><h2 id="32位x86处理器架构"><a href="#32位x86处理器架构" class="headerlink" title="32位x86处理器架构"></a>32位x86处理器架构</h2><h3 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h3><p>x86 处理器有三个主要的操作模式：保护模式、实地址模式和系统管理模式；以及一个子模式：虚拟 8086 (virtual-8086) 模式，这是保护模式的特殊情况。以下是对这些模式的简介：</p><h4 id="1-保护模式-Protected-Mode"><a href="#1-保护模式-Protected-Mode" class="headerlink" title="1) 保护模式 (Protected Mode)"></a>1) 保护模式 (Protected Mode)</h4><p>保护模式是处理器的原生状态，在这种模式下，所有的指令和特性都是可用的。分配给程序的独立内存区域被称为段，而处理器会阻止程序使用自身段范围之外的内存。</p><h4 id="2-虚拟-8086-模式-Virtual-8086-Mode"><a href="#2-虚拟-8086-模式-Virtual-8086-Mode" class="headerlink" title="2) 虚拟 8086 模式 (Virtual-8086 Mode)"></a>2) 虚拟 8086 模式 (Virtual-8086 Mode)</h4><p>保护模式下，处理器可以在一个安全环境中，直接执行实地址模式软件，如 MS-DOS 程序。换句话说，如果一个程序崩溃了或是试图向系统内存区域写数据，都不会影响到同一时间内执行的其他程序。现代操作系统可以同时执行多个独立的虚拟 8086 会话。</p><h4 id="3-实地址模式-Real-Address-Mode"><a href="#3-实地址模式-Real-Address-Mode" class="headerlink" title="3) 实地址模式 (Real-Address Mode)"></a>3) 实地址模式 (Real-Address Mode)</h4><p>实地址模式实现的是早期 Intel 处理器的编程环境，但是增加了一些其他的特性，如切换到其他模式的功能。当程序需要直接访问系统内存和硬件设备时，这种模式就很有用。</p><h4 id="4-系统管理模式-System-Management-Mode"><a href="#4-系统管理模式-System-Management-Mode" class="headerlink" title="4) 系统管理模式 (System Management Mode)"></a>4) 系统管理模式 (System Management Mode)</h4><p>系统管理模式 (SMM) 向操作系统提供了实现诸如电源管理和系统安全等功能的机制。这些功能通常是由计算机制造商实现的，他们为了一个特定的系统设置而定制处理器。</p><h3 id="基本执行环境"><a href="#基本执行环境" class="headerlink" title="基本执行环境"></a>基本执行环境</h3><h4 id="1-地址空间"><a href="#1-地址空间" class="headerlink" title="1) 地址空间"></a>1) 地址空间</h4><p>在 32 位保护模式下，一个任务或程序最大可以寻址 4GB 的线性地址空间。从 P6 处理器开始，一种被称为扩展物理寻址 (extended physical addressing) 的技术使得可以被寻址的物理内存空间增加到 64GB。</p><p>与之相反，实地址模式程序只能寻址 1MB 空间。如果处理器在保护模式下运行多个虚拟 8086 程序，则每个程序只能拥有自己的 1MB 内存空间。</p><h4 id="2-基本程序执行寄存器"><a href="#2-基本程序执行寄存器" class="headerlink" title="2) 基本程序执行寄存器"></a>2) 基本程序执行寄存器</h4><p>寄存器是直接位于 CPU 内的高速存储位置，其设计访问速度远高于传统存储器。例如，当一个循环处理为了速度进行优化时，其循环计数会保留在寄存器中而不是变量中。</p><p>下图展示的是基本程序执行寄存器（basic program execution registers）。8 个通用寄存器，6 个段寄存器，一个处理器状态标志寄存器（EFLAGS），和一 个指令指针寄存器（EIP）。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722310166763" alt="img"></p><h5 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h5><p>通用寄存器主要用于算术运算和数据传输。如下图所示，EAX 寄存器的低 16 位在使用时可以用 AX 表示。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722316676665" alt="img"></p><p>一些寄存器的组成部分可以处理 8 位的值。例如，AX 寄存器的高 8 位被称为 AH，而低 8 位被称为 AL。同样的重叠关系也存在于 EAX、EBX、ECX 和 EDX 寄存器中：</p><table><thead><tr><th>32 位</th><th>16 位</th><th>8 位（高）</th><th>8 位（低）</th></tr></thead><tbody><tr><td>EAX</td><td>AX</td><td>AH</td><td>AL</td></tr><tr><td>EBX</td><td>BX</td><td>BH</td><td>BL</td></tr><tr><td>ECX</td><td>CX</td><td>CH</td><td>CL</td></tr><tr><td>EDX</td><td>DX</td><td>DH</td><td>DL</td></tr></tbody></table><p>其他通用寄存器只能用 32 位或 16 位名称来访问，如下表所示：</p><table><thead><tr><th>32 位</th><th>16 位</th><th>32 位</th><th>16 位</th></tr></thead><tbody><tr><td>ESI</td><td>SI</td><td>EBP</td><td>BP</td></tr><tr><td>EDI</td><td>DI</td><td>ESP</td><td>SP</td></tr></tbody></table><h5 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h5><p>某些通用寄存器有特殊用法：</p><ul><li><p>乘除指令默认使用EAX。它常常被称为扩展累加器（extended accumulator）寄存器。</p></li><li><p>CPU 默认使用 ECX 为循环计数器。</p></li><li><p>ESP 用于寻址堆栈（一种系统内存结构）数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针（extended stack pointer）寄存器。</p></li><li><p>ESI 和 EDI 用于高速存储器传输指令，有时也被称为扩展源变址（extended source index）寄存器和扩展目的变址（extended destination index）寄存器。</p></li><li><p>高级语言通过 EBP 来引用堆栈中的函数参数和局部变量。除了高级编程，它不用于一般算术运算和数据传输。它常常被称为扩展帧指针（extended frame pointer）寄存器。</p></li></ul><h5 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h5><p>实地址模式中，16 位段寄存器表示的是预先分配的内存区域的基址，这个内存区域称为段。保护模式中，段寄存器中存放的是段描述符表指针。一些段中存放程序指令（代码），其他段存放变量（数据），还有一个堆栈段存放的是局部函数变量和函数参数。</p><h5 id="指令指针"><a href="#指令指针" class="headerlink" title="指令指针"></a>指令指针</h5><p>指令指针（EIP）寄存器中包含下一条将要执行指令的地址。某些机器指令能控制 EIP，使得程序分支转向到一个新位置。</p><h5 id="EFLAGS-寄存器"><a href="#EFLAGS-寄存器" class="headerlink" title="EFLAGS 寄存器"></a>EFLAGS 寄存器</h5><p>EFLAGS （或 Flags）寄存器包含了独立的二进制位，用于控制 CPU 的操作，或是反映一些 CPU 操作的结果。有些指令可以测试和控制这些单独的处理器标志位。</p><p>设置标志位时，该标识位 =1；清除（或重置）标识位时，该标志位 =0。</p><h5 id="控制标志位"><a href="#控制标志位" class="headerlink" title="控制标志位"></a>控制标志位</h5><p>控制标志位控制 CPU 的操作。例如，它们能使得 CPU 每执行一条指令后进入中断；在侦测到算术运算溢出时中断执行；进入虚拟 8086 模式，以及进入保护模式。</p><p>程序能够通过设置 EFLAGS 寄存器中的单独位来控制 CPU 的操作，比如，方向标志位和中断标志位。</p><h5 id="状态标志位"><a href="#状态标志位" class="headerlink" title="状态标志位"></a>状态标志位</h5><p>状态标志位反映了 CPU 执行的算术和逻辑操作的结果。其中包括：溢出位、符号位、零标志位、辅助进位标志位、奇偶校验位和进位标志位。下述说明中，标志位的缩写紧跟在标志位名称之后：</p><ul><li><p>进位标志位（CF），与目标位置相比，无符号算术运算结果太大时，设置该标志位。</p></li><li><p>溢出标志位（OF），与目标位置相比，有符号算术运算结果太大或太小时，设置该标志位。</p></li><li><p>符号标志位（SF），算术或逻辑操作产生负结果时，设置该标志位。</p></li><li><p>零标志位（ZF），算术或逻辑操作产生的结果为零时，设置该标志位。</p></li><li><p>辅助进位标志位（AC），算术操作在 8 位操作数中产生了位 3 向位 4 的进位时，设置该标志位。</p></li><li><p>奇偶校验标志位（PF），结果的最低有效字节包含偶数个 1 时，设置该标志位，否则，清除该标志位。一般情况下，如果数据有可能被修改或损坏时，该标志位用于进行 错误检测。</p></li></ul><h3 id="3-MMX-寄存器"><a href="#3-MMX-寄存器" class="headerlink" title="3) MMX 寄存器"></a>3) MMX 寄存器</h3><p>在实现高级多媒体和通信应用时，MMX 技术提高了 Intel 处理器的性能。8 个 64 位 MMX 寄存器支持称为 SIMD（单指令，多数据，Single-Instruction，Multiple-Data）的特殊指令。</p><p>顾名思义，MMX 指令对 MMX 寄存器中的数据值进行并行操作。虽然，它们看上去是独立的寄存器，但是 MMX 寄存器名实际上是浮点单元中使用的同样寄存器的别名。</p><h3 id="4-XMM-寄存器"><a href="#4-XMM-寄存器" class="headerlink" title="4) XMM 寄存器"></a>4) XMM 寄存器</h3><p>x86 结构还包括了 8 个 128 位 XMM 寄存器，它们被用于 SIMD 流扩展指令集。</p><h4 id="浮点单元"><a href="#浮点单元" class="headerlink" title="浮点单元"></a>浮点单元</h4><p>浮点单元（FPU, floating-point unit）执行高速浮点算术运算。之前为了这个目的，需要一个独立的协处理器芯片。从 Intel486 处理器开始，FPU 已经集成到主处理器芯片上。</p><p>FPU 中有 8 个浮点数据寄存器，分别命名为 ST（0），ST（1），ST（2），ST（3），ST（4）， ST（5）， ST （6）和 ST（7）。其他控制寄存器和指针寄存器如下图所示。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722318922167" alt="img"></p><h3 id="x86-内存管理"><a href="#x86-内存管理" class="headerlink" title="x86 内存管理"></a>x86 内存管理</h3><p>x86 处理器按照前面讨论的基本操作模式来管理内存。保护模式是最可靠、最强大的，但是它对应用程序直接访问系统硬件有着严格的限制。</p><p>在实地址模式中，只能寻址 1MB 内存，地址从 00000H 到 FFFFFH。处理器一次只能运行一个程序，但是可以暂时中断程序来处理来自外围设备的请求（称为中断（interrupt））。</p><p>应用程序被允许访问内存的任何位置，包括那些直接与系统硬件相关的地址。MS-DOS 操作系统在实地址模式下运行，Windows 95 和 98 能够引导进入这种模式。</p><p>在保护模式中，处理器可以同时运行多个程序，它为每个进程（运行中的程序）分配总共 4GB 的内存。每个程序都分配有自己的保留内存区域，程序之间禁止意外访问其他程序的代码和数据。MS-Windows 和 Linux 运行在保护模式下。</p><p>在虚拟 8086 模式中，计算机运行在保护模式下，通过创建一个带有 1MB 地址空间的虚拟 8086 机器来模拟运行于实地址模式的 80x86 计算机。例如，在 Windows NT 和 2000 下，当打开一个命令窗口时，就创建了一个虚拟 8086 机器。同一时间可以运行多个这样的窗口，并且窗口之间都是受到保护的。</p><p>在 Windows NT，2000 和 XP 系统中，某些需要直接使用计算机硬件的 MS-DOS 程序不能运行在虚拟 8086 模式下。</p><h2 id="64位x86-64处理器架构"><a href="#64位x86-64处理器架构" class="headerlink" title="64位x86-64处理器架构"></a>64位x86-64处理器架构</h2><p>处理器包括 Intel 64 和 AMD64 处理器系列。指令集是已讨论的 x86 指令集的 64 位扩展。以下为一些基本特征：</p><p>\1) 向后兼容 x86 指令集。</p><p>\2) 地址长度为 64 位，虚拟地址空间为 2 64 字节。按照当前芯片的实现情况，只能使用地址的低 48 位。</p><p>\3) 可以使用 64 位通用寄存器，允许指令具有 64 位整数操作数。</p><p>\4) 比 x86 多了 8 个通用寄存器。</p><p>\5) 物理地址为 48 位，支持高达 256TB 的 RAM。</p><p>另一方面，当处理器运行于本机 64 位模式时，是不支持 16 位实模式或虚拟 8086 模式的。（在传统模式（legacy mode）下，还是支持 16 位编程，但是在 Microsoft Windows 64 位版本中不可用。）</p><p>注意尽管 x86-64 指的是指令集，但是也可以将其看作是处理器类型。学习汇编语言时，没有必要考虑支持 x86-64 的处理器之间的硬件实现差异。</p><p>第一个使用 x86-64 的 Intel 处理器是 Xeon，之后还有许多其他的处理器，包括 Core i5 和 Core i7。AMD 处理器中使用 x86-64 的例子有 Opteron 和 Athlon 64。</p><p>另一个为人所知的 64 位 Intel 架构是 IA-64，后来被称为 Itanium。 IA-64 指令集与 x86 和 x86-64 完全不同，Itanium 处理器通常用于高性能数据库和网络服务器。</p><h3 id="64-位操作模式"><a href="#64-位操作模式" class="headerlink" title="64 位操作模式"></a>64 位操作模式</h3><p>Intel 64 架构引入了一个新模式，称为 IA-32e。从技术上看，这个模式包含两个子模式：兼容模式（compatibility mode）和 64 位模式（64-bit mode）。不过它们常常被看做是模式而不是子模式，因此，先来了解这两个模式。</p><h4 id="1-兼容模式"><a href="#1-兼容模式" class="headerlink" title="1) 兼容模式"></a>1) 兼容模式</h4><p>在兼容模式下，现有的 16 位与 32 位应用程序通常不用进行重新编译就可以运行。但是，16 位 Windows（Win16）和 DOS 应用程序不能运行在 64 位 Microsoft Windows 下。</p><p>与早期 Windows 版本不同，64 位 Windows 没有虚拟 DOS 机器子系统来利用处理器的功能切换到虚拟 8086 模式。</p><h4 id="2-64-位模式"><a href="#2-64-位模式" class="headerlink" title="2) 64 位模式"></a>2) 64 位模式</h4><p>在 64 位模式下，处理器执行的是使用 64 位线性地址空间的应用程序。这是 64 位 Microsoft Windows 的原生模式，该模式能使用 64 位指令操作数。</p><h3 id="基本-64-位执行环境"><a href="#基本-64-位执行环境" class="headerlink" title="基本 64 位执行环境"></a>基本 64 位执行环境</h3><p>64 位模式下，虽然处理器现在只能支持 48 位的地址，但是理论上，地址最大为 64 位。从寄存器来看，64 位模式与 32 位最主要的区别如下所示：</p><ul><li><p>16 个 64 位通用寄存器（32 位模式只有 8 个通用寄存器）</p></li><li><p>8 个 80 位浮点寄存器</p></li><li><p>1 个 64 位状态标志寄存器 RFLAGS （只使用低 32 位）</p></li><li><p>1 个 64 位指令指针寄存器 RIP</p></li></ul><p>32 位标志寄存器和指令指针寄存器分别称为 EFLAGS 和 EIP。此外，还有一些 x86 处理器用于多媒体处理的特殊寄存器：</p><ul><li><p>8 个 64 位 MMX 寄存器</p></li><li><p>16 个 128 位 XMM 寄存器（32 位模式只有 8 个 XMM 寄存器）</p></li></ul><h4 id="通用寄存器-1"><a href="#通用寄存器-1" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>64 位模式下，操作数的默认大小是 32 位，并且有 8 个通用寄存器。但是，给每条指令加上 REX（寄存器扩展）前缀后，操作数可以达到 64 位，可用通用寄存器的数量也增加到 16 个：32 位模式下的寄存器，再加上 8 个有标号的寄存器，R8 到 R15。下表给出了 REX 前缀下可用的寄存器。</p><table><thead><tr><th>操作数大小</th><th>可用寄存器</th></tr></thead><tbody><tr><td>8 位</td><td>AL、BL、CL、DL、DIL、SIL、BPL、SPL、R8L、R9L、R10L、R11L、R12L、R13L、R14L、R15L</td></tr><tr><td>16 位</td><td>AX、BX、CX、DX、DI、SI、BP、SP、R8W、R9W、R10W、R11W、R12W、R13W、R14W、R15W</td></tr><tr><td>32 位</td><td>EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP、R8D、R9D、R10D、R11D、R12D、R13D、R14D、R15D</td></tr><tr><td>64 位</td><td>RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP、R8、R9、R10、R11、R12、R13、R14、R15</td></tr></tbody></table><p>还有一些需要记住的细节：</p><ul><li><p>64 位模式下，单条指令不能同时访问寄存器高字节，如 AH、BH、CH 和 DH，以及新字节寄存器的低字节（如 DIL）。</p></li><li><p>64 位模式下，32 位 EFLAGS 寄存器由 64 位 RFLAGS 寄存器取代。这两个寄存器共享低 32 位，而 RFLAGS 的高 32 位是不使用的。</p></li><li><p>32 位模式和 64 位模式具有相同的状态标志。</p></li></ul><h2 id="x86计算机组件"><a href="#x86计算机组件" class="headerlink" title="x86计算机组件"></a>x86计算机组件</h2><h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><p>主板是微型计算机的心脏，它是一个平面电路板，其上集成了 CPU、支持处理器（芯片组（chipset））、主存、输入输出接口、电源接口和扩展插槽。</p><p>各种组件通过总线即一组直接蚀刻在主板上的导线，进行互连。目前 PC 市场上有几十种主板，它们在扩展功能、集成部件和速度方面存在着差异。但是，下述组件一般都会岀现在主板上：</p><ul><li><p>CPU 插座。根据其支持的处理器类型，插座具有不同的形状和尺寸。</p></li><li><p>存储器插槽（SIMM 或 DIMM），用于直接插入小型内存条。</p></li><li><p>BIOS （基本输入输出系统，basic input-output system）计算机芯片，保存系统软件。</p></li><li><p>CMOS RAM，用一个小型纽扣电池为其持续供电。</p></li><li><p>大容量插槽设备接口，如硬盘和 CD-ROMS。</p></li><li><p>外部设备的 USB 接口。</p></li><li><p>键盘和鼠标接口。</p></li><li><p>PCI 总线接口，用于声卡、显卡、数据采集卡和其他输入输出设备。</p></li></ul><p>以下是可选组件：</p><ul><li><p>集成声音处理器。</p></li><li><p>并行和串行设备接口。</p></li><li><p>集成网卡。</p></li><li><p>用于高速显卡的 AGP 总线接口。</p></li></ul><p>典型系统中还有一些重要的支持处理器：</p><ul><li><p>浮点单元（FPU），处理浮点数和扩展整数运算。</p></li><li><p>8284/82C84 时钟发生器，简称时钟，按照恒定速率振荡。时钟发生器同步 CPU 和计算机的其他部分。</p></li><li><p>8259A 可编程中断控制器（PIC, Programmable Interrupt Controller），处理来自硬件设备的外部中断请求，包括键盘、系统时钟和磁盘驱动器。这些设备能中断 CPU，并使其立即响应它们的请求。</p></li><li><p>8253 可编程间隔定时器 / 计数器（Programmable Interval Timer/Counter），每秒中断系统 18.2 次，更新系统日期和时钟，并控制扬声器。它还负责不断刷新内存，因为 RAM 存储器芯片保持其内容的时间只有几毫秒。</p></li><li><p>8255 可编程并行端口（Programmable Parallel Port），使用 IEEE 并行端口将数据输入和输出计算机。该端口通常用于打印机，但是也可以用于其他输入输出设备。</p></li></ul><h4 id="1-PCI-和-PCI-Express-总线架构"><a href="#1-PCI-和-PCI-Express-总线架构" class="headerlink" title="1) PCI 和 PCI Express 总线架构"></a>1) PCI 和 PCI Express 总线架构</h4><p>PCI（外部设备互联，Peripheral Component Interconnect）总线为 CPU 和其他系统设备提供了连接桥，这些设备包括硬盘驱动器、内存、显卡、声卡和网卡。</p><p>最近，PCI Express 总线在设备、内存和处理器之间提供了双向串行连接。如同网络一样，它用独立的“通道”传送数据包。该总线得到显卡的广泛支持，能以较高速度传输数据。</p><h4 id="2-主板芯片组"><a href="#2-主板芯片组" class="headerlink" title="2) 主板芯片组"></a>2) 主板芯片组</h4><p>主板芯片组（motherlboard chipset）是一组处理器芯片的集合，这些芯片被设计为在特定类型主板上一起工作。</p><p>各种芯片组具有增强处理能力、多媒体功能或减少功耗等特性。以 Intel P965 Express 芯片组为例，该芯片组与 Intel Core2 Duo 或 Pentium D 处理器一起，用于桌面系统</p><p>Intel P965 具有下述特性：</p><ul><li><p>Intel 高速内存访问 (Fast Memory Access) 使用了最新内存控制中心 (MCH)。它可以 800MHz 时钟速度来访问双通道 DDR2 存储器。</p></li><li><p>I/O 控制中心 (Intel ICH8/R/DH) 使用 Intel 矩阵存储技术 (MST) 来支持多个串行 ATA 设备 ( 磁盘驱动器 ) 。</p></li><li><p>支持多个 USB 端口，多个 PCI Express 插槽，联网和 Intel 静音系统技术。</p></li><li><p>高清晰音频芯片提供了数字声音功能。</p></li></ul><p>如下图所示，主板厂商以特定芯片为中心来制造产品。例如，Asus 公司使用 P965 芯片组的 P5B-E P965 主板。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722327386969" alt="img"></p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>基于 Intel 的系统使用的是几种基础类型内存：只读存储器（ROM）、可擦除可编程只读存储器（EPROM）、动态随机访问存储器（DRAM）、静态 RAM （SRAM）、图像随机存储器（VRAM），和互补金属氧化物半导体（CMOS）RAM：</p><ul><li><p>ROM 永久烧录在芯片上，并且不能擦除。</p></li><li><p>EPROM 能用紫外线缓慢擦除，并且重新编程。</p></li><li><p>DRAM，即通常的内存，在程序运行时保存程序和数据的部件。该部件价格便宜，但是每毫秒需要进行刷新，以避免丢失其内容。有些系统使用的是 ECC（错误检查和纠正）存储器。</p></li><li><p>SRAM 主要用于价格高、速度快的 cache 存储器。它不需要刷新，CPU 的 cache 存储器就是由 SRAM 构成的。</p></li><li><p>VRAM 保存视频数据。VRAM 是双端口的，它允许一个端口持续刷新显示器，同时另一个端口将数据写到显示器。</p></li><li><p>CMOS RAM 在系统主板上，保存系统设置信息。它由电池供电，因此当计算机电源关闭后，CMOS RAM 中的内容仍能保留。</p></li></ul><h2 id="计算机I-O输入输出系统"><a href="#计算机I-O输入输出系统" class="headerlink" title="计算机I/O输入输出系统"></a>计算机I/O输入输出系统</h2><p>由于计算机游戏与内存和 I/O 有着非常密切的关系，因此，它们推动计算机达到其最大性能。善于游戏编程的程序员通常很了解视频和音频硬件，并会优化代码的硬件特性。</p><h3 id="I-O-访问层次"><a href="#I-O-访问层次" class="headerlink" title="I/O 访问层次"></a>I/O 访问层次</h3><p>应用程序通常从键盘和磁盘文件读取输入，而将输出写到显示器和文件中。完成 I/O 不需要直接访问硬件——相反，可以调用操作系统的函数。</p><p>与《虚拟机》一节中描述的虚拟机相似，I/O 也有不同的访问层次，主要有以下三个：</p><h4 id="1-高级语言函数"><a href="#1-高级语言函数" class="headerlink" title="1) 高级语言函数"></a>1) 高级语言函数</h4><p>高级编程语言，如 C++ 或 Java，包含了执行输入输出的函数。由于这些函数要在各种不同的计算机系统中工作，并不依赖于任何一个操作系统，因此，这些函数具有可移植性。</p><h4 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2) 操作系统"></a>2) 操作系统</h4><p>程序员能够从被称为 API（应用程序编程接口，Application Programming Interface）的库中调用操作系统函数。操作系统提供高级操作，比如，向文件写入字符串，从键盘读取字符串，和分配内存块。</p><h4 id="3-BIOS"><a href="#3-BIOS" class="headerlink" title="3) BIOS"></a>3) BIOS</h4><p>基本输入输出系统是一组能够直接与硬件设备通信的低级子程序集合。BIOS 由计算机制造商安装并定制，以适应机器硬件。操作系统通常与 BIOS 通信。</p><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>设备驱动程序允许操作系统与硬件设备和系统 BIOS 直接通信。例如，设备驱动程序可能接收来自 OS 的请求来读取一些数据，而满足该请求的方法是，通过执行设备固件中的代码，用设备特有的方式来读取数据。</p><p>设备驱动程序有两种安装方法：一种是在特定硬件设备连接到系统之前，或者设备已连接并且识别之后。对于后一种方法，OS 识别设备名称和签名，然后在计算机上定位并安装设备驱动软件。</p><p>现在，通过展示应用程序在屏幕上显示字符串的过程，来了解 I/O 层次结构如下图所示。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722329286971" alt="img"></p><p>该过程包含以下步骤：</p><ul><li><p>应用程序调用 HLL 库函数，将字符串写入标准输出。</p></li><li><p>库函数（第 3 层）调用操作系统函数，传递一个字符串指针。</p></li><li><p>操作系统函数（第 2 层）用循环的方法调用 BIOS 子程序，向其传递每个字符的 ASCII 码和颜色。操作系统调用另一个 BIOS 子程序，将光标移动到屏幕的下一个位置上。</p></li><li><p>BIOS 子程序（第 1 层）接收一个字符，将其映射到一个特定的系统字体，并把该字符发送到与视频控制卡相连的硬件端口。</p></li><li><p>视频控制卡（第 0 层）为视频显示产生定时硬件信号，来控制光栅扫描并显示像素。</p></li></ul><h3 id="多层次编程"><a href="#多层次编程" class="headerlink" title="多层次编程"></a>多层次编程</h3><p>汇编语言程序在输入输出编程领域有着强大的能力和灵活性。它们可以从以下访问层次进行选择 （如下图所示）：</p><ul><li><p>第 3 层：调用库函数来执行通用文本 I/O 和基于文件的 I/O。</p></li><li><p>第 2 层：调用操作系统函数来执行通用文本 I/O 和基于文件的 I/O。如果 OS 使用了图形用户界面，它就能用与设备无关的方式来显示图形。</p></li><li><p>第 1 层：调用 BIOS 函数来控制设备具体特性，如颜色、图形、声音、键盘输入和底层磁盘 I/O。</p></li><li><p>第 0 层：从硬件端口发送和接收数据，对特定设备拥有绝对控制权。这个方式没有广泛用于各种硬件设备，因此不具可移植性。不同设备通常使用不同硬件端口，因此，程序代码必须根据每个设备的特定类型来进行定制。</p></li></ul><p><img src="/images/loading.gif" data-original="images/asm-language/-162722331090073" alt="img"></p><p>如何进行权衡？控制与可移植性是最重要的。第 2 层（OS）工作在任何一个运行同样操作系统的计算机上。如果 I/O 设备缺少某些功能，那么 OS 将尽可能接近预期结果。第 2 层速度并不特别快，因为每个 I/O 调用在执行前，都必须经过好几个层次。</p><p>第 1 层（BIOS）在具有标准 BIOS 的所有系统上工作，但是在这些系统上不会产生同样的结果。例如，两台计算机可能会有不同分辨率的视频显示功能。在第 1 层上的程序员需要编写代码来检测用户的硬件设置，并调整输出格式来与之匹配。第 1 层的速度比第 2 层快，因为它与硬件之间只隔了一个层次。</p><p>第 0 层（硬件）与通用设备一起工作，如串行端口；或是与由知名厂商生产的特殊 I/O 设备一起工作。这个层次上的程序必须扩展它们的编码逻辑来处理 I/O 设备的变化。实模式的游戏程序就是最好的例子，因为它们常常需要取得计算机的控制权。第 0 层的程序执行速度与硬件一样快。</p><p>举个例子，假设要用音频控制设备来播放一个 WAV 文件。在 OS 层上，不需要了解已安装设备的类型，也不用关心设备卡的非标准特性。</p><p>在 BIOS 上，要查询声卡（通过其已安装的设备驱动软件），找出它是否属于某一类具有已知功能的声卡。在硬件层上，需要对 特定模式声卡的程序进行微调，以利用每个声卡的特性。</p><p>通用操作系统极少允许应用程序直接访问系统硬件，因为这样做会使得它几乎无法同时运行多个程序。相反，硬件只能由设备驱动程序按照严格控制的方式进行访问。</p><p>另一方面，专业设备的小型操作系统则常常直接与硬件相连。这样做是为了减少操作系统代码占用的内存空间，并且这些操作系统几乎总是一次只运行单个程序。Microsoft 最后一个允许程序直接访问硬件的操作系统是 MS-DOS，它一次只能运行一个程序。</p><h1 id="汇编语言基础"><a href="#汇编语言基础" class="headerlink" title="汇编语言基础"></a>汇编语言基础</h1><h2 id="第一个汇编语言程序"><a href="#第一个汇编语言程序" class="headerlink" title="第一个汇编语言程序"></a>第一个汇编语言程序</h2><p>汇编语言以隐晦难懂而著名，它是一种几乎提供了全部信息的语言。程序员可以看到正在发生的所有事情，甚至包括 CPU 中的寄存器和标志！</p><p>但是，在拥有这种能力的同时，程序员必须负责处理数据表示的细节和指令的格式。程序员工作在一个具有大量详细信息的层次。现在以一个简单的汇编语言程序为例，来了解其工作过程。</p><p>程序执行两个数相加，并将结果保存在寄存器中。程序名称为 AddTwo：</p><pre><code>main PROC    mov eax, 5               ;将数字 5 送入 eax 寄存器    add eax, 6               ;eax 寄存器加 6    INVOKE ExitProcess, 0    ;程序结束main ENDP</code></pre><p>现在按照一次一行代码的方法来仔细查看这段程序：</p><ul><li><p>第 1 行开始 main 程序（主程序），即程序的入口；</p></li><li><p>第 2 行将数字 5 送入 eax 寄存器；</p></li><li><p>第 3 行把 6 加到 EAX 的值上，得到新值 11；</p></li><li><p>第 5 行调用 Windows 服务（也被称为函数）ExitProcess 停止程序，并将控制权交还给操作系统；</p></li><li><p>第 6 行是主程序结束的标记。</p></li></ul><p>大家可能已经注意到了程序中包含的注释，它总是用分号开头。程序的顶部省略了一些声明，稍后会予以说明，不过从本质上说，这是一个可以用的程序。</p><p>它不会将全部信息显示在屏幕上，但是借助工具程序调试器的运行，程序员可以按一次一行代码的方式执行程序， 并查看寄存器的值。</p><h4 id="添加一个变量"><a href="#添加一个变量" class="headerlink" title="添加一个变量"></a>添加一个变量</h4><p>现在让这个程序变得有趣些，将加法运算的结果保存在变量 sum 中。要实现这一点，需要增加一些标记，或声明，用来标识程序的代码和数据区：</p><pre><code>.data                          ;此为数据区sum DWORD 0                    ;定义名为sum的变量.code                          ;此为代码区main PROC    mov eax,5                  ;将数字5送入而eax寄存器    add eax,6                  ;eax寄存器加6    mox sum,eax    INVOKE ExitProcess,0       ;结束程序main ENDP</code></pre><p>变量 sum 在第 2 行进行了声明，其大小为 32 位，使用了关键字 DWORD。汇编语言中有很多这样的大小关键字，其作用或多或少与数据类型一样。</p><p>但是与程序员可能熟悉的类型相比它们没有那么具体，比如 int、double、float 等等。这些关键字只限制大小，并不检查变量中存放的内容。记住，程序员拥有完全控制权。</p><p>顺便说一下，那些被 .code 和 .data 伪指令标记的代码和数据区，被称为段。即，程序有代码段和数据段。</p><h2 id="汇编语言常量"><a href="#汇编语言常量" class="headerlink" title="汇编语言常量"></a>汇编语言常量</h2><p>常量（constant）是程序中使用的一个确定数值，在汇编阶段就可以确定，直接编码于指令代码中，不是保存在存储器中可变的变量，因为是编码在指令中的量，和指令一起存储了，所以不用单独开辟主存空间，所以也就没法动态改变它了，这也正是高级语言常量无法修改的原因。</p><h3 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h3><p>整数常量（integer literal）（又称为整型常量（integer constant））由一个可选前置符号、一个或多个数字，以及一个指明其基数的可选基数字符构成：</p><pre><code>[{+|-}] digits [radix]</code></pre><blockquote><p>提示：本教程使用 Microsoft 语法符号。方括号内的元素是可选的；大括号内的元素用 | 符号分隔，且必须要选择其中一个元素；斜体字标识的是有明确定义或 说明的元素。</p></blockquote><p>由此，比如 26 就是一个有效的整数常量。它没有基数，所以假设其是十进制形式。如果想要表示十六进制数 26，就将其写为 26h。同样，数字 1101 可以被看做是十进制值，除非在其末尾添加“b”，使其成为 1101b （二进制）。下表列出了可能的基数值：</p><table><thead><tr><th>h</th><th>十六进制</th><th>r</th><th>编码实数</th></tr></thead><tbody><tr><td>q/o</td><td>八进制</td><td>t</td><td>十进制（备用）</td></tr><tr><td>d</td><td>十进制</td><td>y</td><td>二进制（备用）</td></tr><tr><td>b</td><td>二进制</td><td></td><td></td></tr></tbody></table><p>下面这些整数常量声明了各种基数。每行都有注释：</p><pre><code>26         ;十进制26d        ;十进制11010011b  ;二进制42q        ;八进制42o        ;八进制1Ah        ;十六进制0A3h       ;十六进制</code></pre><p>以字母开头的十六进制数必须加个前置 0，以防汇编器将其解释为标识符。</p><h3 id="整型常量表达式"><a href="#整型常量表达式" class="headerlink" title="整型常量表达式"></a>整型常量表达式</h3><p>整型常量表达式 (constant integer expression) 是一种算术表达式，它包含了整数常量和算术运算符。每个表达式的计算结果必须是一个整数，并可用 32 位 (从 0 到 FFFFFFFFh) 来存放。</p><p>下表列出了算术运算符，并按照从高 (1) 到低 (4) 的顺序给出了它们的优先级。对整型常量表达式而言很重要的是，要意识到它们只在汇编时计算。这里将它们简称为 整数表达式。</p><table><thead><tr><th>运算符</th><th>名称</th><th>优先级</th></tr></thead><tbody><tr><td>()</td><td>圆括号</td><td>1</td></tr><tr><td>+,-</td><td>一元加、减</td><td>2</td></tr><tr><td>*, /</td><td>乘、除</td><td>3</td></tr><tr><td>MOD</td><td>取模</td><td>3</td></tr><tr><td>+, -</td><td>加、减</td><td>4</td></tr></tbody></table><p>运算符优先级 (operator precedence) 是指，当一个表达式包含两个或多个运算符时，这些操作的执行顺序。下面是一些表达式和它们的执行顺序：</p><pre><code>4 + 5 * 2       ;乘法，加法12 - 1 MOD 5    ;取模，减法-5 + 2          ;一元减法，加法(4 + 2)  *  6   ;加法，乘法</code></pre><p>下面给出了一些有效表达式和它们的值：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmFhNGFiYTIzZWM0YzI5OTlkOGE5NzYyZTNlMmQ3NDlfbUlqUDJNQ1NhSFBWMWFTUjhnTlVvZkszZkk1ZlR2R25fVG9rZW46Ym94Y25WZjJvcUo4TG9uNHQzYWlkTjNJVUVjXzE2MjcyMTY3MjU6MTYyNzIyMDMyNV9WNA" alt="img"></p><blockquote><p>提示：在表达式中使用圆括号来表明操作顺序，那么就不用去死记运算符优先级。</p></blockquote><h3 id="实数常量"><a href="#实数常量" class="headerlink" title="实数常量"></a>实数常量</h3><p>实数常量（real number literal）（又称为浮点数常量（floating-point literal））用于表示十进制实数和编码（十六进制）实数。十进制实数包含一个可选符号，其后跟随一个整数，一个十进制小数点，一个可选的表示小数部分的整数，和一个可选的指数：</p><pre><code>[sign]integer.[integer] [exponent]</code></pre><p>符号和指数的格式如下：</p><pre><code>sign               {+,-}exponent       E[{+,-}]integer</code></pre><p>下面是一些有效的十进制实数：</p><pre><code>2.+3.0-44.2E+0526.E5至少需要一个数字和一个十进制小数点。</code></pre><p>编码实数（encoded real）表示的是十六进制实数，用 IEEE 浮点数格式表示短实数。比如，十进制数 +1.0 用二进制表示为：</p><p>0011 1111 1000 0000 0000 0000 0000 0000</p><p>在汇编语言中，同样的值可以编码为短实数：</p><p>3F800000r</p><h3 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h3><p>字符常量 (character literal) 是指，用单引号或双引号包含的一个字符。汇编器在内存中保存的是该字符二进制 ASCII 码的数值。例如：</p><pre><code>'A'"d"</code></pre><p>表明字符常量在内部保存为整数，使用的是 ASCII 编码序列。因此，当编写字符常量“A”时，它在内存中存放的形式为数字 65 ( 或 41h)。</p><h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>字符串常量 (string literal) 是用单引号或双引号包含的一个字符 ( 含空格符 ) 序列：</p><pre><code>'ABC''X'"Good night, Gracie"'40961</code></pre><p>嵌套引号也是被允许的，使用方法如下例所示：</p><pre><code>"This isn't a test"'Say "Good night," Gracie'</code></pre><p>和字符常量以整数形式存放一样，字符串常量在内存中的保存形式为整数字节数值序列。例如，字符串常量“ABCD”就包含四个字节 41h、42h、43h、44h。</p><h2 id="汇编语言保留字"><a href="#汇编语言保留字" class="headerlink" title="汇编语言保留字"></a>汇编语言保留字</h2><p>保留字（reserved words）有特殊意义并且只能在其正确的上下文中使用。默认情况下，保留字是没有大小写之分的。比如，MOV 与 mov、Mov 是相同的。</p><p>保留字有不同的类型：</p><ul><li><p>指令助记符，如 MOV、ADD 和 MUL。</p></li><li><p>寄存器名称。</p></li><li><p>伪指令，告诉汇编器如何汇编程序。</p></li><li><p>属性，提供变量和操作数的大小与使用信息。例如 BYTE 和 WORD。</p></li><li><p>运算符，在常量表达式中使用。</p></li><li><p>预定义符号，比如 @data，它在汇编时返回常量的整数值。</p></li></ul><p>下表是常用的保留字列表。</p><table><thead><tr><th>$</th><th>PARITY?</th><th>DWORD</th><th>STDCALL</th></tr></thead><tbody><tr><td>?</td><td>PASCAL</td><td>FAR</td><td>SWORD</td></tr><tr><td>@B</td><td>QWORD</td><td>FAR16</td><td>SYSCALL</td></tr><tr><td>@F</td><td>REAL4</td><td>FORTRAN</td><td>TBYTE</td></tr><tr><td>ADDR</td><td>REAL8</td><td>FWORD</td><td>VARARG</td></tr><tr><td>BASIC</td><td>REAL10</td><td>NEAR</td><td>WORD</td></tr><tr><td>BYTE</td><td>SBYTE</td><td>NEAR16</td><td>ZERO?</td></tr><tr><td>C</td><td>SDORD</td><td>OVERFLOW?</td><td></td></tr><tr><td>CARRY?</td><td>SIGN?</td><td></td><td></td></tr></tbody></table><h3 id="汇编语言标识符及其命名规则"><a href="#汇编语言标识符及其命名规则" class="headerlink" title="汇编语言标识符及其命名规则"></a>汇编语言标识符及其命名规则</h3><p>标识符（identifier）是由程序员选择的名称，它用于标识变量、常数、子程序和代码标签。</p><p>标识符的形成有一些规则：</p><ul><li><p>可以包含 1 到 247 个字符。</p></li><li><p>不区分大小写。</p></li><li><p>第一个字符必须为字母 (A—Z, a—z) A 下划线 (_)、@、? 或 $。其后的字符也可以是数字。</p></li><li><p>标识符不能与汇编器保留字相同。</p></li></ul><blockquote><p>提示：可以在运行汇编器时，添加 -Cp 命令行切换项来使得所有关键字和标识符变成大小写敏感。</p></blockquote><p>通常，在高级编程语言代码中，标识符使用描述性名称是一个好主意。尽管汇编语言指令短且隐晦，但没有理由使得标识符也要变得难以理解。</p><p>下面是一些命名良好的名称：</p><pre><code>lineCount    firstValue    index    line_countmyFile     xCoord      main    x_Coord</code></pre><p>下面的名称合法，但是不可取：</p><pre><code>_lineCount    $first    @myFile</code></pre><p>一般情况下，应避免用符号 @ 和下划线作为第一个字符，因为它们既用于汇编器，也用于高级语言编译器。</p><h2 id="汇编语言伪指令"><a href="#汇编语言伪指令" class="headerlink" title="汇编语言伪指令"></a>汇编语言伪指令</h2><p>伪指令 (directive) 是嵌入源代码中的命令，由汇编器识别和执行。伪指令不在运行时执行，但是它们可以定义变量、宏和子程序；为内存段分配名称，执行许多其他与汇编器相关的日常任务。</p><p>默认情况下，伪指令不区分大小写。例如，.data，.DATA 和 .Data 是相同的。</p><p>下面的例子有助于说明伪指令和指令的区别。DWORD 伪指令告诉汇编器在程序中为一个双字变量保留空间。另一方面，MOV 指令在运行时执行，将 myVar 的内容复制到 EAX 寄存器中：</p><pre><code>myVar DWORD 26mov eax,myVar</code></pre><p>尽管 Intel 处理器所有的汇编器使用相同的指令集，但是通常它们有着不同的伪指令。比如，Microsoft 汇编器的 REPT 伪指令对其他一些汇编器就是无法识别的。</p><h4 id="定义段"><a href="#定义段" class="headerlink" title="定义段"></a>定义段</h4><p>汇编器伪指令的一个重要功能是定义程序区段，也称为段 (segment)。程序中的段具有不同的作用。如下面的例子，一个段可以用于定义变量，并用 .DATA 伪指令进行标识：</p><pre><code>.data</code></pre><p>.CODE 伪指令标识的程序区段包含了可执行的指令：</p><pre><code>.code</code></pre><p>.STACK 伪指令标识的程序区段定义了运行时堆栈，并设置了其大小：</p><pre><code>.stack 100h</code></pre><h2 id="汇编语言指令详解"><a href="#汇编语言指令详解" class="headerlink" title="汇编语言指令详解"></a>汇编语言指令详解</h2><p>指令（instruction）是一种语句，它在程序汇编编译时变得可执行。汇编器将指令翻译为机器语言字节，并且在运行时由 CPU 加载和执行。</p><p>一条指令有四个组成部分：</p><ul><li><p>标号（可选）</p></li><li><p>指令助记符（必需）</p></li><li><p>操作数（通常是必需的）</p></li><li><p>注释（可选）</p></li></ul><p>不同部分的位置安排如下所示：</p><pre><code>[label: ] mnemonic [operands] [;comment]</code></pre><p>现在分别了解每个部分，先从标号字段开始。</p><h3 id="1-标号"><a href="#1-标号" class="headerlink" title="1) 标号"></a>1) 标号</h3><p>标号（label）是一种标识符，是指令和数据的位置标记。标号位于指令的前端，表示指令的地址。同样，标号也位于变量的前端，表示变量的地址。标号有两种类型：数据标号和代码标号。</p><p>数据标号标识变量的位置，它提供了一种方便的手段在代码中引用该变量。比如，下面定义了一个名为 count 的变量：</p><pre><code>count DWORD 100</code></pre><p>汇编器为每个标号分配一个数字地址。可以在一个标号后面定义多个数据项。在下面的例子中，array 定义了第一个数字（1024）的位置，其他数字在内存中的位置紧随其后：</p><pre><code>array DWORD 1024, 2048      DWORD 4096, 8192</code></pre><p>程序代码区（指令所在区段）的标号必须用冒号（:）结束。代码标号用作跳转和循环指令的目标。例如，下面的 JMP 指令创建一个循环，将程序控制传递给标号 target 标识的位置：</p><pre><code>target:        mov ax,bx        ...        jmp target</code></pre><p>代码标号可以与指令在同一行上，也可以自己独立一行：</p><pre><code>L1: mov ax, bxL2 :</code></pre><p>标号命名规则要求，只要每个标号在其封闭子程序页中是唯一的，那么就可以多次使用相同的标号。</p><h3 id="2-指令助记符"><a href="#2-指令助记符" class="headerlink" title="2) 指令助记符"></a>2) 指令助记符</h3><p>指令助记符（instruction mnemonic）是标记一条指令的短单词。在英语中，助记符是帮助记忆的方法。相似地，汇编语言指令助记符，如 mov, add 和 sub，给出了指令执行操作类型的线索。下面是一些指令助记符的例子：</p><table><thead><tr><th>助记符</th><th>说明</th><th>助记符</th><th>说明</th></tr></thead><tbody><tr><td>MOV</td><td>传送（分配）数值</td><td>MUL</td><td>两个数值相乘</td></tr><tr><td>ADD</td><td>两个数值相加</td><td>JMP</td><td>跳转到一个新位置</td></tr><tr><td>SUB</td><td>从一个数值中减去另一个数值</td><td>CALL</td><td>调用一个子程序</td></tr></tbody></table><h3 id="3-操作数"><a href="#3-操作数" class="headerlink" title="3) 操作数"></a>3) 操作数</h3><p>操作数是指令输入输出的数值。汇编语言指令操作数的个数范围是 0〜3 个，每个操作数可以是寄存器、内存操作数、整数表达式和输入输岀端口。</p><p>生成内存操作数有不同的方法，比如，使用变量名、带方括号的寄存器等。变量名暗示了变量地址，并指示计算机使用给定地址的内存内容。下表列出了一些操作数示例：</p><table><thead><tr><th>示例</th><th>操作数类型</th><th>示例</th><th>操作数类型</th></tr></thead><tbody><tr><td>96</td><td>整数常量</td><td>eax</td><td>寄存器</td></tr><tr><td>2+4</td><td>整数表达式</td><td>count</td><td>内存</td></tr></tbody></table><p>现在来考虑一些包含不同个数操作数的汇编语言指令示例。比如，STC 指令没有操作数：</p><pre><code>stc                    ;进位标志位置 1</code></pre><p>INC 指令有一个操作数：</p><pre><code>inc eax                ;EAX 加 1</code></pre><p>MOV 指令有两个操作数：</p><pre><code>mov count, ebx         ;将 EBX 传送给变量 count</code></pre><p>操作数有固有顺序。当指令有多个操作数时，通常第一个操作数被称为目的操作数，第二个操作数被称为源操作数（source operand）。</p><p>一般情况下，目的操作数的内容由指令修改。比如，在 mov 指令中，数据就是从源操作数复制到目的操作数。</p><p>IMUL 指令有三个操作数，第一个是目的操作数，第二个和第三个是进行乘法的源操作数：</p><pre><code>imul eax,ebx,5</code></pre><p>在上例中，EBX 与 5 相乘，结果存放在 EAX 寄存器中。</p><h3 id="4-注释"><a href="#4-注释" class="headerlink" title="4) 注释"></a>4) 注释</h3><p>注释是程序编写者与阅读者交流程序设计信息的重要途径。程序清单的开始部分通常包含如下信息：</p><ul><li><p>程序目标的说明</p></li><li><p>程序创建者或修改者的名单</p></li><li><p>程序创建和修改的日期</p></li><li><p>程序实现技术的说明</p></li></ul><p>注释有两种指定方法：</p><ul><li><p>单行注释，用分号（;）开始。汇编器将忽略在同一行上分号之后的所有字符。</p></li><li><p>块注释，用 COMMENT 伪指令和一个用户定义的符号开始。汇编器将忽略其后所有的文本行，直到相同的用户定义符号出现为止。</p></li></ul><p>示例如下：</p><pre><code>COMMENT !        This line is a comment.        This line is also a comment.!</code></pre><p>其他符号也可以使用，只要该符号不出现在注释行中：</p><pre><code>COMMENT &amp;        This line is a comment.        This line is also a comment.&amp;</code></pre><p>当然，程序员应该在整个程序中提供注释，尤其是代码意图不太明显的地方。</p><h3 id="5-NOP（空操作）指令"><a href="#5-NOP（空操作）指令" class="headerlink" title="5) NOP（空操作）指令"></a>5) NOP（空操作）指令</h3><p>最安全（也是最无用）的指令是 NOP（空操作）。它在程序空间中占有一个字节，但是不做任何操作。它有时被编译器和汇编器用于将代码对齐到有效的地址边界。</p><p>在下面的例子中，第一条指令 MOV 生成了 3 字节的机器代码。NOP 指令就把第三条指令的地址对齐到双字边界（4 的偶数倍）：</p><pre><code>00000000   66   8B  C3  mov ax,bx00000003   90           nop           ;对齐下条指令00000004   8B   D1      mov edx,ecx</code></pre><p>x86 处理器被设计为从双字的偶数倍地址处加载代码和数据，这使得加载速度更快。</p><h2 id="汇编语言整数加减法示例"><a href="#汇编语言整数加减法示例" class="headerlink" title="汇编语言整数加减法示例"></a>汇编语言整数加减法示例</h2><p>之前给出的 AddTwo 程序，并添加必要的声明使其成为完全能运行的程序。</p><pre><code>; AddTwo.asm -两个 32 位整数相加.386.model flat,stdcall.stack 4096ExitProcess PROTO, dwExitCode:DWORD.codemain PROCmov  eax,5  ;将数字5送入eax寄存器add  eax,6  ;eax寄存器加6INVOKE ExitProcess,0main ENDPEND main</code></pre><p>第 3 行是 .386 伪指令，它表示这是一个 32 位程序，能访问 32 位寄存器和地址。第 4 行选择了程序的内存模式（flat），并确定了子程序的调用规范（称为 stdcall）。其原因是 32 位 Windows 服务要求使用 stdcall 规范。第 5 行为运行时堆栈保留了 4096 字节的存储空间，每个程序都必须有。</p><p>第 6 行声明了 ExitProcess 函数的原型，它是一个标准的 Windows 服务。原型包含了函数名、PROTO 关键字、一个逗号，以及一个输入参数列表。ExitProcess 的输入参数名称为 dwExitCode。</p><p>可以将其看作为给 Windows 操作系统的返回值，返回值为零，则表示程序执行成功；而任何其他的整数值都表示了一个错误代码。因此，程序员可以将自己的汇编程序看作是被操作系统调用的子程序或过程。当程序准备结束时，它就调用 ExitProcess，并向操作系统返回一个整数以表示该程序运行良好。</p><p>大家可能会好奇，为什么操作系统想要知道程序是否成功完成。理由如下：与按序执行一些程序相比，系统管理员常常会创建脚本文件。在脚本文件中的每一个点上，系统管理员都需要知道刚执行的程序是否失败，这样就可以在必要时退出该脚本。</p><p>脚本通常如下例所示，其中，ErrorLevel1 表示前一步的过程返回码大于或等于 1 ：</p><pre><code>call program_1if ErrorLevel 1 goto FailedLabelcall program_2if ErrorLevel 1 goto FailedLabel:SuccessLabel.Echo Great, everything worked!</code></pre><p>现在回到 AddTwo 程序清单。第 15 行用 end 伪指令来标记汇编的最后一行，同时它也标识了程序的入口（main）。标号 main 在第 9 行进行了声明，它标记了程序开始执行的地址。</p><h3 id="汇编伪指令回顾"><a href="#汇编伪指令回顾" class="headerlink" title="汇编伪指令回顾"></a>汇编伪指令回顾</h3><p>现在回顾一些在示例程序中使用过的最重要的汇编伪指令。</p><p>首先是 .MODEL 伪指令，它告诉汇编程序用的是哪一种存储模式：</p><pre><code>.model flat,stdcall</code></pre><p>32 位程序总是使用平面（flat）存储模式，它与处理器的保护模式相关联。关键字 stdcall 在调用程序时告诉汇编器，怎样管理运行时堆栈。</p><p>然后是 .STACK 伪指令，它告诉汇编器应该为程序运行时堆栈保留多少内存字节：</p><pre><code>.stack 4096</code></pre><p>数值 4096 可能比将要用的字节数多，但是对处理器的内存管理而言，它正好对应了一个内存页的大小。所有的现代程序在调用子程序时都会用到堆栈。首先，用来保存传递的参数；其次，用来保存调用函数的代码的地址。</p><p>函数调用结束后，CPU 利用这个地址返回到函数被调用的程序点。此外，运行时堆栈还可以保存局部变量，也就是，在函数内定义的变量。</p><p>.CODE 伪指令标记一个程序代码区的起点，代码区包含了可执行指令。通常，.CODE 的下一行声明程序的入口，按照惯例，一般会是一个名为 main 的过程。程序的入口是指程序要执行的第一条指令的位置。用下面两行来传递这个信息：</p><pre><code>.codemain PROC</code></pre><p>ENDP 伪指令标记一个过程的结束。如果程序有名为 main 的过程，则 endp 就必须使用同样的名称：</p><pre><code>main ENDP</code></pre><p>最后，END 伪指令标记一个程序的结束，并要引用程序入口：</p><pre><code>END main</code></pre><p>如果在 END 伪指令后面还有更多代码行，它们都会被汇编程序忽略。程序员可以在这里放各种内容一一程序注释，代码副本等等，都无关紧要。</p><h3 id="运行和调试-AddTwo-程序"><a href="#运行和调试-AddTwo-程序" class="headerlink" title="运行和调试 AddTwo 程序"></a>运行和调试 AddTwo 程序</h3><p>使用 Visual Studio 可以很方便地编辑、构建和运行汇编语言程序。下面的步骤，按照 Visual Studio 2012，说明了怎样打开示例项目，并创建 AddTwo 程序：</p><p>\1) 启动计算机上安装的最新版本的 Visual Studio。</p><p>\2) 打开 Visual Studio 中 Solution Explorer 窗口。它应该已经是可见的，但是程序员也可以在 View 菜单中选择 Solution Explorer 使其可见。</p><p>\3) 在 Solution Explorer 窗口右键点击项目名称，在文本菜单中选择 Add，再在弹出菜单中选择 New Item。</p><p>\4) 在 Add New File 对话窗口中（如下图所示 ) ，将文件命名为 AddTwo.asm，填写 Location 项为该文件选择一个合适的磁盘文件夹。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722336476775" alt="img"></p><p>\5) 单击 Add 按钮保存文件。</p><p>\6) 键入程序源代码，如下所示。这里大写关键字不是必需的：</p><pre><code>; AddTwo.asm - adds two 32-bit integers..386.model flat,stdcall.stack 4096ExitProcess PROTO,dwExitCode:DWORD.codemain PROCmov eax, 5add eax, 6INVOKE ExitProcess,0main ENDPEND main</code></pre><p>\7) 在 Project 菜单中选择 Build Project，查看 Visual Studio 工作区底部的错误消息。这被称为错误列表窗口。注意，当没有错误时，窗口底部的状态栏会显示 Build succeeded。</p><h4 id="调试演示"><a href="#调试演示" class="headerlink" title="调试演示"></a>调试演示</h4><p>下面将展示 AddTwo 程序的一个示例调试会话。演示使用的是 Visual Studio 2012，不过，自 2008 年起的任何版本的 Visual Studio 都可以使用。</p><p>运行调试程序的一个方法是在 Debug 菜单中选择 Step Over。按照 Visual Studio 的配置，F10 功能键或 Shift+F8 组合键将执行 Step Over 命令。</p><p>开始调试会话的另一种方法是在程序语句上设置断点，方法是在代码窗口左侧灰色垂直条中直接单击。断点处由一个红色大圆点标识出来。然后就可以从 Debug 菜单中选择 Start Debugging 开始运行程序。</p><p>如果试图在非执行代码行设置断点，那么在运行程序时，Visual Studio 会直接将断点前移到下一条可执行代码行。</p><p>当调试器被激活时，Visual Studio 窗口底部的状态栏变为橙色。当调试器停止并返回编辑模式时，状态栏变为蓝色。可视提示是有用的，因为在调试器运行时，程序员无法对程序进行编辑或保存。</p><h4 id="自定义调试接口"><a href="#自定义调试接口" class="headerlink" title="自定义调试接口"></a>自定义调试接口</h4><p>在调试时可以自定义调试接口。例如，如果想要显示 CPU 寄存器，实现方法是，在 Debug 菜单中选择 Windows，然后再选择 Registerso， 其中 Registers 窗口可见，同时还关闭了一些不重要的窗口。EAX 数值显示为 0000000B，是十进制数 11 的十六进制表示。</p><p>Registers 窗口中，EFL 寄存器包含了所有的状态标志位（零标志、进位标志、溢出标志等）。如果在 Registers 窗口中 右键单击，并在弹出菜单中选择Flags，则窗口将显示单个的标志位值。</p><p>Registers 窗口的一个重要特点是，在单步执行程序时，任何寄存器，只要当前指令修改了它的数值，就会变为红色。尽管无法在打印页面（它只有黑白两色）上表示出来，这种红色高亮确实显示给程序员，使之了解其程序是怎样影响寄存器的。 </p><p>在 Visual Studio 中运行一个汇编语言程序时，它是在控制台窗口中启动的。这个窗口与从 Windows 的 Start 菜单运行名为 cmd.exe 程序的窗口是相同的。或者，还可以打开项目 Debug\Bin 文件夹中的命令提示符，直接从命令行运行应用程序。如果采用的是这个方法，程序员就只能看见程序的输出，其中包括了写入控制台窗口的文本。查找具有相同名称的可执行文件作为 Visual Studio 项目。</p><h2 id="汇编器以及汇编流程"><a href="#汇编器以及汇编流程" class="headerlink" title="汇编器以及汇编流程"></a>汇编器以及汇编流程</h2><p>用汇编语言编写的源程序不能直接在其目标计算机上执行，必须通过翻译或汇编将其转换为可执行代码。实际上，汇编器与编译器 (compiler) 很相似，编译器是一类程序，用于将 C++ 或 Java 程序翻译为可执行代码。</p><p>汇编器生成包含机器语言的文件，称为目标文件 (object file)。这个文件还没有准备好执行，它还需传递给一个被称为链接器 (linker) 的程序，从而生成可执行文件 (executable file)。这个文件就准备好在操作系统命令提示符下执行。</p><h3 id="汇编-链接-执行周期"><a href="#汇编-链接-执行周期" class="headerlink" title="汇编-链接-执行周期"></a>汇编-链接-执行周期</h3><p>下面总结了编辑、汇编、链接和执行汇编语言程序的过程。下面详细说明每一个步骤。</p><ul><li><p>步骤1：编程者用文本编辑器 (text editor) 创建一个 ASCII 文本文件，称之为源文件。</p></li><li><p>步骤2：汇编器读取源文件，并生成目标文件，即对程序的机器语言翻译。或者，它也会生成列表文件。只要出现任何错误，编程者就必须返回步骤 1，修改程序。</p></li><li><p>步骤3：链接器读取并检查目标文件，以便发现该程序是否包含了任何对链接库中过程的调用。链接器从链接库中复制任何被请求的过程，将它们与目标文件组合，以生成可执行文件。</p></li><li><p>步骤4：操作系统加载程序将可执行文件读入内存，并使 CPU 分支到该程序起始地址，然后程序开始执行。</p></li></ul><h3 id="列表文件"><a href="#列表文件" class="headerlink" title="列表文件"></a>列表文件</h3><p>列表文件 (listing file) 包括了程序源文件的副本，再加上行号、每条指令的数字地址、每条指令的机器代码字节（十六进制）以及符号表。符号表中包含了程序中所有标识符的名称、段和相关信息。</p><p>高级程序员有时会利用列表文件来获得程序的详细信息。下面的代码展示了 AddTwo 程序的部分列表文件，现在进一步查看这个文件。1〜7 行没有可执行代码，因此它们原封不动地从源文件中直接复制过来。第 9 行表示代码段开始的地址为 0000 0000（在 32 位程序中，地址显示为 8 个十六进制数字）。这个地址是相对于程序内存占用起点而言 的，但是，当程序加载到内存中时，这个地址就会转换为绝对内存地址。此时，该程序就会从这个地址开始，比如 0004 0000h。</p><pre><code>; AddTwo.asm - adds two 32-bit integers.; Chapter 3 example.386.model flat,stdcall.stack 4096ExitProcess PROTO,dwExitCode:DWORD    00000000                            .code    00000000                            main PROC    00000000 B8 00000005                    mov eax, 5    00000005 83 C0 06                       add eax,6                                            invoke ExitProcess,0    00000008 6A 00                          push        +000000000h    0000000A E8 00000000 E                  call        ExitProcess    0000000F                            main ENDP                                        END main</code></pre><p>第 10 行和第 11 行也显示了相同的开始地址 0000 0000，原因是：第一条可执行语句是 MOV 指令，它在第 11 行。请注意第 11 行中，在地址和源代码之间出现了几个十六进制字节，这些字节（B8 0000 0005）代表的是机器代码指令（B8 ），而该指令分配给 EAX 的就是 32 位常数值（0000 0005）：</p><pre><code>00000000 B8 00000005 mov eax, 5</code></pre><p>数值 B8 也被称为操作代码（或简称为操作码），因为它表示了特定的机器指令，将一个 32 位整数送入 eax 寄存器。</p><p>第 12 行也是一条可执行指令，起始偏移量为 0000 0005。这个偏移量是指从程序起始地址开始 5 个字节的距离。</p><p>第 14 行有 invoke 伪指令。注意第 15 行和 16 行是如何插入到这段代码中的，插入代码的原因是，INVOKE 伪指令使得汇编器生成 PUSH 和 CALL 语句，它们就显示在第 15 行和 16 行。</p><p>代码中展示的示例列表文件说明了机器指令是怎样以整数值序列的形式加载到内存的，在这里用十六进制表示：B8、0000 0005、83、C0、06、6A、00、EB、0000 0000。每个数中包含的数字个数暗示了位的个数：2 个数字就是 8 位，4 个数字就是 16 位，8 个数字就是 32 位，以此类推。所以，本例机器指令长正好是 15 个字节（2 个 4 字节值和 7 个 1 字节值）。</p><p>当程序员想要确认汇编器是否按照自己的程序生成了正确的机器代码字节时，列表文件就是最好的资源。如果是刚开始学习机器代码指令是如何生成的，列表文件也是一个很好的教学工具。</p><p>若想告诉 Visual Studio 生成列表文件，则在打开项目时按下述步骤操作：在 Project 菜单中选择 Properties，在 Configuration Properties 下，选择 Microsoft Macro Assemblero 然后选择 Listing File。在对话框中，设置 Generate Preprocessed Source Listing 为 Yes，设置 List All Available Information 为 Yes。</p><h2 id="汇编语言数据类型以及数据定义详解"><a href="#汇编语言数据类型以及数据定义详解" class="headerlink" title="汇编语言数据类型以及数据定义详解"></a>汇编语言数据类型以及数据定义详解</h2><p>汇编器识别一组基本的内部数据类型（intrinsic data type），按照数据大小（字节、字、双字等等）、是否有符号、是整数还是实数来描述其类型。这些类型有相当程度的重叠，例如，DWORD 类型（32 位，无符号整数）就可以和 SDWORD 类型（32 位，有符号整数）相互交换。</p><p>可能有人会说，程序员用 SDWORD 告诉读程序的人，这个值是有符号的，但是，对于汇编器来说这不是强制性的。汇编器只评估操作数的大小。因此，举例来说，程序员只能将 32 位整数指定为 DWORD、SDWORD 或者 REAL4 类型。</p><p>下表给出了全部内部数据类型的列表，有些表项中的 IEEE 符号指的是 IEEE 计算机学会出版的标准实数格式。</p><table><thead><tr><th>类型</th><th>用法</th></tr></thead><tbody><tr><td>BYTE</td><td>8 位无符号整数，B 代表字节</td></tr><tr><td>SBYTE</td><td>8 位有符号整数，S 代表有符号</td></tr><tr><td>WORD</td><td>16 位无符号整数</td></tr><tr><td>SWORD</td><td>16 位有符号整数</td></tr><tr><td>DWORD</td><td>32 位无符号整数，D 代表双（字）</td></tr><tr><td>SDWORD</td><td>32 位有符号整数，SD 代表有符号双（字）</td></tr><tr><td>FWORD</td><td>48 位整数（保护模式中的远指针）</td></tr><tr><td>QWORD</td><td>64 位整数，Q 代表四（字）</td></tr><tr><td>TBYTE</td><td>80 位（10 字节）整数，T 代表 10 字节</td></tr><tr><td>REAL4</td><td>32 位（4 字节）IEEE 短实数</td></tr><tr><td>REAL8</td><td>64 位（8 字节）IEEE 长实数</td></tr><tr><td>REAL10</td><td>80 位（10 字节）IEEE 扩展实数</td></tr></tbody></table><h3 id="数据定义语句"><a href="#数据定义语句" class="headerlink" title="数据定义语句"></a>数据定义语句</h3><p>数据定义语句（data definition statement）在内存中为变量留岀存储空间，并赋予一个可选的名字。数据定义语句根据内部数据类型（上表）定义变量。</p><p>数据定义语法如下所示：<code>[name] directive initializer [,initializer]...</code></p><p>下面是数据定义语句的一个例子：<code>count DWORD 12345</code></p><p>其中：</p><ul><li><p>名字：分配给变量的可选名字必须遵守标识符规范。</p></li><li><p>伪指令：数据定义语句中的伪指令可以是 BYTE、WORD、DWORD、SBTYE、SWORD 或其他在上表中列出的类型。此外，它还可以是传统数据定义伪指令，如下表所示。</p></li></ul><table><thead><tr><th>伪指令</th><th>用法</th><th>伪指令</th><th>用法</th></tr></thead><tbody><tr><td>DB</td><td>8位整数</td><td>DQ</td><td>64 位整数或实数</td></tr><tr><td>DW</td><td>16 位整数</td><td>DT</td><td>定义 80 位（10 字节）整数</td></tr><tr><td>DD</td><td>32 位整数或实数</td><td></td><td></td></tr></tbody></table><p>数据定义中至少要有一个初始值，即使该值为 0。其他初始值，如果有的话，用逗号分隔。对整数数据类型而言，初始值（initializer）是整数常量或是与变量类型，如 BYTE 或 WORD 相匹配的整数表达式。</p><p>如果程序员希望不对变量进行初始化（随机分配数值），可以用符号 ? 作为初始值。所有初始值，不论其格式，都由汇编器转换为二进制数据。 初始值 0011 0010b、32h 和 50d 都具有相同的二进制数值。</p><h3 id="向-AddTwo-程序添加一个变量"><a href="#向-AddTwo-程序添加一个变量" class="headerlink" title="向 AddTwo 程序添加一个变量"></a>向 AddTwo 程序添加一个变量</h3><p>现在创建一个新版本，并称为 AddTwoSum。这个版本引入了变量 sum，它出现在完整的程序清单中：</p><pre><code>;AddTowSum.asm.386.model flat,stdcall.stack 4096ExitProcess PROTO, dwExitCode:DWORD.datasum DWORD 0.codemain PROC    mov eax,5    add eax,6    mov sum,eax    INVOKE ExitProcess,0main ENDPEND main</code></pre><p>可以在第 13 行设置断点，每次执行一行，在调试器中单步执行该程序。执行完第 15 行后，将鼠标悬停在变量 sum 上，查看其值。或者打开一个 Watch 窗口，打开过程如下：在 Debug 菜单中选择 Windows（在调试会话中），选择 Watch，并在四个可用选项（Watch1，Watch2，Watch3 或 Watch4）中选择一个。然后，用鼠标高亮显示 sum 变量，将其拖拉到 Watch 窗口中。下图展示了一个例子，其中用大箭头指出了执行第 15 行后，sum 的当前值。</p><h3 id="定义-BYTE-和-SBYTE-数据"><a href="#定义-BYTE-和-SBYTE-数据" class="headerlink" title="定义 BYTE 和 SBYTE 数据"></a>定义 BYTE 和 SBYTE 数据</h3><p>BYTE（定义字节）和 SBYTE（定义有符号字节）为一个或多个无符号或有符号数值分配存储空间。每个初始值在存储时，都必须是 8 位的。例如：</p><pre><code>value1 BYTE  'A'    ;字符常量value2 BYTE  0      ;最小无符号字节value3 BYTE  255    ;最大无符号字节value4 SBYTE -128   ;最小有符号字节value5 SBYTE +127   ;最大有符号字节</code></pre><p>问号（?）初始值使得变量未初始化，这意味着在运行时分配数值到该变量：</p><pre><code>value6 BYTE ?</code></pre><p>可选名字是一个标号，标识从变量包含段的开始到该变量的偏移量。比如，如果 value1 在数据段偏移量为 0000 处，并在内存中占一个字节，则 value2 就自动处于偏移量为 0001 处：</p><pre><code>value1 BYTE 10hvalue2 BYTE 20h</code></pre><p>DB 伪指令也可以定义有符号或无符号的 8 位变量：</p><pre><code>val1 DB 255  ;无符号字节val2 DB -128 ;有符号字节</code></pre><h4 id="1-多初始值"><a href="#1-多初始值" class="headerlink" title="1) 多初始值"></a>1) 多初始值</h4><p>如果同一个数据定义中使用了多个初始值，那么它的标号只指出第一个初始值的偏移量。在下面的例子中，假设 list 的偏移量为 0000。那么，数值 10 的偏移量就为 0000, 20 的偏移量为 0001，30 的偏移量为 0002，40 的偏移量为 0003：</p><pre><code>list BYTE 10,20,30,40</code></pre><p>并不是所有的数据定义都要用标号。比如，在 list 后面继续添加字节数组，就可以在下一行定义它们：</p><pre><code>list BYTE 10,20,30,40     BYTE 50,60,70,80     BYTE 81,82,83,84</code></pre><p>在单个数据定义中，其初始值可以使用不同的基数。字符和字符串常量也可以自由组合。在下面的例子中，list1 和 list2 有相同的内容：</p><pre><code>list1 BYTE 10, 32, 41h, 00100010blist2 BYTE 0Ah, 20h, 'A', 22h</code></pre><h4 id="2-定义字符串"><a href="#2-定义字符串" class="headerlink" title="2) 定义字符串"></a>2) 定义字符串</h4><p>定义一个字符串，要用单引号或双引号将其括起来。最常见的字符串类型是用一个空字节（值为0）作为结束标记，称为以空字节结束的字符串，很多编程语言中都使用这种类型的字符串：</p><pre><code>greeting1 BYTE "Good afternoon",0greeting2 BYTE 'Good night',0</code></pre><p>每个字符占一个字节的存储空间。对于字节数值必须用逗号分隔的规则而言，字符串是一个例外。如果没有这种例外，greeting1 就会被定义为：</p><pre><code>greeting1 BYTE 'G', 'o', 'o', 'd'....etc.</code></pre><p>这就显得很冗长。一个字符串可以分为多行，并且不用为每一行都添加标号：</p><pre><code>greeting1 BYTE "Welcome to the Encryption Demo program "          BYTE "created by Kip Irvine.",0dh, 0ah          BYTE "If you wish to modify this program, please "          BYTE "send me a copy.",0dh,0ah,0</code></pre><p>十六进制代码 0Dh 和 0Ah 也被称为 CR/LF （回车换行符）或行结束字符。在编写标准输出时，它们将光标移动到当前行的下一行的左侧。</p><p>行连续字符（\）把两个源代码行连接成一条语句，它必须是一行的最后一个字符。下面的语句是等价的：</p><pre><code>greeting1 BYTE "Welcome to the Encryption Demo program "</code></pre><p>和</p><pre><code>greeting1 \BYTE "Welcome to the Encryption Demo program "</code></pre><h4 id="3-DUP-操作符"><a href="#3-DUP-操作符" class="headerlink" title="3) DUP 操作符"></a>3) DUP 操作符</h4><p>DUP 操作符使用一个整数表达式作为计数器，为多个数据项分配存储空间。在为字符串或数组分配存储空间时，这个操作符非常有用，它可以使用初始化或非初始化数据：</p><pre><code>BYTE 20 DUP ( 0 )      ;20 个字节，值都为 0BYTE 20 DUP ( ? )      ;20 个字节，非初始化BYTE 4 DUP ( "STACK" ) ; 20 个字节：</code></pre><h3 id="定义-WORD-和-SWORD-数据"><a href="#定义-WORD-和-SWORD-数据" class="headerlink" title="定义 WORD 和 SWORD 数据"></a>定义 WORD 和 SWORD 数据</h3><p>WORD（定义字）和 SWORD（定义有符号字）伪指令为一个或多个 16 位整数分配存储空间：</p><pre><code>word1 WORD 65535    ;最大无符号数word2 SWORD -32768  ;最小有符号数word3 WORD ?        ;未初始化，无符号</code></pre><p>也可以使用传统的 DW 伪指令：</p><pre><code>val1 DW 65535   ;无符号val2 DW -32768  ;有符号</code></pre><p>16 位字数组通过列举元素或使用 DUP 操作符来创建字数组。下面的数组包含了一组数值：</p><pre><code>myList WORD 1,2,3,4,5</code></pre><p>DUP 操作符提供了一种方便的方法来声明数组：</p><pre><code>array WORD 5 DUP (?) ; 5 个数值，未初始化</code></pre><h3 id="定义-DWORD-和-SDWORD-数据"><a href="#定义-DWORD-和-SDWORD-数据" class="headerlink" title="定义 DWORD 和 SDWORD 数据"></a>定义 DWORD 和 SDWORD 数据</h3><p>DWORD（定义双字）和 SDWORD（定义有符号双字）伪指令为一个或多个 32 位整数分配存储空间：</p><pre><code>val1 DWORD 12345678h    ;无符号val2 SDWORD -2147483648 ;有符号val3 DWORD 20 DUP (?)   ;无符号数组</code></pre><p>传统的 DD 伪指令也可以用来定义双字数据：</p><pre><code>val1 DD 12345678h ;无符号val2 DD -2147483648 ;有符号</code></pre><p>DWORD 还可以用于声明一种变量，这种变量包含的是另一个变量的 32 位偏移量。如下所示，pVal 包含的就是 val3 的偏移量：</p><pre><code>pVal DWORD val3</code></pre><h4 id="32-位双字数组"><a href="#32-位双字数组" class="headerlink" title="32 位双字数组"></a>32 位双字数组</h4><p>现在定义一个双字数组，并显式初始化它的每 一个值：</p><pre><code>myList DWORD 1,2,3,4,5</code></pre><h3 id="定义-QWORD-数据"><a href="#定义-QWORD-数据" class="headerlink" title="定义 QWORD 数据"></a>定义 QWORD 数据</h3><p>QWORD（定义四字）伪指令为 64 位（8 字节）数值分配存储空间：</p><pre><code>quad1 QWORD 1234567812345678h</code></pre><p>传统的 DQ 伪指令也可以用来定义四字数据：</p><pre><code>quad1 DQ 1234567812345678h</code></pre><h3 id="定义压缩-BCD（TBYTE）数据"><a href="#定义压缩-BCD（TBYTE）数据" class="headerlink" title="定义压缩 BCD（TBYTE）数据"></a>定义压缩 BCD（TBYTE）数据</h3><p>Intel 把一个压缩的二进制编码的十进制（BCD, Binary Coded Decimal）整数存放在一个 10 字节的包中。每个字节（除了最高字节之外）包含两个十进制数字。在低 9 个存储字节中，每半个字节都存放了一个十进制数字。最高字节中，最高位表示该数的符号位。如果最高字节为 80h，该数就是负数；如果最高字节为 00h，该数就是正数。整数的范围是 -999 999 999 999 999 999 到 +999 999 999 999 999 999。</p><p>示例下表列出了正、负十进制数 1234 的十六进制存储字节，排列顺序从最低有效字节到最高有效字节：</p><table><thead><tr><th>十进制数值</th><th>存储字节</th></tr></thead><tbody><tr><td>1234</td><td>34 12 00 00 00 00 00 00 00 00</td></tr><tr><td>-1234</td><td>34 12 00 00 00 00 00 00 00 80</td></tr></tbody></table><p>MASM 使用 TBYTE 伪指令来定义压缩 BCD 变量。常数初始值必须是十六进制的，因为，汇编器不会自动将十进制初始值转换为 BCD 码。下面的两个例子展示了十进制 数 -1234 有效和无效的表达方式：</p><pre><code>intVal TBYTE 800000000000001234h ;有效intVal TBYTE -1234               ;无效</code></pre><p>第二个例子无效的原因是 MASM 将常数编码为二进制整数，而不是压缩 BCD 整数。</p><p>如果想要把一个实数编码为压缩 BCD 码，可以先用 FLD 指令将该实数加载到浮点寄存器堆栈，再用 FBSTP 指令将其转换为压缩 BCD 码，该指令会把数值舍入到最接近的整数：</p><pre><code>.dataposVal REAL8 1.5bcdVal TBYTE ?.codefid posVal ;加载到浮点堆栈fbstp bcdVal ;向上舍入到 2，压缩 BCD 码值</code></pre><p>如果 posVal 等于 1.5，结果 BCD 值就是 2。</p><h3 id="定义浮点类型"><a href="#定义浮点类型" class="headerlink" title="定义浮点类型"></a>定义浮点类型</h3><p>REAL4 定义 4 字节单精度浮点变量。REAL8 定义 8 字节双精度数值，REAL10 定义 10 字节扩展精度数值。每个伪指令都需要一个或多个实常数初始值：</p><pre><code>rVal1 REAL4 -1.2rVal2 REAL8 3.2E-260rVal3 REAL10 4.6E+4096ShortArray REAL4 20 DUP(0.0)</code></pre><p>下表描述了标准实类型的最少有效数字个数和近似范围：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722353048077" alt="img"></p><p>DD、DQ 和 DT 伪指令也可以定义实数:</p><pre><code>rVal1 DD -1.2      ;短实数rVal2 DQ 3.2E-260  ;长实数rVal3 DT 4.6E+4096 ;扩展精度实数</code></pre><p>MASM 汇编器包含了诸如 wal4 和 real8 的数据类型，这些类型表明数值是实数。更准确地说，这些数值是浮点数，其精度和范围都是有限的。从数学的角度来看，实数的精度和大小是无限的。</p><h3 id="变量加法程序"><a href="#变量加法程序" class="headerlink" title="变量加法程序"></a>变量加法程序</h3><p>到目前为止，本节的示例程序实现了存储在寄存器中的整数加法。现在已经对如何定义数据有了一些了解，那么可以对同样的程序进行修改，使之实现三个整数变量相加，并将和数存放到第四个变量中。</p><pre><code>;AddTowSum.asm.386.model flat,stdcall.stack 4096ExitProcess PROTO, dwExitCode:DWORD.datafirstval DWORD 20002000hsecondval DWORD 11111111hthirdval DWORD 22222222hsum DWORD 0.codemain PROC    mov eax,firstval    add eax,secondval    add eax,thirdval    mov sum,eax    INVOKE ExitProcess,0main ENDPEND main</code></pre><p>注意，已经用非零数值对三个变量进行了初始化（9〜11 行）。16〜18 行进行变量相加。x86 指令集不允许将一个变量直接与另一个变量相加，但是允许一个变量与一个寄存器相加。这就是为什么 16〜17 行用 EAX 作累加器的原因：</p><pre><code>mov eax,firstvaladd eax,secondval</code></pre><p>第 17 行之后，EAX 中包含了 firstval 和 secondval 之和。接着，第 18 行把 thirdval 加到 EAX 中的和数上：</p><pre><code>add eax,thirdval</code></pre><p>最后，在第 19 行，和数被复制到名称为 sum 的变量中：</p><pre><code>mov sum,eax</code></pre><p>作为练习，鼓励大家在调试会话中运行本程序，并在每条指令执行后检查每个寄存器。最终和数应为十六进制的 53335333。</p><p>在调试会话过程中，如果想要变量显示为十六进制，则按下述步骤操作：鼠标在变量或寄存器上悬停 1 秒，直到一个灰色矩形框出现在鼠标下。右键点击该矩形框，在弹出菜单中选择 Hexadecimal Display。</p><h3 id="小端顺序"><a href="#小端顺序" class="headerlink" title="小端顺序"></a>小端顺序</h3><p>x86 处理器在内存中按小端（little-endian）顺序（低到高）存放和检索数据。最低有效字节存放在分配给该数据的第一个内存地址中，剩余字节存放在随后的连续内存位置中。考虑一个双字 12345678h。如果将其存放在偏移量为 0000 的位置，则 78h 存放在第一个字节，56h 存放在第二个字节，余下的字节存放地址偏移量为 0002 和 0003。</p><p>其他有些计算机系统采用的是大端顺序（高到低）。  12345678h 从偏移量 0000 开始的大端顺序存放。</p><h3 id="声明未初始化数据"><a href="#声明未初始化数据" class="headerlink" title="声明未初始化数据"></a>声明未初始化数据</h3><p>.DATA ? 伪指令声明未初始化数据。当定义大量未初始化数据时，.DATA ? 伪指令减少了编译程序的大小。例如，下述代码是有效声明：</p><pre><code>.datasmallArray DWORD 10 DUP (0) ;40 个字节.data?bigArray DWORD 5000 DUP ( ? ) ;20 000 个字节，未初始化</code></pre><p>而另一方面，下述代码生成的编译程序将会多岀 20 000 个字节：</p><pre><code>.datasmallArray DWORD 10 DUP ( 0 )  ; 40 个字节bigArray DWORD 5000 DUP ( ? )  ; 20 000 个字节</code></pre><p>代码与数据混合汇编器允许在程序中进行代码和数据的来回切换。比如，想要声明一个变量，使其只能在程序的局部区域中使用。下述示例在两个代码语句之间插入了一个名为 temp 的变量：</p><pre><code>.codemov eax,ebx.datatemp DWORD ?.codemov temp,eax</code></pre><p>尽管 temp 声明的出现打断了可执行指令流，MASM 还是会把 temp 放在数据段中，并与保持编译的代码段分隔开。然而同时，混用 .code 和 .data 伪指令会使得程序变得难以阅读。</p><h2 id="汇编语言等号-伪指令"><a href="#汇编语言等号-伪指令" class="headerlink" title="汇编语言等号=伪指令"></a>汇编语言等号=伪指令</h2><p>等号伪指令（equal-sign directive）把一个符号名称与一个整数表达式连接起来，其语法如下：</p><pre><code>name = expression</code></pre><p>通常，表达式是一个 32 位的整数值。当程序进行汇编时，在汇编器预处理阶段，所有出现的 name 都会被替换为 expression。假设下面的语句出现在一个源代码文件开始的位置：</p><pre><code>COUNT = 500</code></pre><p>然后，假设在其后 10 行的位置有如下语句：</p><pre><code>mov eax, COUNT</code></pre><p>那么，当汇编文件时，MASM 将扫描这个源文件，并生成相应的代码行：</p><pre><code>mov eax, 500</code></pre><h4 id="为什么使用符号？"><a href="#为什么使用符号？" class="headerlink" title="为什么使用符号？"></a>为什么使用符号？</h4><p>程序员可以完全跳过 COUNT 符号，简化为直接用常量 500 来编写 MOV 指令，但是经验表明，如果使用符号将会让程序更加容易阅读和维护。</p><p>设想，如果 COUNT 在整个程序中出现多次，那么，在之后的时间里，程序员就能方便地重新定义它的值：</p><pre><code>COUNT = 600</code></pre><p>假如再次对该源文件进行汇编，则所有的 COUNT 都将会被自动替换为 600。</p><h4 id="当前地址计数器"><a href="#当前地址计数器" class="headerlink" title="当前地址计数器"></a>当前地址计数器</h4><p>最重要的符号之一被称为当前地址计数器（current location counter），表示为 $。例如，下面的语句声明了一个变量 selfPtr，并将其初始化为该变量的偏移量：</p><pre><code>selfPtr DWORD $</code></pre><h4 id="键盘定义"><a href="#键盘定义" class="headerlink" title="键盘定义"></a>键盘定义</h4><p>程序通常定义符号来识别常用的数字键盘代码。比如，27 是 Esc 键的 ASCII 码：</p><pre><code>Esc_key = 27</code></pre><p>在该程序的后面，如果语句使用这个符号而不是整数常量，那么它会具有更强的自描述性。</p><p>使用</p><pre><code>mov al,Esc_key ；好的编程风格</code></pre><p>而非</p><pre><code>mov al,27     ;不好的编程风格</code></pre><h4 id="使用DUP操作符"><a href="#使用DUP操作符" class="headerlink" title="使用DUP操作符"></a>使用DUP操作符</h4><p>《数据定义》一节说明了怎样使用 DUP 操作符来存储数组和字符串。为了简化程序的维护，DUP 使用的计数器应该是符号计数器。</p><p>在下例中，如果已经定义了 COUNT，那么它就可以用于下面的数据定义中：</p><p>array dword COUNT DUP(0)</p><h4 id="重定义"><a href="#重定义" class="headerlink" title="重定义"></a>重定义</h4><p>用“=”定义的符号，在同一程序内可以被重新定义。下例展示了当 COUNT 改变数值后，汇编器如何计算它的值：</p><pre><code>COUNT = 5mov al,COUNT ； AL = 5COUNT = 10mov al,COUNT ； AL = 10COUNT = 100mov al,COUNT ； AL = 100</code></pre><p>符号值的改变，例如 COUNT，不会影响语句在运行时的执行顺序。相反，在汇编器预处理阶段，符号会根据汇编器对源代码处理的顺序来改变数值。</p><h2 id="汇编语言计算数组和字符串长度"><a href="#汇编语言计算数组和字符串长度" class="headerlink" title="汇编语言计算数组和字符串长度"></a>汇编语言计算数组和字符串长度</h2><p>在使用数组时，通常会想要知道它的大小。下例使用常量 ListSize 来声明 list 的大小：</p><pre><code>list BYTE 10,20,30,40ListSize = 4</code></pre><p>显式声明数组的大小会导致编程错误，尤其是如果后续还会插入或删除数组元素。声明数组大小更好的方法是，让汇编器来计算这个值。</p><p>$ 运算符（当前地址计数器）返回当前程序语句的偏移量。在下例中，从当前地址计数器（$）中减去 list 的偏移量，计算得到 ListSize：</p><pre><code>list BYTE 10,20,30,40ListSize = ($ - list)</code></pre><p>ListSize 必须紧跟在 list 的后面。下面的例子中，计算得到的 ListSize 值（24）就过大，原因是 var2 使用的存储空间，影响了当前地址计数器与 list 偏移量之间的距离：</p><pre><code>list BYTE 10,20,30,40var2 BYTE 20 DUP(?)ListSize = ($ - list)</code></pre><p>不要手动计算字符串的长度，让汇编器完成这个工作：</p><pre><code>myString BYTE "This is a long string, containing"               BYTE "any number of characters"myString_len = ($ - myString)</code></pre><h4 id="字数组和双字数组"><a href="#字数组和双字数组" class="headerlink" title="字数组和双字数组"></a>字数组和双字数组</h4><p>当要计算元素数量的数组中包含的不是字节时，就应该用数组总的大小（按字节计）除以单个元素的大小。比如，在下例中，由于数组中的每个字要占 2 个字节（16 位），因此，地址范围应该除以 2：</p><pre><code>list WORD 1000h,2000h,3000h,4000hListSize = ($ - list) / 2</code></pre><p>同样，双字数组中每个元素长 4 个字节，因此，其总长度除以 4 才能产生数组元素的个数：</p><pre><code>list DWORD l0000000h,20000000h,30000000h,40000000hListSize = ($ -list) / 4</code></pre><h2 id="汇编语言EQU伪指令"><a href="#汇编语言EQU伪指令" class="headerlink" title="汇编语言EQU伪指令"></a>汇编语言EQU伪指令</h2><p>EQU 伪指令把一个符号名称与一个整数表达式或一个任意文本连接起来，它有 3 种格式：</p><pre><code>name EQU expressionname EQU symbolname EQU &lt;text&gt;</code></pre><p>第一种格式中，expression 必须是一个有效整数表达式。第二种格式中，symbol 是一个已存在的符号名称，已经用 = 或 EQU 定义过了。第三种格式中，任何文本都可以岀现在&lt;…&gt;内。当汇编器在程序后面遇到 name 时，它就用整数值或文本来代替符号。</p><p>在定义非整数值时，EQU 非常有用。比如，可以使用 EQU 定义实数常量：</p><pre><code>PI EQU &lt;3.1416&gt;</code></pre><p>【示例 1】下面的例子将一个符号与一个字符串连接起来，然后用该符号定义一个变量：</p><pre><code>pressKey EQU &lt;"Press any key to continue...", 0&gt;.dataprompt BYTE pressKey</code></pre><p>【示例 2】假设想定义一个符号来计算一个 10 x 10 整数矩阵的元素个数。现在用两种不同的方法来进行符号定义，一种用整数表达式，一种用文本。然后把两个符号都用于数据定义：</p><pre><code>matrix1 EQU 10 * 10matrix2 EQU &lt;10 * 10&gt;.dataM1 WORD matrix1M2 WORD matrix2</code></pre><p>汇编器将为 M1 和 M2 生成不同的数据定义。计算 matrix1 中的整数表达式，并将其赋给M1。而 matrix2 中的文本则直接复制到 M2 的数据定义中：</p><pre><code>M1 WORD 100M2 WORD 10 * 10</code></pre><p>与 = 伪指令不同，在同一源代码文件中，<strong>用 EQU 定义的符号不能被重新定义</strong>。这个限制可以防止现有符号在无意中被赋予新值。</p><h2 id="汇编语言TEXTEQU伪指令"><a href="#汇编语言TEXTEQU伪指令" class="headerlink" title="汇编语言TEXTEQU伪指令"></a>汇编语言TEXTEQU伪指令</h2><p>TEXTEQU 伪指令，类似于 EQU，创建了文本宏（text macro）。它有 3 种格式：第一种为名称分配的是文本；第二种分配的是已有文本宏的内容；第三种分配的是整数常量表达式：</p><pre><code>name TEXTEQU &lt;text&gt;name TEXTEQU textmacroname TEXTEQU %constExpr</code></pre><p>例如，变量 prompt1 使用了文本宏 continueMsg：</p><pre><code>continueMsg TEXTEQU &lt;"Do you wish to continue (Y/N)?"&gt;.dataprompt1 BYTE continueMsg</code></pre><p>文本宏可以相互构建。如下例所示，count 被赋值了一个整数表达式，其中包含 rowSize。然后，符号 move 被定义为 mov。最后，用 move 和 count 创建 setupAL:</p><pre><code>rowSize = 5count TEXTEQU %(rowSize * 2)move TEXTEQU &lt;mov&gt;setupAL TEXTEQU &lt;move al,count&gt;</code></pre><p>因此，语句</p><pre><code>setupAL</code></pre><p>就会被汇编为</p><pre><code>mov al,10</code></pre><p>用 TEXTEQU 定义的符号随时可以被重新定义。</p><h2 id="汇编语言64位编程"><a href="#汇编语言64位编程" class="headerlink" title="汇编语言64位编程"></a>汇编语言64位编程</h2><p>MD 和 Intel 64 位处理器的出现增加了对 64 位编程的兴趣。MASM 支持 64 位代码，所有的 Visual Studio 2012 版本（最终版、高级版和专业版）以及桌面系统的 Visual Studio 2012 Express 都会同步安装 64 位版本的汇编器。</p><p>现在借助《数据定义》一节中给出的 AddTwoSum 程序，将其改为 64 位编程：</p><pre><code>;AddTowSum_64.asmExitProcess PROTO.datasum DWORD 0.codemain PROC    mov eax,5    add eax,6    mov sum,eaxmov eax,0    call ExitProcessmain ENDPEND</code></pre><p>上述程序与之前给出的 32 位版本不同之处如下所示：</p><p>\1) 32 位 AddTwoSum 程序中使用了下列三行代码，而 64 位版本中则没有：</p><pre><code>.386.model flat,stdcall.stack 4096</code></pre><p>\2) 64 位程序中，使用 PROTO 关键字的语句不带参数，如第 3 行代码所示：</p><pre><code>ExitProcess PROTO</code></pre><p>32 位版本代码如下：</p><pre><code>ExitProcess PROTO,dwExitCode:DWORD</code></pre><p>\3) 14〜15 行使用了两条指令（mov 和 call）来结束程序。32 位版本则只使用了一条 INVOKE 语句实现同样的功能。64 位 MASM 不支持 INVOKE 伪指令。</p><p>\4) 在第 17 行，END 伪指令没有指定程序入口点，而 32 位程序则指定了。</p><h4 id="使用-64-位寄存器"><a href="#使用-64-位寄存器" class="headerlink" title="使用 64 位寄存器"></a>使用 64 位寄存器</h4><p>在某些应用中，可能需要实现超过 32 位的整数的算术运算。在这种情况下，可以使用 64 位寄存器和变量。例如，下述步骤让示例程序能使用 64 位数值：</p><ul><li><p>在第 6 行，定义 sum 变量时，把 DWORD 修改为 QWORD。</p></li><li><p>在 10〜12 行，把 EAX 替换为其 64 位版本 RAX。</p></li></ul><p>下面是修改后的 6〜12 行：</p><pre><code>sum DWORD 0.codemain PROC   mov rax,5   add rax,6   mov sum,rax</code></pre><p>编写 32 位还是 64 位汇编程序，很大程度上是个人喜好的问题。但是，需要记住：64 位 MASM 11.0 （Visual Studio 2012 附带的）不支持 INVOKE 伪指令。同时，为了运行 64 位程序，必须使用 64 位Windows。</p><h1 id="汇编语言数据相关的运算符、指令和算术运算"><a href="#汇编语言数据相关的运算符、指令和算术运算" class="headerlink" title="汇编语言数据相关的运算符、指令和算术运算"></a>汇编语言数据相关的运算符、指令和算术运算</h1><h2 id="汇编语言操作数类型"><a href="#汇编语言操作数类型" class="headerlink" title="汇编语言操作数类型"></a>汇编语言操作数类型</h2><p>x86 的指令格式为：</p><pre><code>[label:] mnemonic [operands][ ;comment ]</code></pre><p>指令包含的操作数个数可以是：0 个，1 个，2 个或 3 个。这里，为了清晰起见，省略掉标号和注释：</p><pre><code>mnemonicmnemonic [destination]mnemonic [destination] , [source]mnemonic [destination] , [source-1] , [source-2]</code></pre><p>操作数有 3 种基本类型：</p><ul><li><p>立即数——用数字文本表达式</p></li><li><p>寄存器操作数——使用 CPU 内已命名的寄存器</p></li><li><p>内存操作数——引用内存位置</p></li></ul><p>下表说明了标准操作数类型，它使用了简单的操作数符号（32 位模式下），这些符号来自 Intel 手册并进行了改编。本教程将用这些符号来描述每条指令的语法。</p><table><thead><tr><th>操作数</th><th>说明</th></tr></thead><tbody><tr><td>reg8</td><td>8 位通用寄存器：AH、AL、BH、BL、CH、CL、DH、DL</td></tr><tr><td>reg16</td><td>16 位通用寄存器：AX、BX、CX、DX、SI、DI、SP、BP</td></tr><tr><td>reg32</td><td>32 位通用寄存器：EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP</td></tr><tr><td>reg</td><td>通用寄存器</td></tr><tr><td>sreg</td><td>16 位段寄存器：CS、DS、SS、ES、FS、GS</td></tr><tr><td>imm</td><td>8 位、16 位或 32 位立即数</td></tr><tr><td>imm8</td><td>8 位立即数，字节型数值</td></tr><tr><td>imm16</td><td>16 位立即数，字类型数值</td></tr><tr><td>imm32</td><td>32 位立即数，双字型数值</td></tr><tr><td>reg/mem8</td><td>8 位操作数，可以是 8 位通用寄存器或内存字节</td></tr><tr><td>reg/mem16</td><td>16 位立即数，可以是 16 位通用寄存器或内存字</td></tr><tr><td>reg/mem32</td><td>32 位立即数，可以是 32 位通用寄存器或内存双字</td></tr><tr><td>mem</td><td>8位、16 位或 32 位内存操作数</td></tr></tbody></table><h3 id="直接内存操作数"><a href="#直接内存操作数" class="headerlink" title="直接内存操作数"></a>直接内存操作数</h3><p>变量名引用的是数据段内的偏移量。例如，如下变量 varl 的声明表示，该变量的大小类型为字节，值为十六进制的10：</p><pre><code>.datavar1 BYTE 10h</code></pre><p>可以编写指令，通过内存操作数的地址来解析（查找）这些操作数。假设 var1 的地址偏移量为 10400h。如下指令将该变量的值复制到 AL 寄存器中：</p><pre><code>mov al var1</code></pre><p>指令会被汇编为下面的机器指令：</p><pre><code>A0 00010400</code></pre><p>这条机器指令的第一个字节是操作代码（即操作码（opcode））。剩余部分是 var1 的 32 位十六进制地址。虽然编程时有可能只使用数字地址，但是如同 var1 一样的符号标号会让使用内存更加容易。</p><p>另一种表示法。一些程序员更喜欢使用下面这种直接操作数的表达方式，因为，括号意味着解析操作：</p><pre><code>mov al, [var1]</code></pre><p>MASM 允许这种表示法，因此只要愿意就可以在程序中使用。由于多数程序（包括 Microsoft 的程序）印刷时都没有用括号，所以，本书只在出现算术表达式时才使用这种带括号的表示法：</p><pre><code>mov al,[var1 + 5]</code></pre><h2 id="汇编语言MOV指令：将源操作数复制到目的操作数"><a href="#汇编语言MOV指令：将源操作数复制到目的操作数" class="headerlink" title="汇编语言MOV指令：将源操作数复制到目的操作数"></a>汇编语言MOV指令：将源操作数复制到目的操作数</h2><p>MOV 指令将源操作数复制到目的操作数。作为数据传送（data transfer）指令，它几乎用在所有程序中。在它的基本格式中，第一个操作数是目的操作数，第二个操作数是源操作数：</p><pre><code>MOV destination,source</code></pre><p>其中，目的操作数的内容会发生改变，而源操作数不会改变。这种数据从右到左的移动与 C++ 或 Java 中的赋值语句相似：</p><pre><code>dest = source;</code></pre><p>在几乎所有的汇编语言指令中，左边的操作数是目标操作数，而右边的操作数是源操作数。只要按照如下原则，MOV 指令使用操作数是非常灵活的。</p><ul><li><p>两个操作数必须是同样的大小。</p></li><li><p>两个操作数不能同时为内存操作数。</p></li><li><p>指令指针寄存器（IP、EIP 或 RIP）不能作为目标操作数。</p></li></ul><p>下面是 MOV 指令的标准格式：</p><pre><code>MOV reg, regMOV mem, regMOV reg, memMOV mem, immMOV reg, imm</code></pre><h4 id="内存到内存"><a href="#内存到内存" class="headerlink" title="内存到内存"></a>内存到内存</h4><p>单条 MOV 指令不能用于直接将数据从一个内存位置传送到另一个内存位置。相反，在将源操作数的值赋给内存操作数之前，必须先将该数值传送给一个寄存器：</p><pre><code>.datavar1 WORD ?var2 WORD ?.codemov ax,var1mov var2,ax</code></pre><blockquote><p>提示：在将整型常数复制到一个变量或寄存器时，必须考虑该常量需要的最少字节数。</p></blockquote><h4 id="覆盖值"><a href="#覆盖值" class="headerlink" title="覆盖值"></a>覆盖值</h4><p>下述代码示例演示了怎样通过使用不同大小的数据来修改同一个 32 位寄存器。当 oneWord 字传送到 AX 时，它就覆盖了 AL 中已有的值。当 oneDword 传送到 EAX 时，它就覆盖了 AX 的值。最后，当 0 被传送到 AX 时，它就覆盖了 EAX 的低半部分。</p><pre><code>.dataoneByte BYTE 78honeWord WORD 1234honeDword DWORD 12345678h.codemov eax,0                                 ;EAX=OOOOOOOOhmov al,oneByte                            ;EAX=00000078hmov ax,oneWord                            ;EAX=00001234hmov eax,oneDword                          ;EAX=12345678hmov ax, 0                                 ;EAX=12340000h</code></pre><h2 id="汇编语言MOVZX和MOVSX指令"><a href="#汇编语言MOVZX和MOVSX指令" class="headerlink" title="汇编语言MOVZX和MOVSX指令"></a>汇编语言MOVZX和MOVSX指令</h2><p>尽管 MOV 指令不能直接将较小的操作数复制到较大的操作数中，但是程序员可以想办法解决这个问题。假设要将 count（无符号，16 位）传送到 ECX（32 位），可以先将 ECX 设置为 0，然后将 count 传送到 CX：</p><pre><code>.datacount WORD 1.codemov ecx,0mov cx,count</code></pre><p>如果对一个有符号整数 -16 进行同样的操作会发生什么呢？</p><pre><code>.datasignedVal SWORD -16      ; FFF0h （-16）.codemov ecx,0mov cx,signedVal         ; ECX = 0000FFF0h（+ 65,52 0）</code></pre><p>ECX 中的值（+65 520）与 -16 完全不同。但是，如果先将 ECX 设置为 FFFFFFFFh，然后再把 signedVal 复制到 CX，那么最后的值就是完全正确的：</p><pre><code>mov ecx,0FFFFFFFFhmov cx,signedVal    ;ECX = FFFFFFF0h（-16）</code></pre><p>本例的有效结果是用源操作数的最高位（1）来填充目的操作数 ECX 的高 16 位，这种技术称为符号扩展（sign extension）。当然，不能总是假设源操作数的最高位是 1。幸运的是，Intel 的工程师在设计指令集时已经预见到了这个问题，因此，设置了 MOVZX 和 MOVSX 指令来分别处理无符号整数和有符号整数。</p><h3 id="MOVZX-指令"><a href="#MOVZX-指令" class="headerlink" title="MOVZX 指令"></a>MOVZX 指令</h3><p>MOVZX 指令（进行全零扩展并传送）将源操作数复制到目的操作数，并把目的操作数 0 扩展到 16 位或 32 位。这条指令只用于无符号整数，有三种不同的形式：</p><pre><code>MOVZX reg32,reg/mem8MOVZX reg32,reg/mem16MOVZX reg16,reg/mem8</code></pre><p>在三种形式中，第一个操作数（寄存器）是目的操作数，第二个操作数是源操作数。注意，源操作数不能是常数。下例将二进制数 1000 1111 进行全零扩展并传送到 AX：</p><pre><code>.databyteVal BYTE 10001111b.codemovzx ax,byteVal ;AX = 0000000010001111b</code></pre><p>下图展示了如何将源操作数进行全零扩展，并送入 16 位目的操作数。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722365952879" alt="img"></p><p>下面例子的操作数是各种大小的寄存器：</p><pre><code>mov bx, 0A69Bhmovzx eax, bx     ;EAX = 0000A69Bhmovzx edx, bl     ;EDX = 0000009Bhmovzx cx, bl     ;CX = 009Bh</code></pre><p>下面例子的源操作数是内存操作数，执行结果是一样的：</p><pre><code>.databyte1 BYTE  9Bhword1 WORD 0A69Bh.codemovzx eax, word1 ;EAX = 0000A69Bhmovzx edx, byte1 ;EDX = 0000009Bhmovzx ex, byte1     ;CX = 009Bh</code></pre><h3 id="MOVSX-指令"><a href="#MOVSX-指令" class="headerlink" title="MOVSX 指令"></a>MOVSX 指令</h3><p>MOVSX 指令（进行符号扩展并传送）将源操作数内容复制到目的操作数，并把目的操作数符号扩展到 16 位或 32 位。这条指令只用于有符号整数，有三种不同的形式：</p><pre><code>MOVSX reg32, reg/mem8MOVSX reg32, reg/mem16MOVSX reg16, reg/mem8</code></pre><p>操作数进行符号扩展时，在目的操作数的全部扩展位上重复（复制）长度较小操作数的最高位。下面的例子是将二进制数 1000 1111b 进行符号扩展并传送到 AX：</p><pre><code>.databyteVal BYTE 10001111b.codemovsx ax,byteVal      ;AX = 1111111110001111b</code></pre><p>如下图所示，复制最低 8 位，同时，将源操作数的最高位复制到目的操作数高 8 位的每一位上。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722367434481" alt="img"></p><p>如果一个十六进制常数的最大有效数字大于 7，那么它的最高位等于 1。如下例所示，传送到 BX 的十六进制数值为 A69B，因此，数字“A”就意味着最高位是 1。（A69B 前面的 0 是一种方便的表示法，用于防止汇编器将常数误认为标识符。）</p><h2 id="汇编语言LAHF和SAHF指令"><a href="#汇编语言LAHF和SAHF指令" class="headerlink" title="汇编语言LAHF和SAHF指令"></a>汇编语言LAHF和SAHF指令</h2><p>LAHF（加载状态标志位到 AH）指令将 EFLAGS 寄存器的低字节复制到 AH。被复制的标志位包括：符号标志位、零标志位、辅助进位标志位、奇偶标志位和进位标志位。使用这条指令，可以方便地把标志位副本保管在变量中：</p><pre><code>.datasaveflags BYTE ?.codelahf                      ;将标志位加载到 AHmov saveflags, ah         ;用变量保存这些标志位</code></pre><p>SAHF（保存 AH 内容到状态标志位）指令将 AH 内容复制到 EFLAGS（或 RFLAGS）寄存器低字节。例如，可以检索之前保存到变量中的标志位数值：</p><pre><code>mov ah, saveflags  ;加载被保存标志位到 AHsahf                        ;复制到 FLAGS 寄存器</code></pre><h2 id="汇编语言XCHG指令：交换两个操作数内容"><a href="#汇编语言XCHG指令：交换两个操作数内容" class="headerlink" title="汇编语言XCHG指令：交换两个操作数内容"></a>汇编语言XCHG指令：交换两个操作数内容</h2><p>XCHG（交换数据）指令交换两个操作数内容。该指令有三种形式：</p><pre><code>XCHG reg, regXCHG reg, memXCHG mem, reg</code></pre><p>除了 XCHG 指令不使用立即数作操作数之外，XCHG 指令操作数的要求与《MOV指令》一节中介绍的 MOV 指令操作数要求是一样的。</p><p>在数组排序应用中，XCHG 指令提供了一种简单的方法来交换两个数组元素。下面是几个使用 XCHG 指令的例子。</p><pre><code>xchg ax,bx      ;交换 16 位寄存器内容xchg ah,al      ;交换 8 位寄存器内容xchg var1,bx    ;交换 16 位内存操作数与 BX 寄存器内容xchg eax,ebx    ;交换 32 位寄存器内容</code></pre><p>如果要交换两个内存操作数，则用寄存器作为临时容器，把 MOV 指令与 XCHG 指令一起使用：</p><pre><code>mov ax,val1xchg ax,val2mov val1,ax</code></pre><h2 id="汇编语言直接偏移量操作数"><a href="#汇编语言直接偏移量操作数" class="headerlink" title="汇编语言直接偏移量操作数"></a>汇编语言直接偏移量操作数</h2><p>变量名加上一个位移就形成了一个直接 - 偏移量操作数。这样可以访问那些没有显式标记的内存位置。假设现有一个字节数组 arrayB：</p><pre><code>arrayB BYTE 10h,20h,30h,40h,50h</code></pre><p>用该数组作为 MOV 指令的源操作数，则自动传送数组的第一个字节：</p><pre><code>mov al,arrayB         ;AL = 10h</code></pre><p>通过在 arrayB 偏移量上加 1 就可以访问该数组的第二个字节：</p><pre><code>mov al,[arrayB+1]      ;AL = 20h</code></pre><p>如果加 2 就可以访问该数组的第三个字节：</p><pre><code>mov al,[arrayB+2]      ;AL = 30h</code></pre><p>形如 arrayB+1 一样的表达式通过在变量偏移量上加常数来形成所谓的有效地址。有效地址外面的括号表明，通过解析这个表达式就可以得到该内存地址指示的内容。汇编器并不要求在地址表达式之外加括号，但为了清晰明了，建议使用括号。</p><p>MASM 没有内置的有效地址范围检查。在下面的例子中，假设数组 arrayB 有 5 个字节，而指令访问的是该数组范围之外的一个内存字节。其结果是一种难以发现的逻辑错误，因此，在检查数组引用时要非常小心：</p><pre><code>mov al, [arrayB+20]              ; AL = ??</code></pre><h4 id="字和双字数组"><a href="#字和双字数组" class="headerlink" title="字和双字数组"></a>字和双字数组</h4><p>在 16 位的字数组中，每个数组元素的偏移量比前一个多 2 个字节。这就是为什么在下面的例子中，数组 ArrayW 加 2 才能指向该数组的第二个元素：</p><pre><code>.dataarrayW WORD 100h,200h,300h.codemov ax, arrayW                               ;AX = 100hmov ax,[arrayW+2]                            ;AX = 200h</code></pre><p>同样，如果是双字数组，则第一个元素偏移量加 4 才能指向第二个元素：</p><pre><code>.dataarrayD DWORD l0000h,20000h.codemov eax, arrayD                            ;EAX = 10000hmov eax,[arrayD+4]                         ;EAX = 20000h</code></pre><h2 id="汇编语言数据传送示例"><a href="#汇编语言数据传送示例" class="headerlink" title="汇编语言数据传送示例"></a>汇编语言数据传送示例</h2><p>该程序中包含了到此介绍的所有指令，包括：MOV、XCHG、MOVSX 和 MOVZX，展示了字节、字和双字是如何受到它们的影响。同时，程序中还包括了一些直接 - 偏移量操作数。</p><pre><code>;数据传送示例.386.model flat,stdcall.stack 4096ExitProcess PROTO,dwExitCode:DWORD.dataval1 WORD 1000hval2 WORD 2000harrayB BYTE 10h,20h,30h,40h,50harrayW WORD 100h,200h,300harrayD DWORD 10000h,20000h.codemain PROC;演示 MOVZX 指令    mov bx,0A69Bh    movzx eax,bx        ;EAX = 0000A69Bh    movzx edx,bl        ;EDX = 0000009Bh    movzx cx,bl         ;CX     = 009Bh;演示 MOVSX 指令    mov bx,0A69Bh    movsx eax,bx        ;EAX = FFFFA69Bh    movsx edx,bl        ;EDX = FFFFFF9Bh    mov bl,7Bh    movsx cx,bl         ;CX = 007Bh;内存-内存的交换    mov ax,val1         ;AX = 1000h    xchg ax val2        ;AX = 2000h,val2 = 1000h    mov val1,ax         ;val1 = 2000h;直接-偏移量寻址（字节数组）    mov al,arrayB        ;AL = 10h    mov al,[arrayB+1]    ;AL = 20h    mov al,[arrayB+2]    ;AL = 30h;直接-偏移量寻址（字数组）    mov ax,arrayW        ;AX = 100h    mov ax,[arrayW+2]    ;AX = 200h;直接-偏移量寻址（双字数组）    mov eax,arrayD        ;EAX = 10000h    mov eax,[arrayD+4]    ;EAX = 20000h    mov eax,[arrayD+4]    ;EAX = 20000h    INVOKE ExitProcess,0main ENDPEND main</code></pre><p>该程序不会产生屏幕输出，但是可以用调试器（debugger）运行。</p><h4 id="在-Visual-Studio-调试器中显示-CPU-标志位"><a href="#在-Visual-Studio-调试器中显示-CPU-标志位" class="headerlink" title="在 Visual Studio 调试器中显示 CPU 标志位"></a>在 Visual Studio 调试器中显示 CPU 标志位</h4><p>在调试期间显示 CPU 状态标志位时，在 Debug 菜单中选择 Windows 子菜单，再选择 Register。在 Register 窗口，右键选择下拉列表中的 Flags。要想查看这些菜单选项，必须调试程序。下表是 Register 窗口中用到的标志位符号：</p><table><thead><tr><th>标志名称</th><th>溢岀</th><th>方向</th><th>中断</th><th>符号</th><th>零</th><th>辅助进位</th><th>奇偶</th><th>进位</th></tr></thead><tbody><tr><td>符号</td><td>OV</td><td>UP</td><td>EI</td><td>PL</td><td>ZR</td><td>AC</td><td>PE</td><td>CY</td></tr></tbody></table><p>每个标志位有两个值：0（清除）或 1（置位）。示例如下:</p><pre><code>OV = 0    UP = 0     EI = 1PL = 0   ZR = 1   AC = 0PE = 1   CY = 0   </code></pre><p>调试程序期间，当逐步执行代码时，指令只要修改了标志位的值，则标志位就会显示为红色。这样就可以通过单步执行来了解指令是如何影响标志位的，并可以密切关注这些标志位值的变化。</p><h2 id="汇编语言加法和减法详解"><a href="#汇编语言加法和减法详解" class="headerlink" title="汇编语言加法和减法详解"></a>汇编语言加法和减法详解</h2><p>先从最简单、最有效的指令开始：INC（增加）和 DEC（减少）指令，即加 1 和减 1。然后是能提供更多操作的 ADD、SUB 和 NEG（非）指令。最后，将讨论算术运算指令如何影响 CPU 状态标志位（进位位、符号位、零标志位等）。请记住，汇编语言的细节很重要。</p><h3 id="INC-和-DEC-指令"><a href="#INC-和-DEC-指令" class="headerlink" title="INC 和 DEC 指令"></a>INC 和 DEC 指令</h3><p>INC（增加）和DEC（减少）指令分别表示寄存器或内存操作数加 1 和减 1。语法如下所示：</p><pre><code>INC reg/memDEC reg/mem</code></pre><p>下面是一些例子：</p><pre><code>.datamyWord WORD 1000h.codeinc myWord                         ; myWord = 1001hmov bx,myWorddec bx                             ; BX = 1000h</code></pre><p>根据目标操作数的值，溢岀标志位、符号标志位、零标志位、辅助进位标志位、进位标志位和奇偶标志位会发生变化。INC 和 DEC 指令不会影响进位标志位（这还真让人吃惊）。</p><h3 id="ADD-指令"><a href="#ADD-指令" class="headerlink" title="ADD 指令"></a>ADD 指令</h3><p>ADD 指令将长度相同的源操作数和目的操作数进行相加操作。语法如下：</p><pre><code>ADD dest,source</code></pre><p>在操作中，源操作数不能改变，相加之和存放在目的操作数中。该指令可以使用的操作数与 MOV 指令相同。下面是两个 32 位整数相加的短代码示例：</p><pre><code>.datavar1 DWORD 10000hvar2 DWORD 20000h.codemov eax,var1    ； EAX = 10000hadd eax,var2    ； EAX = 30000h</code></pre><p>标志位：进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位和奇偶标 志位根据存入目标操作数的数值进行变化。</p><h3 id="SUB-指令"><a href="#SUB-指令" class="headerlink" title="SUB 指令"></a>SUB 指令</h3><p>SUB 指令从目的操作数中减去源操作数。该指令对操作数的要求与 ADD 和 MOV 指令相同。指令语法如下：</p><pre><code>SUB dest, source</code></pre><p>下面是两个 32 位整数相减的短代码示例：</p><pre><code>.datavar1 DWORD 30000hvar2 DWORD 10000h.codemov eax,var1         ;EAX = 30000hsub eax,var2         ;EAX = 20000h</code></pre><p>标志位：进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位和奇偶标 志位根据存入目标操作数的数值进行变化。</p><h3 id="NEG-指令"><a href="#NEG-指令" class="headerlink" title="NEG 指令"></a>NEG 指令</h3><p>NEG（非）指令通过把操作数转换为其二进制补码，将操作数的符号取反。下述操作数可以用于该指令：</p><pre><code>NEG regNEG mem</code></pre><blockquote><p>提示：将目标操作数按位取反再加 1，就可以得到这个数的二进制补码。</p></blockquote><p>标志位：进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位和奇偶标志位根据存入目标操作数的数值进行变化。</p><h3 id="执行算术表达式"><a href="#执行算术表达式" class="headerlink" title="执行算术表达式"></a>执行算术表达式</h3><p>使用 ADD、SUB 和 NEG 指令，就有办法来执行汇编语言中的算术表达式，包括加法、减法和取反。换句话说，当有下述表达式时，就可以模拟 C++ 编译器的行为：</p><pre><code>Rval = -Xval + (Yval - Zval);</code></pre><p>现在来看看，使用如下有符号 32 位变量，汇编语言是如何执行上述表达式的。</p><pre><code>Rval SDWORD ?Xval SDWORD 26Yval SDWORD 30Zval SDWORD 40</code></pre><p>转换表达式时，先计算每个项，最后再将所有项结合起来。首先，对 Xval 的副本进行取反，并存入寄存器：</p><pre><code>; first term： -Xvalmov eax,Xvalneg eax                            ; EAX = -26</code></pre><p>然后，将 Yval 复制到寄存器中，再减去 Zval：</p><pre><code>; second term： （Yval - Zval）mov ebx,Yvalsub ebx,Zval                    ; EBX = -10</code></pre><p>最后，将两个项（EAX 和 EBX 的内容）相加：</p><pre><code>; add the terms and store:add eax,ebxmov Rval,eax                    ; -36</code></pre><h3 id="加减法影响的标志位"><a href="#加减法影响的标志位" class="headerlink" title="加减法影响的标志位"></a>加减法影响的标志位</h3><p>执行算术运算指令时，常常想要了解结果。它是负数、正数还是零？对目的操作数来说，它是太大，还是太小？这些问题的答案有助于发现计算错误，否则可能会导致程序的错误行为。</p><p>检查算术运算结果使用的是 CPU 状态标志位的值，同时，这些值还可以触发条件分支指令，即基本的程序逻辑工具。下面是对状态标志位的简要概述：</p><ul><li><p>进位标志位意味着无符号整数溢出。比如，如果指令目的操作数为 8 位，而指令产生的结果大于二进制的 1111 1111，那么进位标志位置 1。</p></li><li><p>溢出标志位意味着有符号整数溢出。比如，指令目的操作数为 16 位，但其产生的负数结果小于十进制的 -32 768，那么溢出标志位置 1。</p></li><li><p>零标志位意味着操作结果为 0。比如，如果两个值相等的操作数相减，则零标志位置 1。</p></li><li><p>符号标志位意味着操作产生的结果为负数。如果目的操作数的最高有效位（MSE）置 1，则符号标志位置 1。</p></li><li><p>奇偶标志位是指，在一条算术或布尔运算指令执行后，立即判断目的操作数最低有效字节中 1 的个数是否为偶数。</p></li><li><p>辅助进位标志位置 1，意味着目的操作数最低有效字节中位 3 有进位。</p></li></ul><p>要在调试时显示 CPU 状态标志位，打开 Register 窗口，右键点击该窗口，并选择 Flags。</p><h4 id="1-无符号数运算：零标志位、进位标志位和辅助进位标志位"><a href="#1-无符号数运算：零标志位、进位标志位和辅助进位标志位" class="headerlink" title="1) 无符号数运算：零标志位、进位标志位和辅助进位标志位"></a>1) 无符号数运算：零标志位、进位标志位和辅助进位标志位</h4><p>当算术运算结果等于 0 时，零标志位置 1。下面的例子展示了执行 SUB、INC 和 DEC 指令后，目的寄存器和零标志位的状态：</p><pre><code>mov ecx,1sub ecx,1                          ;ECX = 0, ZF = 1mov eax,0FFFFFFFFhinc    eax                         ;EAX =    0,    ZF    =    1inc    eax                         ;EAX =    1,    ZF    =    0dec    eax                         ;EAX =    0,    ZF    =    1</code></pre><p>加法和进位标志位，如果将加法和减法分开考虑，那么进位标志位的操作是最容易解释的。两个无符号整数相加时，进位标志位是目的操作数最高有效位进位的副本。直观地说，如果和数超过了目的操作数的存储大小，就可以认为 CF = 1。在下面的例子里，ADD 指令将进位标志位置 1，原因是，相加的和数（100h）超过了 AL 的大小：</p><pre><code>mov al,0FFhadd al,1              ; AL = 00, CF = 1</code></pre><p>下图演示了在 0FFh 上加 1 时，操作数的位是如何变化的。AL 最高有效位的进位复制到进位 标志位。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722376326983" alt="img"></p><p>另一方面，如果 AX 的值为 00FFh，则对其进行加 1 操作后，和数不会超过 16 位，那么进位标志位清 0：</p><pre><code>mov ax,00FFhadd ax, 1           ; AX = 0100h, CF = 0</code></pre><p>但是，如果 AX 的值为 FFFFh，则对其进行加 1 操作后，AX 的高位就会产生进位：</p><pre><code>mov ax,0FFFFhadd ax, 1           ; AX = 0000, CF = 1</code></pre><p>减法和进位标志位，从较小的无符号整数中减去较大的无符号整数时，减法操作就会将进位标志位置 1。下图说明了，操作数为 8 位时，计算（1-2）会出现什么情况。下面是相应的汇编代码：</p><pre><code>mov al, 1sub al, 2            ; AL = FFh, CF = 1</code></pre><p><img src="/images/loading.gif" data-original="images/asm-language/-162722378015785" alt="img"></p><blockquote><p>提示：INC 和 DEC 指令不会影响进位标志位。在非零操作数上应用 NEG 指令总是会将进位标志位置 1。</p></blockquote><p>辅助进位标志位，辅助进位（AC）标志位意味着目的操作数位 3 有进位或借位。它主要用于二进制编码的十进制数（BCD）运算，也可以用于其他环境。现在，假设计算（1+0Fh），和数在位 4 上为 1，这是位 3 的进位：</p><pre><code>mov al,0Fhadd al, 1           ; AC = 1</code></pre><p>计算过程如下：</p><pre><code>   00001111+  00000001--------------   00010000</code></pre><p>奇偶标志位，目的操作数最低有效字节中 1 的个数为偶数时，奇偶（PF）标志位置 1。下例中，ADD 和 SUB 指令修改了 AL 的奇偶性：</p><pre><code>mov al,10001100badd al,00000010b    ; AL = 10001110, PF = 1sub al,10000000b    ; AL = 00001110, PF = 0</code></pre><p>执行了 ADD 指令后，AL 的值为 1000 1110 （4 个 0, 4 个 1）, PF=1。执行了 SUB 指令后，AL 的值包含了奇数个 1，因此奇偶标志位等于 0。</p><h4 id="2-有符号数运算：符号标志位和溢出标志位"><a href="#2-有符号数运算：符号标志位和溢出标志位" class="headerlink" title="2) 有符号数运算：符号标志位和溢出标志位"></a>2) 有符号数运算：符号标志位和溢出标志位</h4><p>符号标志位，有符号数算术操作结果为负数，则符号标志位置 1。下面的例子展示的是小数（4）减去大数（5）：</p><pre><code>mov eax, 4sub eax,5        ; EAX = -1, SP = 1</code></pre><p>从机器的角度来看，符号标志位是目的操作数高位的副本。下面的例子表示产生了负数结果后，BL 中的十六进制的值：</p><pre><code>mov bl,1        ; BL = 01hsub bl,2        ; BL = FFh（-1）, SF = 1</code></pre><p>溢出标志位，有符号数算术操作结果与目的操作数相比，如果发生上溢或下溢，则溢出标志位置 1。例如，8 位有符号整数的最大值为 +127，再加 1 就会溢出：</p><pre><code>mov al,+127add al, 1       ; OF = 1</code></pre><p>同样，最小的负数为-128,再减1就发生下溢。如果目的操作数不能容纳一个有效算 术运算结果，那么溢出标志位置 1：</p><pre><code>mov al,-128sub al,1        ;OF = 1</code></pre><p>加法测试，两数相加时，有个很简单的方法可以判断是否发生溢出。溢出发生的情况有：</p><ul><li><p>两个正数相加，结果为负数</p></li><li><p>两个负数相加，结果为正数</p></li></ul><p>如果两个加数的符号相反，则不会发生溢出。</p><p>硬件如何检测溢出，加法或减法操作后，CPU 用一种有趣的机制来检测溢出标志位的状态。计算结果的最高有效位产生的进位与结果的最高位进行 异或操作，异或的结果存入溢岀标志位。如下图所示，两个 8 位二进制数 1000 0000 和 1111 1110 相加，产生进位 CF=1，和数最高位（位 7）= 0，即 1 XOR 0=1，则 OF=1。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722379913787" alt="img"></p><p>NEG 指令，如果 NEG 指令的目的操作数不能正确存储，则该结果是无效的。例如， AL 中存放的是 -128，对其求反，正确的结果为 +128，但是这个值无法存入 AL。则溢出标志位置 1 就表示 AL 中存放的是一个无效的结果：</p><pre><code>mov al,-128         ;AL = 10000000bneg al              ;AL = 10000000b, OF = 1</code></pre><p>反之，如果对 +127 求反，结果是有效的，则溢出标志位清 0：</p><pre><code>mov al,+127         ;AL = 01111111bneg al              ;AL = 10000001b, OF = 0</code></pre><p>CPU 如何知道一个算术运算是有符号的还是无符号的？答案看上去似乎有点愚蠢：它不知道！在算术运算之后，不论标志位是否与之相关，CPU 都会根据一组布尔规则来设置所有的状态标志位。程序员要根据执行操作的类型，来决定哪些标志位需要分析，哪些可以忽略。</p><h3 id="示例程序（AddSubTest）"><a href="#示例程序（AddSubTest）" class="headerlink" title="示例程序（AddSubTest）"></a>示例程序（AddSubTest）</h3><p>AddSubTest 程序利用 ADD、SUB、INC、DEC 和 NEG 指令执行各种算术运算表达式，并展示了相关状态标志位是如何受到影响的：</p><pre><code>;加法和减法   （AddSubTest.asm）.386.model flat,stdcall.stack 4096ExitProcess proto,dwExitCode:dword.dataRval    SDWORD ?Xval    SDWORD 26Yval    SDWORD 30Zval    SDWORD 40.codemain PROC    ;INC和DEC    mov    ax,1000h    inc    ax        ;1001h    dec    ax        ;1000h    ;表达式：Rval=-Xval+(Yval-Zval)    mov    eax,Xval    neg    eax        ;-26    mov    ebx,Yval    sub    ebx,Zval   ;-10    add    eax,ebx    mov    Rval,eax;36    ;零标志位示例    mov    cx,1    sub    cx,1       ;ZF = 1    mov    ax,0FFFFh    inc    ax         ;ZF = 1    ;符号标志位示例    mov    cx,0    sub    cx,1       ;SF = 1    mov    ax,7FFFh    add    ax,2       ;SF = 1    ;进位标志位示例    mov    al,0FFh    add    al,1       ;CF = 1,AL = 00    ;溢出标志位示例    mov    al,+127    add    al,1       ;OF = 1    mov    al,-128    sub    al,1       ;OF = 1    INVOKE ExitProcess,0main ENDPEND main</code></pre><h2 id="汇编语言OFFSET运算符：返回数据标号的偏移量"><a href="#汇编语言OFFSET运算符：返回数据标号的偏移量" class="headerlink" title="汇编语言OFFSET运算符：返回数据标号的偏移量"></a>汇编语言OFFSET运算符：返回数据标号的偏移量</h2><p>OFFSET 运算符返回数据标号的偏移量。这个偏移量按字节计算，表示的是该数据标号距离数据段起始地址的距离。如下图所示为数据段内名为 myByte 的变量。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722381694389" alt="img"></p><h3 id="OFFSET-示例"><a href="#OFFSET-示例" class="headerlink" title="OFFSET 示例"></a>OFFSET 示例</h3><p>在下面的例子中，将用到如下三种类型的变量：</p><pre><code>.databVal BYTE ?wVal WORD ?dVal DWORD ?dVal2 DWORD ?</code></pre><p>假设 bVal 在偏移量为 0040 4000（十六进制）的位置，则 OFFSET 运算符返回值如下：</p><pre><code>mov esi,OFFSET bVal             ; ESI = 00404000hmov esi,OFFSET wVal             ; ESI = 00404001hmov esi,OFFSET dVal             ; ESI = 00404003hmov esi,OFFSET dVal2            ; ESI = 00404007h</code></pre><p>OFFSET 也可以应用于直接 - 偏移量操作数。设 myArray 包含 5 个 16 位的字。下面的 MOV 指令首先得到 myArray 的偏移量，然后加 4，再将形成的结果地址直接传送给 ESI。因此，现在可以说 ESI 指向数组中的第 3 个整数。</p><pre><code>.datamyArray WORD 1,2,3,4,5.codemov esi,OFFSET myArray + 4</code></pre><p>还可以用一个变量的偏移量来初始化另一个双字变量，从而有效地创建一个指针。如下例所示，pArray 就指向 bigArray 的起始地址：</p><pre><code>.databigArray DWORD 500 DUP (?)pArray DWORD bigArray</code></pre><p>下面的指令把该指针的值加载到 ESI 中，因此，这个 ESI 寄存器就可以指向数组的起始地址：</p><pre><code>mov esi,pArray</code></pre><h2 id="汇编语言ALIGN伪指令：对齐一个变量"><a href="#汇编语言ALIGN伪指令：对齐一个变量" class="headerlink" title="汇编语言ALIGN伪指令：对齐一个变量"></a>汇编语言ALIGN伪指令：对齐一个变量</h2><p>ALIGN 伪指令将一个变量对齐到字节边界、字边界、双字边界或段落边界。</p><p>语法如下：</p><pre><code>ALIGN bound</code></pre><p>Bound 可取值有：1、2、4、8、16。当取值为 1 时，则下一个变量对齐于 1 字节边界（默认情况）。当取值为 2 时，则下一个变量对齐于偶数地址。当取值为 4 时，则下一个变量地址为 4 的倍数。当取值为 16 时，则下一个变量地址为 16 的倍数，即一个段落的边界。</p><p>为了满足对齐要求，汇编器会在变量前插入一个或多个空字节。为什么要对齐数据？因为，对于存储于偶地址和奇地址的数据来说，CPU 处理偶地址数据的速度要快得多。</p><p>下述例子中，bVal 处于任意位置，但其偏移量为 0040 4000。在 wVal 之前插入 ALIGN 2 伪指令，这使得 wVal 对齐于偶地址偏移量：</p><pre><code>bVal BYTE ?           ;00404000hALIGN 2 wVal WORD ?           ;00404002hbVal2 BYTE ?          ;00404004hALIGN 4 dVal DWORD ?          ;00404008hdVal2 DWORD ?         ;0040400Ch</code></pre><p>请注意，dVal 的偏移量原本是 0040 4005，但是 ALIGN 4 伪指令使它的偏移量成为 0040 4008。</p><h2 id="汇编语言PTR运算符：重写操作数的大小类型"><a href="#汇编语言PTR运算符：重写操作数的大小类型" class="headerlink" title="汇编语言PTR运算符：重写操作数的大小类型"></a>汇编语言PTR运算符：重写操作数的大小类型</h2><p>PTR 运算符可以用来重写一个已经被声明过的操作数的大小类型。只要试图用不同于汇编器设定的大小属性来访问操作数，那么这个运算符就是必需的。</p><p>例如，假设想要将一个双字变量 myDouble 的低 16 位传送给 AX 由于操作数大小不匹配，因此，汇编器不会允许这种操作：</p><pre><code>.datamyDouble DWORD 12345678h.codemov ax,myDouble</code></pre><p>但是，使用 WORD PTR 运算符就能将低位字（5678h）送入 AX：</p><pre><code>mov ax,WORD PTR myDouble</code></pre><p>为什么送入 AX 的不是 1234h ？因为，x86 处理器采用的是小端存储格式，即低位字节存放于变量的起始地址。如下图所示，用三种方式表示 myDouble 的内存布局：第一列是一个双字，第二列是两个字（5678h、1234h），第三列是四个字节（78h、56h、34h、12h）。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722383732791" alt="img"></p><p>不论该变量是如何定义的，都可以用三种方法中的任何一种来访问内存。比如，如果 myDouble 的偏移量为 0000，则以这个偏移量为首地址存放的 16 位值是 5678h。同时也可以检索到 1234h，其字地址为 myDouble+2，指令如下：</p><pre><code>mov ax,WORD PTR [myDouble+2]     ; 1234h</code></pre><p>同样，用 BYTE PTR 运算符能够把 myDouble 的单个字节传送到 BL：</p><pre><code>mov b1,BYTE PTR myDouble       ; 78h</code></pre><p>注意，PTR 必须与一个标准汇编数据类型一起使用，这些类型包括：BYTE、SEYTE、WORD、SWORD、DWORD、SDWORD、FWORD、QWORD 或 TBYTE。</p><h4 id="将较小的值送入较大的目的操作数"><a href="#将较小的值送入较大的目的操作数" class="headerlink" title="将较小的值送入较大的目的操作数"></a>将较小的值送入较大的目的操作数</h4><p>程序可能需要将两个较小的值送入一个较大的目的操作数。如下例所示，第一个字复制到 EAX 的低半部分，第二个字复制到高半部分。而 DWORD PTR 运算符能实现这种操作：</p><pre><code>.datawordList WORD 5678h,1234h.codemov eax, DWORD PTR wordList      ; EAX = 12345678h</code></pre><h2 id="汇编语言TYPE运算符：返回变量的大小"><a href="#汇编语言TYPE运算符：返回变量的大小" class="headerlink" title="汇编语言TYPE运算符：返回变量的大小"></a>汇编语言TYPE运算符：返回变量的大小</h2><p>TYPE 运算符返回变量单个元素的大小，这个大小是以字节为单位计算的。比如，TYPE 为字节，返回值是 1；TYPE 为字，返回值是 2；TYPE 为双字，返回值是 4；TYPE 为四字，返回值是 8。示例如下：</p><pre><code>.datavar1 BYTE ?var2 WORD ?var3 DWORD ?var4 QWORD ?</code></pre><p>下表是每个 TYPE 表达式的值。</p><table><thead><tr><th>表达式</th><th>值</th><th>表达式</th><th>值</th></tr></thead><tbody><tr><td>TYPE var1</td><td>1</td><td>TYPE var3</td><td>4</td></tr><tr><td>TYPE var2</td><td>2</td><td>TYPE var4</td><td>8</td></tr></tbody></table><h2 id="汇编语言LENGTHOF运算符：计算数组中元素的个数"><a href="#汇编语言LENGTHOF运算符：计算数组中元素的个数" class="headerlink" title="汇编语言LENGTHOF运算符：计算数组中元素的个数"></a>汇编语言LENGTHOF运算符：计算数组中元素的个数</h2><p>LENGTHOF 运算符计算数组中元素的个数，元素个数是由数组标号同一行出现的数值来定义的。示例如下：</p><pre><code>.data byte1 BYTE  10,20,30array1 WORD  30 DUP (?),0,0array2 WORD 5 DUP(3 DUP(?))array3 DWORD 1,2,3,4digitStr  BYTE "12345678",0</code></pre><p>如果数组定义中出现了嵌套的 DUP 运算符，那么 LENGTHOF 返回的是两个数值的乘积。下表列出了每个 LENGTHOF 表达式返回的数值。</p><table><thead><tr><th>表达式</th><th>值</th><th>表达式</th><th>值</th></tr></thead><tbody><tr><td>LENGTHOF byte1</td><td>3</td><td>LENGTHOF array3</td><td>4</td></tr><tr><td>LENGTHOF array1</td><td>30+2</td><td>LENGTHOF digitStr</td><td>9</td></tr><tr><td>LENGTHOF array2</td><td>5*3</td><td></td><td></td></tr></tbody></table><p>如果数组定义占据了多个程序行，那么 LENGTHOF 只针对第一行定义的数据。比如有如下数据，则 LENGTHOF myArray 返回值为 5 :</p><pre><code>myArray BYTE 10,20,30,40,50        BYTE 60,70,80,90,100</code></pre><p>另外，也可以在第一行结尾处用逗号，并在下一行继续进行数组初始化。若有如下数据定义， LENGTHOF myArray 返回值为 10：</p><pre><code>myArray BYTE 10,20,30,40,50,             60,70,80,90,100</code></pre><h2 id="汇编语言LABEL伪指令"><a href="#汇编语言LABEL伪指令" class="headerlink" title="汇编语言LABEL伪指令"></a>汇编语言LABEL伪指令</h2><p>LABEL 伪指令可以插入一个标号，并定义它的大小属性，但是不为这个标号分配存储空间。LABEL 中可以使用所有的标准大小属性，如 BYTE、WORD、DWORD、QWORD 或 TBYTE。</p><p>LABEL 常见的用法是，为数据段中定义的下一个变量提供不同的名称和大小属性。如下例所示，在变量 val32 前定义了一个变量，名称为 val16 属性为 WORD：</p><pre><code>.dataval16 LABEL WORDval32 DWORD 12345678h.codemov ax,val16          ; AX = 5678hmov dx,[val16+2]      ; DX = 1234h</code></pre><p>val16 与 val32 共享同一个内存位置。LABEL 伪指令自身不分配内存。</p><p>有时需要用两个较小的整数组成一个较大的整数，如下例所示，两个 16 位变量组成一个 32 位变量并加载到 EAX 中：</p><pre><code>.dataLongValue LABEL DWORDval1 WORD 5678hval2 WORD 1234h.codemov eax,LongValue         ; EAX = 12345678h</code></pre><h2 id="汇编语言间接寻址"><a href="#汇编语言间接寻址" class="headerlink" title="汇编语言间接寻址"></a>汇编语言间接寻址</h2><p>直接寻址很少用于数组处理，因为，用常数偏移量来寻址多个数组元素时，直接寻址不实用。反之，会用寄存器作为指针（称为间接寻址）并控制该寄存器的值。如果一个操作数使用的是间接寻址，就称之为间接操作数。</p><h3 id="间接操作数"><a href="#间接操作数" class="headerlink" title="间接操作数"></a>间接操作数</h3><h4 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h4><p>任何一个 32 位通用寄存器（EAX、EBX、ECX、EDX、ESI、EDI、EBP 和 ESP）加上括号就能构成一个间接操作数。</p><p>寄存器中存放的是数据的地址。示例如下，ESI 存放的是 byteVal 的偏移量，MOV 指令使用间接操作数作为源操作数，解析 ESI 中的偏移量，并将一个字节送入 AL：</p><pre><code>.databyteVal BYTE 10h.codemov esi,OFFSET byteValmov al,[esi]                              ; AL = 10h</code></pre><p>如果目的操作数也是间接操作数，那么新值将存入由寄存器提供地址的内存位置。在下面的例子中，BL 寄存器的内容复制到 ESI 寻址的内存地址中：</p><pre><code>mov [esi],bl</code></pre><h4 id="PTR-与间接操作数一起使用"><a href="#PTR-与间接操作数一起使用" class="headerlink" title="PTR 与间接操作数一起使用"></a>PTR 与间接操作数一起使用</h4><p>一个操作数的大小可能无法从指令中直接看出来。下面的指令会导致汇编器产生“operand must have size（操作数必须有大小）”的错误信息：</p><pre><code>inc [esi]    ;错误：operand must have size</code></pre><p>汇编器不知道 ESI 指针的类型是字节、字、双字，还是其他的类型。而 PTR 运算符则可以确定操作数的大小类型：</p><pre><code>inc BYTE PTR [esi]</code></pre><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>间接操作数是步进遍历数组的理想工具。下例中，arrayB 有 3 个字节，随着 ESI 不断加 1，它就能顺序指向每一个字节：</p><pre><code>.dataarrayB BYTE 10h,20h,30h.codemov esi,OFFSET arrayBmov al [esi]                        ;AL = lOhinc esimov al, [esi]                        ;AL = 20hinc esimov al, [esi]                        ;AL = 30h</code></pre><p>如果数组是 16 位整数类型，则 ESI 加 2 就可以顺序寻址每个数组元素：</p><pre><code>.dataarrayW WORD 1000h,2000h,3000h.codemov esi,OFFSET arrayWmov ax,[esi]                         ; AX = 1000hadd esi, 2mov ax,[esi]                         ; AX = 2000hadd esi, 2mov axz [esi]                        ; AX = 3000h</code></pre><p>假设 arrayW 的偏移量为 10200h，下图展示的是 ESI 初始值相对数组数据的位置。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722386993093" alt="img"></p><p>示例：32 位整数相加下面的代码示例实现的是 3 个双字相加。由于双字是 4 个字节的，因此，ESI 要加 4 才能顺序指向每个数组数值：</p><pre><code>.dataarrayD DWORD 10000h,20000h,30000h.codemov esi,OFFSET arrayDmov eax, [esi]                  ;（第一个数）add esi, 4add eax, [esi]                   ;（第二个数）add esi, 4add eax, [esi]                   ;（第三个数）</code></pre><p>假设 arrayD 的偏移量为 10200h。下图展示的是 ESI 初始值相对数组数据的位置：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722389365195" alt="img"></p><h3 id="变址操作数"><a href="#变址操作数" class="headerlink" title="变址操作数"></a>变址操作数</h3><p>变址操作数是指，在寄存器上加上常数产生一个有效地址。每个 32 位通用寄存器都可以用作变址寄存器。MASM 可以用不同的符号来表示变址操作数（括号是表示符号的一部分）：</p><pre><code>constant [reg][constant + reg]</code></pre><p>第一种形式是变量名加上寄存器。变量名由汇编器转换为常数，代表的是该变量的偏移量。下面给岀的是两种符号形式的例子：</p><table><thead><tr><th>arrayB[esi]</th><th>[arrayB + esi]</th></tr></thead><tbody><tr><td>arrayD[ebx]</td><td>[arrayD + ebx]</td></tr></tbody></table><p>变址操作数非常适合于数组处理。在访问第一个数组元素之前，变址寄存器需要初始化为 0：</p><pre><code>.dataarrayB BYTE 10h,20h,30h.codemov esi, 0mov al, arrayB[esi]                ; AL = 10h</code></pre><p>最后一条语句将 ESI 和 arrayB 的偏移量相加，表达式 [arrayB+ESI] 产生的地址被解析，并将相应内存字节的内容复制到AL。</p><p>增加位移量变址寻址的第二种形式是寄存器加上常数偏移量。变址寄存器保存数组或结构的基址，常数标识各个数组元素的偏移量。下例展示了在一个 16 位字数组中如何使用这种形式：</p><pre><code>.dataarrayW WORD 1000h,2000h,3000h.codemov esi,OFFSET arrayWmov ax, [esi]                   ;AX = 1000hmov ax, [esi+2]                 ;AX = 2000hmov ax, [esi+4]                 ;AX = 3000h</code></pre><h4 id="使用-16-位寄存器"><a href="#使用-16-位寄存器" class="headerlink" title="使用 16 位寄存器"></a>使用 16 位寄存器</h4><p>在实地址模式中，一般用 16 位寄存器作为变址操作数。在这种情况下，能被使用的寄存器只有 SI、DI、BX 和 BP：</p><pre><code>mov al,arrayB[si]mov ax,arrayW[di]mov eax,arrayD[bx]</code></pre><p>如果有间接操作数，则要避免使用 BP 寄存器，除非是寻址堆栈数据。</p><h4 id="变址操作数中的比例因子"><a href="#变址操作数中的比例因子" class="headerlink" title="变址操作数中的比例因子"></a>变址操作数中的比例因子</h4><p>在计算偏移量时，变址操作数必须考虑每个数组元素的大小。比如下例中的双字数组，下标（3 ）要乘以 4（一个双字的大小）才能生成内容为 400h 的数组元素的偏移量：</p><pre><code>.dataarrayD DWORD 100h, 200h, 300h, 400h.codemov esi , 3 * TYPE arrayD                            ; arrayD [ 3 ]的偏移量mov eax,arrayD[esi]                                  ; EAX = 400h</code></pre><p>Intel 设计师希望能让编译器编写者的常用操作更容易，因此，他们提供了一种计算偏移量的方法，即使用比例因子。比例因子是数组元素的大小（字 = 2，双字 =4，四字 =8）。现在对刚才的例子进行修改，将数组下标（3）送入 ESI，然后 ESI 乘以双字的比例因子（4）：</p><pre><code>.dataarrayD DWORD 1,2,3,4.code mov esi, 3                               ;下标mov eax,arrayD[esi*4]                    ;EAX = 4</code></pre><p>TYPE 运算符能让变址更加灵活，它可以让 arrayD 在以后重新定义为别的类型：</p><pre><code>mov esi, 3                         ;下标 mov eax,arrayD[esi*TYPE arrayD]    ;EAX = 4</code></pre><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>如果一个变量包含另一个变量的地址，则该变量称为指针。指针是控制数组和数据结构的重要工具，因为，它包含的地址在运行时是可以修改的。比如，可以使用系统调用来分配（保留）一个内存块，再把这个块的地址保存在一个变量中。</p><p>指针的大小受处理器当前模式（32位或64位）的影响。下例为 32 位的代码，ptrB 包含了 arrayB 的偏移量：</p><pre><code>.dataarrayB byte 10h,20h,30h,40hptrB dword arrayB</code></pre><p>还可以用 OFFSET 运算符来定义 ptrB，从而使得这种关系更加明确：</p><pre><code>ptrB dword OFFSET arrayB</code></pre><p>32 位模式程序使用的是近指针，因此，它们保存在双字变量中。这里有两个例子：ptrB 包含 arrayB 的偏移量，ptrW 包含 arrayW 的偏移量：</p><pre><code>arrayB BYTE 10h,20h,30h,40harrayW WORD 1000h,2000h,3000hptrB    DWORD arrayBptrW    DWORD arrayW</code></pre><p>同样，也还可以用 OFFSET 运算符使这种关系更加明确：</p><pre><code>ptrB DWORD OFFSET arrayBptrW DWORD OFFSET arrayW</code></pre><p>高级语言刻意隐藏了指针的物理细节，这是因为机器结构不同，指针的实现也有差异。汇编语言中，由于面对的是单一实现，因此是在物理层上检查和使用指针。这样有助于消除围绕着指针的一些神秘感。</p><h4 id="使用-TYPEDEF-运算符"><a href="#使用-TYPEDEF-运算符" class="headerlink" title="使用 TYPEDEF 运算符"></a>使用 TYPEDEF 运算符</h4><p>TYPEDEF 运算符可以创建用户定义类型，这些类型包含了定义变量时内置类型的所有状态。它是创建指针变量的理想工具。比如，下面声明创建的一个新数据类型 PBYTE 就是一个字节指针：</p><p>PBYTE TYPEDEF PTR BYTE</p><p>这个声明通常放在靠近程序开始的地方，在数据段之前。然后，变量就可以用 PBYTE 来定义：</p><pre><code>.dataarrayB BYTE 10h,20h,30h,40hptr1 PBYTE ?                              ;未初始化ptr2 PBYTE arrayB                     ;指向一个数组</code></pre><h4 id="示例程序：Pointers"><a href="#示例程序：Pointers" class="headerlink" title="示例程序：Pointers"></a>示例程序：Pointers</h4><p>下面的程序（pointers.asm）用 TYPEDEF 创建了 3 个指针类型（PBYTE、PWORD、PDWORD）。此外，程序还创建了几个指针，分配了一些数组偏移量，并解析了这些指针：</p><pre><code>TITLE Pointers            (Pointers.asm).386.model flat,stdcall.stack 4096ExitProcess proto,dwExitCode:dword;创建用户定义类型PBYTE TYPEDEF PTR BYTE                ;字节指针PWORD TYPEDEF PTR WORD                ;字指针PDWORD TYPEDEF PTR DWORD            ;双字指针.dataarrayB BYTE 10h,20h,30harrayW WORD 1,2,3arrayD DWORD 4,5,6;创建几个指针变量ptr1 PBYTE arrayBptr2 PWORD arrayWptr3 PDWORD arrayD.codemain PROC;使用指针访问数据    mov esi,ptr1    mov al,[esi]                    ;10h    mov esi,ptr2    mov ax,[esi]                    ;1    mov esi,ptr3    mov eax,[esi]                    ;4    invoke ExitProcess,0main ENDPEND main</code></pre><h2 id="汇编语言JMP和LOOP（转移）指令"><a href="#汇编语言JMP和LOOP（转移）指令" class="headerlink" title="汇编语言JMP和LOOP（转移）指令"></a>汇编语言JMP和LOOP（转移）指令</h2><p>默认情况下，CPU 是顺序加载并执行程序。但是，当前指令有可能是有条件的，也就是说，它按照 CPU 状态标志（零标志、符号标志、进位标志等）的值，把控制转向程序中的新位置。</p><p>汇编语言程序使用条件指令来实现如 IF 语句的高级语句与循环。每条条件指令都包含了一个可能的转向不同内存地址的转移（跳转）。控制转移，或分支，是一种改变语句执行顺序的方法，它有两种基本类型：</p><ul><li><p>无条件转移：无论什么情况都会转移到新地址。新地址加载到指令指针寄存器，使得程序在新地址进行执行。JMP 指令实现这种转移。</p></li><li><p>条件转移：满足某种条件，则程序出现分支。各种条件转移指令还可以组合起来，形成条件逻辑结构。CPU 基于 ECX 和标志寄存器的内容来解释真 / 假条件。</p></li></ul><h3 id="JMP-指令"><a href="#JMP-指令" class="headerlink" title="JMP 指令"></a>JMP 指令</h3><p>JMP 指令无条件跳转到目标地址，该地址用代码标号来标识，并被汇编器转换为偏移 量。语法如下所示：</p><pre><code>JMP destination</code></pre><p>当 CPU 执行一个无条件转移时，目标地址的偏移量被送入指令指针寄存器，从而导致迈从新地址开始继续执行。</p><p>JMP 指令提供了一种简单的方法来创建循环，即跳转到循环开始时的标号：</p><pre><code>top:    .    .    jmp top     ;不断地循环</code></pre><p>JMP 是无条件的，因此循环会无休止地进行下去，除非找到其他方法退岀循环。</p><h3 id="LOOP-指令"><a href="#LOOP-指令" class="headerlink" title="LOOP 指令"></a>LOOP 指令</h3><p>LOOP 指令，正式称为按照 ECX 计数器循环，将程序块重复特定次数。ECX 自动成为计数器，每循环一次计数值减 1。语法如下所示：</p><pre><code>LOOP destination</code></pre><p>循环目标必须距离当前地址计数器 -128 到 +127 字节范围内。LOOP 指令的执行有两个步骤：</p><ul><li><p>第一步，ECX 减 1。</p></li><li><p>第二步，将 ECX 与 0 比较。</p></li></ul><p>如果 ECX 不等于 0，则跳转到由目标给出的标号。否则，如果 ECX 等于 0，则不发生跳转，并将控制传递到循环后面的指令。</p><p>实地址模式中，CX 是 LOOP 指令的默认循环计数器。同时，LOOPD 指令使用 ECX 为循环计数器，LOOPW 指令使用 CX 为循环计数器。</p><p>下面的例子中，每次循环是将 AX 加 1。当循环结束时，AX=5, ECX=0：</p><pre><code>    mov ax,0    mov ecx,5L1:    inc ax    loop L1</code></pre><p>一个常见的编程错误是，在循环开始之前，无意间将 ECX 初始化为 0。如果执行了这个操作，LOOP 指令将 ECX 减 1 后，其值就为 FFFFFFFFh，那么循环次数就变成了 4 294 967 296！如果计数器是 CX （实地址模式下），那么循环次数就为 65 536。</p><p>有时，可能会创建一个太大的循环，以至于超过了 LOOP 指令允许的相对跳转范围。下面给出是 MASM 产生的一条错误信息，其原因就是 LOOP 指令的跳转目标太远了：</p><pre><code>error A2075: jump destination too far : by 14 byte(s)</code></pre><p>基本上，在一个循环中不用显式的修改 ECX，否则，LOOP 指令可能无法正常工作。下例中，每次循环 ECX 加 1。这样 ECX 的值永远不能到 0，因此循环也永远不会停止：</p><pre><code>top:    .    .    inc ecx    loop top</code></pre><p>如果需要在循环中修改 ECX，可以在循环开始时，将 ECX 的值保存在变量中，再在 LOOP 指令之前恢复被保存的计数值：</p><pre><code>.datacount DWORD ?.code    mov ecx, 100        ;设置循环计数值top:    mov count, ecx      ;保存计数值    .    mov ecx, 20         ;修改 ECX    .    mov ecx, count      ;恢复计数值    loop top循环嵌套</code></pre><p>当在一个循环中再创建一个循环时，就必须特别考虑外层循环的计数器 ECX，可以将它保存在一个变量中：</p><pre><code>.datacount DWORD ?.code    mov ecx, 100    ;设置外层循环计数值L1:    mov count, ecx  ;保存外层循环计数值    mov ecx, 20     ;设置内层循环计数值L2 :    loop L2         ;重复内层循环    mov ecx, count  ;恢复外层循环计数值    loop L1         ;重复外层循环</code></pre><blockquote><p>提示：作为一般规则，多于两重的循环嵌套难以编写。如果使用的算法需要多重循环，则将一些内层循环用子程序来实现。</p></blockquote><h3 id="在-Visual-Studio-调试器中显示数组"><a href="#在-Visual-Studio-调试器中显示数组" class="headerlink" title="在 Visual Studio 调试器中显示数组"></a>在 Visual Studio 调试器中显示数组</h3><p>在调试期间，如果想要显示数组的内容，步骤如下：选择 Debug 菜单 -&gt; 选择 Windows -&gt; 选择 Memory -&gt; 选择Memory 1。则出现内存窗口，可以用鼠标拖动并停靠在 Visual Studio 工作区的任何一边。还可以右键点击该窗口的标题栏，表明要这个窗口浮动在编辑窗口之上。</p><p>在内存窗口上端的 Address 栏里， 键入 &amp; 符号和数组名称，然后点击 Enter。比如，&amp;myArray 就是一个有效的地址表达式。内存窗口将显示从这个数组地址开始的内存块，如下图所示。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722394684997" alt="img"></p><p>如果数组的值是双字，可以在内存窗口中，点击右键并在弹出菜单里选择 4-byte integer。还有不同的格式可供选择，包括 Hexadecimal Display,Signed Display（有符号显示），和 Unsigned Display（无符号显示）。下图显示了所有的选项。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-162722396582199" alt="img"></p><h3 id="整数数组求和"><a href="#整数数组求和" class="headerlink" title="整数数组求和"></a>整数数组求和</h3><p>在刚开始编程时，几乎没有任务比计算数组元素总和更常见了。汇编语言实现数组求和步骤如下：</p><ul><li><p>指定一个寄存器作变址操作数，存放数组地址。</p></li><li><p>循环计数器初始化为数组的长度。</p></li><li><p>指定一个寄存器存放累积和数，并赋值为0。</p></li><li><p>创建标号来标记循环开始的地方。</p></li><li><p>在循环体内，将和数与一个数组元素相加。</p></li><li><p>指向下一个数组元素。</p></li><li><p>用LOOP指令重复循环。</p></li></ul><p>步骤 1 到步骤 3 可以按照任何顺序执行。下面的短程序实现对一个 16 位整数数组求和。</p><pre><code>; 数组求和（SumArray. asm）.386.model flat,stdcall.stack 4096ExitProcess proto,dwExitCode:dword.dataintarray DWORD 10000h,20000h,30000h,40000h.codemain PROC    mov edi, OFFSET intarray   ; 1: EDI=intarray 地址    mov ecx, LENGTHOF intarray ; 2 :循环计数器初始化    mov    eax,0               ; 3:    sum=0L1:                            ; 4：标记循环开始的地方    add    eax,    [edi]       ; 5：加一个整数    add edi, TYPE intarray     ; 6：指向下一个元素    loop    L1                 ; 7：重复，直到 ECX=0    invoke ExitProcess, 0main ENDPEND main</code></pre><h3 id="复制字符串"><a href="#复制字符串" class="headerlink" title="复制字符串"></a>复制字符串</h3><p>程序常常要将大块数据从一个位置复制到另一个位置。这些数据可能是数组或字符串，但是它们可以包括任何类型的对象。</p><p>现在看看在汇编语言中如何实现这种操作，用循环来复制一个字符串，而字符串表示为带有一个空终止值的字节数组。变址寻址很适合于这种操作，因为可以用同一个变址寄存器来引用两个字符串。目标字符串必须有足够的空间来接收 被复制的字符，包括最后的空字节：</p><pre><code>;复制字符串    （CopyStr.asm）.386.model flat,stdcall.stack 4096ExitProcess proto,dwExitCode:dword.datasource BYTE "This is the source string", 0target BYTE SIZEOF source DUP(0).codemain PROC    mov    esi, 0                      ;变址寄存器    mov ecx, SIZEOF source             ;循环计数器L1：                                   ;从源字符串获取一个字符    mov    al, source [esi]            ;保存到目标字符串    mov target [esi] , al              ;指向下一个字符    inc esi                            ;重复，直到整个字符串完成    loop L1    invoke ExitProcess,0main ENDPEND main</code></pre><p>MOV 指令不能同时有两个内存操作数，所以，每个源字符串字符送入 AL，然后再从 AL 送入目标字符串。</p><h2 id="汇编语言64位MOV指令"><a href="#汇编语言64位MOV指令" class="headerlink" title="汇编语言64位MOV指令"></a>汇编语言64位MOV指令</h2><p>64 位模式下的 MOV 指令与 32 位模式下的有很多共同点，只有几点区别，现在讨论一下。立即操作数（常数）可以是 8 位、16 位、32 位或 64 位。下面为一个 64 位示例：</p><pre><code>mov rax, 0ABCDEF0AFFFFFFFFh ; 64 位立即操作数</code></pre><p>当一个 32 位常数送入 64 位寄存器时，目标操作数的高 32 位（位 32—位 63）被清除（等于 0）：</p><pre><code>mov rax, 0FFFFFFFFh ;rax = 00000000FFFFFFFF</code></pre><p>向 64 位寄存器送入 16 位或 8 位常数，其高位也要清零：</p><pre><code>mov rax, 06666h  ;清位 16—位 63mov rax, 055h      ;清位 8—位 63</code></pre><p>如果将内存操作数送入 64 位寄存器，则结果是确定的。比如，传送一个 32 位内存操作数到 EAX（RAX 寄存器的低半部分），就会清除 RAX 的高 32 位：</p><pre><code>.datamyDword DWORD 80000000h.codemov rax,0FFFFFFFFFFFFFFFFhmov eax,myDword                     ; RAX = 0000000080000000</code></pre><p>但是，如果是将 8 位或 16 位内存操作数送入 RAX 的低位，那么，目标寄存器的高位不受影响：</p><pre><code>.datamyByte BYTE 55hmyWord WORD 6666h.codemov ax,myWord                ;位 16—位 63 不受影响mov al, myByte                  ;位 8—位 63 不受影响</code></pre><p>MOVSXD 指令（符号扩展传送）允许源操作数为 32 位寄存器或内存操作数。下面的指令使得 RAX 的值为 FFFFFFFFFFFFFFFFh：</p><pre><code>mov ebx, 0FFFFFFFFhmovsxd rax,ebx</code></pre><p>OFFSET 运算符产生 64 位地址，必须用 64 位寄存器或变量来保存。下例中使用的是 RSI 寄存器：</p><pre><code>.datamyArray WORD 10,20,30,40.codemov rsi,OFFSET myArray64 位模式中，LOOP 指令用 RCX 作为循环计数器。</code></pre><p>有了这些基本概念，就可以编写许多 64 位模式程序了。大多数情况下，如果一直使用 64 位整数变量或 64 位寄存器，那么编程比较容易。ASCII 码字符串是一种特殊情况，因为它们总是包含字节。一般在处理时，采用间接或变址寻址。</p><h2 id="汇编语言64位加法和减法"><a href="#汇编语言64位加法和减法" class="headerlink" title="汇编语言64位加法和减法"></a>汇编语言64位加法和减法</h2><p>如同 32 位模式下一样，ADD、SUB、INC 和 DEC 指令在 64 位模式下，也会影响 CPU 状态标志位。在下面的例子中，RAX 寄存器存放一个 32 位数，执行加 1，每一位都向左产生一个进位，因此，在位 32 生成 1：</p><pre><code>mov rax, 0FFFFFFFFh ;低 32 位是全 1add rax,1           ; RAX = 100000000h</code></pre><p>需要时刻留意操作数的大小，当操作数只使用部分寄存器时，要注意寄存器的其他部分是没有被修改的。如下例所示，AX 中的 16 位总和翻转为全 0，但是不影响 RAX 的高位。这是因为该操作只使用 16 位寄存器（AX 和 BX）：</p><pre><code>mov rax,0FFFFh        ; RAX = 000000000000FFFFmov bx, 1add ax,bx             ; RAX = 0000000000000000</code></pre><p>同样，在下面的例子中，由于 AL 中的进位不会进入 RAX 的其他位，所以执行 ADD 指令后，RAX 等于 0：</p><pre><code>mov rax,0FFh         ; RAX = 00000000000000FFmov bl, 1add al,bl            ; RAX = 0000000000000000</code></pre><p>减法也使用相同的原则。在下面的代码段中，EAX 内容为 0，对其进行减 1 操作，将会使得 RAX 低32位变为 -1（FFFFFFFFh）。同样，AX 内容为 0，对其进行减 1 操作，使得 RAX 低 16 位等于 -1（FFFFh）。</p><pre><code>mov rax,0               ; RAX = 0000000000000000mov ebx, 1sub eax,ebx             ; RAX = 00000000FFFFFFFFmov rax,0               ; RAX = 0000000000000000mov bx,1sub ax,bx               ; RAX = 000000000000FFFF</code></pre><p>当指令包含间接操作数时，必须使用 64 位通用寄存器。记住，一定要使用 PTR 运算符来明确目标操作数的大小。下面是一些包含了 64 位目标操作数的例子：</p><pre><code>dec BYTE PTR [rdi]              ;8 位目标操作数inc WORD PTR [rbx]              ;16 位目标操作数inc QWORD PTR [rsi]             ;64 位目标操作数</code></pre><p>64 位模式下，可以对间接操作数使用比例因子，就像在 32 位模式下一样。如下例所示，如果处理的是 64 位整数数组，比例因子就是 8：</p><pre><code>.dataarray QWORD 1,2,3,4.codemov esi, 3                   ;下标mov rax,array[rsi*8]         ; RAX = 4</code></pre><p>64 位模式的指针变量包含的是 64 位偏移量。在下面的例子中，ptrB 变量包含了数组 B 的偏移量：</p><pre><code>.dataarrayB BYTE 10h, 20h, 30h, 40hptrB QWORD arrayB</code></pre><p>或者，还可以用 OFFSET 运算符来定义 ptrB，使得这个关系更加明确：</p><pre><code>ptrB QWORD OFFSET arrayB</code></pre><h1 id="汇编语言过程"><a href="#汇编语言过程" class="headerlink" title="汇编语言过程"></a>汇编语言过程</h1><h2 id="汇编语言堆栈简介"><a href="#汇编语言堆栈简介" class="headerlink" title="汇编语言堆栈简介"></a>汇编语言堆栈简介</h2><p>如下图所示，如果把 10 个盘子垒起来，其结果就称为堆栈。虽然有可能从这个堆栈的中间移出一个盘子，但是，更普遍的是从顶端移除。新的盘子可以叠加到堆栈顶部，但不能加在底部或中部。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627223990378101" alt="img"></p><p>堆栈数据结构（stack data structure）的原理与盘子堆栈相同：新值添加到栈顶，删除值也在栈顶移除。通常，对各种编程应用来说，堆栈都是有用的结构，并且它们也容易用面向对象的编程方法来实现。</p><p>如果大家已经学习过使用数据结构的编程课程，那么就应该已经用过堆栈抽象数据类型（stack abstract data type）。</p><p>堆栈也被称为 LIFO 结构（后进先出，Last-In First-Out），,其原因是，最后进入堆栈的值也是第一个出堆栈的值。</p><h2 id="汇编语言运行时堆栈（内存数组）"><a href="#汇编语言运行时堆栈（内存数组）" class="headerlink" title="汇编语言运行时堆栈（内存数组）"></a>汇编语言运行时堆栈（内存数组）</h2><p>运行时堆栈是内存数组，CPU 用 ESP（扩展堆栈指针，extended stack pointer）寄存器对其进行直接管理，该寄存器被称为堆栈指针寄存器（stack pointer register）。</p><p>32位模式下，ESP 寄存器存放的是堆栈中某个位置的 32 位偏移量。ESP 基本上不会直接被程序员控制，反之，它是用 CALL、RET、PUSH 和 POP 等指令间接进行修改。</p><p>ESP 总是指向添加，或压入（pushed）到栈顶的最后一个数值。为了便于说明，假设现有一个堆栈，内含一个数值。如下图所示，ESP 的内容是十六进制数 0000 1000，即刚压入堆栈数值（0000 0006）的偏移量。在图中，当堆栈指针数值减少时，栈顶也随之下移。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224003680103" alt="img"></p><p>上图中，每个堆栈位置都是32位长，这 是32位模式下运行程序的情形。</p><p>运行时堆栈工作于系统层，处理子程序调用。堆栈 ADT 是编程结构，通常用高级编程语言编写，如 C++ 或 Java。它用于实现基于后进先出操作的算法。</p><h3 id="入栈操作"><a href="#入栈操作" class="headerlink" title="入栈操作"></a>入栈操作</h3><p>32 位入栈操作把栈顶指针减 4，再将数值复制到栈顶指针指向的堆栈位置。下图展示了把 0000 00A5 压入堆栈的结果，堆栈中已经有一个数值（0000 0006）。注意，ESP 寄存器总是指向最后压入堆栈的数据项。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224014416105" alt="img"></p><p>上图中显示的堆栈顺序与之前示例给出的盘堆栈顺序相反，这是因为运行时堆栈在内存中是向下生长的，即从高地址向低地址扩展。入栈之前， ESP=0000 1000h；入栈之后，ESP=0000 0FFCh。下图显示了同一个堆栈总共压入 4 个整数之后的情况。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224026567107" alt="img"></p><h3 id="出栈操作"><a href="#出栈操作" class="headerlink" title="出栈操作"></a>出栈操作</h3><p>出栈操作从堆栈删除数据。数值弹出堆栈后，栈顶指针增加（按堆栈元素大小），指向堆栈中下一个最高位置。下图展示了数值 0000 0002 弹出前后的堆栈情况。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224038465109" alt="img"></p><p>ESP 之下的堆栈域在逻辑上是空白的，当前程序下一次执行任何数值入栈操作指令都可以覆盖这个区域。</p><h3 id="堆栈应用"><a href="#堆栈应用" class="headerlink" title="堆栈应用"></a>堆栈应用</h3><p>运行时堆栈在程序中有一些重要用途：</p><ul><li><p>当寄存器用于多个目的时，堆栈可以作为寄存器的一个方便的临时保存区。在寄存器被修改后，还可以恢复其初始值。</p></li><li><p>执行 CALL 指令时，CPU 在堆栈中保存当前过程的返回地址。</p></li><li><p>调用过程时，输入数值也被称为参数，通过将其压入堆栈实现参数传递。</p></li><li><p>堆栈也为过程局部变量提供了临时存储区域。</p></li></ul><h2 id="汇编语言PUSH和POP指令（压栈和出栈）"><a href="#汇编语言PUSH和POP指令（压栈和出栈）" class="headerlink" title="汇编语言PUSH和POP指令（压栈和出栈）"></a>汇编语言PUSH和POP指令（压栈和出栈）</h2><p>汇编里把一段内存空间定义为一个栈，栈总是先进后出，栈的最大空间为 64K。由于 “栈” 是由高到低使用的，所以新压入的数据的位置更低，ESP 中的指针将一直指向这个新位置，所以 ESP 中的地址数据是动态的。</p><h3 id="PUSH-指令"><a href="#PUSH-指令" class="headerlink" title="PUSH 指令"></a>PUSH 指令</h3><p>PUSH 指令首先减少 ESP 的值，再将源操作数复制到堆栈。操作数是 16 位的，则 ESP 减 2，操作数是 32 位的，则 ESP 减 4。PUSH 指令有 3 种格式：</p><pre><code>PUSH reg/mem16PUSH reg/mem32PUSH inm32</code></pre><h3 id="POP指令"><a href="#POP指令" class="headerlink" title="POP指令"></a>POP指令</h3><p>POP 指令首先把 ESP 指向的堆栈元素内容复制到一个 16 位或 32 位目的操作数中，再增加 ESP 的值。如果操作数是 16 位的，ESP 加 2，如果操作数是 32 位的，ESP 加 4：</p><pre><code>POP reg/mem16POP reg/mem32</code></pre><h3 id="PUSHFD-和-POPFD-指令"><a href="#PUSHFD-和-POPFD-指令" class="headerlink" title="PUSHFD 和 POPFD 指令"></a>PUSHFD 和 POPFD 指令</h3><p>PUSHFD 指令把 32 位 EFLAGS 寄存器内容压入堆栈，而 POPFD 指令则把栈顶单元内容弹出到 EFLAGS 寄存器：</p><pre><code>pushfdpopfd</code></pre><p>不能用 MOV 指令把标识寄存器内容复制给一个变量，因此，PUSHFD 可能就是保存标志位的最佳途径。有些时候保存标志寄存器的副本是非常有用的，这样之后就可以恢复标志寄存器原来的值。通常会用 PUSHFD 和 POPFD 封闭一段代码：</p><pre><code>pushfd          ;保存标志寄存器;;任意语句序列;popfd          ;恢复标志寄存器</code></pre><p>当用这种方式使用入栈和出栈指令时，必须确保程序的执行路径不会跳过 POPFD 指令。当程序随着时间不断修改时，很难记住所有入栈和出栈指令的位置。因此，精确的文档就显得至关重要！</p><p>一种不容易出错的保存和恢复标识寄存器的方法是：将它们压入堆栈后，立即弹出给一个变量：</p><pre><code>.datasaveFlags DWORD ?.codepushfd                    ;标识寄存器内容入栈pop saveFLags             ;复制给一个变量</code></pre><p>下述语句从同一个变量中恢复标识寄存器内容：</p><pre><code>push saveFlags            ;被保存的标识入栈popfd                     ;复制给标识寄存器</code></pre><h3 id="PUSHAD，PUSHA，POPAD-和-POPA"><a href="#PUSHAD，PUSHA，POPAD-和-POPA" class="headerlink" title="PUSHAD，PUSHA，POPAD 和 POPA"></a>PUSHAD，PUSHA，POPAD 和 POPA</h3><p>PUSHAD 指令按照 EAX、ECX、EDX、EBX、ESP（执行 PUSHAD 之前的值）、EBP、ESI 和 EDI 的顺序，将所有 32 位通用寄存器压入堆栈。</p><p>POPAD 指令按照相反顺序将同样的寄存器弹出堆栈。与之相似，PUSHA 指令按序（AX、CX、DX、BX、SP、BP、SI 和 DI）将 16 位通用寄存器压入堆栈。</p><p>POPA 指令按照相反顺序将同样的寄存器弹出堆栈。在 16 位模式下，只能使用 PUSHA 和 POPA 指令。</p><p>如果编写的过程会修改 32 位寄存器的值，则在过程开始时使用 PUSHAD 指令，在结束时使用 POPAD 指令，以此保存和恢复寄存器的内容。示例如下列代码段所示：</p><pre><code>MySub PROC    pushad                 ;保存通用寄存器的内容    .    .    mov eax,...    mov edx,...    mov ecx,...    .    .    popad                   ;恢复通用寄存器的内容    retMySub ENDP</code></pre><p>必须要指岀，上述示例有一个重要的例外：过程用一个或多个寄存器来返回结果时，不应使用 PUSHA 和 PUSHAD。假设下述 ReadValue 过程用 EAX 返回一个整数；调用 POPAD 将会覆盖 EAX 中的返回值：</p><pre><code>ReadValue PROC    pushad                    ;保存通用寄存器的内容    .    .    mov eax rreturn_value    .    .    popad                    ;覆盖 EAX !    retReadValue ENDP</code></pre><p>示例：字符串反转</p><p>现在查看名为 RevStr 的程序：在一个字符串上循环，将每个字符压入堆栈，再把这些字符从堆栈中弹出（相反顺序），并保存回同一个字符串变量。由于堆栈是 LIFO（后进先出）结构，字符串中的字母顺序就发生了翻转：</p><pre><code>;字符串翻转（Revstr.asm）.386.model flat,stdcall.stack 4096ExitProcess PROTO,dwExitCode:DWORD.dataaName BYTE "Abraham Lincoln",0nameSize = ($-aName)-1.codemain PROC;将名字压入堆栈    mov ecx,nameSize    mov esi,0L1:    movzx eax,aName[esi]        ;获取字符    push eax                       ;压入堆栈    inc esi    loop L1;将名字逆序弹出堆栈;并存入aName数组    mov ecx,nameSize    mov esi,0L2:    pop eax                        ;获取字符    mov aName[esi],al                 ;存入字符串    inc esi    loop L2    INVOKE ExitProcess,0main ENDPEND main</code></pre><h2 id="汇编语言PROC和ENDP伪指令：定义一个过程"><a href="#汇编语言PROC和ENDP伪指令：定义一个过程" class="headerlink" title="汇编语言PROC和ENDP伪指令：定义一个过程"></a>汇编语言PROC和ENDP伪指令：定义一个过程</h2><p>在汇编语言中，通常用术语过程（procedure）来指代子程序。在其他语言中，子程序也被称为方法或函数。</p><p>就面向对象编程而言，单个类中的函数或方法大致相当于封装在一个汇编语言模块中的过程和数据集合。汇编语言出现的时间远早于面向对象编程，因此它不具备面向对象编程中的形式化结构。汇编程序员必须在程序中实现自己的形式化结构。</p><h3 id="定义过程"><a href="#定义过程" class="headerlink" title="定义过程"></a>定义过程</h3><p>过程可以非正式地定义为：由返回语句结束的已命名的语句块。过程用 PROC 和 ENDP 伪指令来定义，并且必须为其分配一个名字（有效标识符）。到目前为止，所有编写的程序都包含了一个名为 main 的过程，例如：</p><pre><code>main PROC..main ENDP</code></pre><p>当在程序启动过程之外创建一个过程时，就用 RET 指令来结束它。RET 强制 CPU 返回到该过程被调用的位置：</p><pre><code>sample PROC   .   .   retsample ENDP</code></pre><h3 id="过程中的标号"><a href="#过程中的标号" class="headerlink" title="过程中的标号"></a>过程中的标号</h3><p>默认情况下，标号只在其被定义的过程中可见。这个规则常常影响到跳转和循环指令。在下面的例子中，名为 Destination 的标号必须与 JMP 指令位于同一个过程中：</p><pre><code>jmp Destination</code></pre><p>解决这个限制的方法是定义全局标号，即在名字后面加双冒号 (::)。</p><pre><code>Destination::</code></pre><p>就程序设计而言，跳转或循环到当前过程之外不是个好主意。过程用自动方式返回并调整运行时堆栈。如果直接跳出一个过程，则运行时堆栈很容易被损坏。</p><h3 id="示例：三个整数求和"><a href="#示例：三个整数求和" class="headerlink" title="示例：三个整数求和"></a>示例：三个整数求和</h3><p>现在创建一个名为 SumOf 的过程计算三个 32 位整数之和。假设在过程调用之前，整数已经分配给 EAX、EBX 和 ECX。过程用 EAX 返回和数：</p><pre><code>SumOf PROC    add eax,ebx    add eax,ecx    retSumOf ENDP</code></pre><h3 id="过程说明"><a href="#过程说明" class="headerlink" title="过程说明"></a>过程说明</h3><p>要培养的一个好习惯是为程序添加清晰可读的说明。下面是对放在每个过程开头的信息的一些建议：</p><ul><li><p>对过程实现的所有任务的描述。</p></li><li><p>输入参数及其用法的列表，并将其命名为 Receives ( 接收 )。如果输入参数对其数值有特殊要求，也要在这里列岀来。</p></li><li><p>对过程返回的所有数值的描述，并将其命名为 Returns ( 返回 )。</p></li><li><p>所有特殊要求的列表，这些要求被称为先决条件 (preconditions)，必须在过程被调用之前满足。列表命名为 Requires。例如，对一个画图形线条的过程来说，一个有用的先决条件是该视频显示适配器必须已经处于图形模式。</p></li></ul><p>上述选择的描述性标号，如 ReceivesReturns 和 Requires，不是绝对的；其他有用的名字也常常被使用。</p><p>有了这些思想，现在对 SumOf 过程添加合适的说明：</p><pre><code>;-------------------------------------------------------; sumof; 计算 3 个 32 位整数之和并返回和数。; 接收：EAX、EBX和ECX为3个整数，可能是有符号数，也可能是无符号数。; 返回：EAX=和数;------------------------------------------------------SumOf PROC    add eax,ebx    add eax,ecx    retSumOf ENDP</code></pre><p>用高级语言，如 C 和 C++，编写的函数，通常用 AL 返回 8 位的值，用 AX 返回 16 位的值，用 EAX 返回 32 位的值。</p><h2 id="汇编语言CALL和RET指令：调用一个过程"><a href="#汇编语言CALL和RET指令：调用一个过程" class="headerlink" title="汇编语言CALL和RET指令：调用一个过程"></a>汇编语言CALL和RET指令：调用一个过程</h2><p>CALL 指令调用一个过程，指挥处理器从新的内存地址开始执行。过程使用 RET（从过程返回）指令将处理器转回到该过程被调用的程序点上。</p><p>从物理上来说，CALL 指令将其返回地址压入堆栈，再把被调用过程的地址复制到指令指针寄存器。当过程准备返回时，它的 RET 指令从堆栈把返回地址弹回到指令指针寄存器。32 位模式下，CPU 执行的指令由 EIP（指令指针寄存器）在内存中指岀。16 位模式下，由 IP 指出指令。</p><h3 id="调用和返回示例"><a href="#调用和返回示例" class="headerlink" title="调用和返回示例"></a>调用和返回示例</h3><p>假设在 main 过程中，CALL 指令位于偏移量为 0000 0020 处。通常，这条指令需要 5 个字节的机器码，因此，下一条语句（本例中为一条 MOV 指令）就位于偏移量为 0000 0025 处：</p><pre><code>   main PROC00000020 call MySub00000025 mov eax,ebx</code></pre><p>然后，假设 MySub 过程中第一条可执行指令位于偏移量 0000 0040 处：</p><pre><code>  MySub PROC00000040 mov eaxz edx   .   .   ret  MySub ENDP</code></pre><p>当 CALL 指令执行时如下图所示，调用之后的地址（0000 0025）被压入堆栈，MySub 的地址加载到 EIP。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224084011111" alt="img"></p><p>执行 MySub 中的全部指令直到 RET 指令。当执行 RET 指令时，ESP 指向的堆栈数值被弹岀到 EIP（如下图所示，步骤 1）。在步骤 2 中，ESP 的数值增加，从而指向堆栈中的前一个值（步骤 2）。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224094141113" alt="img"></p><h2 id="汇编语言过程调用嵌套"><a href="#汇编语言过程调用嵌套" class="headerlink" title="汇编语言过程调用嵌套"></a>汇编语言过程调用嵌套</h2><p>被调用过程在返回之前又调用了另一个过程时，就发生了过程调用嵌套。假设 main 调用了过程 Sub1。当 Sub1 执行时，它调用了过程 Sub2。当 Sub2 执行时，它调用了过程 Sub3。步骤如下图所示。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224106158115" alt="img"></p><p>当执行 Sub3 末尾的 RET 指令时，将 stack[ESP]（堆栈段首地址 +ESP 给出的偏移量）中的数值弹出到指令指针寄存器中，这使得执行转回到调用 Sub3 后面的指令。下图显示的是执行从 Sub3 返回操作之前的堆栈：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224116861117" alt="img"></p><p>返回之后，ESP 指向栈顶下一个元素。当 Sub2 末尾的 RET 指令将要执行时，堆栈如下所示：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224127277119" alt="img"></p><p>最后，执行 Sub1 的返回，stack[ESP] 的内容弹出到指令指针寄存器，继续在 main 中执行：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224138623121" alt="img"></p><p>显然，堆栈证明了它很适合于保存信息，包括过程调用嵌套。一般说来，堆栈结构用于程序需要按照特定顺序返回的情况。</p><h3 id="向过程传递寄存器参数"><a href="#向过程传递寄存器参数" class="headerlink" title="向过程传递寄存器参数"></a>向过程传递寄存器参数</h3><p>如果编写的过程要执行一些标准操作，如整数数组求和，那么，在过程中包含对特定变量名的引用就不是一个好主意。如果这样做了，该过程就只能作用于一个数组。更好的方法是向过程传递数组的偏移量以及指定数组元素个数的整数。这些内容被称为参数（或输入参数）。在汇编语言中，经常用通用寄存器来传递参数。</p><p>在《PROC和ENDP伪指令》一节中创建了一个简单的过程 SumOf，计算 EAX、EBX 和 ECX 中的整数之和。在 main 调用 SumOf 之前，将数值分配给 EAX、EBX 和 ECX：</p><pre><code>.datatheSum DWORD ?.codemain PROCmov eax, 10000h          ;参数mov ebx, 20000h          ;参数mov ecx, 30000h          ;参数call Sumof               ;EAX=(EAX+EEX+ECX)mov theSum,eax           ;保存和数</code></pre><p>在 CALL 语句之后，选择了将 EAX 中的和数复制给一个变量。</p><h2 id="汇编语言示例：整数数组求和"><a href="#汇编语言示例：整数数组求和" class="headerlink" title="汇编语言示例：整数数组求和"></a>汇编语言示例：整数数组求和</h2><p>现在创建一个过程 ArraySum，从一个调用程序接收两个参数：一个指向 32 位整数数组的指针，以及一个数组元素个数的计数器。该过程计算和数，并用 EAX 返回数组之和：</p><pre><code>;------------------------------------;ArraySum;计算32位整数数组元素之和;接收：ESI = 数组偏移量;      ECX = 数组元素的个数;返回：EAX = 数组元素之和;-------------------------------------ArraySum PROC    push esi                ;保存ESI和ECX    push ecx    mov eax,0               ;设置和数为0L1：    add eax,[esi]       ;将每个整数与和数相加    add esi,TYPE DWORD      ;指向下一个整数    loop L1                 ;按照数组大小重复    pop ecx                 ;恢复ECX和ESI    pop esi                   ret                     ;和数在EAX中ArraySum ENDP</code></pre><p>这个过程没有特别指定数组名称和大小，它可以用于任何需要计算32位整数数组之和的程序。只要有可能，编程者也应该编写具有灵活性和适应性的程序。</p><h4 id="测试-ArraySum-过程"><a href="#测试-ArraySum-过程" class="headerlink" title="测试 ArraySum 过程"></a>测试 ArraySum 过程</h4><p>下面的程序通过传递一个 32 位整数数组的偏移量和长度来测试 ArraySum 过程。调用 ArraySum 之后，程序将过程的返回值保存在变量 theSum 中。</p><pre><code>;测试ArraySum过程.386.model flat,stdcall.stack 4096ExitProcess PROTO,dwExitCode:DWORD.dataarray DWORD 10000h,20000h,30000h,40000h,50000htheSum DWORD ?.codemain PROC    mov esi,OFFSET array          ;ESI指向数组    mov ecx,LENGTHOF array        ;ECX = 数组计算器    call ArraySum                 ;计算和数    mov theSum,eax                ;用EAX返回和数    INVOKE ExitProcess,0main ENDP;------------------------------------;ArraySum;计算32位整数数组元素之和;接收：ESI = 数组偏移量;       ECX = 数组元素的个数;返回：EAX = 数组元素之和;-------------------------------------ArraySum PROC    push esi                 ;保存ESI和ECX    push ecx    mov eax,0                ;设置和数为0L1：    add eax,[esi]        ;将每个整数与和数相加    add esi,TYPE DWORD      ;指向下一个整数    loop L1                 ;按照数组大小重复    pop ecx                 ;恢复ECX和ESI    pop esi                   ret                     ;和数在EAX中ArraySum ENDPEND  main</code></pre><h2 id="汇编语言USES运算符：保存和恢复寄存器"><a href="#汇编语言USES运算符：保存和恢复寄存器" class="headerlink" title="汇编语言USES运算符：保存和恢复寄存器"></a>汇编语言USES运算符：保存和恢复寄存器</h2><h3 id="USES-运算符"><a href="#USES-运算符" class="headerlink" title="USES 运算符"></a>USES 运算符</h3><p>USES 运算符与 PROC 伪指令一起使用，让程序员列出在该过程中修改的所有寄存器名。USES 告诉汇编器做两件事情：第一，在过程开始时生成 PUSH 指令，将寄存器保存到堆栈；第二，在过程结束时生成 POP 指令，从堆栈恢复寄存器的值。</p><p>USES 运算符紧跟在 PROC 之后，其后是位于同一行上的寄存器列表，表项之间用空格符或制表符（不是逗号）分隔。</p><p>在 ArraySum 过程使用 PUSH 和 POP 指令来保存和恢复 ESI 和 ECX。 USES 运算符能够更加容易地实现同样的功能：</p><pre><code>ArraySum PROC USES esi ecx  mov eax, 0                   ;置和数为0L1:  add eax,[esi]                ;将每个整数与和数相加  add esi, TYPE DWORD          ;指向下个整数  loop L1                      ;按照数组大小重复  ret                          ;和数在 EAX 中ArraySum ENDP</code></pre><p>汇编器生成的相应代码展示了使用 USES 的效果：</p><pre><code>ArraySum PROC  push esi  push ecx  mov eax, 0                      ;置和数为0L1:  add eax, [esi]                  ;将每个整数与和数相加  add esi, TYPE DWORD             ;指向下一个整数  loop L1                         ;按照数组大小重复  pop ecx  pop esi  retArraySum ENDP</code></pre><blockquote><p>调试提示：使用 Microsoft Visual Studio 调试器可以查看由 MASM 高级运算符和伪指令生成的隐藏机器指令。在调试窗口中右键点击，选择 Go To Disassembly。该窗口显示程序源代码，以及由汇编器生成的隐藏机器指令。</p></blockquote><p>当过程利用寄存器（通常用 EAX）返回数值时，保存使用寄存器的惯例就岀现了一个重要的例外。在这种情况下，返回寄存器不能被压入和弹出堆栈。例如下述 SumOf 过程把 EAX 压入、弹出堆栈，就会丢失过程的返回值：</p><pre><code>SumOf PROC                             ;三个整数之和  push eax                             ;保存EAX  add eax, ebx  add eax, ecx                         ;计算EAX、EBX和ECX之和  pop eax                              ;和数丢失！  retSumOf ENDP</code></pre><h2 id="汇编语言链接库简介"><a href="#汇编语言链接库简介" class="headerlink" title="汇编语言链接库简介"></a>汇编语言链接库简介</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>链接库是一种文件，包含了已经汇编为机器代码的过程（子程序）。链接库开始时是一个或多个源文件，这些文件再被汇编为目标文件。目标文件插入到一个特殊格式文件，该文件由链接器工具识别。</p><p>假设一个程序调用过程 WriteString 在控制台窗口显示一个字符串。该程序源代码必须包含 PROTO 伪指令来标识 WriteString 过程：</p><pre><code>WriteString proto</code></pre><p>之后，CALL 指令执行 WriteString：</p><pre><code>call WriteString</code></pre><p>当程序进行汇编时，汇编器将不指定 CALL 指令的目标地址，它知道这个地址将由链接器指定。链接器在链接库中寻找 WriteString，并把库中适当的机器指令复制到程序的可执行文件中。同时，它把 WriteString 的地址插入到 CALL 指令。</p><p>如果被调用过程不在链接库中，链接器就发出错误信息，且不会生成可执行文件。</p><h3 id="链接命令选项"><a href="#链接命令选项" class="headerlink" title="链接命令选项"></a>链接命令选项</h3><p>链接器工具把一个程序的目标文件与一个或多个目标文件以及链接库组合在一起。比如，下述命令就将 hello.obj 与 irvine32.lib 和 kernel32.lib 库链接起来：</p><pre><code>link hello.obj irvine32.lib kernel32.lib</code></pre><h3 id="32位程序链接"><a href="#32位程序链接" class="headerlink" title="32位程序链接"></a>32位程序链接</h3><p>kernel32.lib 文件是 Microsoft Windows 平台软件开发工具（Software Development Kit）的一部分，它包含了 kernel32.dll 文件中系统函数的链接信息。kernel32.dll 文件是 MS-Windows 的一个基本组成部分，被称为动态链接库（dynamic link library）。它含有的可执行函数实现基于字符的输入输出。</p><p>下图展示了为什么 kernel32.lib 是通向 kernel32.dll 的桥梁。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224157743123" alt="img"></p><h2 id="汇编语言Irvine32链接库"><a href="#汇编语言Irvine32链接库" class="headerlink" title="汇编语言Irvine32链接库"></a>汇编语言Irvine32链接库</h2><p>即使是在那个时代，如果想在控制台上显示一个整数，也需要编写一个相当复杂的程序，将整数的内部二进制表示转换为可以在屏幕上显示的 ASCII 字符序列。这个过程被称为 WriteInt，下面是其抽象为伪代码的逻辑：</p><p>初始化：</p><pre><code>let n equal the binary valuelet buffer be an array of char[size]</code></pre><p>算法：</p><pre><code>i = size -1                      ;缓冲区最后一个位置repeat  r = n mod 10                   ;余数  n = n / 10                     ;整数除法  digit = r OR 30h               ;将工转换为 ASCII 数字  bufferf[i--] = digit           ;保存到缓冲区until n = 0if n is negative  buffer[i] = "-"                ;插入负号while i &gt; 0  print buffer[i]  i++</code></pre><p>注意，数字是按照逆序生成，插入缓冲区，从后往前移动。然后，数字按照正序写到控制台。虽然这段代码简单到足以用 C/C++ 实现，但是如果是在汇编语言中，它还需要一些高级技巧。</p><p>专业程序员通常更愿意自己建立库，这是一种很好的学习经验。在 Windows 的 32 位模式下，输入输出库必须能直接调用操作系统的内容。这个学习曲线相当陡峭，对编程初学者提出了一些挑战。因此，Irvine32 链接库被设计成给初学者提供简单的输入输岀接口。</p><p>随着学习的推进，我们将能获得自己创建库的知识和技术。只要成为库的创建者，就能自由地修改和重用库。</p><p>下表列出了 Irvine32 链接库的全部过程。</p><table><thead><tr><th>过程</th><th>说明</th></tr></thead><tbody><tr><td>CloseFile</td><td>关闭之前已经打开的磁盘文件</td></tr><tr><td>Clrscr</td><td>清除控制台窗口，并将光标置于左上角</td></tr><tr><td>CreateOutputFile</td><td>为输出模式下的写操作创建一个新的磁盘文件</td></tr><tr><td>Crlf</td><td>在控制台窗口中写一个行结束的序列</td></tr><tr><td>Delay</td><td>程序执行暂停指定的 n 毫秒</td></tr><tr><td>DumpMem</td><td>以十六进制形式，在控制台窗口写一个内存块</td></tr><tr><td>DumpRegs</td><td>以十六进制形式显示 EAX、EEX、ECX、EDX、ESI、EDI、EBP、ESP、EFLAGS 和 EIP 寄存器。也显示最常见的 CPU 状态标志位</td></tr><tr><td>GetCommandTail</td><td>复制程序命名行参数（称为命令尾）到一个字节数组</td></tr><tr><td>GetDateTime</td><td>从系统获取当前日期和时间</td></tr><tr><td>GetMaxXY</td><td>返回控制台窗口缓冲器的行数和列数</td></tr><tr><td>GetMseconds</td><td>返回从午夜开始经过的毫秒数</td></tr><tr><td>GetTextColor</td><td>返回当前控制台窗口的前景色和背景色</td></tr><tr><td>Gotoxy</td><td>将光标定位到控制台窗口内指定的位置</td></tr><tr><td>IsDigit</td><td>如果 AL 寄存器中包含了十进制数字（0-9）的 ASCII 码，则零标志位置 1</td></tr><tr><td>MsgBox</td><td>显示一个弹出消息框</td></tr><tr><td>MsgBoxAsk</td><td>在弹出消息框中显示 yes/no 问题</td></tr><tr><td>OpenlnputFile</td><td>打开一个已有磁盘文件进行输入操作</td></tr><tr><td>ParseDecimal32</td><td>将一个无符号十进制整数字符串转换为 32 位二进制数</td></tr><tr><td>Parselnteger32</td><td>将一个有符号十进制整数字符串转换为 32 位二进制数</td></tr><tr><td>Random32</td><td>在 0〜FFFFFFFFh 范围内，生成一个 32 位的伪随机整数</td></tr><tr><td>Randomize</td><td>用一个值作为随机数生成器的种子</td></tr><tr><td>RandomRange</td><td>在特定范围内生成一个伪随机整数</td></tr><tr><td>ReadChar</td><td>等待从键盘输入一个字符，并返回该字符</td></tr><tr><td>ReadDec</td><td>从键盘读取一个无符号 32 位十进制整数，用回车符结束</td></tr><tr><td>ReadFromFile</td><td>将一个输入磁盘文件读入缓冲区</td></tr><tr><td>ReadHex</td><td>从键盘读取一个 32 位十六进制整数，用回车符结束</td></tr><tr><td>Readlnt</td><td>从键盘读取一个有符号 32 位十进制整数，用回车符结束</td></tr><tr><td>ReadKey</td><td>无需等待输入即从键盘输入缓冲区读取一个字符</td></tr><tr><td>ReadString</td><td>从键盘读取一个字符串，用回车符结束</td></tr><tr><td>SetTextColor</td><td>设置控制台输出字符的前景色和背景色</td></tr><tr><td>Str_compare</td><td>比较两个字符串</td></tr><tr><td>Str_copy</td><td>将源字符串复制到目的字符串</td></tr><tr><td>Str_length</td><td>用 EAX 返回字符串长度</td></tr><tr><td>Str_trim</td><td>从字符串删除不需要的字符</td></tr><tr><td>Str_ucase</td><td>将字符串转换为大写字母</td></tr><tr><td>WaitMsg</td><td>显示信息并等待按键操作</td></tr><tr><td>WriteBin</td><td>用 ASCII 二进制格式，向控制台窗口写一个无符号 32 位整数</td></tr><tr><td>WriteBinB</td><td>用字节、字或双字格式向控制台窗口写一个二进制整数</td></tr><tr><td>WriteChar</td><td>在控制台窗口写一个字符</td></tr><tr><td>WriteDec</td><td>用十进制格式，向控制台窗口写一个无符号 32 位整数</td></tr><tr><td>WriteHex</td><td>用十六进制格式，向控制台窗口写一个 32 位整数</td></tr><tr><td>WriteHexB</td><td>用十六进制格式，向控制台窗口写一个字节、字或双字整数</td></tr><tr><td>Writelnt</td><td>用十进制格式，向控制台窗口写一个有符号 32 位整数</td></tr><tr><td>WriteStackFrame</td><td>向控制台窗口写当前过程的堆栈帧</td></tr><tr><td>WriteStackFrameName</td><td>向控制台窗口写当前过程的名称和堆栈帧</td></tr><tr><td>WriteString</td><td>向控制台窗口写一个以空字符结束的字符串</td></tr><tr><td>WriteToFile</td><td>将缓冲区内容写入一个输出文件</td></tr><tr><td>WriteWindowsMsg</td><td>显示一个字符串，包含 MS-Windows 最近一次产生的错误</td></tr></tbody></table><h3 id="CloseFile"><a href="#CloseFile" class="headerlink" title="CloseFile"></a>CloseFile</h3><p>CloseFile 过程关闭之前已经创建或打开的文件（参见 CreateOutputFile 和 OpenlnputFile）。该文件用一个 32 位整数的句柄来标识，句柄由 EAX 传递。如果文件成功关闭，EAX 中的返回值就是非零的。示例如下：</p><pre><code>mov eax,fileHandlecall CloseFile</code></pre><h3 id="Clrscr"><a href="#Clrscr" class="headerlink" title="Clrscr"></a>Clrscr</h3><p>Clrscr 过程清除控制台窗口。该过程通常在程序开始和结束时被调用。如果在其他时间调用这个过程，就需要先调用 WaitMsg 来暂停程序，这样就可以让用户在屏幕被清除之前，阅读屏幕上的信息。调用示例如下：</p><pre><code>call WaitMsg       ; "Press any key..."call Clrscr</code></pre><h3 id="CreateOutputFile"><a href="#CreateOutputFile" class="headerlink" title="CreateOutputFile"></a>CreateOutputFile</h3><p>CreateOutputFile 过程创建并打开一个新的磁盘文件，进行写操作。调用该过程时，将文件名的偏移量送入 EDX。过程返回后，如果文件创建成功则 EAX 将包含一个有效文件句柄（32 位整数），否则，EAX 将等于 INVALID_HANDLE_VALUE（一个预定义的常数）。调用示例如下：</p><pre><code>.datafilename BYTE "newfile.txt",0.codemov edx,OFFSET filenamecall CreateOutputFile</code></pre><p>下面的伪代码描述的是调用 CreateOutputFile 之后，可能会出现的结果：</p><pre><code>if EAX = INVALID_HANDLE_VALUE    the file was not created successfullyelse    EAX = handle for the open fileendif</code></pre><h3 id="Crlf"><a href="#Crlf" class="headerlink" title="Crlf"></a>Crlf</h3><p>Crlf 过程将光标定位在控制台窗口下一行的开始位置。它写的字符串包含了 ASCII 字符代码 ODh 和 OAh。调用示例如下：</p><pre><code>call Crlf</code></pre><h3 id="Delay"><a href="#Delay" class="headerlink" title="Delay"></a>Delay</h3><p>Delay 过程按照特定毫秒数暂停程序。在调用 Delay 之前，将预定时间间隔送入 EAXO 调用示例如下：</p><pre><code>mov eax,1000              ;1 秒call Delay</code></pre><h3 id="DumpMen"><a href="#DumpMen" class="headerlink" title="DumpMen"></a>DumpMen</h3><p>DumpMen 过程在控制台窗口中用十六进制的形式显示一段内存区域。ESI 中存放的是内存区域首地址；ECX 中存放的是单元个数；EBX 中存放的是单元大小（1 = 字节，2 = 字，4 = 双字)。下述调用示例用十六进制形式显示了包含 11 个双字的数组：</p><pre><code>.dataarray DWORD 1,2,3,4,5,6,7,8,9,0Ah,0Bh.codemain PROC        mov esi,OFFSET array                   ;首地址偏移量        mov ecx, LENGTHOF array                ;单元个数        mov ebx,TYPE array                     ;双字格式        call DumpMen</code></pre><p>产生的输出如下所示：</p><pre><code>00000001   00000002   00000003   00000004   00000005   0000000600000007  00000008  00000009  0000000A   0000000B</code></pre><h3 id="DumpRegs"><a href="#DumpRegs" class="headerlink" title="DumpRegs"></a>DumpRegs</h3><p>DumpRegs 过程用十六进制形式显示 EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP、EIP 和 EFL（EFLAGS）的内容，以及进位标志位、符号标志位、零标志位、溢出标志位、辅助进位标志位和奇偶标志位的值。调用示例如下：</p><pre><code>call DumpRegs</code></pre><p>示例输出如下所示：</p><pre><code>EAX=00000613   EBX=00000000   ECX=000000FF   EDX=00000000ESI=00000000   EDI=00000100   EBP=0000091E   ESP=000000F6EIP=00401026   EFL=00000286   CF=0   SF=1   ZF=0   OF=0   AF=0   PF=1</code></pre><p>EIP 显示的数值是调用 DumpRegs 的下一条指令的偏移量。DumpRegs 在调试程序时很有用，因为它显示了 CPU 快照。该过程没有输入参数和返回值。</p><h3 id="GetCommandTail"><a href="#GetCommandTail" class="headerlink" title="GetCommandTail"></a>GetCommandTail</h3><p>GetCommandTail 过程将程序命令行复制到一个空字节结束的字符串。如果命令行是空，则进位标志位置 1 ；否则进位标志位清零。该过程的作用在于能让程序用户通过命令行传递参数。假设有一程序 Encrypt.exe 读取输入文件 filel.txt，并产生输出文件 file2.txt。程序运行时，用户可以通过命令行传递这两个文件名：</p><pre><code>Encrypt filel.txt file2.txt</code></pre><p>当 Encrypt 程序启动时，它可以调用 GetCommandTail，检索这两个文件名。调用 GetCommandTail 时，EDX 必须包含一个数组的偏移量，该数组至少要有 129 个字节。调用示例如下：</p><pre><code>.datacmdTail BYTE 129 DUP ( 0 )          ;空缓冲区.codemov edx,OFFSET cmdTailcall GetCommandTail                 ;填充缓冲区</code></pre><p>在 Visual Studio 中运行应用程序时，有一种方法可以传递命令行参数。在 Project 菜单中，选择 <projectname>Properties。在 Property Pages 窗口，展开 Configuration Properties 选项，选择 Debugging。然后，在右边 Command Arguments 面板的编辑行中输入程序的命令参数。</projectname></p><h3 id="GetMaxXY"><a href="#GetMaxXY" class="headerlink" title="GetMaxXY"></a>GetMaxXY</h3><p>GetMaxXY 过程获取控制台窗口缓冲区的大小。如果控制台窗口缓冲区大于可视窗口尺寸，则自动显示滚动条。GetMaxXY 没有输入参数。当过程返回时，DX 寄存器包含了缓冲区的列数，AX 寄存器包含了缓冲区的行数。每个数值的可能范围都不超过 255，这也许会小于实际窗口缓冲区的大小。调用示例如下：</p><pre><code>.datarows BYTE ?cols BYTE ?.codecall GetMaxXYmov rows, almov cols,dl</code></pre><h3 id="GetMseconds"><a href="#GetMseconds" class="headerlink" title="GetMseconds"></a>GetMseconds</h3><p>GetMseconds 过程获取主机从午夜开始经过的毫秒数，并用 EAX 返回该值。在计算事件间隔时间时，这个过程是非常有用的。过程不需要输入参数。</p><p>下面的例子调用了 GetMseconds，并保存了返回值。执行循环之后，代码第二次调用 GetMseconds，并将两次返回的时间值相减，结果就是执行循环的大致时间：</p><pre><code>.datastartTime DWORD ?.codecall GetMsecondsmov startTime,eaxLI :;(loop body)loop LIcall GetMsecondssub eax, startTime      ;EAX = 循环时间，按毫秒计</code></pre><h3 id="GetTextColor"><a href="#GetTextColor" class="headerlink" title="GetTextColor"></a>GetTextColor</h3><p>GetTextColor 过程获取控制台窗口当前的前景色和背景色，它没有输入参数。返回时，AL 中的高四位是背景色，低四位是前景色。调用示例如下：</p><pre><code>.datacolor byte ?.codecall GetTextColormov color,AL</code></pre><h3 id="Gotoxy"><a href="#Gotoxy" class="headerlink" title="Gotoxy"></a>Gotoxy</h3><p>Gotoxy 过程将光标定位到控制台窗口的指定位置。默认情况下，控制台窗口的X轴范围为 0〜79，Y 轴范围为 0〜24。调用 Gotoxy 时，将 Y 轴（行数）传递到 DH 寄存器，X 轴（列数）传递到 DL 寄存器。调用示例如下：</p><pre><code>mov dh, 10              ;第 10 行mov dl, 20              ;第 20 列call Gotoxy             ;定位光标用户可能会修改控制台窗口大小，因此可以调用 GetMaxXY 获取当前窗口的行列数。</code></pre><h3 id="IsDigit"><a href="#IsDigit" class="headerlink" title="IsDigit"></a>IsDigit</h3><p>IsDigit 过程确定 AL 中的数值是否是一个有效十进制数的 ASCII 码。过程被调用时，将一个 ASCII 字符传递到 AL。如果 AL 包含的是一个有效十进制数，则过程将零标志位置 1；否则，清除零标志位。调用示例如下：</p><pre><code>mov AL,somecharcall IsDigit</code></pre><h3 id="MsgBox"><a href="#MsgBox" class="headerlink" title="MsgBox"></a>MsgBox</h3><p>MsgBox 过程显示一个带选择项的图形界面弹出消息框。（当程序运行于控制台窗口时有效。）过程用 EDX 传递一个字符串的偏移量，该字符串将显示在消息框中。还可以用 EBX 传递消息框标题字符串的偏移量，如果标题为空，则 EBX 为 0。调用示例如下：</p><pre><code>.datacaption BYTE "Dialog Title", 0HelloMsg BYTE "This is a pop-up message box.", 0dh, 0ah         BYTE "Click OK to continue...", 0.codemov ebx,OFFSET captionmov edx,OFFSET HelloMsgcall MsgBox</code></pre><h3 id="MsgBoxAsk"><a href="#MsgBoxAsk" class="headerlink" title="MsgBoxAsk"></a>MsgBoxAsk</h3><p>MsgBoxAsk 过程显示带有 Yes 和 No 按钮的图形弹岀消息框。（当程序运行于控制台窗口时有效。）过程用 EDX 传递问题字符串的偏移量，该问题字符串将显示在消息框中。还可以用 EBX 传递消息框标题字符串的偏移量，如果标题为空，则 EBX 为 0。</p><p>MsgBoxAsk 用 EAX 中的返回值表示用户选择的是哪个按钮，返回值有两个选择，都是预先定义的 Windows 常数：IDYES （值为 6）或 IDNO（值为 7）。调用示例如下：</p><pre><code>.datacaption BYTE "Survey Completed",0question BYTE "Thank you for completing the survey."BYTE 0dh,0ahBYTE "Would you like to receive the results?",0.codemov ebx,OFFSET captionmov edx,OFFSET questioncall MsgBoxAsk                    ;查看 EAX 中的返回值</code></pre><h3 id="OpenlnputFile"><a href="#OpenlnputFile" class="headerlink" title="OpenlnputFile"></a>OpenlnputFile</h3><p>OpenlnputFile 过程打开一个已存在的文件进行输入。过程用 EDX 传递文件名的偏移量。当从过程返回时，如果文件成功打开，则 EAX 就包含有效的文件句柄。 否则，EAX 等于 INVALID_HANDLE_VALUE（一个预定义的常数）。</p><p>调用示例如下：</p><pre><code>.datafilename BYTE "myfile.txt",0.codemov edx,OFFSET filenamecall OpenlnputFile</code></pre><p>下述伪代码显示了调用 OpenlnputFile 后可能的结果：</p><pre><code>if EAX = INVALID_HANDLE_VALUE    the file was not opened successfullyelse    EAX = handle for the open fileendif</code></pre><h3 id="ParseDecimal32"><a href="#ParseDecimal32" class="headerlink" title="ParseDecimal32"></a>ParseDecimal32</h3><p>ParseDecimal32 过程将一个无符号十进制整数字符串转换为 32 位二进制数。非数字符号之前所有的有效数字都要转，前导空格要忽略。过程用 EDX 传递字符 串的偏移量，用 ECX 传递字符串的长度，用 EAX 返回二进制数值。</p><p>调用示例如下：</p><pre><code>.databuffer BYTE "8193"bufSize = ($ - buffer).codemov edx,OFFSET buffermov ecx, bufSizecall Pars eDecimal32     ;返回 EAX</code></pre><ul><li><p>如果整数为空，则 EAX=0 且 CF=1</p></li><li><p>如果整数只有空格，则 EAX=0 且 CF=1</p></li><li><p>如果整数大于（2³²-1），则 EAX=0 且 CF=1</p></li><li><p>否则，EAX 为转换后的数，且 CF=0</p></li></ul><p>参阅 ReadDec 过程的说明，详细了解进位标志位是如何受到影响的。</p><h3 id="Parselnteger32"><a href="#Parselnteger32" class="headerlink" title="Parselnteger32"></a>Parselnteger32</h3><p>Parselnteger32 过程将一个有符号十进制整数字符串转换为32位二进制数。字符串开始到第一个非数字符号之间所有的有效数字都要转，前导空格要忽略。过程用 EDX 传递字符串的偏移量，用 ECX 传递字符串的长度，用 EAX 返回二进制数值。调用示例如下：</p><pre><code>.databuffer byte ,'-8193"bufSize = ($ - buffer).codemov edx,OFFSET buffermov ecx,bufSizecall Parselnteger32            ;返回 EAX</code></pre><p>字符串可能包含一个前导加号或减号，但其后只能跟十进制数字。如果数值不能表示为 32 位有符号整数（范围：-2 147 483 648 到 +2 147 483 647），则溢出标志位置 1，且在控制 台显示一个错误信息。</p><h3 id="Random32"><a href="#Random32" class="headerlink" title="Random32"></a>Random32</h3><p>Random32 过程生成一个 32 位随机整数并用 EAX 返回该数。当被反复调用时，Random32 就会生成一个模拟的随机数序列，这些数由一个简单的函数产生，该函数有一个输入称为种子（seed）。</p><p>函数利用公式里的种子生成一个随机数值，并且每次都使用前次生成的随机数作为种子，来生成后续随机数。下述代码段展示了一个调用 Random32 的例子：</p><pre><code>.datarandVal DWORD ?.codecall Random32mov randVal, eax</code></pre><h3 id="Randomize"><a href="#Randomize" class="headerlink" title="Randomize"></a>Randomize</h3><p>Randomize 过程对 Random32 和 RandomRange 过程的第一个种子进行初始化。种子等于一天中的时间，精度为 1/100 秒。每当调用 Random32 和 RandomRaiige 的程序运行时，生成的随机数序列都不相同。而 Randomize 程只需要在程序开头调用一次。 下面的例子生成了 10 个随机整数：</p><pre><code>call Randomizemov ecx,10L1: call Random32;在此使用或显示 EAX 中的随机数loop L1</code></pre><h3 id="RandomRange"><a href="#RandomRange" class="headerlink" title="RandomRange"></a>RandomRange</h3><p>RandomRange 过程在范围 0〜n-1 内生成一个随机整数，其中 n 是用 EAX 寄存器传递的输入参数。生成的随机数也用 EAX 返回。下面的例子在 0 到 4999 之间生成一个随机整数，并将其放在变量 randVal 中。</p><pre><code>.datarandVal DWORD ?.codemov eax,5000call RandomRangemov randVal, eax</code></pre><h3 id="ReadChar"><a href="#ReadChar" class="headerlink" title="ReadChar"></a>ReadChar</h3><p>ReadChar 过程从键盘读取一个字符，并用 AL 寄存器返回，字符不在控制台窗口中回显。调用示例如下：</p><pre><code>.datachar BYTE ?.codecall ReadCharmov char,al</code></pre><p>如果用户按下的是扩展键，如功能键、方向键、Ins 键或 Del 键，则过程就把 AL 清零，而 AH 包含的是键盘扫描码。EAX 的高字节没有使用。下述伪代码描述了调用 ReadChar 之后可能产生的结果：</p><pre><code>if an extended key was pressed    AL = 0    AH = keyboard scan codeelse    AL = ASCII key valueendif</code></pre><h3 id="ReadDec"><a href="#ReadDec" class="headerlink" title="ReadDec"></a>ReadDec</h3><p>ReadDec 过程从键盘读取一个 32 位无符号十进制整数，并用 EAX 返回该值，前导空格要忽略。返回值为遇到第一个非数字字符之前的所有有效数字。比如，如果用户输入123AEC，则 EAX 中的返回值为 123。下面是一个调用示例：</p><pre><code>.dataintVal DWORD ?.codecall ReadDecmov intVal,eax</code></pre><p>ReadDec 会影响进位标志位：</p><ul><li><p>如果整数为空，则 EAX=0 且 CF=1</p></li><li><p>如果整数只有空格，则 EAX=0 且 CF=1</p></li><li><p>如果整数大于（2³²-1），则 EAX=0 且 CF=1</p></li><li><p>否则，EAX 为转换后的数，且 CF=0</p></li></ul><h3 id="ReadFromFile"><a href="#ReadFromFile" class="headerlink" title="ReadFromFile"></a>ReadFromFile</h3><p>ReadFromFile 过程读取存储缓冲区中的一个输入磁盘文件。当调用 ReadFromFile 时，用 EAX 传递打开文件的句柄，用 EDX 传递缓冲区的偏移量，用 ECX 传递读取的最大字节数。</p><p>ReadFromFile 返回时要查看进位标志位的值：如果 CF 清零，则 EAX 包含了从文件中读取的字节数；如果 CF 置 1，则 EAX 包含了数字系统错误代码。调用 WriteWindowsMsg 程就可以获得该错误的文本。在下面的例子中，从文件读取的 5000 个字节复制到了缓冲区变量：</p><pre><code>.dataBUFFER_SIZE = 5000buffer BYTE BUFFER_SIZE DUP(?)bytesRead DWORD ?.codemov edx,OFFSET buffer         ;指向缓冲区mov ecx,BUFFER_SIZE           ;读取的最大字节数call ReadFromFile             ; 读文件 }</code></pre><p>如果此时进位标志位清零，则可以执行如下指令：</p><pre><code>mov bytesRead, eax            ;实际读取的字节数</code></pre><p>但是，如果此时进位标志位置 1，就可以调用 WriteWindowsMsg 过程，显示错误代码以及该应用最近产生错误的说明：</p><pre><code>call WriteWindowsMsg</code></pre><h3 id="ReadHex"><a href="#ReadHex" class="headerlink" title="ReadHex"></a>ReadHex</h3><p>ReadHex 过程从键盘读取一个 32 位十六进制整数，并用 EAX 返回相应的二进制数。对无效字符不进行任何错误检查。字母 A 到 F 的大小写都可以使用。最多能够输入 8 个数字（超出的字符将被忽略），前导空格将被忽略。调用示例如下：</p><pre><code>.datahexVal DWORD ?.codecall ReadHexmov hexVal,eax</code></pre><h3 id="Readlnt"><a href="#Readlnt" class="headerlink" title="Readlnt"></a>Readlnt</h3><p>Readlnt 过程从键盘读取一个 32 位有符号整数，并用 EAX 返回该值。用户可以键入前置加号或减号，而其后跟的只能是数字。</p><p>Readlnt 设置溢出标志位，如果输入数值无法表示为 32 位有符号数（范围：-2 147 483 648 至 +2 147 483 647），则显示一个错误信息。返回值包括所有的有效数字，直到遇见第一个非数字字符。例如，如果用户输入 +123ABC，则返回值为 +123。调用示例如下：</p><pre><code>.dataintVal SDWORD ?.codecall Readlntmov intVal,eax</code></pre><h3 id="ReadKey"><a href="#ReadKey" class="headerlink" title="ReadKey"></a>ReadKey</h3><p>ReadKey 过程执行无等待键盘检查。换句话说，它检查键盘输入缓冲区以查看用户是否有按键操作。如果没有发现键盘数据，则零标志位置 1。如果 ReadKey 发现有按键，则清除零标志位，且向 AL 送入 0 或 ASCII 码。若 AL 为 0，表示用户可能按下了一个特殊键（功能键、方向键等）。</p><p>AH 寄存器为虚拟扫描码，DX 为虚拟键码，EBX 为键盘标志位。下述伪代码说明了调用 ReadKey 时的各种结果：</p><pre><code>if no_keyboard_data then    ZF = 1else    ZF = 0    if AL = 0 then        extended key was pressed, and AH = scan code, DX = virtual           key code, and EBX = keyboard flag bits    else        AL = the key's ASCII code    endifendif</code></pre><p>当调用 ReadKey 时，EAX 和 EDX 的高 16 位会被覆盖。</p><h3 id="ReadString"><a href="#ReadString" class="headerlink" title="ReadString"></a>ReadString</h3><p>ReadString 过程从键盘读取一个字符串，直到用户键入回车键。过程用 EDX 传递缓冲区的偏移量，用 ECX 传递用户能键入的最大字符数加 1（保留给终止空字节），用 EAX 返回用户键入的字符数。示例调用如下：</p><pre><code>.databuffer BYTE 21 DUP(0)          ;输入缓冲区byteCount DWORD ?              ;定义计数器.codemov edx,OFFSET buffer           ;指向缓冲区mov ecxz SIZEOF buffer          ;定义最大字符数call ReadString                 ;输入字符串mov byteCount, eax              ;字符数</code></pre><p>ReadString 在内存中字符串的末尾自动插入一个 null 终止符。用户输入“ABCDEFG”后，buffer 中前 8 个字节的十六进制形式和 ASCII 形式如下所示：</p><p>41 42 43 44 45 46 47 00 ABCDEFG</p><p>变量 byteCoun t等于 7。</p><h3 id="SetTextColor"><a href="#SetTextColor" class="headerlink" title="SetTextColor"></a>SetTextColor</h3><p>SetTextColor 过程（仅在 Irvine32 链接库中）设置输出文本的前景色和背景色。调用 SetTextColor 时，给 EAX 分配一个颜色属性。下列预定义的颜色常数都可以用于前景色和背景色：</p><table><thead><tr><th>black = 0</th><th>red = 4</th><th>gray = 8</th><th>lightRed = 12</th></tr></thead><tbody><tr><td>blue = 1</td><td>magenta = 5</td><td>lightBlue = 9</td><td>light Magenta = 13</td></tr><tr><td>green = 2</td><td>brown = 6</td><td>light Green = 10</td><td>yellow = 14</td></tr><tr><td>cyan = 3</td><td>lightGray = 7</td><td>lightCyan = 11</td><td>white = 15</td></tr></tbody></table><p>颜色常量在 Irvine32.inc 文件中进行定义。要获得完整的颜色字节数值，就将背景色乘以 16 再加上前景色。例如，下述常量表示在蓝色背景上输出黄色字符：</p><pre><code>yellow + (blue * 16)</code></pre><p>下列语句设置为蓝色背景上输出白色字符：</p><pre><code>mov eax,white + (blue * 16)     ; 蓝底白字call SetTextColor</code></pre><p>另一种表示颜色常量的方法是使用 SHL 运算符，将背景色左移 4 位再加上前景色。</p><pre><code>yellow + (blue SHL 4)</code></pre><p>位移是在汇编时执行的，因此它只能用常数作操作数。</p><h3 id="Str-length"><a href="#Str-length" class="headerlink" title="Str_length"></a>Str_length</h3><p>Str_length 过程返回空字节结束的字符串的长度。过程用 EDX 传递字符串的偏移量，用 EAX 返回字符串的长度。调用示例如下：</p><pre><code>.databuffer BYTE "abcde",0bufLength DWORD ?.codemov edx, OFFSET buffer          ;指向字符串call Str_length                 ;EAX=5mov bufLength, eax              ;保存长度</code></pre><h3 id="WaitMsg"><a href="#WaitMsg" class="headerlink" title="WaitMsg"></a>WaitMsg</h3><p>WaitMsg 过程显示“Press any key to continue…”消息，并等待用户按键。当用户想在数据滚动和消失之前暂停屏幕显示时，这个过程就很有用。过程没有输入参数。 调用示例如下：</p><pre><code>call WaitMsg</code></pre><h3 id="WriteBin"><a href="#WriteBin" class="headerlink" title="WriteBin"></a>WriteBin</h3><p>WriteBin 过程以 ASCII 二进制格式向控制台窗口输出一个整数。过程用 EAX 传递该整数。为了便于阅读，二进制位以四位一组的形式进行显示。调用示例如下：</p><pre><code>mov eax,12346AF9hcall WriteBin</code></pre><p>示例代码显示如下：</p><pre><code>0001 0010 0011 0100 0110 1010 1111 1001</code></pre><h3 id="WriteBinB"><a href="#WriteBinB" class="headerlink" title="WriteBinB"></a>WriteBinB</h3><p>WriteBinB 过程以 ASCII 二进制格式向控制台窗口输出一个 32 位整数。过程用 EAX 寄存器传递该整数，用 EDX 表示以字节为单位的显示大小（1、2，或 4）。为了便于阅读，二进制位以四位一组的形式进行显示。调用示例如下：</p><pre><code>mov eax,00001234hmov ebx,TYPE WORD           ; 两个字节call WriteBinB              ; 显示 0001 0010 0011 0100</code></pre><h3 id="WriteChar"><a href="#WriteChar" class="headerlink" title="WriteChar"></a>WriteChar</h3><p>WriteChar 过程向控制台窗口写一个字符。过程用 AL 传递字符（或其 ASCII 码）。调用示例如下：</p><pre><code>mov al, 'A'call WriteChar           ;显示："A"</code></pre><h3 id="WriteDec"><a href="#WriteDec" class="headerlink" title="WriteDec"></a>WriteDec</h3><p>WriteDec 过程以十进制格式向控制台窗口输出一个 32 位无符号整数，且没有前置 0。过程用 EAX 寄存器传递该整数。调用示例如下：</p><pre><code>mov eax,295call WriteDec            ;显示："295"</code></pre><h3 id="WriteHex"><a href="#WriteHex" class="headerlink" title="WriteHex"></a>WriteHex</h3><p>WriteHex 过程以 8 位十六进制格式向控制台窗口输出一个 32 位无符号整数，如果需要，应插入前置 0。过程用 EAX 传递整数。调用示例如下：</p><pre><code>mov eax,7FFFhcall WriteHex           ;显示："00007FFF"</code></pre><h3 id="WriteHexB"><a href="#WriteHexB" class="headerlink" title="WriteHexB"></a>WriteHexB</h3><p>WriteHexB 过程以十六进制格式向控制台窗口输岀一个 32 位无符号整数，如果需要，应插入前置 0。过程用 EAX 传递整数，用 EBX 表示显示格式的字节数（1、2，或 4）。调用示例如下：</p><pre><code>mov eax, 7FFFhmov ebx, TYPE WORD        ;两个字节call WriteHexB            ;显示："7FFF"</code></pre><h3 id="Writelnt"><a href="#Writelnt" class="headerlink" title="Writelnt"></a>Writelnt</h3><p>Writelnt 过程以十进制向控制台窗口输岀一个 32 位有符号整数，有前置符号，但没有前置 0。过程用 EAX 传递整数。调用示例如下：</p><pre><code>mov eax, 216543call Writelnt             ;显示："+216543"</code></pre><h3 id="WriteString"><a href="#WriteString" class="headerlink" title="WriteString"></a>WriteString</h3><p>WriteString 过程向操作台窗口输出一个空字节结束的字符串。过程用 EDX 传递字符串的偏移量。调用示例如下：</p><pre><code>.dataprompt BYTE "Enter your name: ",0.codemov edx,OFFSET promptcall WriteString</code></pre><h3 id="WriteToFile"><a href="#WriteToFile" class="headerlink" title="WriteToFile"></a>WriteToFile</h3><p>WriteToFile 过程向一个输出文件写入缓冲区内容。过程用 EAX 传递有效的文件句柄，用 EDX 传递缓冲区偏移量，用 ECX 传递写入的字节数。当过程返回时，如果 EAX 大于 0，则其包含的是写入的字节数；否则，发生错误。下述代码调用了 WriteToFile：</p><pre><code>BUFFER_SIZE = 5000.datafileHandle DWORD ?buffer BYTE BUFFER_SIZE DUP(?).codemov eax, fileHandlemov edx, OFFSET buffermov ecx, BUFFER SIZEcall WriteToFile</code></pre><p>下面的伪代码说明了调用 WriteToFile 之后对 EAX 返回值的处理：</p><pre><code>if EAX = 0 then    error occurred when writing to file    call WriteWindowsMessage to see the errorelse    EAX = number of bytes written to the fileendif</code></pre><h3 id="WriteWindowsMsg"><a href="#WriteWindowsMsg" class="headerlink" title="WriteWindowsMsg"></a>WriteWindowsMsg</h3><p>WriteWindowsMsg 过程向控制台窗口输出应用程序在调用系统函数时最近产生的错误信息。调用示例如下：</p><pre><code>call WriteWindowsMsg</code></pre><p>下面的例子展示了一个消息字符串：</p><pre><code>Error 2: The system cannot find the file specified.</code></pre><h2 id="汇编语言Irvine64链接库"><a href="#汇编语言Irvine64链接库" class="headerlink" title="汇编语言Irvine64链接库"></a>汇编语言Irvine64链接库</h2><p>一个能支持 64 位编程的最小链接库，其中包含了如下过程：</p><ul><li><p>Crlf：向控制台写一个行结束的序列。</p></li><li><p>Random64：在0〜2⁶⁴-1 内，生成一个 64 位的伪随机整数。随机数值用 RAX 寄存器返回。</p></li><li><p>Randomize：用一个值作为随机数生成器的种子。</p></li><li><p>Readlnt64：从键盘读取一个 64 位有符号整数，用回车符结束。数值用 RAX 寄存器返回。</p></li><li><p>ReadString：从键盘读取一个字符串，用回车符结束。过程用 RDX 传递输入缓冲器偏移量；用 RCX 传递用户可输入的最大字符数加 1（用于 unll 结束符字节）。返回值（用 RAX）为用户实际输入的字符数。</p></li><li><p>Str_compare：比较两个字符串。过程将源串指针传递给 RSI，将目的串指针传递给 RDIO 用与 CMP（比较）指令一样的方式设置零标志位和进位标志位。</p></li><li><p>Str_copy：将一个源串复制到目标指针指定的位置。源串偏移量传递给 RSI，目标偏移量传递给 RDI。</p></li><li><p>Strjength：用 RAX 寄存器返回一个空字节结束的字符串的长度。过程用 RCX 传递字符串的偏移量。</p></li><li><p>Writelnt64：将 RAX 寄存器中的内容显示为 64 位有符号十进制数，并加上前置加号或减号。过程没有返回值。</p></li><li><p>WriteHex64：将 RAX 寄存器中的内容显示为 64 位十六进制数。过程没有返回值。</p></li><li><p>WriteHexB：将 RAX 寄存器中的内容显示为 1 字节、2 字节、4 字节或 8 字节的十六进制数。将显示的大小（1、2、4 或 8) 传递给 RBX 寄存器。过程没有返回值。</p></li><li><p>WriteString：显示一个空字节结束的 ASCII 字符串。将字符串的 64 位偏移量传递给 RDX。过程没有返回值。</p></li></ul><p>尽管这个库比 32 位链接库小很多，它还是包含了许多重要工具能使得程序更具互动性。随着学习的深入，大家可以用自己的代码来扩展这个链接库。Irvine64 链接库会保留 RBX、RBP、RDI、RSI、R12、R13、R14 和 R15 寄存器的值，反之，RAX、RCX、RDX、R8、R9、R10 和 R11 寄存器的值则不会保留。</p><h3 id="调用-64-位子程序"><a href="#调用-64-位子程序" class="headerlink" title="调用 64 位子程序"></a>调用 64 位子程序</h3><p>如果想要调用自己编写的子程序，或是 Irvine64 链接库中的子程序，则程序员需要做的就是将输入参数送入寄存器，并执行 CALL 指令。比如：</p><pre><code>mov rax,12345678hcall WriteHex64</code></pre><p>还有一件小事也需要完成，即程序员要在自己程序的顶部用 PROTO 伪指令指定所有在本程序之外同时又将会被调用的过程：</p><pre><code>ExitProcess PROTO         ;位于 Windows APIWriteHex64 PROTO          ;位于 Irvine64 链接库</code></pre><h3 id="x64-调用规范"><a href="#x64-调用规范" class="headerlink" title="x64 调用规范"></a>x64 调用规范</h3><p>Microsoft 在 64 位程序中使用统一模式来传递参数并调用过程，称为 Microsoft x64 调用规范。该规范由 C/C++ 编译器和 Windows 应用编程接口（API）使用。</p><p>程序员只有在调用 Windows API 的函数或用 C/C++ 编写的函数时，才会使用这个调用规范。该调用规范的一些基本特性如下所示：</p><p>\1) CALL 指令将 RSP（堆栈指针）寄存器减 8，因为地址是 64 位的。</p><p>\2) 前四个参数依序存入 RCX、RDX、R8 和 R9 寄存器，并传递给过程。如果只有一个参数，则将其放入 RCX。如果还有第二个参数，则将其放入 RDX，以此类推。其他参数，按照从左到右的顺序压入堆栈。</p><p>\3) 调用者的责任还包括在运行时堆栈分配至少 32 字节的影子空间（shadow space），这样，被调用的过程就可以选择将寄存器参数保存在这个区域中。</p><p>\4) 在调用子程序时，堆栈指针（RSP）必须进行 16 字节边界对齐（16 的倍数）。CALL 指令把 8 字节的返回值压入堆栈，因此，除了已经减去的影子空间的 32 之外，调用程序还必须从堆栈指针中减去 8。后面的示例将显示如何实现这些操作。</p><blockquote><p>提示：调用 Irvine64 链接库中的子程序时，不需使用 Microsoft x64 调用规范；只在调用 Windows API 函数时使用它。</p></blockquote><h3 id="调用过程示例"><a href="#调用过程示例" class="headerlink" title="调用过程示例"></a>调用过程示例</h3><p>现在编写一段小程序，使用 Microsoft x64 调用规范来调用子程序 AddFour。这个子程序将四个参数寄存器（RCX、RDX、R8 和 R9）的内容相加，并将和数保存到 RAX。</p><p>由于过程通常使用 RAX 返回结果，因此，当从子程序返回时，调用程序也期望返回值在这个寄存器中。这样就可以说这个子程序是一个函数，因为，它接收了四个输入并（确切地说）产生了一个输出。</p><pre><code>;在64模式下调用子程序ExitProcess PROTOWriteInt64 PROTO          ;Irvine64链接库Crlf PROTO                ;Irvine64链接库.codemain PROC    sub    rsp,8            ;对准堆栈指针    sub    rsp,20h          ;为影子参数保留32个字节    mov    rcx,1            ;依序传递参数    mov    rdx,2    mov    r8,3    mov    r9,4    call AddFour            ;在RAX中查找返回值    call WriteInt64         ;显示数字    call Crlf               ;输出回车换行符    mov    ecx,0    call ExitProcessmain ENDPAddFour PROC    mov rax,rcx    add    rax,rdx    add    rax,r8    add    rax,r9            ;和数保存在RAX中    retAddFour ENDPEND</code></pre><p>现在来看看本例中的其他细节：第 10 行将堆栈指针对齐到 16 字节的偶数边界。为什么要这样做？在 OS 调用主程序之前，假设堆栈指针是对齐 16 字节边界的。然后，当 OS 调用主程序时，CALL 指令将 8 字节的返回地址压入堆栈。将堆栈指针再减去 8，使其减少成一个 16 的倍数。</p><p>可以在 Visual Studio 调试器中运行该程序，并查看 RSP 寄存器（堆栈指针）改变数值。通过这个方法，能够看到用图形方式在下图中展示的十六进制数值。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224198156125" alt="img"></p><p>上图只展示了每个地址的低 32 位，因为高 32 位为全零：</p><p>\1) 执行第 10 行前，RSP=01AFE48。这表示在 OS 调用本程序之前，RSP 等于 01AFE50。（ CALL 指令使得堆栈指针减 8。）</p><p>\2) 执行第 10 行后，RSP=01AFE40，表示堆栈正好对齐到 16 字节边界。</p><p>\3) 执行第 11 行后，RSP=01AFE20，表示 32 个字节的影子空间位置从 01AFE20 到 01AFE3F。</p><p>\4) 在 AddFour 过程中，RSP=01AFE18，表示调用者的返回地址已经压入堆栈。</p><p>\5) 从 AddFour 返回后，RSP 再一次等于 01AFE20，与调用 AddFour 之前的值相同。</p><p>与调用 ExitProcess 来结束程序相比，本程序选择的是执行 RET 指令，这将返回到启动本程序的过程。但是，这也就要求能将堆栈指针恢复到其在 main 程开始执行时的位置。下面的代码行能替代 CallProc_64 程序的第 20 和 21 行：</p><pre><code>add rsp,28         ;恢复堆栈指针mov ecx,0          ;过程返回码ret                ;返回 OS</code></pre><blockquote><p>提示：要使用 Irvine64 链接库，将 Irvine64.obj 文件添加到用户的 Visual Studio 项目中。Visual Studio 中的操作步骤如下：在 Solution Explorer 窗口中右键点击项目名称，选择 Add，选择 Existing Item，再选择 Irvine64.obj 文件名。</p></blockquote><h1 id="汇编语言条件判断"><a href="#汇编语言条件判断" class="headerlink" title="汇编语言条件判断"></a>汇编语言条件判断</h1><h2 id="汇编语言布尔和比较指令简介"><a href="#汇编语言布尔和比较指令简介" class="headerlink" title="汇编语言布尔和比较指令简介"></a>汇编语言布尔和比较指令简介</h2><p>首先了解按位指令，这里使用的技术也可以用于操作硬件设备控制位，实现通信协议以及加密数据，这里只列举了几种应用。Intel 指令集包含了 AND、OR、XOR 和 NOT 指令，它们能直接在二进制位上实现布尔操作，如下表所示。此外，TEST 指令是一种非破坏性的 AND 操作。</p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>AND</td><td>源操作数和目的操作数进行逻辑与操作</td></tr><tr><td>OR</td><td>源操作数和目的操作数进行逻辑或操作</td></tr><tr><td>XOR</td><td>源操作数和目的操作数进行逻辑异或操作</td></tr><tr><td>NOT</td><td>对目标操作数进行逻辑非操作</td></tr><tr><td>TEST</td><td>源操作数和目的操作数进行逻辑与操作，并适当地设置 CPU 标志位</td></tr></tbody></table><p>布尔指令影响零标志位、进位标志位、符号标志位、溢出标志位和奇偶标志位。下面简单回顾一下这些标志位的含义：</p><ul><li><p>操作结果等于 0 时，零标志位置 1。</p></li><li><p>操作使得目标操作数的最高位有进位时，进位标志位置 1。</p></li><li><p>符号标志位是目标操作数高位的副本，如果标志位置 1，表示是负数；标志位清 0，表示是正数。（假设 0 为正。）</p></li><li><p>指令产生的结果超出了有符号目的操作数范围时，溢出标志位置 1。</p></li><li><p>指令使得目标操作数低字节中有偶数个 1 时，奇偶标志位置 1。</p></li></ul><h2 id="汇编语言AND指令：对两个操作数进行逻辑（按位）与操作"><a href="#汇编语言AND指令：对两个操作数进行逻辑（按位）与操作" class="headerlink" title="汇编语言AND指令：对两个操作数进行逻辑（按位）与操作"></a>汇编语言AND指令：对两个操作数进行逻辑（按位）与操作</h2><p>AND 指令在两个操作数的对应位之间进行（按位）逻辑与（AND）操作，并将结果存放在目标操作数中：</p><pre><code>AND destination,source</code></pre><p>下列是被允许的操作数组合，但是立即操作数不能超过 32 位：</p><pre><code>AND reg, regAND reg, memAND reg, immAND mem, regAND mem, imm</code></pre><p>操作数可以是 8 位、16 位、32 位和 64 位，但是两个操作数必须是同样大小。两个操作数的每一对对应位都遵循如下操作原则：如果两个位都是 1，则结果位等于 1；否则结果位等于 0。</p><p>下表展示了两个输入位 X 和 Y，第三列是表达式 X^Y 的值：</p><table><thead><tr><th>X</th><th>Y</th><th>X^Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>AND 指令可以清除一个操作数中的 1 个位或多个位，同时又不影响其他位。这个技术就称为位屏蔽，就像在粉刷房子时，用遮盖胶带把不用粉刷的地方（如窗户）盖起来。</p><p>例如，假设要将一个控制字节从 AL 寄存器复制到硬件设备。并且当控制字节的位 0 和位 3 等于 0 时，该设备复位。那么，如果想要在不修改 AL 其他位的条件下，复位设备，可以用下面的指令：</p><pre><code>and AL, 11110110b            ;清除位 0 和位 3 ，其他位不变</code></pre><p>如，设 AL 初始化为二进制数 1010 1110，将其与 1111 0110 进行 AND 操作后，AL 等于 1010 0110：</p><pre><code>mov al,10101110band al, 11110110b   ;AL 中的结果 = 1010 0110</code></pre><h3 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h3><p>AND 指令总是清除<strong>溢出和进位标志位</strong>，并根据目标操作数的值来修改符号标志位、零标志位和奇偶标志位。比如，下面指令的结果存放在 EAX 寄存器，假设其值为 0。在这种情况下，零标志位就会置 1：</p><pre><code>and eax,1Fh</code></pre><h3 id="将字符转换为大写"><a href="#将字符转换为大写" class="headerlink" title="将字符转换为大写"></a>将字符转换为大写</h3><p>AND 指令提供了一种简单的方法将字符从小写转换为大写。如果对比大写 A 和小写 a 的 ASCII 码，就会发现只有位 5 不同：</p><pre><code>0 1 1 0 0 0 0 1 = 61h ('a')0 1 0 0 0 0 0 1 = 41h ('A')</code></pre><p>其他的字母字符也是同样的关系。把任何一个字符与二进制数 1101 1111 进行 AND，则除位 5 外的所有位都保持不变，而位 5 清 0。下例中，数组中所有字符都转换为大写：</p><pre><code>.dataarray BYTE 50 DUP(?).code    mov ecx,LENGTHOF array    mov esi,OFFSET arrayL1: and BYTE PTR [esi], 11011111b       ;清除位 5    inc esi    loop L1</code></pre><h2 id="汇编语言OR指令：对两个操作数进行逻辑（按位）或操作"><a href="#汇编语言OR指令：对两个操作数进行逻辑（按位）或操作" class="headerlink" title="汇编语言OR指令：对两个操作数进行逻辑（按位）或操作"></a>汇编语言OR指令：对两个操作数进行逻辑（按位）或操作</h2><p>OR 指令在两个操作数的对应位之间进行（按位）逻辑或（OR）操作，并将结果存放在目标操作数中：</p><pre><code>OR destination, source</code></pre><p>OR 指令操作数组合与 AND 指令相同：</p><pre><code>OR reg,regOR reg,memOR reg, immOR mem,regOR mem,imm</code></pre><p>操作数可以是 8 位、16 位、32 位和 64 位，但是两个操作数必须是同样大小。对两个操作数的每一对对应位而言，只要有一个输入位是 1，则输出位就是 1。下面的真值表展示了布尔运算 x∨y：</p><table><thead><tr><th>X</th><th>Y</th><th>X∨Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>当需要在不影响其他位的情况下，将操作数中的 1 个位或多个位置为 1 时，OR 指令就非常有用了。比如，计算机与伺服电机相连，通过将控制字节的位 2 置 1 来启动电机。假设该控制字节存放在 AL 寄存器中，每一个位都含有重要信息，那么，下面的指令就只设置了位 2：</p><pre><code>or AL, 00000100b ;位 2 置 1，其他位不变</code></pre><p>如果 AL 初始化为二进制数 1110 0011，把它与 0000 0100 进行 OR 操作，其结果等于 1110 0111：</p><pre><code>mov al,11100011bor al, 00000100b       ;AL 中的结果 =1110 0111</code></pre><h3 id="标志位-1"><a href="#标志位-1" class="headerlink" title="标志位"></a>标志位</h3><p>OR 指令总是清除<strong>进位和溢出标志位</strong>，并根据目标操作数的值来修改符号标志位、零标志位和奇偶标志位。比如，可以将一个数与它自身（或 0）进行 OR 运算，来获取该数值的某些信息：</p><pre><code>or al,al</code></pre><p>下表给出了零标志位和符号标志位对 AL 内容的说明：</p><table><thead><tr><th>零标志位</th><th>符号标志位</th><th>AL 中的值</th></tr></thead><tbody><tr><td>清0</td><td>清0</td><td>大于0</td></tr><tr><td>置1</td><td>清0</td><td>等于0</td></tr><tr><td>清0</td><td>置1</td><td>小于0</td></tr></tbody></table><h2 id="汇编语言位向量（位映射）"><a href="#汇编语言位向量（位映射）" class="headerlink" title="汇编语言位向量（位映射）"></a>汇编语言位向量（位映射）</h2><p>有些应用控制的对象是从一个有限全集中选出来的一组项目。就像公司里的雇员，或者气象监测站的环境读数。在这些情景中，二进制位可以代表集合成员。</p><p>与 Java HashSet 用指针或引用指向容器内对象不同，应用可以用位向量（或位映射）把一个二进制数中的位映射为数组中的对象。</p><p>如下例所示，二进制数的位从左边 0 号开始，到右边 31 号为止，该数表示了数组元素 0、1、2 和 31 是名为 SetX 的集合成员：</p><pre><code>SetX = 10000000 00000000 00000000 00000111</code></pre><p>（为了提供可读性，字节已经分开。）通过在特定位置与 1 进行 AND 运算，就可以方便地检测出该位是否为集合成员：</p><pre><code>mov eax,SetXand eax, 10000b  ;元素［4］是 SetX 的成员吗？</code></pre><p>如果本例中的 AND 指令清除了零标志位，那么就可以知道元素［4］是 SetX 的成员。</p><h4 id="1-补集"><a href="#1-补集" class="headerlink" title="1) 补集"></a>1) 补集</h4><p>补集可以用 NOT 指令生成，NOT 指令将所有位都取反。因此，可以用下面的指令生成上例中 SetX 的补集，并存放在 EAX 中：</p><pre><code>mov eax,SetXnot eax                 ;Setx的补集</code></pre><h4 id="2-交集"><a href="#2-交集" class="headerlink" title="2) 交集"></a>2) 交集</h4><p>AND 指令可以生成位向量来表示两个集合的交集。下面的代码生成集合 SetX 和 SetY 的交集，并将其存放在 EAX 中：</p><pre><code>mov eax,SetXand eax,SetY</code></pre><p>SetX 和 SetY 交集生成过程如下所示：</p><pre><code>        1000000000000000000000000000111 （SetX）AND     1000001010100000000011101100011 （SetY）-------------------------------------------------------------        1000000000000000000000000000011 （交集）</code></pre><p>很难想象还有更快捷的方法生成交集。对于更大的集合来说，它所需要的位超过了单个寄存器的容量，因此，需要用循环来实现所有位的 AND 运算。</p><h4 id="3-并集"><a href="#3-并集" class="headerlink" title="3) 并集"></a>3) 并集</h4><p>OR 指令生成位图表示两个集合的并集。下面的代码产生集合 SetX 和 SetY 的并集，并将其存放在 EAX 中：</p><pre><code>mov eax,SetXor eax,SetY</code></pre><p>OR 指令生成 SetX 和 SetY 并集的过程如下所示：</p><pre><code>         1000000000000000000000000000111 （SetX）OR       1000001010100000000011101100011 （SetY）-------------------------------------------------------------         1000001010100000000011101100111 （并集）</code></pre><h2 id="汇编语言XOR指令：对两个操作数进行逻辑（按位）异或操作"><a href="#汇编语言XOR指令：对两个操作数进行逻辑（按位）异或操作" class="headerlink" title="汇编语言XOR指令：对两个操作数进行逻辑（按位）异或操作"></a>汇编语言XOR指令：对两个操作数进行逻辑（按位）异或操作</h2><p>XOR 指令在两个操作数的对应位之间进行（按位）逻辑异或（XOR）操作，并将结果存放在目标操作数中：</p><pre><code>XOR destination, source</code></pre><p>XOR 指令操作数组合和大小与 AND 指令及 OR 指令相同。两个操作数的每一对对应位都应用如下操作原则：如果两个位的值相同（同为 0 或同为 1），则结果位等于 0；否则结果位等于 1。</p><p>下表描述的是布尔运算 X㊉y：</p><table><thead><tr><th>x</th><th>y</th><th>x㊉y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>与 0 异或值保持不变，与 1 异或则被触发（求补）。对相同操作数进行两次 XOR 运算，则结果逆转为其本身。如下表所示，位 x 与位 y 进行了两次异或，结果逆转为 x 的初始值：</p><table><thead><tr><th>x</th><th>y</th><th>x㊉y</th><th>(x㊉y)㊉y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p>异或运算这种“可逆的”属性使其成为简单对称加密的理想工具。</p><h4 id="标志位-2"><a href="#标志位-2" class="headerlink" title="标志位"></a>标志位</h4><p>XOR 指令总是清除溢岀和进位标志位，并根据目标操作数的值来修改符号标志位、零标志位和奇偶标志位。</p><h4 id="检查奇偶标志"><a href="#检查奇偶标志" class="headerlink" title="检查奇偶标志"></a>检查奇偶标志</h4><p>奇偶检查是在一个二进制数上实现的功能，计算该数中 1 的个数；如果计算结果为偶数，则说该数是偶校验；如果结果为奇数，则该数为奇校验。</p><p>x86 处理器中，当按位操作或算术操作的目标操作数最低字节为偶校验时，奇偶标志位置 1。反之，如果操作数为奇校验，则奇偶标志位清 0。一个既能检查数的奇偶性，又不会修改其数值的有效方法是，将该数与 0 进行异或运算：</p><pre><code>mov al,10110101b       ;5 个 1,奇校验xor al, 0                              ;奇偶标志位清 0 （奇）mov al, 11001100b       ;4 个 1，偶校验xor al, 0                              ;奇偶标志位置 1（偶）</code></pre><p>Visual Studio 用 PE=1 表示偶校验，PE=0 表示奇校验。</p><h4 id="16-位奇偶性"><a href="#16-位奇偶性" class="headerlink" title="16 位奇偶性"></a>16 位奇偶性</h4><p>对 16 位整数来说，可以通过将其高字节和低字节进行异或运算来检测数的奇偶性：</p><pre><code>mov ax,64Clh   ;0110 0100 1100 0001xor ah, al           ;奇偶标志位置1 （偶）</code></pre><p>将每个寄存器中的置 1 位（等于 1 的位）想象为一个 8 位集合中的成员。XOR 指令把两个集合交集中的成员清 0，并形成了其余位的并集。这个并集的奇偶性与整个 16 位整数的奇偶性相同。</p><p>那么 32 位数值呢？如果将数值的字节进行编号，从 B₀ 到 B₃ 那么计算奇偶性的表达式为:B₀ XOR B₁ XOR B₂ XOR B₃。</p><h2 id="汇编语言NOT（反码）指令：翻转操作数的所有位"><a href="#汇编语言NOT（反码）指令：翻转操作数的所有位" class="headerlink" title="汇编语言NOT（反码）指令：翻转操作数的所有位"></a>汇编语言NOT（反码）指令：翻转操作数的所有位</h2><p>NOT 指令触发（翻转）操作数中的所有位。其结果被称为反码。该指令允许的操作数类型如下所示：</p><pre><code>NOT regNOT mem</code></pre><p>例如，F0h 的反码是 0Fh：</p><pre><code>mov al,11110000bnot al             ;AL = 00001111b</code></pre><blockquote><p>提示：NOT 指令不影响标志位。</p></blockquote><h2 id="汇编语言TEST指令：对两个操作数进行逻辑（按位）与操作"><a href="#汇编语言TEST指令：对两个操作数进行逻辑（按位）与操作" class="headerlink" title="汇编语言TEST指令：对两个操作数进行逻辑（按位）与操作"></a>汇编语言TEST指令：对两个操作数进行逻辑（按位）与操作</h2><p>TEST 指令在两个操作数的对应位之间进行 AND 操作，并根据运算结果设置符号标志位、零标志位和奇偶标志位。</p><p>TEST 指令与《AND指令》中介绍的 AND 指令唯一不同的地方是，TEST 指令不修改目标操作数。TEST 指令允许的操作数组合与 AND 指令相同。在发现操作数中单个位是否置位时，TEST 指令非常有用。</p><h4 id="示例：多位测试"><a href="#示例：多位测试" class="headerlink" title="示例：多位测试"></a>示例：多位测试</h4><p>TEST 指令同时能够检查几个位。假设想要知道 AL 寄存器的位 0 和位 3 是否置 1，可以使用如下指令：</p><pre><code>test al, 00001001b ;测试位 0 和位 3</code></pre><p>（本例中的 0000 1001 称为位掩码。）从下面的数据集例子中，可以推断只有当所有测试位都清 0 时，零标志位才置 1：</p><pre><code>0 0 1 0 0 1 0 1   &lt;- 输入值0 0 0 0 1 0 0 1   &lt;- 测试值0 0 0 0 0 0 0 1   &lt;- 结果：ZF=00 0 1 0 0 1 0 0   &lt;- 输入值0 0 0 0 1 0 0 1   &lt;- 测试值0 0 0 0 0 0 0 0   &lt;- 结果：ZF=1</code></pre><h4 id="标志位-3"><a href="#标志位-3" class="headerlink" title="标志位"></a>标志位</h4><p>TEST 指令总是清除溢出和进位标志位，其修改符号标志位、零标志位和奇偶标志位的方法与 AND 指令相同。</p><h2 id="汇编语言CMP（比较）指令：比较整数"><a href="#汇编语言CMP（比较）指令：比较整数" class="headerlink" title="汇编语言CMP（比较）指令：比较整数"></a>汇编语言CMP（比较）指令：比较整数</h2><p>了解了所有按位操作指令后，现在来讨论逻辑（布尔）表达式中的指令。最常见的布尔表达式涉及一些比较操作，下面的伪码片段展示了这种情况：</p><pre><code>if A &gt; B ...while X &gt; 0 and X &lt; 200  ...if check_for_error(N) = true</code></pre><p>x86 汇编语言用 CMP 指令比较整数。字符代码也是整数，因此可以用 CMP 指令。</p><p>CMP（比较）指令执行从目的操作数中减去源操作数的隐含减法操作，并且不修改任何操作数：</p><pre><code>CMP destination,source</code></pre><h4 id="标志位-4"><a href="#标志位-4" class="headerlink" title="标志位"></a>标志位</h4><p>当实际的减法发生时，CMP 指令按照计算结果修改溢出、符号、零、进位、辅助进位和奇偶标志位。</p><p>如果比较的是两个无符号数，则零标志位和进位标志位表示的两个操作数之间的关系如右表所示：</p><table><thead><tr><th>CMP结果</th><th>ZF</th><th>CF</th></tr></thead><tbody><tr><td>目的操作数 &lt; 源操作数</td><td>0</td><td>1</td></tr><tr><td>目的操作数 &gt; 源操作数</td><td>0</td><td>0</td></tr><tr><td>目的操作数 = 源操作数</td><td>1</td><td>0</td></tr></tbody></table><p>如果比较的是两个有符号数，则符号标志位、零标志位和溢出标志位表示的两个操作数之间的关系如右表所示：</p><table><thead><tr><th>CMP结果</th><th>标志位</th></tr></thead><tbody><tr><td>目的操作数 &lt; 源操作数</td><td>SF ≠ OF</td></tr><tr><td>目的操作数 &gt; 源操作数</td><td>SF=OF</td></tr><tr><td>目的操作数 = 源操作数</td><td>ZF=1</td></tr></tbody></table><p>CMP 指令是创建条件逻辑结构的重要工具。当在条件跳转指令中使用 CMP 时，汇编语言的执行结果就和 IF 语句一样。</p><p>下面用三段代码来说明标志位是如何受到 CMP 影响的。设 AX=5，并与 10 进行比较，则进位标志位将置 1，原因是（5-10）需要借位：</p><pre><code>mov ax, 5cmp ax,10    ; ZF = 0 and CF = 1</code></pre><p>1000 与 1000 比较会将零标志位置 1，因为目标操作数减去源操作数等于 0：</p><pre><code>mov ax,1000mov cx,1000cmp cx, ax       ;ZF = 1 and CF = 0105 与 0 进行比较会清除零和进位标志位，因为（105-0）的结果是一个非零的正整数。mov si,105cmp si, 0       ; ZF = 0 and CF = 0</code></pre><h2 id="汇编语言置位和清除单个CPU标志位"><a href="#汇编语言置位和清除单个CPU标志位" class="headerlink" title="汇编语言置位和清除单个CPU标志位"></a>汇编语言置位和清除单个CPU标志位</h2><p>怎样能方便地置位和清除零标志位、符号标志位、进位标志位和溢出标志位？有几种方法，其中的一些需要修改目标操作数。要将零标志位置 1，就把操作数与 0 进行 TEST 或 AND 操作；要将零标志位清零，就把操作数与 1 进行 OR 操作：</p><pre><code>test al, 0          ;零标志位置 1and al, 0          ;零标志位置 1or al, 1       ;零标志位清零</code></pre><p>TEST 指令不修改目的操作数，而 AND 指令则会修改目的操作数。若要符号标志位置 1，将操作数的最高位和 1 进行 OR 操作；若要清除符号标志位，则将操作数最高位和 0 进行 AND 操作：</p><pre><code>or al, 80h     ;符号标志位置 1and al, 7Fh    ;符号标志位清零</code></pre><p>若要进位标志位置 1，用 STC 指令；清除进位标志位，用 CLC 指令：</p><pre><code>stc          ;进位标志位置 1clc          ;进位标志位清零</code></pre><p>若要溢出标志位置 1，就把两个正数相加使之产生负的和数；若要清除溢出标志位，则将操作数和 0 进行 OR 操作：</p><pre><code>mov al,7Fh      ; AL = +127inc al        ; AL = 80h (-128), OF=1or eax, 0          ; 溢出标志位清零</code></pre><h2 id="汇编语言64位模式下的布尔指令"><a href="#汇编语言64位模式下的布尔指令" class="headerlink" title="汇编语言64位模式下的布尔指令"></a>汇编语言64位模式下的布尔指令</h2><p>大多数情况下，64 位模式中的 64 位指令与 32 位模式中的操作是一样的。比如，如果源操作数是常数，长度小于 32 位，而目的操作数是一个 64 位寄存器或内存操作数，那么，目的操作数中所有的位都会受到影响：</p><pre><code>.dataallones QWORD 0FFFFFFFFFFFFFFFFh.code    mov rax,allones                  ;RAX = FFFFFFFFFFFFFFFF    and rax,80h                      ;RAX = 0000000000000080    mov rax,allones                  ;RAX = FFFFFFFFFFFFFFFF    and rax,8080h                    ;RAX = 0000000000008080    mov rax,allones                  ;RAX = FFFFFFFFFFFFFFFF    and rax,808080h                  ;RAX = 0000000000808080</code></pre><p>但是，如果源操作数是 32 位常数或寄存器，那么目的操作数中，只有低 32 位会受到影响。如下例所示，只有 RAX 的低 32 位被修改了：</p><pre><code>mov rax,allones                ;RAX = FFFFFFFFFFFFFFFFand rax,80808080h              ;RAX = FFFFFFFF80808080</code></pre><p>当目的操作数是内存操作数时，得到的结果是一样的。显然，32 位操作数是一个特殊的情况，需要与其他大小操作数的情况分开考虑。</p><h2 id="汇编语言条件跳转简介"><a href="#汇编语言条件跳转简介" class="headerlink" title="汇编语言条件跳转简介"></a>汇编语言条件跳转简介</h2><p>x86 指令集中没有明确的高级逻辑结构，但是可以通过比较和跳转的组合来实现它们。</p><p>执行一个条件语句需要两个步骤：</p><ul><li><p>第一步，用 CMP、AND 或 SUB 操作来修改 CPU 状态标志位；</p></li><li><p>第二步，用条件跳转指令来测试标志位，并产生一个到新地址的分支。</p></li></ul><p>下面是一些例子。</p><p>【示例 1】本例中的 CMP 指令把 EAX 的值与 0 进行比较，如果该指令将零标志位置 1，则 JZ（为零跳转）指令就跳转到标号 L1：</p><pre><code>       cmp eax, 0       jz L1                  ;如果 ZF=1 则跳转       .       .L1：</code></pre><p>【示例 2】本例中的 AND 指令对 DL 寄存器进行按位与操作，并影响零标志位。如果零标志位清零，则 JNZ（非零跳转）指令跳转：</p><pre><code>       and dl,10110000b       jnz L2                        ;如果 ZF=0 则跳转       .       .L2 :</code></pre><h4 id="Jcond-指令"><a href="#Jcond-指令" class="headerlink" title="Jcond 指令"></a>Jcond 指令</h4><p>当状态标志条件为真时，条件跳转指令就分支到目标标号。否则，当标志位条件为假时，立即执行条件跳转后面的指令。语法如下所示：</p><pre><code>Jcond destination</code></pre><p>cond 是指确定一个或多个标志位状态的标志位条件。下面是基于进位和零标志位的例子：</p><table><thead><tr><th>JC</th><th>进位跳转（进位标志位置 1）</th></tr></thead><tbody><tr><td>JNC</td><td>无进位跳转（进位标志位清零）</td></tr><tr><td>JZ</td><td>为零跳转（零标志位置 1）</td></tr><tr><td>JNZ</td><td>非零跳转（零标志位清零）</td></tr></tbody></table><p>CPU 状态标志位最常见的设置方法是通过算术运算、比较和布尔运算指令。条件跳转指令评估标志位状态，利用它们来决定是否发生跳转。</p><p>用 CMP 指令 假设当 EAX=5 时，跳转到标号 L1。在下面的例子中，如果 EAX=5，CMP 指令就将零标志位置 1；之后，由于零标志位为 1，JE 指令就跳转到 L1：</p><pre><code>cmp eax,5je L1                 ;如果相等则跳转</code></pre><p>JE 指令总是按照零标志位的值进行跳转。如果 EAX 不等于 5，CMP 就会清除零标志位，那么，JE 指令将不跳转。</p><p>下例中，由于 AX 小于 6，所以 JL 指令跳转到标号 L1：</p><pre><code>mov ax, 5cmp ax, 6jl L1                ;小于则跳转</code></pre><p>下例中，由于 AX 大于4，所以发生跳转：</p><pre><code>mov ax,5cmp ax,4jg L1             ;大于则跳转</code></pre><h2 id="汇编语言条件跳转指令汇总"><a href="#汇编语言条件跳转指令汇总" class="headerlink" title="汇编语言条件跳转指令汇总"></a>汇编语言条件跳转指令汇总</h2><p>x86 指令集包含大量的条件跳转指令。它们能比较有符号和无符号整数，并根据单个 CPU 标志位的值来执行操作。条件跳转指令可以分为四个类型：</p><ul><li><p>基于特定标志位的值跳转</p></li><li><p>基于两数是否相等，或是否等于（E）CX 的值跳转</p></li><li><p>基于无符号操作数的比较跳转</p></li><li><p>基于有符号操作数的比较跳转</p></li></ul><p>下表展示了基于零标志位、进位标志位、溢出标志位、奇偶标志位和符号标志位的跳转。</p><table><thead><tr><th>助记符</th><th>说明</th><th>标志位/寄存器</th><th>助记符</th><th>说明</th><th>标志位/寄存器</th></tr></thead><tbody><tr><td>JZ</td><td>为零跳转</td><td>ZF=1</td><td>JNO</td><td>无溢出跳转</td><td>OF=0</td></tr><tr><td>JNZ</td><td>非零跳转</td><td>ZF=0</td><td>JS</td><td>有符号跳转</td><td>SF=1</td></tr><tr><td>JC</td><td>进位跳转</td><td>CF=1</td><td>JNS</td><td>无符号跳转</td><td>SF=0</td></tr><tr><td>JNC</td><td>无进位跳转</td><td>CF=0</td><td>JP</td><td>偶校验跳转</td><td>PF=1</td></tr><tr><td>JO</td><td>溢出跳转</td><td>OF=1</td><td>JNP</td><td>奇校验跳转</td><td>PF=0</td></tr></tbody></table><h4 id="1-相等性的比较"><a href="#1-相等性的比较" class="headerlink" title="1) 相等性的比较"></a>1) 相等性的比较</h4><p>下表列出了基于相等性评估的跳转指令。有些情况下，进行比较的是两个操作数；其他情况下，则是基于 CX、ECX 或 RCX 的值进行跳转。表中符号 leftOp 和 rightOp 分别指的是 CMP 指令中的左（目的）操作数和右（源）操 作数：</p><table><thead><tr><th>助记符</th><th>说明</th></tr></thead><tbody><tr><td>JE</td><td>相等跳转 (leftOp=rightOp)</td></tr><tr><td>JNE</td><td>不相等跳转 (leftOp M rightOp)</td></tr><tr><td>JCXZ</td><td>CX=0 跳转</td></tr><tr><td>JECXZ</td><td>ECX=0 跳转</td></tr><tr><td>JRCXZ</td><td>RCX=0 跳转（64 位模式）</td></tr></tbody></table><pre><code>CMP leftOp,rightOp</code></pre><p>操作数名字反映了代数中关系运算符的操作数顺序。比如，表达式 X&lt; Y 中，X 被称为 leftOp，Y 被称为 rightOp。</p><p>尽管 JE 指令相当于 JZ（为零跳转），JNE 指令相当于 JNZ（非零跳转），但是，最好是选择最能表明编程意图的助记符（JE 或 JZ），以便说明是比较两个操作数还是检查特定的状态标志位。</p><p>下述示例使用了 JE、JNE、JCXZ 和 JECXZ 指令。仔细阅读注释，以保证理解为什么条件跳转得以实现（或不实现）。</p><p>示例 1：</p><pre><code>mov edx, 0A523hcmp edx, 0A523hjne L5            ;不发生跳转je L1                        ;跳转</code></pre><p>示例 2：</p><pre><code>mov bx,1234hsub bx,1234hjne L5            ;不发生跳转je L1                        ;跳转</code></pre><p>示例 3：</p><pre><code>mov ex, 0FFFFhinc exjexz L2                     ;跳转</code></pre><p>示例4：</p><pre><code>xor ecx,ecxjeexz L2                  ;跳转</code></pre><h4 id="2-无符号数比较"><a href="#2-无符号数比较" class="headerlink" title="2) 无符号数比较"></a>2) 无符号数比较</h4><p>基于无符号数比较的跳转如下表所示。操作数的名称反映了表达式中操作数的顺序（比如 leftOp &lt; rightOp）。下表中的跳转仅在比较无符号数值时才有意义。有符号操作数使用不同的跳转指令。</p><table><thead><tr><th>助记符</th><th>说明</th><th>助记符</th><th>说明</th></tr></thead><tbody><tr><td>JA</td><td>大于跳转（若 leftOp &gt; rightOp）</td><td>JB</td><td>小于跳转（若 leftOp &lt; rightOp）</td></tr><tr><td>JNBE</td><td>不小于或等于跳转（与 JA 相同）</td><td>JNAE</td><td>不大于或等于跳转（与 JB 相同）</td></tr><tr><td>JAE</td><td>大于或等于跳转（若 leftOp ≥ rightOp）</td><td>JBE</td><td>小于或等于跳转（若 leftOp ≤ rightOp）</td></tr><tr><td>JNB</td><td>不小于跳转（与 JAE 相同）</td><td>JNA</td><td>不大于跳转（与 JBE 相同）</td></tr></tbody></table><h4 id="3-有符号数比较"><a href="#3-有符号数比较" class="headerlink" title="3) 有符号数比较"></a>3) 有符号数比较</h4><p>下表列岀了基于有符号数比较的跳转。下面的指令序列展示了两个有符号数值的比较：</p><table><thead><tr><th>助记符</th><th>说明</th><th>助记符</th><th>说明</th></tr></thead><tbody><tr><td>JG</td><td>大于跳转（若 leftOp &gt; rightOp）</td><td>JL</td><td>小于跳转（若 leftOp &lt; rightOp）</td></tr><tr><td>JNLE</td><td>不小于或等于跳转（与 JG 相同）</td><td>JNGE</td><td>不大于或等于跳转（与 JL 相同）</td></tr><tr><td>JGE</td><td>大于或等于跳转（若 leftOp ≥ rightOp）</td><td>JLE</td><td>小于或等于跳转（若 leftOp ≤ rightOp）</td></tr><tr><td>JNL</td><td>不小于跳转（与 JGE 相同）</td><td>JNG</td><td>不大于跳转（与 JLE 相同）</td></tr></tbody></table><pre><code>mov al, +127       ;十六进制数值 7Fhcmp al, -128             ;十六进制数值 80hja Is Above        ;不跳转，因为 7Fh &lt; 80hjg IsGreater        ;跳转，因为 +127 &gt; -128</code></pre><p>由于无符号数 7Fh 小于无符号数 80h，因此，为无符号数比较而设计的 JA 指令不发生跳转。另一方面，由于 +127 大于 -128，因此，为有符号数比较而设计的 JG 指令发生跳转。</p><p>对下面的代码示例，阅读注释，以保证理解为什么跳转得以实现（或不实现）：</p><p>示例 1：</p><pre><code>mov edx,-1cmp edx, 0jnl L5          ;不发生跳转（-1 ≥ 0 为假）jnle L5                 ;不发生跳转（-1 &gt; 0 为假）jl L1                     ;跳转（-1 &lt; 0 为真）</code></pre><p>示例 2：</p><pre><code>mov bx,+ 32cmp bx,-35jng L5         ;不发生跳转（ + 32 ≤ -35 为假）jnge L5        ;不发生跳转（ + 32 &lt; -35 为假）jge L1                ;跳转（ + 32 ≥ -35 为真）</code></pre><p>示例 3：</p><pre><code>mov ecx, 0cmp ecx, 0jg L5                    ;不发生跳转（0 &gt; 0 为假）jnl L1          ;跳转（0 ≥ 0 为真）</code></pre><p>示例 4：</p><pre><code>mov ecx, 0cmp ecx, 0jl L5                     ;不发生跳转（0 &lt; 0 为假）jng L1                  ;跳转（0 ≤ 0 为真）</code></pre><h2 id="汇编语言条件跳转应用及示例"><a href="#汇编语言条件跳转应用及示例" class="headerlink" title="汇编语言条件跳转应用及示例"></a>汇编语言条件跳转应用及示例</h2><p>条件跳转指令常常用这些状态标志位来决定是否将控制转向代码标号。例如，假设有一个名为 status 的 8 位内存操作数，它包含了与计算机连接的一个外设的状态信息。如果该操作数的位 5 等于 1，表示外设离线，则下面的指令就跳转到标号：</p><pre><code>mov al, statustest al, 00100000b         ;测试位 5jnz DeviceOffline</code></pre><p>如果位 0、1 或 4 中任一位置 1，则下面的语句跳转到标号：</p><pre><code>mov al, statustest al, 00010011b         ;测试位 0、1、4jnz InputDataByte</code></pre><p>如果是位 2、3 和 7 都置 1 使得跳转发生，则还需要 AND 和 CMP 指令：</p><pre><code>mov al, statusand al,10001100b            ;屏蔽位 2、3 和 7cmp al, 10001100b          ;所有位都置 1 ?je ResetMachine        ;是：跳转</code></pre><h4 id="两个数中的较大数"><a href="#两个数中的较大数" class="headerlink" title="两个数中的较大数"></a>两个数中的较大数</h4><p>下面的代码比较了 EAX 和 EBX 中的两个无符号整数，并且把其中较大的数送入 EDX：</p><pre><code>   mov   edx, eax        ;假设EAX存放较大的数   cmp eax, ebx                  ;若 EAX ≥ EBX   jae L1                              ;跳转到 L1   mov   edx, ebx        ;否则，将 EBX 的值送入 EDXL1:                                      ;EDX 中存放的是较大的数</code></pre><h4 id="三个数中的最小数"><a href="#三个数中的最小数" class="headerlink" title="三个数中的最小数"></a>三个数中的最小数</h4><pre><code>下面的代码比较了分别存放于三个变量 VI、V2 和 V3 的无符号 16 位数值，并且把其中最小的数送入AX：.dataV1 WORD ?V2 WORD ?V3 WORD ?.code       mov   ax, V1   ;假设 V1 是最小值       cmp   ax, V2   ;如果 AX ≤ V2       jbe   L1       ;跳转到 L1       mov   ax, V2   ;否则，将 V2 送入 AXLI:    cmp   ax, V3   ;如果 AX ≤ V3       jbe L2        ;跳转到L2       mov   ax, V3    ;否则，将V3送入AXL2 :</code></pre><h4 id="循环直到按下按键"><a href="#循环直到按下按键" class="headerlink" title="循环直到按下按键"></a>循环直到按下按键</h4><p>下面的 32 位代码会持续循环，直到用户按下任意一个标准的字母数字键。如果输入缓冲区中当前没有按键，那么 Irvine32 库中的 ReadKey 函数就会将零标 志位置1:</p><pre><code>.datachar BYTE ?.codeL1: mov eax, 10                call Delay             ;创建 10 毫秒的延迟;       call ReadKey    ;检查按键       jz L1           ;如果没有按键则循环       mov char, AL    ;保存字符)</code></pre><p>上述代码在循环中插入了一个 10 毫秒的延迟，以便 MS-Windows 有时间处理事件消息。如果省略这个延迟，那么按键可能被忽略。</p><h4 id="【示例-1】：顺序搜索数组"><a href="#【示例-1】：顺序搜索数组" class="headerlink" title="【示例 1】：顺序搜索数组"></a>【示例 1】：顺序搜索数组</h4><p>常见的编程任务是在数组中搜索满足某些条件的数值。例如，下述程序就是在一个 16 位数组中寻找第一个非零数值。如果找到，则显示该数值；否则，就显示一条信息，以说明没有发现非零数值：</p><pre><code>;扫描数组    （ArrayScan.asm）;扫描数组寻找第一个非零数值INCLUDE Irvine32.inc.dataintArray SWORD 0,0,0,0,1,20,35,-12,66,4,0;intArray SWORD 1,0,0,0            ;候补测试数据;intArray SWORD 0,0,0,0            ;候补测试数据;intArray SWORD 0,0,0,1            ;候补测试数据noneMsg BYTE "A non-zero value was not found",0.codemain PROC    mov ebx,OFFSET intArray        ;指向数组    mov ecx,LENGTHOF intArray      ;循环计数器L1: cmp WORD PTR [ebx],0           ;将数值与0比较    jnz found                      ;寻找数值    add ebx,2                      ;指向下一个元素    loop L1                        ;继续循环    jmp    notFound                ;没有发现非零数值found:    movsx eax,WORD PTR[ebx]        ;送人EAX并进行符号扩展    call WriteInt    jmp quitnotFound:    mov edx,OFFSET noneMsg         ;显示“没有发现”消息    call WriteStringquit:    call Crlf    exitmain ENDPEND main本程序包含了可以替换的测试数据，它们已经被注释出来。取消这些注释行，就可 以用不同的数据配置来测试程序。</code></pre><h4 id="【示例-2】：简单字符串加密"><a href="#【示例-2】：简单字符串加密" class="headerlink" title="【示例 2】：简单字符串加密"></a>【示例 2】：简单字符串加密</h4><p>XOR 指令有一个有趣的属性。如果一个整数 X 与 Y 进行 XOR，其结果再次与 Y 进行 XOR，则最后的结果就是 X：</p><p>( ( X ㊉ Y ) ㊉ Y) = X</p><p>XOR 的可逆性为简单数据加密提供了一种方便的途径：明文消息转换成加密字符串，这个加密字符串被称为密文，加密方法是将该消息与被称为密钥的第三个字符串按位进行 XOR 操作。预期的查看者可以用密钥解密密文，从而生成原始的明文。</p><p>下面将演示一个使用对称加密的简单程序，即用同一个密钥既实现加密又实现解密的过程。运行时，下述步骤依序发生：</p><p>\1) 用户输入明文。</p><p>\2) 程序使用单字符密钥对明文加密，产生密文并显示在屏幕上。</p><p>\3) 程序解密密文，产生初始明文并显示出来。</p><p>程序清单完整的程序清单如下所示：</p><pre><code>;加密程序    （Encrypt.asm）INCLUDE Irvine32.incKEY = 239                    ;1-255之间的任一值BUFMAX = 128                 ;缓冲区的最大容量.datasPrompt BYTE "Enter the plain text:",0sEncrypt BYTE "Cipher text",0sDecrypt BYTE "Decrypted:",0buffer BYTE BUFMAX+1 DUP(0)bufSize DWORD ?.codemain PROC    call InputTheString        ;输入明文    call TranslateBuffer       ;加密缓冲区    mov edx,OFFSET sEncrypt    ;显示加密消息    call DisplayMessage    call TranslateBuffer       ;解密缓冲区    mov edx,OFFSET sDecrypt    ;显示解密消息    call DisplayMessage    exitmain ENDP;-----------------------------------------InputTheString PROC;;提示用户输入一个纯文本字符串;保存字符串和它的长度;接收：无;返回：无;-----------------------------------------    pushad                     ;保存32位寄存器    mov edx,OFFSET sPrompt     ;显示提示    call WriteString    mov ecx,BUFMAX             ;字符计数器最大值    mov edx,OFFSET buffer      ;指向缓冲区    call ReadString            ;输入字符串    mov bufSize,eax            ;保存长度    call Crlf    popad    retInputTheString ENDP;-----------------------------------------DisplayMessage PROC;;显示加密或解密消息;接收：EDX指向消息;返回：无;-----------------------------------------    pushad    call WriteString    mov edx,OFFSET buffer        ;显示缓冲区    call WriteString    call Crlf    call Crlf    popad    retDisplayMessage ENDP;-----------------------------------------TranslateBuffer PROC;;字符串的每个字节都与密钥字节进行异或;实现转换;接收：无;返回：无;-----------------------------------------    pushad    mov ecx,bufSize                ;循环计数器    mov esi,0                      ;缓冲区索引初始值赋0L1:    xor buffer[esi],KEY            ;转换一个字节    inc esi                        ;指向下一个字节    loop L1    popad    retTranslateBuffer ENDPEND main</code></pre><h2 id="汇编语言LOOPZ（为零跳转）和LOOPE（相等跳转）指令"><a href="#汇编语言LOOPZ（为零跳转）和LOOPE（相等跳转）指令" class="headerlink" title="汇编语言LOOPZ（为零跳转）和LOOPE（相等跳转）指令"></a>汇编语言LOOPZ（为零跳转）和LOOPE（相等跳转）指令</h2><p>LOOPZ（为零跳转）指令的工作和 LOOP 指令相同，只是有一个附加条件：为零控制转向目的标号，零标志位必须置 1。指令语法如下：</p><pre><code>LOOPZ destination</code></pre><p>LOOPE（相等跳转）指令相当于 LOOPZ 它们有相同的操作码。这两条指令执行如下任务：</p><pre><code>ECX = ECX - 1if ECX &gt; 0 and ZF = 1, jump to destination</code></pre><p>否则，不发生跳转，并将控制传递到下一条指令。LOOPZ 和 LOOPE 不影响任何状态标志位。32 位模式下，ECX 是循环计数器；64 位模式下，RCX 是循环计数器。</p><h2 id="汇编语言LOOPNZ（非零跳转）和LOOPNE（不等跳转）指令"><a href="#汇编语言LOOPNZ（非零跳转）和LOOPNE（不等跳转）指令" class="headerlink" title="汇编语言LOOPNZ（非零跳转）和LOOPNE（不等跳转）指令"></a>汇编语言LOOPNZ（非零跳转）和LOOPNE（不等跳转）指令</h2><p>LOOPNZ（非零跳转）指令与 LOOPZ 相对应。当 ECX 中无符号数值大于零（减 1 操作之后）且零标志位等于零时，继续循环。指令语法如下：</p><pre><code>LOOPNZ destination</code></pre><p>LOOPNE（不等跳转）指令相当于 LOOPNZ 它们有相同的操作码。这两条指令执行如 下任务：</p><pre><code>ECX = ECX - 1if ECX &gt; 0 and ZF = 0, jump to destination</code></pre><p>否则，不发生跳转，并将控制传递到下一条指令。</p><p>【示例】扫描数组中的每一个数，直到发现一个非负数（符号位为 0）为止。注意，在执行 ADD 指令前要把标志位压入堆栈，因为 ADD 有可能修改标志位。然后在执行 LOOPNZ 指令之前，用 POPFD 恢复这些标志位：</p><pre><code>.dataarray  SWORD  -3,-6,-1,-10,10,30,40,4sentinel SWORD  0.codemain PROCmov esi,OFFSET arraymov ecx,LENGTHOF arraynext:test WORD PTR [esi],8000h    ; 测试符号位pushfd                       ; 标志位入栈add  esi,TYPE array          ; 移动到下一个位置popfd                        ; 标志位出栈loopnz next                  ; 继续循环jnz  quit                    ; 没有发现非负数sub  esi,TYPE array          ; ESI 指向数值quit:</code></pre><p>如果找到一个非负数，ESI 会指向该数值。如果没有找到一个正数，则只有当 ECX=0 时才终止循环。在这种情况下，JNZ 指令跳转到标号 quit，同时 ESI 指向标记值（0），其在内存中的位置正好紧接着该数组。</p><h2 id="使用汇编语言实现IF语句"><a href="#使用汇编语言实现IF语句" class="headerlink" title="使用汇编语言实现IF语句"></a>使用汇编语言实现IF语句</h2><p>IF 结构包含一个布尔表达式，其后有两个语句列表：一个是当表达式为真时执行，另一个是当表达式为假时执行：</p><pre><code>if( boolean-expression )   statement-list-1else   statement-list-2</code></pre><p>结构中的 else 部分是可选的。在汇编语言中，则是用多个步骤来实现这种结构的。首先，对布尔表达式求值，这样一来某个 CPU 状态标志位会受到影响。然后，根据相关 CPU 状态标志位的值，构建一系列跳转把控制传递给两个语句列表。</p><p>【示例 1】下面的 C++ 代码中，如果 op1 等于 op2，则执行两条赋值语句：</p><pre><code>if( op1 = op2 ){    X = 1;    Y = 2;}</code></pre><p>在汇编语言中，这种 IF 语句转换为条件跳转和 CMP 指令。由于 op1 和 op2 都是内存操作数（变量），因此，在执行 CMP 之前，要将其中的一个操作数送入寄存器。</p><p>下面实现 IF 语句的程序是高效的，当逻辑表达式为真时，它允许代码“通过”直达两条期望被执行的 MOV 指令：</p><pre><code>        mov eax, op1        cmp eax,op2                  ; op1 == op2?        jne L1                       ; 否：跳过后续指令        mov X, 1                     ; 是：X, Y 赋值        mov Y, 2L1:</code></pre><p>如果用 JE 来实现 == 运算符，生成的代码就没有那么紧凑了（6 条指令，而非 5 条指令）：</p><pre><code>        mov    eax, op1        cmp    eax,op2              ; op1 == op2?        je    L1                    ; 是：跳转到 L1        jmp    L2                   ; 否：跳过赋值语句LI：    mov X, 1                    ; X, Y 赋值        mov    Y, 2L2 :</code></pre><p>从上面的例子可以看出，相同的条件结构在汇编语言中有多种实现方法。上面给出 的编译代码示例只代表一种假想的编译器可能产生的结果。</p><p>【示例 2】NTFS 文件存储系统中，磁盘簇的大小取决于磁盘卷的总容量。如下面的伪代码所示，如果卷大小（用变量 terrabytes 存放）不超过 16TB，则簇大小设置为 4096。否则， 簇大小设置为 8192：</p><pre><code>clusterSize = 8192;if terrabytes &lt; 16   clusterSize = 4096;</code></pre><p>用汇编语言实现该伪代码：</p><pre><code>        mov clusterSize, 8192                ;假设较大的磁盘簇        cmp terrabytes, 16                   ;小于 16TB?        jae next        mov clusterSize, 4096                ;切换到较小的磁盘簇next:</code></pre><p>【示例 3】下面的伪代码有两个分支：</p><pre><code>if op1 &gt; op2   call Routine1else   call Routine2end if</code></pre><p>用汇编语言翻译这段伪代码，设 op1 和 op2 是有符号双字变量。对这两个变量比较时，其中一个必须送入寄存器：</p><pre><code>        mov eax, op1                    ; opl送入寄存器        cmp    eax, op2                 ; opl &gt; op2?        jg    A1                        ; 是：调用 Routine1        call    Routine2                ; 否：调用 Routine2        jmp    A2    ;退出工F语句A1:     call Routine1A2:</code></pre><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p>复杂条件语句可能有多个执行路径，这使得它们难以进行调试检查（查看代码）。程序员经常使用的技术称为白盒测试，用来验证子程序的输入和相应的输出。</p><p>白盒测试需要源代码，并对输入变量进行不同的赋值。对每个输入组合，要手动跟踪源代码，验证其执行路径和子程序产生的输出。下面，通过嵌套 IF 语句的汇编程序来看看这个测试过程：</p><pre><code>if op1 == op2    if X &gt; Y        call Routine1    else        call Routine2    end ifelse    call Routine3end if</code></pre><p>下面是可能的汇编语言翻译，加上了参考行号。程序改变了初始条件（op1 == op2），并立即跳转到 ELSE 部分。剩下要翻译的内容是内层 IF-ELSE 语句：</p><pre><code>        mov    eax, op1        cmp eax, op2                             ;op1 == op2?        jne    L2                                ;否：调用 Routine3; 处理内层 IF-ELSE 语句。        mov    eax, X        cmp    eax, Y                             ; X &gt; Y?        jg    L1                                  ; 是：调用 Routine1        call    Routine2                          ; 否：调用 Routine2        jmp    L3                                 ; 退出L1:     call Routine1                             ; 调用 Routine1        jmp    L3                                 ; 退出L2:     call    Routine3L3:</code></pre><p>下表给出了示例代码的白盒测试结果。前四列对 op1、op2、X 和 Y 进行测试赋值。第 5 列和第 6 列对生成的执行路径进行了验证。</p><table><thead><tr><th>op1</th><th>op2</th><th>X</th><th>Y</th><th>执行行序列</th><th>调用</th></tr></thead><tbody><tr><td>10</td><td>20</td><td>30</td><td>40</td><td>1, 2, 3, 11, 12</td><td>Rountine3</td></tr><tr><td>10</td><td>20</td><td>40</td><td>30</td><td>1, 2, 3, 11, 12</td><td>Rountine3</td></tr><tr><td>10</td><td>10</td><td>30</td><td>40</td><td>1, 2, 3, 4, 5, 6, 7, 8, 12</td><td>Rountine2</td></tr><tr><td>10</td><td>10</td><td>40</td><td>30</td><td>1, 2, 3, 4, 5, 6, 9, 10, 12</td><td>Rountine1</td></tr></tbody></table><h2 id="使用汇编语言实现逻辑表达式"><a href="#使用汇编语言实现逻辑表达式" class="headerlink" title="使用汇编语言实现逻辑表达式"></a>使用汇编语言实现逻辑表达式</h2><h3 id="逻辑-AND-运算符"><a href="#逻辑-AND-运算符" class="headerlink" title="逻辑 AND 运算符"></a>逻辑 AND 运算符</h3><p>汇编语言很容易实现包含 AND 运算符的复合布尔表达式。考虑下面的伪代码，假设其中进行比较的是无符号整数：</p><pre><code>if (a1 &gt; b1) AND (b1 &gt; c1)   X = 1end if</code></pre><h4 id="短路求值"><a href="#短路求值" class="headerlink" title="短路求值"></a>短路求值</h4><p>下面的例子是短路求值的简单实现，如果第一个表达式为假，则不需计算第二个表达式。高级语言的规范如下：</p><pre><code>        cmp a1,b1                  ;第一个表达式…        ja L1        jmp nextL1:     cmp b1, c1                 ;第二个表达式…        ja L2        jmp nextL2:   mov X, 1                     ;全为真：将 X 置 1next:</code></pre><p>如果把第一条 JA 指令替换为 JBE，就可以把代码减少到 5 条：</p><pre><code>        cmp    a1,b1                  ; 第一个表达式…        jbe next                      ; 如果假，则退出        cmp    b1,c1                  ; 第二个表达式…        jbe next                      ; 如果假，则退出        mov    X, 1                   ; 全为真next:</code></pre><p>若第一个 JBE 不执行，CPU 可以直接执行第二个 CMP 指令，这样就能够减少 29% 的代码量（指令数从 7 条减少到 5 条）。</p><h2 id="逻辑-OR-运算符"><a href="#逻辑-OR-运算符" class="headerlink" title="逻辑 OR 运算符"></a>逻辑 OR 运算符</h2><p>当复合表达式包含的子表达式是用 OR 运算符连接的，那么只要一个子表达式为真，则整个复合表达式就为真。以如下伪代码为例：</p><pre><code>if (a1 &gt; b1) OR (b1 &gt; c1)   X = 1</code></pre><p>在下面的实现过程中，如果第一个表达式为真，则代码分支到 L1；否则代码直接执行第二个 CMP 指令。第二个表达式翻转了 &gt; 运算符，并使用了 JBE 指令：</p><pre><code>        cmp a1, b1                  ; 1：比较 AL 和 BL        ja L1                       ; 如果真，跳过第二个表达式        cmp b1, c1                  ; 2：比较 BL 和 CL        jbe next                    ; 假：跳过下一条语句L1:     mov X, 1                    ; 真：将 x 置 1next:</code></pre><p>对于一个给定的复合表达式而言，汇编语句有多种实现方法。</p><h2 id="使用汇编语言实现WHILE循环"><a href="#使用汇编语言实现WHILE循环" class="headerlink" title="使用汇编语言实现WHILE循环"></a>使用汇编语言实现WHILE循环</h2><p>WHILE 循环在执行语句块之前先进行条件测试。只要循环条件一直为真，那么语句块就不断重复。下面是用 C++ 编写的循环：</p><pre><code>while( val1 &lt; val2 ){   val1++；   val2 --；}</code></pre><p>用汇编语言实现这个结构时，可以很方便地改变循环条件，当条件为真时，跳转到 endwhile。假设 val1 和 val2 都是变量，那么在循环开始之前必须将其中的一个变量送入寄存器，并且还要在最后恢复该变量的值：</p><pre><code>        mov eax, val1                  ; 把变量复制到 EAXbeginwhile:        cmp eax, val2                  ; 如果非 val1 &lt; val2        jnl     endwhile               ; 退出循环        inc    eax                     ; val1++;        dec    val2                    ; val2--;        jmp    beginwhile              ; 重复循环endwhile:        mov    val1, eax                ;保存 val1 的新值</code></pre><p>在循环内部，EAX 是 val1 的代理（替代品），对 val1 的引用必须要通过 EAX。JNL 的使用意味着 val1 和 val2 是有符号整数。</p><p>【示例】循环内的 IF 语句嵌套</p><p>高级语言尤其善于表示嵌套的控制结构。如下 C++ 代码所示，在一个 WHILE 循环中有嵌套 IF 语句。它计算所有大于 sample 值的数组元素之和：</p><pre><code>int array[] = {10,60,20,33,72,89,45,65,72,18};int sample  =  50;int ArraySize = sizeof array / sizeof sample;int index = 0;int sum  =  0;while( index &lt; ArraySize ){    if( array[index] &gt; sample )    {        sum += array[index];    }    index++;}</code></pre><p>在用汇编语言编写该循环之前，用下图的流程图来说明其逻辑。为了简化转换过程，并通过减少内存访问次数来加速执行，图中用寄存器来代替变量：EDX-sample, EAX=sum, ESI=index, ECX=ArraySize ( 常数 )。标号名称也已经添加到逻辑框上。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224258239127" alt="img"></p><h4 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码"></a>汇编代码</h4><p>从流程图生成汇编代码最简单的方法就是为每个流程框编写单独的代码。注意流程图标签和下面源代码使用标签之间的直接关系：</p><pre><code>array DWORD 10,60,20,33,72,89,45,65,72,18ArraySize = ($ - Array) / TYPE array.codemain PROC    mov    eax,0                           ; 求和    mov    edx,sample    mov    esi,0                           ; 索引    mov    ecx,ArraySizeL1: cmp    esi,ecx                         ; 如果 esi &lt; ecx    jl    L2    jmp    L5L2: cmp    array[esi*4], edx               ; 如果array[esi] &gt; edx    jg    L3    jmp    L4L3: add    eax,array[esi*4]L4: inc    esi    jmp    L1L5: mov    sum,eax</code></pre><h2 id="汇编语言表驱动选择"><a href="#汇编语言表驱动选择" class="headerlink" title="汇编语言表驱动选择"></a>汇编语言表驱动选择</h2><p>表驱动选择是用查表来代替多路选择结构的一种方法。使用这种方法，需要新建一个表，表中包含查询值和标号或过程的偏移量，然后必须用循环来检索这个表。当有大量比较操作时，这个方法最有效。</p><p>例如，下面是一个表的一部分，该表包含单字符查询值，以及过程的地址：</p><pre><code>.dataCaseTable BYTE   'A'          ;查询值       DWORD Process_A   ;过程地址       BYTE 'B'       DWORD Process_B       (etc.)</code></pre><p>假设 Process_A、Process_B、Process_C 和 Process_D 的地址分别是 120h、130h、140h 和 150h。上表在内存中的存放如下图所示。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224276467129" alt="img"></p><h4 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h4><p>用户从键盘输入一个字符。通过循环，该字符与表的每个表项进行比较。第一个匹配的查询值将会产生一个调用，调用对象是紧接在该查询值后面的过程偏移量。每个过程加载到 EDX 的偏移量都代表了一个不同的字符串，它将在循环中显示：</p><pre><code>; 过程偏移量表          (ProcTble.asm); 本程序包含了过程偏移量表格; 使用这个表执行间接过程调用INCLUDE Irvine32.inc.dataCaseTable  BYTE   'A'                  ; 查询值           DWORD   Process_A           ; 过程地址           BYTE   'B'           DWORD   Process_B           BYTE   'C'           DWORD   Process_C           BYTE   'D'           DWORD   Process_DNumberOfEntries = 4prompt BYTE "Press capital A,B,C,or D: ",0;为每个过程定义一个单独的消息字串msgA BYTE "Process_A",0msgB BYTE "Process_B",0msgC BYTE "Process_C",0msgD BYTE "Process_D",0.codemain PROC    mov  edx,OFFSET prompt              ; 请求用户输入    call WriteString    call ReadChar                       ; 读取字符到AL    mov  ebx,OFFSET CaseTable           ; 设 EBX 为表指针    mov  ecx,NumberOfEntries            ; 循环计数器L1:    cmp  al,[ebx]                       ; 出现匹配项?    jne  L2                             ; 否: 继续    call NEAR PTR [ebx + 1]             ; 是: 调用过程;这个 CALL 指令调用过程，其地址保存在 EBX+1 指向的内存位置中，像这样的间接调用需要使用 NEAR PTR 运算符    call WriteString                    ; 显示消息    call Crlf    jmp  L3                             ; 推出搜索    add  ebx,5                          ; 指向下一个表项    loop L1                             ; 重复直到 ECX = 0L3:    exitmain ENDP;下面的每个过程向EDX加载不同字符串的偏移量Process_A PROC    mov  edx,OFFSET msgA    retProcess_A ENDPProcess_B PROC    mov  edx,OFFSET msgB    retProcess_B ENDPProcess_C PROC    mov  edx,OFFSET msgC    retProcess_C ENDPProcess_D PROC    mov  edx,OFFSET msgD    retProcess_D ENDPEND main</code></pre><p>表驱动选择有一些初始化开销，但是它能减少编写的代码总量。一个表就可以处理大量的比较，并且与一长串的比较、跳转和 CALL 指令序列相比，它更加容易修改。甚至在运行时，表还可以重新配置。</p><h2 id="有限状态机（FSM）与汇编语言-附带实例"><a href="#有限状态机（FSM）与汇编语言-附带实例" class="headerlink" title="有限状态机（FSM）与汇编语言[附带实例]"></a>有限状态机（FSM）与汇编语言[附带实例]</h2><p>有限状态机（FSM）是一个根据输入改变状态的机器或程序。用图表示 FSM 相当简明， 下图中的矩形（或圆形）称为节点，节点之间带箭头的线段称为边（或弧）。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224297492131" alt="img"></p><p>上图给出了一个简单的例子。每个节点代表一个程序状态，每个边代表从一个状态到另一个状态的转换。一个节点被指定为初始状态，在图中用一个输入箭头指出。其余的状态可以用数字或字母来标示。一个或多个状态可以指定为终止状态，用粗框矩形表示。终止状态表示程序无出错的结束状态。</p><p>FSM 是一种被称为有向图的更一般结构的特例。有向图就是一组节点，它们用具有特定方向的边进行连接。</p><h3 id="验证输入字符串"><a href="#验证输入字符串" class="headerlink" title="验证输入字符串"></a>验证输入字符串</h3><p>读取输入流的程序往往要通过执行一定量的错误检查来验证它们的输入。比如，编程语言编译器可以用 FSM 来扫描程序，将文字和符号转换为记号（通常是指关键字、算法运算符和标识符）。</p><p>用 FSM 来验证输入字符串时，常常是按字符进行读取。每一个字符都用图中的一条边（转换）来表示。FSM 有两种方法检测非法输入序列：</p><ul><li><p>下一个输入字符没有对应到当前状态的任何一个转换。</p></li><li><p>输入已经终止，但是当前状态是非终止状态。</p></li></ul><p>字符串示例现在根据下面两条原则来验证一个输入字符串：</p><ul><li><p>该字符串必须以字母“x”开始，以字母“z”结束。</p></li><li><p>第一个和最后一个字符之间可以有零个或多个字母，但其范围必须是 {a,….,y}。</p></li></ul><p>下图的 FSM 显示了上述语法。每一个转换都是由特定类型的输入来标识。比如，仅当从输入流中读取字母 x 时，才能完成状态 A 到状态 B 的转换。输入任何非“z”的字母，都会使得状态 B 转换为其自身。而仅当从输入流中读取字母 z 时，才会发生状态 B 到状态 C 的转换。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224316028133" alt="img"></p><p>如果输入流已经结束，而程序只出现了状态 A 和状态 B，那么就生成出错条件，因为只有状态 C 才能标记终止状态。下述输入字符串能被该 FSM 认可：</p><pre><code>xaabcdefgzxzxyyqqrrstuvz</code></pre><h3 id="验证有符号整数"><a href="#验证有符号整数" class="headerlink" title="验证有符号整数"></a>验证有符号整数</h3><p>下图表示的是 FSM 解析一个有符号整数。输入包括一个可选的前置符号，其后跟一串数字。图中没有对数字个数进行限制。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224328124135" alt="img"></p><p>有限状态机很容易转换为汇编代码。图中的每个状态（A、B、C…）代表了一段有标号的程序。每个标号执行的操作如下：</p><p>\1) 调用输入程序读入下一个输入字符。</p><p>\2)   如果是终止状态，则检查用户是否按下 Enter 键来结束输入。</p><p>\3)   一个或多个比较指令检查从状态发岀的所有可能的转换。每个比较指令后面跟一个条件跳转指令。</p><p>比如，在状态 A，如下代码读取下一个输入字符并检查到状态 B 的可能的转换：</p><pre><code>StateA:        Cal1 Getnext                          ;读取下一个字符，并送入 AL        cmp    al, '+'                        ;前置+ ?        je    StateB                          ;到状态 b        cmp    al, '-'                        ;前置 - ?        je    StateB                          ;到状态 B        call    IsDigit                       ;如果 AL 包含数字，则 ZF = 1        jz    StateC                          ;到状态 C        call    DisplayErrorMsg               ;发现非法输入        jmp Quit</code></pre><p>下面来更详细地检查这段代码。首先，代码调用 Getnext，从控制台输入读取下一个字符，送入 AL 寄存器。接着检查前置 + 或 -，先将 AL 的值与符号“+”进行比较，如果匹配，就发生到标号 StateB 的跳转：</p><pre><code>StateA:        call Getnext                         ;读取下一个字符，并送入 al        cmp al, ' + '                        ;前置 + ?        je StateB                            ;到状态 B</code></pre><p>现在，再次查看上图，发现只有输入 + 或 - 时，才发生状态 A 到状态 B 的转换。所以，代码还需检查减号：</p><pre><code>cmp al, '-'                                  ;前置 - ？je StateB                                    ;到状态 B</code></pre><p>如果无法发生到状态 B 的转换，就可以检查 AL 寄存器中是否为数字，这可以导致到状态 C 的转换。调用 IsDigit 子程序，当 AL 包含数字时，零标志位置 1：</p><pre><code>call IsDigit                                 ;如果AL包含数字，贝U ZF=1jz StateC                                    ;到状态 C</code></pre><p>最后，状态 A 没有其他可能的转换。如果发现 AL 中的字符既不是前置符号，又不是数字，程序就会调用 DisplayErrorMsg （在控制台上显示一条错误消息）子程序，并跳转到标号 Quit 处：</p><pre><code>call DisplayErrorMsg                         ;发现非法输入jmp Quit</code></pre><p>标号 Quit 标识程序的出口，位于主程序的结尾：</p><pre><code>Quit:    call Crlf    exitmain ENDP</code></pre><h3 id="完整的有限状态机程序"><a href="#完整的有限状态机程序" class="headerlink" title="完整的有限状态机程序"></a>完整的有限状态机程序</h3><p>如下程序实现上图所示的有符号整数 FSM：</p><pre><code>; 有限状态机              (Finite.asm)INCLUDE Irvine32.incENTER_KEY = 13.dataInvalidInputMsg BYTE "Invalid input",13,10,0.codemain PROC    call ClrscrStateA:    call    Getnext               ; 读取下一个字符，并送入AL    cmp    al,'+'                 ; 前置+ ?    je    StateB                  ; 到状态 B    cmp    al,'-'                 ; 前置 - ?    je    StateB                  ; 到状态 B    call    IsDigit               ; 如果 AL 包含数字 ，则 ZF = 1    jz    StateC                  ; 到状态 C    call    DisplayErrorMsg       ; 发现非法输入    jmp    QuitStateB:    call    Getnext               ; 读取下一个字符，并送入AL    call    IsDigit               ; 如果AL包含数字，则 ZF = 1    jz    StateC    call    DisplayErrorMsg       ; 发现非法输入    jmp    QuitStateC:    call    Getnext               ; 读取下一个字符，并送入AL    call    IsDigit               ; 如果AL包含数字，则 ZF = 1    jz    StateC    cmp    al,ENTER_KEY           ; 按下Enter键?    je    Quit                    ; 是：Quit    call    DisplayErrorMsg       ; 否: 发现非法输入    jmp    QuitQuit:    call    Crlf    exitmain ENDP;-----------------------------------------------Getnext PROC;; 从标准输入读取一个字符; 接收: 无; 返回: 字符保存在AL中;-----------------------------------------------     call ReadChar            ; 从键盘输入     call WriteChar           ; 显示在屏幕上     retGetnext ENDP;-----------------------------------------------DisplayErrorMsg PROC;; 显示一个错误消息以表示; 输入流中包含非法输入; 接收: 无.; 返回: 无;-----------------------------------------------     push  edx     mov      edx,OFFSET InvalidInputMsg     call  WriteString     pop      edx     retDisplayErrorMsg ENDPEND main</code></pre><h3 id="IsDigit子程序"><a href="#IsDigit子程序" class="headerlink" title="IsDigit子程序"></a>IsDigit子程序</h3><p>有限状态机示例程序调用 IsDigit 子程序，该子程序属于本教程的链接库。现在来看看 IsDigit 的源程序，程序把 AL 寄存器作为输入，其返回值设置零标志位：</p><pre><code>;----------------------------------------------------IsDigit PROC;;确定 AL 中的字符是否为有效的十进制数字。;接收：AL= 字符;返回：若 AL 为有效的十进制字符，ZF=1;否则，ZF=0;---------------------------------------------------        cmp    al,'0'        jb    ID1                                 ;跳转发生，ZF=0        cmp    al, '9'        ja    ID1                                 ;跳转发生，ZF = 0        test    ax, 0                             ;设置 ZF=1ID1: retIsDigit ENDP</code></pre><p>在查看 IsDigit 的代码之前，先回顾十进制数字的十六进制 ASCII 码，如下表所示。由于这些值是连续的，因此，只需要检查第一个和最后一个值：</p><table><thead><tr><th>字符</th><th>‘0’</th><th>‘1’</th><th>‘2’</th><th>‘3’</th><th>‘4’</th><th>‘5’</th><th>‘6’</th><th>‘7’</th><th>‘8’</th><th>‘9’</th></tr></thead><tbody><tr><td>ASCII 码（十六进制）</td><td>30</td><td>31</td><td>32</td><td>33</td><td>34</td><td>35</td><td>36</td><td>37</td><td>38</td><td>39</td></tr></tbody></table><p>IsDigit 子程序中，开始的两条指令将 AL 寄存器中字符的值与数字 0 的 ASCII 码进行比较。如果字符的 ASCII 码小于 0 的 ASCII 码，程序跳转到标号 ID1：</p><pre><code>cmp al, '0'jb ID1                       ;跳转发生，ZF=0</code></pre><p>但是有人可能会问了，如果 JB 将控制传递给标号 ID1，那么，怎么知道零标志位的状态呢？答案就在 CMP 指令的执行方式里——它执行一个隐含的减法操作，从 AL 寄存器的字符中减去 0 的 ASCII 码（30h）。如果 AL 中的值较小，那么进位标志位置 1，零标志位清除（你可能想用调试器来单步执行这段代码来验证这个事实）。JB 指令的目的是，当 CF=1 且 ZF=0 时，将控制传递给一个标号。</p><p>接下来，IsDigit 子程序代码把 AL 与数字 9 的 ASCII 码进行比较。如果 AL 的值较大，代码跳转到同一个标号：</p><pre><code>cmp al, '9'ja ID1                ;跳转发生，ZF=0</code></pre><p>如果 AL 中字符的 ASCII 码大于数字 9 的 ASCII 码（39h），清除进位标志位和零标志位。这也正好是使得 JA 指令将控制传递到目的标号的标志位组合。</p><p>如果没有跳转发生（JA 或 JE），又假设 AL 中的字符确实是一个数字，则插入一条指令确保将零标志位置 1。将 0 与任何数值进行 test 操作，就意味着执行一次隐含的与全 0 的 AND 运算。其结果必然为 0：</p><pre><code>test ax, 0         ; 置 ZF=1</code></pre><p>前面 IsDigit 中的 JA 和 JB 指令跳转到了 TEST 指令后面的标号。所以，如果发生跳转，零标志位将清零。下面再次给出完整的过程：</p><pre><code>Isdigit PROC    cmp al,'0'    jb ID1             ;若跳转发生，则 ZF=0    cmp al,'9'    ja ID1             ;若跳转发生，则 ZF=0    test ax,0          ;置 zf=1ID1: retIsdigit ENDP</code></pre><p>在实时或高性能应用中，程序员常常利用硬件特性的优势，来对其代码进行充分优化。IsDigit 过程就是这种方法的例子，它利用 JB、JA 和 TEST 对标志的设置，实际上返回的是一个布尔结果。</p><h2 id="汇编语言条件控制流伪指令"><a href="#汇编语言条件控制流伪指令" class="headerlink" title="汇编语言条件控制流伪指令"></a>汇编语言条件控制流伪指令</h2><p>32 位模式下，MASM 包含了一些高级条件控制流伪指令（conditional control flow directives），这有助于简化编写条件语句。遗憾的是，这些伪指令不能用于 64 位模式。</p><p>对程序进行汇编之前，汇编器执行的是预处理步骤。在这个步骤中，汇编器要识别伪指令，如：.CODE、.DATA，以及一些用于条件控制流的伪指令。下表列出了这些伪指令。</p><table><thead><tr><th>伪指令</th><th>说明</th></tr></thead><tbody><tr><td>.BREAK</td><td>生成代码终止 .WHILE 或 .REPEAT 块</td></tr><tr><td>.CONTINUE</td><td>生成代码跳转到 .WHILE 或 .REPEAT 块的顶端</td></tr><tr><td>.ELSE</td><td>当 .IF 条件不满足时，开始执行的语句块</td></tr><tr><td>.ELSEIF condition</td><td>生成代码测试 condition，并执行其后的语句，直到碰到一个 .ENDIF 或另一个 .ELSEIF 伪指令</td></tr><tr><td>.ENDIF</td><td>终止 .IF、.ELSE 或 .ELSEIF 伪指令后面的语句块</td></tr><tr><td>.ENDW</td><td>终止 .WHILE 伪指令后面的语句块</td></tr><tr><td>.IF condition</td><td>如果 condition 为真，则生成代码执行语句块</td></tr><tr><td>.REPEAT</td><td>生成代码重复执行语句块，直到条件为真</td></tr><tr><td>.UNTIL condition</td><td>生成代码重复执行 .REPEAT 和 .UNTIL 伪指令之间的语句块，直到 condition 为真</td></tr><tr><td>.UNTILCXZ</td><td>生成代码重复执行 .REPEAT 和 .UNTILCXZ 伪指令之间的语句块，直到 CX 为零</td></tr><tr><td>.WHILE condition</td><td>当 condition 为真时，生成代码执行 .WHILE 和 .ENDW 伪指令之间的语句块</td></tr></tbody></table><h2 id="汇编语言-IF、-ELSE、-ELSEIF、-ENDIF伪指令"><a href="#汇编语言-IF、-ELSE、-ELSEIF、-ENDIF伪指令" class="headerlink" title="汇编语言.IF、.ELSE、.ELSEIF、.ENDIF伪指令"></a>汇编语言.IF、.ELSE、.ELSEIF、.ENDIF伪指令</h2><p>.IF、.ELSE、.ELSEIF 和 .ENDIF 伪指令使得程序员易于对多分支逻辑进行编码。它们让汇编器在后台生成 CMP 和条件跳转指令，这些指令显示在输出列表文件中。语法如下所示：</p><pre><code>.IF conditionl   statements[.ELSEIF condition2   statements ][.ELSE   statements ].ENDIF</code></pre><p>方括号表示 .ELSEIF 和 .ELSE 是可选的，而 .IF 和 .ENDIF 则是必需的。condition（条件）是布尔表达式，使用与 C++ 和 Java 相同的运算符 ( 比如：&lt;、&gt;、== 和 !=)。表达式在运行时计算。下面的例子给出了一些有效的条件，使用的是 32 位寄存器和变量：</p><pre><code>eax &gt; 10000hval1 &lt;= 100val2 == eaxval3 != ebx</code></pre><p>下面的例子给出的是复合条件：</p><pre><code>(eax &gt; 0) &amp;&amp; (eax &gt; 10000h)(val1 &lt;= 100) || (val2 &lt;= 100)(val2 != ebx) &amp;&amp; !CARRY?</code></pre><p>下表列出了所有的关系和逻辑运算符。</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>expr1 == expr2</td><td>若 expr1 等于 expr2，则返回“真”</td></tr><tr><td>expr1 != expr2</td><td>若 expr1 不等于 expr2，则返回“真”</td></tr><tr><td>expr1 &gt; expr2</td><td>若 expr1 大于 expr2，则返回”真”</td></tr><tr><td>expr1 ≥ expr2</td><td>若 expr1 大于等于 expr2，则返回“真”</td></tr><tr><td>expr1 &lt; expr2</td><td>若 expr1 小于 expr2，则返回“真”</td></tr><tr><td>expr1 ≤ expr2</td><td>若 expr1 小于等于 expr2，则返回“真”</td></tr><tr><td>!expr1</td><td>若 expr 为假，则返回“真”</td></tr><tr><td>expr1expr2</td><td>对 expr1 和 expr2 执行逻辑 AND 运算</td></tr><tr><td>expr1 || expr2</td><td>对 1xprl 和 expr2 执行逻辑 OR 运算</td></tr><tr><td>expr1 &amp; expr2</td><td>对 expr1 和 expr2 执行按位 AND 运算</td></tr><tr><td>CARR1?</td><td>若进位标志位置 11则返回“真”</td></tr><tr><td>OVERFLOW ?</td><td>若溢出标志位置 1，则返回“真”</td></tr><tr><td>PARITY ?</td><td>若奇偶标志位置 1，则返回“真”</td></tr><tr><td>SIGN ?</td><td>若符号标志位置 1，则返回“真”</td></tr><tr><td>ZERO ?</td><td>若零标志位置 1，则返回“真”</td></tr></tbody></table><p>在使用 MASM 条件伪指令之前，一定要彻底了解怎样用纯汇编语言实现条件分支指令。此外，在包含条件伪指令的程序汇编时，要查看列表文件以确认 MASM 生成的代码确实是编程者所需要的。</p><h4 id="生成-ASM-代码"><a href="#生成-ASM-代码" class="headerlink" title="生成 ASM 代码"></a>生成 ASM 代码</h4><p>当使用如 .IF 和 .ELSE 一样的高级伪指令时，汇编器将为程序员编写代码。例如，编写一条 .IF 伪指令来比较 EAX 与变量 val1：</p><pre><code>mov eax,6.IF eax &gt; val1    mov result,1.ENDIF</code></pre><p>假设 val1 和 result 是 32 位无符号整数，当汇编器读到前述代码时，就将它们扩展为下述汇编语言指令，用 Visual Studio 调试器运行程序时可以查看这些指令，操作为：右键点击, 选择 Go To Disassembly。</p><pre><code>    mov eax,6    cmp eax,val1    jbe @C0001            ;无符号数比较跳转    mov result, 1@C0001:</code></pre><p>标号名 @C0001 由汇编器创建，这样可以确保同一个过程中的所有标号都具有唯一性。</p><p>要控制 MASM 生成代码是否显示在源列表文件中，可以在 Visual Studio 中配置 Project 的属性。步骤如下：在 Project 菜单中，选择 Project Properties，选择 Microsoft Macro Assembler，选择 Listing File，再设置 Enable Assembly Generated Code Listing 为 Yes。</p><h3 id="有符号数和无符号数的比较"><a href="#有符号数和无符号数的比较" class="headerlink" title="有符号数和无符号数的比较"></a>有符号数和无符号数的比较</h3><p>当使用 .IF 伪指令来比较数值时，必须认识到 MASM 是如何生成条件跳转的。如果比较包含了一个无符号变量，则在生成代码中插入一条无符号条件跳转指令。如下还是前面的例子，比较 EAX 和无符号双字变量 val1：</p><pre><code>.dataval1 DWORD 5result DWORD ?.code    mov eax,6    .IF eax &gt; val1        mov result,1    .ENDIF</code></pre><p>汇编器用 JBE（无符号跳转）指令对其进行扩展：</p><pre><code>mov eax,6cmp eax,val1    jbe @C0001             ;无符号比较跳转    mov result,1@C0001：</code></pre><h4 id="1-有符号数比较"><a href="#1-有符号数比较" class="headerlink" title="1) 有符号数比较"></a>1) 有符号数比较</h4><p>如果 .IF 伪指令比较的是有符号变量，则在生成代码中插入一条有符号条件跳转指令。例如，val2 为有符号双字：</p><pre><code>.dataval2 SDWORD -1result DWORD ?.code    mov eax,6    .IF eax &gt; val2        mov result,1    .ENDIF</code></pre><p>因此，汇编器用 JLE 指令生成代码，即基于有符号比较的跳转：</p><pre><code>    mov eax,6    cmp eax,val2    jle @C0001               ;有符号比较跳转    mov result,1@C0001：</code></pre><h4 id="2-寄存器比较"><a href="#2-寄存器比较" class="headerlink" title="2) 寄存器比较"></a>2) 寄存器比较</h4><p>那么，现在可能会有一个问题：如果是两个寄存器进行比较，情况又是怎样的？显然，汇编器无法确定寄存器中的数值是有符号的还是无符号的：</p><pre><code>mov eax,6mov ebx,val2.IF eax &gt; ebx    mov result,1.ENDIF</code></pre><p>下面生成的代码表示汇编器将其默认为无符号数比较（注意使用的是 JBE 指令）：</p><pre><code>    mov eax, 6    mov ebx,val2    cmp eax, ebx    jbe @C0001    mov result,1@C0001:</code></pre><h3 id="复合表达式"><a href="#复合表达式" class="headerlink" title="复合表达式"></a>复合表达式</h3><p>很多复合布尔表达式使用逻辑 OR 和 AND 运算符。用 .IF 伪指令时，符号 || 表示的是逻辑 OR 运算符：</p><pre><code>.IF expression1 || expression2   statements.ENDIF</code></pre><p>同样，符号 &amp;&amp; 表示的是逻辑 AND 运算符：</p><pre><code>.IF expression1 &amp;&amp; expression2   statements.ENDIF</code></pre><p>下面的程序示例中将使用逻辑 OR 运算符。</p><h4 id="1-SetCursorPosition-示例"><a href="#1-SetCursorPosition-示例" class="headerlink" title="1) SetCursorPosition 示例"></a>1) SetCursorPosition 示例</h4><p>下例给出的 SetCursorPosition 过程，根据两个输入参数 DH 和 DL，执行范围检查。Y 坐标（DH）范围必须为 0〜24。X 坐标（DL）范围必须为 0〜79。不论发现哪个坐标超出范围，都显示一条错误消息：</p><pre><code>SetCursorPosition PROC; 设置光标位置; 接收: DL = X坐标, DH = Y坐标; 检查 DL 和 DH 的范围; 返回：无;------------------------------------------------.dataBadXCoordMsg BYTE "X-Coordinate out of range!",0Dh,0Ah,0BadYCoordMsg BYTE "Y-Coordinate out of range!",0Dh,0Ah,0.code    .IF (DL &lt; 0) || (DL &gt; 79)       mov  edx,OFFSET BadXCoordMsg       call WriteString       jmp  quit    .ENDIF    .IF (DH &lt; 0) || (DH &gt; 24)       mov  edx,OFFSET BadYCoordMsg       call WriteString       jmp  quit    .ENDIF    call Gotoxyquit:    retSetCursorPosition ENDP</code></pre><p>MASM 对 SetCursorPosition 进行预处理时，生成代码如下：</p><pre><code>.code;.IF (dl &lt; 0) || (dl &gt; 79)    cmp dl, OOOh    jb @C0002    cmp dl, 04Fh    jbe @C0001@C0002:    mov edx,OFFSET BadXCoordMsg    call WriteString    jmp quit;.ENDIF@C0001:;.IF (dh &lt; 0) || (dh &gt; 24)    cmp dh, OOOh    jb @COOO5    cmp    dh, 018h    jbe @C0004@COOO5:    mov edx,OFFSET BadYCoordMsg    call WriteString    jmp quit;.ENDIF@C0004:    call Gotoxyquit:    ret2) 大学注册示例</code></pre><p>假设有一个大学生想要进行课程注册。现在用两个条件来决定该生是否能注册：第一个条件是学生的平均成绩，范围为 0〜400，其中 400 是可能的最高成绩；第二个条件是学生期望获得的学分。可以使用多分支结构，包括 .IF、.ELSEIF 和 .ENDIF。示例如下。</p><pre><code>.dataTRUE = 1FALSE = 0gradeAverage  WORD 275    ; 要检查的数值credits       WORD 12     ; 要检查的数值OkToRegister  BYTE ?.codemain PROC    mov OkToRegister,FALSE    .IF gradeAverage &gt; 350       mov OkToRegister,TRUE    .ELSEIF (gradeAverage &gt; 250) &amp;&amp; (credits &lt;= 16)       mov OkToRegister,TRUE    .ELSEIF (credits &lt;= 12)       mov OkToRegister,TRUE    .ENDIF</code></pre><p>汇编器生成的相应代码如下所示，用 Microsoft Visual Studio 调试器的 Dissassembly 窗口可以查看该表。（为了便于阅读，已经对其进行了一些整理。）</p><pre><code>    mov byte ptr OkToRegister,FALSE    cmp word ptr gradeAverage,350    jbe @C0006    mov byte ptr OkToRegister,TRUE    jmp @C0008@C0006:    cmp word ptr gradeAverage,250    jbe @C0009    cmp word ptr credits,16    ja  @COOO9    mov byte ptr OkToRegister,TRUE    jmp @C0008@C0009:    cmp word ptr credits,12    ja  @C0008    mov byte ptr OkToRegister,TRUE@COOO8：</code></pre><p>汇编程序时，如果使用 /Sg 命令行就可以在源列表文件中显示 MASM 生成代码。被定义常量的大小（如当前代码示例中的 TRUE 和 FALSE）为 32 位。所以，把一个常量送入 BYTE 类型地址时，MASM 会插入 BYTE PTR 运算符。</p><h2 id="汇编语言用-REPEAT和-WHILE伪指令实现循环"><a href="#汇编语言用-REPEAT和-WHILE伪指令实现循环" class="headerlink" title="汇编语言用.REPEAT和.WHILE伪指令实现循环"></a>汇编语言用.REPEAT和.WHILE伪指令实现循环</h2><p>除了用 CMP 和条件跳转指令外，.REPEAT 和 .WHILE 伪指令还提供了另一种方法来编写循环。它们可以使用之前由《.IF伪指令》一节中关系和逻辑运算符表所列出的条件表达式。</p><p>.REPEAT 伪指令执行循环体，然后测试 .UNTIL 伪指令后面的运行时条件：</p><pre><code>.REPEAT   statements.UNTIL condition.WHILE 伪指令在执行循环体之前测试条件：.WHILE condition   statements.ENDW</code></pre><p>示例：下述语句使用 .WHILE 伪指令显示数值 1 到 10。循环之前，计数器寄存器 (EAX) 被初始化为 0。之后，循环体内的第一条语句将 EAX 加 1。当 EAX 等于 10 时，.WHILE 伪指令将分支到循环体外。</p><pre><code>mov eax,0.WHILE eax &lt; 10    inc eax    call WriteDec    call Crlf.ENDW</code></pre><p>下述语句使用 .REPEAT 伪指令显示数值 1 到 10：</p><pre><code>mov eax,0.REPEAT    inc eax    call WriteDec    call Crlf.UNTIL eax == 10</code></pre><p>【示例】：含 IF 语句的循环</p><p>《使用汇编语言实现WHILE循环》一节中展示了如何编写汇编语言代码来实现 WHILE 循环嵌套 IF 语句。伪代码如下：</p><pre><code>while( op1 &lt; op2 ){    op1++;    if( op1 == op3 )        X = 2;    else        X = 3;}</code></pre><p>下面用 .WHILE 和 .IF 伪指令实现这段伪代码。由于 op1、op2 和 op3 是变量，为了避免任何指令出现两个内存操作数，它们被送入寄存器：</p><pre><code>.dataX DWORD 0op1 DWORD 2     ;被检测的数据op2 DWORD 4     ;被检测的数据op3 DWORD 5     ;被检测的数据.code    mov eax, op1    mov ebx, op2    mov ecx, op3    .WHILE eax &lt; ebx        inc eax        .IF eax == ecx            mov X,2        .ELSE            mov X,3        .ENDIF    .ENDW</code></pre><h1 id="汇编语言整数运算"><a href="#汇编语言整数运算" class="headerlink" title="汇编语言整数运算"></a>汇编语言整数运算</h1><h2 id="汇编语言移位和循环移位指令简介"><a href="#汇编语言移位和循环移位指令简介" class="headerlink" title="汇编语言移位和循环移位指令简介"></a>汇编语言移位和循环移位指令简介</h2><p>移位指令与前面介绍的按位操作指令一起形成了汇编语言最显著的特点之一。位移动 (bit shifting) 意味着在操作数内向左或向右移动。</p><p>x86 处理器在这方面提供了相当丰富的指令集如下表所示，这些指令都会影响溢出标志位和进位标志位。</p><table><thead><tr><th>SHL</th><th>左移</th><th>ROR</th><th>循环右移</th></tr></thead><tbody><tr><td>SHR</td><td>右移</td><td>RCL</td><td>带进位的循环左移</td></tr><tr><td>SAL</td><td>算术左移</td><td>RCR</td><td>带进位的循环右移</td></tr><tr><td>SAR</td><td>算术右移</td><td>SHLD</td><td>双精度左移</td></tr><tr><td>ROL</td><td>循环左移</td><td>SHRD</td><td>双精度右移</td></tr></tbody></table><h3 id="逻辑移位和算术移位"><a href="#逻辑移位和算术移位" class="headerlink" title="逻辑移位和算术移位"></a>逻辑移位和算术移位</h3><p>移动操作数的位有两种方法。第一种是逻辑移位 (logic shift)，空出来的位用 0 填充。如下图所示，一个字节的数据向右移动一位。也就是说，每一位都被移动到其旁边的低位上。注意，位 7 被填充为 0：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224369745137" alt="img"></p><p>下图所示为二进制数 1100 1111 逻辑右移一位，得到 OllOOlll。最低位移入进位标志位：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224378978139" alt="img"></p><p>另一种移位的方法是算术移位 (arithmetic shift)，空出来的位用原数据的符号位填充：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224388993141" alt="img"></p><p>例如，二进制数 1100 1111，符号位为 1。算术右移一位后，得到 1110 0111：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224397913143" alt="img"></p><h2 id="汇编语言SHL（左移）指令：将操作数逻辑左移一位"><a href="#汇编语言SHL（左移）指令：将操作数逻辑左移一位" class="headerlink" title="汇编语言SHL（左移）指令：将操作数逻辑左移一位"></a>汇编语言SHL（左移）指令：将操作数逻辑左移一位</h2><p>SHL（左移）指令使目的操作数逻辑左移一位，最低位用 0 填充。最高位移入进位标志位，而进位标志位中原来的数值被丢弃：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224409956145" alt="img"></p><p>若将 1100 1111 左移 1 位，该数就变为 1001 1110：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224420441147" alt="img"></p><p>SHL 的第一个操作数是目的操作数，第二个操作数是移位次数：</p><pre><code>SHL destination,count</code></pre><p>该指令可用的操作数类型如下所示：</p><pre><code>SHL reg, imm8SHL mem, imm8SHL reg, CLSHL mem, CL</code></pre><p>x86 处理器允许 imm8 为 0〜255 中的任何整数。另外，CL 寄存器包含的是移位计数。上述格式同样适用于 SHR、SAL、SAR、ROR、ROL、RCR 和 RCL 指令。</p><p>【示例】下列指令中，BL 左移一位。最高位复制到进位标志位，最低位填充 0：</p><pre><code>mov b1, 8Fh         ; BL = 10001111bshl bl, 1         ; CF = 1, BL = 00011110b</code></pre><p>当一个数多次进行左移时，进位标志位保存的是最后移岀最高有效位（MSB）的数值。下例中，位 7 没有留在进位标志位中，因为，它被位 6（0）替换了：</p><pre><code>mov al, 10000000bshl al, 2          ; CF = 0, AL = 00000000b</code></pre><p>同样，当一个数多次进行右移时，进位标志位保存的是最后移出最低有效位（LSB）的数值。</p><h4 id="位元乘法"><a href="#位元乘法" class="headerlink" title="位元乘法"></a>位元乘法</h4><p>数值进行左移（向 MSB 移动）即执行了位元乘法（Bitwise Multiplication）。例如，SHL 可以通过 2 的幕进行乘法运算。任何操作数左移 n 位，即将该数乘以 2n。现将整数 5 左移一位则得到 5 x 2¹ = 10：</p><pre><code>mov dl, 5           ; 移动前：00000101 = 5shl dl, 1       ; 移动后：00001010 = 10</code></pre><p>若二进制数 0000 1010（十进制数 10）左移两位，其结果与 10 乘以 2² 相同：</p><pre><code>mov dl, 10          ;移动前：00001010shl dl, 2        ;移动后：00101000</code></pre><h2 id="汇编语言SHR（右移）指令：将操作数逻辑右移一位"><a href="#汇编语言SHR（右移）指令：将操作数逻辑右移一位" class="headerlink" title="汇编语言SHR（右移）指令：将操作数逻辑右移一位"></a>汇编语言SHR（右移）指令：将操作数逻辑右移一位</h2><p>SHR（右移）指令使目的操作数逻辑右移一位，最高位用 0 填充。最低位复制到进位标志位，而进位标志位中原来的数值被丢弃：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224464364149" alt="img"></p><p>SHR 与 SHL 的指令格式相同。在下面的例子中，AL 中的最低位 0 被复制到进位标志位，而 AL 中的最高位用 0 填充：</p><pre><code>mov al, 0D0h    ; AL = 11010000bshr al, 1       ; AL = 01101000b, CF = 0</code></pre><p>在多位移操作中，最后一个移出位 0（LSB）的数值进入进位标志位：</p><pre><code>mov al, 00000010bshr al, 2          ; AL = 00000000b, CF = 1</code></pre><h4 id="位元除法"><a href="#位元除法" class="headerlink" title="位元除法"></a>位元除法</h4><p>数值进行右移（向 LSB 移动）即执行了位元除法（Bitwise Division）。将一个无符号数右移 n 位，即将该数除以 2n。下述语句将 32 除以 2¹，结果为 16：</p><pre><code>mov dl, 32          ;移动前：00100000 = 32shr dl, 1        ;移动后：00010000 = 16</code></pre><p>下例实现的是 64 除以 2³：</p><pre><code>mov al, 01000000b    ;AL = 64shr al, 3             ;除以 8, AL = 00001000b</code></pre><p>用移位的方法实现有符号数除法可以使用 SAR 指令，因为该指令会保留操作数的符号位。</p><h2 id="汇编语言SAL（算术左移）和SAR（算术右移）指令：将操作数左-右移一位"><a href="#汇编语言SAL（算术左移）和SAR（算术右移）指令：将操作数左-右移一位" class="headerlink" title="汇编语言SAL（算术左移）和SAR（算术右移）指令：将操作数左/右移一位"></a>汇编语言SAL（算术左移）和SAR（算术右移）指令：将操作数左/右移一位</h2><p>SAL（算术左移）指令的操作与SHL 指令一样。每次移动时，SAL 都将目的操作数中的每一位移动到下一个最高位上。最低位用 0 填充；最高位移入进位标志位，该标志位原来的值被丢弃：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224479971151" alt="img"></p><p>如，二进制数 1100 1111 算术左移一位，得到 1001 1110：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224488989153" alt="img"></p><p>SAR（算术右移）指令将目的操作数进行算术右移：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224503818155" alt="img"></p><p>SAL 与 SAR 指令的操作数类型与 SHL 和 SHR 指令完全相同。移位可以重复执行，其次数由第二个操作数给出的计数器决定：</p><pre><code>SAR destination, count</code></pre><p>下面的例子展示了 SAR 是如何复制符号位的。执行指令前 AL 的符号位为负，执行指令后该位移动到右边的位上：</p><pre><code>mov al, 0F0h ; AL = 11110000b (-16)sar al, 1    ; AL = 11111000b (-8) , CF = 0</code></pre><h4 id="有符号数除法"><a href="#有符号数除法" class="headerlink" title="有符号数除法"></a>有符号数除法</h4><p>使用 SAR 指令，就可以将有符号操作数除以 2 的幂。下例执行的是 -128 除以2³，商为 -16：</p><pre><code>mov dl, -128 ; DL = 10000000bsar dl, 3    ; DL = 11110000b</code></pre><h4 id="AX-符号扩展到-EAX"><a href="#AX-符号扩展到-EAX" class="headerlink" title="AX 符号扩展到 EAX"></a>AX 符号扩展到 EAX</h4><p>设 AX 中为有符号数，现将其符号位扩展到 EAX。首先把 EAX 左移 16 位，再将其算术右移 16 位：</p><pre><code>mov ax, -128 ; EAX = ????FF80hshl eax, 16    ; EAX = FF800000hsar eax, 16    ; EAX = FFFFFF80h</code></pre><h2 id="汇编语言ROL（循环左移）指令：将操作数所有位都向左移"><a href="#汇编语言ROL（循环左移）指令：将操作数所有位都向左移" class="headerlink" title="汇编语言ROL（循环左移）指令：将操作数所有位都向左移"></a>汇编语言ROL（循环左移）指令：将操作数所有位都向左移</h2><p>以循环方式来移位即为位元循环（Bitwise Rotation）。一些操作中，从数的一端移出的位立即复制到该数的另一端。还有一种类型则是把进位标志位当作移动位的中间点。</p><p>ROL（循环左移）指令把所有位都向左移。最高位复制到进位标志位和最低位。该指令格式与 SHL 指令相同：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224516806157" alt="img"></p><p>位循环不会丢弃位。从数的一端循环出去的位会出现在该数的另一端。在下例中，请注意最高位是如何复制到进位标志位和位 0 的：</p><pre><code>mov al,40h       ; AL = 01000000brol al,1        ; AL = 10000000b, CF = 0rol al,1        ; AL = 00000001b, CF = 1rol alz1       ; AL = 00000010b, CF = 0</code></pre><h4 id="循环多次"><a href="#循环多次" class="headerlink" title="循环多次"></a>循环多次</h4><p>当循环计数值大于 1 时，进位标志位保存的是最后循环移出 MSB 的位：</p><pre><code>mov al,00100000brol al,3          ; CF = 1, AL = 00000001b</code></pre><h4 id="位组交换"><a href="#位组交换" class="headerlink" title="位组交换"></a>位组交换</h4><p>利用 ROL 可以交换一个字节的高四位（位 4〜7）和低四位（位 0〜3）。例如，26h 向任何方向循环移动 4 位就变为 62h：</p><pre><code>mov al, 26hrol al, 4         ; AL = 62h</code></pre><p>当多字节整数以四位为单位进行循环移位时，其效果相当于一次向右或向左移动一个十六进制位。例如，将 6A4Bh 反复循环左移四位，最后就会回到初始值：</p><pre><code>mov ax, 6A4Bhrol ax, 4       ; AX = A4B6hrol ax, 4       ; AX = 4B6Ahrol ax, 4       ; AX = B6A4hrol ax, 4       ; AX = 6A4Bh</code></pre><h2 id="汇编语言ROR（循环右移）指令：将操作数所有位都向右移"><a href="#汇编语言ROR（循环右移）指令：将操作数所有位都向右移" class="headerlink" title="汇编语言ROR（循环右移）指令：将操作数所有位都向右移"></a>汇编语言ROR（循环右移）指令：将操作数所有位都向右移</h2><p>ROR（循环右移）指令把所有位都向右移，最低位复制到进位标志位和最高位。该指令格式与 SHL 指令相同：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224533344159" alt="img"></p><p>在下例中，请注意最低位是如何复制到进位标志位和结果的最高位的：</p><pre><code>mov al, 0lh         ; AL = 00000001bror al, 1        ; AL = 10000000b, CF = 1ror al, 1        ; AL = 01000000b, CF = 0</code></pre><h4 id="循环多次-1"><a href="#循环多次-1" class="headerlink" title="循环多次"></a>循环多次</h4><p>当循环计数值大于 1 时，进位标志位保存的是最后循环移出 LSB 的位：</p><pre><code>mov al, 00000100bror al, 3       ; AL = 10000000b, CF = 1</code></pre><h2 id="汇编语言RCL（带进位循环左移）和RCR（带进位循环右移）指令"><a href="#汇编语言RCL（带进位循环左移）和RCR（带进位循环右移）指令" class="headerlink" title="汇编语言RCL（带进位循环左移）和RCR（带进位循环右移）指令"></a>汇编语言RCL（带进位循环左移）和RCR（带进位循环右移）指令</h2><p>RCL（带进位循环左移）指令把每一位都向左移，进位标志位复制到 LSB，而 MSB 复制到进位标志位：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224551521161" alt="img"></p><p>如果把进位标志位当作操作数最高位的附加位，那么 RCL 就成了循环左移操作。下面的例子中，CLC 指令清除进位标志位。第一条 RCL 指令将 BL 最高位移入进位标志位，其他位都向左移一位。第二条 RCL 指令将进位标志位移入最低位，其他位都向左移一位：</p><pre><code>clc               ; CF = 0mov bl, 88h       ; CF,BL = 0 1000100Obrcl bl, 1           ; CF,BL = 1 00010000brcl b1, 1          ; CF,BL = 0 00100001b</code></pre><h4 id="从进位标志位恢复位"><a href="#从进位标志位恢复位" class="headerlink" title="从进位标志位恢复位"></a>从进位标志位恢复位</h4><p>RCL 可以恢复之前移入进位标志位的位。下面的例子把 testval 的最低位移入进位标志位，并对其进行检查。如果 testval 的最低位为 1，则程序跳转；如果最低位为 0，则用 RCL 将该数恢复为初始值：</p><pre><code>.datatestval BYTE 01101010b.codeshr testval, 1         ; 将lsb移入进位标志位jc exit           ; 如果该标志位置 1，则退出rcl testval, 1      ; 否则恢复该数原值</code></pre><h4 id="RCR-指令"><a href="#RCR-指令" class="headerlink" title="RCR 指令"></a>RCR 指令</h4><p>RCR（带进位循环右移）指令把每一位都向右移，进位标志位复制到 MSB，而 LSB 复制到进位标志位：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224565649163" alt="img"></p><p>从上图来看，RCL 指令将该整数转化成了一个 9 位值，进位标志位位于 LSB 的右边。下面的示例代码用 STC 将进位标志位置 1，然后，对 AH 寄存器执行一次带进位循环右移操作：</p><pre><code>stc              ; CF = 1mov ah, 10h            ; AH, CF = 00010000 1rcr ah, 1          ; AH, CF = 10001000 0</code></pre><h4 id="有符号数溢出"><a href="#有符号数溢出" class="headerlink" title="有符号数溢出"></a>有符号数溢出</h4><p>如果有符号数循环移动一位生成的结果超过了目的操作数的有符号数范围，则溢出标志位置 1。换句话说，即该数的符号位取反。下例中，8 位寄存器中的正数（+127）循环左移后变为负数（-2）：</p><pre><code>mov al, +127         ; AL = 01111111brol al, 1          ; OF = 1, AL = 11111110b</code></pre><p>同样，-128 向右移动一位，溢出标志位置 1。AL 中的结果（+64）符号位与原数相反：</p><pre><code>mov al, -128      ; AL = 10000000bshr al, 1         ; OF = 1, AL = 01000000b</code></pre><p>如果循环移动次数大于 1，则溢出标志位无定义。</p><h2 id="汇编语言SHLD（双精度左移）和SHRD（双精度右移）指令"><a href="#汇编语言SHLD（双精度左移）和SHRD（双精度右移）指令" class="headerlink" title="汇编语言SHLD（双精度左移）和SHRD（双精度右移）指令"></a>汇编语言SHLD（双精度左移）和SHRD（双精度右移）指令</h2><p>SHLD（双精度左移）指令将目的操作数向左移动指定位数。移动形成的空位由源操作数的高位填充。源操作数不变，但是符号标志位、零标志位、辅助进位标志位、奇偶标志位和进位标志位会受影响：</p><p>SHLD dest, source, count</p><p>下图展示的是 SHLD 执行移动一位的过程。源操作数的最高位复制到目的操作数的最低位上。目的操作数的所有位都向左移动：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224593457165" alt="img"></p><p>SHRD（双精度右移）指令将目的操作数向右移动指定位数。移动形成的空位由源操作数的低位填充：</p><p>SHRD dest, source, count</p><p>下图展示的是 SHRD 执行移动一位的过程：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224603501167" alt="img"></p><p>下面的指令格式既可以应用于 SHLD 也可以应用于 SHRD。目标操作数可以是寄存器或内存操作数；源操作数必须是寄存器；移位次数可以是 CL 寄存器或者 8 位立即数：</p><pre><code>SHLD regl6, regl6, CL/imm8SHLD meml6, regl6, CL/imm8SHLD reg32, reg32, CL/imm8SHLD mem32, reg32, CL/imm8</code></pre><p>【示例 1】下述语句将 wval 左移 4 位，并把 AX 的高 4 位插入 wval 的低 4 位：</p><pre><code>.datawval WORD 9BA6h.codemov ax, 0AC36hshld wval, ax, 4             ; wval = BA6Ah</code></pre><p>数据移动过程如下图所示：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224640436169" alt="img"></p><p>【示例 2】下例中，AX 右移 4 位，DX 的低 4 位移入 AX 的高 4 位：</p><pre><code>mov ax, 234Bhmov dx,7654hshrd ax, dx, 4</code></pre><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224650611171" alt="img"></p><p>为了在屏幕上重定位图像而必须将位元组左右移动时，可以用 SHLD 和 SHRD 来处理位映射图像。另一种可能的应用是数据加密，如果加密算法中包含位的移动的话。最后，对于很长的整数来说，这两条指令还可以用于快速执行其乘除法。</p><p>下面的代码示例展示了用 SHRD 如何将一个双字数组右移 4 位：</p><pre><code>.dataarray DWORD 648B2165h, 8C943A29h, 6DFA4B86h, 91F76C04h, 8BAF9857h.code    mov bl, 4                            ;移位次数    mov esi, OFFSET array                ;数组的偏移量    mov ecx, (LENGTHOF array) - 1        ;数组元素个数L1: push ecx                             ;保存循环计数    mov eax, [esi + TYPE DWORD]    mov cl, bl                            ;移动次数    shrd [esi], eax, cl                   ;EAX [ESI] 的高位    add esi, TYPE DWORD                   ;指向下一对双字    pop ecx                               ;恢复循环计数    loop L1    shr DWORD PTR [esi], 4                ;最后一个双字进行移位</code></pre><h2 id="汇编语言移位和循环移位的应用"><a href="#汇编语言移位和循环移位的应用" class="headerlink" title="汇编语言移位和循环移位的应用"></a>汇编语言移位和循环移位的应用</h2><p>当程序需要将一个数的位从一部分移动到另一部分时，汇编语言是非常合适的工具。有时，把数的位元子集移动到位 0，便于分离这些位的值。本节将展示一些易于实现的常见移位和循环移位的应用。</p><h3 id="多个双字的移位"><a href="#多个双字的移位" class="headerlink" title="多个双字的移位"></a>多个双字的移位</h3><p>对于已经被分割为字节、字或双字数组的扩展精度整数可以进行移位操作。在此之前，必须知道该数组元素是如何存放的。保存整数的常见方法之一被称为小端顺序 (little-endian order)。</p><p>其工作方式如下：将数组的最低字节存放到它的起始地址，然后，从该字节开始依序把高字节存放到下一个顺序的内存地址中。除了可以将数组作为字节序列存放外，还可以将其作为字序列和双字序列存放。如果是后两种形式，则字节和字节之间仍然是小端顺序，因为 x86 机器是按照小端顺序存放字和双字的。</p><p>下面的步骤说明了怎样将一个字节数组右移一位。</p><p>步骤 1)：把位于 [ESI+2] 的最高字节右移一位，其最低位自动复制到进位标志位。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224671040173" alt="img"></p><p>步骤 2)：把 [ESI+1] 循环右移一位，即用进位标志位填充最高位，而将最低位移入进位标志位：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224685333175" alt="img"></p><p>步骤 3) ：把 [ESI] 循环右移一位，即用进位标志位填充最高位，而将最低位移入进位标志位：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224695969177" alt="img"></p><p>步骤 3 完成后，所有的位都向右移动了一位:</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224706173179" alt="img"></p><p>实现的是上述 3 个步骤，代码如下：</p><pre><code>.dataArraySize = 3array BYTE ArraySize DUP(99h)          ; 每个半字节的值都是 1001.codemain PROC    mov esi,0    shr array[esi+2],1                 ; 高字节    rcr array[esi+1],1                 ; 中间字节，包括进位标志位    rcr array[esi],1                   ; 低字节，包括进位标志位</code></pre><p>虽然这个例子只有 3 个字节进行了移位，但是它能很容易被修改成执行字数组或双字数组的移位操作。利用循环，可以对任意大小的数组进行移位操作。</p><h3 id="二进制乘法"><a href="#二进制乘法" class="headerlink" title="二进制乘法"></a>二进制乘法</h3><p>有时程序员会压榨出任何可以获得的性能优势，他们会使用移位而非 MUL 指令来实现整数乘法。当乘数是 2 的幂时，SHL 指令执行的是无符号数乘法。</p><p>一个无符号数左移 n 位就是将其乘以 2n。其他任何乘数都可以表示为 2 的幂之和。例如，若将 EAX 中的无符号数乘以 36，则可以将 36 写为 25+22，再使用乘法 分配律：</p><pre><code>EAX * 36 = EAX * (2⁵ + 2²)        = EAX * (32 + 4)        = (EAX * 32) + (EAX * 4)</code></pre><p>下图展示了乘法 123*36 得到结果 4428 的过程：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224731007181" alt="img"></p><p>请注意这里有个有趣的现象，乘数 (36) 的位 2 和位 5 都为 1，而整数 2 和 5 又是需要移位的次数。利用这个现象，下面的代码片段使用 SHL 和 ADD 指令实现了 123 乘以 36：</p><pre><code>mov eax, 123mov ebx, eaxshl eax, 5                ; 乘以 2⁵shl ebx, 2                ; 乘以 2²add eax, ebx            ; 乘积相力口</code></pre><h3 id="显示二进制位"><a href="#显示二进制位" class="headerlink" title="显示二进制位"></a>显示二进制位</h3><p>将二进制整数转换为 ASCII 码的位串，并显示出来是一种常见的编程任务。SHL 指令适用于这个要求，因为每次操作数左移时，它都会把操作数的最高位复制到进位标志位。下面的 BinToAsc 过程是该功能一个简单的实现：</p><pre><code>;---------------------------------------------------------BinToAsc PROC;; 将 32 位二进制整数转换为 ASCII 码的二进制形式。; 接收：EAX = 二进制整数，EST 为缓冲区指针; 返回：包含 ASCII 码二进制数字的缓冲区;---------------------------------------------------------    push    ecx    push    esi    mov    ecx,32                    ; EAX 中的位数L1:    shl    eax,1                  ; 最高位移入进位标志位    mov    BYTE PTR [esi],'0'        ; 选择0作为默认数字    jnc    L2                        ; 如果进位标志位为0,则跳转到L2    mov    BYTE PTR [esi],'1'        ; 否则将1送入缓冲区L2:    inc    esi                    ; 指向下一个缓冲区位置    loop    L1                       ; 下一位进行左移    pop    esi    pop    ecx    retBinToAsc ENDP</code></pre><h3 id="提取文件日期字段"><a href="#提取文件日期字段" class="headerlink" title="提取文件日期字段"></a>提取文件日期字段</h3><p>当存储空间非常宝贵的时候，系统软件常常将多个数据字段打包为一个整数。要获得这些数据，应用程序就需要提取被称为位串（bit string）的位序列。例如，在实地址模式下，MS-DOS 函数 57h 用 DX 返回文件的日期戳。</p><p>（日期戳显示的是该文件最后被修改的日期。）其中，位 0〜 位 4 表示的是 1〜31 内的日期；位 5〜 位 8 表示的是月份；位 9〜 位 15 表示的是年份。如果一个文件最后被修改的日期是 1999 年 3 月 10 日，则 DX 寄存器中该文件的日期戳就如下图所示（年份以 1980 为基点）：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224746271183" alt="img"></p><p>要提取一个位串，就把这些位移到寄存器的低位部分，再清除掉其他无关的位。下面的代码示例从一个日期戳中提取日期字段，方法是：复制 DL，然后屏蔽与该字段无关的位：</p><pre><code>mov al, dl            ; 复制 DLand al, 00011111b        ; 清除位 5 〜 位 7mov day, al          ; 结果存入变量 day</code></pre><p>要提取月份字段，就把位 5〜 位 8 移到 AL 的低位部分，再清除其他无关位，最后把 AL 复制到变量中：</p><pre><code>mov ax, dx           ;复制 DXshr ax, 5             ;右移5位and al, 00001111b        ;清除位 4 〜位 7mov month, al        ;结果存入变量month年份字段（位 9〜 位 15）完全包含在 DH 寄存器中，将其复制到 AL，再右移 1 位：mov al, dh                ;复制 DHshr al, 1           ;右移1位mov ah, 0         ;将 AH 清零add ax, 1980            ;年份基点为1980mov year, ax            ;结果存入变量year</code></pre><h2 id="汇编语言MUL指令：无符号数乘法"><a href="#汇编语言MUL指令：无符号数乘法" class="headerlink" title="汇编语言MUL指令：无符号数乘法"></a>汇编语言MUL指令：无符号数乘法</h2><p>32 位模式下，MUL（无符号数乘法）指令有三种类型：</p><ul><li><p>第一种执行 8 位操作数与 AL 寄存器的乘法；</p></li><li><p>第二种执行 16 位操作数与 AX 寄存器的乘法；</p></li><li><p>第三种执行 32 位操作数与 EAX 寄存器的乘法。</p></li></ul><p>乘数和被乘数的大小必须保持一致，乘积的大小则是它们的一倍。这三种类型都可以使用寄存器和内存操作数，但不能使用立即数：</p><pre><code>MUL reg/mem8MUL reg/meml6MUL reg/mem32</code></pre><p>MUL 指令中的单操作数是乘数。下表按照乘数的大小，列出了默认的被乘数和乘积。由于目的操作数是被乘数和乘数大小的两倍，因此不会发生溢岀。</p><table><thead><tr><th>被乘数</th><th>乘数</th><th>乘积</th></tr></thead><tbody><tr><td>AL</td><td>reg/mem8</td><td>AX</td></tr><tr><td>AX</td><td>reg/mem16</td><td>DX:AX</td></tr><tr><td>EAX</td><td>reg/mem32</td><td>EDX:EAX</td></tr></tbody></table><p>如果乘积的高半部分不为零，则 MUL 会把进位标志位和溢出标志位置 1。因为进位标志位常常用于无符号数的算术运算，在此我们也主要说明这种情况。例如，当 AX 乘以一个 16 位操作数时，乘积存放在 DX 和 AX 寄存器对中。其中，乘积的高 16 位存放在 DX，低 16 位存放在 AX。如果 DX 不等于零，则进位标志位置 1，这就意味着隐含的目的操作数的低半部分容纳不了整个乘积。</p><p>有个很好的理由要求在执行 MUL 后检查进位标志位，即，确认忽略乘积的高半部分是否安全。</p><h3 id="MUL-示例"><a href="#MUL-示例" class="headerlink" title="MUL 示例"></a>MUL 示例</h3><p>下述语句实现 AL 乘以 BL，乘积存放在 AX 中。由于 AH（乘积的高半部分）等于零，因此进位标志位被清除（CF=0）：</p><pre><code>mov al, 5hmov bl, 10hmul bl                   ; AX = 0050h, CF = 0</code></pre><p>下图展示了寄存器内容的变化：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224774279185" alt="img"></p><p>下述语句实现 16 位值 2000h 乘以 0100h。由于乘积的高半部分（存放于 DX）不等于零，因此进位标志位被置 1：</p><pre><code>.dataval1 WORD 2000hval2 WORD 0l00h.codemov ax, val1           ; AX = 2000hmul val2               ; DX:AX = 00200000h, CF = 1</code></pre><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224784439187" alt="img"></p><p>下述语句实现 12345h 乘以 1000h，产生的 64 位乘积存放在 EDX 和 EAX 寄存器对中。EDX 中存放的乘积高半部分为零，因此进位标志位被清除：</p><pre><code>mov eax, 12345hmov ebx, 1000hmul ebx                  ; EDX:EAX = 0000000012345000h, CF = 0</code></pre><p>下图展示了寄存器内容的变化：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224795495189" alt="img"></p><h3 id="在-64-位模式下使用-MUL"><a href="#在-64-位模式下使用-MUL" class="headerlink" title="在 64 位模式下使用 MUL"></a>在 64 位模式下使用 MUL</h3><p>64 位模式下，MUL 指令可以使用 64 位操作数。一个 64 位寄存器或内存操作数与 RAX 相乘，产生的 128 位乘积存放到 RDX:RAX 寄存器中。下例中，RAX 乘以 2，就是将 RAX 中的每一位都左移一位。RAX 的最高位溢出到 RDX 寄存器，使得 RDX 的值为 0000 0000 0000 0001h：</p><pre><code>mov rax, 0FFFF0000FFFF0000hmov rbx, 2mul rbx                    ; RDX:RAX = 0000000000000001FFFE0001FFFE0000</code></pre><p>下面的例子中，RAX 乘以一个 64 位内存操作数。该寄存器的值乘以 16，因此，其中的每个十六进制数字都左移一位（一次移动 4 个二进制位就相当于乘以 16）。</p><pre><code>.datamultiplier QWORD 10h.codemov rax, OAABBBBCCCCDDDDhmul multiplier       ; RDX:RAX = 00000000000000000AABBBBCCCCDDDDOh</code></pre><h2 id="汇编语言IMUL指令：有符号数乘法"><a href="#汇编语言IMUL指令：有符号数乘法" class="headerlink" title="汇编语言IMUL指令：有符号数乘法"></a>汇编语言IMUL指令：有符号数乘法</h2><p>IMUL（有符号数乘法）指令执行有符号整数乘法。与 MUL 指令不同，IMUL 会保留乘 积的符号，实现的方法是，将乘积低半部分的最高位符号扩展到高半部分。</p><p>x86 指令集支持三种格式的 IMUL 指令：单操作数、双操作数和三操作数。单操作数格式中，乘数和被乘数大小相同，而乘积的大小是它们的两倍。</p><h4 id="单操作数格式"><a href="#单操作数格式" class="headerlink" title="单操作数格式"></a>单操作数格式</h4><p>单操作数格式将乘积存放在 AX、DX:AX 或 EDX:EAX 中：</p><pre><code>IMUL reg/mem8   ; AX = AL * reg/mem8IMUL reg/meml6   ; DX:AX = AX * reg/meml6IMUL reg/mem32   ; EDX:EAX = EAX * reg/mem32</code></pre><p>和 MUL 指令一样，其乘积的存储大小使得溢出不会发生。同时，如果乘积的高半部分不是其低半部分的符号扩展，则进位标志位和溢出标志位置 1。利用这个特点可以决定是否忽略乘积的高半部分。</p><h4 id="双操作数格式（32位模式）"><a href="#双操作数格式（32位模式）" class="headerlink" title="双操作数格式（32位模式）"></a>双操作数格式（32位模式）</h4><p>32 位模式中的双操作数 IMUL 指令把乘积存放在第一个操作数中，这个操作数必须是寄存器。第二个操作数（乘数）可以是寄存器、内存操作数和立 即数。16位格式如下所示：</p><pre><code>IMUL regl6, reg/meml6IMUL regl6, imm8IMUL regl6, imml6</code></pre><p>32 位操作数类型如下所示，乘数可以是 32 位寄存器、32 位内存操作数或立即数（8 位 或 32 位）：</p><pre><code>IMUL reg32, reg/mem32IMUL reg32, inun8IMUL reg32, imm32</code></pre><p>双操作数格式会按照目的操作数的大小来截取乘积。如果被丢弃的是有效位，则溢出标志位和进位标志位置 1。因此，在执行了有两个操作数的 IMUL 操作后，必须检查这些标志位中的一个。</p><h4 id="三操作数格式"><a href="#三操作数格式" class="headerlink" title="三操作数格式"></a>三操作数格式</h4><p>32 位模式下的三操作数格式将乘积保存在第一个操作数中。第二个操作数可以是 16 位寄存器或内存操作数，它与第三个操作数相乘，该操作数是一个8位或16 位立即数：</p><pre><code>IMUL regl6, reg/meml6,imm8IMUL regl6, reg/meml6, iirrnl6</code></pre><p>而 32 位寄存器或内存操作数可以与 8 位或 32 位立即数相乘：</p><pre><code>IMUL reg32, reg/mem32, imm8IMUL reg32, reg/mem32, imm32</code></pre><p>IMUL 执行时，若乘积有效位被丢弃，则溢出标志位和进位标志位置 1。因此，在执行了有三个操作数的 IMUL 操作后，必须检查这些标志位中的一个。</p><h3 id="在-64-位模式下执行-IMUL"><a href="#在-64-位模式下执行-IMUL" class="headerlink" title="在 64 位模式下执行 IMUL"></a>在 64 位模式下执行 IMUL</h3><p>在 64 位模式下，IMUL 指令可以使用 64 位操作数。在单操作数格式中，64 位寄存器或内存操作数与 RAX 相乘，产生一个 128 位且符号扩展的乘积存放到 RDX:RAX 寄存器中。在下面的例子中，RBX 与 RAX 相乘，产生 128 位的乘积 -16。</p><pre><code>mov rax, -4mov rbx, 4imul rbx         ; RDX = 0FFFFFFFFFFFFFFFFh, RAX = -16</code></pre><p>也就是说，十进制数 -16 在 RAX 中表示为十六进制 FFFF FFFF FFF0，而 RDX 只包含 TRAX 的高位扩展，即它的符号位。</p><p>三操作数格式也可以用于 64 位模式。如下例所示，被乘数 (-16) 乘以 4，生成 RAX 中的乘积 -64：</p><pre><code>.datamultiplicand QWORD -16.codeimul rax, multiplicand, 4       ; RAX = FFFFFFFFFFFFFFC0 (-64)</code></pre><h4 id="无符号乘法"><a href="#无符号乘法" class="headerlink" title="无符号乘法"></a>无符号乘法</h4><p>由于有符号数和无符号数乘积的低半部分是相同的，因此双操作数和三操作数的 IMUL 指令也可以用于无符号乘法。但是这种做法也有一点不便的地方：进位标志位和溢出标志位将无法表示乘积的高半部分是否为零。</p><h3 id="IMUL-示例"><a href="#IMUL-示例" class="headerlink" title="IMUL 示例"></a>IMUL 示例</h3><p>下述指令执行 48 乘以 4，乘积 +192 保存在 AX 中。虽然乘积是正确的，但是 AH 不是 AL 的符号扩展，因此溢出标志位置 1：</p><pre><code>mov al,48mov bl, 4imul bl            ; AX = 00C0h, OF = 1</code></pre><p>下述指令执行 -4 乘以 4，乘积 -16 保存在 AX 中。AH 是 AL 的符号扩展，因此溢出标志位清零：</p><pre><code>mov al, -4mov bl, 4imul bl            ; AX = FFF0h, OF = 0</code></pre><p>下述指令执行 48 乘以 4，乘积 +192 保存在 DX:AX 中。DX 是 AX 的符号扩展，因此溢出标志位清零：</p><pre><code>mov ax, 48mov bx, 4imul bx            ; DX:AX = 000000C0h, OF = 0</code></pre><p>下述指令执行 32 位有符号乘法 (4 823 424*-423)，乘积 -2 040 308 352 保存在 EDX:EAX 中。溢出标志位清零，因为 EDX 是 EAX 的符号扩展：</p><pre><code>mov eax, +4823424mov ebx, -423imul ebx        ; EDX:EAX = FFFFFFFF86635D80h, OF = 0</code></pre><p>下述指令展示了双操作数格式：</p><pre><code>.dataword1 SWORD 4dword1 SDWORD 4.codemov ax, -16            ; AX = -16mov bx, 2              ; BX = 2imul bx, ax            ; BX = -32imul bx, 2             ; BX = -64imul bx, word1         ; BX = -256mov eax, -16           ; EAX = -16mov ebx, 2             ; EBX = 2imul ebx, eax          ; EBX = -32imul ebx, 2            ; EBX = -64imul ebx, dword1       ; EBX = -256</code></pre><p>双操作数和三操作数 IMUL 指令的目的操作数大小与乘数大小相同。因此，有可能发生有符号溢出。执行这些类型的 IMUL 指令后，总要检查溢岀标志位。下面的双操作数指令展示了有符号溢出，因为 -64000 不适合 16 位目的操作数：</p><pre><code>mov ax, -32000imul ax, 2           ; OF = 1</code></pre><p>下面的指令展示的是三操作数格式，包括了有符号溢出的例子：</p><pre><code>.dataword1 SWORD 4dword1 SDWORD 4.codeimul bx, word1, -16             ; BX = word1 * -16imul ebx, dword1, -16           ; EBX = dword1 * -16imul ebx, dword1, -2000000000   ; 有符号溢出！</code></pre><h2 id="汇编语言GetMseconds：测量程序执行时间"><a href="#汇编语言GetMseconds：测量程序执行时间" class="headerlink" title="汇编语言GetMseconds：测量程序执行时间"></a>汇编语言GetMseconds：测量程序执行时间</h2><p>通常，程序员发现用测量执行时间的方法来比较一段代码与另一段代码执行的性能是很有用的。Microsoft Windows API 为此提供了必要的工具，lrvine32 库中的 GetMseconds 过程可使其变得更加方便使用。该过程获取系统自午夜过后经过的毫秒数。</p><p>在下面的代码示例中，首先调用 GetMseconds，这样就可以记录系统开始时间。然后调用想要测量其执行时间的过程 (FirstProcedureToTest)。最后，再次调用 GetMseconds，计算开始时间和当前毫秒数的差值：</p><pre><code>.datastartTime DWORD ?procTime1 DWORD ?procTime2 DWORD ?.codecall GetMseconds    ;获得开始时间mov startTime, eax.call FirstProcedureToTest.call GetMseconds     ;获得结束时间sub eax, startTime   ;计算执行花费的时间mov procTime1, eax   ;保存执行花费的时间</code></pre><p>当然，两次调用 GetMseconds 会消耗一点执行时间。但是在衡量两个代码实现的性能时间之比时，这点开销是微不足道的。现在，调用另一个被测试的过程，并保存其执行时间 (procTime2)：</p><pre><code>call GetMseconds                ;获得开始时间mov startTime, eax.call SecondProcedureToTest.call GetMseconds                ;获得结束时间sub eax, startTime              ;计算执行花费的时间mov procTime2, eax              ;保存执行花费的时间</code></pre><p>则 procTime1 和 procTime2 的比值就可以表示这两个过程的相对性能。</p><h3 id="MUL、IMUL-与移位的比较"><a href="#MUL、IMUL-与移位的比较" class="headerlink" title="MUL、IMUL 与移位的比较"></a>MUL、IMUL 与移位的比较</h3><p>对老的 x86 处理器来说，用移位操作实现乘法和用 MUL、IMUL 指令实现乘法之间有着明显的性能差异。可以用 GetMseconds 程比较这两种类型乘法的执行时间。下面的两个过程重复执行乘法，用常量 LOOP_COUNT 决定重复的次数：</p><pre><code>mult_by_shifting PROC;;用 SHL 执行 EAX 乘以 36,执行次数为LOOP_COUNT    mov ecx, LOOP_COUNTL1: push eax                    ;保存原始 EAX    mov ebx, eax    shl eax, 5    shl ebx, 2    add eax, ebx    pop eax                      ;恢复 EAX    loop LI    retmult_by_shifting ENDPmult_by_MUL PROC;;用MUL执行EAX乘以36,执行次数为LOOP_COUNT    mov ecx, LOOP_COUNTLI: push eax                    ;保存原始 EAX    mov ebx, 36    mul ebx    pop eax                      ;恢复 EAX    loop L1    retmult_by_MUL ENDP</code></pre><p>下述代码调用 multi_by_shifting，并显示计时结果。</p><pre><code>.dataLOOP_COUNT = 0FFFFFFFFh.dataintval DWORD 5startTime DWORD ?.codemain PROC    call    GetMseconds          ; 获取开始时间    mov    startTime,eax    mov    eax,intval            ; 开始乘法    call    mult_by_shifting    call    GetMseconds          ; 获取结束时间    sub    eax,startTime    call    WriteDec             ; 显示乘法执行花费的时间</code></pre><p>用同样的方法调用 mult_by_MUL，在传统的 4GHz 奔腾 4 处理器上运行的结果为：SHL 方法执行时间是 6.078 秒，MUL 方法执行时间是 20.718 秒。也就是说，使用 MUL 指令速度会慢 2.41 倍。</p><p>但是，在近期的处理器上运行同样的程序，调用两个函数的时间是完全一样的。这个例子说明，Intel 在近期的处理器上已经设法大大地优化了 MUL 和 IMUL 指令。</p><h2 id="汇编语言DIV指令：无符号除法"><a href="#汇编语言DIV指令：无符号除法" class="headerlink" title="汇编语言DIV指令：无符号除法"></a>汇编语言DIV指令：无符号除法</h2><p>32 位模式下，DIV（无符号除法）指令执行 8 位、16 位和 32 位无符号数除法。其中，单寄存器或内存操作数是除数。格式如下：</p><pre><code>DIV reg/mem8DIV reg/meml6DIV reg/mem32</code></pre><p>下表给出了被除数、除数、商和余数之间的关系：</p><table><thead><tr><th>被除数</th><th>除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td>AX</td><td>reg/mem8</td><td>AL</td><td>AH</td></tr><tr><td>DX:AX</td><td>reg/mem16</td><td>AX</td><td>DX</td></tr><tr><td>EDX:EAX</td><td>reg/mem32</td><td>EAX</td><td>EDX</td></tr></tbody></table><p>64 位模式下，DIV 指令用 RDX:RAX 作被除数，用 64 位寄存器和内存操作数作除数, 商存放到 RAX，余数存放在 RDX 中。</p><h3 id="DIV-示例"><a href="#DIV-示例" class="headerlink" title="DIV 示例"></a>DIV 示例</h3><p>下述指令执行 8 位无符号除法 (83h/2)，生成的商为 41h，余数为 1：</p><pre><code>mov ax, 0083h   ; 被除数mov bl, 2        ; 除数div bl           ; AL = 41h, AH = Olh</code></pre><p>下图展示了寄存器内容的变化：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224849377191" alt="img"></p><p>下述指令执行 16 位无符号除法 (8003h/100h)，生成的商为 80h，余数为 3。DX 包含的是被除数的高位部分，因此在执行 DIV 指令之前，必须将其清零：</p><pre><code>mov dx, 0         ; 清除被除数高16位mov ax, 8003h     ; 被除数的低16位mov ex, 100h      ; 除数div ex            ; AX = 0080h, DX = 0003h</code></pre><p>下图展示了寄存器内容的变化：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224862453193" alt="img"></p><p>下述指令执行 32 位无符号除法，其除数为内存操作数：</p><pre><code>.datadividend QWORD 0000000800300020hdivisor DWORD 00000100h.codemov edx, DWORD PTR dividend + 4  ; 高双字mov eax, DWORD PTR dividend      ; 低双字div divisor                      ; EAX = 08003000h, EDX = 00000020h</code></pre><p>下图展示了寄存器内容的变化：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224876038195" alt="img"></p><p>下面的 64 位除法生成的商 (0108 0000 0000 3330h) 在 RAX 中，余数 (0000 0000 0000 0020h) 在 RDX 中：</p><pre><code>.datadividend_hi QWORD 0000000000000108hdividend_lo QWORD 0000000033300020hdivisor QWORD OOOOOOOOOOOlOOOOh.codemov rdx, dividend_himov rax, dividend_lodiv divisor                ; RAX = 0108000000003330                           ; RDX = 0000000000000020</code></pre><p>请注意，由于被 64k 除，被除数中的每个十六进制数字是如何右移 4 位的。(若被 16 除，则每个数字只需右移一位。)</p><h2 id="汇编语言IDICV指令：有符号数除法"><a href="#汇编语言IDICV指令：有符号数除法" class="headerlink" title="汇编语言IDICV指令：有符号数除法"></a>汇编语言IDICV指令：有符号数除法</h2><p>有符号除法几乎与无符号除法相同，只有一个重要的区别：在执行除法之前，必须对被除数进行符号扩展。</p><p>符号扩展是指将一个数的最高位复制到包含该数的变量或寄存器的所有高位中。为了说明为何有此必要，让我们先不这么做。下面的代码使用 MOV 把 -101 赋给 AX，即 DX:AX 的低半部分：</p><pre><code>.datawordVal SWORD -101      ; 009Bh.codemov dx, 0mov ax, wordVal         ; DX:AX = 0000009Bh (+155mov bx, 2               ; BX 是除数idiv bx                 ; DX:AX除以BX (有符号操作)</code></pre><p>可惜的是，DX:AX 中的 009Bh 并不等于 -101，它等于 +155。因此，除法产生的商为 +77，这不是所期望的结果。而解决该问题的正确方法是使用 CWD( 字转双字 ) 指令，在进行除法之前在 DX:AX 中对 AX 进行符号扩展：</p><pre><code>.datawordVal SWORD -101      ; 009Bh.codemov dx, 0mov ax, wordVal          ; DX:AX = 0000009Bh (+155)cwd                      ; DX:AX = FFFFFF9Bh (-101 )mov bx, 2idiv bx</code></pre><p>x86 指令集有几种符号扩展指令。首先了解这些指令，然后再将其应用到有符号除法指令 IDIV 中。</p><h3 id="符号扩展指令（CBW、CWD、CDQ）"><a href="#符号扩展指令（CBW、CWD、CDQ）" class="headerlink" title="符号扩展指令（CBW、CWD、CDQ）"></a>符号扩展指令（CBW、CWD、CDQ）</h3><p>Intel 提供了三种符号扩展指令：CBW、CWD 和 CDQ。CBW（字节转字）指令将 AL 的符号位扩展到 AH，保留了数据的符号。如下例所示，9Bh（AL 中）和 FF9Bh （AX 中）都等于十进制的 -101：</p><pre><code>.databyteVal SBYTE -101     ; 9Bh.codemov al, byteVal        ; AL = 9Bhcbw                    ; AX = FF9Bh</code></pre><p>CWD（字转双字）指令将 AX 的符号位扩展到 DX：</p><pre><code>.datawordVal SWORD -101     ; FF9Bh.codemov ax, wordVal         ; AX = FF9Bhcwd                     ; DX:AX = FFFFFF9Bh</code></pre><p>CDQ（双字转四字）指令将 EAX 的符号位扩展到 EDX：</p><pre><code>.datadwordVal SDWORD -101    ; FFFFFF9Bh.codemov eax, dwordValCdq                     ; EDX:EAX = FFFFFFFFFFFFFF9Bh</code></pre><h3 id="IDIV-指令"><a href="#IDIV-指令" class="headerlink" title="IDIV 指令"></a>IDIV 指令</h3><p>IDIV（有符号除法）指令执行有符号整数除法，其操作数与 DIV 指令相同。执行 8 位除法之前，被除数（AX）必须完成符号扩展。余数的符号总是与被除数相同。</p><p>【示例 1】下述指令实现 -48 除以 5。IDIV 执行后，AL 中的商为 -9，AH 中的余数为 -3：</p><pre><code>.databyteVal SBYTE -48       ;D0 十六进制.codemov al, byteVal         ;被除数的低字节cbw                     ;AL扩展到AHmov bl,+5               ;除数idiv bl                 ;AL = -9, AH = -3</code></pre><p>下图展示了 AL 是如何通过 CBW 指令符号扩展为 AX 的：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224895878197" alt="img"></p><p>为了理解被除数的符号扩展为什么这么重要，现在在不进行符号扩展的前提下重复之前的例子。下面的代码将 AH 初始化为 0，这样它就有了确定值，然后没有用 CBW 指令转换被除数就直接进行了除法：</p><pre><code>.databyteVal SBYTE -48       ;D0 十六进制.codemov ah, 0               ;被除数高字节mov al, byteVal         ;被除数低字节mov bl, +5              ;除数idiv bl                 ;AL = 41z AH = 3</code></pre><p>执行除法之前，AX=00D0h ( 十进制数 208)。 IDIV 把这个数除以 5，生成的商为十进制数 41，余数为3。这显然不是正确答案。</p><p>【示例 2】16 位除法要求 AX 符号扩展到 DX。下例执行 -5000 除以 256：</p><pre><code>.datawordVal SWORD -5000.codemov ax, wordVal          ;被除数的低字cwd                      ;AX扩展到DXmov bx, +256             ;除数idiv bx                  ;商 AX=-19,余数 DX=-13 6</code></pre><p>【示例 3】32 位除法要求 EAX 符号扩展到 EDX。下例执行 50 000 除以 -256：</p><pre><code>.datadwordVal SDWORD +50000.codemov eax, dwordVal         ;被除数的低双字cdq                       ;EAX 扩展至q EDXmov ebx, -256             ;除数idiv ebx                 ;商 EAX=-195,余数 EDX=+80</code></pre><p>执行 DIV 和 IDIV 后，所有算术运算状态标志位的值都不确定。</p><h3 id="除法溢出"><a href="#除法溢出" class="headerlink" title="除法溢出"></a>除法溢出</h3><p>如果除法操作数生成的商不适合目的操作数，则产生除法溢出 (divide overflow)。这将导致处理器异常并暂停执行当前程序。例如，下面的指令就产生了除法溢出，因为它的商 (100h) 对 8 位的 AL 目标寄存器来说太大了：</p><pre><code>mov ax,1000hmov bl,10hdiv bl          ; AL无法容纳100h</code></pre><p>运行这段代码时，Visual Studio 就会产生如下所示的结果错误。如果试图运行除以零的代码，也会显示相同的对话框。</p><pre><code>Unhandled exception at 0x00401016 in Project.exe:0xC0000095:Integer overflow.</code></pre><p>对此有个建议：使用 32 位除数和 64 位被除数来减少出现除法溢出条件的可能性。如下面的代码所示，除数为 EBX，被除数在 EDX 和 EAX 组成的 64 位寄存器对中：</p><pre><code>mov eax,1000hcdqmov ebx,10hdiv ebx              ; EAX = 00000100h</code></pre><p>要预防除以零的操作，则在进行除法之前检查除数：</p><pre><code>mov ax, dividendmov bl, divisorcmp bl, 0              ;检查除数je NoDivideZero        ;为零？显不错误div bl                 ;不为零：继续..NoDivideZero:         ;显示 "Attmpt to divide by zero"</code></pre><h2 id="使用汇编语言实现算术表达式-实例"><a href="#使用汇编语言实现算术表达式-实例" class="headerlink" title="使用汇编语言实现算术表达式[实例]"></a>使用汇编语言实现算术表达式[实例]</h2><p>有两种简单的方法可以查看 C++ 编译器生成的汇编代码：</p><ul><li><p>一种方法是用 Visual Studio 调试时，在调试窗口中右键点击，选择 Go to Disassembly。</p></li><li><p>一种方法是，在 Project 菜单中选择 Properties，生成一个列表文件。在 Configuration Properties，选择 Microsoft Macro Assembler，再选择 Listing Fileo 在对话窗口中，将 Generate Preprocessed Source Listing 设置为 Yes，List All Available Information 也设置为 Yes。</p></li></ul><p>【示例 1】使用 32 位无符号整数，用汇编语言实现下述 C++ 语句：</p><pre><code>var4 = (var1 + var2) * var3;</code></pre><p>这个问题很简单，因为可以从左到右来处理 (先加法再乘法)。执行了第二条指令后，EAX 存放的是 val1 与 var2 之和。第三条指令中，EAX 乘以 var3，乘积存放在 EAX 中：</p><pre><code>mov eax, var1add eax, var2mul var3                   ; EAX = EAX * var3jc tooBig                  ;无符号溢出？mov var4, eaxjmp nexttooBig:                    ;显示错误消息</code></pre><p>如果 MUL 指令产生的乘积大于 32 位，则 JC 指令跳转到有标号指令来处理错误。</p><p>【示例 2】使用 32 位无符号整数实现下述 C++ 语句：</p><pre><code>var4 = (var1 * 5) / (var2 - 3);</code></pre><p>本例有两个用括号括起来的子表达式。左边的子表达式可以分配给 EDX:EAX，因此不必检查溢出。右边的子表达式分配给 EBX，最后用除法完成整个表达式：</p><pre><code>mov eax, var1             ;左边的子表达式mov ebx, 5mul ebx                   ;EDX:EAX=乘积mov ebx, var2             ;右边的子表达式sub ebx, 3div ebx                   ;最后的除法mov var4, eax</code></pre><p>【示例 3】使用 32 位有符号整数实现下述 C++ 语句：</p><pre><code>var4 = (varl * -5) / (-var2 % var3);</code></pre><p>与之前的例子相比，这个例子需要一些技巧。可以先从右边的表达式开始，并将其保存在 EBX 中。由于操作数是有符号的，因此必须将被除数符号扩展到 EDX，再使用 IDIV 指令：</p><pre><code>mov eax,var2         ;开始计算右边的表达式neg eaxcdq                  ;符号扩展被除数idiv var3            ;EDX = 余数mov ebx,edx          ;EBX = 右边表达式的结果</code></pre><p>第二步，计算左边的表达式，并将乘积保存在 EDX:EAX 中：</p><pre><code>mov eax, -5          ;开始计算左边表达式imul var1            ;EDX:EAX=左边表达式的结果</code></pre><p>最后，左边表达式结果 (EDX:EAX) 除以右边表达式结果 (EBX)：</p><pre><code>idiv ebx             ;最后计算除法mov var4,eax         ;商</code></pre><h2 id="汇编语言ADC指令：带进位加法"><a href="#汇编语言ADC指令：带进位加法" class="headerlink" title="汇编语言ADC指令：带进位加法"></a>汇编语言ADC指令：带进位加法</h2><p>ADC（带进位加法）指令将源操作数和进位标志位的值都与目的操作数相加。该指令格式与 ADD 指令一样，且操作数大小必须相同：</p><pre><code>ADC reg, regADC mem, regADC reg, memADC mem, immADC reg, imm</code></pre><p>例如，下述指令实现两个 8 位整数相加 (FFh+FFh)，产生的 16 位和数存入 DL:AL，其值为 01FEh：</p><pre><code>mov dl, 0mov al, 0FFhadd al, 0FFh    ; AL = FEhadc dl, 0       ; DL/AL = OlFEh</code></pre><p>下图展示了这两个数相加过程中的数据活动。首先，FFh 与 AL 相加，生成 FEh 存入 AL 寄存器，并将进位标志位置 1。然后，将 0 和进位标志位与 DL 寄存器相加：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224917793199" alt="img"></p><p>同样，下述指令实现两个 32 位整数相加 (FFFF FFFFh+ FFFF FFFFh)，产生的 64 位和数存入 EDX:EAX，其值为：0000 0001 FFFF FFFEh：</p><pre><code>mov edx, 0mov eax, 0FFFFFFFFhadd eax, 0FFFFFFFFhadc edx, 0</code></pre><h3 id="扩展加法示例"><a href="#扩展加法示例" class="headerlink" title="扩展加法示例"></a>扩展加法示例</h3><p>接下来将说明过程 Extended_Add 实现两个大小相同的扩展整数的加法。利用循环，该过程将两个扩展整数当作并行数组实现加法操作。数组中每对数值相加时，都要包括前一次循环迭代执行的加法所产生的进位标志位。实现过程时，假设整数存储在字节数组中，不过 本例很容易就能修改为双字数组的加法。</p><p>该过程接收两个指针，存入 ESI 和 EDI，分别指向参与加法的两个整数。EBX 寄存器指向缓冲区，用于存放和数，该缓冲区的前提条件是必须比两个加数大一个字节。此外，过程还用 ECX 接收最长加数的长度。</p><p>两个加数都需要按小端顺序存放，即其最低字节存放在该数组的起始地址。过程代码如下所示，添加了代码行编号便于进行详细讨论：</p><pre><code>;------------------------------------------Extended_Add PROC; 计算两个以字节数组存放的扩展整数之和。; 接收：ESI和EDI为两个加数的指针;      EBX 为和数变量指针，;      ECX为; 相加的字节数。; 和数存储区必须比输入的操作数多一个字节。; 返回：无;------------------------------------------    pushad    clc                         ;清除进位标志位L1: mov    al, [esi]            ;取第一个数    adc    al, [edi]            ;与第二个数相加    pushfd                      ;保存进位标志位    mov    [ebx], al            ;保存部分和    add    esi, 1               ;三个指针都加1    add    edi, 1    add    ebx, 1    popfd                      ;恢复进位标志位    loop    L1                 ;重复循环    mov byte ptr [ebx], 0      ;清除和数高字节    adc byte ptr [ebx], 0      popad                      ;加上其他的进位    retExtended_Add ENDP</code></pre><p>当第14行和第15行将两个数组的最低字节相加时，加法运算可能会将进位标志位置 1。因此，第16行将进位标志位压入堆栈进行保存就很重要，因为在循环重复时会用到进位 标志位。第17行保存了和数的第一个字节，第18〜20行将三个指针（两个操作数，一个和数）都加 1。第 21 行恢复进位标志位，第 22 行将循环返回到第 14 行。</p><p>（LOOP 指令不会修改 CPU 的状态标志位。）再次循环时，第 17 行进行的是第二对字节的加法，其中包括进位标志位的值。因此，如果第一次循环过程产生了进位，则第二次循环就要包括该进位。按照这种方式循环，直到所有的字节都完成了加法。然后，最后的第 24 行和第 25 行检查操作数最高字节相加是否产生进位，若产生了进位，就将该值加到和数多岀来的那个字节中。</p><p>下面的代码示例调用 Extended_Add，并向其传递两个 8 字节的整数。要注意为和数多分配一个字节：</p><pre><code>.dataop1 BYTE 34h,12h,98h,74h,06h,0A4h,0B2h,0A2hop2 BYTE 02h,45h,23h,00h,00h,87h,10h,80hsum BYTE 9 dup(0)     ; = 0122C32B0674BB5736h.codemain PROC    mov    esi,OFFSET op1        ; 第一个操作数    mov    edi,OFFSET op2        ; 第二个操作数    mov    ebx,OFFSET sum        ; 和数    mov    ecx,LENGTHOF op1      ; 字节数    call    Extended_Add; 显示和数    mov  esi,OFFSET sum    mov  ecx,LENGTHOF sum    call    Display_Sum    call Crlf</code></pre><p>上述程序的输出如下所示，加法产生了一个进位：</p><pre><code>0122C32B0674BB5736</code></pre><p>过程 Display_Sum 按照正确的顺序显示和数，即从最高字节开始依次显示到最低字节：</p><pre><code>Display_Sum PROC    pushad    ; 指向左后一个数组    add esi,ecx    sub esi,TYPE BYTE    mov ebx,TYPE BYTEL1:    mov  al,[esi]            ; 取一个数组字节    call WriteHexB              ; 显示该字节    sub  esi,TYPE BYTE          ; 指向前一个字节    loop L1    popad    retDisplay_Sum ENDP</code></pre><h2 id="汇编语言SBB指令：带借位减法"><a href="#汇编语言SBB指令：带借位减法" class="headerlink" title="汇编语言SBB指令：带借位减法"></a>汇编语言SBB指令：带借位减法</h2><p>SBB（带借位减法）指令从目的操作数中减去源操作数和进位标志位的值。</p><p>下面的示例代码用 32 位操作数实现 64 位减法，EDX:EAX 的值为 0000 0007 0000 0001h，从该值中减去 2。低 32 位先执行减法，并设置进位标志位，然后高 32 位再进行包括进位标志位的减法：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627224985454201" alt="img"></p><h2 id="汇编语言ASCII和非压缩十进制运算"><a href="#汇编语言ASCII和非压缩十进制运算" class="headerlink" title="汇编语言ASCII和非压缩十进制运算"></a>汇编语言ASCII和非压缩十进制运算</h2><p>假设程序需要用户输入两个数，并将它们相加。若用户输入 3402 和 1256，则程序输出如下所示：</p><p>输入第一个数： 3402</p><p>输入第二个数： 1256</p><p>和数： 4658</p><p>有两种方法可以计算并显示和数：</p><p>\1) 将两个操作数都转换为二进制，进行二进制加法，再将和数从二进制转换为 ASCII 数字串。</p><p>\2) 直接进行数字串的加法，按序相加每对 ASCII 数字（2+6、0+5、4+2、3+1）。和数为 ASCII 数字串，因此可以直接显示在屏幕上。</p><p>第二种方法需要在执行每对 ASCII 数字相加后，用特殊指令来调整和数。有四类指令用于处理 ASCII 加法、减法、乘法和除法，如下所示：</p><table><thead><tr><th>AAA</th><th>（执行加法后进行 ASCII 调整）</th><th>AAM</th><th>（执行乘法后进行 ASCII 调整）</th></tr></thead><tbody><tr><td>AAS</td><td>（执行减法后进行 ASCII 调整）</td><td>AAD</td><td>（执行除法前进行 ASCII 调整）</td></tr></tbody></table><h4 id="ASCII-十进制数和非压缩十进制数"><a href="#ASCII-十进制数和非压缩十进制数" class="headerlink" title="ASCII 十进制数和非压缩十进制数"></a>ASCII 十进制数和非压缩十进制数</h4><p>非压缩十进制整数的高 4 位总是为零，而 ASCII 十进制数的高 4 位则应该等于 0011b。在任何情况下，这两种类型的每个数字都占用一个字节。</p><p>下面的例子展示了 3402 用这两种类型存放的格式：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225000028203" alt="img"></p><p>尽管 ASCII 运算执行速度比二进制运算要慢很多，但是它有两个明显的优点：</p><p>\1) 不必在执行运算之前转换串格式。</p><p>\2) 使用假设的十进制小数点，使得实数操作不会出现浮点运算的舍入误差的危险。</p><p>ASCII 加减法运行操作数为 ASCII 格式或非压缩十进制格式，但是乘除法只能使用非压缩十进制数。</p><h2 id="汇编语言AAA指令：调整ADD或ADC指令的二进制运算结果"><a href="#汇编语言AAA指令：调整ADD或ADC指令的二进制运算结果" class="headerlink" title="汇编语言AAA指令：调整ADD或ADC指令的二进制运算结果"></a>汇编语言AAA指令：调整ADD或ADC指令的二进制运算结果</h2><p>在 32 位模式下，AAA ( 加法后的 ASCII 调整 ) 指令调整 ADD 或 ADC 指令的二进制运算结果。设两个 ASCII 数字相加，其二进制结果存放在 AL 中，则 AAA 将 AL 转换为两个非压缩十进制数字存入 AH 和 AL。一旦成为非压缩格式，通过将 AH 和 AL 与 30h 进 OR 运算，很容易就能把它们转换为 ASCII 码。</p><p>下例展示了如何用 AAA 指令正确地实现 ASCII 数字 8 加 2。在执行加法之前，必须把 AH 清零，否则它将影响 AAA 执行的结果。最后一条指令将 AH 和 AL 转换为 ASCII 数字：</p><pre><code>mov ah, 0mov al, '8'                     ; AX = 0038hadd al, '2'                     ; AX = 006Ahaaa                             ; AX = 0100h (结果进行 ASCII 调整)or ax, 3030h                    ; AX = 3130h ='10' (转换为 ASCH 码)</code></pre><h3 id="使用-AAA-实现多字节加法"><a href="#使用-AAA-实现多字节加法" class="headerlink" title="使用 AAA 实现多字节加法"></a>使用 AAA 实现多字节加法</h3><p>现在来查看一个过程，其功能为实现包含了隐含小数点的 ASCII 十进制数值相加。由于每次数字相加的进位标志位都要传递到更高位，因此，过程的实现要比想象的更复杂一些。下面的伪代码中，acc 代表的是一个 8 位的累加寄存器：</p><pre><code>esi (index) = length of first_number - 1edi (index) = length of first_numberecx = length of first_numberset carry value to 0Loop   acc = first_number[esi]   add previous carry to acc   save carry in carry1   acc += second_number[esi]   OR the carry with carry1   sum[edi] = acc   dec ediUntil ecx == 0Store last carry digit in sum</code></pre><p>进位值必须总是被转换为 ASCII 码。将进位值与第一个操作数相加时，就需要用 AAA 来调整结果。程序清单如下：</p><pre><code>; ASCII Addition                      (ASCII_add.asm); 对有隐含固定小数点的串执行 ASCII 运算。INCLUDE Irvine32.incDECIMAL_OFFSET = 5                            ; 距离右侧的偏移量.datadecimal_one BYTE "100123456789765"            ; 1001234567.89765decimal_two BYTE "900402076502015"            ; 9004020765.02015sum BYTE (SIZEOF decimal_one + 1) DUP(0),0.codemain PROC; 从最后一个数字开始    mov    esi,SIZEOF decimal_one - 1    mov    edi,SIZEOF decimal_one    mov    ecx,SIZEOF decimal_one    mov    bh,0                       ; 进位值清零L1:    mov    ah,0                    ; 执行加法前清除AH    mov    al,decimal_one[esi]        ; 取第一个数字    add    al,bh                      ; 加上之前的进位值    aaa                               ; 调整和数 (AH = 进位值)    mov    bh,ah                      ; 将进位保存到 carry1    or    bh,30h                      ; 将其转化为 ASCII 码    add    al,decimal_two[esi]        ; 加第二个数字    aaa                               ; 调整和数 (AH = 进位值)    or    bh,ah                       ; 将进位值 carry1 进行 OR 运算    or    bh,30h                      ; 将其转换为 ASCII 码    or    al,30h                      ; 将 AL 转换为 ASCII 码    mov    sum[edi],al                ; 将 AL 保存到 sum    dec    esi                        ; 后退一个数字    dec    edi    loop    L1    mov    sum[edi],bh                ; 保存最后的进位值; 显示和数字符串    mov    edx,OFFSET sum    call    WriteString    call    Crlf    exitmain ENDPEND main</code></pre><p>程序输出如下所示，和数没有显示十进制小数点:1000 5255 3329 1780</p><h2 id="汇编语言AAS指令：减法后的ASXII调整"><a href="#汇编语言AAS指令：减法后的ASXII调整" class="headerlink" title="汇编语言AAS指令：减法后的ASXII调整"></a>汇编语言AAS指令：减法后的ASXII调整</h2><p>32 位模式下，AAS（减法后的 ASCII 调整）指令紧随 SUB 或 SBB 指令之后，这两条指令执行两个非压缩十进制数的减法，并将结果保存到 AL 中。AAS 指令将 AL 转换为 ASCII 码的数字形式。</p><p>只有减法结果为负时，调整才是必需的。比如，下面的语句实现 ASCII 码 数字 8 减去 9：</p><pre><code>.dataval1 BYTE '8'val2 BYTE '9'.codemov ah, 0mov al,val1            ; AX = 0038hsub al,val2            ; AX = OOFFhaas                    ; AX = FF09hpushf                  ; 保存进位标志位or al,30h              ; AX = FF39hpopf                   ; 恢复进位标志位</code></pre><p>执行 SUB 指令后，AX 等于 00FFh。AAS 指令将 AL 转换为 09h，AH 减 1 等于 FFh，并且把进位标志位置 1。</p><h2 id="汇编语言AAM（乘法后的ASCII调整）和AAD（除法之前的ASCII调整）指令"><a href="#汇编语言AAM（乘法后的ASCII调整）和AAD（除法之前的ASCII调整）指令" class="headerlink" title="汇编语言AAM（乘法后的ASCII调整）和AAD（除法之前的ASCII调整）指令"></a>汇编语言AAM（乘法后的ASCII调整）和AAD（除法之前的ASCII调整）指令</h2><p>32 位模式下，MUL 执行非压缩十进制乘法，AAM（乘法后的 ASCII 调整）指令转换由其产生的二进制乘积。乘法只能使用非压缩十进制数。</p><p>下面的例子实现 5 乘以 6，并调整 AX 中的结果。调整后，AX=0300h，非压缩十进制表示为 30：</p><pre><code>.dataAscVal BYTE 05h, 06h.codemov bl, ascVal      ;第一个操作数mov al, [ascVal+1]  ;第二个操作数mul bl              ;AX = 001Ehaam                 ;AX = 0300h</code></pre><p>同样在 32 位模式下，AAD（除法之前的 ASCII 调整）指令将 AX 中的非压缩十进制被除数转换为二进制，为执行 DIV 指令做准备。</p><p>下面的例子把非压缩 0307h 转换为二进制数，然后除以 5。DIV 指令在 AL 中生成商 07h，在 AH 中生成余数 02h：</p><pre><code>.dataquotient BYTE ?remainder BYTE ?.codemov ax, 0307h         ; 被除数aad                   ; AX = 0025hmov bl, 5             ; 除数div bl                ; AX = 0207hmov quotient,almov remainder,ah</code></pre><h2 id="汇编语言压缩十进制运算简介"><a href="#汇编语言压缩十进制运算简介" class="headerlink" title="汇编语言压缩十进制运算简介"></a>汇编语言压缩十进制运算简介</h2><p>压缩十进制数的每个字节存放两个十进制数字，每个数字用 4 位表示。如果数字个数为奇数，则最高的半字节用零填充。存储大小可变：</p><pre><code>bcd1 QWORD 2345673928737285h       ;十进制数 2 345 673 928 737 285bcd2 DWORD 12345678h            ;十进制数 12 345 678bcd3 DWORD 08723654h            ;十进制数 8 723 654bcd4 WORD 9345h                 ;十进制数 9345bcd5 WORD 0237h                 ;十进制数 237bcd6 BYTE 34h                     ;十进制数 34</code></pre><p>压缩十进制存储至少有两个优势：</p><p>\1) 数据几乎可以包含任何个数的有效数字。这使得以很高的精度执行计算成为可能。</p><p>\2) 实现压缩十进制数与 ASCII 码之间的相互转换相对简单。</p><p>DAA（加法后的十进制调整）和 DAS（减法后的十进制调整）这两条指令调整压缩十进制数加减法的结果。可惜的是，目前还没有与乘除法有关的相似指令。在这些情况下，相乘或相除的数必须是非压缩的，执行后再压缩。</p><h2 id="汇编语言DAA指令：加法后的十进制调整"><a href="#汇编语言DAA指令：加法后的十进制调整" class="headerlink" title="汇编语言DAA指令：加法后的十进制调整"></a>汇编语言DAA指令：加法后的十进制调整</h2><p>32 位模式下，ADD 或 ADC 指令在 AL 中生成二进制和数，DAA（加法后的十进制调整）指令将和数转换为压缩十进制格式。比如，下述指令执行压缩十进制数 35 加 48。二进制和数（7Dh）被调整为 83h，即 35 和 48 的压缩十进制和数。</p><pre><code>mov al, 35hadd al, 48h       ; AL = 7Dhdaa          ; AL = 83h （调整后的结果）</code></pre><p>【示例】下面的程序执行两个 16 位压缩十进制整数加法，并将和数保存在一个压缩双字中。加法要求和数变量的存储大小比操作数多一个数字：</p><pre><code>; 压缩十进制示例    （AddPacked.asm）; 演示压缩十进制加法。INCLUDE Irvine32.inc.datapacked_1 WORD 4536hpacked_2 WORD 7207hsum DWORD ?.codemain PROC; 初始化和数与索引    mov    sum,0    mov    esi,0; 低字节相加    mov    al,BYTE PTR packed_1[esi]    add    al,BYTE PTR packed_2[esi]    daa    mov    BYTE PTR sum[esi],al; 高字节相加，包括进位标志位    inc    esi    mov    al,BYTE PTR packed_1[esi]    adc    al,BYTE PTR packed_2[esi]    daa    mov    BYTE PTR sum[esi],al; 若还有进位，则加上该进位值    inc    esi    mov    al,0    adc    al,0    mov    BYTE PTR sum[esi],al; 用十六进制显示和数    mov    eax,sum    call    WriteHex    call    Crlf    exitmain ENDPEND main</code></pre><h2 id="汇编语言DAS指令：减法后的十进制调整"><a href="#汇编语言DAS指令：减法后的十进制调整" class="headerlink" title="汇编语言DAS指令：减法后的十进制调整"></a>汇编语言DAS指令：减法后的十进制调整</h2><p>32 位模式下，SUB 或 SBB 指令在 AL 中生成二进制结果，DAS（减法后的十进制调整）指令将其转换为压缩十进制格式。</p><p>具体调整规则如下：</p><ul><li><p>如果 AL 的低四位大于 9，或 AF=1，那么，AL=AL-06H，并置 AF=1；</p></li><li><p>如果 AL 的高四位大于 9，或 CF=1，那么，AL=AL-60H，并置 CF=1；</p></li><li><p>如果以上两点都不成立，则清除标志位 AF 和 CF。</p></li></ul><p>经过调整后，AL 的值仍是压缩型 BCD 码，即：二个压缩型 BCD 码相减，并进行调整后，得到的结果还是压缩型 BCD 码。</p><p>比如，下面的语句计算压缩十进制数 85 减 48，并调整结果：</p><pre><code>mov bl,48hmov al,85hsub al,bl   ; AL = 3Dhdas         ; AL = 37h （调整后的结果）</code></pre><p>DAS 的内部逻辑请参阅 Intel 指令集参考手册。</p><h1 id="汇编语言高级过程"><a href="#汇编语言高级过程" class="headerlink" title="汇编语言高级过程"></a>汇编语言高级过程</h1><h2 id="汇编语言堆栈帧简介"><a href="#汇编语言堆栈帧简介" class="headerlink" title="汇编语言堆栈帧简介"></a>汇编语言堆栈帧简介</h2><p>子程序接收的是寄存器参数。比如在 Irvine32 链接库中就是如此。接下来将展示子程序如何用堆栈接收参数。</p><p>在 32 位模式下，堆栈参数总是由 Windows API 函数使用。然而在 64 位模式下，Windows 函数可以同时接收寄存器参数和堆栈参数。</p><p>堆栈帧 (stack frame)( 或活动记录 (activation Tecord)) 是一块堆栈保留区域，用于存放被传递的实际参数、子程序的返回值、局部变量以及被保存的寄存器。</p><p>堆栈帧的创建步骤如下所示：</p><p>\1) 被传递的实际参数。如果有，则压入堆栈。</p><p>\2) 当子程序被调用时，使该子程序的返回值压入堆栈。</p><p>\3) 子程序开始执行时，EEP 被压入堆栈。</p><p>\4) 设置 EBP 等于 ESP。从这时开始，EBP 就变成了该子程序所有参数的引用基址。</p><p>\5) 如果有局部变量，修改 ESP 以便在堆栈中为这些变量预留空间。</p><p>\6) 如果需要保存寄存器，就将它们压入堆栈。</p><p>程序内存模式和对参数传递规则的选择直接影响到堆栈帧的结构。</p><p>学习用堆栈传递参数有个好理由：几乎所有的高级语言都会用到它们。比如，如果想要在 32 位 Windows 应用程序接口 (API) 中调用函数，就必须用堆栈传递参数。而 64 位程序可以使用另一种不同的参数传递规则。</p><h2 id="汇编语言寄存器参数的缺点"><a href="#汇编语言寄存器参数的缺点" class="headerlink" title="汇编语言寄存器参数的缺点"></a>汇编语言寄存器参数的缺点</h2><p>多年以来，Microsoft 在 32 位程序中包含了一种参数传递规则，称为 fastcall。如同这个名字所暗示的，只需简单地在调用子程序之前把参数送入寄存器，就可以将运行效率提高一些。相反，如果把参数压入堆栈，则执行速度就要更慢一点。</p><p>典型用于参数的寄存器包括 EAX、EBX、ECX 和 EDX，少数情况下，还会使用 EDI 和 ESI。可惜的是，这些寄存器在用于存放数据的同时，还用于存放循环计数值以及参与计算的操作数。</p><p>因此，在过程调用之前，任何存放参数的寄存器须首先入栈，然后向其分配过程参数，在过程返回后再恢复其原始值。例如，如下代码从 Irvine32 链接库中调用了 DumpMem：</p><pre><code>push ebx               ;保存寄存器值push ecxpush esimov esi,OFFSET array   ;初始 OFFSETmov ecx,LENGTHOF array ;大小，按元素个数计mov ebx, TYPE array    ;双字格式call DumpMem           ;显示内存pop esi                ;恢复寄存器值pop ecxpop ebx</code></pre><p>这些额外的入栈和出栈操作不仅会让代码混乱，还有可能消除性能优势，而这些优势正是通过使用寄存器参数所期望获得的！此外，程序员还要非常仔细地将 PUSH 与相应的 POP 进行匹配，即使代码存在着多个执行路径。</p><p>例如，在下面的代码中，第 8 行的 EAX 如果等于 1，那么过程在第 17 行就无法返回其调用者，原因就是有三个寄存器的值留在运行时堆栈里。</p><pre><code>push ebx                   ;保存寄存器值push ecxpush esimov esi, OFFSET array      ;初始 OFFSETmov ecx, LENGTHOF array    ;大小，按元素个数计mov ebx, TYPE array        ;双字格式call DumpMem               ;显示内存cmp eax, 1                 ;设置错误标志？je error_exit              ;设置标志后退出pop esi                    ;恢复寄存器值pop ecxpop ebxreterror_exit:mov edx, offset error_msgret不得不说，像这样的错误是不容易发现的，除非是花了相当多的时间来检查代码。</code></pre><p>堆栈参数提供了一种不同于寄存器参数的灵活方法：只需要在调用子程序之前，将参数压入堆栈即可。比如，如果 DumpMem 使用了堆栈参数，就可以通过如下代码对其进行调用：</p><pre><code>push TYPE arraypush LENGTHOF arraypush OFFSET arraycall DumpMem</code></pre><p>子程序调用时，有两种常见类型的参数会入栈：</p><ul><li><p>值参数（变量和常量的值）</p></li><li><p>引用参数（变量的地址）</p></li></ul><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><p>当一个参数通过数值传递时，该值的副本会被压入堆栈。假设调用一个名为 AddTwo 的子程序，向其传递两个 32 位整数：</p><pre><code>.dataval1 DWORD 5val2 DWORD 6.codepush val2push val1call AddTwo</code></pre><p>执行 CALL 指令前，堆栈如下图所示：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225057439205" alt="img"></p><p>用 C++ 编写相同的功能调用则为</p><pre><code>int sum = AddTwo(val1, val2);</code></pre><p>观察发现参数入栈的顺序是相反的，这是 C 和 C++ 语言的规范。</p><h4 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h4><p>通过引用来传递的参数包含的是对象的地址（偏移量）。下面的语句调用了 Swap，并传递了两个引用参数：</p><pre><code>push OFFSET val2push OFFSET val1call Swap</code></pre><p>调用 Swap 之前，堆栈如下图所示：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225074159207" alt="img"></p><p>在 C/C++ 中，同样的函数调用将传递 val1 和 val2 参数的地址：</p><pre><code>Swap(&amp;vail, &amp;val2);</code></pre><h4 id="传递数组"><a href="#传递数组" class="headerlink" title="传递数组"></a>传递数组</h4><p>高级语言总是通过引用向子程序传递数组。也就是说，它们把数组的地址压入堆栈。然后，子程序从堆栈获得该地址，并用其访问数组。</p><p>不愿意用值来传递数组的原因是显而易见的，因为这样就会要求将每个数组元素分别压入堆栈。这种操作不仅速度很慢，而且会耗尽宝贵的堆栈空间。</p><p>下面的语句用正确的方法向子程序 ArrayFill 传递了数组的偏移量：</p><pre><code>.dataarray DWORD 50 DUP(?).codepush OFFSET arraycall ArrayFill</code></pre><h2 id="汇编语言访问堆栈参数详解"><a href="#汇编语言访问堆栈参数详解" class="headerlink" title="汇编语言访问堆栈参数详解"></a>汇编语言访问堆栈参数详解</h2><p>高级语言有多种方式来对函数调用的参数进行初始化和访问。以 C 和 C++ 语言为例，它们以保存 EBP 寄存器并使该寄存器指向栈顶的语句为开始 (prologue)。</p><p>然后，根据实际情况，它们可以把某些寄存器入栈，以便在函数返回时恢复这些寄存器的值。在函数结尾 (epilogue) 部分，恢复 EBP 寄存器，并用 RET 指令返回调用者。</p><h4 id="AddTwo示例"><a href="#AddTwo示例" class="headerlink" title="AddTwo示例"></a>AddTwo示例</h4><p>下面是用 C 编写的 AddTwo 函数，它接收了两个值传递的整数，然后返回这两个数之和：</p><pre><code>int AddTwo( int x, int y ){    return x + y;}</code></pre><p>现在用汇编语言实现同样的功能。在函数开始的时候，AddTwo 将 EBP 入栈，以保存其当前值：</p><pre><code>AddTwo PROC   push ebp</code></pre><p>接下来，EBP 的值被设置为等于 ESP，这样 EBP 就成为 AddTwo 堆栈帧的基址指针：</p><pre><code>AddTwo PROC   push ebp   mov ebp,esp</code></pre><p>执行了上面两条指令后，堆栈帧的内容如下图所示。而形如 AddTwo(5, 6) 的函数调用会先把第一个参数入栈，再把第二个参数入栈：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225091937209" alt="img"></p><p>AddTwo 在其他寄存器入栈时，不用通过 EEP 来修改堆栈参数的偏移量。数值会改变的是 ESP，而 EBP 则不会。</p><h4 id="基址-偏移量寻址"><a href="#基址-偏移量寻址" class="headerlink" title="基址-偏移量寻址"></a>基址-偏移量寻址</h4><p>可以使用基址-偏移量寻址 (base-offset addressing) 方式来访问堆栈参数。其中，EBP 是基址寄存器，偏移量是常数。通常，EAX 为 32 位返回值。AddTwo 的实现如下所示，参数相加后，EAX 返回它们的和数：</p><pre><code>AddTwo PROC    push ebp    mov ebp, esp              ;堆栈帧的基址    mov eax, [ebp + 12]       ;第二个参数    add eax, [ebp + 8]        ;第一个参数 pop ebp    retAddTwo ENDP</code></pre><h4 id="显式的堆栈参数"><a href="#显式的堆栈参数" class="headerlink" title="显式的堆栈参数"></a>显式的堆栈参数</h4><p>若堆栈参数的引用表达式形如 [ebp+8]，则称它们为显式的堆栈参数 (explicit stack parameters)。这个名称的含义是：汇编代码显式地说明了参数的偏移量是一个常数。有些程序员定义符号常量来表示显式的堆栈参数，以使其代码更具易读性：</p><pre><code>y_param EQU [ebp + 12]x_param EQU [ebp + 8]AddTwo PROC    push ebp    mov ebp,esp    mov eax,y_param    add eax,x_param    pop ebp    retAddTwo ENDP</code></pre><h4 id="清除堆栈"><a href="#清除堆栈" class="headerlink" title="清除堆栈"></a>清除堆栈</h4><p>子程序返回时，必须将参数从堆栈中删除。否则将导致内存泄露，堆栈就会被破坏。例如，设如下语句在 main 中调用 AddTwo：</p><pre><code>push 6push 5call AddTwo</code></pre><p>假设 AddTwo 有两个参数留着堆栈中，下图所示为调用返回后的堆栈：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225174556211" alt="img"></p><p>main 部分试图忽略这个问题，并希望程序能正常结束。但是，如果循环调用 AddTwo，堆栈就会溢出。因为每次调用都会占用 12 字节的堆栈空间——每个参数需要 4 个字节，再加 4 个字节留给 CALL 指令的返回地址。如果在 main 中调用 Example1，而它又要调用 AddTwo 就会导致更加严重的问题：</p><pre><code>main PROC    call Example1    exitmain ENDPExample1 PROC    push 6    push 5    call AddTwo    ret                   ;堆栈被破坏了！Example1 ENDP</code></pre><p>当 Example1 的 RET 指令将要执行时，ESP 指向整数 5 而不是能将其带回 main 的返回地址：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225186412213" alt="img"></p><p>RET 指令把整数 5 加载到指令指针寄存器，尝试将控制转移到内存地址为 5 的位置。假设这个地址在程序代码边界之外，那么处理器将给出运行时异常，通知 OS 终止程序。</p><h2 id="常用32位编程调用规范简介"><a href="#常用32位编程调用规范简介" class="headerlink" title="常用32位编程调用规范简介"></a>常用32位编程调用规范简介</h2><p>C 语言发布的 C 调用规范，该语言用于 Unix 和 Windows。然后是 STDCALL 调用规范，它描述了调用 Windows API 函数的协议。这两种规范都很重要，因为在 C 和 C++ 程序中会调用汇编函数, 同时汇编语言程序也会调用大量的 Windows API 函数。</p><h3 id="C-调用规范"><a href="#C-调用规范" class="headerlink" title="C 调用规范"></a>C 调用规范</h3><p>C 调用规范用于 C 和 C++ 语言。子程序的参数按逆序入栈，因此，C 程序在调用如下函数时，先将 B 入栈，再将 A 入栈：</p><pre><code>AddTwo(A, B)</code></pre><p>C 调用规范用一种简单的方法解决了清除运行时堆栈的问题：程序调用子程序时，在 CALL 指令的后面紧跟一条语句使堆栈指针（ESP）加上一个数，该数的值即为子程序参数所占堆栈空间的总和。下面的例子在执行 CALL 指令之前，将两个参数（5 和 6）入栈：</p><pre><code>Example1 PROC    push 6    push 5    call AddTwo    add esp, 8        ;从堆栈移除参数    retExample1 ENDP</code></pre><p>因此，用 C/C++ 编写的程序在从子程序返回后，总是能把参数从堆栈中删除。</p><h3 id="STDCALL-调用规范"><a href="#STDCALL-调用规范" class="headerlink" title="STDCALL 调用规范"></a>STDCALL 调用规范</h3><p>另一种从堆栈删除参数的常用方法是使用名为 STDCALL 的规范。如下所示的 AddTwo 过程给 RET 指令添加了一个整数参数，这使得程序在返回到调用过程时，ESP 会加上数值 8。这个添加的整数必须与被调用过程参数占用的堆栈空间字节数相等：</p><pre><code>AddTwo PROC    push ebp    mov ebp,esp                   ;堆栈帧基址    mov eax, [ebp + 12 ]       ;第二个参数    add eax, [ebp + 8 ]        ;第一个参数    pop ebpret 8                           ;清除堆栈AddTwo ENDP</code></pre><p>要说明的是，STDCALL 与 C 相似，参数是按逆序入栈的。通过在 RET 指令中添加参数，STDCALL 不仅减少了子程序调用产生的代码量（减少了一条指令），还保证了调用程序永远不会忘记清除堆栈。</p><p>另一方面，C 调用规范则允许子程序声明不同数量的参数，主调程序可以决定传递多少个参数。C 语言的 printf 函数就是一个例子，它的参数数量取决于初始字符串参数中的格式说明符的个数：</p><pre><code>int x = 5;float y = 3.2;char z = 'Z';printf("Printing values: %d, %f, %c", xz y, z);</code></pre><p>C 编译器按逆序将参数入栈，被调用的函数负责确定要传递的实际参数的个数，然后依次访问参数。这种函数实现没有像给 RET 指令添加一个常数那样简便的方法来清除堆栈，因此，这个责任就留给了主调程序。</p><p>调用 32 位 Windows API 函数时，Irvine32 链接库使用的是 STDCALL 调用规范。Irvine64 链接库使用的是 x64 调用规范。</p><h3 id="保存和恢复寄存器"><a href="#保存和恢复寄存器" class="headerlink" title="保存和恢复寄存器"></a>保存和恢复寄存器</h3><p>通常，子程序在修改寄存器之前要将它们的当前值保存到堆栈。这是一个很好的做法，因为可以在子程序返回之前恢复寄存器的原始值。理想情况下，相关寄存器入栈应在设置 EBP 等于 ESP 之后，在为局部变量保留空间之前。这有利于避免修改当前堆栈参数的偏移量。</p><p>例如，假设如下过程 MySub 有一个堆栈参数。在 EBP 被设置为堆栈帧基址后，ECX 和 EDX 入栈，然后堆栈参数加载到 EAX：</p><pre><code>MySub PROC    push ebp                ;保存基址指针    mov ebp,esp             ;堆栈帧基址    push ecx    push edx                ;保存 EDX    mov eax,[ebp+8]         ;取堆栈参数    .    .    pop    edx               ;恢复被保存的寄存器    pop ecx    pop    ebp               ;恢复基址指针    ret                      ;清除堆栈MySub ENDP</code></pre><p>EBP 被初始化后，在整个过程期间它的值将保持不变。ECX 和 EDX 的入栈不会影响到已入栈参数与 EBP 之间的位移量，因为堆栈的增长位于 EBP 的下方，如下图所示。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225220131215" alt="img"></p><h2 id="汇编语言局部变量应用"><a href="#汇编语言局部变量应用" class="headerlink" title="汇编语言局部变量应用"></a>汇编语言局部变量应用</h2><p>高级语言中，在单一子程序内新建、使用和撤销的变量被称为局部变量 (local variable)。局部变量创建于运行时堆栈，通常位于基址指针 (EBP) 之下。</p><p>尽管不能在汇编时给它们分配默认值，但是能在运行时初始化它们。可以使用与 C 和 C++ 相同的方法在汇编语言中新建局部变量。</p><p>【示例】下面的 C++ 函数声明了局部变量 X 和 Y：</p><pre><code>void MySub(){    int X = 10;    int Y = 20;}</code></pre><p>如果这段代码被编译为机器语言，就能看出局部变量是如何分配的。每个堆栈项都默认为 32 位，因此，每个变量的存储大小都要向上取整保存为 4 的倍数。两个局部变量一共要保留 8 个字节：</p><table><thead><tr><th>变量</th><th>字节数</th><th>堆栈偏移量</th></tr></thead><tbody><tr><td>X</td><td>4</td><td>EBP-4</td></tr><tr><td>Y</td><td>4</td><td>EBP-8</td></tr></tbody></table><p>MySub 函数（在调试器中）的反汇编展示了 C++ 程序如何创建局部变量，以及如何从堆栈中删除它们。该例使用了 C 调用规则：</p><pre><code>MySub PROC    push ebp    mov ebp, esp    sub esp, 8                    ;创建局部变量    mov DWORD PTR [ebp-4],10      ; X    mov DWORD PTR [ebp-8],20      ; Y    mov esp, ebp                  ;从堆栈中删除局部变量    pop ebp    retMySub ENDP</code></pre><p>局部变量初始化后，函数的堆栈帧如下图所示。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225244311217" alt="img"></p><p>在结束前，函数通过将 EBP 的值赋给堆栈指针完成对其的重置，该操作的效果是把局部变量从堆栈中删除：</p><pre><code>mov esp, ebp        ;从堆栈中删除局部变量</code></pre><p>如果省略这一步，那么 POP EBP 指令将会把 EBP 设置为 20，而 RET 指令就会分支到内存地址 10 的位置，从而导致程序因出现处理器异常而终止。下面的 MySub 代码就是这种情况：</p><pre><code>MySub PROC    push ebp    mov ebp, esp    sub esp, 8                      ; 创建局部变量    mov DWORD PTR [ebp-4], 10    ; X    mov DWORD PTR [ebp-8], 20    ; Y    pop ebp    ret                             ; 返回到无效地址！MySub ENDP</code></pre><p>为了使程序更加易读，可以为每个局部变量的偏移量定义一个符号，然后在代码中使用这些符号：</p><pre><code>X_local EQU DWORD PTR [ebp-4]Y_local EQU DWORD PTR [ebp-8]MySub PROC    push ebp    mov ebp, esp    sub esp, 8              ; 为局部变量保留空间    mov X_local, 10         ; X    mov Y_local, 20         ; Y    mov esp, ebp            ;从堆栈中删除局部变量    pop ebp    rstMySub ENDP</code></pre><h2 id="汇编语言引用参数简介"><a href="#汇编语言引用参数简介" class="headerlink" title="汇编语言引用参数简介"></a>汇编语言引用参数简介</h2><p>引用参数通常是由过程用基址-偏移量寻址（从 EBP）方式进行访问。由于每个引用参数都是一个指针，因此，常常作为一个间接操作数放在寄存器中。例如，假设堆栈地址 [ebp+12] 存放了一个数组指针，则下述语句就把该指针复制到 ESP 中：</p><pre><code>mov esi, [ebp+12 ]  ;指向数组</code></pre><p>【示例】下面将要展示的 ArrayFill 过程用 16 位整数的伪随机序列来填充数组。它接收两个参数：数组指针和数组长度，第一个为引用传递，第二个为值传递。调用示例如下：</p><pre><code>.datacount = 100array WORD count DUP(?).codemain PROC    push OFFSET array    push COUNT    call ArrayFill</code></pre><p>在 ArrayFill 中，下面的代码为其开始部分，对堆栈帧指针（EBP）进行初始化：</p><pre><code>ArrayFill PROC       push ebp    mov ebp,esp</code></pre><p>现在，堆栈帧中包含了数组偏移量、数组长度（count）、返回地址以及被保存的 EBP：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225272487219" alt="img"></p><p>ArrayFill 保存了通用寄存器，检索参数并填充数组：</p><pre><code>ArrayFill PROC       push ebp    mov ebp,esp    pushad                ; 保存寄存器    mov esi,              ; 数组偏移量    mov ecx,[ebp+8]       ; 数组长度    cmp ecx,0             ; ECX == 0?    je L2                 ; 是: 跳过循环L1:    mov eax,10000h        ; 随机范围 0 - FFFFh    call RandomRange      ; 从链接库生成随机数    mov [esi],ax          ; 在数组中插入值    add esi,TYPE WORD     ; 指向下一个元素    loop L1L2:    popad                ; 恢复寄存器    pop ebp    ret 8                   ; 清除堆栈ArrayFill ENDP</code></pre><h2 id="汇编语言LEA指令：返回间接操作数的地址"><a href="#汇编语言LEA指令：返回间接操作数的地址" class="headerlink" title="汇编语言LEA指令：返回间接操作数的地址"></a>汇编语言LEA指令：返回间接操作数的地址</h2><p>LEA 指令返回间接操作数的地址。由于间接操作数中包含一个或多个寄存器，因此会在运行时计算这些操作数的偏移量。为了演示如何使用 LEA，现在来看下面的 C++ 程序，该程序声明了一个局部数组 myString，并引用它来分配数组值：</p><pre><code>void makeArray(){    char myString[30];    for ( int i = 0; i &lt; 30; i++ )        myString[i] = '*';}</code></pre><p>与之等效的汇编代码在堆栈中为 myString 分配空间，并将地址（间接操作数）赋给 ESI。虽然数组只有 30 个字节，但是 ESP 还是递减了 32 以对齐双字边界。注意如何使用 LEA 把数组地址分配给 ESI：</p><pre><code>makeArray PROC    push ebp    mov ebp,esp    sub esp, 32            ;myString 位于 EBP-30 的位置    lea esi, [ebp-30]      ;加载 myString 的地址    mov ecx, 30            ;循环计数器LI: mov BYTE PTR [esi]     ;填充一个位置    inc esi                ;指向下一个元素    loop LI                ;循环，直到 ECX=0    add esp, 32            ;删除数组(恢复ESP)    pop ebp    retmakeArray ENDP</code></pre><p>不能用 OFFSET 获得堆栈参数的地址，因为 OFFSET 只适用于编译时已知的地址。下面的语句无法汇编：</p><pre><code>mov esi,OFFSET [ebp-30 ]   ;错误</code></pre><h2 id="汇编语言ENTER和LEAVE指令：创建和结束堆栈帧"><a href="#汇编语言ENTER和LEAVE指令：创建和结束堆栈帧" class="headerlink" title="汇编语言ENTER和LEAVE指令：创建和结束堆栈帧"></a>汇编语言ENTER和LEAVE指令：创建和结束堆栈帧</h2><p>ENTER 指令为被调用过程自动创建堆栈帧。它为局部变量保留堆栈空间，把 EBP 入栈。具体来说，它执行三个操作：</p><ul><li><p>把 EBP 入栈 (push ebp)</p></li><li><p>把 EBP 设置为堆栈帧的基址 (mov ebp, esp)</p></li><li><p>为局部变量保留空间 (sub esp, numbytes)</p></li></ul><p>ENTER 有两个操作数：第一个是常数，定义为局部变量保存的堆栈空间字节数；第二个定义了过程的词法嵌套级。</p><pre><code>ENTER numbytes, nestinglevel</code></pre><p>这两个操作数都是立即数。Numbytes 总是向上舍入为 4 的倍数，以便 ESP 对齐双字边界。Nestinglevel 确定了从主调过程堆栈帧复制到当前帧的堆栈帧指针的个数。在示例程序中，nestinglevel 总是为 0。</p><p>【示例 1】下面的例子声明了一个没有局部变量的过程：</p><pre><code>MySub PROC   enter 0,0</code></pre><p>它与如下指令等效：</p><pre><code>MySub PROC   push ebp   mov ebp, esp</code></pre><p>【示例 2】ENTER 指令为局部变量保留了 8 个字节的堆栈空间：</p><pre><code>MySub PROC   enter 8,0</code></pre><p>它与如下指令等效：</p><pre><code>MySub PROC   push ebp   mov ebp,esp   sub esp,8</code></pre><p>下图为执行 ENTER 指令前后的堆栈示意图。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225291416221" alt="img"></p><p>如果要使用 ENTER 指令，那么强烈建议在同一个过程的结尾处同时使用 LEAVE 指令。否则，为局部变量保留的堆栈空间就可能无法释放。这将会导致 RET 指令从堆栈中弹出错误的返回地址。</p><h4 id="LEAVE-指令"><a href="#LEAVE-指令" class="headerlink" title="LEAVE 指令"></a>LEAVE 指令</h4><p>LEAVE 指令结束一个过程的堆栈帧。它反转了之前的 ENTER 指令操作：恢复了过程被调用时 ESP 和 EBP 的值。再次以 MySub 过程为例，现在可以编码如下：</p><pre><code>MySub PROC   enter 8,0   .   .   leave   retMySub ENDP</code></pre><p>下面是与之等效的指令序列，其功能是在堆栈中保存和删除 8 个字节的局部变量：</p><pre><code>MySub PROC   push ebp   mov ebp, esp   sub esp, 8   .   .   mov esp, ebp   pop ebp   retMySub ENDP</code></pre><h2 id="汇编语言LOCAL伪指令：声明一个或多个变量名"><a href="#汇编语言LOCAL伪指令：声明一个或多个变量名" class="headerlink" title="汇编语言LOCAL伪指令：声明一个或多个变量名"></a>汇编语言LOCAL伪指令：声明一个或多个变量名</h2><p>不难想象，Microsoft 创建 LOCAL 伪指令是作为 ENTER 指令的高级替补。LOCAL 声明一个或多个变量名，并定义其大小属性。（另一方面，ENTER 则只为局部变量保留一块未命名的堆栈空间。）如果要使用 LOCAL 伪指令，它必须紧跟在 PROC 伪指令的后面。</p><p>其语法如下所示：</p><p>LOCAL varlist</p><p>varlist 是变量定义列表，用逗号分隔表项，可选为跨越多行。每个变量定义采用如下格式：</p><p>label:type</p><p>其中，标号可以为任意有效标识符，类型既可以是标准类型（WORD、DWORD 等），也可以是用户定义类型。</p><p>【示例】MySub 过程包含一个局部变量 var1，其类型为 BYTE：</p><pre><code>MySub PROCLOCAL var1:BYTE</code></pre><p>BubbleSort 过程包含一个双字局部变量 temp 和一个类型为 BYTE 的 SwapFlag 变量：</p><pre><code>BubbleSort PROCLOCAL temp:DWORD, SwapFlag:BYTE</code></pre><p>Merge 过程包含一个类型为 PTR WORD 的局部变量 pArray，它是一个 16 位整数的指针：</p><pre><code>Merge PROCLOCAL pArray:PTR WORD</code></pre><p>局部变量 TempArray 是一个数组，包含 10 个双字。请注意用方括号显示数组大小：</p><pre><code>LOCAL TempArray[10]:DWORD</code></pre><h4 id="MASM-代码生成"><a href="#MASM-代码生成" class="headerlink" title="MASM 代码生成"></a>MASM 代码生成</h4><p>使用 LOCAL 伪指令时，查看 MASM 生成代码是有好处的。下面的过程 Example1 有一个双字局部变量：</p><pre><code>Example1 PROC    LOCAL temp:DWORD    mov eax,temp    retExample1 ENDP</code></pre><p>MASM 为 Example1 生成如下代码，展示了 ESP 怎样减去 4，以便为双字变量预留空间：</p><pre><code>push ebpmov ebp, espadd esp, OFFFFFFFCh     ;ESP 加 -4mov eax, [ebp-4]leaveret</code></pre><p>Example1 的堆栈帧示意图如下所示：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225312627223" alt="img"></p><h2 id="汇编语言Microsoft-x64调用规范简介"><a href="#汇编语言Microsoft-x64调用规范简介" class="headerlink" title="汇编语言Microsoft x64调用规范简介"></a>汇编语言Microsoft x64调用规范简介</h2><p>Microsoft 遵循固定模式实现 64 位编程中的参数传递和子程序调用，该模式被称为 Microsoft x64 调用规范（Microsoft x64 calling convention）。它既用于 C 和 C++ 编译器，也用于 Windows API库。</p><p>只有在要么调用 Windows 函数，要么调用 C 和 C++ 函数时，才需要使用这个调用规范。它的特点和要求如下所示：</p><p>\1) 由于地址长为 64 位，因此 CALL 指令把 RSP（堆栈指针）寄存器的值减去8。</p><p>\2) 第一批传递给子程序的四个参数依次存放于寄存器 RCX、RDX、R8 和 R9。因此，如果只传递一个参数，它就会被放入 RCX。如果还有第二个参数，它就会被放入 RDX，以此类推。其他参数按照从左到右的顺序入栈。</p><p>\3) 长度不足 64 位的参数不进行零扩展，因此，其高位的值是不确定的。</p><p>\4) 如果返回值的长度小于或等于 64 位，那么它必须放在 RAX 寄存器中。</p><p>\5) 主调者要负责在堆栈中分配至少 32 字节的影子空间，以便被调用的子程序可以选择将寄存器保存在这个区域中。</p><p>\6) 调用子程序时，堆栈指针（RSP）必须对齐 16 字节边界。CALL 指令将 8 字节的返回地址压入堆栈，因此，主调程序除了把堆栈指针减去 32 以便存放寄存器参数之外，还要减去8。</p><p>\7) 被调用子程序执行结束后，主调程序需负责从运行时堆栈中移除所有的参数和影子空间。</p><p>\8) 大于 64 位的返回值存放于运行时堆栈，由 RCX 指出其位置。</p><p>\9) 寄存器 RAX、RCX、RDX、R8、R9、R10 和 R11 常常被子程序修改，因此，如果主调程序想要保存它们的值，就应在调用子程序之前将它们入栈，之后再从堆栈弹出。</p><p>\10) 寄存器 RBX、RBP、RDI、RSI、R12、R13、R14 和 R15 的值必须由子程序保存。</p><h2 id="汇编语言递归及应用详解"><a href="#汇编语言递归及应用详解" class="headerlink" title="汇编语言递归及应用详解"></a>汇编语言递归及应用详解</h2><p>递归子程序（recursive subrountine）是指直接或间接调用自身的子程序。递归，调用递归子程序的做法，在处理具有重复模式的数据结构时，它是一个强大的工具。例如链表和各种类型的连接图，这些情况下，程序都需要追踪其路径。</p><h3 id="无限递归"><a href="#无限递归" class="headerlink" title="无限递归"></a>无限递归</h3><p>子程序对自身的调用是递归中最显而易见的类型。例如，下面的程序包含一个名为 Endless 的过程，它不间断地重复调用自身：</p><pre><code>;无限递归 (Endless, asm)INCLUDE Irvine32.inc.dataendlessStr BYTE "This recursion never stops",0.codemain PROC    call Endless    exitmain ENDPEndless PROC    mov edx,OFFSET endlessStr    call WriteString    call Endless    ret                           ;从不执行Endless ENDPEND main</code></pre><p>当然，这个例子没有任何实用价值。每次过程调用自身时，它会占用 4 字节的堆栈空间让 CALL 指令将返回地址入栈。RET 指令永远不会被执行，仅当堆栈溢出时，程序终止。</p><h3 id="递归求和"><a href="#递归求和" class="headerlink" title="递归求和"></a>递归求和</h3><p>实用的递归子程序总是包含终止条件。当终止条件为真时，随着程序执行所有挂起的 RET 指令，堆栈展开。举例说明，考虑一个名为 CalcSum 的递归过程，执行整数 1 到 n 的加法，其中 n 是通过 ECX 传递的输入参数。CalcSum 用 EAX 返回和数：</p><pre><code>;整数求和   (RecursiveSum. asm)INCLUDE Irvine32.inc.codemain PROC    mov  ecx,5          ; 计数值 = 5    mov  eax,0          ; 保存和数    call CalcSum        ; 计算和数L1:    call WriteDec    ; 显示 EAX    call Crlf           ; 换行    exitmain ENDP;--------------------------------------------------------CalcSum PROC; 计算整数列表的和数; 接收: ECX = 计数值; 返回: EAX = 和数;--------------------------------------------------------    cmp  ecx,0         ; 检查计数值    jz   L2            ; 若为零则推出    add  eax,ecx       ; 否则，与和数相加    dec  ecx           ; 计数值递减    call CalcSum       ; 递归调用L2:    retCalcSum ENDPEND Main</code></pre><p>CalcSum 的开始两行检查计数值，若 ECX=0 则退出该过程，代码就跳过了后续的递归调用。当第一次执行 RET 指令时，它返回到前一次对 CalcSum 的调用，而这个调用再返回到它的前一次调用，依序前推。</p><p>下表给出了 CALL 指令压入堆栈的返回地址（用标号表示），以及与之相应的 ECX（计数值）和 EAX（和数）的值。</p><table><thead><tr><th>入栈的返回地址</th><th>ECX的值</th><th>EAX的值</th><th>入栈的返回地址</th><th>ECX的值</th><th>EAX的值</th></tr></thead><tbody><tr><td>L1</td><td>5</td><td>0</td><td>L2</td><td>2</td><td>12</td></tr><tr><td>L2</td><td>4</td><td>5</td><td>L2</td><td>1</td><td>14</td></tr><tr><td>L2</td><td>3</td><td>9</td><td>L2</td><td>0</td><td>15</td></tr></tbody></table><p>即使是一个简单的递归过程也会使用大量的堆栈空间。每次过程调用发生时最少占用 4 字节的堆栈空间，因为要把返回地址保存到堆栈。</p><h3 id="计算阶乘"><a href="#计算阶乘" class="headerlink" title="计算阶乘"></a>计算阶乘</h3><p>递归子程序经常用堆栈参数来保存临时数据。当递归调用展开时，保存在堆栈中的数据就有用了。下面要查看的例子是计算整数 n 的阶乘。阶乘算法计算 n!，其中 n 是无符号整数。第一次调用 factorial 函数时，参数 n 就是初始数字。下面给出的是用 C/C++/Java 语法编写的代码：</p><pre><code>int function factorial(int n){    if(n == 0)        return 1;    else        return n * factorial(n-1);}</code></pre><p>假设给定任意 n，即可计算 n-1 的阶乘。这样就可以不断减少 n，直到它等于 0 为止。根据定义，0!=l。而回溯到原始表达式 n! 的过程，就会累积每次的乘积。比如计算 5! 的递归算法如下图所示，左列为算法递进过程，右列为算法回溯过程。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225333218225" alt="img"></p><p>【示例】下面的汇编语言程序包含了过程 Factorial，递归计算阶乘。通过堆栈把 n(0〜12 之间的无符号整数 ) 传递给过程 Factorial，返回值在 EAX 中。由于 EAX 是 32 位寄存器，因此，它能容纳的最大阶乘为 12!(479 001 600 )。</p><pre><code>; 计算阶乘 (Fact.asm)INCLUDE Irvine32.inc.codemain PROC    push 5                ; 计算 5!    call Factorial        ; 计算阶乘 (eax)    call WriteDec         ; 显示结果    call Crlf    exitmain ENDPFactorial PROC    push ebp    mov  ebp,esp    mov  eax,[ebp+8]       ; 获取 n    cmp  eax,0             ; n &lt; 0?    ja   L1                ; 是: 继续    mov  eax,1             ; 否: 返回0!的值 1    jmp  L2                ; 并返回主调程序L1:    dec  eax    push eax               ; Factorial(n-1)    call Factorial; 每次递归调用返回时; 都要执行下面的指令ReturnFact:    mov  ebx,[ebp+8]       ; 获取 n    mul  ebx               ; EDX:EAX = EAX*EBXL2:    pop  ebp            ; 返回 EAX    ret  4                 ; 清除堆栈Factorial ENDPEND main</code></pre><p>现在通过跟踪初始值 N=3 的调用过程，来更加详细地查看 Factorial。按照其说明中的记录，Factorial 用 EAX 寄存器返回结果：</p><pre><code>push 3call Factorial          ; EAX = 3!</code></pre><p>Factorial 过程接收一个堆栈参数 N 为初始值，以决定计算哪个数的阶乘。主调程序的返回地址由 CALL 指令自动入栈。Factorial 的第一个操作是把 EBP 入栈，以便保存主调程序堆栈的基址指针：</p><pre><code>Factorial PROC   push ebp</code></pre><p>之后，它必须把 EBP 设置为当前堆栈帧的起始地址：</p><pre><code>mov ebp resp</code></pre><p>现在，EBP 和 ESP 都指向栈顶，运行时堆栈的堆栈帧如下图所示。其中包含了参数 N、主调程序的返回地址和被保存的 EBP 值：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225348212227" alt="img"></p><p>由上图可知，要从堆栈中取出 N 并加载到 EAX，代码需要把 EBP 加 8 后进行基址-偏移量寻址：</p><pre><code>mov eax, [ebp+8]     ; 获取 n</code></pre><p>然后，代码检查基本情况 (base case)，即停止递归的条件。如果 N (EAX 当前值 ) 等于 0，函数返回 1，也就是 0! 的定义值。</p><pre><code>cmp   eax,0    ; n&gt;0   ?ja   L1         ; 是：继续mov   eax, 1    ; 否：返回o   !的结果1jmp   L2       ; 并返回主调程序</code></pre><p>由于当前 EAX 的值为 3，Factorial 将递归调用自身。首先，它从 N 中减去 1，并把新值入栈。该值作为参数传递给新调用的 Factorial:</p><pre><code>L1: dec eax   push eax        ; Factorial(n - 1)   call Factorial</code></pre><p>现在，执行转向 Factorial 的第一行，计算数值为 N 的新值：</p><pre><code>Factorial PROC   push ebp   mov ebp,esp</code></pre><p>运行时堆栈又包含了第二个堆栈帧，其中 N 等于 2：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225364070229" alt="img"></p><p>现在 N 的值为 2，将其加载到 EAX，并与 0 比较：</p><pre><code>mov eax, [ebp+8]     ;当前 N=2cmp   eax, 0             ; N 与 0 比较ja   L1            ;仍然大于0mov   eax, 1             ;不执行jmp   L2          ;不执行</code></pre><p>N 大于 0，因此，继续执行标号 L1。</p><p>大家可能已经注意到之前的 EAX，即第一次调用时分配给 Factorial 的值，被新值覆盖了。这说明了一个重要的事实：在过程进行递归调用时，应该小心注意哪些寄存器会被修改。如果需要保存这些寄存器的值，就需要在递归调用之前将其入栈，并在调用返回之后将其弹出堆栈。幸运的是，对 Factorial 过程而言，在递归调用之间保存 EAX 并不是必要的。</p><pre><code>执行 L1 时，将会用递归过程调用来计算 N-1 的阶乘。代码将 EAX 减 1，并将结果入栈，再调用 Factorial：L1: dec   eax           ; N = 1   push eax       ; Factorial(1)   call Factorial</code></pre><p>现在，第三次进入 Factorial，堆栈中也有了三个活动的堆栈帧：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225377869231" alt="img"></p><p>Factorial 程将 N 与 0 比较，发现 N 大于 0，则再次调用 Factorial，此时 N=0。当最后一次进入 Factorial 过程时，运行时堆栈出现了第四个堆栈帧：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225389165233" alt="img"></p><p>在 N=0 时调用 Factorial，情况变得有趣了。下面的语句产生了到标号 L2 的分支。由于 0! =1，因此数值 1 赋给 EAX，而 EAX 必须包含 Factorial 的返回值：</p><pre><code>mov eax,[ebp+8]     ; EAX = 0cmp eax,0          ; n &lt; 0?ja L1               ; 是: 继续mov eax,1          ; 否: 返回0!的值 1jmp L2             ; 并返回主调程序标号 L2 的语句如下，它使得 Factorial 返回到前一次的调用：L2: pop ebp           ; 返回 EAX   ret 4          ; 清除堆栈</code></pre><p>此时，如下图所示，最近的帧已经不在运行时堆栈中，且 EAX 的值为 1（零的阶乘）。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225411423235" alt="img"></p><p>下面的代码行是 Factorial 调用的返回点。它们获取 N 的当前值（保存于堆栈 EBP+8 的位置），将其与 EAX（Factorial 调用的返回值）相乘。那么，EAX 中的乘积就是 Factorial 本次迭代的返回值：</p><pre><code>ReturnFact:   mov ebx,[ebp+8]      ; 获取 n   mul ebx           ; EDX:EAX = EAX*EBXL2:   pop ebp               ; 返回 EAX   ret 4              ; 清除堆栈Factorial ENDP</code></pre><p>（EDX 中的乘积高位部分为全 0，可以忽略。）由此，上述代码行第一次得以执行，EAX 保存了表达式 1 x 1 的乘积。随着 RET 指令的执行，又一个堆栈帧从堆栈中删除：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225438512237" alt="img"></p><p>再次执行 CALL 指令后面的语句，将 N（现在等于 2）与 EAX 的值（等于 1）相乘：</p><pre><code>ReturnFact:   mov ebx,[ebp+8]      ; 获取 n   mul ebx           ; EDX:EAX = EAX*EBXL2:   pop ebp               ; 返回 EAX   ret 4             ; 清除堆栈Factorial ENDP</code></pre><p>EAX 中的乘积现在等于 2，RET 指令又从堆栈中移除一个堆栈帧：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225449995239" alt="img"></p><p>现在，最后一次执行 CALL 指令后面的语句，将 N（等于 3）与 EAX 的值（等于 2）相乘：</p><pre><code>ReturnFact:   mov ebx,[ebp+8]      ; 获取 n   mul ebx           ; EDX:EAX = EAX*EBXL2:   pop ebp               ; 返回 EAX   ret 4              ; 清除堆栈Factorial ENDP</code></pre><p>EAX 的返回值为 6，是 3! 的计算结果，也是第一次调用 Factorial 时希望进行的计算。当 RET 指令执行时，最后一个堆栈帧也从堆栈中移除。</p><h2 id="汇编语言INVOKE伪指令：将参数入栈并调用过程"><a href="#汇编语言INVOKE伪指令：将参数入栈并调用过程" class="headerlink" title="汇编语言INVOKE伪指令：将参数入栈并调用过程"></a>汇编语言INVOKE伪指令：将参数入栈并调用过程</h2><p>INVOKE 伪指令，只用于 32 位模式，将参数入栈（按照 MODEL 伪指令的语言说明符所指定的顺序）并调用过程。INVOKE 是 CALL 指令一个方便的替代品，因为，它用一行代码就能传递多个参数。常见语法如下：</p><pre><code>INVOKE procedureName [, argumentList]</code></pre><p>ArgumentList 是可选项，它用逗号分隔传递给过程的参数。例如，执行若干 PUSH 指令后调用 DumpArray 过程，使用 CALL 指令的形式如下：</p><pre><code>push TYPE arraypush LENGTHOF arraypush OFFSET arraycall DumpArray</code></pre><p>使用等效的 INVOKE 则将代码减少为一行，列表中的参数逆序排列（假设遵循 STDCALL 规范）：</p><pre><code>INVOKE DumpArray, OFFSET array, LENGTHOF array, TYPE array</code></pre><p>INVOKE 对参数数量几乎没有限制，每个参数也可以独立成行。下面的 INVOKE 语句包含了有用的注释：</p><pre><code>INVOKE DumpArray,     ;显示数组OFFSET array,          ;指向数组LENGTHOF array,             ;数组长度TYPE array             ;数组元素的大小类型参数类型如下表所示。</code></pre><table><thead><tr><th>类型</th><th>例子</th><th>类型</th><th>例子</th></tr></thead><tbody><tr><td>立即数</td><td>10, 3000h, Offset mylist, TYPE array</td><td>寄存器</td><td>eax, bl, edi</td></tr><tr><td>整数表达式</td><td>(10*20), COUNT</td><td>ADDR name</td><td>ADDR myList</td></tr><tr><td>变量</td><td>myLIst, array, my Word, myDword</td><td>OFFSET name</td><td>OFFSET myList</td></tr><tr><td>地址表达式</td><td>[myList+2], [ebx+esi]</td><td></td><td></td></tr></tbody></table><h4 id="覆盖-EAX-和-EDX"><a href="#覆盖-EAX-和-EDX" class="headerlink" title="覆盖 EAX 和 EDX"></a>覆盖 EAX 和 EDX</h4><p>如果向过程传递的参数小于 32 位，那么在将参数入栈之前，INVOKE 为了扩展参数常常会使得汇编器覆盖 EAX 和 EDX 的内容。有两种方法可以避免这种情况：</p><ul><li><p>其一，传递给 INVOKE 的参数总是 32 位的；</p></li><li><p>其二，在过程调用之前保存 EAX 和 EDX，在过程调用之后再恢复它们的值。</p></li></ul><h2 id="汇编语言ADDR运算符：传递指针参数"><a href="#汇编语言ADDR运算符：传递指针参数" class="headerlink" title="汇编语言ADDR运算符：传递指针参数"></a>汇编语言ADDR运算符：传递指针参数</h2><p>ADDR 运算符同样可用于 32 位模式，在使用 INVOKE 调用过程时，它可以传递指针参数。比如，下面的 INVOKE 语句给 FillArray 过程传递了 myArray 的地址：</p><pre><code>INVOKE FillArray, ADDR myArray</code></pre><p>传递给 ADDR 的参数必须是汇编时常数。下面的例子就是错误的：</p><pre><code>INVOKE mySub, ADDR [ebp+12 ]     ;错误</code></pre><p>ADDR 运算符只能与 INVOKE 一起使用，下面的例子也是错误的：</p><pre><code>mov esi, ADDR myArray             ;错误</code></pre><p>【示例】下例中的 INVOKE 伪指令调用 Swap，并向其传递了一个双字数组前两个元素的地址：</p><pre><code>.dataArray DWORD 20 DUP(?).code...INVOKE Swap,  ADDR Array,  ADDR [Array+4]</code></pre><p>假设使用 STDCALL 规范，那么汇编器生成的相应代码如下所示：</p><pre><code>push OFFSET Array+4push OFFSET Arraycall Swap</code></pre><h2 id="汇编语言PROC伪指令：过程定义"><a href="#汇编语言PROC伪指令：过程定义" class="headerlink" title="汇编语言PROC伪指令：过程定义"></a>汇编语言PROC伪指令：过程定义</h2><p>32 位模式中，PROC 伪指令基本语法如下所示：label PROC [attributes] [USES reglist], parameter_list</p><p>Label 是按照《LABEL伪指令》中说明的标识符规则、由用户定义的标号。Attributes 是指下述任一内容：</p><pre><code>[distance] [langtype] [visibility] [prologuearg]</code></pre><p>下表对这些属性进行了说明。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>distance</td><td>NEAR 或 FAR。指定汇编器生成的 RET 指令（RET 或 RETF）类型</td></tr><tr><td>langtype</td><td>指定调用规范（参数传递规范），如 C、PASCAL 或 STDCALL。能覆盖由 .MODEL 伪指令指定的语言</td></tr><tr><td>visibility</td><td>指明本过程对其他模块的可见性。选项包括 PRIVATE、PUBLIC （默认项）和 EXPORT。若可见性为 EXPORT，则链接器把过程名放入分段可执行文件的导出表。EXPORT 也使之具有了 PUBLIC 可见性</td></tr><tr><td>prologuearg</td><td>指定会影响开始和结尾代码生成的参数</td></tr></tbody></table><h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><p>PROC 伪指令允许在声明过程时，添加上用逗号分隔的参数名列表。代码实现可以用名称来引用参数，而不是计算堆栈偏移量，如 [ebp+8]:</p><pre><code>label PROC [attributes] [USES reglist],   parameter_1,   parameter_2,   ...   parameter_n</code></pre><p>如果参数列表与 PROC 在同一行，则 PROC 后面的逗号可以省略：</p><pre><code>label PROC [attributes], parameter_1, parameter_2, ..., parameter_n</code></pre><p>每个参数的语法如下：</p><pre><code>paramName: type</code></pre><p>ParamName 是分配给参数的任意名称，其范围只限于当前过程（称为局部作用域（local scope））。同样的参数名可以用于多个过程，但却不能作为全局变量或代码标号的名称。</p><p>Type 可以在这些类型中选择：BYTE、SBYTE、WORD、SWORD、DWORD、SDWORD、FWORD、QWORD 或 TBYTE。此外，type 还可以是限定类型（qualified type），如指向现有类型的指针。</p><p>下面是限定类型的例子：</p><pre><code>PTR BYTE     PTR SBYTEPTR WORD   PTR SWORDPTR DWORD   PTR SDWORDPTR QWORD   PTR TBYTE</code></pre><p>虽然可以在这些表达式中添加 NEAR 和 FAR 属性，但它们只与更加专用的应用程序相关。限定类型还能够用 TYPEDEF 和 STRUCT 伪指令创建。</p><p>【示例 1】AddTwo 过程接收两个双字数值，用 EAX 返回它们的和数：</p><pre><code>AddTwo PROC,    val1:DWORD,    val2:DWORD    mov eax,val1    add eax,val2    retAddTwo ENDP</code></pre><p>AddTwo 汇编时，MASM 生成的汇编代码显示了参数名是如何被转换为 EBP 偏移量的。由于使用的是 STDCALL，因此 RET 指令附加了一个常量操作数：</p><pre><code>AddTwo PROC    push ebp    mov ebp, esp    mov eax, dword ptr [ebp+8]    add eax, dword ptr [ebp+OCh]    leave    ret 8AddTwo ENDP</code></pre><p>用指令 ENTERO, 0 来代替下面的语句，AddTwo 过程也一样正确：</p><pre><code>push ebpmov ebp,esp</code></pre><p>【示例 2】FillArray 过程接收一个字节数组的指针：</p><pre><code>FillArray PROC,   pArray:PTR BYTE   ...FillArray ENDP</code></pre><p>【示例 3】Swap 过程接收两个双字指针：</p><pre><code>Swap PROC,    pValX:PTR DWORD,    pValY:PTR DWORDSwap ENDP</code></pre><p>【示例 4】Read_File 过程接收一个字节指针 pBuffer，有一个局部双字变量 fileHandle，并把两个寄存器保存入栈（EAX 和 EBX）：</p><pre><code>Read_File PROC USES eax ebx,   pBuffer:PTR BYTE   LOCAL fileHandle:DWORD   mov esi,pBuffer   mov fileHandle,eax   ...   retRead_File ENDP</code></pre><p>MASM 为 Read_File 生成的代码显示了在 EAX 和 EBX 入栈（由 USES 子句指定）前，如何为局部变量（fileHandle）预留堆栈空间：</p><pre><code>Read_File PROC    push ebp    mov ebp,esp    add esp, OFFFFFFFCh          ;创建 fileHandle    push eax                     ;保存 EAX    push ebx                     ;保存 EBX    mov esi, dword ptr [ebp+8]   ; pBuffer    mov dword ptr [ebp-4],eax    ; fileHandle    pop ebx    pop eax    leave    ret 4Read_File ENDP</code></pre><p>注意：尽管 Microsoft 没有采用这种方法，但 Read_File 生成代码的开始部分还可以是这样的：</p><pre><code>Read_File PROC   enter 4,0   push eax   (etc.)</code></pre><p>ENTER 指令首先保存 EBP，再将它设置为堆栈指针的值，并为局部变量保留空间。</p><h4 id="由-PROC-修改的-RET-指令"><a href="#由-PROC-修改的-RET-指令" class="headerlink" title="由 PROC 修改的 RET 指令"></a>由 PROC 修改的 RET 指令</h4><p>当 PROC 有一个或多个参数时，STDCALL 是默认调用规范。假设 PROC 有 n 个参数，MASM 将生成如下入口和出口代码：</p><pre><code>push ebpmov ebp,esp...leaveret (n*4)</code></pre><p>RET 指令中的常数是参数个数乘以 4 ( 因为每个参数都是一个双字 )。若使用了 INCLUDE Irvine32.inc，则 STDCALL 是默认规范，它是所有 Windows API 函数调用使用的调用规范。</p><h4 id="指定参数传递协议"><a href="#指定参数传递协议" class="headerlink" title="指定参数传递协议"></a>指定参数传递协议</h4><p>一个程序可以调用 Irvme32 链接库过程，反之，也可以包含能被 C++ 程序调用的过程。为了提供这样的灵活性，PROC 伪指令的属性域允许程序指定传递参数的语言规范，并且能覆盖 .MODEL 伪指令指定的默认语言规范。</p><p>下例声明的过程采用了 C 调用规范：</p><pre><code>Examplel PROC C,   parm1:DWORD, parm2:DWORD</code></pre><p>若用 INVOKE 执行 Examplel，汇编器将生成符合 C 调用规范的代码。同样，如果用 STDCALL 声明 Examplel，INVOKE 的生成代码也会符合这个语言规范：</p><pre><code>Examplel PROC STDCALL,   parm1:DWORD, parm2:DWORD</code></pre><h2 id="汇编语言PROTO伪指令：指定程序的外部过程"><a href="#汇编语言PROTO伪指令：指定程序的外部过程" class="headerlink" title="汇编语言PROTO伪指令：指定程序的外部过程"></a>汇编语言PROTO伪指令：指定程序的外部过程</h2><p>64 模式中，PROTO 伪指令指定程序的外部过程，示例如下：</p><pre><code>ExitProcess PROTO.codemov ecx, 0call ExitProcess</code></pre><p>然而在 32 位模式中，PROTO 是一个更有用的工具，因为它可以包含过程参数列表。可以说，PROTO 伪指令为现有过程创建了原型 (prototype)。原型声明了过程的名称和参数列表。它还允许在定义过程之前对其进行调用，并验证参数的数量和类型是否与过程的定义相匹配。</p><p>MASM 要求 INVOKE 调用的每个过程都有原型。PROTO 必须在 INVOKE 之前首先岀现。换句话说，这些伪指令的标准顺序为：</p><pre><code>MySub PROTO       ;过程原型.INVOKE MySub      ;过程调用.MySub PROC     ;过程实现..MySub ENDP</code></pre><p>还有一种情况也是可能的：过程实现可以出现在程序的前面，先于调用该过程的 INVOKE 语句。在这种情况下，PROC 就是它自己的原型：</p><pre><code>MySub PROC          ;过程定义..MySub ENDP.INVOKE MySub      ;过程调用</code></pre><p>假设已经编写了一个特定的过程，创建其原型也是很容易的，即复制 PROC 语句并做如下修改：</p><ul><li><p>将关键字 PROC 改为 PROTO。</p></li><li><p>如有 USES 运算符，则把该运算符连同其寄存器列表一起删除。</p></li></ul><p>比如，假设已经创建了 ArraySum 过程：</p><pre><code>ArraySum PROC USES esi ecx,    ptrArray:PTR DWORD,        ;指向数组    szArray:DWORD              ;数组大小;省略其余代码行……ArraySum ENDP</code></pre><p>下面是与之对应的 PROTO 声明：</p><pre><code>ArraySum PROTO,   ptrArray:PTR DWORD,     ;指向数组   szArray:DWORD          ;数组大小</code></pre><p>PROTO 伪指令可以覆盖 .MODEL 伪指令中的参数传递协议。但它必须与过程的 PROC 声明一致：</p><pre><code>Example1 PROTO C,   parm1:DWORD, parm2:DWORD</code></pre><h3 id="汇编时参数检查"><a href="#汇编时参数检查" class="headerlink" title="汇编时参数检查"></a>汇编时参数检查</h3><p>PROTO 伪指令帮助汇编器比较过程调用和过程定义的参数列表。但是这个错误检查没有如 C 和 <a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a> 语言中那样重要。相反，MASM 检查参数正确的数量，并在某些情况下，匹配实际参数和形式参数的类型。比如，假设 Sub1 的原型声明如下：</p><pre><code>Sub1 PROTO, p1:BYTE, p2:WORD, p3:PTR BYTE</code></pre><p>现在定义变量：</p><pre><code>.databyte_1 BYTE 10h.word_1 WORD 2000hword_2 WORD 3000hdword_1 DWORD 12345678h</code></pre><p>那么，下面是 Sub1 的一个有效调用：</p><pre><code>INVOKE Sub1, byte_1, word_1, ADDR byte_1</code></pre><p>MASM 为这个 INVOKE 生成的代码显示了参数按逆序压入堆栈：</p><pre><code>push 404000h                  ;指向 byte_1 的指针sub   esp, 2                    ;在栈项填充两个字节push word ptr ds:[00404001h]     ;word_1 的值mov   al, byte ptr ds:[00404000h]  ;byte_1 的值push eaxcall 00401071</code></pre><p>EAX 被覆盖，sub esp,2 指令填充接下来的两个堆栈单元，以扩展到 32 位。</p><h4 id="MASM-会检测的错误"><a href="#MASM-会检测的错误" class="headerlink" title="MASM 会检测的错误"></a>MASM 会检测的错误</h4><p>如果实际参数超过了形式参数声明的大小，MASM 就会产生一个错误：</p><pre><code>INVOKE Sub1, word_1, word_2, ADDR byte_1     ;参数 1 错误</code></pre><p>如果调用 Sub1 时参数个数太少或太多，则 MASM 会产生错误：</p><pre><code>INVOKE Sub1, byte_1, word_2               ;错误：参数个数太少INVOKE Sub1, byte_1,                      ;错误：参数个数太多   word_2, ADDR byte_1, word_2</code></pre><h4 id="MASM-不会检测的错误"><a href="#MASM-不会检测的错误" class="headerlink" title="MASM 不会检测的错误"></a>MASM 不会检测的错误</h4><p>如果实际参数的类型小于形式参数的声明，那么 MASM 不会检测出错误：</p><pre><code>INVOKE Sub1, byte_1, byte_1, ADDR byte_1</code></pre><p>相反，MASM 会把实际参数扩展为形式参数声明的类型大小。下面是 INVOKE 示例生成的代码，其中第二个实际参数 (byte_1) 入栈之前，在 EAX 中进行了扩展：</p><pre><code>push 404000h                  ;byte_1 的地址mov al,byte ptr ds:[00404000h]        ;byte_1movzx eax,al                   ;在 EAX 中扩展push eax                      ;入栈mov al,byte ptr ds:[00404000h]    ;byte_1 的值push eax                      ;入栈call 00401071                  ;调用 Sub1</code></pre><p>如果在想要传递指针时传递了一个双字，则不会检测出任何错误。当子程序试图把这个堆栈参数用作指针时，这种情况通常会导致一个运行时错误：</p><pre><code>INVOKE Sub1, byte_1, word_2, dword_1 ;无错误检出</code></pre><h3 id="ArraySum-示例"><a href="#ArraySum-示例" class="headerlink" title="ArraySum 示例"></a>ArraySum 示例</h3><p>过程用寄存器传递参数，现在，可以用 PROC 伪指令来声明堆栈参数：</p><pre><code>ArraySum PROC USES esi ecx,    ptrArray:PTR DWORD,                  ;指向数组    szArray:DWORD                        ;数组大小    mov esi, ptrArray                    ;数组地址    mov ecx, szArray                     ;数组大小    mov eax, 0                           ;和数清零    cmp ecx, 0                           ;数组长度=0?    je L2                                ;是：退出L1: add eax, [esi]                       ;将每个整数加到和数中    add esi, 4                           ;指向下一个整数    loop L1                              ;按数组大小重复L2: ret                                  ;和数保存在EAX中ArraySum ENDP</code></pre><p>INVOKE 语句调用 ArraySum，传递数组地址和元素个数：</p><pre><code>.dataarray DWORD 10000h, 20000h, 30000h, 40000h, 50000htheSum DWORD ?.codemain PROC    INVOKE ArraySum,        AD DR array,                     ;数组地址        LENGTHOF array                   ;元素个数    mov theSum, eax                      ;保存和数</code></pre><h2 id="汇编语言过程参数简介"><a href="#汇编语言过程参数简介" class="headerlink" title="汇编语言过程参数简介"></a>汇编语言过程参数简介</h2><p>过程参数一般按照数据在主调程序和被调用过程之间传递的方向来分类：</p><h4 id="1-输入类"><a href="#1-输入类" class="headerlink" title="1) 输入类"></a>1) 输入类</h4><p>输入参数是指从主调程序传递给过程的数据。被调用过程不会被要求修改相应的参数变量，即使修改了，其范围也只能局限在自身过程中。</p><h4 id="2-输出类"><a href="#2-输出类" class="headerlink" title="2) 输出类"></a>2) 输出类</h4><p>当主调程序向过程传递变量地址，就会产生输岀参数。过程用地址来定位变量，并为其分配数据。比如，Win32 控制台库中的 ReadConsole 函数，其功能为从键盘读入一个字符串。用户键入的字符由 ReadConsole 保存到缓冲区中，而主调程序传递的就是这个字符串缓冲区的指针：</p><pre><code>.databuffer BYTE 80 DUP(?)inputHandle DWORD ?.codeINVOKE ReadConsole, inputHandle, ADDR buffer,   (etc.)</code></pre><h4 id="3-输入输出类"><a href="#3-输入输出类" class="headerlink" title="3) 输入输出类"></a>3) 输入输出类</h4><p>输入输出参数与输出参数相同，只有一个例外：被调用过程预期参数引用的变量中会包含一些数据，并且能通过指针来修改这些变量。</p><p>【示例】下面的例子实现两个 32 位整数的交换。Swap 过程有两个输入输出参数 pValX 和 pValY，它们是交换数据的地址：</p><pre><code>; Swap 过程示例   (Swap.asm)INCLUDE Irvine32.incSwap PROTO, pValX:PTR DWORD, pValY:PTR DWORD.dataArray DWORD 10000h,20000h.codemain PROC    ; 显示交换前的数组    mov  esi,OFFSET Array    mov  ecx,2                     ; 计数值 = 2    mov  ebx,TYPE Array    call DumpMem                   ; 显示数组    INVOKE Swap,ADDR Array, ADDR [Array+4]    ; 显示交换后的数组    call DumpMem    exitmain ENDP;-------------------------------------------------------Swap PROC USES eax esi edi,    pValX:PTR DWORD,              ; 第一个整数的指针    pValY:PTR DWORD               ; 第二个整数的指针; 交换两个32位整数的值; 返回: 无;-------------------------------------------------------    mov esi,pValX                 ; 获得指针    mov edi,pValY    mov eax,[esi]                 ; 取第一个整数    xchg eax,[edi]                ; 与第二个数交换    mov [esi],eax                 ; PROC 在这里生成 RET 8    retSwap ENDPEND main</code></pre><p>Swap 程的两个参数 pValX 和 pValY 都是输入输出参数。它们的当前值要输入到过程，而它们的新值也会从过程输出。由于使用的 PROC 带有参数，汇编器把 Swap 过程末尾的 RET 指令改为 RET 8（假设调用规范是 STDCALL）。</p><h3 id="调试提示"><a href="#调试提示" class="headerlink" title="调试提示"></a>调试提示</h3><p>这里提醒编程者要注意的一些常见错误是汇编语言在传递过程参数时会遇到的，希望编程者永远不要犯这些错误。</p><h4 id="1-参数大小不匹配"><a href="#1-参数大小不匹配" class="headerlink" title="1) 参数大小不匹配"></a>1) 参数大小不匹配</h4><p>数组地址以其元素的大小为基础。比如，一个双字数组第二个元素的地址就是其起始地址加 4。假设调用 Swap 过程，并传递 DoubleArray 前两个元素的指针。如果错误地把第二个元素的地址计算为 DoubleArray+1，那么调用 Swap 后，DoubleArray 中的十六进制结果值也不正确：</p><pre><code>.dataDoubleArray DWORD 10000h,20000h.codeINVOKE Swap, ADDR [DoubleArray+0], ADDR [DoubleArray+1]2) 传递错误类型的指针</code></pre><p>在使用 INVOKE 时，要记住汇编器不会验证传递给过程的指针类型。例如，Swap 过程期望接收到两个双字指针，假若不小心传递的是指向字节的指针：</p><pre><code>.dataByteArray BYTE 10h,20h,30h,40h,50h,60h,70h,80h.codeINVOKE Swap, ADDR [ByteArray+0], ADDR [ByteArray+1]</code></pre><p>程序可以汇编运行，但是当 ESI 和 EDI 解引用时，就会交换两个 32 位数值。</p><h4 id="3-传递立即数"><a href="#3-传递立即数" class="headerlink" title="3) 传递立即数"></a>3) 传递立即数</h4><p>如果过程有一个引用参数，就不要向其传递立即数参数。考虑下面的过程，它只有一个引用参数：</p><pre><code>Sub2 PROC, dataPtr:PTR WORD    mov esi, dataPtr         ;获得地址    mov WORD PTR [esi], 0    ;解引用，分配零    retSub2 ENDP</code></pre><p>汇编下面的 INVOKE 语句将导致一个运行时错误。Sub2 过程接收 1000h 作为指针的值，并解引用到内存地址 1000h：</p><pre><code>INVOKE Sub2, 1000h</code></pre><p>上例很可能会导致一般性保护故障，因为内存地址1000h不大可能在该程序的数据段中。</p><h2 id="汇编语言WriteStackFrame过程：显示当前过程堆栈帧的内容"><a href="#汇编语言WriteStackFrame过程：显示当前过程堆栈帧的内容" class="headerlink" title="汇编语言WriteStackFrame过程：显示当前过程堆栈帧的内容"></a>汇编语言WriteStackFrame过程：显示当前过程堆栈帧的内容</h2><p>Irvine32 链接库有个很有用的过程 WriteStackFrame，用于显示当前过程堆栈帧的内容，其中包括过程的堆栈参数、返回地址、局部变量和被保存的寄存器。</p><p>该过程由太平洋路德大学 (Pacific Lutheran University) 的詹姆斯·布林克 (James Brink) 教授慷慨提供，原型如下：</p><pre><code>WriteStackFrame PROTO,   numParam:DWORD,        ;传递参数的数量   numLocalVal: DWORD,      ;双字局部变量的数量   numSavedReg: DWORD        ;被保存寄存器的数量</code></pre><p>下面的代码节选自WriteStackFrame的演示程序：</p><pre><code>main PROC    mov eax, 0EAEAEAEAh    mov ebx, 0EBEBEBEBh    INVOKE myProc, 1111h, 2222h ;传递两个整数参数    exitmain ENDPmyProc PROC USES eax ebx,    x: DWORD, y: DWORD    LOCAL a:DWORD, b:DWORD    PARAMS = 2    LOCALS = 2    SAVED_REGS = 2    mov a, 0AAAAh    mov b, 0BBBBh    INVOKE WriteStackFrame, PARAMS, LOCALS, SAVED_REGS</code></pre><p>该调用生成的输岀如下所示：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225562460241" alt="img"></p><p>还有一个过程名为 WriteStackFrameName，增加了一个参数，保存拥有该堆栈帧的过程名：</p><pre><code>WriteStackFrameName PROTO,   numParam:DWORD,                ;传递参数的数量   numLocalVal: DWORD,       ;双字局部变量的数量   numSavedReg: DWORD,         ;被保存寄存器的数量   procName:PTR BYTE        ;空字节结束的字符串</code></pre><p>Irvine32 链接库的源代码保存在安装目录的 \Examples\Lib32 子目录下，文件名为 Irvine32.asm。Irvine32 链接库安装文件下载（<a href="https://pan.baidu.com/s/1yQBqLbViAgs8mCImheCe6g" target="_blank" rel="noopener">https://pan.baidu.com/s/1yQBqLbViAgs8mCImheCe6g</a> 提取码:6kvk）获取。</p><h2 id="汇编语言多模块程序简述"><a href="#汇编语言多模块程序简述" class="headerlink" title="汇编语言多模块程序简述"></a>汇编语言多模块程序简述</h2><p>大型源文件难于管理且汇编速度慢，可以把单个文件拆分为多个子文件，但是，对其中任何子文件的修改仍需对所有的文件进行整体汇编。更好的方法是把一个程序按模块（module）（汇编单位）分割。每个模块可以单独汇编，因此，对一个模块源代码的修改就只需要重汇编这个模块。</p><p>链接器将所有汇编好的模块（OEJ 文件）组合为一个可执行文件的速度是相当快的，链接大量目标模块比汇编同样数量的源代码文件花费的时间要少得多。</p><p>新建多模块程序有两种常用方法：</p><ul><li><p>其一是传统方法，使用 EXTERN 伪指令，基本上它在不同的 x86 汇编器之间都可以进行移植。</p></li><li><p>其二是使用 Microsoft 的高级伪指令 INVOKE 和 PROTO，这能够简化过程调用，并隐藏一些底层细节。</p></li></ul><h4 id="隐藏和导出过程名"><a href="#隐藏和导出过程名" class="headerlink" title="隐藏和导出过程名"></a>隐藏和导出过程名</h4><p>默认情况下，MASM 使所有的过程都是 public 属性，即允许它们能被同一程序中任何其他模块调用。使用限定词 PRIVATE 可以覆盖这个属性：</p><pre><code>mySub PROC PRIVATE</code></pre><p>使过程为 private 属性，可以利用封装原则将过程隐藏在模块中，如果其他模块有相同过程名，就还需避免潜在的重名冲突。</p><h4 id="OPTION-PROC-PRIVAT-E-伪指令"><a href="#OPTION-PROC-PRIVAT-E-伪指令" class="headerlink" title="OPTION PROC:PRIVAT E 伪指令"></a>OPTION PROC:PRIVAT E 伪指令</h4><p>在源模块中隐藏过程的另一个方法是，把 OPTION PROC:PRIVATE 伪指令放在文件顶部。则所有的过程都默认为 private，然后用 PUBLIC 伪指令指明那些希望其可见的过程：</p><pre><code>OPTION PROC:PRIVATEPUBLIC mySub</code></pre><p>PUBLIC 伪指令用逗号分隔过程名：</p><pre><code>PUBLIC sub1, sub2, sub3</code></pre><p>或者，也可以单独指定过程为 public 属性：</p><pre><code>mySub PROC PUBLIC.mySub ENDP</code></pre><p>如果程序的启动模块使用了 OPTION PROC:PRIVATE，那么就应该将它（通常为 main）指定为 PUBLIC，否则操作系统加载器无法发现该启动模块。比如：</p><pre><code>main PROC PUBLIC</code></pre><h2 id="汇编语言EXTERN伪指令：调用外部过程"><a href="#汇编语言EXTERN伪指令：调用外部过程" class="headerlink" title="汇编语言EXTERN伪指令：调用外部过程"></a>汇编语言EXTERN伪指令：调用外部过程</h2><p>调用当前模块之外的过程时使用EXTERN伪指令，它确定过程名和堆栈帧大小。下面的示例程序调用了 sub1，它在一个外部模块中：</p><pre><code>INCLUDE Irvine32.incEXTERN sub1@0:PROC.codemain PROC    call subl@0    exitmain ENDPEND main</code></pre><p>当汇编器在源文件中发现一个缺失的过程时（由 CALL 指令指定），默认情况下它会产生错误消息。但是，EXTERN 伪指令告诉汇编器为该过程新建一个空地址。在链接器生成程序的可执行文件时再来确定这个空地址。</p><p>过程名的后缀 @n 确定了已声明参数占用的堆栈空间总量。如果使用的是基本 PROC 伪指令，没有声明参数，那么 EXTERN 中的每个过程名后缀都为 @0。若用扩展 PROC 伪指令声明一个过程，则每个参数占用 4 字节。假设现在声明的 AddTwo 带有两个双字参数：</p><pre><code>AddTwo PROC,   val1:DWORD,   val2:DWORD   ...AddTwo ENDP则相应的 EXTERN 伪指令为 EXTERN AddTwo@8 : PROC。或者，也可以用 PROTO 伪指令来代替 EXTERN：AddTwo PROTO,   val1:DWORD,   val2:DWORD</code></pre><h2 id="汇编语言跨模块使用变量和标号"><a href="#汇编语言跨模块使用变量和标号" class="headerlink" title="汇编语言跨模块使用变量和标号"></a>汇编语言跨模块使用变量和标号</h2><p>默认情况下，变量和符号对其包含模块是私有的（private）。可以使用 PUBLIC 伪指令输出指定过程名，如下所示：</p><pre><code>PUBLIC count, SYM1SYM1 = 10.datacount DWORD 0</code></pre><h3 id="访问外部变量和符号"><a href="#访问外部变量和符号" class="headerlink" title="访问外部变量和符号"></a>访问外部变量和符号</h3><p>使用 EXTERN 伪指令可以访问在外部过程中定义的变量和符号：</p><pre><code>EXTERN name:type</code></pre><p>对符号（由 EQU 和 = 定义）而言，type 应为 ABS。对变量而言，type 是数据定义属性，如 BYTE、WORD、DWORD 和 SDWORD，可以包含 PTR。例子如下：</p><pre><code>EXTERN one:WORD, two:SDWORD, three:PTR BYTE, four:ABS</code></pre><h3 id="使用带-EXTERNDEF-的-INCLUDE-文件"><a href="#使用带-EXTERNDEF-的-INCLUDE-文件" class="headerlink" title="使用带 EXTERNDEF 的 INCLUDE 文件"></a>使用带 EXTERNDEF 的 INCLUDE 文件</h3><p>MASM 中一个很有用的伪指令 EXTERNDEF 可以代替 PUBLIC 和 EXTERN。它可以放在文本文件中，并用 INCLUDE 伪指令复制到每个程序模块。比如，现在用如下声明定义文件 vars.inc：</p><pre><code>;var s.incEXTERNDEF count:DWORD, SYM1:ABS</code></pre><p>接着，新建名为 sub1.asm 的源文件，其中包含了 count 和 SYM1，以及一条用于把 vars.inc 复制到编译流中的 INCLUDE 语句。</p><pre><code>;sub1.asm.386.model flat,STDCALLINCLUDE vars.incSYM1 = 10.datacount DWORD 0END</code></pre><p>因为不是程序启动模块，因此 END 伪指令省略了程序入口标号，并且不用声明运行时堆栈。</p><p>现在再新建一个启动模块 main.asm，其中包含 vars.inc，并使用了 count 和 SYM1：</p><pre><code>; main.asm.386.model flat,stdcall.stack 4096ExitProcess proto, dwExitCode:dwordINCLUDE vars.inc.codemain PROC    mov count,2000h    mov eax,SYM1    INVOKE ExitProcess,0main ENDPEND main</code></pre><h2 id="汇编语言用Extern伪指令新建模块"><a href="#汇编语言用Extern伪指令新建模块" class="headerlink" title="汇编语言用Extern伪指令新建模块"></a>汇编语言用Extern伪指令新建模块</h2><h4 id="PromptForIntegers"><a href="#PromptForIntegers" class="headerlink" title="PromptForIntegers"></a>PromptForIntegers</h4><p>jprompt.asm 是 PromptForIntegers 过程的源代码文件。它显示提示要求用户输入三个整数，调用 Readlnt 获取数值，并将它们插入数组：</p><pre><code>;提示整数输入请求    (_prompt.asm)INCLUDE Irvine32.inc.code;--------------------------------PromptForIntegers PROC;提示用户为数组输入整数，并用;用户输入填充该数组。;接收：;    ptrPrompt:PTR BYTE    ;提示信息字符串;    ptrArray:PTR DWORD    ;数组指针;    arraySize:DWORD       ;数组大小;返回：无;--------------------------------arraySize EQU [ebp+16]ptrArray EQU [ebp+12]ptrPrompt EQU [ebp+8]    enter 0,0    pushad                     ;保存全部寄存器    mov ecx,arraySize    cmp    ecx,0               ;数据大小WO?    jle    L2                  ;是：退出    mov edx,ptrPrompt          ;提示信息的地址    mov esi,ptrArrayL1: call WriteString           ;显示字符串    call ReadInt               ;将整数读入EAX    call Crlf                  ;换行    mov [esi],eax              ;保存入数组    add esi,4                  ;下一个整数    loop L1L2: popad                      ;恢复全部寄存器    leave     ret 12                     ;恢复堆栈PromptForIntegers ENDPEND</code></pre><h4 id="ArraySum"><a href="#ArraySum" class="headerlink" title="ArraySum"></a>ArraySum</h4><p>_arraysum.asm 模块为 ArraySum 过程，计算数组元素之和，并用 EAX 返回计算结果：</p><pre><code>;ArraySumit程    (_arrysum.asm)INCLUDE Irvine32.inc.code;----------------------------------------------   ArraySum PROC;计算32位整数数组之和。;接收：;    ptrArray    ;数组指针;    arraySize    ;数组大小(DWROD);返回：EAX = 和数;----------------------------------------------   ptrArray EQU [ebp+8]arraySize EQU [ebp+12]    enter 0,0    push ecx                      ;EAX 不入栈    push esi    mov    eax, 0                 ;和数清零    mov    esi, ptrArray    mov    ecx,arraySize    cmp    ecx, 0                 ;数组大小WO?    jle    L2                     ;是：退出L1: add    eax, [esi]             ;将每个整数加到和数中    add    esi,4                  ;指向下一个整数    loop L1                       ;按数组大小重复L2: pop esi    pop ecx                       ;用EAX返回和数    leave    ret    8                      ;恢复堆栈ArraySum ENDPEND</code></pre><h4 id="DisplaySum"><a href="#DisplaySum" class="headerlink" title="DisplaySum"></a>DisplaySum</h4><p>_display.asm 模块为 DisplaySum 过程，显示标号和和数的结果：</p><pre><code>;DisplaySum 过程    (_display.asm)INCLUDE Irvine32.inc.code;-----------------------------------------DisplaySum PROC;在控制台显示和数。;接收：;    ptrPrompt      ;提示字符串的偏移量;    theSum         ;数组和数(DWROD);返回：无;-----------------------------------------theSum EQU [ebp+12]ptrPrompt EQU [ebp+8]    enter 0,0    push eax    push edx    mov edx,ptrPrompt                           ;提示字符串的指针    call WriteString    mov eax,theSum    call Writelnt                               ;显示 EAX    call Crlf    pop edx    pop eax    leave    ret 8                                        ;恢复堆栈DisplaySum ENDPEND</code></pre><h4 id="Startup-模块"><a href="#Startup-模块" class="headerlink" title="Startup 模块"></a>Startup 模块</h4><p>Sum_main.asm 模块为启动过程 (main)。其中的 EXTERN 伪指令指定了三个外部过程。为了使源代码更加友好，用 EQU 伪指令再次定义了过程名：</p><pre><code>ArraySum          EQU ArraySum@0PromptForIntegers EQU PromptForIntegers@0DisplaySum        EQU DisplaySum@0</code></pre><p>每次过程调用之前，用注释说明了参数顺序。该过程使用 STDCALL 参数传递规范：</p><pre><code>;整数求和过程(Sum_main.asm);多模块示例;本程序由用户输入多个整数，;将它们存入数组，计算数组之和，;并显示和数。INCLUDE Irvine32.incEXTERN PromptForIntegers@0:PROCEXTERN ArraySum@0:PROC, DisplaySum@0:PROC;为方便起见，重新定义外部符号ArraySum          EQU ArraySum@0PromptForIntegers EQU PromptForIntegers@0DisplaySum        EQU DisplaySum@0;修改 Count 来改变数组大小：Count = 3.dataprompt1 BYTE "Enter a signed integer: ",0prompt2 BYTE "The sum of the integers is: ",0array DWORD Count DUP(?)sum DWORD ?.codemain PROC    call Clrscr;PromptForIntegers (addr prompt1, addr array, Count)    push Count    push OFFSET array    push OFFSET prompt1    call PromptForIntegers;sum = ArraySum(addr array, Count)    push Count    push OFFSET array    call ArraySum    mov sum,eax;DisplaySum(addr prompt2, sum)    push sum    push OFFSET prompt2    call DisplaySum    call Crlf    exitmain ENDPEND main</code></pre><h2 id="汇编语言用INVOKE和PROTO新建模块"><a href="#汇编语言用INVOKE和PROTO新建模块" class="headerlink" title="汇编语言用INVOKE和PROTO新建模块"></a>汇编语言用INVOKE和PROTO新建模块</h2><p>32 位模式中，可以用 Microsoft 的 INVOKE、PROTO 和扩展 PROC 伪指令新建多模块程序。与更加传统的 CALL 和 EXTERN 相比，它们的主要优势在于：能够将 INVOKE 传递的参数列表与 PROC 声明的相应列表进行匹配。</p><p>现在用 INVOKE、PROTO 和高级 PROC 伪指令重新编写 ArraySum。为每个外部过程创建含有 PROTO 伪指令的头文件是很好的开始。每个模块都会包含这个文件 ( 用 INCLUDE 伪指令) 且不会增加任何代码量或运行时开销。</p><p>如果一个模块不调用特定过程，汇编器就会忽略相应的 PROTO 伪指令。</p><p>sum.inc 头文件本程序的 sum.inc 头文件如下所示：</p><pre><code>; (sum.inc)INCLUDE Irvine32.incPromptForIntegers PROTO,    ptrPrompt:PTR BYTE,        ; 提示字符串    ptrArray:PTR DWORD,        ; 数组指针    arraySize:DWORD            ; 数组大小ArraySum PROTO,    ptrArray:PTR DWORD,        ; 数组指针    arraySize:DWORD            ; 数组大小DisplaySum PROTO,    ptrPrompt:PTR BYTE,        ; 提示字符串    theSum:DWORD               ; 数组之和</code></pre><h4 id="prompt-模块"><a href="#prompt-模块" class="headerlink" title="_prompt 模块"></a>_prompt 模块</h4><p>_prompt.asm 文件用 PROC 伪指令为 PromptForIntegers 过程声明参数，用 INCLUDE 将 sum.inc 复制到本文件：</p><pre><code>; 提示整数输入请求          (_prompt.asm)INCLUDE sum.inc        ; 获得过程原型.code;-----------------------------------------------------PromptForIntegers PROC,  ptrPrompt:PTR BYTE,        ; 提示字符串  ptrArray:PTR DWORD,        ; 数组指针  arraySize:DWORD            ; 数组大小;; 提示用户输入数组元素值，并用用户输入; 填充数组; 返回：无;-----------------------------------------------------    pushad                 ; 保存所有寄存器    mov  ecx,arraySize    cmp  ecx,0             ; 数组大小 &lt;= 0?    jle  L2                ; 是: 退出    mov  edx,ptrPrompt     ; 提示信息的地址    mov  esi,ptrArrayL1:    call WriteString    ; 显示字符串    call ReadInt           ; 把整数读入EAX    call Crlf              ; 换行    mov  [esi],eax         ; 保存入数组    add  esi,4             ; 下一个整数    loop L1L2:    popad               ; 恢复所有寄存器    retPromptForIntegers ENDPEND与前面的 PromptForIntegers 版本比较，语句 enter 0，0 和 leave 不见了，这是因为当 MASM 遇到 PROC 伪指令及其声明的参数时，会自动生成这两条语句。同样，RET 指令也不需要自带常数参数了，PROC 会处理好。</code></pre><h4 id="arraysum-模块"><a href="#arraysum-模块" class="headerlink" title="_arraysum 模块"></a>_arraysum 模块</h4><p>接下来，_arraysum.asm 文件包含了 ArraySum 过程：</p><pre><code>; ArraySum 过程                 (_arrysum.asm)INCLUDE sum.inc.code;-----------------------------------------------------ArraySum PROC,    ptrArray:PTR DWORD,    ; 数组指针    arraySize:DWORD        ; 数组大小;; 计算 32 位整数数组之和; 返回:  EAX = 和数;-----------------------------------------------------    push ecx              ; EAX 不入栈    push esi    mov  eax,0            ; 和数清零    mov  esi,ptrArray    mov  ecx,arraySize    cmp  ecx,0            ; 数组大小 &lt;= 0?    jle  L2               ; 是: 退出L1:    add  eax,[esi]     ; 将每个整数加到和数中    add  esi,4            ; 指向下一个整数    loop L1               ; 按数组大小重复L2:    pop esi    pop ecx               ; 用 EAX 返回和数    retArraySum ENDPEND</code></pre><h4 id="display-模块"><a href="#display-模块" class="headerlink" title="_display 模块"></a>_display 模块</h4><p>_display.asm 文件包含了 DisplaySum 过程：</p><pre><code>; DisplaySum 过程        (_display.asm)INCLUDE Sum.inc.code;-----------------------------------------------------DisplaySum PROC,    ptrPrompt:PTR BYTE,    ; 提示字符串    theSum:DWORD           ; 数组之和;; 控制台显示和数; 返回：无;-----------------------------------------------------    push    eax    push    edx    mov    edx,ptrPrompt        ; 提示信息的指针    call    WriteString    mov    eax,theSum    call    WriteInt            ; 显示 EAX    call    Crlf    pop    edx    pop    eax    retDisplaySum ENDPEND</code></pre><h4 id="Sum-main-模块"><a href="#Sum-main-模块" class="headerlink" title="Sum_main 模块"></a>Sum_main 模块</h4><p>Sum_main.asm ( 启动模块 ) 包含主程序并调用所有其他的过程。它使用 INCLUDE 从 sum.inc 复制过程原型：</p><pre><code>; 整数求和程序         (Sum_main.asm)INCLUDE sum.incCount = 3.dataprompt1 BYTE  "Enter a signed integer: ",0prompt2 BYTE  "The sum of the integers is: ",0array   DWORD  Count DUP(?)sum     DWORD  ?.codemain PROC    call Clrscr    INVOKE PromptForIntegers, ADDR prompt1, ADDR array, Count    INVOKE ArraySum, ADDR array, Count    mov    sum,eax    INVOKE DisplaySum, ADDR prompt2, sum    call Crlf    exitmain ENDPEND main</code></pre><p>小结 本节与上一节《用Extern伪指令新建模块》展示了在 32 位模式中新建多模块程序的两种方法：</p><ul><li><p>第一种使用 的是更传统的EXTERN伪指令；</p></li><li><p>第二种使用的是INVOKE. PROTO和PROC的高级功能。</p></li></ul><p>后一种中的伪指令简化了很多细节，并为 Windows API 函数调用进行了优化。此外，它们还隐藏了一些细节，因此，编程者可能更愿意使用显式的堆栈参数和 CALL 及 EXTERN 伪指令。</p><h2 id="汇编语言使用USES运算符注意事项"><a href="#汇编语言使用USES运算符注意事项" class="headerlink" title="汇编语言使用USES运算符注意事项"></a>汇编语言使用USES运算符注意事项</h2><p>在《USES运算符》一节中列出了在过程开始保存、结尾恢复的寄存器名。汇编器自动为每个列出的寄存器生成相应的 PUSH 和 POP 指令。</p><p>但是必须注意的是：如果过程用常数偏移量访问其堆栈参数，比如 [ebp+8]，那么声明该过程时不能使用 USES 运算符。现在举例说明其原因。下面的 MySub1 过程用 USES 运算符保存和恢复 ECX 和 EDX：</p><pre><code>MySub1 PROC USES ecx edx   retMySub1 ENDP</code></pre><p>当 MASM 汇编 MySub1 时，生成代码如下：</p><pre><code>push ecxpush edxpop edxpop ecxret</code></pre><p>假设在使用 USES 的同时还使用了堆栈参数，如 MySub2 过程所示，该参数预期保存的堆栈地址为 EBP+8：</p><pre><code>MySub2 PROC USES ecx edx    push ebp                 ;保存基址指针    mov ebp, esp             ;堆栈帧基址    mov eax, [ebp+8]         ;取堆栈参数    pop ebp                  ;恢复基址指针    ret 4                    ;清除堆栈MySub2 ENDP</code></pre><p>则 MASM 为 MySub2 生成的相应代码如下：</p><pre><code>push ecxpush edxpush ebpmov ebp,espmov eax, dword ptr [ebp+8]   ;错误地址！pop ebppop edxpop ecxret 4</code></pre><p>由于汇编器在过程开头插入了 ECX 和 EDX 的 PUSH 指令，使得堆栈参数的偏移量发生变化，从而导致结果错误。</p><p>下图说明了为什么堆栈参数现在必须以［EBP+16］来引用。USES 在保存 EBP 之前修改了堆栈，破坏了子程序常用的标准开始代码。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225596555243" alt="img"></p><p>提示：前面介绍了 PROC 伪指令声明堆栈参数的高级语法。在那种情况下，USES 运算符不会带来问题。</p><h2 id="汇编语言向堆栈传递8位和16位参数"><a href="#汇编语言向堆栈传递8位和16位参数" class="headerlink" title="汇编语言向堆栈传递8位和16位参数"></a>汇编语言向堆栈传递8位和16位参数</h2><p>32 位模式中，向过程传递堆栈参数时，最好是压入 32 位操作数。虽然也可以将 16 位操作数入栈，但是这样会使得 EBP 不能对齐双字边界，从而可能导致出现页面失效、降低运行时性能。因此，在入栈之前，要把操作数扩展为 32 位。下面的 Uppercase 过程接收一个字符参数，并用 AL 返回其大写字母：</p><pre><code>Uppercase PROC    push ebp    mov ebp, esp    mov    al, [esp+8 ]          ;AL=字符    cmp    al, 'a'               ;小于'a' ?    jb L1                        ;是：什么都不做    cmp    al, 'z'               ;大于'z' ?    ja L1                        ;是：什么都不做    sub    al, 32                ;否：转换字符L1:    pop ebp    ret 4                        ;清除堆栈Uppercase ENDP</code></pre><p>当向 Uppercase 传递一个字母字符时，PUSH 指令自动将其扩展为 32 位：</p><pre><code>push 'x'call Uppercase</code></pre><p>如果传递的是字符变量就需要更小心一些，因为 PUSH 指令不允许操作数为 8 位：</p><pre><code>.datacharVal BYTE 'x'.codepush charVal                 ;语法错误！call Uppercase</code></pre><p>相反，要用 MOVZX 把字符扩展到 EAX：</p><pre><code>movzx eax,charVal             ;扩展并传送push eaxcall Uppercase</code></pre><h3 id="16-位参数示例"><a href="#16-位参数示例" class="headerlink" title="16 位参数示例"></a>16 位参数示例</h3><p>假设现在想向之前给出的 AddTwo 过程传递两个 16 位整数。由于该过程期望的数值为 32 位，所以下面的调用会发生错误：</p><pre><code>.dataword1 WORD 1234hword2 WORD 4111h.codepush word1push word2call AddTwo                    ;错误！</code></pre><p>因此，可以在每个参数入栈之前进行全零扩展。下面的代码将会正确调用 AddTwo：</p><pre><code>movzx eax,word1push eaxmovzx eax,word2push eaxcall AddTwo                    ; EAX 为和数</code></pre><p>一个过程的主调者必须保证它传递的参数与过程期望的参数是一致的。对堆栈参数而言，参数的顺序和大小都很重要！</p><h2 id="汇编语言32位模式下传递64位参数"><a href="#汇编语言32位模式下传递64位参数" class="headerlink" title="汇编语言32位模式下传递64位参数"></a>汇编语言32位模式下传递64位参数</h2><p>32 位模式中，通过堆栈向子程序传递 64 位参数时，先将参数的高位双字入栈，再将其低位双字入栈。这样就使得整数在堆栈中是按照小端顺序（低字节在低地址）存放的，因而子程序容易检索到这些数值，如同下面的 WriteHex64 过程操作一样。该过程用十六进制显示 64 位整数：</p><pre><code>WriteHex64 PROC    push ebp    mov ebp, esp    mov eax, [ebp+12]     ;高位双字    call WriteHex    mov eax, [ebp+8]      ;低位双字    call WriteHex    pop ebp    ret 8WriteHex64 ENDP</code></pre><p>WriteHex64 的调用示例如下，它先把 longVal 的高半部分入栈，再把 longVal 的低半部分入栈：</p><pre><code>.datalongVal QWORD 1234567800ABCDEFh.codepush DWORD PTR longVal + 4            ;高位双字push DWORD PTR longVal                ;低位双字call WriteHex64</code></pre><p>下图显示的是在 EBP 入栈，并把 ESP 复制给 EBP 之后，WriteHex64 的堆栈帧示意图。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225660422249" alt="img"></p><h2 id="汇编语言非双字局部变量"><a href="#汇编语言非双字局部变量" class="headerlink" title="汇编语言非双字局部变量"></a>汇编语言非双字局部变量</h2><p>在声明不同大小的局部变量时，LOCAL 伪指令的操作会变得很有趣。每个变量都按照其大小来分配空间：8 位的变量分配给下一个可用的字节，16 位的变量分配给下一个偶地址（字对齐），32 位变量分配给下一个双字对齐的地址。</p><p>现在来看几个例子。首先，Example 过程含有一个局部变量 var1，类型为 BYTE：</p><pre><code>Example1 PROC    LOCAL var1:byte    mov al,var1       ;[EBP-1]    retExample1 ENDP</code></pre><p>由于 32 位模式中，堆栈偏移量默认为 32 位，因此，var1 可能被认为会存放于 EBP-4 的位置。实际上，如下图所示，MASM 将 EBP 减去 4，但是却把 var1 存放在 EBP-1，其下面的三个字节并未使用（用 nu 标记，表示没有使用）。图中，每个方块表示一个字节。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225676744251" alt="img"></p><p>过程 Example2 含一个双字局部变量和一个字节局部变量：</p><pre><code>Example2 PROC   local temp:dword, SwapFlag:BYTE   ...   retExample2 ENDP</code></pre><p>汇编器为 Example2 生成的代码如下所示。ADD 指令将 ESP 加 -8，在 ESP 和 EBP 之间为这两个局部变量预留了空间：</p><pre><code>push ebpmov ebp, espadd esp,0FFFFFFF8h     ; ESP+（-8）mov eax,[ebp-4]        ; tempmov bl,[ebp-5]         ; SwapFlagleaveret</code></pre><p>虽然 SwapFlag 只是一个字节变量，但是 ESP 还是会下移到堆栈中下一个双字的位置。下图以字节为单位详细展示了堆栈的情况：SwapFlag 确切的位置以及位于其下方的三个没有使用的空间（用 nu 标记）。图中，每个方块表示一个字节。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225690104253" alt="img"></p><p>如果要创建超过几百字节的数组作为局部变量，那么一定要确保为运行时堆栈预留足够的空间。此时可以使用 STACK 伪指令。比如，在 Irvine32 链接库中，要预留 4096 个字节的堆栈空间：</p><pre><code>.stack 4096</code></pre><p>对嵌套调用来说，不论程序执行到哪一步，运行时堆栈都必须大到能够容纳下全部的活跃局部变量。比如在下面的代码中，Sub1 调用 Sub2，Sub2 调用 Sub3，每个过程都有一个局部数组变量：</p><pre><code>Sub1 PROClocal array1 [50]:dword       ; 200 字节callSub2...retSub1 ENDPSub2 PROClocal array2 [80]:word        ; 160 字节callSub3...retSub2 ENDPSub3 PROClocal array3 [300]:dword      ; 1200 字节...retSub3 ENDP</code></pre><p>当程序进入 Sub3 时，运行时堆栈中有来自 Sub1、Sub2 和 Sub3 的全部局部变量。那么堆栈总共需要：1560 个字节保存局部变量，加上两个过程的返回地址（8 字节），还要加上在过程中入栈的所有寄存器占用的空间。若过程为递归调用，则堆栈空间大约为其局部变量与参数总的大小乘以预计的递归次数。</p><h2 id="Java虚拟机（JVM）工作原理"><a href="#Java虚拟机（JVM）工作原理" class="headerlink" title="Java虚拟机（JVM）工作原理"></a>Java虚拟机（JVM）工作原理</h2><p>JVM 是基于堆栈机器的首选示例。JVM 用堆栈实现数据传送、算术运算、比较和分支操作，而不是用寄存器来保存操作数（如同 x86 一样）。</p><h3 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h3><p>Java 虚拟机（JVM）是执行已编译 Java 字节码的软件。它是 Java 平台的重要组成部分，包括程序、规范、库和数据结构，让它们协同工作。Java 字节码是指编译好的 Java 程序中使用的机器语言的名字。</p><p>JVM 执行的编译程序包含了 Java 字节码。每个 Java 源程序都必须编译为 Java 字节码（形式为 .class 文件）后才能执行。包含 Java 字节码的程序可以在任何安装了 Java 运行时软件的计算机系统上执行。</p><p>例如，一个 Java 源文件名为 Account.java，编译为文件 Account.class。这个类文件是该类中每个方法的字节码流。JVM 可能选择实时编译（just-in-time compilation）技术把类字节码编译为计算机的本机机器语言。</p><p>正在执行的 Java 方法有自己的堆栈帧存放局部变量、操作数栈、输入参数、返回地址和返回值。操作数区实际位于堆栈顶端，因此，压入这个区域的数值可以作为算术和逻辑运算的操作数，以及传递给类方法的参数。</p><p>在局部变量被算术运算指令或比较指令使用之前，它们必须被压入堆栈帧的操作数区域。通常把这个区域称为操作数栈（operand stack）。</p><p>Java 字节码中，每条指令包含 1 字节的操作码、零个或多个操作数。操作码可以用 Java 反汇编工具显示名字，如 iload、istore、imul 和 goto。每个堆栈项为 4 字节（32 位）。</p><h4 id="查看反汇编字节码"><a href="#查看反汇编字节码" class="headerlink" title="查看反汇编字节码"></a>查看反汇编字节码</h4><p>Java 开发工具包（JDK）中的工具 javap.exe 可以显示 java.class 文件的字节码，这个操作被称为文件的反汇编。命令行语法如下所示：</p><pre><code>javap -c classname</code></pre><p>比如，若类文件名为 Account.class，则相应的 javap 命令行为：</p><pre><code>javap -c Account</code></pre><p>安装 Java 开发工具包后，可以在 \bin 文件夹下找到 javap.exe 工具。</p><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><h4 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1) 基本数据类型"></a>1) 基本数据类型</h4><p>JVM 可以识别 7 种基本数据类型，如下表所示。和 x86 整数一样，所有有符号整数都是二进制补码形式。但它们是按照大端顺序存放的，即高位字节位于每个整数的起始地址（x86 的整数按小端顺序存放）。</p><table><thead><tr><th>数据类型</th><th>所占字节</th><th>格式</th><th>数据类型</th><th>所占字节</th><th>格式</th></tr></thead><tbody><tr><td>char</td><td>2</td><td>Unicode 字符</td><td>long</td><td>8</td><td>有符号整数</td></tr><tr><td>byte</td><td>1</td><td>有符号整数</td><td>float</td><td>4</td><td>IEEE 单精度实数</td></tr><tr><td>short</td><td>2</td><td>有符号整数</td><td>double</td><td>8</td><td>IEEE 双精度实数</td></tr><tr><td>int</td><td>4</td><td>有符号整数</td><td></td><td></td><td></td></tr></tbody></table><h4 id="2-比较指令"><a href="#2-比较指令" class="headerlink" title="2) 比较指令"></a>2) 比较指令</h4><p>比较指令从操作数栈的顶端弹出两个操作数，对它们进行比较，再把比较结果压入堆栈。现在假设操作数入栈顺序如下所示：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225714129255" alt="img"></p><p>下表给出了比较 op1 和 op2 之后压入堆栈的数值：</p><table><thead><tr><th>op1 和 op2 比较的结果</th><th>压入操作数栈的数值</th></tr></thead><tbody><tr><td>op1 &gt; op2</td><td>1</td></tr><tr><td>op1 = op2</td><td>0</td></tr><tr><td>op1 &lt; op2</td><td>-1</td></tr></tbody></table><p>dcmp 指令比较双字，fcmp 指令比较浮点数。</p><h4 id="3-分支指令"><a href="#3-分支指令" class="headerlink" title="3) 分支指令"></a>3) 分支指令</h4><p>分支指令可以分为有条件分支和无条件分支。Java 字节码中无条件分支的例子是 goto 和 jsr。</p><p>goto 指令无条件分支到一个标号：</p><pre><code>goto label</code></pre><p>jsr 指令调用用标号定义的子程序。其语法如下：</p><pre><code>jsr label</code></pre><p>条件分支指令通常检测从操作数栈顶弹出的数值。根据该值，指令决定是否分支到给定标号。比如，ifle 指令就是当弹出数值小于等于 0 时跳转到标号。其语法如下：</p><pre><code>ifle label</code></pre><p>同样，ifgt 指令就是当弹出数值大于等于 0 时跳转到标号。其语法如下：</p><pre><code>ifgt label</code></pre><h3 id="Java-反汇编示例"><a href="#Java-反汇编示例" class="headerlink" title="Java 反汇编示例"></a>Java 反汇编示例</h3><p>为了帮助理解 Java 字节码是如何工作的，本节将给出用 Java 编写的一些短代码例子。在这些例子中，请注意不同版本 Java 的字节码清单细节会存在些许差异。</p><p>【示例 1】两个整数相加</p><p>下面的 Java 源代码行实现两个整数相加，并将和数保存在第三个变量中：</p><pre><code>int A = 3;int B = 2;int sum = 0;sum = A + B;</code></pre><p>该 Java 代码的反汇编如下：</p><pre><code>iconst_3istore_0iconst_2istore_liconst_0istore_2iload_0iload_liaddistore_2</code></pre><p>每个编号行表示一条 Java 字节码指令的字节偏移量。本例中，可以发现每条指令都只占一个字节，因为指令偏移量的编号是连续的。</p><p>尽管字节码反汇编一般不包括注释，这里还是会将注释添加上去。虽然局部变量在运行时堆栈中有专门的保留区域，但是指令在执行算术运算和数据传送时还会使用另一个堆栈，即操作数栈。为了避免在这两个堆栈间产生混淆，将用索引值来指代变量位置，如 0、1、2 等。</p><p>现在来仔细分析刚才的字节码。开始的两条指令将一个常数值压入操作数栈，并把同一个值弹出到位置为 0 的局部变量：</p><pre><code>iconst_3 //常数（3）压入操作数栈istore_0 //弹出到局部变量0</code></pre><p>接下来的四行将其他两个常数压入操作数栈，并把它们弹岀到位置分别为 1 和 2 的局部变量：</p><pre><code>iconst_2 //常数（2）压入操作数栈istore_1 //弹出到局部变量1iconst_0 //常数（0）压入操作数栈istore_2 //弹出到局部变量2</code></pre><p>由于已经知道了该生成字节码的 Java 源代码，因此，很明显下表列出的是三个变量的位置索引：</p><table><thead><tr><th>位置索引</th><th>变量名</th></tr></thead><tbody><tr><td>0</td><td>A</td></tr><tr><td>1</td><td>B</td></tr><tr><td>2</td><td>sum</td></tr></tbody></table><p>接下来，为了实现加法，必须将两个操作数压入操作数栈。指令 iload_0 将变量 A 入栈，指令 iload_1 对变量 B 进行相同的操作：</p><pre><code>iload_0 // （A 入栈）iload_1 // （B 入栈）</code></pre><p>现在操作数栈包含两个数：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225740268257" alt="img"></p><p>这里并不关心这些例子的实际机器表示，因此上图中的运行时堆栈是向上生长的。每个堆栈示意图中的最大值即为栈顶。</p><p>指令 iadd 将栈顶的两个数相加，并把和数压入堆栈：</p><pre><code>iadd</code></pre><p>操作数栈现在包含的是 A、B 的和数：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225751057259" alt="img"></p><p>指令 istore_2 将栈顶内容弹出到位置为 2 的变量，其变量名为 sum：</p><pre><code>istore_2</code></pre><p>操作数栈现在为空。</p><p>【示例 2】两个 Double 类型数据相加</p><p>下面的 Java 代码片段实现两个 double 类型的变量相加，并将和数保存到 sum。它执行的操作与两个整数相加示例相同，因此这里主要关注的是整数处理与 double 处理的差异：</p><pre><code>double A = 3.1;double B = 2;double sum = A + B;</code></pre><p>本例的反汇编字节码如下所示，用 javap 实用程序可以在右边插入注释：</p><pre><code>ldc2_w #20; // double 3.Iddstore_0ldc2_w #22; // double 2.Oddstore_2dload_0dload_2dadddstore_4</code></pre><p>下面对这个代码进行分步讨论。偏移量为 0 的指令 ldc2_w 把一个浮点常数（3.1）从常数池压入操作数栈。ldc2 指令总是用两个字节作为常数池区域的索引：</p><pre><code>ldc2_w #20; // double 3.ld</code></pre><p>偏移量为 3 的 dstore 指令从堆栈弹出一个 double 数，送入位置为 0 的局部变量。该指令起始偏移量（3）反映出第一条指令占用的字节数（操作码加上两字节索引）：</p><pre><code>dstore_0 //保存到 A</code></pre><p>同样，接下来偏移量为 4 和 7 的两条指令对变量 B 进行初始化：</p><pre><code>ldc2_w #22; // double 2.Oddstore_2 // 保存到 B</code></pre><p>指令 dload_0 和 dload_2 把局部变量入栈，其索引指的是 64 位位置（两个变量栈项），因为双字数值要占用 8 个字节：</p><pre><code>dload_0dload_2接下来的指令（dadd）将栈顶的两个 double 值相加，并把和数入栈：dadd</code></pre><p>最后，指令 dstore_4 把栈顶内容弹出到位置为 4 的局部变量：</p><pre><code>dstore_4</code></pre><h3 id="JVM-条件分支"><a href="#JVM-条件分支" class="headerlink" title="JVM 条件分支"></a>JVM 条件分支</h3><p>了解 JVM 怎样处理条件分支是理解 Java 字节码的重要一环。比较操作总是从堆栈栈顶弹出两个数据，对它们进行比较后，再把结果数值入栈。条件分支指令常常跟在比较操作的后面，利用栈顶数值决定是否分支到目标标号。比如，下面的 Java 代码包含一个简单的 IF 语句，它将两个数值中的一个分配给一个布尔变量：</p><pre><code>double A = 3.0;boolean result = false;if( A &gt; 2.0 )result = false;elseresult = true;</code></pre><p>该 Java 代码对应的反汇编如下所示：</p><pre><code>ldc2_w #26; // double 3.Oddstore_0 // 弹出到 Aiconst_0 // false = 0istore_2 //保存到 resultdload_0ldc2_w #22; // double 2.0ddcmplifle 19     //如果 A ≤ 2.0,转到 19iconst_0 // falseistore_2 // result = falsegoto 21     //跳过后面两条语句iconst_l // trueistore_2 // result = true</code></pre><p>开始的两条指令将 3.0 从常数池复制到运行时堆栈，再把它从堆栈弹岀到变量 A：</p><pre><code>ldc2_w #26; // double 3.0ddstore_0 // 弹出至A</code></pre><p>接下来的两条指令将布尔值 false （等于 0）从常量区复制到堆栈，再把它弹出到变量 result：</p><pre><code>iconst_0 // false = 0istore_2 // 保存到 result</code></pre><p>A 的值（位置 0）压入操作数栈，数值 2.0 紧跟其后入栈：</p><pre><code>dload_0    //A 入栈ldc2_w #22; // double 2.0d</code></pre><p>操作数栈现在有两个数值：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225772467261" alt="img"></p><p>指令 dcmpl 将两个 double 数弹出堆栈进行比较。由于栈顶的数值（2.0）小于它下面的数值（3.0），因此整数 1 被压入堆栈。</p><pre><code>dcmpl</code></pre><p>如果从堆栈弹出的数值小于等于 0，则指令 ifle 就分支到给定的偏移量：</p><pre><code>ifle 19  //如果 stack.pop() &lt;= 0，转到 19</code></pre><p>这里要回顾一下之前给出的 Java 源代码示例，若 A&gt;2.0，其分配的值为 false：</p><pre><code>if( A &gt; 2.0 )    result = false;else    result = true;</code></pre><p>如果 A &lt;= 2.0，Java 字节码就把 IF 语句转向偏移量为 19 的语句，为 result 分配数值 true。与此同时，如果不发生到偏移量 19 的分支，则由下面几条指令把 false 赋给 result：</p><pre><code>iconst_0   // falseistore_2   // result = falsegoto 21    //跳过后面两条指令</code></pre><p>偏移量 16 的指令 goto 跳过后面两行代码，它们的作用是给 result 分配 true：</p><pre><code>iconst_l // trueistore_2 // result = true</code></pre><p>Java 虚拟机的指令集与 x86 处理器系列的指令集有很大的不同。它采用面向堆栈的方法实现计算、比较和分支，与 x86 指令经常使用寄存器和内存操作数形成了鲜明的对比。</p><p>虽然字节码的符号反汇编不如 x86 汇编语言简单，但是，编译器生成字节码也是相当容易的。每个操作都是原子的，这就意味着它只执行一个操作。</p><p>若 JVM 使用的是实时编译器，则 Java 字节码只要在执行前转换为本地机器语言即可。就这方面来说，Java 字节码与基于精简指令集（RISC）模型的机器语言有很多共同点。</p><h1 id="汇编语言字符串和数组"><a href="#汇编语言字符串和数组" class="headerlink" title="汇编语言字符串和数组"></a>汇编语言字符串和数组</h1><h2 id="汇编语言字符串基本指令简介"><a href="#汇编语言字符串基本指令简介" class="headerlink" title="汇编语言字符串基本指令简介"></a>汇编语言字符串基本指令简介</h2><p>x86 指令集有五组指令用于处理字节、字和双字数组。虽然它们被称为字符串原语 (string primitives)，但它们并不局限于字符数组。32 位模式中，下表中的每条指令都隐含使用 ESI、EDI，或是同时使用这两个寄存器来寻址内存。</p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>MOVSB、MOVSW、MOVSD</td><td>传送字符串数据：将 ESI 寻址的内存数据复制到 EDI 寻址的内存位置</td></tr><tr><td>CMPSB、CMPSW、CMPSD</td><td>比较字符串：比较分别由 ESI 和 EDI 寻址的内存数据</td></tr><tr><td>SCASB、SCASW、SCASD</td><td>扫描字符串：比较累加器 (AL、AX 或 EAX) 与 EDI 寻址的内存数据</td></tr><tr><td>STOSB、STOSW、STOSD</td><td>保存字符串数据：将累加器内容保存到 EDI 寻址的内存位置</td></tr><tr><td>LODSB、LODSW、LODSD</td><td>从字符串加载到累加器：将 ESI 寻址的内存数据加载到累加器</td></tr></tbody></table><p>根据指令数据大小，对累加器的引用隐含使用 AL、AX 或 EAX。字符串原语能高效执行，因为它们会自动重复并增加数组索引。</p><h4 id="使用重复前缀"><a href="#使用重复前缀" class="headerlink" title="使用重复前缀"></a>使用重复前缀</h4><p>就其自身而言，字符串基本指令只能处理一个或一对内存数值。如果加上重复前缀，指令就可以用 ECX 作计数器重复执行。重复前缀使得单条指令能够处理整个数组。下面为可用的重复前缀：</p><table><thead><tr><th>REP</th><th>ECX &gt; 0 时重复</th></tr></thead><tbody><tr><td>REPZ、REPE</td><td>零标志位置 1 且 ECX &gt; 0 时重复</td></tr><tr><td>REPNZ、REPNE</td><td>零标志位清零且 ECX &gt; 0 时重复</td></tr></tbody></table><p>【示例】复制字符串：下面的例子中，MOVSB 从 string1 传送 10 个字节到 string2。重复前缀在执行 MOVSB 指令之前，首先测试 ECX 是否大于 0。若 ECX=0，MOVSB 指令被忽略，控制传递到程序的下一行代码；若 ECX&gt;0，则 ECX 减 1 并重复执行 MOVSB 指令：</p><pre><code>cld                       ;清除方向标志位mov esi, OFFSET string1           ; ESI 指向源串mov edi, OFFSET string2      ; EDI 执行目的串mov ecx, 10                ;计数器赋值为10rep movsb                 ;传送io个字节</code></pre><p>重复 MOVSB 指令时，ESI 和 EDI 自动增加，这个操作由 CPU 的方向标志位控制。</p><h4 id="方向标志位"><a href="#方向标志位" class="headerlink" title="方向标志位"></a>方向标志位</h4><p>根据方向标志位的状态，字符串基本青令增加或减少 ESI 和 EDI 如下表所示。可以用 CLD 和 STD 指令显式修改方向标志位：</p><pre><code>CLD ;方向标志位清零（正向）STD ;方向标志位置 1（反向）</code></pre><table><thead><tr><th>方向标志位的值</th><th>对ESI和EDI的影响</th><th>地址顺序</th></tr></thead><tbody><tr><td>0</td><td>增加</td><td>低到高</td></tr><tr><td>1</td><td>减少</td><td>高到低</td></tr></tbody></table><p>在执行字符串基本指令之前，若忘记设置方向标志位会产生大麻烦，因为 ESI 和 EDI 寄存器可能无法按预期增加或减少。</p><h2 id="汇编语言MOVSB、MOVSW和MOVSD指令：将数据到EDI指向的内存"><a href="#汇编语言MOVSB、MOVSW和MOVSD指令：将数据到EDI指向的内存" class="headerlink" title="汇编语言MOVSB、MOVSW和MOVSD指令：将数据到EDI指向的内存"></a>汇编语言MOVSB、MOVSW和MOVSD指令：将数据到EDI指向的内存</h2><p>MOVSB、MOVSW 和 MOVSD 指令将数据从 ESI 指向的内存位置复制到 EDI 指向的内存位置。（根据方向标志位的值）这两个寄存器自动地增加或减少：</p><table><thead><tr><th>MOVSB</th><th>传送（复制）字节</th></tr></thead><tbody><tr><td>MOVSW</td><td>传送（复制）字</td></tr><tr><td>MOVSD</td><td>传送（复制）双字</td></tr></tbody></table><p>MOVSB、MOVSW 和 MOVSD 可以使用重复前缀。方向标志位决定 ESI 和 EDI 是否增加或减少。增加 / 减少的量如下表所示：</p><table><thead><tr><th>指令</th><th>ESI 和 EDI 增加或减少的数值</th></tr></thead><tbody><tr><td>MOVSB</td><td>1</td></tr><tr><td>MOVSW</td><td>2</td></tr><tr><td>MOVSD</td><td>4</td></tr></tbody></table><p>【示例】复制双字数组，假设现在想从 source 复制 20 个双字整数到 target。数组复制完成后，ESI 和 EDI 将分别指向两个数组范围之外的一个位置（即超出 4 字节）：</p><pre><code>.datasource DWORD 20 DUP(OFFFFFFFFh)target DWORD 20 DUP(?).codecld                     ;方向为正向mov ecx,LENGTHOF source ;设置 REP 计数器mov esi,OFFSET source   ;ES工指向 sourcemov edi,OFFSET target   ;ED工指向 targetrep novsd               ;复制双</code></pre><h2 id="汇编语言CMPSB、CMPSW和CMPSD指令：比较两个操作数"><a href="#汇编语言CMPSB、CMPSW和CMPSD指令：比较两个操作数" class="headerlink" title="汇编语言CMPSB、CMPSW和CMPSD指令：比较两个操作数"></a>汇编语言CMPSB、CMPSW和CMPSD指令：比较两个操作数</h2><p>CMPSB、CMPSW 和 CMPSD 指令比较 ESI 指向的内存操作数与 EDI 指向的内存操作数：</p><table><thead><tr><th>CMPSB</th><th>比较字节</th></tr></thead><tbody><tr><td>CMPSW</td><td>比较字</td></tr><tr><td>CMPSD</td><td>比较双字</td></tr></tbody></table><p>CMPSB、CMPSW 和 CMPSD 可以使用重复前缀。方向标志位决定 ESI 和 EDI 的增加或减少。</p><p>【示例】比较双字，假设现在想用 CMPSD 比较两个双字。下例中，source 的值小于 target，因此 JA 指令不会跳转到标号 L1。</p><pre><code>.datasource DWORD 1234htarget DWORD 5678h.codemov esi,OFFSET sourcemov edi,OFFSET targetcmpsd                 ;比较双字ja L1                 ;若 source &gt; target 则跳转</code></pre><p>比较多个双字时，清除方向标志位（正向），ECX 初始化为计数器，并给 CMPSD 添加重复前缀：</p><pre><code>mov esi,OFFSET sourcemov edi,OFFSET targetcld                       ;方向为正向mov ecx,LENGTHOF source   ;设置重复计数器repe cmpsd                ;相等则重复</code></pre><p>REPE 前缀重复比较操作，并自动增加 ESI 和 EDI，直到 ECX 等于 0，或者发现了一对不相等的双字。</p><h2 id="汇编语言SCASB、SCASW和SCASD指令：在字符串或数组中寻找一个值"><a href="#汇编语言SCASB、SCASW和SCASD指令：在字符串或数组中寻找一个值" class="headerlink" title="汇编语言SCASB、SCASW和SCASD指令：在字符串或数组中寻找一个值"></a>汇编语言SCASB、SCASW和SCASD指令：在字符串或数组中寻找一个值</h2><p>SCASB、SCASW 和 SCASD 指令分别将 AL/AX/EAX 中的值与 EDI 寻址的一个字节 / 字 / 双字进行比较。这些指令可用于在字符串或数组中寻找一个数值。结合 REPE（或 REPZ）前缀，当 ECX &gt; 0 且 AL/AX/EAX 的值等于内存中每个连续的值时，不断扫描字符串或数组。</p><p>REPNE 前缀也能实现扫描，直到 AL/AX/EAX 与某个内存数值相等或者 ECX = 0。</p><p>扫描是否有匹配字符下面的例子扫描字符串 alpha，在其中寻找字符 F。如果发现该字符，则 EDI 指向匹配字符后面的一个位置。如果未发现匹配字符，则 JNZ 执行退出：</p><pre><code>.dataalpha BYTE "ABCDEFGH",0.codemov edi,OFFSET alpha        ;ED工指向字符串mov al, 'F'                 ;检索字符Fmov ecx,LENGTHOF alpha      ;设置检索计数器cld                         ;方向为正向repne seasb                 ;不相等则重复jnz quit                    ;若未发现字符则退出dec edi                     ;发现字符：EDI 减 1</code></pre><p>循环之后添加了 JNZ 以测试由于 ECX=0 且没有找到 AL 中的字符而结束循环的可能性。</p><h2 id="汇编语言STOSB、STOSW和STOSD指令：把AL-AX-EAX的内容存储到EDI指向的内存单元中"><a href="#汇编语言STOSB、STOSW和STOSD指令：把AL-AX-EAX的内容存储到EDI指向的内存单元中" class="headerlink" title="汇编语言STOSB、STOSW和STOSD指令：把AL/AX/EAX的内容存储到EDI指向的内存单元中"></a>汇编语言STOSB、STOSW和STOSD指令：把AL/AX/EAX的内容存储到EDI指向的内存单元中</h2><p>STOSB、STOSW 和 STOSD 指令分别将 AL/AX/EAX 的内容存入由 EDI 中偏移量指向的内存位置。EDI 根据方向标志位的状态递增或递减。</p><p>与 REP 前缀组合使用时，这些指令实现用同一个值填充字符串或数组的全部元素。例如，下面的代码就把 string1 中的每一个字节都初始化为 OFFh：</p><pre><code>.dataCount = 100string1 BYTE Count DUP(?).codemov al, OFFh              ;要保存的数值mov edi,OFFSET string1       ;ED：［指向目标字符串mov ecx,Count              ;字符计数器cld                          ;方向为正向rep stosb                  ;用 AL 的内容实现填充</code></pre><h2 id="汇编语言LODSB、LODSW和LODSD指令：加载一个字节或字"><a href="#汇编语言LODSB、LODSW和LODSD指令：加载一个字节或字" class="headerlink" title="汇编语言LODSB、LODSW和LODSD指令：加载一个字节或字"></a>汇编语言LODSB、LODSW和LODSD指令：加载一个字节或字</h2><p>LODSB、LODSW 和 LODSD 指令分别从 ESI 指向的内存地址加载一个字节或一个字到 AL/AX/EAX。ESI 按照方向标志位的状态递增或递减。</p><p>LODS 很少与 REP 前缀一起使用，原因是，加载到累加器的新值会覆盖其原来的内容。相对而言，LODS常常被用于加载单个 数值。在后面的例子中，LODSB代替了如下两条指令（假设方向标志位清零）：</p><pre><code>mov al, ［esi］   ;将字节送入ALinc esi   ;指向下一个字节</code></pre><p>【示例】数组乘法，下面的程序把一个双字数组中的每个元素都乘以同一个常数。程序同时 使用了 LODSD 和 STOSD：</p><pre><code>;数组乘法    （Mult.asm）;本程序将一个32位整数数组中的每个元素都乘以一个常数。INCLUDE Irvine32.inc.dataarray DWORD 1,2,3,4,5,6,7,8,9,10    ;测试数据mug" 0W0RD -10.codemain PROC    cld                             ;方向为正向    mov esi,OFFSET array            ;源数组索引    itqv edi,esi                    ;目标数组索引    mov ecx,LENGTHOF array          ;循环计数器L1: lodsd                           ;将 [ESI] 加载到 EAXmul multiplier                      ;与常数相乘stosd                               ;将 EAX 保存到［EDI］loop L1exitmain ENDPEND main</code></pre><h2 id="汇编语言Irvine32字符串过程详解"><a href="#汇编语言Irvine32字符串过程详解" class="headerlink" title="汇编语言Irvine32字符串过程详解"></a>汇编语言Irvine32字符串过程详解</h2><p> Irvine32 链接库中的几个过程来处理空字节结束的字符串。这些过程与标准 C 库中的函数有着明显的相似性：</p><pre><code>;将源串复制到目的串。Str_copy PROTO,   source:PTR BYTE,   target:PTR BYTE;用 EAX 返回串长度（包括零字节）。Str_length PROTO,   pString:PTR BYTE;比较字符串 1 和字符串 2。;并用与 CMP 指令相同的方法设置零标志位和进位标志位。Str_compare PROTO,   string1:PTR BYTE,   string2:PTR BYTE;从字符串尾部去掉特定的字符。;第二个参数为要去除的字符。Str_trim PROTO,   pString:PTR BYTE,   char:BYTE;将字符串转换为大写。Str_ucase PROTO,   pString:PTR BYTE</code></pre><h3 id="Str-compare-过程"><a href="#Str-compare-过程" class="headerlink" title="Str_compare 过程"></a>Str_compare 过程</h3><p>Str_compare 过程比较两个字符串，其调用格式如下：</p><pre><code>INVOKE Str_compare, ADDR string1, ADDR string2</code></pre><p>它从第一个字节开始按正序比较字符串。这种比较是区分大小写的，因为字母的大写和小写 ASCII 码不相同。该过程没有返回值，若参数为 string1 和 string2，则进位标志位和零标志位的含义如下表所示。</p><table><thead><tr><th>关系</th><th>进位标志位</th><th>零标志位</th><th>为真则分支（指令）</th></tr></thead><tbody><tr><td>string1 &lt; string2</td><td>1</td><td>0</td><td>JB</td></tr><tr><td>string1 = string2</td><td>0</td><td>1</td><td>JE</td></tr><tr><td>string1 &gt; string2</td><td>0</td><td>0</td><td>JA</td></tr></tbody></table><p>回顾《CMP指令》一节中 CMP 指令如何设置进位标志位和零标志位。下面给出了 Str_compare 过程的代码清单。</p><pre><code>;--------------------------------------Str_compare PROC USES eax edx esi edi,    string1:PTR BYTE,    string2:PTR BYTE;比较两个字符串。;无返回值，但是零标志位和进位标志位受到的影响与 CMP 指令相同。;--------------------------------------    mov esi, string1    mov edi, string2L1: mov al, [esi]    mov dl, [edi]    cmp al, 0            ; string1 结束？    jne L2               ; 否    cmp dl, 0            ; 是：string2 结束？    jne L2               ; 否    jmp L3               ; 是，退出且ZF=1L2: inc esi              ; 指向下一个字符    inc edi              ; 字符相等？    cmp al,dl            ; 是：继续循环    je L1L3: ret                  ; 否：退出并设置标志位Str_compare ENDP</code></pre><p>实现 Str_compare 时也可以使用 CMPSB 指令，但是这条指令要求知道较长字符串的长度，这样就需要调用 Str_length 程两次。</p><p>本例中，在同一个循环内检测两个字符串的零结束符显得更加容易。CMPSB 在处理长度已知的大型字符串或数组时最有效。</p><h3 id="Str-length-过程"><a href="#Str-length-过程" class="headerlink" title="Str_length 过程"></a>Str_length 过程</h3><p>Str_length 过程用 EAX 返回一个字符串的长度。调用该过程时，要传递字符串的偏移地址。例如：</p><pre><code>INVOKE Str_length, ADDR myString</code></pre><p>过程实现如下：</p><pre><code>Str_length PROC USES edi,    pString:PTR BYTE       ;指向字符串    mov edi, pString       ;字符计数器    mov eax, 0             ;字符结束？L1: cmp BYTE PTR[edi],0    je L2                  ;是：退出    inc edi                ;否：指向下一个字符    inc eax                ;计数器加1    jmp L1L2: retStr_length ENDP</code></pre><h3 id="Str-copy-过程"><a href="#Str-copy-过程" class="headerlink" title="Str_copy 过程"></a>Str_copy 过程</h3><p>Str_copy 过程把一个空字节结束的字符串从源地址复制到目的地址。调用该过程之前，要确保目标操作数能够容纳被复制的字符串。Str_copy 的调用语法如下：</p><pre><code>INVOKE Str_copy, ADDR source, ADDR target</code></pre><p>过程无返回值。下面是其实现：</p><pre><code>;--------------------------------------Str_copy PROC USES eax ecx esi edi,    source:PTR BYTE,       ; source string    target:PTR BYTE        ; target string;将字符串从源串复制到目的串。;要求：目标串必须有足够空间容纳从源复制来的串。;--------------------------------------    INVOKE Str_length, source      ;EAX = 源串长度    mov ecx, eax                   ;重复计数器    inc    ecx                     ;由于有零字节，计数器加 1    mov esi, source    mov edi, target    cld                            ;方向为正向    rep    movsb                   ;复制字符串    retStr_copy ENDP</code></pre><h3 id="Str-trim-过程"><a href="#Str-trim-过程" class="headerlink" title="Str_trim 过程"></a>Str_trim 过程</h3><p>Str_trim 程从空字节结束字符串中移除所有与选定的尾部字符匹配的字符。其调用语法如下：</p><pre><code>INVOKE Str_trim, ADDR string, char_to_trim</code></pre><p>这个过程的逻辑很有意思，因为程序需要检查多种可能的情况（以下用 # 作为尾部字符）：</p><p>\1) 字符串为空。</p><p>\2) 字符串一个或多个尾部字符的前面有其他字符，如“Hello#”。</p><p>\3) 字符串只含有一个字符，且为尾部字符，如“#”。</p><p>\4) 字符串不含尾部字符，如“Hello”或“H”。</p><p>\5) 字符串在一个或多个尾部字符后面跟随有一个或多个非尾部字符，如“#H”或“##Hello”</p><p>使用 Str_trim 过程可以删除字符串尾部的全部空格（或者任何重复的字符）。从字符串中去掉字符的最简单的方法是，在想要移除的字符前面插入一个空字节。空字节后面的任何字符都会变得无意义。</p><p>下表列出了一些有用的测试例子。在所有例子中都假设从字符串中删除的是 # 字符，表中给出了期望的输出。</p><table><thead><tr><th>输入字符串</th><th>预期修改后的字符串</th></tr></thead><tbody><tr><td>“Hello##”</td><td>“Hello”</td></tr><tr><td>“#”</td><td>“”（空字符串）</td></tr><tr><td>“Hello”</td><td>“Hello”</td></tr><tr><td>“H”</td><td>“H”</td></tr><tr><td>“#H”</td><td>“#H”</td></tr></tbody></table><p>现在来看看测试 Str_trim 程的代码。INVOKE 语句向 Str_trim 传递字符串地址：</p><pre><code>.datastring_1 BYTE "Hello##",0.codeINVOKE Str_trim,ADDR string_1,'#'INVOKE ShowString,ADDR string_1</code></pre><p>ShowString 过程用方括号显示了被裁剪后的字符串，这里未给出其代码。过程输出示例如下：[Hello]</p><p>下面给出了 Str_trim 的实现，它在想要保留的最后一个字符后面插入了一个空字节。空字节后面的任何字符一般都会被字符串处理函数所忽略。</p><pre><code>;-------------------------------------;Str_trim;从字符串末尾删除所有与给定分隔符匹配的字符。;返回：无;-------------------------------------Str_trim PROC USES eax ecx edi,    pString:PTR BYTE,                ;指向字符串    char: BYTE                       ;要移必的字符    mov edi,pString                  ;准备调用 Str_length    INVOKE Str_length,edi            ;用 EAX 返回鬆    cmp eax,0                        ;长度是否为零？    je L3                            ;是：立刻退出    mov ecx, eax                     ;否：ECX = 字符串长度    dec eax    add edi,eax                      ;指向最后一个字符L1: mov al, [edi]                    ;取一个字符    cmp al,char                      ;是否为分隔符？    jne L2                           ;否：插入空字节    cec edi                          ;是：继续后退一个字符    loop L1                          ;直到字符串的第一个字符L2: mov BYTE PTR [edi+1 ],0          ;插入一个空字节L3:    retStr_trim ENDP</code></pre><h4 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h4><p>现在仔细研究一下 Str_trim。该算法从字符串最后一个字符开始，反向进行串扫描，以寻找第一个非分隔符字符。当找到这样的字符后，就在该字符后面的位置上插入一个空字节：</p><pre><code>ecx = length(str)if length (str) &gt; 0 then    edi = length - 1    do while ecx &gt; 0        if str[edi] ≠ delimiter then            str[edi+1] = null            break        else            edi = edi - 1        end if        ecx = ecx - 1    end do</code></pre><p>下面逐行查看代码实现。首先，pString 为待裁剪字符串的地址。程序需要知道该字符串的长度，Str_length 过程用 EDI 寄存器接收其输入参数：</p><pre><code>mov edi,pString       ;准备调用 Str_lengthINVOKE Str_length,edi   ;过程返回值在 Eax 中</code></pre><p>Str_length 过程用 EAX 寄存器返回字符串长度，所以，后面的代码行将它与零进行比较，如果字符串为空，则跳过后续代码：</p><pre><code>cmp eax,0   ;字符串长度等于零吗？je L3       ;是：立刻退出</code></pre><p>在继续后面的程序之前，先假设该字符串不为空。ECX 为循环计数器，因此要将字符串长度赋给它。由于希望 EDI 指向字符串最后一个字符，因此把 EAX（包含字符串长度）减 1 后再加到 EDI 上：</p><pre><code>mov ecx,eax         ;否：ECX =字符串长度dec eaxadd edi,eax      ;指向最后一个字符</code></pre><p>现在 EDI 指向的是最后一个字符，将该字符复制到 AL 寄存器，并与分隔符比较：</p><pre><code>L1: mov al, [edi]   ;取字符   cmp al, char   ;是分隔符吗？</code></pre><p>如果该字符不是分隔符，则退出循环，并用标号为 L2 的语句插入一个空字节：</p><pre><code>jne L2          ;否：插入空字节</code></pre><p>否则，如果发现了分隔符，则继续循环，逆向搜索字符串。实现的方法为：将 EDI 后退一个字符，再重复循环：</p><pre><code>dec edi         ;是：继续后退loop L1        ;直到字符串的第一个字符</code></pre><p>如果整个字符串都由分隔符组成，则循环计数器将减到零，并继续执行 loop 指令下面的代码行，即标号为 L2 的代码，在字符串中插入一个空字节：</p><pre><code>L2: mov BYTE PTR [edi+1], 0     ;插入空字节</code></pre><p>假如程序控制到达这里的原因是循环计数减为零，那么，EDI 就会指向字符串第一个字符之前的位置。因此需要用表达式 [edi+1] 来指向第一个字符。</p><p>在两种情况下，程序会执行标号 L2：</p><ul><li><p>其一，在字符串中发现了非分隔符字符；</p></li><li><p>其二， 循环计数减为零。</p></li></ul><p>标号 L2 后面是标号为 L3 的 RET 指令，用来结束整个过程：</p><pre><code>L3:   retStr_trim ENDP</code></pre><h3 id="Str-ucase-过程"><a href="#Str-ucase-过程" class="headerlink" title="Str_ucase 过程"></a>Str_ucase 过程</h3><p>Str_ucase 过程把一个字符串全部转换为大写字母，无返回值。调用过程时，要向其传 递字符串的偏移量：</p><pre><code>INVOKE Str_ucase, ADDR myString</code></pre><p>过程实现如下：</p><pre><code>;---------------------------------;Str_ucase;将空字节结束的字符串转换为大写字母。;返回：无;---------------------------------Str_ucase PROC USES eax esi,pString:PTR BYTE    mov esi,pStringL1:    mov al, [esi]           ;取字符    cmp al, 0               ;字符串是否结束？    je L3                   ;是：退出    cnp al, 'a'             ;小于"a" ？    jb L2    cnp al, 'z'             ;大于"z" ？    ja L2    and BYTE PTR [esi], 11011111b ;转换字符L2: inc esi                 ;下一个字符    jmp L1L3: retStr_ucase ENDP</code></pre><h3 id="字符串演示程序"><a href="#字符串演示程序" class="headerlink" title="字符串演示程序"></a>字符串演示程序</h3><p>下面的 32 位程序演示了对 Irivne32 链接库中 Str_trim、Str_ucase、Str_compare 和 Str_length 过程的调用：</p><pre><code>; String Library Demo    (StringDemo.asm); 该程序演示了链接库中字符串处理过程INCLUDE Irvine32.inc.datastring_1 BYTE "abcde////",0string_2 BYTE "ABCDE",0msg0     BYTE "string_1 in upper case: ",0msg1     BYTE "string1 and string2 are equal",0msg2     BYTE "string_1 is less than string_2",0msg3     BYTE "string_2 is less than string_1",0msg4     BYTE "Length of string_2 is ",0msg5     BYTE "string_1 after trimming: ",0.codemain PROC    call trim_string    call upper_case    call compare_strings    call print_length    exitmain ENDPtrim_string PROC; 从 string_1 删除尾部字符    INVOKE Str_trim, ADDR string_1,'/'    mov        edx,OFFSET msg5    call    WriteString    mov        edx,OFFSET string_1    call    WriteString    call    Crlf    rettrim_string ENDPupper_case PROC; 将 string_1 转换为大写字母    mov        edx,OFFSET msg0    call    WriteString    INVOKE  Str_ucase, ADDR string_1    mov        edx,OFFSET string_1    call    WriteString    call    Crlf    retupper_case ENDPcompare_strings PROC; 比较 string_1 和 string_2.    INVOKE Str_compare, ADDR string_1, ADDR string_2    .IF ZERO?    mov    edx,OFFSET msg1    .ELSEIF CARRY?    mov    edx,OFFSET msg2     ; string 1 小于...    .ELSE    mov    edx,OFFSET msg3     ; string 2 小于...    .ENDIF    call    WriteString    call    Crlf    retcompare_strings  ENDPprint_length PROC; 显示 string_2 的长度    mov        edx,OFFSET msg4    call    WriteString    INVOKE  Str_length, ADDR string_2    call    WriteDec    call    Crlf    retprint_length ENDPEND main</code></pre><p>调用 Str_trim 过程从 string_1 删除尾部字符，调用 Str_ucase 过程将字符串转换为大写字母。</p><p>String Library Demo 程序的输出如下所示：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225815305263" alt="img"></p><h2 id="汇编语言Irivne64字符串过程详解"><a href="#汇编语言Irivne64字符串过程详解" class="headerlink" title="汇编语言Irivne64字符串过程详解"></a>汇编语言Irivne64字符串过程详解</h2><p>下面将一些比较重要的字符串处理过程从 Irvine32 链接库转换为 64 位模式。变化非常简单，删除堆栈参数，并将所有的 32 位寄存器都替换为 64 位寄存器。</p><p>下表列出了这些字符串过程、过程说明及其输入输出。</p><table><thead><tr><th>Str_compare</th><th>比较两个字符串 输入参数：RSI 为源串指针，RDI 为目的串指针 返回值：若源串 &lt; 目的串，则进位标志位 CF=1；若源串 = 目的串，则零标志位 ZF=1；若源串 &gt; 目的串，则 CF=0 且 ZF=0</th></tr></thead><tbody><tr><td>Str_copy</td><td>将源串复制到目的指针指向的位置 输入参数：RSI 为源串指针，RDI 指向被复制串将要存储的位置</td></tr><tr><td>Str_length</td><td>返回空字节结束字符串的长度 输入参数：RCX 为字符串指针 返回值：RAX 为该字符串的长度</td></tr></tbody></table><p>Str_compare 过程中，RSI 和 RDI 是输入参数的合理选择，因为字符串比较循环会用到它们。使用这两个寄存器参数能在过程开始时避免将输入参数复制到 RSI 和 RDI 寄存器中：</p><pre><code>;------------------------------------;Str_compare;比较两个字符串;接收：RSI 为源串指针;     RDT 为目的串指针;返回：若字符串相等，ZF 置 1;      若源串 &lt; 目的串，CF 置 1;------------------------------------Str_compare PROC USES rax rdx rsi rdiL1: mov al,[rsi]    mov dl,[rdi]    cmp al, 0            ; string1 结束？    jne L2               ; 否    cmp dl, 0            ;是：string2 结束？    jne L2               ;否    jmp L3               ;是：退出且 ZF=1L2: inc rsi              ;指向下一个字符    inc rdi    cmp al,dl            ;字符相等？    je L1                ;是：继续循环                         ;否：退出并设置标志位L3: retStr_compare ENDP</code></pre><p>注意，PROC 伪指令用 USES 关键字列出了所有需要在过程开始时入栈、在过程时返回出栈的寄存器。</p><p>Str_copy 过程用 RSI 和 RDI 接收字符串指针：</p><pre><code>;-------------------------------------;Str_copy;复制字符串;接收：RSI 为源串指针;     RDI 为目的串指针;返回：无;-------------------------------------Str_copy PROC USES rax rex rsi rdi    mov rex,rsi               ;获得源串长度    call Str_length           ;RAX 返回长度    mov rex,rax               ;循环计数器    inc rex                   ;有空字节，加 1    cld                       ;方向为正向    rep movsb                 ;复制字符串    retStr_copy ENDP</code></pre><p>Str_length 过程用 RCX 接收字符串指针，然后循环扫描该字符串直到发现空字节。字符串长度用 RAX 返回：</p><pre><code>;-------------------------------------;Str_length;计算辜符串长度;接收：RCX 指向字符串;返回：RAX 为字符串长度;-------------------------------------Str_length PROC USES rdi    mov rdi,rex           ;获得指针    mov eax,0             ;字符计数L1：    cmp BYTE PTR [rdi],0  ;字符串结束？    je L2                 ;是：退出    inc rdi               ;否：指向下一个字符    inc rax               ;计数器加 1    jmp L1L2: ret                   ;RAX 返回计数值Str_length ENDP</code></pre><h4 id="一个简单的测试程序"><a href="#一个简单的测试程序" class="headerlink" title="一个简单的测试程序"></a>一个简单的测试程序</h4><p>下面的测试程序调用了 64 位的 Str_length、Str_copy 和Str_compare 过程。虽然程序中没有显示字符串的语句，但是建议在 Visual Studio 凋试器中运行，这样就可以查看内存窗口、寄存器和标志位。</p><pre><code>; 测试 Irvine64 字符串程序Str_compare        protoStr_length        protoStr_copy        protoExitProcess     proto.datasource byte "AABCDEFGAABCDFG",0      ; 大小为 15target byte 20 dup(0).codemain proc    mov   rax,offset source    call  Str_length                ; 用 RAX 返回长度    mov   rsi,offset source    mov   rdi,offset target    call  str_copy; 由于刚刚才复制了字符串，因此它们应该相等    call  str_compare                ; ZF = 1, 字符串相等; 修改目的串的第一个字符，再比较两个字符串; compare them again:    mov   target,'B'    call  str_compare                ; CF = 1, 源串 &lt; 目的串    mov   ecx,0    call  ExitProcessmain ENDP</code></pre><h2 id="汇编语言二维数组简介"><a href="#汇编语言二维数组简介" class="headerlink" title="汇编语言二维数组简介"></a>汇编语言二维数组简介</h2><p>在汇编语言程序员看来，二维数组是一位数组的高级抽象。高级语言有两种方法在内存中存放数组的行和列：行主序和列主序，如下图所示。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225834648265" alt="img"></p><p>使用行主序（最常用）时，第一行存放在内存块开始的位置，第一行最后一个元素后面紧跟的是第二行的第一个元素。使用列主序时，第一列的元素存放在内存块开始的位置，第一列最后一个元素后面紧跟的是第二列的第一个元素。</p><p>用汇编语言实现二维数组时，可以选择其中的任意一种顺序。这里使用的是行主序。如果是为高级语言编写汇编子程序，那么应该使用高级语言文档中指定的顺序。</p><p>x86 指令集有两种操作数类型：基址-变址和基址-变址-位移量，这两种类型都适用于数组。下面将对它们进行研究并通过例子来说明如 何有效地使用它们。</p><h3 id="基址-变址操作数"><a href="#基址-变址操作数" class="headerlink" title="基址-变址操作数"></a>基址-变址操作数</h3><p>基址-变址操作数将两个寄存器（称为基址和变址）相加，生成一个偏移地址：</p><pre><code>[base + index]</code></pre><p>其中的方括号是必需的。32 位模式下，任一 32 位通用寄存器都可以用作基址和变址寄存器。（通常情况下避免使用 EBP，除非进行堆栈寻址。）下面的例子是 32 位模式中基址和变址操作数的各种组合：</p><pre><code>.dataarray WORD 1000h,2000h,3000h.codemov ebx,OFFSET arraymov esi, 2mov ax,[ebx+esi]    ; AX = 2000hmov edi, OFFSET arraymov ecx,4mov ax,[edi+ecx]    ; AX = 3000hmov ebp,OFFSET arraymov esi, 0mov ax,[ebp+esi]    ; AX = l000h</code></pre><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>按行访问一个二维数组时，行偏移量放在基址寄存器中，列偏移量放在变址寄存器中。例如，下表给出的数组为 3 行 5 列：</p><pre><code>tableB BYTE 10h, 20h, 30h, 40h, 50hRowsize = （$ - tableB）    BYTE 60h, 70h, 80h, 90h, 0A0h    BYTE 0B0h, 0C0h, 0D0h, 0E0h, 0F0h</code></pre><p>该表为行主序，汇编器计算的常数 Rowsize 是表中每行的字节数。如果想用行列坐标定位表中的某个表项，则假设坐标基点为 0，那么，位于行 1 列 2 的表项为 80h。</p><p>将 EBX 设置为该表的偏移量，加上（Rowsizerow_index），计算出行偏移量，将 ESI 设置为列索引：</p><pre><code>row_index = 1column_index = 2mov ebx, OFFSET tableB            ; 表偏移量add ebx, RowSize * row_index      ; 行偏移量mov esi, column_indexmov al,[ebx + esi]                ; AL = 80h</code></pre><p>假设该数组位置的偏移量为 0150h，则其有效地址表示为 EBX+ESI，计算得 0157h。下图展示了如何通过 EBX 加上 ESI 生成 tableB[1, 2] 字节的偏移量。如果有效地址指向该程序数据区之外，那么就会产生一个运行时错误。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225851154267" alt="img"></p><h4 id="1-计算数组行之和"><a href="#1-计算数组行之和" class="headerlink" title="1) 计算数组行之和"></a>1) 计算数组行之和</h4><p>基于变址的寻址简化了二维数组的很多操作。比如，用户可能想要计算一个整数矩阵中一行的和。下面的 32 位 calc_row_sum 程序就计算了一个 8 位整数矩阵中被选中行的和数：</p><pre><code>;------------------------------------------------------------; calc_row_sum; 计算字节矩阵中一行的和数; 接收: EBX = 表偏移量, EAX = 行索引;       ECX = 按字节计的行大小; 返回:  EAX 为和数;------------------------------------------------------------calc_row_sum PROC uses ebx ecx edx esi    mul     ecx              ; 行索引 * 行大小    add     ebx,eax          ; 行偏移量    mov     eax,0            ; 累加器    mov     esi,0            ; 列索引L1:    movzx edx,BYTE PTR[ebx + esi]        ; 取一个字节    add     eax,edx                         ; 与累加器相加    inc     esi                             ; 行中的下一个字节    loop L1    retcalc_row_sum ENDP</code></pre><p>BYTE PTR 是必需的，用于声明 MOVZX 指令中操作数的类型。</p><h4 id="2-比例因子"><a href="#2-比例因子" class="headerlink" title="2) 比例因子"></a>2) 比例因子</h4><p>如果是为字数组编写代码，则需要将变址操作数乘以比例因子 2。下面的例子定位行 1 列 2 的元素值：</p><pre><code>tablew WORD 10h, 20h, 30h, 40h, 50hRowsizeW = ($ - tableW)    WORD 60h, 70h, 80h, 90h, 0A0h    WORD 0B0h, 0C0h, 0D0h, 0E0h, 0F0h.coderow_index = 1column_index = 2mov ebx,OFFSET tableW             ;表偏移量add ebx,RowSizeW * row_index      ;行偏移量mov esi, column_indexmov ax,[ebx + esi*TYPE tableW]    ;AX = 0080h</code></pre><p>本例的比例因子 (TYPE tableW) 等于 2。同样，如果数组类型为双字，则比例因子为 4：</p><pre><code>tableD DWORD 10h, 20h, . . .etc..codemov eax,[ebx + esi*TYPE tableD]</code></pre><h3 id="基址-变址-偏移量操作数"><a href="#基址-变址-偏移量操作数" class="headerlink" title="基址-变址-偏移量操作数"></a>基址-变址-偏移量操作数</h3><p>基址-变址-偏移量操作数用一个偏移量、一个基址寄存器、一个变址寄存器和一个可选的比例因子来生成有效地址。格式如下：</p><pre><code>[base + index + displacement]displacement[base + index]</code></pre><p>Displacement ( 偏移量 ) 可以是变量名或常量表达式。32 位模式下，任一 32 位通用寄存器都可以用作基址和变址寄存器。基址-变址-偏移量操作数非常适于处理二维数组。偏移量可以作为数组名，基址操作数为行偏移量，变址操作数为列偏移量。</p><p>双字数组示例</p><p>下面的二维数组包含了 3 行 5 列的双字：</p><pre><code>tableD DWORD 10h, 20h, 30h, 40h, 50hRowsize = ($ - tableD)DWORD 60h, 70h, 80h, 90h, 0A0hDWORD 0B0h, 0C0h, 0D0h, 0E0h, 0F0h</code></pre><p>Rowsize 等于 20 (14h) 。假设坐标基点为 0，那么位于行 1 列 2 的表项为 80h。为了访问到这个表项，将 EBX 设置为行索引，ESI 设置为列索引：</p><pre><code>mov ebx, Rowsize             ;行索弓|mov esi, 2             ;列索引mov eax, tableD[ebx + esi*TYPE tableD]</code></pre><p>设 tableD 开始于偏移量 0150h 处，下图展示了 EBX 和 ESI 相对于该数组的位置。偏移量为十六进制。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225867481269" alt="img"></p><h3 id="64-位模式下的基址-变址操作数"><a href="#64-位模式下的基址-变址操作数" class="headerlink" title="64 位模式下的基址-变址操作数"></a>64 位模式下的基址-变址操作数</h3><p>64 位模式中，若用寄存器索引操作数则必须为 64 位寄存器。基址-变址操作数和基址-变址-偏移量操作数都可以使用。</p><p>下面是一段小程序，它用 get_tableVal 过程在 64 位整数的二维数组中定位一个数值。如果将其与前面的 32 位代码进行比较，会发现 ESI 被替换为 RSI，EAX 和 EBX 也成了 RAX 和 RBX。</p><pre><code>;64 位模式下的二维数组 (TwoDimArrays.asm)Crlf        protoWriteInt64  protoExitProcess proto.datatable QWORD 1,2,3,4,5RowSize = ($ - table)      QWORD 6,7,8,9,10      QWORD 11,12,13,14,15.codemain proc; 基址-变址-偏移量操作数    mov    rax,1                    ; 行索引基点为0    mov    rsi,4                    ; 列索引基点为0    call    get_tableVal            ; RAX中为返回值    call    WriteInt64              ; 显示返回值    call    Crlf    mov   ecx,0               call  ExitProcess               ; 程序结束main endp;------------------------------------------------------; get_tableVal; 返回四字二维数组中给定行列值的元素; 接收: RAX = 行数, RSI = 列数; 返回: RAX中的数值;------------------------------------------------------get_tableVal proc uses rbx    mov    rbx,RowSize    mul    rbx                ; 乘积（低） = RAX    mov    rax,table[rax + rsi*TYPE table]    retget_tableVal endpend</code></pre><h2 id="汇编语言冒泡排序简述"><a href="#汇编语言冒泡排序简述" class="headerlink" title="汇编语言冒泡排序简述"></a>汇编语言冒泡排序简述</h2><p>冒泡排序从位置 0 和 1 开始，对比数组的两个数值。如果比较结果为逆序，就交换这两个数。下图展示了对一个整数数组进行一次遍历的过程。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225896028271" alt="img"></p><p>一次冒泡过程之后，数组仍没有按序排列，但此时最高索引位置上是最大数。外层循环则开始对该数组再一次遍历。经过 1 次遍历后，数组就会按序排列。</p><p>冒泡排序对小型数组效果很好，但对较大的数组而言，它的效率就十分低下。计算机科学家在衡量算法的相对效率时，常常使用一种被称为 “时间复杂度”（big-O）的概念来描述随着处理对象数量的增加，平均运行时间是如何增加的。</p><p>冒泡排序是 O (n²) 算法，这就意味着，它的平均运行时间随着数组元素 (n) 个数的平方增加。比如，假设 1000 个元素排序需要 0.1 秒。当元素个数增加 10 倍时，该数组排序所需要的时间就会增加 10² (100) 倍。</p><p>下表列出了不同数组大小需要的排序时间，假设 1000 个数组元素排序花费 0.1 秒：</p><table><thead><tr><th>数组大小</th><th>时间(秒)</th><th>数组大小</th><th>时间(秒)</th></tr></thead><tbody><tr><td>1 000</td><td>0.1</td><td>100 000</td><td>1000</td></tr><tr><td>10 000</td><td>10</td><td>1 000 000</td><td>100 000 （27.78 小时）</td></tr></tbody></table><p>对于一百万个整数来说，冒泡排序谈不上有效率，因为它完成任务的时间太长了！但是对于几百个整数，它的效率是足够的。</p><p>用类似于汇编语言的伪代码为冒泡排序编写的简化代码是有用的。代码用 N 表示数组大小，cx1 表示外循环计数器，cx2 表示内循环计数器：</p><pre><code>cx1 = N - 1while( cxl &gt; 0 ){    esi = addr (array)    cx2 = cx1    while ( cx2 &gt; 0 )    {        if(array[esi] &gt; array[esi+4])            exchange(array[esi], array[esi+4])        add esi,4        dec cx2    }    dec cxl}</code></pre><p>如保存和恢复外循环计数器等的机械问题被刻意忽略了。注意内循环计数 (cx2) 是基于外循环计数 (cx1) 当前值的，每次遍历数组时它都依次递减。</p><p>根据伪代码能够很容易生成与之对应的汇编程序，并将它表示为带参数和局部变量的过程：</p><pre><code>;----------------------------------------;BubbleSort;使用冒泡算法，将一个 32 位有符号整数数组按升序进行排列。;接收：数组指针，数组大小;返回：无;----------------------------------------BubbleSort PROC USES eax ecx esi,    pArray:PTR DWORD,           ;数组指针    Count: DWORD                ;数组大小    mov ecx,Count    dec ecx                     ;计数值减1L1: push ecx                    ;保存外循环计数值    mov esi,pArray              ;指向第一个数值L2: mov eax, [esi]              ;取数组元素值    cmp [esi+4],eax             ;比较两个数值    jg L3                       ;如果[ESI]&lt;=[ESI + 4]，不交换    xchg eax, [esi+4]           ;交换两数    mov [esi],eaxL3: add esi,4                   ;两个指针都向前移动一个元素    loop L2                     ;内循环    pop    ecx                  ;恢复外循环计数值    loop L1                     ;若计数值不等于0,则继续外循环L4: retBubbleSort ENDP</code></pre><h2 id="汇编语言对半查找（二分查找）简述"><a href="#汇编语言对半查找（二分查找）简述" class="headerlink" title="汇编语言对半查找（二分查找）简述"></a>汇编语言对半查找（二分查找）简述</h2><p>数组查找是日常编程中最常见的一类操作。对小型数组 (1000 个元素或更少 ) 而言，顺序查找(sequential search) 是很容易的，从数组开始的位置顺序检查每一个元素，直到发现匹配的元素为止。对任意 n 个元素的数组，顺序查找平均需要比较 n/2 次。如果查找的是小型数组，则执行时间也很少。但是，如果查找的数组包含一百万个元素就需要相当多的处理时间了。</p><p>对半查找 (binary search) 算法用于从大型数组中查找一个数值是非常有效的。但是它有一个重要的前提：数组必须是按升序或降序排列。下面的算法假设数组元素是升序：</p><p>开始查找前，请求用户输入一个整数，将其命名为 searchVal</p><p>\1) 被查找数组的范围用下标行 first 和 last 来表示。如果 first &gt; last，则退出查找，也就是说没有找到匹配项。</p><p>\2) 计算位于数组 first 和 last 下标之间的中点。</p><p>\3) 将 searchVal 与数组中点进行比较：</p><ul><li><p>如果数值相等，将中点送入 EAX，并从过程返回。该返回值表示在数组中发现了匹配值。</p></li><li><p>否则，如果 searchVal 大于中点值，则将 first 重新设置为中点后一位元素的位置。</p></li><li><p>或者，如果 searchVal 小于中点值，则将 last 重新设置为中点前一位元素的位置。</p></li></ul><p>\4) 返回步骤 1</p><p>对半查找效率高的原因是它采用了分而治之的策略。每次循环迭代中，数值范围都被对半分为成两部分。通常它被描述为 O (log n) 算法，即，当数组元素增加 n 倍时，平均查找时间仅增加 log₂n 倍。</p><p>为了帮助了解对半查找效率有多高，下表列出了数组大小相同时，顺序查找和对半查找需要执行的最大比较次数。表中的数据代表的是最坏的情况一一在实际应用 中，经过更少次的比较就可能找到匹配数值。</p><table><thead><tr><th>数组大小</th><th>顺序查找</th><th>对半查找</th></tr></thead><tbody><tr><td>64</td><td>64</td><td>6</td></tr><tr><td>1 024</td><td>1 024</td><td>10</td></tr><tr><td>65 536</td><td>65 536</td><td>17</td></tr><tr><td>1 048 576</td><td>1 048 576</td><td>21</td></tr><tr><td>4 294 967 296</td><td>4 294 967 296</td><td>33</td></tr></tbody></table><p>下面是用 C++ 语言实现的对半查找功能，用于有符号整数数组：</p><pre><code>int BinSearch( int values[], const int searchVal, int count ){    int first = 0;    int last = count - 1;    while( first &lt;= last )    {        int mid = (last + first) / 2;        if( values[mid] &lt; searchVal )            first = mid + 1;        else if( values[mid] &gt; searchVal )            last = mid - 1;        else            return mid;    // 成功    }    return -1;    // 未找至U}</code></pre><p>该 C++ 代码示例的汇编语言程序清单如下所示：</p><pre><code>;-------------------------------------------------------------; Binary Search procedureINCLUDE Irvine32.inc.codeBinarySearch PROC USES ebx edx esi edi,    pArray:PTR DWORD,          ; 数组指针    Count:DWORD,               ; 数组大学    searchVal:DWORD            ; 给定查找数值LOCAL first:DWORD,             ; first 的位置    last:DWORD,                ; last 的位置    mid:DWORD                  ; 中点; 接收: 数组指针、数组大小、给定查找数值; 返回: 若发现匹配项则EAX=该匹配元素在数组中的位置 否则 EAX = -1;-------------------------------------------------------------    mov     first,0              ; first = 0    mov     eax,Count            ; last = (count - 1)    dec     eax    mov     last,eax    mov     edi,searchVal        ; EDI = searchVal    mov     ebx,pArray           ; EBX 为数组指针L1: ; while first &lt;= last    mov     eax,first    cmp     eax,last    jg     L5                    ; 退出查找; mid = (last + first) / 2    mov     eax,last    add     eax,first    shr     eax,1    mov     mid,eax; EDX = values[mid]    mov     esi,mid    shl     esi,2                ; 将 mid 值乘 4    mov     edx,[ebx+esi]        ; EDX = values[mid]; if ( EDX &lt; searchval(EDI) );    first = mid + 1;    cmp     edx,edi    jge     L2    mov     eax,mid                ; first = mid + 1    inc     eax    mov     first,eax    jmp     L4; else if( EDX &gt; searchVal(EDI) );    last = mid - 1;L2:    cmp     edx,edi    jle     L3    mov     eax,mid                ; last = mid - 1    dec     eax    mov     last,eax    jmp     L4; else return midL3:    mov     eax,mid                  ; 发现数值    jmp     L9                          ; 返回 (mid)L4:    jmp     L1                       ; 继续循环L5:    mov     eax,-1                   ; 查找失败L9:    retBinarySearch ENDPEND</code></pre><h2 id="Java如何字符串处理及常用方法"><a href="#Java如何字符串处理及常用方法" class="headerlink" title="Java如何字符串处理及常用方法"></a>Java如何字符串处理及常用方法</h2><p>【示例】：寻址子串，下面的 Java 代码定义了一个字符串变量，其中包含了一个雇员 ID 和该雇员的姓氏。然后，调用 substring 方法将账号送入第二个字符串变量：</p><pre><code>String empInfo = "10034Smith";String id = empInfo.substring(0,5);</code></pre><p>对该 Java 代码反汇编，其字节码显示如下：</p><pre><code>ldc #32; //字符串 10034Smithastore_0aload_0iconst_0iconst_5invokevirtual #34; // Method java/lang/String.substringastore_1</code></pre><p>现在分步研究这段代码，并加上自己的注释。ldc 指令把一个对字符串文本的引用从常量池加载到操作数栈。接着，astore_0 指令从运行时堆栈弹出该字符串引用，并把它保存到局部变量 empInfo 中，其在局部变量区域中的索引为 0：</p><pre><code>ldc #32; //加载文本字符串：10034Smithastore_0 //保存到 empInfo （索引 0）</code></pre><p>接下来，aload_0 指令把对 empInfo 的引用压入操作数栈：</p><pre><code>aload_0 //加载 empInfo 到堆栈</code></pre><p>然后，在调用 substring 方法之前，它的两个参数（0 和 5）必须压入操作数栈。该操作由指令 iconst_0 和 iconst_5 完成：</p><pre><code>iconst_0iconst_5</code></pre><p>invokevirtual 指令调用 substring 方法，它的引用 ID 号为 34：</p><pre><code>invokevirtual #34; // Method java/lang/String.substring</code></pre><p>substring 方法将参数弹出堆栈，创建新字符串，并将该字符串的引用压入操作数栈。其后的 astore_1 指令把这个字符串保存到局部变量区域内索引 1 的位置，也就是变量 id 所在的位置：astore_1</p><h1 id="汇编语言结构和宏"><a href="#汇编语言结构和宏" class="headerlink" title="汇编语言结构和宏"></a>汇编语言结构和宏</h1><h2 id="汇编语言STRUCT和ENDS伪指令：定义结构"><a href="#汇编语言STRUCT和ENDS伪指令：定义结构" class="headerlink" title="汇编语言STRUCT和ENDS伪指令：定义结构"></a>汇编语言STRUCT和ENDS伪指令：定义结构</h2><p>定义结构使用的是 STRUCT 和 ENDS 伪指令。在结构内，定义字段的语法与一般的变量定义是相同的。结构对其包含字段的数量几乎没有任何限制：</p><pre><code>name STRUCT   field-declarationsname ENDS</code></pre><p>字段初始值若结构字段有初始值，那么在创建结构变量时就要进行赋值。字段初始值可以使用各种类型：</p><ul><li><p>无定义：运算符？使字段初始值为无定义。</p></li><li><p>字符串文本：用引号括起的字符串。</p></li><li><p>整数：整数常数和整数表达式。</p></li><li><p>数组：DUP 运算符可以初始化数组元素。</p></li></ul><p>下面的 Employee 结构描述了雇员信息，其包含字段有 ID 号、姓氏、服务年限，以及薪酬历史信息数组。结构定义如下所示，定义必须在声明 Employee 变量之前：</p><pre><code>Employee STRUCT    IdNum BYTE "000000000"    LastName BYTE 30 DUP(0)    Years WORD 0    SalaryHistory DWORD 0,0,0,0Employee ENDS</code></pre><p>该结构内存保存形式的线性表示如下：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225935975273" alt="img"></p><h4 id="对齐结构字段"><a href="#对齐结构字段" class="headerlink" title="对齐结构字段"></a>对齐结构字段</h4><p>为了获得最好的内存 I/O 性能，结构成员应按其数据类型进行地址对齐。否则，CPU 将会花更多时间访问成员。例如，一个双字成员应对齐到双字边界。下表列岀了 Microsoft C 和 C++ 编译器，以及 Win32 API 函数的对齐方式。汇编语言中的 ALIGN 伪指令会使其后的字段或变量按地址对齐：</p><pre><code>ALIGN datatype</code></pre><table><thead><tr><th>成员类型</th><th>对齐方式</th><th>成员类型</th><th>对齐方式</th></tr></thead><tbody><tr><td>BYTE, SBYTE</td><td>对齐到 8 位（字节）边界</td><td>REAL4</td><td>对齐到 32 位（双字）边界</td></tr><tr><td>WORD, SWORD</td><td>对齐到 16 位（字）边界</td><td>REAL8</td><td>对齐到 64 位（四字）边界</td></tr><tr><td>DWORD, SDWORD</td><td>对齐到 32 位（双字）边界</td><td>structure</td><td>所有成员的最大对齐要求</td></tr><tr><td>QWORD</td><td>对齐到 64 位（四字）边界</td><td>union</td><td>第一个成员的对齐要求</td></tr></tbody></table><p>比如，下面的例子就把 myVar 对齐到双字边界：</p><pre><code>.dataALIGN DWORDmyVar DWORD ?</code></pre><p>现在正确地定义 Employee 结构，利用 ALIGN 将 Years 按字（WORD）边界对齐，SalaryHistory 按双字（DWORD）边界对齐。注释为字段大小：</p><pre><code>Employee STRUCT    IdNum BYTE "000000000"              ; 9    LastName BYTE 30 DUP(0)             ; 30    ALIGN WORD                          ; 加 1 字节    Years WORD 0                        ; 2    ALIGN DWORD                         ; 加 2 字节    SalaryHistory DWORD 0,0,0,0         ; 16Employee ENDS                           ;共 60 字节</code></pre><h2 id="汇编语言声明结构变量"><a href="#汇编语言声明结构变量" class="headerlink" title="汇编语言声明结构变量"></a>汇编语言声明结构变量</h2><p>结构变量可以被声明，并能选择为是否用特定值进行初始化。语法如下，其中 structureType 已经用 STRUCT 伪指令定义过了：</p><pre><code>identifier structureType &lt;initializer-list&gt;</code></pre><p>identifier 的命名规则与 MASM 中其他变量的规则相同。initializer-list 为可选项，但是如果选择使用，则该项就是一个用逗号分隔的汇编时常数列表，需要与特定结构字段的数据类型相匹配：</p><pre><code>initializer [, initializer] ...</code></pre><p>空括号 &lt;&gt; 使结构包含的是结构定义的默认字段值。此外，还可以在选定字段中插入新值。结构字段中的插入值顺序为从左到右，与结构声明中字段的顺序一致。这两种方法的示例如下，使用的结构是 COORD 和 Employee：</p><pre><code>.datapoint1 COORD &lt;5,10&gt;             ; X = 5, Y = 10point2 COORD &lt;20&gt;               ; X = 20, Y = ?point3 COORD &lt;&gt;                 ; X = ?, Y = ?worker Employee &lt;&gt;              ; 默认初始值</code></pre><p>可以只覆盖选定字段的初始值。下面的声明只覆盖了 Employee 结构的 IdNum 字段，而其他字段仍为默认值：</p><pre><code>person1 Employee &lt;"555223333"&gt;</code></pre><p>还有一种形式是使用大括号 {…} 而不是尖括号：</p><pre><code>person2 Employee {"555223333"}</code></pre><p>若字符串字段初始值的长度少于字段的定义，则多出的位置用空格填充。空字节不会自动插到字符串字段的尾部。通过插入逗号作为位置标记可以跳过结构字段。例如，下面的语句就跳过了 IdNum 字段，初始化了 LastName 字段：</p><pre><code>person3 Employee &lt;, "dJones"&gt;</code></pre><p>数组字段使用 DUP 运算符来初始化某些或全部数组元素。如果初始值比字段位数少，则多出的位置用零填充。下面的语句只初始化了前两个 SalaryHistory 的值，而其他的值则为 0：</p><pre><code>person4 Employee &lt;, , ,2 DUP(20000)&gt;</code></pre><p>DUP 运算符能够用于定义结构数组，如下所示，AllPoints 中每个元素的 X 和 Y 字段都被初始化为 0：</p><pre><code>NumPoints = 3AllPoints COORD NumPoints DUP(&lt;0,0&gt;)</code></pre><h4 id="对齐结构变量"><a href="#对齐结构变量" class="headerlink" title="对齐结构变量"></a>对齐结构变量</h4><p>为了最好的处理器性能，结构变量在内存中的位置要与其最大结构成员的边界对齐。Employee 结构包含双字 (DWORD) 字段，因此，下面的定义使用了双字对齐：</p><pre><code>.dataALIGN DWORDperson Employee &lt;&gt;</code></pre><h2 id="汇编语言TYPE和SIZEOF运算符：引用结构变量和结构名称"><a href="#汇编语言TYPE和SIZEOF运算符：引用结构变量和结构名称" class="headerlink" title="汇编语言TYPE和SIZEOF运算符：引用结构变量和结构名称"></a>汇编语言TYPE和SIZEOF运算符：引用结构变量和结构名称</h2><p>使用 TYPE 和 SIZEOF 运算符可以引用结构变量和结构名称。例如，现在回到之前的 Employee 结构：</p><pre><code>Employee STRUCT    IdNum BYTE "000000000"      ; 9    LastName BYTE 30 DUP(0)     ; 30    ALIGN WORD                  ; 加 1 字节    Years WORD 0                ; 2    ALIGN DWORD                 ; 加 2 字节    SalaryHistory DWORD 0,0,0,0 ; 16Employee ENDS                   ; 共 60 字节</code></pre><p>给定数据定义：</p><pre><code>.dataworker Employee &lt;&gt;</code></pre><p>则下列所有表达式返回的值都相同：</p><pre><code>TYPE Employee        ; 60SIZEOF Employee           ; 60SIZEOF worker        ; 60</code></pre><p>TYPE 运算符返回的是标识符存储类型（BYTE、WORD、DWORD 等）的字节数。LENGTHOF 运算符返回的是数组元素的个数。SIZEOF 运算符则为 LENGTHOF 与 TYPE 的乘积。</p><h4 id="1-引用成员"><a href="#1-引用成员" class="headerlink" title="1) 引用成员"></a>1) 引用成员</h4><p>引用已命名的结构成员时，需要用结构变量作为限定符。以 Employee 结构为例，在汇编时能生成下述常量表达式：</p><pre><code>TYPE Employee.SalaryHistory            ; 4LENGTHOF Employee.SalaryHistory             ; 4SIZEOF Employee.SalaryHistory           ; 16TYPE Employee.Years                   ; 2</code></pre><p>以下为对 worker（一个 Employee）的运行时引用：</p><pre><code>.dataworker Employee &lt;&gt;.codemov dx,worker.Yearsmov worker.SalaryHistory, 20000              ;第一个工资mov [worker.SalaryHistory+4 ], 30000         ;第二个工资</code></pre><p>使用 OFFSET 运算符能获得结构变量中一个字段的地址：</p><pre><code>mov edx,OFFSET worker.LastName</code></pre><h4 id="2-间接和变址操作数"><a href="#2-间接和变址操作数" class="headerlink" title="2) 间接和变址操作数"></a>2) 间接和变址操作数</h4><p>间接操作数用寄存器（如 ESI）对结构成员寻址。间接寻址具有灵活性，尤其是在向过程传递结构地址或者使用结构数组的情况下。引用间接操作数时需要 PTR 运算符：</p><pre><code>mov esi,OFFSET workermov ax,(Employee PTR [esi]).Years</code></pre><p>下面的语句不能汇编，原因是 Years 自身不能表明它所属的结构：</p><pre><code>mov ax, [esi].Years   ;无效</code></pre><h4 id="变址操作数-1"><a href="#变址操作数-1" class="headerlink" title="变址操作数"></a>变址操作数</h4><p>用变址操作数可以访问结构数组。假设 department 是一个包含 5 个 Employee 对象的数组。下述语句访问的是索引位置为 1 的雇员的 Years 字段：</p><pre><code>.datadepartment Employee 5 DUP(&lt;&gt;).codemov esi, TYPE Employee              ; 索引 = 1mov department[esi].Years, 4</code></pre><h4 id="数组循环"><a href="#数组循环" class="headerlink" title="数组循环"></a>数组循环</h4><p>带间接或变址寻址的循环可以用于处理结构数组。下面的程序 (AllPoints.asm)为 AllPoints 数组分配坐标：</p><pre><code>; 数组循环       (AllPoints.asm)INCLUDE Irvine32.incNumPoints = 3.dataALIGN WORDAllPoints COORD NumPoints DUP(&lt;0,0&gt;).codemain PROC    mov edi,0                    ; 数组索引    mov ecx,NumPoints            ; 循环计数器    mov ax,1                     ; 起始 X, Y 的值L1:    mov (COORD PTR AllPoints[edi]).X,ax    mov (COORD PTR AllPoints[edi]).Y,ax    add edi,TYPE COORD    inc ax    loop L1    exitmain ENDPEND main3) 对齐的结构成员的性能</code></pre><p>之前已经断言，处理器访问正确对齐的结构成员时效率更高。那么，非对齐字段会对性能产生多大影响呢？现在使用本章介绍的 Employee 结构的两种不同版本，进行一个简单的测试。测试将对第一个版本进行重命名，以便两种版本能在同一个程序中使用：</p><pre><code>EmployeeBad STRUCT       Idnum    BYTE "000000000"    Lastname BYTE 30 DUP(0)    Years    WORD 0    SalaryHistory DWORD 0,0,0,0EmployeeBad ENDS               Employee STRUCT       Idnum    BYTE "000000000"    Lastname BYTE 30 DUP(0)    ALIGN    WORD    Years    WORD 0    ALIGN    DWORD    SalaryHistory DWORD 0,0,0,0Employee ENDS</code></pre><p>下面的代码首先获取系统时间，再执行循环以访问结构字段，最后计算执行花费的时 间。变量 emp 可以声明为 Employee 对象或者 EmployeeBad 对象：</p><pre><code>.dataALIGN DWORDstartTime DWORD ?                ; 对齐 startTimeemp EmployeeBad &lt;&gt;               ; 或: EmployeeBad.code    call    GetMSeconds          ; 获取系统时间    mov    startTime,eax    mov    ecx,0FFFFFFFFh        ; 循环计数器L1:    mov    emp.Years,5    mov    emp.SalaryHistory,35000    loop    L1    call    GetMSeconds        ; 获取开始时间    sub    eax,startTime    call    WriteDec           ; 显示执行花费的时间</code></pre><p>在这个简单的测试程序中，使用正确对齐的 Employee 结构的执行时间为 6141 毫秒，而使用 EmployeeBad 结构的执行时间为 6203 毫秒。两者相差不大 (62 毫秒)，可能是因为处理器的内存 cache 将对齐问题最小化了。</p><h2 id="汇编语言实例：显示系统时间"><a href="#汇编语言实例：显示系统时间" class="headerlink" title="汇编语言实例：显示系统时间"></a>汇编语言实例：显示系统时间</h2><p>MS-Windows 提供了设置屏幕光标位置和获取系统时间的控制台函数。要使用这些函数，先为两个预先定义的结构 COORD 和 SYSTEMTIME 创建实例：</p><pre><code>COORD STRUCT    X WORD ?    Y WORD ?COORD ENDSSYSTEMTIME STRUCT    wYear WORD ?    wMonth WORD ?    wDayOfWeek WORD ?    wDay WORD ?    wHour WORD ?    wMinute WORD ?    wSecond WORD ?    wMilliseconds WORD ?SYSTEMTIME ENDS</code></pre><p>这两个结构都在 SmallWin.inc 中进行了定义，这个文件位于汇编器的 INCLUDE 目录下，并且由 Irvine32.inc 引用。首先获取系统时间（调整本地时间），调用 MS-Windows 的 GetLocalTime 函数，并向其传递 SYSTEMTIME 结构的地址：</p><pre><code>.datasysTime SYSTEMTIME &lt;&gt;.codeINVOKE GetLocalTime, ADDR sysTime</code></pre><p>接着，从 SYSTEMTIME 结构检索相应的数值：</p><pre><code>movzx eax,sysTime.wYearcall WriteDec</code></pre><p>当 Win32 程序产生屏幕输出时，它要调用 MS-Windows GetStdHandle 函数来检索标准控制台输出句柄（一个整数）：</p><pre><code>.dataconsoleHandle DWORD ?.codeINVOKE GetStdHandle, STD_OUTPUT_HANDLEmov consoleHandle,eax</code></pre><p>设置光标位置要调用 MS-Windows SetConsoleCursorPosition 函数，并向其传递控制台输岀句柄，以及包含 X、Y 字符坐标的 COORD 结构变量：</p><pre><code>.dataXYPos COORD &lt;10,5&gt;.codeINVOKE SetConsoleCursorPosition, consoleHandle, XYPos</code></pre><h4 id="程序清单"><a href="#程序清单" class="headerlink" title="程序清单"></a>程序清单</h4><p>下面的程序检索系统时间，并将其显示在指定的屏幕位置。该程序只在保护模式下运行：</p><pre><code>; 结构    （ShowTime.asm）INCLUDE Irvine32.inc.datasysTime SYSTEMTIME &lt;&gt;XYPos   COORD &lt;10,5&gt;consoleHandle DWORD ?colonStr BYTE ":",0.codemain PROC; 获取 Win32 控制台的标准输出句柄    INVOKE GetStdHandle, STD_OUTPUT_HANDLE    mov consoleHandle,eax; 设置光标位置并获取系统时间    INVOKE SetConsoleCursorPosition, consoleHandle, XYPos    INVOKE GetLocalTime,ADDR sysTime; 显示系统时间 (hh:mm:ss).    movzx eax,sysTime.wHour          ; 小时    call  WriteDec    mov   edx,offset colonStr        ; ":"    call  WriteString    movzx eax,sysTime.wMinute        ; 分钟    call  WriteDec    call  WriteString                ; ":"    movzx eax,sysTime.wSecond        ; 秒    call  WriteDec    call Crlf    exitmain ENDPEND main</code></pre><p>SmallWin.inc（自动包含在 Irvine32.inc 中）中的上述程序采用如下定义：</p><pre><code>STD_OUTPUT_HANDLE EQU -11SYSTEMTIME STRUCT ...COORD STRUCT ...GetStdHandle PROTO,   nStdHandle:DWORDGetLocalTime PROTO,   lpSystemTime:PTR SYSTEMTIMESetConsoleCursorPosition PROTO,   nStdHandle:DWORD,   coords:COORD</code></pre><p>下面是示例程序输出，执行时间为下午 12:16：</p><pre><code>12:16:35Press any key to continue...</code></pre><h2 id="汇编语言结构嵌套简述"><a href="#汇编语言结构嵌套简述" class="headerlink" title="汇编语言结构嵌套简述"></a>汇编语言结构嵌套简述</h2><p>结构还可以包含其他结构的实例。例如，Rectangle 可以用其左上角和右下角来定义，而它们都是 COORD 结构：</p><pre><code>Rectangle STRUCT   UpperLeft COORD &lt;&gt;   LowerRight COORD &lt;&gt;Rectangle ENDS</code></pre><p>Rectangle 变量可以被声明为不覆盖或者覆盖单个 COORD 字段。各种表达形式如下所示：</p><pre><code>rect1 Rectangle &lt; &gt;rect2 Rectangle { }rect3 Rectangle { {10,10}, {50,20} }rect4 Rectangle &lt; &lt;10,10&gt;, &lt;50,20&gt; &gt;</code></pre><p>下面是对其一个结构字段的直接引用：</p><pre><code>mov rect1.UpperLeft.X, 10</code></pre><p>也可以用间接操作数访问结构字段。下例用 ESI 指向结构，并把 10 送人该结构左上角的 Y 坐标：</p><pre><code>mov esi,OFFSET rect1mov (Rectangle PTR [esi]).UpperLeft.Y, 10</code></pre><p>OFFSET 运算符能返回单个结构字段的指针，包括嵌套字段：</p><pre><code>mov edi,OFFSET rect2.LowerRightmov (COORD PTR [edi]).X, 50mov edi,OFFSET rect2.LowerRight.Xmov WORD PTR [edi], 50</code></pre><h4 id="示例：醉汉行走"><a href="#示例：醉汉行走" class="headerlink" title="示例：醉汉行走"></a>示例：醉汉行走</h4><p>现在来看一个使用结构的小程序将会有所帮助。下面完成一个“醉汉行走”练习，用程序模拟一个不太清醒的教授从计算机科学假期聚会回家的路线。利用随机数生成器，选择该教授每一步行走的方向。假设教授处于一个虚构的网格中心，其中的每个方格代表的是北、南、东、西方向上的一步。现在按照随机路径通过网格，如下图所示。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627225967968275" alt="img"></p><p>本程序将使用 COORD 结构追踪这个人行走路径上的每一步，它们被保存在一个 COORD 对象数组中。</p><pre><code>WalkMax == 50DrunkardWalk STRUCT   path COORD WalkMax DUP(&lt;0, 0&gt;)   pathsUsed WORD 0DrunkardWalk ENDS</code></pre><p>Walkmax 是一个常数，决定在模拟中教授能够行走的总步数。pathsUsed 字段表示在程序循环结束后，一共行走了多少步。教授每走一步，其位置就被记录在 COORD 对象中，并插入 path 数组下一个可用的位置。程序将在屏幕上显示这些坐标。</p><p>以下是完整的程序清单, 需在 32 位模式下运行：</p><pre><code>; 醉汉行走    (Walk. asm); 醉汉行走程序。教授的起点坐标为（25，25），并在周围徘徊INCLUDE Irvine32.incWalkMax = 50StartX = 25StartY = 25DrunkardWalk STRUCT    path COORD WalkMax DUP(&lt;0,0&gt;)    pathsUsed WORD 0DrunkardWalk ENDSDisplayPosition PROTO currX:WORD, currY:WORD.dataaWalk DrunkardWalk &lt;&gt;.codemain PROC    mov esi,OFFSET aWalk    call TakeDrunkenWalk    exitmain ENDP;-------------------------------------------------------TakeDrunkenWalk PROC    LOCAL currX:WORD, currY:WORD;; 向随机方向行走(北, 南, 东, 西); 接收: ESI 为 DrunkardWalk 结构的指针; 返回:  结构初始化为随机数;-------------------------------------------------------    pushad; 用 OFFSET 运算符获取 path，COORD 对象数组的地址，并将其复制到 EDI.    mov edi,esi    add edi,OFFSET DrunkardWalk.path    mov ecx,WalkMax            ; 循环计数器    mov currX,StartX           ; 当前 X 的位置    mov currY,StartY           ; 当前 Y 的位置Again:    ; 把当前位置插入数组    mov ax,currX    mov (COORD PTR [edi]).X,ax    mov ax,currY    mov (COORD PTR [edi]).Y,ax    INVOKE DisplayPosition, currX, currY    mov      eax,4      ; 选择一个方向 (0-3)    call  RandomRange    .IF eax == 0        ; 北      dec currY    .ELSEIF eax == 1    ; 南      inc currY    .ELSEIF eax == 2    ; 西      dec currX    .ELSE               ; 东 (EAX = 3)      inc currX    .ENDIF    add    edi,TYPE COORD    ; 指向下一个 COORD    loop    AgainFinish:    mov (DrunkardWalk PTR [esi]).pathsUsed, WalkMax    popad    retTakeDrunkenWalk ENDP;-------------------------------------------------------DisplayPosition PROC currX:WORD, currY:WORD; 显示当前 X 和 Y 的位置;-------------------------------------------------------.datacommaStr BYTE ",",0.code    pushad    movzx eax,currX                ; 当前 X 的位置    call     WriteDec    mov     edx,OFFSET commaStr    ; "," 字符串    call     WriteString    movzx eax,currY                ; 当前 Y 的位置    call     WriteDec    call     Crlf    popad    retDisplayPosition ENDPEND main</code></pre><p>现在进一步查看 TakeDrunkenWalk 过程。过程接收指向 DrunkardWalk 结构的指针 (ESI)，利用 OFFSET 运算符计算 path 数组的偏移量，并将其复制到 EDI：</p><pre><code>mov edi,esiadd edi,OFFSET DrunkardWalk.path</code></pre><p>教授初始位置的 X 和 Y 值 (StartX 和 StartY) 都被设置为 25，位于 50 x 50 虚拟网格的中点。循环计数器也进行了初始化：</p><pre><code>mov ecx, WalkMax ;循环计数器mov currX, StartX  ;当前 X 的位置mov currY, StartY  ;当前 Y 的位置</code></pre><p>循环开始时，对 path 数组的第一项进行初始化：</p><pre><code>Again:   ; 把当前位置插入数组   mov ax,currX   mov (COORD PTR [edi]).X,ax   mov ax,currY   mov (COORD PTR [edi]).Y,ax</code></pre><p>路径结束时，在 pathsUsed 字段插入一个计数值，表示总共走了多少步：</p><pre><code>Finish:   mov (DrunkardWalk PTR [esi]).pathsUsed, WalkMax</code></pre><p>在当前的程序中，pathsUsed 总是等于 WalkMaX。不过，若在行走过程中发现障碍，如湖泊或建筑物，情况就会发生变化，循环将会在达到 WalkMax 之前结束。</p><h2 id="汇编语言联合-union-的声明和使用"><a href="#汇编语言联合-union-的声明和使用" class="headerlink" title="汇编语言联合 (union) 的声明和使用"></a>汇编语言联合 (union) 的声明和使用</h2><p>结构中的每个字段都有相对于结构第一个字节的偏移量，而联合 (union) 中所有的字段则都起始于同一个偏移量。一个联合的存储大小即为其最大字段的长度。如果不是结构的组成部分，那么需要用 UNION 和 ENDS 伪指令来定义联合：</p><pre><code>unionname UNION   union-fieldsunionname ENDS</code></pre><p>如果联合嵌套在结构内，其语法会有一点不同：</p><pre><code>structname STRUCT   structure-fields   UNION unionname       union-fields   ENDSstructname ENDS</code></pre><p>除了其每个字段都只有一个初始值之外，联合字段声明的规则与结构的规则相同。例如，Integer 联合对同一个数据声明了 3 种不同的大小属性，并将所有的字段都初始化为 0：</p><pre><code>Integei; UNION   D DWORD 0   W WORD 0   B BYTE 0Integer ENDS</code></pre><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>如果使用初始值，那么它们必须为相同的数值。假设 Integer 声明了 3 个不同的初始值：</p><pre><code>Integer UNION   D DWORD 1   W WORD 5   B BYTE 8Integer ENDS</code></pre><p>同时还假设声明了一个 Integer 变量 mylnt 使用默认初始值：</p><pre><code>.datamylnt Integer &lt;&gt;</code></pre><p>结果发现，myInt.D、myInt.W 和 myInt.B 都等于 1。字段 W 和 B 中声明的初始值会被汇编器忽略。</p><h4 id="结构包含联合"><a href="#结构包含联合" class="headerlink" title="结构包含联合"></a>结构包含联合</h4><p>在结构声明中使用联合的名称，就可以使联合嵌套在这个结构中。方法如同下面在 Fileinfo 结构中声明 FilelD 字段一样：</p><pre><code>Fileinfo STRUCT   FilelD Integer &lt;&gt;   FileName BYTE 64 DUP(?)Fileinfo ENDS</code></pre><p>还可以直接在结构中定义联合，方法如同下面定义 FilelD 字段一样：</p><pre><code>Fileinfo STRUCT   UNION FilelD       D DWORD ?       W WORD ?       B BYTE ?   ENDS   FileName BYTE 64 DUP(?)Fileinfo ENDS</code></pre><h4 id="声明和使用联合变量"><a href="#声明和使用联合变量" class="headerlink" title="声明和使用联合变量"></a>声明和使用联合变量</h4><p>联合变量的声明和初始化方法与结构变量相同，只除了一个重要的差异：不允许初始值多于一个。下面是 Integer 类型变量的例子：</p><pre><code>val1 Integer &lt;12345678h&gt;val2 Integer &lt;100h&gt;val3 Integer &lt;&gt;</code></pre><p>在可执行指令中使用联合变量时，必须给出字段的一个名称。下面的例子把寄存器的值赋给了 Integer 联合字段。注意其可以使用不同操作数大小的灵活性：</p><pre><code>mov val3.B, almov val3.W, axmov val3.D, eax</code></pre><p>联合还可以包含结构。有些 MS-Windows 控制台输入函数会使用如下 INPUT_RECORD 结构，它包含了一个名为 Event 的联合，这个联合对几个预定义的结构类型进行选择。EventType 字段表示联合中出现的是哪种 record。每一种结构都有不同的布局和大小，但是一次只能使用一种：</p><pre><code>INPUT_RECORD STRUCT   EventType WORD ?   ALIGN DWORD   UNION Event       KEY_EVENT_RECORD &lt;&gt;       MOUSE_EVENT_RECORD &lt;&gt;       WINDOW_BUFFER_SIZE_RECORD &lt;&gt;       MENU_EVENT_RECORD &lt;&gt;       FOCUS_EVENT_RECORD &lt;&gt;   ENDSINPUT_RECORD ENDS</code></pre><h4 id="Win32-API"><a href="#Win32-API" class="headerlink" title="Win32 API"></a>Win32 API</h4><p>在命名结构时，常常使用单词 RECORD。KEY_EVENT_RECORD 结构的定义如下所示：</p><pre><code>KEY_EVENT_RECORD STRUCT   bKeyDown DWORD ?   wRepeatCount WORD ?   wVirtualKeyCode WORD ? wVirtualScanCode WORD ?   UNION uChar       UnicodeChar WORD ?       AsciiChar BYTE ?   ENDS   dwControlKeyState DWORD ?KEY_EVENT_RECORD ENDS</code></pre><h2 id="汇编语言宏过程（macro-procedure）简述"><a href="#汇编语言宏过程（macro-procedure）简述" class="headerlink" title="汇编语言宏过程（macro procedure）简述"></a>汇编语言宏过程（macro procedure）简述</h2><p>宏过程 (macro procedure) 是一个命名的汇编语句块。一旦定义好了，它就可以在程序中多次被调用。在调用宏过程时，其代码的副本将被直接插入到程序中该宏被调用的位置。</p><p>这种自动插入代码也被称为内联展开(inline expansion)。尽管从技术上来说没有 CALL 指令，但是按照惯例仍然说调用 (calling) 宏过程。</p><blockquote><p>提示：Microsoft 汇编程序手册中的术语宏过程是指无返回值的宏。还有一种宏函数 (macro function) 则有返回值。在程序员中，单词宏 (macro) 通常被理解为宏过程。在下面的讲解中将使用宏这个简短的称呼。</p></blockquote><p>位置宏定义一般出现在程序源代码开始的位置，或者是放在独立文件中，再用 INCLUDE 伪指令复制到程序里。</p><p>宏在汇编器预处理 (preprocessing) 阶段进行扩展。在这个阶段中，预处理程序读取宏定义并扫描程序剩余的源代码。每到宏被调用的位置，汇编器就将宏的源代码复制插入到程序中。</p><p>汇编器在调用宏之前，必须先找到宏定义。如果程序定义了宏但却没有调用它，那么在编译好的程序中不会出现宏代码。</p><p>在下例中，宏 PrintX 调用了 Irvine32 链接库的 WriteChar 过程。这个定义通常会被放置在数据段之前：</p><pre><code>PrintX MACRO   mov al,'X'   call WriteCharENDM</code></pre><p>接着，在代码段中调用这个宏：</p><pre><code>.codePrintX</code></pre><p>当预处理程序扫描这个程序并发现对 PrintX 的调用后，它就用如下语句替换宏调用：</p><pre><code>mov al, 'X'call WriteChar</code></pre><p>这里发生的是文本替换。虽然宏有点不灵活，但后面很快就会展示如何向宏传递实参，使它们变得更有用。</p><h2 id="汇编语言MACRO和ENDM伪指令：定义宏"><a href="#汇编语言MACRO和ENDM伪指令：定义宏" class="headerlink" title="汇编语言MACRO和ENDM伪指令：定义宏"></a>汇编语言MACRO和ENDM伪指令：定义宏</h2><p>定义一个宏使用的是 MACRO 和 ENDM 伪指令，其语法如下所示：</p><pre><code>macroname MACRO parameter-1, parameter-2...   statement-listENDM</code></pre><p>关于缩进没有硬性规定，但是还是建议对 macroname 和 ENDM 之间的语句进行缩进。 同时，还希望在宏名上使用前缀 m，形成易识别的名称，如 mPutChar，mWriteString 和 mGotoxy。</p><p>除非宏被调用，否则 MACRO 和 ENDM 伪指令之间的语句不会被汇编。宏定义中还可以有多个形参，参数之间用逗号隔开。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>宏形参 (macro parameter) 是需传递给调用者的文本实参的命名占位符。实参实际上可能是整数、变量名或其他值，但是预处理程序把它们都当做文本。</p><p>形参不包含类型信息，因此，预处理程序不会检查实参类型来看它们是否正确。如果发生类型不匹配，它将会在宏展开之后，被汇编器捕获。</p><h4 id="mPutChar-示例"><a href="#mPutChar-示例" class="headerlink" title="mPutChar 示例"></a>mPutChar 示例</h4><p>下面宏 mPutChar 接收一个名为 char 的输入形参，通过调用本教程链接库的 WriteChar 将其显示在控制台：</p><pre><code>mPutchar MACRO char    push eax    mov al,char    call WriteChar    pop eaxENDM</code></pre><h2 id="汇编语言宏的调用简述"><a href="#汇编语言宏的调用简述" class="headerlink" title="汇编语言宏的调用简述"></a>汇编语言宏的调用简述</h2><p>调用宏的方法是把宏名插入到程序中，后面可能跟有宏的实参。宏调用语法如下：</p><pre><code>macroname argument-1, argument-2,</code></pre><p>Macroname 必须是源代码中在此之前被定义宏的名称。每个实参都是文本值，用以替换宏的一个形参。实参的顺序要与形参一致，但是两者的数量不须相同。如果传递的实参数太 多，则汇编器会发出警告。如果传递给宏的实参数太少，则未填充的形参保持为空。</p><h4 id="调用-mPutChar"><a href="#调用-mPutChar" class="headerlink" title="调用 mPutChar"></a>调用 mPutChar</h4><p>上一节《MACRO和ENDM伪指令》中定义了宏 mPutChar。调用 mPutChar 时，可以传递任何字符或 ASCII 码。下面的语句调用了 mPutChar，并向其传递了字母 “A”：</p><pre><code>mPutchar 'A'</code></pre><p>汇编器的预处理程序将这条语句展开为下述代码，以列表文件的形式展开如下：</p><pre><code>1 push eax1 mov al,'A'1 call WriteChar1 pop eax</code></pre><p>左侧的 1 表示宏展开的层次，如果在宏的内部又调用了其他的宏，那么该值将会增加。下面的循环显示了字母表中前 20 个字母：</p><pre><code>   mov al,'A'   mov ecx,20L1:   mPutchar al           ;宏调用   inc al   loop L1</code></pre><p>该循环由预处理程序在下面的代码中展开（源列表文件中可见），其中，宏调用在其展开的前面：</p><pre><code>   mov al,'A'   mov ecx,20L1:   mPutchar al   ;调用宏   1 push eax   1 mov al,al   1 call WriteChar   1 pop eax   inc al   loop L1</code></pre><blockquote><p>提示：与过程相比，宏执行起来更快，其原因是过程的 CALL 和 RET 指令需要额外的开销。但是，使用宏也有缺点：重复使用大型宏会增加程序的大小，因为，每次调用宏都会在程序中插入宏代码的一个新副本。</p></blockquote><h4 id="调试宏"><a href="#调试宏" class="headerlink" title="调试宏"></a>调试宏</h4><p>调试使用了宏的程序相当具有挑战性。程序汇编之后，检查其列表文件（扩展名为 .LST) 以确保每个宏都按照程序员的要求展开。然后，在Visual Studio 调试器中启动该程序，在调试窗口点击右键，从弹出菜单中选择Go to Disassemblyo每个宏调用的后面都紧 跟其生成代码。示例如下：</p><pre><code>mWriteAt 15,10,"Hi there"    push edx    mov dh, 0Ah    mov dl, 0Fh    call _Gotoxy@0 (401551h)    pop edx    push edx    mov edx,offset ??0000 (405004h)    call _WriteString@0 (401D64h)pop edx</code></pre><p>由于 Irvine32 链接库使用的是 STDCALL 调用规范，因此函数名用下划线 (_) 开始。</p><h2 id="汇编语言宏的特性"><a href="#汇编语言宏的特性" class="headerlink" title="汇编语言宏的特性"></a>汇编语言宏的特性</h2><h4 id="1-规定形参"><a href="#1-规定形参" class="headerlink" title="1) 规定形参"></a>1) 规定形参</h4><p>利用 REQ 限定符，可以指定必需的宏形参。如果被调用的宏没有实参与规定形参相匹配，那么汇编器将显示出错消息。如果一个宏有多个规定形参，则每个形参都要使用 REQ 限定符。</p><p>下面是宏 mPutChar，形参 char 是必需的：</p><pre><code>mPutchar MACRO char:REQ    push eax    mov al,char    call WriteChar    pop eaxENDM</code></pre><h4 id="2-宏注释"><a href="#2-宏注释" class="headerlink" title="2) 宏注释"></a>2) 宏注释</h4><p>宏定义中的注释行一般都出现在每次宏展开的时候。如果希望忽略宏展开时的注释，就在它们的前面添加双分号 (;;)。示例如下：</p><pre><code>mPutchar MACRO char:REQ    push eax             ;; 提示：char 必须包含 8 个比特    mov al, char    call WriteChar    pop eaxENDM</code></pre><h4 id="3-ECHO-伪指令"><a href="#3-ECHO-伪指令" class="headerlink" title="3) ECHO 伪指令"></a>3) ECHO 伪指令</h4><p>在程序汇编时，ECHO 伪指令写一个字符串到标准输出。下面的 mPutChar 在汇编时会显示消息“Expanding the mPutChar macro” :</p><pre><code>mPutchar MACRO char:REQ    ECHO Expanding the mPutchar macro    push eax    mov al,char    call WriteChar    pop eaxENDM</code></pre><p>Visual Studio 2012 的控制台窗口不会捕捉 ECHO 伪指令的输出，除非在编写程序时将其设置为生成详细输出。设置方法如下：从 Tool 菜单选择 Options，选择 Projects and Solutions，选择 Build and Run，再从 MSBuild project build output verbosity 下拉列表中选择 Detailed。或者打开一个命令提示符并汇编程序。</p><p>首先，执行如下命令，调整 Visual Studio 当前版本的路径：   </p><pre><code>"C:\Program Files\Microsoft Visual Studio 11.0\VC\bin\vcvars32"</code></pre><p>然后，键入如下指令，其中 filename.asm 是程序的源代码文件名：</p><pre><code>ml.exe /c /I "c:\Irvine" filename.asm</code></pre><h4 id="4-LOCAL-伪指令"><a href="#4-LOCAL-伪指令" class="headerlink" title="4) LOCAL 伪指令"></a>4) LOCAL 伪指令</h4><p>宏定义中常常包含了标号，并会在其代码中对这些标号进行自引用。例如，下面的宏 makeString 声明了一个变量 string，且将其初始化为字符数组：</p><pre><code>makestring MACRO text    .data    string BYTE text,0ENDM</code></pre><p>假设两次调用宏：</p><pre><code>makeString "Hello"makeString "Goodbye"</code></pre><p>由于汇编器不允许两个标号有相同的名字，因此结果出现错误：</p><pre><code>makeString "Hello"1 .data1 string BYTE "Hello",0 makeString "Goodbye"1 .data1 string BYTE "Goodbye",0     ;错误！</code></pre><h4 id="使用-LOCAL"><a href="#使用-LOCAL" class="headerlink" title="使用 LOCAL"></a>使用 LOCAL</h4><p>为了避免标号重命名带来的问题，可以对一个宏定义内的标号使用 LOCAL 伪指令。若标号被标记为 LOCAL，那么每次进行宏展开时，预处理程序就把标号名转换为唯一的标识符。下面是使用了 LOCAL 的宏 makeString：</p><pre><code>makeString MACRO text    LOCAL string    .data    string BYTE text,0ENDM</code></pre><p>假设和前面一样，也是两次调用宏，预处理程序生成的代码会将每个string替换成唯一 的标识符：</p><pre><code>makeString "Hello"1 .data1 ??0000 BYTE "Hello",0 makeString "Goodbye"1 .data1 ??0001 BYTE "Goodbye",0</code></pre><p>汇编器生成的标号名使用了 ??nnnn 的形式，其中 nnnn 是具有唯一性的整数。local 伪指令还可以用于宏内的代码标号。</p><h4 id="5-包含代码和数据的宏"><a href="#5-包含代码和数据的宏" class="headerlink" title="5) 包含代码和数据的宏"></a>5) 包含代码和数据的宏</h4><p>宏通常既包含代码又包含数据。例如，下面的宏mWrite在控制台显示文本字符串：</p><pre><code>mWrite MACRO text    LOCAL string            ;;local号    .data                   ;;定义字符串    string BYTE text,0    .code    push edx    mov edx, OFFSET string    call WriteString    pop edxENDM</code></pre><p>下面的语句两次调用宏，并向其传递不同的字符串文本：</p><pre><code>mWrite "Please enter your first name"mWrite "Please enter your last name"</code></pre><p>汇编器对这两条语句进行展开时，每个字符串都被赋予了唯一的标号，且MOV指令也 作了相应的调整：</p><pre><code>mWrite "Please enter your first name"1 .data1 ??0000 BYTE "Please enter your first name",01 .code1 push edx1 mov edx, OFFSET ??00001 call WriteString1 pop edx mWrite "Please enter your last name"1 .data1 ??0001 BYTE "Please enter your last name", 01 .code1 push edx1 mov edx, OFFSET ??00011 call Writestring1 pop edx</code></pre><h4 id="6-宏嵌套"><a href="#6-宏嵌套" class="headerlink" title="6) 宏嵌套"></a>6) 宏嵌套</h4><p>被其他宏调用的宏称为被嵌套的宏 (nested macro)。当汇编器的预处理程序遇到对被嵌套宏的调用时，它会就地展开该宏。传递给主调宏的形参也将直接传递给它的被嵌套宏。</p><p>提示：使用模块方法创建宏。保持它们的简短性，以便将它们组合到更复杂的宏内。这样有助于减少程序中的复制代码量。</p><p>【示例】下面的宏 mWritein 写一个字符串文本到控制台，并添加换行符。它调用宏 mWrite 和 Crlf 过程：</p><pre><code>mWriteln MACRO text    mWrite text    call CrlfENDM</code></pre><p>形参 text 被直接传递给 mWrite。假设用下述语句调用 mWriteln：</p><pre><code>mWriteln "My Sample Macro Program"</code></pre><p>在结果代码展开，语句旁边的嵌套级数（2）表示被调用的是一个嵌套宏：</p><pre><code>mWriteln "My Sample Macro Program"2  .data2  ??0002 BYTE "My Sample Macro Program",02  .code2  push edx2  mov   edx,OFFSET ??00022  call WriteString2  pop   edx1  call Crlf</code></pre><h2 id="汇编语言Macro宏库详解"><a href="#汇编语言Macro宏库详解" class="headerlink" title="汇编语言Macro宏库详解"></a>汇编语言Macro宏库详解</h2><p>示例程序包含了一个小而实用的 32 位链接库，只需要在程序的 INCLUDE 后面添加如下代码行就可以使用该链接库：</p><pre><code>INCLUDE Macros.inc</code></pre><p>有些宏封装在了 Irvine32 链接库的过程中，这样传递参数就更加容易。其他宏则提供新的功能。下表详细介绍了每个宏。</p><table><thead><tr><th>宏名</th><th>形式参数</th><th>说明</th></tr></thead><tbody><tr><td>mDump</td><td>varName, useLabel</td><td>用变量名和默认属性显示一个变量</td></tr><tr><td>mDumpMem</td><td>abbress, itemCount, componentsize</td><td>显示内存区域</td></tr><tr><td>mGotoxy</td><td>X,Y</td><td>将光标位置设置在控制台窗口缓冲区</td></tr><tr><td>mReadString</td><td>varName</td><td>从键盘读取一个字符串</td></tr><tr><td>mShow</td><td>itsName, format</td><td>用各种格式显示一个变量或寄存器</td></tr><tr><td>mShowRegister</td><td>itsName, regValue</td><td>显示32位寄存器名，并用十六进制显示其内容</td></tr><tr><td>mWrite</td><td>text</td><td>向控制台窗口输出一个字符串文本</td></tr><tr><td>mWriteSpace</td><td>count</td><td>向控制台窗口输出一个或多个空格</td></tr><tr><td>mWriteString</td><td>buffer</td><td>向控制台窗口输岀一个字符串变量的内容</td></tr></tbody></table><h4 id="1-mDumpMem"><a href="#1-mDumpMem" class="headerlink" title="1) mDumpMem"></a>1) mDumpMem</h4><p>宏 mDumpMem 在控制台窗口显示一个内存区域。向其传递的第一个实参为包含待显示内存偏移量的常数、寄存器或者变量，第二个实参应为待显示内存中存储对象的数量，第三个实参为每个存储对象的大小。</p><p>宏在调用mDumpMem库过程时，分别将这三个实参分配给 ESI、ECX 和 EBX。现假设有一数据定义如下：</p><pre><code>.dataarray DWORD 1000h, 2000h, 3000h, 4000h</code></pre><p>下面的语句按照默认属性显示数组:</p><pre><code>mDumpMem OFFSET array, LENGTHOF array, TYPE array</code></pre><p>输出为：</p><pre><code>Dump of offset 00405004------------------------------00001000 00002000 00003000 00004000</code></pre><p>下面的语句则将同一个数组显示为字节序列：</p><pre><code>mDumpMem OFFSET array, SIZEOF array, TYPE BYTE</code></pre><p>输出为：</p><pre><code>Dump of offset 00405004------------------------------00 10 00 00 00 20 00 00 00 30 00 00 00 40 00 00</code></pre><p>下面的代码把三个数值压入堆栈，并设置好 EBX、ECX 和 ESI，然后调用 mDumpMem 显示堆栈：</p><pre><code>mov eax,0AAAAAAAAhpush eaxmov eax,0BBBBBBBBhpush eaxmov eax,OCCCCCCCChpush eaxmov ebx,1mov ecx,2mov esi,3mDumpMem esp, 8, TYPE DWORD</code></pre><p>显示出来的结果堆栈区域表明，宏已经先把 EBX、ECX 和 ESI 压入了堆栈。这些数值之后是在调用 mDumpMem 之前入栈的 3 个整数：</p><pre><code>Dump of offset 0012FFAC------------------------------00000003 00000002 00000001 CCCCCCCC BBBBBBBB AAAAAAAA 7C816D4F0000001A</code></pre><p>实现宏代码清单如下：</p><pre><code>mDumpMem MACRO address:REQ, itemCount:REQ, componentsize:REQ;用 DumpMem 过程显示一个内存区域。;接收：内存偏移量、显示对象的数量，以及每个存储对象的大小。;避免用 EBX、ECX 和 ESI 传递实参。    push ebx    push ecx    push esi    mov esi, address    mov ecx, itemCount    mov ebx, componentSize    call DumpMem    pop esi    pop ecx    pop ebxENDM2) mDump</code></pre><p>宏 mDump 用十六进制显示一个变量的地址和内容。传递给它的参数有：变量名和（可选的）一个字符以表明在该变量之后应显示的标号。显示格式自动与变量的大小属性（BYTE、WORD 或 DWORD）匹配。</p><p>下面的例子展示了对 mDump 的两次调用:：</p><pre><code>.datadiskSize DWORD 12345h.codemDump diskSize      ; no labelmDump diskSize,Y       ; show label</code></pre><p>代码执行后，产生的输出如下所示：</p><pre><code>Dump of cffset 00405000------------------------00012345Variable name: diskSizeDump of offset 00405000------------------------00012345</code></pre><p>下面是宏 mDump 的代码清单，它反过来又调用了 mDumpMem。代码用一个新的伪指令 IFNE （若不为空）来发现主调者是否向第二个形参传递了实参：</p><pre><code>;-----------------------------------------------mDump MACRO varName:REQ, useLabel;用其已知属性显示一个变量。;接收：varName为变量名。;如果 useLabel 不为空，则显示变量名。;-----------------------------------------------    call Crlf    IFNB &lt;useLabel&gt;        mWrite "Variable name: &amp;varName"    ENDIF    mDumpMem OFFSET varName, LENGTHOF varName, TYPE varNameENDM</code></pre><p>&amp;varName 中的符号 &amp; 是替换操作符，它允许将 varName 形参的值插入到字符串文本中。</p><h4 id="3-mGotoxy"><a href="#3-mGotoxy" class="headerlink" title="3) mGotoxy"></a>3) mGotoxy</h4><p>宏 mGotoxy 把光标定位在控制台窗口缓冲区内指定的行列上。可以向其传递 8 位立即数、内存操作数和寄存器值：</p><pre><code>mGotoxy   10,20                 ;立即数mGotoxy   row, col             ;内存操作数mGotoxy   ch,cl                 ;寄存器值</code></pre><p>实现 下面是宏的源代码清单：</p><pre><code>;-----------------------------mGotoxy MACRO X:REQ, Y:REQ;设置光标在控制台窗口的位置。;接收：X和Y坐标（类型为BYTE）。避免用DH和DL传递实参。;-----------------------------    push edx    mov dh,Y    mov dl,X    call Gotoxy    pop edxENDM</code></pre><p>若宏的实参是寄存器，它们有时可能会与宏内使用的寄存器发生冲突。比如，调用 mGotoxy 时用了 DH 和 DL，那么就不会生成正确的代码。为了说明原因，现在来查看上述参数被替换后展开的代码：</p><pre><code>1 push edx2 mov dhr dl    ;;行3 mov dl,dh   ;;列4 call Gotoxy5 pop edx</code></pre><p>假设 DL 传递的是 Y 值，DH 传递的是 X 值，代码行 2 会在代码行 3 有机会把列值复制 到DL之前就替换了 DH的原值。</p><blockquote><p>提示：只要有可能，宏定义应该用注释说明哪些寄存器不能用作实参。</p></blockquote><h4 id="4-mReadString"><a href="#4-mReadString" class="headerlink" title="4) mReadString"></a>4) mReadString</h4><p>宏 mReadSrting 从键盘读取一个字符串，并将其存储在缓冲区。在这个宏的内部封装了一个对 ReadString 库过程的调用。需向其传递缓冲区名：</p><pre><code>.datafirstName BYTE 30 DUP(?).codemReadString firstName</code></pre><p>下面是宏的源代码：</p><pre><code>;-----------------------------------------   mReadString MACRO varName:REQ;从标准输入读到缓冲区。;接收:缓冲区名。避免用 ECX 和 EDX 传递实参。;-----------------------------------------       push ecx    push edx    mov edx,OFFSET varName    mov ecx,SIZEOF varName    call Readstring    pop edx    pop ecxENDM5) mShow</code></pre><p>宏 mShow 按照主调者选择的格式显示任何寄存器或变量的名字和内容。传递给它的是寄存器名，其后可选择性地加上一个字母序列，以表明期望的格式。字母选择如下：H = 十六进制，D = 无符号十进制，I 二有符号十进制，B 二二进制，N = 换行。</p><p>可以组合多种输出格式，还可以指定多个换行。默认格式为“HIN”。mShow 是一种有用的辅助调试工具，经常被 DumpRegs 库过程使用。可以把mShow当作调试工具，显示重要寄存器或变量的值。</p><p>【示例】下面的语句将 AX 寄存器的值显示为十六进制、有符号十进制、无符号十进制和二进制：</p><pre><code>mov ax, 4096mShow AX       ;默认选项：HTNmShow AX,DBN   ;无符号十进制，二进制，换行</code></pre><p>输出如下：</p><pre><code>AX = 1000h +4096dAX = 4096d 0001 0000 0000 0000b</code></pre><p>【示例】下面的语句在同一行上，用无符号十进制格式显示 AX, BX, CX 和 DX：</p><pre><code>;插入测试数值，显示4个寄存器：mov ax, 1mov bx, 2mov cx, 3mov dxz 4mShow AX, DmShow BX, DmShow CX,DmShow DX, DN</code></pre><p>相应输出如下：AX = Id BX = 2d CX = 3d DX = 4d</p><p>【示例】下面的代码调用 mShow，用无符号十进制格式显示 mydword 的内容，并换行：</p><pre><code>.datamydword. DWORD ?.codemS how mydword,DN</code></pre><p>实现 mShow的实现代码太长不便在这里给岀，不过可以在本书安装文件夹（C ： \Irvine）内的Macros.inc文件中找到完整代码。在编写mShow时，需要注意在寄存器被宏 自身的内部语句修改之前显示其当前值。</p><h4 id="6-mShowRegister"><a href="#6-mShowRegister" class="headerlink" title="6) mShowRegister"></a>6) mShowRegister</h4><p>宏 mShowRegister 显示单个 32 位寄存器的名称，并用十六进制格式显示其内容。传递给它的是希望被显示的寄存器名，其后紧跟寄存器本身。下面的宏调用指定了被显示的名称为 EBX：</p><pre><code>mShowRegister EBX, ebx</code></pre><p>产生的输出如下：</p><pre><code>EBX=7FFD9000</code></pre><p>下面的调用使用尖括号把标号括起来，其原因是标号内有一个空格：</p><pre><code>mShowRegister &lt;Stack Pointer&gt;, esp</code></pre><p>产生输出如下：</p><pre><code>Stack Pointer=0012FFC0</code></pre><p>实现宏的源代码如下：</p><pre><code>;------------------------------------mShowRegister MACRO regName, regValueLOCAL tempStr;显示寄存器名和内容。;接收：寄存器名，寄存器值;------------------------------------    .data    tempStr BYTE " &amp;regName=",0    .code    push eax    ;显示寄存器名    push edx    mov edx,OFFSET tempStr    call WriteString    pop edx    ;显示寄存器内容    mov eax,regValue    call WriteHex    pop eaxENDM</code></pre><h4 id="7-mWriteSpace"><a href="#7-mWriteSpace" class="headerlink" title="7) mWriteSpace"></a>7) mWriteSpace</h4><p>宏 mWriteSpace 向控制台窗口输出一个或多个空格。可以选择性地向其传递一个整数形参，以指定空格数 ( 默认为一个 )。例如，下面的语句写了 5 个空格：</p><pre><code>mWriteSpace 5</code></pre><p>实现mWriteSpace的源代码如下：</p><pre><code>;-------------------------------------------mWriteSpace MACRO count:=&lt;1&gt;;向控制台窗口输出一个或多个空格。;接收：一个整数以指定空格数。;默认个数为l。;-------------------------------------------LOCAL spaces.dataspaces BYTE count DUP('    '),0.code    push edx    mov edx,OFFSET spaces    call WriteString    pop edxENDM</code></pre><h4 id="8-mWriteString"><a href="#8-mWriteString" class="headerlink" title="8) mWriteString"></a>8) mWriteString</h4><p>宏 mWriteSrting 向控制台窗口输出一个字符串变量的内容。从宏的内部来看，它通过在同一语句行上传递字符串变量名简化了对 WriteString的调用。例如：</p><pre><code>.datastr1 BYTE "Please enter your name: ", 0.codemWriteString str1</code></pre><p>mWriteString 的实现如下，它将 EDX 保存到堆栈，然后把字符串偏移量赋给 EDX，在过程调用后，再从堆栈恢复 EDX 的值：</p><pre><code>;------------------------------mWriteString MACRO buffer:REQ;向标准输出写一个字符串变量。;接收：字符串变量名。;------------------------------    push edx    mov    edx,OFFSET buffer    call WriteString    pop edxENDM</code></pre><h2 id="汇编语言实例：封装器"><a href="#汇编语言实例：封装器" class="headerlink" title="汇编语言实例：封装器"></a>汇编语言实例：封装器</h2><p>现在创建一个简短的程序 Wraps.asm 来展示之前已介绍的作为过程封装器的宏。由于每个宏都隐含了大量繁琐的参数传递，因此程序出奇得紧凑。假设这里所有的宏当前都在 Macros.inc 文件内：</p><pre><code>; 过程封装器宏        (Wraps.asm); 本程序演示宏作为库过程的封装器。; 内容: mGotoxy, mWrite, mWriteString, mReadString, 和 mDumpMem.INCLUDE Irvine32.incINCLUDE Macros.inc            ; 宏定义.dataarray DWORD 1,2,3,4,5,6,7,8firstName BYTE 31 DUP(?)lastName  BYTE 31 DUP(?).codemain PROC    mGotoxy 0,0    mWrite &lt;"Sample Macro Program",0dh,0ah&gt;; 输入用户名    mGotoxy 0,5    mWrite "Please enter your first name: "    mReadString firstName    call Crlf    mWrite "Please enter your last name: "    mReadString lastName    call Crlf; 显示用户名    mWrite "Your name is "    mWriteString firstName    mWriteSpace    mWriteString lastName    call Crlf; 显示整数数组    mDumpMem OFFSET array,LENGTHOF array, TYPE array    exitmain ENDPEND main</code></pre><p>程序输出 程序输出的示例如下：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226024408277" alt="img"></p><h2 id="汇编语言条件汇编伪指令简述"><a href="#汇编语言条件汇编伪指令简述" class="headerlink" title="汇编语言条件汇编伪指令简述"></a>汇编语言条件汇编伪指令简述</h2><p>很多不同的条件汇编伪指令都可以和宏一起使用，这使得宏更加灵活。条件汇编伪指令常用语法如下所示：</p><pre><code>IF condition  statements[ELSE  statements]ENDIF</code></pre><p>下表列出了更多常用的条件汇编伪指令。若说明为该伪指令允许汇编，就意味着所有的后续语句都将被汇编，直到遇到下一个 ELSE 或 ENDIF 伪指令。必须强调的是，表中列出的伪指令是在汇编时而不是运行时计算。</p><table><thead><tr><th>伪指令</th><th>说明</th></tr></thead><tbody><tr><td>IF expression</td><td>若 expression 为真（非零）则允许汇编。可能的关系运算符为 LT、GT、EQ、NE、LE 和 GE</td></tr><tr><td>IFB<argument></argument></td><td>若 argument 为空则允许汇编。实参名必须用尖括号（＜＞）括起来</td></tr><tr><td>IFNB<argument></argument></td><td>若 argument 为非空则允许汇编。实参名必须用尖括号（＜＞）括起来</td></tr><tr><td>IFIDN<arg1>,<arg2></arg2></arg1></td><td>若两个实参相等（相同）则允许汇编。采用区分大小写的比较</td></tr><tr><td>IFIDNI<arg1>,<arg2></arg2></arg1></td><td>若两个实参相等（相同）则允许汇编。采用不区分大小写的比较</td></tr><tr><td>IFDIF<arg1>,<arg2></arg2></arg1></td><td>若两个实参不相等则允许汇编。采用区分大小写的比较</td></tr><tr><td>IFDIFI<arg1>,<arg2></arg2></arg1></td><td>若两个实参不相等则允许汇编。采用不区分大小写的比较</td></tr><tr><td>IFDIF name</td><td>若 name 已定义则允许汇编</td></tr><tr><td>IFNDEF name</td><td>若 name 还未定义则允许汇编</td></tr><tr><td>ENDIF</td><td>结束用一个条件汇编伪指令开始的代码块</td></tr><tr><td>ELSE</td><td>若条件为真，则终止汇编之前的语句。若条件为假，ELSE 汇编语句直到遇到下一个 ENDIF</td></tr><tr><td>ELSEIF expression</td><td>若之前条件伪指令指定的条件为假，而当前表达式为真，则汇编全部语句直到出现 ENDIF</td></tr><tr><td>EXITM</td><td>立即退出宏，阻止所有后续宏语句的展开</td></tr></tbody></table><h2 id="汇编语言IFB和IFNB伪指令：检查缺失的参数"><a href="#汇编语言IFB和IFNB伪指令：检查缺失的参数" class="headerlink" title="汇编语言IFB和IFNB伪指令：检查缺失的参数"></a>汇编语言IFB和IFNB伪指令：检查缺失的参数</h2><p>宏能够检查其参数是否为空。通常，宏若接收到空参数，则预处理程序在进行宏展开时会导致出现无效指令。例如，如果调用宏 mWriteString 却又不传递实参，那么宏展开在把字符串偏移量传递给 EDX 时，就会出现无效指令。</p><p>汇编器生成的如下语句检测出缺失的操作数，并产生了一个错误消息：</p><pre><code>mWriteString1 push edx1 mov edx,OFFSETMacro2.asm(18) : error A2081: missing operand after unary operator1 call WriteString1 pop edx</code></pre><p>为了防止由于操作数缺失而导致的错误，可以使用 IFB (if blank) 伪指令，若宏实参为空，则该伪指令返回值为真。</p><p>还可以使用 IFNB (if not blank) 运算符，若宏实参不为空，则其返回值为真。现在编写 mWriteString 的另一个版本，使其可以在汇编时显示错误消息：</p><pre><code>mWriteString MACRO string    IFB &lt;string&gt;        ECHO -------------------------------------------        ECHO * Error: parameter missing in mWriteString        ECHO *  (no code generated)        ECHO -------------------------------------------    EXITM    ENDIF    push edx    mov edx,OFFSET string    call WriteString    pop edxENDM</code></pre><p>程序汇编时，ECHO 伪指令向控制台写一个消息。EXITM 伪指令告诉预处理程序退岀宏，不再展开更多宏语句。汇编的程序有缺失参数时，其屏幕输出如下所示：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226043378279" alt="img"></p><h2 id="汇编语言宏默认值设定及布尔表达式简述"><a href="#汇编语言宏默认值设定及布尔表达式简述" class="headerlink" title="汇编语言宏默认值设定及布尔表达式简述"></a>汇编语言宏默认值设定及布尔表达式简述</h2><p>宏可以有默认参数初始值。如果调用宏出现了宏参数缺失，那么就可以使用默认参数。其语法如下：</p><pre><code>paramname := &lt; argument &gt;</code></pre><p>运算符前后的空格是可选的。比如，宏 mWriteln 提供含有一个空格的字符串作为其默认参数。如果对其进行无参数调用，它仍然会打印一个空格并换行：</p><pre><code>mWriteln MACRO text:=&lt;" "&gt;  mWrite text  call CrlfENDM</code></pre><p>若把空字符串 (“ “) 作为默认参数，那么汇编器会产生错误，因此必须在引号之间至少插入一个空格。</p><h4 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h4><p>汇编器允许在包含 IF 和其他条件伪指令的常量布尔表达式中使用下列关系运算符：</p><table><thead><tr><th>LT</th><th>小于</th></tr></thead><tbody><tr><td>GT</td><td>大于</td></tr><tr><td>EQ</td><td>等于</td></tr><tr><td>NE</td><td>不等于</td></tr><tr><td>LE</td><td>小于等于</td></tr><tr><td>GE</td><td>大于等于</td></tr></tbody></table><h2 id="汇编语言IF、ELSE和DENDIF伪指令"><a href="#汇编语言IF、ELSE和DENDIF伪指令" class="headerlink" title="汇编语言IF、ELSE和DENDIF伪指令"></a>汇编语言IF、ELSE和DENDIF伪指令</h2><p>IF 伪指令的后面必须跟一个常量布尔表达式。该表达式可以包含整数常量、符号常量或者常量宏实参，但不能包含寄存器或变量名。仅适用于 IF 和 ENDIF 的语法格式如下：</p><pre><code>IF expression   statement-listENDIF</code></pre><p>另一种格式则适用于 IF、ELSE 和 ENDIF：</p><pre><code>IF expression   statement-listELSE   statement-listENDIF</code></pre><p>【示例】宏 mGotoxyConst 利用 LT 和 GT 运算符对传递给宏的参数进行范围检查。实参 X 和 Y 必须为常数。还有一个常数符号 ERRS 对发现的错误进行计数。根据 X 的值，可以将 ERRS 设置为 1。根据 Y 的值，可以将 ERRS 加 1。最后，如果 ERRS 大于零，EXITM 伪指令退岀宏：</p><pre><code>;-------------------------------------mGotoxyConst MACRO X:REQ, Y:REQ;;将光标位置设置在 X 列 Y 行。;要求 X 和 Y 的坐标为常量表达式;其范围为 0 ≤ X &lt; 80, 0 ≤ Y &lt; 25。;-------------------------------------    LOCAL ERRS               ;;门局部常量    ERRS = 0    IF (X LT 0) OR (X GT 79)        ECHO Warning: First argument to mGotoxy (X) is out of range.        ECHO ******************************************************        ERRS = 1    ENDIF    IF (Y LT 0) OR (Y GT 24)        ECHO Warning: Second argument to mGotoxy (Y) is out of range.        ECHO ******************************************************        ERRS = ERRS + 1    ENDIF    IF ERRS GT 0                 ;;若发现错误，        EXITM                    ;;退出宏    ENCIF    push edx    mov dh,Y    mov dl,X    call Gotoxy    pop edxENDM</code></pre><h2 id="汇编语言IFIDN和IFIDNI伪指令：对两个参数进行比较"><a href="#汇编语言IFIDN和IFIDNI伪指令：对两个参数进行比较" class="headerlink" title="汇编语言IFIDN和IFIDNI伪指令：对两个参数进行比较"></a>汇编语言IFIDN和IFIDNI伪指令：对两个参数进行比较</h2><p>IFIDNI 伪指令在两个符号（包括宏参数名）之间进行不区分大小写的比较，如果它们相等，则返回真。IFIDN 伪指令执行的是区分大小写的比较。</p><p>如果想要确认宏主调者使用的寄存器参数不会与宏内使用的寄存器发生冲突，那么可以使用这两个伪指令中的前者。IFIDNI 的语法如下：</p><pre><code>IFIDNI &lt;symbol&gt;, &lt;symbol&gt;   statementsENDIF</code></pre><p>IFIDN 的语法与之相同。例如下面的宏 mReadBuf，其第二个参数不能用 EDX，因为当 buffer 的偏移量被送入 EDX 时，原来的值就会被覆盖。</p><p>在如下修改过的宏代码中，如果这个条件不满足，就会显示一条警告消息：</p><pre><code>;-------------------------------------mReadBuf MACRO bufferPtr, maxChars;将键盘输入读到缓冲区。;接收：缓冲区偏移量，最多可输入字符的数量。第二个参数不能用 edx 或EDX。;-------------------------------------    IFIDNI &lt;maxChars&gt;,&lt;EDX&gt;        ECHO Warning: Second argument to mReadBuf cannot be EDX        ECHO **************************************************        EXITM    ENDIF    push ecx    push edx    mov edx,bufferPtr    mov ecx,maxChars    call Readstring    pop edx    pop ecxENDM</code></pre><p>下面的语句将会导致宏产生警告消息，因为 EDX 是其第二个参数：</p><pre><code>mReadBuf OFFSET buffer,edx</code></pre><h2 id="汇编语言实例：矩阵行求和"><a href="#汇编语言实例：矩阵行求和" class="headerlink" title="汇编语言实例：矩阵行求和"></a>汇编语言实例：矩阵行求和</h2><p>前面已经展示了如何计算字节矩阵中单个行的总和。尽管这个解决方案有些冗长，现在还是要看看能否用宏来简化任务。首先，我们来回顾一下 calc_row_sum 过程：</p><pre><code>;------------------------------------------------------------; calc_row_sum; 计算字节矩阵中一行的和数; 接收: EBX = 表偏移量, EAX = 行索引;       ECX = 按字节计的行大小; 返回:  EAX 为和数;------------------------------------------------------------calc_row_sum PROC uses ebx ecx edx esi    mul     ecx                             ; 行索引 * 行大小    add     ebx,eax                         ; 行偏移量    mov     eax,0                           ; 累加器    mov     esi,0                           ; 列索引L1:    movzx edx,BYTE PTR[ebx + esi]        ; 取一个字节    add     eax,edx                         ; 与累加器相加    inc     esi                             ; 行中的下一个字节    loop L1    retcalc_row_sum ENDP</code></pre><p>从把 PROC 改为 MACRO 开始，删除 RET 指令，把 ENDP 改为 ENDM。由于没有宏与 USES 伪指令功能相当，因此插入 PUSH 和 POP 指令：</p><pre><code>mCalc_row_sum MACRO    push ebx              ;保存被修改的寄存器    push ecx    push esi    mul ecx               ;行索引x行大小    add ebx,eax           ;行偏移量    mov eax,0             ;累加器    mov esi,0             ;列索引L1: movzx edx,BYTE PTR[ebx + esi]    add eax, edx          ;取一个字节    inc esi               ;与累加器相加    loop L1               ;行内的下一个字节    pop esi               ;恢复被修改的寄存器    pop ecx    pop ebxENDM</code></pre><p>接着，用宏参数代替寄存器参数，并对宏内寄存器进行初始化：</p><pre><code>mCalc_row_sum MACRO index, arrayoffset, rowSize    push ebx                       ;保存被修改的寄存器    push ecx    push esi;设置需要的寄存器    mov eax,index    mov ebx,arrayOffset    mov ecx,rowSize    mul ecx                        ;行索引x行大小    add ebx,eax                    ;行偏移量    mov eax,0                      ;累加器    mov esi,0                      ;列索引L1: movzx edx, BYTE PTR[ebx + esi] ;取一个字节    add eax, edx                   ;与累力口器相力口    inc esi                        ;行内的下一个字节    loop L1    pop esi                        ;恢复被修改的寄存器    pop ecx    pop ebxENDM</code></pre><p>然后，添加一个参数 eltType 指定数组类型 (BYTE、WORD 或 DWORD)：</p><pre><code>mCalc_row_sum MACRO index, arrayOffset, rowSize, eltType</code></pre><p>复制到 ECX 的参数 rowSize 现在表示的是每行的字节数。如果要用其作为循环计数器，那么它就必须转换为每行的元素 (element) 个数。</p><p>因此，若为 16 位数组，就将 ECX 除以 2 ;若为双字数组，就将 ECX 除以 4。实现上述操作的快捷方式为：eltType 除以 2，把商作为移位计数器，再将 ECX 右移：</p><pre><code>shr ecx,(TYPE eltType/2)         ; byte=0, word=1, dword=2</code></pre><p>TYPE eltType 就成为 MOVZX 指令中基址-变址操作数的比例因子：</p><pre><code>movzx edx,eltType PTR[ebx + esi*(TYPE eltType)]</code></pre><p>若 MOVZX 右操作数为双字，那么指令不会汇编。所以，当 eltType 为 DWORD 时，需要用 IFIDNI 运算符另外编写一条 MOV 指令：</p><pre><code>IFIDNI &lt;eltType&gt;,&lt;DWORD&gt;   mov edx,eltType PTR[ebx + esi*(TYPE eltType)]ELSE   movzx edx, eltType PTR[ebx + esi*(TYPE eltType)]ENDIF</code></pre><p>最后必须结束宏，记住要把标号 L1 指定为 LOCAL：</p><pre><code>;-----------------------------------------------------mCa1c_row_sum MACRO index, arrayOffset, rowSize, eltType;计算二维数组中一行的和数。;接收：行索引、数组偏移量、每行的字节数、数组类型 (BYTE、WORD、或 DWORD)。;返回：EAX= 和数。;-----------------------------------------------------LOCAL L1    push ebx                    ;保存被修改的寄存器    push ecx    push esi;设置需要的寄存器    mov eax, index    mov ebx, arrayOffset    mov ecx, rowSize;计算行偏移量    mul ecx                      ;行索引x行大小    add ebx, eax                 ;行偏移量;初始化循环计数器    shr ecx,(TYPE eltType/2)     ;byte=0, word=1, dword=2;初始化累加器和列索引    mov eax,0                    ;累加器    mov esi,0                    ;列索引L1:    IFIDNI &lt;eltType&gt;, &lt;DWORD&gt;        mov edx,eltType PTR[ebx + esi*(TYPE eltType)]    ELSE        movzx edx,eltType PTR[ebx + esi*(TYPE eltType)]    ENDIF    add eax,edx                  ;与累加器相加    inc esi    loop L1    pop esi                      ;恢复被修改的寄存器    pop ecx    pop ebxENDM</code></pre><p>下面用字节数组、字数组和双字数组对宏进行示例调用：</p><pre><code>.datatableB BYTE 10h, 20h, 30h, 40h, 50hRowSizeB = ($ - tableB)    BYTE 60h, 70h, 80h, 90h, 0A0h    BYTE 0B0h, 0C0h, 0D0h, 0E0h, 0F0htableW WORD 10h, 20h, 30h, 40h, 50hRowSizeW = ($ - tableW)    WORD 60h, 70h, 80h, 90h, 0A0h    WORD 0B0h, 0C0h, 0D0h, 0E0h, 0F0htableD DWORD 10h, 20h, 30h, 40h, 50hRowSizeD = ($ - tableD)    DWORD 60h, 70h, 80h, 90h, 0A0h    DWORD 0B0h, 0C0h, 0D0h, 0E0h, 0F0hindex DWORD ?.codemCalc_row_sum index, OFFSET tableB, RowSizeB, BYTEmCalc_row_sum index, OFFSET tableW, RowSizeW, WORDmCalc_row_sum index, OFFSET tableD, RowSizeD, DWORD</code></pre><h2 id="汇编语言替换（-amp-）、文本（-lt-gt-）、字符（-）、展开（-）运算符简述"><a href="#汇编语言替换（-amp-）、文本（-lt-gt-）、字符（-）、展开（-）运算符简述" class="headerlink" title="汇编语言替换（&amp;）、文本（<>）、字符（!）、展开（%）运算符简述"></a>汇编语言替换（&amp;）、文本（&lt;&gt;）、字符（!）、展开（%）运算符简述</h2><p>下述四个汇编运算符使得宏更加灵活：</p><table><thead><tr><th>&amp;</th><th>替换运算符</th></tr></thead><tbody><tr><td>&lt;&gt;</td><td>文字文本运算符</td></tr><tr><td>!</td><td>文字字符运算符</td></tr><tr><td>%</td><td>展开运算符</td></tr></tbody></table><h3 id="替换运算符（-amp-）"><a href="#替换运算符（-amp-）" class="headerlink" title="替换运算符（&amp;）"></a>替换运算符（&amp;）</h3><p>替换运算符（&amp;）解析对宏参数名的有歧义的引用。宏 mShowRegister 显示了一个 32 位寄存器的名称和十六进制的内容。示例调用如下：</p><pre><code>.codemShowRegister ECX</code></pre><p>下面是调用 mShowRegister 产生的示例输出：</p><pre><code>ECX=00000101</code></pre><p>在宏内可以定义包含寄存器名的字符串变量：</p><pre><code>mShowRegister MACRO regName.datatempStr BYTE "regName=",0</code></pre><p>但是预处理程序会认为 regName 是字符串文本的一部分，因此，不会将其替换为传递给宏的实参值。相反，如果添加了 &amp; 运算符，它就会强制预处理程序在字符串文本中插入宏实参 ( 如 ECX)。下面展示的是如何定义 tempStr：</p><pre><code>mShowRegister MACRO regName.datatempStr BYTE "&amp;regName=",0</code></pre><h3 id="展开运算符（-）"><a href="#展开运算符（-）" class="headerlink" title="展开运算符（%）"></a>展开运算符（%）</h3><p>展开运算符（%）展开文本宏并将常量表达式转换为文本形式。有几种方法实现该功能。若使用的是 TEXTEQU，% 运算符就计算常量表达式，再把结果转换为整数。</p><p>在下面的例子中，% 运算符计算表达式 (5+count)，并返回整数 15 ( 以文本形式 )：</p><pre><code>count = 10sumVal TEXTEQU %(5 + count)           ;="15"</code></pre><p>如果宏请求的实参是整数常量，% 运算符就能使程序具有传递一个整数表达式的灵活性。计算这个表达式得到结果值，然后将这个值传递给宏。例如，调用 mGotoxyConst 时，计算表达式的结果分别为 50 和 7：</p><pre><code>mGotoxyConst %(5 * 10), %(3 + 4)</code></pre><p>预处理程序将产生如下语句：</p><pre><code>1 push edx1 mov dh,71 mov dl,501 call Gotoxy1 pop edx</code></pre><h4 id="在一行的首位"><a href="#在一行的首位" class="headerlink" title="% 在一行的首位"></a>% 在一行的首位</h4><p>当展开运算符 (%) 是一行源代码的第一个字符时，它指示预处理程序展开该行上的所有文本宏和宏函数。比如，假设想在汇编时将数组大小显示在屏幕上。下面的尝试不会产生期望的结果：</p><pre><code>.dataarray DWORD 1,2,3,4,5,6,7,8.codeECHO The array contains (SIZEOF array) bytesECHO The array contains %(SIZEOF array) bytes</code></pre><p>屏幕输出没什么用：</p><pre><code>The array contains (SIZEOF array) bytesThe array contains %(SIZEOF array) bytes</code></pre><p>反之，如果用 TEXTEQU 编写包含 (SIZEOF array) 的文本宏，那么该宏就可以展开为之后的代码行：</p><pre><code>TempStr TEXTEQU %(SIZEOF array)%  ECHO The array contains TempStr bytes</code></pre><p>产生的输出如下所示：</p><pre><code>The array contains 32 bytes</code></pre><h4 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h4><p>下面的宏 Mul32 将它前两个实参相乘，乘积由第三个实参返回。其形参可以是寄存器、内存操作数和立即数 ( 乘积除外 )：</p><pre><code>Mul32 MACRO op1, op2, product    IFIDNI &lt;op2&gt;,&lt;EAX&gt;%        LINENUM TEXTEQU %(@LINE)        ECHO ----------------------------------------------%       ECHO * Error on line LINENUM: EAX cannot be the second        ECHO * argument when invoking the MUL32 macro.        ECHO ----------------------------------------------    EXITM    ENDIF    push eax    mov eax,op1    mul op2    mov product,eax    pop eaxENDM</code></pre><p>Mul32 要检查的一个重要要求是：EAX 不能作为第二个实参。这个宏有趣的地方是，它显示的是其调用者的行号，这样更加易于追踪并解决问题。首先定义文本宏 LINENUM，它引用的 @LINE 是一个预先定义的汇编运算符，其功能为返回当前源代码行的编号：</p><pre><code>LINENUM TEXTEQU % ((@LINE)</code></pre><p>接着，在含有 ECHO 语句的代码行第一列上的展开运算符 (%) 使得 LINENUM 被展开：</p><pre><code>%  ECHO * Error on line LINENUM: EAX cannot be the second</code></pre><p>假设如下宏调用发生在程序的 40 行：</p><pre><code>MUL32 val1, eax,val3</code></pre><p>那么，汇编时将显示如下信息：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226072185281" alt="img"></p><h3 id="文字文本运算符（-lt-gt-）"><a href="#文字文本运算符（-lt-gt-）" class="headerlink" title="文字文本运算符（<>）"></a>文字文本运算符（&lt;&gt;）</h3><p>文字文本（literal-text）运算符（&lt;&gt;）把一个或多个字符和符号组合成一个文字文本，以防止预处理程序把列表中的成员解释为独立的参数。</p><p>在字符串含有特殊字符时该运算符非常有用，比如逗号、百分号（%）、和号（&amp;）以及分号（;），这些符号既可以被解释为分隔符，又可以被解释为其他的运算符。例如，之前给岀的宏 mWrite 接收一个字符串文本作为其唯一的实参。如果传递的字符串如下所示，预处理程序就会将其解释为3个独立的实参：</p><pre><code>mWrite "Line three", 0dh, 0ah</code></pre><p>第一个逗号后面的文本会被丢弃，因为宏只需要一个实参。然而，如果用文字文本运算 符将字符串括起来，那么预处理程序就会把尖括号内所有的文本当作一个宏实参：</p><pre><code>mWrite ＜"Line three", 0dh, 0ah＞</code></pre><h3 id="文字字符运算符（-）"><a href="#文字字符运算符（-）" class="headerlink" title="文字字符运算符（!）"></a>文字字符运算符（!）</h3><p>构造文字字符（literal-character）运算符（!）的目的与文字文本运算符的几乎完全一样：强制预处理程序把预先定义的运算符当作普通的字符。在下面的 TEXTEQU 定义中，运算符 ! 可以防止符号 &gt; 被当作文本分隔符：</p><pre><code>BadYValue TEXTEQU &lt;Warning: Y-coordinate is !&gt; 24&gt;</code></pre><h4 id="警告信息示例"><a href="#警告信息示例" class="headerlink" title="警告信息示例"></a>警告信息示例</h4><p>下面的例子有助于说明运算符 %、&amp; 和 ! 是如何工作的。假设已经定义了符号 BadYValue。现在创建一个宏 ShowWarning，接收一个用引号括起来的文本实参，并将其传递给宏 mWrite。注意替换（&amp;）运算符的用法：</p><pre><code>ShowWarning MACRO message   mWrite "&amp;message"ENDM</code></pre><p>然后调用 ShowWarning，把表达式 %BadYValue 传递给它。% 运算符计算（解析） BadYValue，并生成与之等价的字符串：</p><pre><code>.codeShowWarning %BadYValue</code></pre><p>正如所期望的，程序运行并显示警告信息：Warning: Y-coordinate is &gt; 24</p><h2 id="汇编语言宏函数"><a href="#汇编语言宏函数" class="headerlink" title="汇编语言宏函数"></a>汇编语言宏函数</h2><p>宏函数与宏过程有相似的地方，它也为汇编语言语句列表分配一个名称。不同的地方在于，宏函数通过 EXITM 伪指令总是返回一个常量（整数或字符串）。如下例所示，如果给定符号已定义则宏 IsDefined 返回真（-1）；否则返回假（0）：</p><pre><code>IsDefined MACRO symbol    IFDEF symbol        EXITM &lt;-l&gt;     ;; 真    ELSE        EXITM &lt;0&gt;      ;; 假    ENDIFENDM</code></pre><p>EXITM （退出宏）伪指令终止了所有后续的宏展开。</p><h4 id="调用宏函数"><a href="#调用宏函数" class="headerlink" title="调用宏函数"></a>调用宏函数</h4><p>调用宏函数时，它的实参列表必须用括号括起来。比如，调用宏 IsDefined 并传递 RealMode （一个可能已定义也可能还未定义的符号名）：</p><pre><code>IF IsDefined(RealMode)   mov ax, @data   mov ds, axENDIF</code></pre><p>如果在汇编过程中，汇编器在此之前已经遇到过对 RealMode 的定义，那么它就会汇编这两条指令：</p><pre><code>mov ax,@datamov ds,ax</code></pre><p>同样的 IF 伪指令可以被放在名为 Startup 的宏内：</p><pre><code>Startup MACRO    IF IsDefined(RealMode)        mov ax,@data        mov ds,ax    ENDIFENDM</code></pre><p>像 IsDefined 这样的宏可以用于设计多种内存模式的程序。比如，可以用它来决定使用哪种头文件：</p><pre><code>IF IsDefined(RealMode)    INCLUDE Irvine16.incELSE    INCLUDE Irvine32.incENDIF</code></pre><h4 id="定义-RealMode-符号"><a href="#定义-RealMode-符号" class="headerlink" title="定义 RealMode 符号"></a>定义 RealMode 符号</h4><p>剩下的任务就只是找到定义 RealMode 符号的方法。方法之一是把下面的代码行放在程序开始的位置：</p><pre><code>RealMode = 1</code></pre><p>或者，汇编器命令行也有选项来定义符号，即，使用 -D。下面的 ML 命令行定义了 RealMode 符号并为其赋值 1：</p><pre><code>ML -c -DRealMode=l myProg.asm</code></pre><p>而保护模式程序中相应的 ML 命令就没有定义 RealMode 符号：</p><pre><code>ML -c myProg.asm</code></pre><h4 id="HelioNew-程序"><a href="#HelioNew-程序" class="headerlink" title="HelioNew 程序"></a>HelioNew 程序</h4><p>下面的程序 (HelloNew.asm) 使用刚才介绍的宏，在屏幕上显示了一条消息：</p><pre><code>; 宏函数    (HelloNew.asm)INCLUDE Macros.incIF IsDefined( RealMode )    INCLUDE Irvine16.incELSE    INCLUDE Irvine32.incENDIF.codemain PROC    Startup    mWrite &lt;"This program can be assembled to run ",0dh,0ah&gt;    mWrite &lt;"in both Real mode and Protected mode.",0dh,0ah&gt;    exitmain ENDPEND main</code></pre><p>16 位实模式程序运行于模拟的 MS-DOS 环境中，使用的是 Irvine16.inc 头文件和 Irvine16 链接库。</p><h2 id="汇编语言定使用WHILE、REPEAT、FOR-和-FORC伪指令定义重复语句块"><a href="#汇编语言定使用WHILE、REPEAT、FOR-和-FORC伪指令定义重复语句块" class="headerlink" title="汇编语言定使用WHILE、REPEAT、FOR 和 FORC伪指令定义重复语句块"></a>汇编语言定使用WHILE、REPEAT、FOR 和 FORC伪指令定义重复语句块</h2><p>MASM 有许多循环伪指令用于生成重复的语句块：WHILE、REPEAT、FOR 和 FORC。与 LOOP 指令不同，这些伪指令只在汇编时起作用，并使用常量值作为循环条件和计数器：</p><ul><li><p>WHILE 伪指令根据一个布尔表达式来重复语句块。</p></li><li><p>REPEAT 伪指令根据计数器的值来重复语句块。</p></li><li><p>FOR 伪指令通过遍历符号列表来重复语句块。</p></li><li><p>FORC 伪指令通过遍历字符串来重复语句块。</p></li></ul><h3 id="WHILE-伪指令"><a href="#WHILE-伪指令" class="headerlink" title="WHILE 伪指令"></a>WHILE 伪指令</h3><p>WHILE 伪指令重复一个语句块，直到特定的常量表达式为真。其语法如下：</p><pre><code>WHILE constExpression   statementsENDM</code></pre><p>下面的代码展示了如何在 1 到 F000 0000h 之间生成斐波那契 (Fibonacci) 数，作为汇编时常数序列：</p><pre><code>.dataval1 = 1val2 = 1DWORD val1                   ;前两个值DWORD val2val3 = val1 + val2WHILE val3 LT 0F0000000h    DWORD val3    val1 = val2    val2 = val3    val3 = val1 + val2ENDM</code></pre><h3 id="REEPEAT-伪指令"><a href="#REEPEAT-伪指令" class="headerlink" title="REEPEAT 伪指令"></a>REEPEAT 伪指令</h3><p>在汇编时，REPEAT 伪指令将一个语句块重复固定次数。其语法如下：</p><pre><code>REPEAT constExpression   statementsENDM</code></pre><p>constExpression 是一个无符号整数常量表达式，用于确定重复次数。</p><p>在创建数组时，REPEAT 的用法与 DUP 类似。在下面的例子中，WeatherReadings 结构含有一个地点字符串和一个包含了降雨量与湿度读数的数组：</p><pre><code>WEEKS_PER_YEAR = 52    WeatherReadings STRUCT    location BYTE 50 DUP(0)    REPEAT WEEKS_PER_YEAR        LOCAL rainfall, humidity        rainfall DWORD ?        humidity DWORD ?    ENDMWeatherReadings ENDS</code></pre><p>由于汇编时循环会对降雨量和湿度重定义，使用 LOCAL 伪指令可以避免因其导致的错误。</p><h3 id="FOR-伪指令"><a href="#FOR-伪指令" class="headerlink" title="FOR 伪指令"></a>FOR 伪指令</h3><p>FOR 伪指令通过迭代用逗号分隔的符号列表来重复一个语句块。列表中的每个符号都会引发循环的一次迭代过程。其语法如下：</p><pre><code>FOR parameter,&lt;arg1,arg2,arg3,...&gt;   statementsENDM</code></pre><p>第一次循环迭代时，parameter 取 arg1 的值，第二次循环迭代时，parameter 取 arg2 的值; 以此类推，直到列表的最后一个实参。</p><p>【示例】现在创建一个学生注册的场景，其中，COURSE 结构含有课程编号和学分值；SEMESTER 结构包含一个有 6 门课程的数组和一个计数器 NumCourses：</p><pre><code>COURSE STRUCT    Number BYTE 9 DUP(?)    Credits BYTE ?COURSE ENDS;semester 含有一个课程数组。SEMESTER STRUCT    Courses COURSE 6 DUP(&lt;&gt;)    NumCourses WORD ?SEMESTER ENDS</code></pre><p>使用 FOR 循环可以定义 4 个 SEMESTER 对象，每一个对象都从由尖括号括起的符号列表中选择一个不同的名称：</p><pre><code>.data   FOR semName,&lt;Fall2013, Spring2014, Summer2014, Fall2014&gt;   semName SEMESTER &lt;&gt;ENDM如果查看列表文件就会发现如下变量：.dataFall2013 SEMESTER &lt;&gt;Spring2014 SEMESTER &lt;&gt;Summer2014 SEMESTER &lt;&gt;Fall2014 SEMESTER &lt;&gt;</code></pre><h3 id="FORC-伪指令"><a href="#FORC-伪指令" class="headerlink" title="FORC 伪指令"></a>FORC 伪指令</h3><p>FORC 伪指令通过迭代字符串来重复一个语句块。字符串中的每个字符都会引发循环的一次迭代过程。其语法如下：</p><pre><code>FORC parameter, &lt;string&gt;   statementsENDM</code></pre><p>第一次循环迭代时，parameter 等于字符串的第一个字符，第二次循环迭代时，parameter 等于字符串的第二个字符；以此类推，直到最后一个字符。</p><p>下面的例子创建了一个字符查找表，其中包含了一些非字母字符。注意，&lt; 和 &gt; 的前面必须有文字字符（!）运算符，以防它们违反FORC伪指令的语法：</p><pre><code>Delimiters LABEL BYTEFORC code, &lt;@#$%^&amp;*!&lt;!&gt;&gt;   BYTE "&amp;code"ENDM</code></pre><p>生成的数据表如下所示，可以在列表文件中查看：</p><pre><code>00000000 40 1 BYTE "@"00000001 23 1 BYTE "#"00000002 24 1 BYTE "$"00000003 25 1 BYTE "%"00000004 5E 1 BYTE "^"00000005 26 1 BYTE "&amp;"00000006 2A 1 BYTE "*"00000007 3C 1 BYTE "&lt;"00000008 3E 1 BYTE "&gt;"</code></pre><h4 id="示例：链表"><a href="#示例：链表" class="headerlink" title="示例：链表"></a>示例：链表</h4><p>结合结构声明与 REPEAT 伪指令以指示汇编器创建一个链表的数据结构是相当简单的。链表中的每个节点都含有一个数据域和一个链接域：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226269964283" alt="img"></p><p>在数据域中，一个或多个变量可以保存每个节点所特有的数据。在链接域中，一个指针包含了链表下一个节点的地址。最后一个节点的链接域通常是一个空指针。现在编写程序创建并显示一个简单链表。首先，程序定义一个节点，其中含有一个整数(数据)和一个指向下一个节点的指针：</p><pre><code>ListNode STRUCT   NodeData DWORD ?   ;节点的数据   NextPtr DWORD ?       ;指向下一个节点的指针ListNode ENDS</code></pre><p>接着 REPEAT 伪指令创建了 ListNode 对象的多个实例。为了便于测试，NodeData 域含有一个整数常量，其范围为 1〜15，在循环内部，计数器加 1 并将值插入到 ListNode 域：</p><pre><code>TotalNodeCount = 15NULL = 0Counter = 0.dataLinkedList LABEL PTR ListNodeREPEAT TotalNodeCount    Counter = Counter + 1    ListNode &lt;Counter, ($ + Counter * SIZEOF ListNode)&gt;ENDM</code></pre><p>表达式 ($+Counter*SIZEOF ListNode) 告诉汇编器把计数值与 ListNode 的大小相乘，并将乘积与当前地址计数器相加。结果值插入结构内的 NextPtr 域。［注意一个有趣的现象：位置计数器的值 ($) 固定在表的第一节点上。］该表用尾节点 (tail node) 来标记末尾，其 NextPtr 域为空 (0)：</p><pre><code>ListNode &lt;0,0&gt;</code></pre><p>当程序遍历该表时，它用下面的语句检索 NextPtr 域，并将其与 NULL 比较，以检查是否为表的末尾：</p><pre><code>mov eax,(ListNode PTR [esi]).NextPtrcmp eax,NULL</code></pre><h3 id="程序清单-1"><a href="#程序清单-1" class="headerlink" title="程序清单"></a>程序清单</h3><p>完整的程序清单如下所示。在 main 中，一个循环遍历链表并显示全部的节点值。与使用固定计数值控制循环相比，程序检查是否为尾节点的空指针，若是则停止循环：</p><pre><code>; 创建一个链表            (List.asm)INCLUDE Irvine32.incListNode STRUCT  NodeData DWORD ?  NextPtr  DWORD ?ListNode ENDSTotalNodeCount = 15NULL = 0Counter = 0.dataLinkedList LABEL PTR ListNodeREPT TotalNodeCount    Counter = Counter + 1    ListNode &lt;Counter, ($ + Counter * SIZEOF ListNode)&gt;ENDMListNode &lt;0,0&gt;    ; tail node.codemain PROC    mov  esi,OFFSET LinkedList; 显示 NodeData 域的值NextNode:    ; 检查是否为尾节点    mov  eax,(ListNode PTR [esi]).NextPtr    cmp  eax,NULL    je   quit    ; 显示节点数据    mov  eax,(ListNode PTR [esi]).NodeData    call WriteDec    call Crlf    ; 获取下一个节点的指针    mov  esi,(ListNode PTR [esi]).NextPtr    jmp  NextNodequit:    exitmain ENDPEND main</code></pre><h1 id="汇编语言MS-Windows编程"><a href="#汇编语言MS-Windows编程" class="headerlink" title="汇编语言MS-Windows编程"></a>汇编语言MS-Windows编程</h1><h2 id="汇编语言MS-Windows编程简述"><a href="#汇编语言MS-Windows编程简述" class="headerlink" title="汇编语言MS-Windows编程简述"></a>汇编语言MS-Windows编程简述</h2><p>一个 Windows 应用程序开始的时候，要么创建一个控制台窗口，要么创建一个图形化窗口。本教程的项目文件一直把如下选项与 LINK 命令一起使用。它告诉链接器创建一个基于控制台的应用程序：</p><p>/SUBSYSTEM:CONSOLE</p><p>控制台程序的外观和操作就像 MS-DOS 窗口，它的一些改进部分将在后面进行介绍。控制台有一个输入缓冲区以及一个或多个屏幕缓冲区：</p><h4 id="1-输入缓冲区（input-buffer）："><a href="#1-输入缓冲区（input-buffer）：" class="headerlink" title="1) 输入缓冲区（input buffer）："></a>1) 输入缓冲区（input buffer）：</h4><p>包含一组输入记录（input records），其中的每个记录都是一个输入事件的数据。输入事件的例子包括键盘输入、鼠标点击，以及用户调整控制台窗口大小。</p><h4 id="2-屏幕缓冲区（screen-buffer）："><a href="#2-屏幕缓冲区（screen-buffer）：" class="headerlink" title="2) 屏幕缓冲区（screen buffer）："></a>2) 屏幕缓冲区（screen buffer）：</h4><p>是字符与颜色数据的二维数组，它会影响控制台窗口文本的外观。</p><h3 id="Win32-API-参考信息"><a href="#Win32-API-参考信息" class="headerlink" title="Win32 API 参考信息"></a>Win32 API 参考信息</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>在接下来的讲解中将介绍 Win32 API 函数的子集并给岀一些简单的例子。由于篇幅的限制，将不会涉及很多细节。如果想了解更多信息，请访问 Microsoft MSDN 网站（地址为：<a href="http://www.msdn.microsoft.com/" target="_blank" rel="noopener">www.msdn.microsoft.com</a>）。在搜索函数或标识符时，把 Filtered by 参数设置为 Platform SDK。</p><h4 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h4><p>阅读 Win32 API 函数的文档时，常常会见到常量名，如 TIME_ZONE_ID_UNKNOWN。少数情况下，这些常量已经在 SmallWin.inc 中定义过。例如，头文件 WinNT.h 就定义了 TIME_ZONE_ID_UNKNOWN 及相关常量：</p><pre><code>#define TIME_ZONE_ID_UNKNOWN 0#define TIME_ZONE_ID_STANDARD 1#define TIME_ZONE_ID_DAYLIGHT 2</code></pre><p>利用这个信息，可以将下述语句添加到 SmallWin.h 或者用户自己的头文件中:</p><pre><code>TIME_ZONE_ID_UNKNOWN = 0TIME_ZONE_ID_STANDARD = 1TIME_ZONE_ID_DAYLIGHT = 2</code></pre><h3 id="字符集和-Windows-API-函数"><a href="#字符集和-Windows-API-函数" class="headerlink" title="字符集和 Windows API 函数"></a>字符集和 Windows API 函数</h3><p>调用 Win32 API 函数时会使用两类字符集：8 位的 ASCII/ANSI 字符集和 16 位的 Unicode 字符集（所有近期的 Windows 版本中都有）。</p><p>Win32 函数可以处理的文本通常有两种版本：一种以字母 A 结尾（8 位 ANSI 字符），另一种以 W 结尾（宽字符集，包括了 Unicode）。WriteConsole 即为其中之一：</p><p>WriteConsoleA</p><p>WriteConsoleW</p><p>Windows95 和 98 不支持以 W 结尾的函数名。另一方面，在所有近期的 Windows 版本中，Unicode 都是原生字符集。例如调用名为 WriteConsoleA 的函数，则操作系统将把字符从 ANSI 转换为 Unicode，再调用 WriteConsoleW。</p><p>在 Microsoft MSDN 链接库的函数文件中，如 WriteConsole，尾字符 A 和 W 都被省略了。</p><p>WriteConsole EQU <writeconsolea></writeconsolea></p><p>这个定义使得程序能按 WriteConsole 的通用名对其进行调用。</p><h3 id="高级别和低级别访问"><a href="#高级别和低级别访问" class="headerlink" title="高级别和低级别访问"></a>高级别和低级别访问</h3><p>控制台访问有两个级别，这就能够在简单控制和完全控制之间进行权衡：</p><ul><li><p>高级别控制台函数从控制台输入缓冲区读取字符流，并将字符数据写入控制台的屏幕缓冲区。输入和输出都可以重定向到文本文件。</p></li><li><p>低级别控制台函数检索键盘和鼠标事件，以及用户与控制台窗口交互 ( 拖曳、调整大小等 ) 的详细信息。这些函数还允许对窗口大小、位置以及文本颜色进行详细控制。</p></li></ul><h3 id="Windows-数据类型"><a href="#Windows-数据类型" class="headerlink" title="Windows 数据类型"></a>Windows 数据类型</h3><p>Win32 函数使用 C/C++ 程序员的函数声明进行记录。在这些声明中，所有函数参数类型要么基于标准 C 类型，要么基于 MS-Windows 预定义类型 (下表中列出了部分类型 ) 之一。</p><table><thead><tr><th>MS-Windows 类型</th><th>MASM类型</th><th>说明</th></tr></thead><tbody><tr><td>BOOL, BOOLEAN</td><td>DWORD</td><td>布尔值 (TRUE 或 FALSE)</td></tr><tr><td>BYTE</td><td>BYTE</td><td>8 位无符号整数</td></tr><tr><td>CHAR</td><td>BYTE</td><td>8 位 Windows ANSI 字符</td></tr><tr><td>COLORREF</td><td>DWORD</td><td>作为颜色值的 32 位数值</td></tr><tr><td>DWORD</td><td>DWORD</td><td>32 位无符号整数</td></tr><tr><td>HANDLE</td><td>DWORD</td><td>对象句柄</td></tr><tr><td>HFILE</td><td>DWORD</td><td>用 OpenFile 打开的文件的句柄</td></tr><tr><td>INT</td><td>SDWORD</td><td>32 位有符号整数</td></tr><tr><td>LONG</td><td>SDWORD</td><td>32 位有符号整数</td></tr><tr><td>LPARAM</td><td>DWORD</td><td>消息参数，由窗口过程和回调函数使用</td></tr><tr><td>LPCSTR</td><td>PTR BYTE</td><td>32 位指针，指向由 8 位 Windows (ANSI)字符组成的空字节结束的字符串常量</td></tr><tr><td>LPCVOID</td><td>DWORD</td><td>指向任何类型的常量</td></tr><tr><td>LPSTR</td><td>PTR BYTE</td><td>32 位指针，指向由 8 位 Windows (ANSI) 字符组成的空字节结束的字符串</td></tr><tr><td>LPCTSTR</td><td>PTR WORD</td><td>32 位指针，指向对 Unicode 和双字节字符集可移植的字符串常量</td></tr><tr><td>LPTSTR</td><td>PTR WORD</td><td>32 位指针，指向对 Unicode 和双字节字符集可移植的字符串</td></tr><tr><td>LPVOID</td><td>DWORD</td><td>32 位指针，指向未指定类</td></tr><tr><td>LRESULT</td><td>DWORD</td><td>窗口过程和回调函数返回的 32 位数值</td></tr><tr><td>SIZE_T</td><td>DWORD</td><td>一个指针可以指向的最大字节数</td></tr><tr><td>UNIT</td><td>DWORD</td><td>32 位无符号整数</td></tr><tr><td>WNDPROC</td><td>DWORD</td><td>32 位指针，指向窗口过程</td></tr><tr><td>WORD</td><td>WORD</td><td>16 位无符号整数</td></tr><tr><td>WPARAM</td><td>DWORD</td><td>作为参数传递给窗口过程或回调函数的 32 位数值</td></tr></tbody></table><p>区分数据值和指向值的指针是很重要的。以字母 LP 开头的类型名是长指针 (long pointer)，指向其他对象。</p><h3 id="SmallWin-inc-头文件"><a href="#SmallWin-inc-头文件" class="headerlink" title="SmallWin.inc 头文件"></a>SmallWin.inc 头文件</h3><p>SmallWin.inc 是一个头文件，其中包含了 Win32 API 编程的常量定义、等价文本以及函数原型。通过本教程一直使用的 Irvine32.inc，SmallWin.inc 被自动包含在程序中。</p><p>大多数常量都可以在用于 C 和 C++ 编程的头文件 Windows.h 中找到。与它的名字不同，SmallWin.inc 文件相当大， 因此这里只展示其突出部分：</p><pre><code>DO_NOT_SHARE = 0NULL = 0TRUE = 1FALSE = 0;Win32 控制台句柄STD_INPUT_HANDLE EQU -10STD_OUTPUT_HANDLE EQU -11STD_ERROR_HANDLE EQU -12</code></pre><p>类型 HANDLE 是 DWORD 的代名词,能帮助函数原型与 Microsoft Win32 文档更加一致：</p><pre><code>HANDLE TEXTEQU &lt;DWORD&gt;</code></pre><p>SmallWin.inc 也包括用于 Win32 调用的结构定义。下面给出了两个结构定义：</p><pre><code>COORD STRUCT   X WORD ?   Y WORD ?COORD ENDSSYSTEMTIME STRUCT   wYear WORD ?   wMonth WORD ?   wDayOfWeek WORD ?   wDay WORD ?   wHour WORD ?   wMinute WORD ?   wSecond WORD ?   wMilliseconds WORD ?SYSTEMTIME ENDS</code></pre><h3 id="控制台句柄"><a href="#控制台句柄" class="headerlink" title="控制台句柄"></a>控制台句柄</h3><pre><code>几乎所有的 Win32 控制台函数都要求向其传递一个句柄作为第一个实参。句柄 (handle) 是 一个 32 位无符号整数，用于唯一标识一个对象，例如一个位图、画笔或任何输入/输岀设备：STD_INPUT_HANDLE standard inputSTD_OUTPUT_HANDLE standard outputSTD_ERROR_HANDLE standard error output</code></pre><p>上述句柄中的后两个用于写控制台活跃屏幕缓冲区。</p><p>GetStdHandle 函数返回一个控制台流的句柄：输入、输出或错误输出。基于控制台的程序中所有的输入/输出操作都需要句柄。函数原型如下：</p><pre><code>GetStdHandle PROTO,   nStdHandle:HANDLE       ;句柄类型</code></pre><p>nStdHandle 可以是 STD_INPUT_HANDLE、STD_OUTPUT_HANDLE 或者 STD_ERROR_ HANDLE。函数用 EAX 返回句柄，且应将它复制给变量保存。下面是一个调用示例：</p><pre><code>.datainputHandle HANDLE ?.codeINVOKE GetStdHandle, STD_INPUT_HANDLEmov inputHandle；eax</code></pre><h2 id="汇编语言Win32控制台函数简述"><a href="#汇编语言Win32控制台函数简述" class="headerlink" title="汇编语言Win32控制台函数简述"></a>汇编语言Win32控制台函数简述</h2><p>下表为所有 Win32 控制台函数的一览表。在 <a href="http://www.msdn.microsoft.com" target="_blank" rel="noopener">www.msdn.microsoft.com</a> 上可以找到 MSDN 库中每个函数的完整描述。</p><blockquote><p>提示：Win32 API 函数不保存 EAX、EBX、ECX 和 EDX，因此程序员需自己完成这些寄存器的入栈和出栈操作。</p></blockquote><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>AllocConsole</td><td>为调用进程分配一个新控制台</td></tr><tr><td>CreateConsoleScreenBuffer</td><td>创建控制台屏幕缓冲区</td></tr><tr><td>ExitProcess</td><td>结束进程及其所有线程</td></tr><tr><td>FillConsoleOutputAttribute</td><td>为指定数量的字符单元格设置文本和背景颜色属性</td></tr><tr><td>FillConsoleOutputCharacter</td><td>按指定次数将一个字符写入屏幕缓冲区</td></tr><tr><td>FlushConsoleInputBuffer</td><td>刷新控制台输入缓冲区</td></tr><tr><td>FreeConsole</td><td>将主调进程与其控制台分离</td></tr><tr><td>GenerateConsoleCtrlEvent</td><td>向控制台进程组发送指定信号，这些进程组共享与主调进程关联的控制台</td></tr><tr><td>GetConsoleCP</td><td>获取与主调进程关联的控制台使用的输入代码页</td></tr><tr><td>GetConsoleCursorInfo</td><td>获取指定控制台屏幕缓冲区光标大小和可见性的信息</td></tr><tr><td>GetConsoleMode</td><td>获取控制台输入缓冲区的当前输入模式或控制台屏幕缓冲区的当前输出模式</td></tr><tr><td>GetConsoleOutputCP</td><td>获取与主调进程关联的控制台使用的输出代码页</td></tr><tr><td>GetConsoleScreenBufferInfo</td><td>获取指定控制台屏幕缓冲区信息</td></tr><tr><td>GetConsoleTitle</td><td>获取当前控制台窗口的标题栏字符串</td></tr><tr><td>GetConsoleWindow</td><td>获取与主调进程关联的控制台使用的窗口句柄</td></tr><tr><td>GetLargestConsoleWindowSize</td><td>获取控制台窗口最大可能的大小</td></tr><tr><td>GetNumberOfConsoleInputEvents</td><td>获取控制台输入缓冲区中未读输入记录的个数</td></tr><tr><td>GetNumberOfConsoleMouseButtons</td><td>获取当前控制台使用的鼠标按钮数</td></tr><tr><td>GetStdHandle</td><td>获取标准输入、标准输出或标准错误设备的句柄</td></tr><tr><td>HandlerRoutine</td><td>与 SetConsoleCtrlHandler 函数一起使用的应用程序定义的函数</td></tr><tr><td>PeekConsoleInput</td><td>从指定控制台输入缓冲区读取数据，且不从缓冲区删除该数据</td></tr><tr><td>ReadConsole</td><td>从控制台输入缓冲区读取并删除输入字符</td></tr><tr><td>ReadConsoleInput</td><td>从控制台输入缓冲区读取并删除该数据</td></tr><tr><td>ReadConsoleOutput</td><td>从控制台屏幕缓冲区的矩形字符单元格区域读取字符和颜色属性数据</td></tr><tr><td>ReadConsoleOutputAttribute</td><td>从控制台屏幕缓冲区的连续单元格复制指定数量的前景和背景颜色属性</td></tr><tr><td>ReadConsoleOutputCharacter</td><td>从控制台屏幕缓冲区的连续单元格复制若干字符</td></tr><tr><td>ScrollConsoleScreenBuffer</td><td>移动屏幕缓冲区内的一个数据块</td></tr><tr><td>SetConsoleActiveScreenBuffer</td><td>设置指定屏幕缓冲区为当前显示的控制台屏幕缓冲区</td></tr><tr><td>SetConsoleCP</td><td>设置主调过程的控制台输入代码页</td></tr><tr><td>SetConsoleCtrlHandler</td><td>为主调过程从处理函数列表中添加或删除应用程序定义的 HandlerRoutine</td></tr><tr><td>SetConsoleCursorInfo</td><td>设置指定控制台屏幕缓冲区光标的大小和可见度</td></tr><tr><td>SetConsoleCursorPosition</td><td>设置光标在指定控制台屏幕缓冲区中的位置</td></tr><tr><td>SetConsoleMode</td><td>设置控制台输入缓冲区的输入模式或者控制台屏幕缓冲区的输出模式</td></tr><tr><td>SetConsoleOntputCP</td><td>设置主调过程的控制台输出代码页</td></tr><tr><td>SetConsoleScreenBufferSize</td><td>修改指定控制台屏幕缓冲区的大小</td></tr><tr><td>SetConsoleTextAttribute</td><td>设置写入屏幕缓冲区的字符的前景（文本）和背景颜色属性</td></tr><tr><td>SetConsoleTitle</td><td>为当前控制台窗口设置标题栏字符串</td></tr><tr><td>SetConsoleWindowInfo</td><td>设置控制台屏幕缓冲区窗口当前的大小和位置</td></tr><tr><td>SetStdHandle</td><td>设置标准输入、输出和标准错误设备的句柄.</td></tr><tr><td>WriteConsole</td><td>向由当前光标位置标识开始的控制台屏幕缓冲区写一个字符串</td></tr><tr><td>WriteConsoleInput</td><td>直接向控制台输入缓冲区写数据</td></tr><tr><td>WriteConsoleOutput</td><td>向控制台屏幕缓冲区内指定字符单元格的矩形块写字符和颜色属性数据</td></tr><tr><td>WriteConsoleOutputAttribute</td><td>向控制台屏幕缓冲区的连续单元格复制一组前景和背景颜色属性</td></tr><tr><td>WriteConsoleOutputCharacter</td><td>向控制台屏幕缓冲区的连续单元格复制一组字符</td></tr></tbody></table><h2 id="汇编语言MessageBoxA函数：显示消息框"><a href="#汇编语言MessageBoxA函数：显示消息框" class="headerlink" title="汇编语言MessageBoxA函数：显示消息框"></a>汇编语言MessageBoxA函数：显示消息框</h2><p>Win32 应用程序生成输岀的一个最简单的方法就是调用 MessageBoxA 函数：</p><pre><code>MessageBoxA PROTO,   hWnd:DWORD,                  ;窗口句柄（可以为空）   lpText:PTR BYTE,         ;字符串，对话框内   lpCaption:PTR BYTE,          ;字符串，对话框标题   uType:DWORD          ;内容和行为</code></pre><p>基于控制台的应用程序可以将 hWnd 设置为空，表示该消息框没有相关的包含窗口或父窗口。lpText 参数是指向空字节结束字符串的指针，该字符串将出现在消息框内。lpCaption 参数指向作为对话框标题的空字节结束字符串。uType 参数指定对话框的内容和行为。</p><h4 id="内容和行为"><a href="#内容和行为" class="headerlink" title="内容和行为"></a>内容和行为</h4><p>uType 参数包含的位图整数组合了三种选项：显示按钮、图标和默认按钮选择。几种可能的按钮组合如下：</p><ul><li><p>MB_OK</p></li><li><p>MB_OKCANCEL</p></li><li><p>MB_YESNO</p></li><li><p>MB_YESNOCANCEL</p></li><li><p>MB_RETRYCANCEL</p></li><li><p>MB_ABORTRETRYIGNORE</p></li><li><p>MB_CANCELTRYCONTINUE</p></li></ul><h4 id="默认按钮"><a href="#默认按钮" class="headerlink" title="默认按钮"></a>默认按钮</h4><p>可以选择按钮作为用户点击 Enter 键时的自动选项。选项包括 MB_DEFBUTTON1（默认）、MB_DEFBUTTON2、MB_DEFBUTTON3 和 MB_DEFBUTTON4。按钮从左到右，从 1 开始编号。</p><h4 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h4><p>有四个图标可用。有时多个常数会产生相同的图标：</p><ul><li><p>停止符：MB_ICONSTOP. MB_ICONHAND 或 MB_ICONERROR</p></li><li><p>问号（?）：MB_ICONQUESTION</p></li><li><p>信息符（i）：MB_ICONINFORMATION、MB_ICONASTERISK</p></li><li><p>感叹号（!）：MB_ICONEXCLAMATION、MB_ICONWARNING</p></li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>如果 MessageBoxA 失败，则返回零；否则，它将返回一个整数以表示用户在关闭对话框时点击的按钮。选项包括 IDABORT、IDCANCEL、IDCONTINUE、IDIGNORE、IDNO、IDOK、IDRETRY、IDTRYAGAIN，以及 IDYES。</p><p>Smallwin.inc 将 MessageBoxA 重定义为 MessageBox，这个名字看上去具有更强的用户友好性。</p><p>如果想要消息框窗口浮动于桌面所有其他窗口之上，就在传递的最后一个参数（uType 参数）值上添加 MB_SYSTEMMODAL 选项。</p><h4 id="1-演示程序"><a href="#1-演示程序" class="headerlink" title="1) 演示程序"></a>1) 演示程序</h4><p>下面将通过一个小程序来演示函数 MessageBoxA 的一些功能。第一个函数调用显示一条警告信息：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226298485285" alt="img"></p><p>第二个函数调用显示一个问号图标以及 Yes/No 按钮。如果用户选择 Yes 按钮，则程序利用返回值选择一个操作：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226306838287" alt="img"></p><p>第三个函数调用显示一个信息图标以及三个按钮：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226314038289" alt="img"></p><p>第四个函数调用显示一个停止图标和一个 OK 按钮：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226323631291" alt="img"></p><h4 id="2-程序清单"><a href="#2-程序清单" class="headerlink" title="2) 程序清单"></a>2) 程序清单</h4><p>MessageBoxA 演示程序的完整清单如下所示。函数 MessageBoxA 重命名为函数 MessageBox，这样就可以使用更加简单的函数名：</p><pre><code>; 演示 MessageBoxAINCLUDE Irvine32.inc.datacaptionW        BYTE "Warning",0warningMsg    BYTE "The current operation may take years "                BYTE "to complete.",0captionQ        BYTE "Question",0questionMsg    BYTE "A matching user account was not found."                BYTE 0dh,0ah,"Do you wish to continue?",0   captionC        BYTE "Information",0infoMsg        BYTE "Select Yes to save a backup file "                BYTE "before continuing,",0dh,0ah                BYTE "or click Cancel to stop the operation",0captionH        BYTE "Cannot View User List",0haltMsg        BYTE "This operation not supported by your "                BYTE "user account.",0               .codemain PROC; 显示感叹号图标和 OK 按钮    INVOKE MessageBox, NULL, ADDR warningMsg,        ADDR captionW,        MB_OK + MB_ICONEXCLAMATION; 显示问号图标和 Yes/No 按钮    INVOKE MessageBox, NULL, ADDR questionMsg,        ADDR captionQ, MB_YESNO + MB_ICONQUESTION    ; 解释用户点击的按钮      cmp    eax,IDYES        ; YES button clicked?; 显示信息图标和 Yes/No/Cancel 按钮    INVOKE MessageBox, NULL, ADDR infoMsg,      ADDR captionC, MB_YESNOCANCEL + MB_ICONINFORMATION \          + MB_DEFBUTTON2; 显示停止图标和 OK 按钮    INVOKE MessageBox, NULL, ADDR haltMsg,        ADDR captionH,        MB_OK + MB_ICONSTOP    exitmain ENDPEND main </code></pre><h2 id="汇编语言ReadConsole函数：读取文本输入并将其送入缓冲区"><a href="#汇编语言ReadConsole函数：读取文本输入并将其送入缓冲区" class="headerlink" title="汇编语言ReadConsole函数：读取文本输入并将其送入缓冲区"></a>汇编语言ReadConsole函数：读取文本输入并将其送入缓冲区</h2><p>函数 ReadConsole 为读取文本输入并将其送入缓冲区提供了便捷的方法。其原型如下所示：</p><pre><code>ReadConsole PROTO,   hConsoleInput: HANDLE z            ;输入句柄   lpBuffer:PTR BYTE,                  ;缓冲区指针   nNumberOfCharsToRead:DWORD,        ;读取的字符数   lpNumberOfCharsRead:PTR DWORD,    ;指向读取字节数的指针   lpReserved:DWORD                 ;未使用</code></pre><p>hConsoleInput 是函数 GetStdHandle 返回的可用控制台输入句柄。参数 lpBuffer 是字符数组的偏移量。nNumberOfCharsToRead 是一个 32 位整数，指明读取的最大字符数。lpNumberOfCharsRead 是一个允许函数填充的双字指针，当函数返回时，字符数的计数值将被放入缓冲区。最后一个参数未使用，因此传递的值为 0。</p><p>在调用 ReadConsole 时，输入缓冲区还要包含两个额外的字节用来保存行结束字符。如果希望输入缓冲区里是空字节结束字符串，则用空字节来代替内容为 ODh 的字节。Irvine32.lib 的过程 ReadString 就是这样操作的。</p><blockquote><p>注意：Win32 API 函数不会保存 EAX、EBX、ECX 和 EDX 寄存器。</p></blockquote><p>【示例】要读取用户输入的字符，就调用 GetStdHandle 来获得控制台标准输入句柄，再使用该句柄调用 ReadConsoleo 下面的 ReadConsole 程序演示了这个方法。</p><blockquote><p>提示：Win32 API 调用与 Irvine32 链接库兼容，因此在调用 Win32 函数的同时还可以调用 DumpRegs</p></blockquote><pre><code>; 从控制台读取    (ReadConsole.asm)INCLUDE Irvine32.incBufSize = 80.databuffer BYTE BufSize DUP(?),0,0stdInHandle HANDLE ?bytesRead   DWORD ?.codemain PROC    ; 获取标准输入句柄    INVOKE GetStdHandle, STD_INPUT_HANDLE    mov    stdInHandle,eax    ; 等待用户输入    INVOKE ReadConsole, stdInHandle, ADDR buffer,      BufSize, ADDR bytesRead, 0    ; 显示缓冲区    mov    esi,OFFSET buffer    mov    ecx,bytesRead    mov    ebx,TYPE buffer    call    DumpMem    exitmain ENDPEND main</code></pre><p>如果用户输入 “abcdefg”，程序将生成如下输出。缓冲区会插入 9 个字节：“abcdefg” 再加上 ODh 和 OAh，即用户按下 Enter 键时产生的行结束字符。bytesRead 等于 9：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226344982293" alt="img"></p><h2 id="汇编语言GetLastError和FormatMessage函数：获取错误信息"><a href="#汇编语言GetLastError和FormatMessage函数：获取错误信息" class="headerlink" title="汇编语言GetLastError和FormatMessage函数：获取错误信息"></a>汇编语言GetLastError和FormatMessage函数：获取错误信息</h2><p>若 Windows API 函数返回了错误值 ( 如 NULL)，则可以调用 API 函数 GetLastError 来获取该错误的更多信息。该函数用 EAX 返回 32 位整数错误码：</p><pre><code>.datamessageId DWORD ?.codecall GetLastErrormov messageId,eax</code></pre><p>MS-Windows 有大量的错误码，因此，程序员可能希望得到一个消息字符串来对错误进行说明。要想达到这个目的，就调用函数 FormatMessage：</p><pre><code>FormatMessage PROTO,     ;格式化消息   dwFlags:DWORD,        ;格式化选项   lpSource:DWORD,        ;消息定义的位置   dwMsgID:DWORD,       ;消息标识符   dwLanguageID:DWORD,   ;语言标识符   lpBuffer:PTR BYTE,        ;缓冲区接收字符串指针   nSize:DWORD,           ;缓冲区大小   va_list: DWORD          ;参数列表指针</code></pre><p>该函数的参数有点复杂，程序员需要阅读 SDK 文档来了解全部信息。下面简要列出了最常用的参数值。除了 lpBuffer 是输出参数外，其他都是输入参数：</p><h4 id="1-dwFlags"><a href="#1-dwFlags" class="headerlink" title="1) dwFlags"></a>1) dwFlags</h4><p>保存格式化选项的双字整数，包括如何解释参数 lpSource。它规定怎样处理换行，以及格式化输出行的最大宽度。建议值为 FORMAT_MESSAGE_ALLOCATE_BUFFER 和 FORMAT_MESSAGE_FROM_SYSTEM。</p><h4 id="2-lpSource"><a href="#2-lpSource" class="headerlink" title="2) lpSource"></a>2) lpSource</h4><p>消息定义位置的指针。若按照建议值设置 dwFlags，则 lpSource 设置为 NULL(0)。</p><h4 id="3-dwMsgID"><a href="#3-dwMsgID" class="headerlink" title="3) dwMsgID"></a>3) dwMsgID</h4><p>调用 GetLastError 后返回的双字整数。</p><h4 id="4-dwLanguageID"><a href="#4-dwLanguageID" class="headerlink" title="4) dwLanguageID"></a>4) dwLanguageID</h4><p>语言标识符。若将其设置为 0，则消息为语言无关，否则将对应于用户的默认语言环境。</p><h4 id="5-lpBuffer-输出参数"><a href="#5-lpBuffer-输出参数" class="headerlink" title="5) lpBuffer( 输出参数 )"></a>5) lpBuffer( 输出参数 )</h4><p>接收空字节结束消息字符串的缓冲区指针。如果使用了 FORMAT_MESSAGE_ALLOCATE_BUFFER 选项，则会自动分配缓冲区。</p><h4 id="6-nSize"><a href="#6-nSize" class="headerlink" title="6) nSize"></a>6) nSize</h4><p>用于指定一个缓冲区来保存消息字符串。如果 dwFlags 使用了上述建议选项，则该参数可以设置为 0。</p><h4 id="7-va-list"><a href="#7-va-list" class="headerlink" title="7) va_list"></a>7) va_list</h4><p>数组指针，该数组包含了可以插入到格式化消息的值。由于没有格式化错误消息，这个参数可以为 NULL(0)。</p><p>FormatMessage 的示例调用如下：</p><pre><code>.datamessageId DWORD ?pErrorMsg DWORD ?            ;指向错误消息.codecall GetLastErrormov messageId,eaxINVOKE FormatMessage, FORMAT_MESSAGE_ALLOCATE_BUFFER + \    FORMAT_MESSAGE_FROM_SYSTEM, NULL, messagelD, 0,    ADDR pErrorMsg, 0, NULL</code></pre><p>调用 FormatMessage 后，再调用 LocalFree 来释放由 FormatMessage 分配的存储空间：</p><pre><code>INVOKE LocalFree, pErrorMsg</code></pre><h4 id="WriteWindowsMsg-1"><a href="#WriteWindowsMsg-1" class="headerlink" title="WriteWindowsMsg"></a>WriteWindowsMsg</h4><p>Irvine32 链接库有如下 WriteWindowsMsg 程，它封装了消息处理的细节：</p><pre><code>;----------------------------------------------------WriteWindowsMsg PROC USES eax edx;; 显示包含 MS-Windows 最新生成的错误字符串; 接收: 无; 返回: 无;----------------------------------------------------.dataWriteWindowsMsg_1 BYTE "Error ",0WriteWindowsMsg_2 BYTE ": ",0pErrorMsg DWORD ?              ; 指向错误消息messageId DWORD ?.code    call    GetLastError    mov    messageId,eax; 显示错误号    mov    edx,OFFSET WriteWindowsMsg_1    call    WriteString    call    WriteDec    ; show error number    mov    edx,OFFSET WriteWindowsMsg_2    call    WriteString; 获取相应的消息字符串    INVOKE FormatMessage, FORMAT_MESSAGE_ALLOCATE_BUFFER + \      FORMAT_MESSAGE_FROM_SYSTEM, NULL, messageID, NULL,      ADDR pErrorMsg, NULL, NULL; 显示 MS-Windows 生成的错误消息    mov    edx,pErrorMsg    call    WriteString; 释放错误消息字符串的空间    INVOKE LocalFree, pErrorMsg    retWriteWindowsMsg ENDP</code></pre><h2 id="汇编语言单字符输入简述"><a href="#汇编语言单字符输入简述" class="headerlink" title="汇编语言单字符输入简述"></a>汇编语言单字符输入简述</h2><p>控制台模式下的单字符输入有些复杂。MS-Windows 为当前安装的键盘提供了驱动器。当一个键被按下时，一个 8 位的扫描码 (scan code) 就被传递到计算机的键盘端口。当这个键被释放时，就会传递第二个扫描码。</p><p>MS-Windows 利用设备驱动程序将扫描码转换为 16 位的虚拟键码 (virtual-key code)，即 MS-Windows 定义的用于标识按键用途的与设备无关数值。MS-Windows 生成含有扫描码、虚拟键码和其他信息的消息。这个消息放在 MS-Windows 消息队列中，并最终进入当前执行程序线程（由控制台输入句柄标识）。</p><p>如果想要进一步了解键盘输入过程，请参阅 Platform SDK 文档中的 About Keyboard Input 主题。虚拟键常数列表位于本教程 \Examples\chll 目录下的 VirtualKeys.inc 文件中。</p><p>Irvine32 键盘过程 Irvine32 链接库由两个相关过程：</p><ul><li><p>ReadChar：等待键盘输入一个 ASCII 字符，并用 AL 返回该字符。</p></li><li><p>ReadKey：过程执行无等待键盘检查。如果控制台输入缓冲区中没有等待的按键，则零标志位置 1。如果发现有按键，则零标志位清零且 AL 等于零或 ASCII 码。EAX 和 EDX 的高 16 位被覆盖。</p></li></ul><p>如果 ReadKey 过程中的 AL 等于 0，那么用户可能按下了特殊键（功能键、光标箭头等）。AH 寄存器为键盘扫描码。DX 为虚拟键码，EBX 为键盘控制键状态信息。</p><p>下表为控制键值列表。调用 ReadKey 之后，可以用 TEST 指令检查各种键值。</p><table><thead><tr><th>值</th><th>含义</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td>CAPSLOCK_ON</td><td>CAPSLOCK 指示灯亮</td><td>RIGHT_ALT_PRESSED</td><td>右 ALT 键被按下</td></tr><tr><td>ENHANCED_KEY</td><td>被按下增强的</td><td>RIGHT_CTRL_PRESSED</td><td>右 CTRL 键被按下</td></tr><tr><td>LEFT_ALT_PRESSED</td><td>该键是左 ALT 键</td><td>SCROLLLOCL_ON</td><td>SCROLLLOCK 指示灯亮</td></tr><tr><td>LEFT_CTRL_PRESSED</td><td>左 CTRL 键被按下</td><td>SHIFT_PRESSED</td><td>SHIFT 键被按下</td></tr><tr><td>NUMLOCK_ON</td><td>NUMLOCK 指示灯亮</td><td></td><td></td></tr></tbody></table><h4 id="ReadKey-测试程序"><a href="#ReadKey-测试程序" class="headerlink" title="ReadKey 测试程序"></a>ReadKey 测试程序</h4><p>下面是 ReadKey 测试程序：等待一个按键，然后报告按下的是否为 CapsLock 键。程序应考虑延迟因素，以便在调用 ReadKey 时留出时间让 MS-Windows 处理其消息循环：</p><pre><code>; 测试 ReadKey    ( TestReadkey. asm)INCLUDE Irvine32.incINCLUDE Macros.inc.codemain PROCL1: mov    eax,10             ; 消息处理带来的延迟    call    Delay    call    ReadKey           ; 等待按键    jz    L1    test    ebx,CAPSLOCK_ON       jz    L2    mWrite &lt;"CapsLock is ON",0dh,0ah&gt;    jmp    L3L2:    mWrite &lt;"CapsLock is OFF",0dh,0ah&gt;L3:    exitmain ENDPEND main</code></pre><h2 id="汇编语言GetKeyState函数：获得键盘状态"><a href="#汇编语言GetKeyState函数：获得键盘状态" class="headerlink" title="汇编语言GetKeyState函数：获得键盘状态"></a>汇编语言GetKeyState函数：获得键盘状态</h2><p>通过测试单个键盘按键可以发现当前按下的是哪个键。方法是调用 API 函数 GetKeyState。</p><pre><code>GetKeyState PROTO, nVirtKey:DWORD</code></pre><p>向该函数传递如下表所示的虚拟键值。测试程序必须按照同一个表来测试 EAX 里面的返回值。</p><table><thead><tr><th>按键</th><th>虚拟键符号</th><th>EAX 中被测试的位</th></tr></thead><tbody><tr><td>NumLock</td><td>VK_NUMLOCK</td><td>0</td></tr><tr><td>Scroll Lock</td><td>VK_SCROLL</td><td>0</td></tr><tr><td>Left Shift</td><td>VK_LSHIFT</td><td>15</td></tr><tr><td>Right Shift</td><td>VK_tRSHIFT</td><td>15</td></tr><tr><td>Left Ctrl</td><td>VK_LCONTROL</td><td>15</td></tr><tr><td>Right Ctrl</td><td>VK_RCONTROL</td><td>15</td></tr><tr><td>Left Menu</td><td>VK_LMENU</td><td>15</td></tr><tr><td>Right Menu</td><td>VK_RMENU</td><td>15</td></tr></tbody></table><p>下面的测试程序通过检查 NumLock 键和左 Shift 键的状态来演示 GetKeyState 函数：</p><pre><code>; 键盘切换键    （Keybd.asm）INCLUDE Irvine32.incINCLUDE Macros.inc; 如果当前触发了切换键 (CapsLock, NumLock, ScrollLock)，; 则 GetKeyState 将 EAX 的位 0 置 1; 如果当前按下了特殊键，则将 EAX 的最高位置 1.codemain PROC    INVOKE GetKeyState, VK_NUMLOCK    test al,1    .IF !Zero?      mWrite &lt;"The NumLock key is ON",0dh,0ah&gt;    .ENDIF    INVOKE GetKeyState, VK_LSHIFT    call DumpRegs    test eax,80000000h    .IF !Zero?      mWrite &lt;"The Left Shift key is currently DOWN",0dh,0ah&gt;    .ENDIF    exitmain ENDPEND main</code></pre><h2 id="汇编语言WriteConsole和WriteConsoleOutputCharacter函数：控制台输出"><a href="#汇编语言WriteConsole和WriteConsoleOutputCharacter函数：控制台输出" class="headerlink" title="汇编语言WriteConsole和WriteConsoleOutputCharacter函数：控制台输出"></a>汇编语言WriteConsole和WriteConsoleOutputCharacter函数：控制台输出</h2><p>有些 Win32 控制台函数使用的是预定义的数据结构，包括 COORD 和 SMALL_RECT。COORD 结构包含的是控制台屏幕缓冲区内字符单元格的坐标。坐标原点（0, 0）位于左上角单元格：</p><pre><code>COORD STRUCT   X WORD ?   Y WORD ?COORD ENDS</code></pre><p>SMALL_RECT 结构包含的是矩形的左上角和右下角，它指定控制台窗口中的屏幕缓冲区字符单元格区域：</p><pre><code>SMALL_RECT STRUCT   Left WORD ?   Top WORD ?   Right WORD ?   Bottom WORD ?SMALL_RECT ENDS</code></pre><h3 id="WriteConsole-函数"><a href="#WriteConsole-函数" class="headerlink" title="WriteConsole 函数"></a>WriteConsole 函数</h3><p>函数 WriteConsole 在控制台窗口的当前光标所在位置写一个字符串，并将光标留着字符串末尾右边的字符位置上。它按照标准 ASCII 控制字符操作，比如制表符、回车和换行。</p><p>字符串不一定以空字节结束。函数原型如下：</p><pre><code>WriteConsole PROTO,   hConsoleOutput:HANDLE,   lpBuffer:PTR BYTE,   nNumberOfCharsToWrite:DWORD,   lpNumberOfCharsWritten:PTR DWORD,   lpReserved:DWORD</code></pre><p>hConsoleOutput 是控制台输出流句柄；lpBuffer 是输出字符数组的指针；nNumberOfCharsToWrite 是数组长度；lpNumberOfCharsWritten 是函数返回时实际输出字符数量的整数指针。最后一个参数未使用，因此将其设置为 0。</p><h3 id="示例程序：Console1"><a href="#示例程序：Console1" class="headerlink" title="示例程序：Console1"></a>示例程序：Console1</h3><p>下面的程序通过向控制台窗口写字符串演示了函数 GetStdHandle、ExitProcess 和 WriteConsole：</p><pre><code>; Win32 控制台示例 #1    (Consolel.asm); 本程序调用如下 Win32 控制台函数:; GetStdHandle, ExitProcess, WriteConsoleINCLUDE Irvine32.inc.dataendl EQU &lt;0dh,0ah&gt;            ; 行结尾message LABEL BYTE    BYTE "This program is a simple demonstration of "    BYTE "console mode output, using the GetStdHandle "    BYTE "and WriteConsole functions.", endlmessageSize DWORD ($-message)consoleHandle HANDLE 0     ; 标准输出设备句柄bytesWritten  DWORD ?      ; 输出字节数.codemain PROC  ; 获得控制台输出句柄    INVOKE GetStdHandle, STD_OUTPUT_HANDLE    mov consoleHandle,eax  ; 向控制台写一个字符串    INVOKE WriteConsole,      consoleHandle,          ; 控制台输出句柄      ADDR message,           ; 字符串指针      messageSize,            ; 字符长度      ADDR bytesWritten,      ; 返回输出字节数      0                       ; 未使用    INVOKE ExitProcess,0main ENDPEND main</code></pre><p>程序生成输出如下所示：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226429825295" alt="img"></p><h3 id="WriteConsoleOutputCharacter-函数"><a href="#WriteConsoleOutputCharacter-函数" class="headerlink" title="WriteConsoleOutputCharacter 函数"></a>WriteConsoleOutputCharacter 函数</h3><p>函数 WriteConsoleOutputCharacter 从指定位置开始，向控制台屏幕缓冲区的连续单元格内复制一组字符。原型如下：</p><pre><code>WriteConsoleOutputCharacter PROTO,   hConsoleOutput:HANDLE,             ;控制台输出句柄   lpCharacter :PTR BYTE,                ;缓冲区指针   nLength: DWORD,                   ;缓冲区大小   dwWriteCoord: COORD,               ;第一个单元格的坐标   lpNumberOfCharsWritten: PTR DWORD  ;输出计数器</code></pre><p>如果文本长度超过了一行，字符就会输岀到下一行。屏幕缓冲区的属性值不会改变。如果函数不能写字符，则返回零。ASCII 码，如制表符、回车和换行，会被忽略。</p><h2 id="汇编语言CreateFile函数：创建新文件或者打开已有文件"><a href="#汇编语言CreateFile函数：创建新文件或者打开已有文件" class="headerlink" title="汇编语言CreateFile函数：创建新文件或者打开已有文件"></a>汇编语言CreateFile函数：创建新文件或者打开已有文件</h2><p>函数 CreateFile 可以创建一个新文件或者打开一个已有文件。如果调用成功，函数返回打开文件的句柄；否则，返回特殊常数 INVALID_HANDLE_VALUEO 原型如下：</p><pre><code>CreateFile PROTO,                ;创建新文件   lpFilename:PTR BYTE,            ;文件名指针   dwDesiredAccess:DWORD,       ;访问模式   dwShareMode:DWORD,         ;共享模式   lpSecurityAttributes:DWORD,     ;安全属性指针   dwCreationDisposition:DWORD,   ;文件创建选项   dwFlagsAndAttributes:DWORD,   ;文件属性   hTemplateFile:DWORD          ;文件模板句柄</code></pre><p>下表对参数进行了说明。如果函数调用失败则返回值为零。</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>lpFileName</td><td>指向一个空字节结束字符串，该串为部分或全部合格的文件名（drive:\path\filename）</td></tr><tr><td>dwDesiredAccess</td><td>指定文件访问方式（读或写）</td></tr><tr><td>dwShareMode</td><td>控制多个程序对打开文件的访问能力</td></tr><tr><td>lpSecurityAttributes</td><td>指向安全结构，该结构控制安全权限</td></tr><tr><td>dwCreationDisposition</td><td>指定文件存在或不存在时的操作</td></tr><tr><td>dwFlagsAndAttributes</td><td>包含位标志指定文件属性，如存档、加密、隐藏、普通、系统和临时</td></tr><tr><td>hTemplateFile</td><td>包含一个可选的文件模板句柄，该文件为已创建的文件提供文件属性和扩展属性；如果不使用该参数，就将其设置为 0</td></tr></tbody></table><h4 id="dwDesiredAccess"><a href="#dwDesiredAccess" class="headerlink" title="dwDesiredAccess"></a>dwDesiredAccess</h4><p>参数 dwDesiredAccess 允许指定对文件进行读访问、写访问、读/写访问，或者设备查询访问。可以从下表列出的值中选择，也可以从表中未列出的更多特定标志值选择。</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>为对象指定设备查询访问。应用程序可以查询设备属性而无需访问设备，也可以检查文件是否存在</td></tr><tr><td>GENERIC_READ</td><td>为对象指定读访问。可以从文件中读取数据，文件指针可以移动。与 GENERIC_WRITE 一起使用为读/写访问</td></tr><tr><td>GENERIC_WRITE</td><td>对对象指定写访问。可以向文件中写入数据，文件指针可以移动。与 GENERIC_READ 一起使用为读/写访问</td></tr></tbody></table><h4 id="dwCreationDisposition"><a href="#dwCreationDisposition" class="headerlink" title="dwCreationDisposition"></a>dwCreationDisposition</h4><p>参数 dwCreationDisposition 指定当文件存在或不存在时应采取怎样的操作。可从下表中选择一个值。</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>CREATE_NEW</td><td>创建一个新文件。要求将参数 dwDesiredAccess 设置为 GENERIC_WRITE。如果文件已经存在，则函数调用失败</td></tr><tr><td>CREATE_ALWAYS</td><td>创建一个新文件。如果文件已存在，则函数会覆盖原文件，清除现有属性，并合并文件 属性与预定义的常数 FILE_ATTRIBUTES_ARCHIVE 中属性参数指定的标志。要求将参数 dwDesiredAccess 设置为 GENERIC WRITE</td></tr><tr><td>OPEN_EXISTING</td><td>打开文件。如果文件不存在，则函数调用失败。可用于读取和/或写入文件</td></tr><tr><td>OPEN_ALWAYS</td><td>如果文件存在，则打开文件。如果不存在，则函数创建文件，就好像CreateDisposition 的值为 CREATE NEW</td></tr><tr><td>TRUNCATE_EXISTING</td><td>打开文件。一旦打开，文件将被截断，使其大小为零。要求将参数 dwDesiredAccess 设置为 GENERIC_WRITE。如果文件不存在，则函数调用失败</td></tr></tbody></table><p>下表列出了参数 dwFlagsAndAttributes 比较常用的值。（完整列表请在 Microsoft 在线文档中搜索CreateFiko）允许任意属性组合，除了 FILE_ATTRIBUTE_NORMAL 会被其他 所有属性覆盖。这些值能映射为 2 的幂，因此可以用汇编时 OR 运算符或 + 运算符将它们组 合为一个参数：</p><pre><code>FILE_ATTRIBUTE_HIDDEN OR FILE_ATTRIBUTE_READONLYFILE_ATTRIBUTE_HIDDEN + FILE_ATTRIBUTE_READONLY</code></pre><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>FILE_ATTRIBUTE_ARCHIVE</td><td>文件存档。应用程序使用这个属性标记文件以便备份或移动</td></tr><tr><td>FILE_ATTRIBUTE_HIDDEN</td><td>文件隐藏。不包含在普通目录列表中</td></tr><tr><td>FILE_ATTRIBUTE_NORMAL</td><td>文件没有其他属性设置。该属性只在单独使用时有效</td></tr><tr><td>FILE_ATTRIBUTE_READONLY</td><td>文件只读。应用程序可以读文件但不能写或删除文件</td></tr><tr><td>FILE_ATTRIBUTE_TEMPORARY</td><td>文件被用于临时存储</td></tr></tbody></table><p>【示例】下面的例子仅具说明性，展示了如何创建和打开文件。请参阅在线从 Microsoft文 档，了解 CreateFile 更多可用选项：</p><p>打开并读取（输入）已存在文件：</p><pre><code>INVOKE CreateFile,    ADDR filename,            ;文件名指针    GENERIC_READ,             ;读文件    DO_NOT_SHARE,             ;共享模式    NULL,                     ;安全属性指针    OPEN_EXISTING,            ;打开已存在文件    FILE_ATTRIBUTE_NORMALA    ;普通文件属性    0                         ;未使用</code></pre><p>打开并写入（输出）已存在文件。文件打开后，可以通过写入覆盖当前数据，或者将文件指针移到末尾，向文件添加新数据（参见11.1.6节的SetFilePointer）：</p><pre><code>INVOKE CreateFile,    ADDR filename,    GENERIC_WRITEZ,      ;写文件    DO_NOT_SHARE,    NULL,    OPEN_EXISTIN,       ;文件必须存在    FILE_ATTRIBUTE_NORMAL,    0</code></pre><p>创建有普通属性的新文件，并删除所有已存在的同名文件：</p><pre><code>INVOKE CreateFile,    ADDR filename,    GENERIC_WRITE,       ;写文件    DO _NOT_SHARE,    NULL,    CREATE_ALWAYS,       ;覆盖已存在的文件    FILE_ATTRIBUTE_NORMAL,    0</code></pre><p>若文件不存在，则创建文件；否则打开并输出现有文件：</p><pre><code>INVOKE CreateFile,    ADDR filename,    GENERIC_WRITE,         ;写文件    DO_NOT_SHARE,    NULL,    CREATE_NEW,            ;不删除已存在文件    FILE_ATTRIBUTE_NORMAL,    0</code></pre><h2 id="汇编语言CloseHandle函数：关闭一个打开的对象句柄"><a href="#汇编语言CloseHandle函数：关闭一个打开的对象句柄" class="headerlink" title="汇编语言CloseHandle函数：关闭一个打开的对象句柄"></a>汇编语言CloseHandle函数：关闭一个打开的对象句柄</h2><p>函数 CloseHandle 关闭一个打开的对象句柄。其原型如下：</p><pre><code>CloseHandle PROTO,  hObject: HANDLE ;对象句柄</code></pre><p>可以用 CloseHandle 关闭当前打开的文件句柄。如果函数调用失败，则返回值为零。</p><h2 id="汇编语言ReadFile函数：从输入文件中读取文本"><a href="#汇编语言ReadFile函数：从输入文件中读取文本" class="headerlink" title="汇编语言ReadFile函数：从输入文件中读取文本"></a>汇编语言ReadFile函数：从输入文件中读取文本</h2><p>函数 ReadFile 从输入文件中读取文本。其原型如下：</p><pre><code>ReadFile PROTO,   hFile:HANDLE,                      ;输入句柄   lpBuffer:PTR BYTE,                   ;缓冲区指针   nNumberOfBytesToRead:DWORD,          ;读取的字节数   lpNumberOfBytesRead:PTR DWORD,      ;实际读出的 字节数   lpOverlapped:PTR DWORD            ;异步信息指针</code></pre><p>其中：</p><ul><li><p>hFile 是由 CreateFile 返回的打开文件的句柄；</p></li><li><p>lpBuffer 指向的缓冲区接收从该文件读取的数据；</p></li><li><p>nNumberOfBytesToRead 定义从该文件读取的最大字节数；</p></li><li><p>lpNumberOfBytesRead 指向的整数为函数返回时实际读取的字节数；</p></li><li><p>lpOverlapped 应被设置为 NULL(0)。若函数调用失败，则返回值为零。</p></li></ul><p>如果对同一个打开文件的句柄进行多次调用，那么 ReadFile 就会记住最后一次读取的位置，并从这个位置开始读。换句话说，函数有一个内部指针指向文件内的当前位置。</p><p>ReadFile 还可以运行在异步模式下，这意味着调用程序不用等到读操作完成。</p><h2 id="汇编语言WriteFile函数：向文件写入数据"><a href="#汇编语言WriteFile函数：向文件写入数据" class="headerlink" title="汇编语言WriteFile函数：向文件写入数据"></a>汇编语言WriteFile函数：向文件写入数据</h2><p>函数 WriteFile 用输出句柄向文件写入数据。句柄可以是屏幕缓冲区句柄，也可以是分配给文本文件的句柄。函数从文件内部位置指针所指向的位置开始写数据。</p><p>写操作完成后，文件位置指针按照实际写入的字节数进行调整。函数原型如下：</p><pre><code>WriteFile PROTO,   hFile:HANDLE,                      ;输出句柄   lpBuffer:PTR BYTE,                   ;缓冲区指针   nNumberOfBytesToWrite:DWORD,      ;缓冲区大小   lpNumberOfBytesWritten:PTR DWORD,  ;写入字节数   lpOverlapped:PTR DWORD            ;异步信息指针</code></pre><p>其中：</p><ul><li><p>hFile 是已打开文件的句柄；</p></li><li><p>lpBuffer 指向的缓冲区包含了写入到文件的数据；</p></li><li><p>nNumberOfBytesToWrite 指定向文件写入多少字节；</p></li><li><p>lpNumberOfBytesWritten 指向的整数为函数执行后实际写入的字节数；</p></li><li><p>若为同步操作，则 lpOverlapped 应被设置为 NULL。若函数调用失败，则返回值为零。</p></li></ul><h2 id="汇编语言SetFilePointer函数：移动打开文件的位置指针"><a href="#汇编语言SetFilePointer函数：移动打开文件的位置指针" class="headerlink" title="汇编语言SetFilePointer函数：移动打开文件的位置指针"></a>汇编语言SetFilePointer函数：移动打开文件的位置指针</h2><p>函数 SetFilePointer 移动打开文件的位置指针。该函数可以用于向文件添加数据，或是执行随机访问记录处理：</p><pre><code>SetFilePointer PROTO,   hFile:HANDLE,                     ;文件句柄   lpDistanceToMove:SDWORD,         ;指针移动 字节数   lpDistanceToMoveHigh:PTR SDWORD,  ;指针移动字节数，高双字   dwMoveMethod:DWORD            ;起点</code></pre><p>若函数调用失败，则返回值为零。dwMoveMode 指定文件指针移动的起点，选择项为 3 个预定义符号：FILE_BEGIN、FILE_CURRENT 和 FILE_END。</p><p>移动距离本身为 64 位有符号整数值，分为两个部分：</p><ul><li><p>lpDistanceToMove：低 32 位</p></li><li><p>lpDistanceToMoveHigh：含有高 32 位的变量指针</p></li></ul><p>如果 lpDistanceToMoveHigh 为空，则只用 lpDistanceToMove 的值来移动文件指针。例如，下面的代码准备添加到一个文件末尾：</p><pre><code>INVOKE SetFilePointer,   fileHandle,       ;文件句柄   0,           ;距离低32位   0,           ;距离高32位   FILE_END     ;移动模式</code></pre><h2 id="汇编语言Irvine32链接库文件I-O（输入-输出）"><a href="#汇编语言Irvine32链接库文件I-O（输入-输出）" class="headerlink" title="汇编语言Irvine32链接库文件I/O（输入/输出）"></a>汇编语言Irvine32链接库文件I/O（输入/输出）</h2><p>Irvine32 库中包含了一些简化的文件 I/O 过程。这些过程已经封装到本章描述的 Win32 API 函数中。</p><p>下面的源代码就给岀了 CreateOutputFile、OpenFile、WriteToFile、ReadFromFile 和 CloseFile：</p><pre><code>;------------------------------------------------------CreateOutputFile PROC;; 创建一个新文件并以输出模式打开; 接收: EDX 指向文件名; 返回: 如果文件创建成功, EAX 包含一个有效的文件句柄。 ; 否则，EAX 等于 INVALID_HANDLE_VALUE;------------------------------------------------------    INVOKE CreateFile,      edx, GENERIC_WRITE, DO_NOT_SHARE, NULL,      CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0    retCreateOutputFile ENDP;-------------------------------------------------------OpenFile PROC;打开一个新的文本文件进行输入。;接收：EDX 指向文件名。;返回：如果文件打开成功，EAX 包含一个有效的文件;句柄。否则，EAX 等于 INVALID_HANDLE_VALUE。;-------------------------------------------------------    INVOKE CreateFilez        edx, GENERIC_READ, DO_NOT_SHARE, NULL,        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0    retOpenFile ENDP;--------------------------------------------------------WriteToFile PROC;; 将缓冲区内容写入一个输出文件; 接收: EAX = 文件句柄, EDX = 缓冲区偏移量,;    ECX = 写入字节数; 返回: EAX = 实际写入文件的字节数; 如果 EAX 返回的值小于 ECX 中的参数， 则可能发生错误;--------------------------------------------------------.dataWriteToFile_1 DWORD ?        ; 已写入字节数.code    INVOKE WriteFile,        ; 向文件写缓冲区        eax,                 ; 文件句柄        edx,                 ; 缓冲区指针        ecx,                 ; 写入字节数        ADDR WriteToFile_1,  ; 已写入字节数        0                    ; 覆盖执行标志    mov    eax,WriteToFile_1 ; 返回值    retWriteToFile ENDP;--------------------------------------------------------ReadFromFile PROC; 将一个输入文件读入缓冲区; 接收: EAX = 文件句柄, EDX = 缓冲区偏移量,;    ECX = 读字节数; 返回: 如果 CF=0，EAX = 已读字节数; 如果 CF=1，则EAX包含Win32 API 函数 GetLastError 返回的系统错误码;--------------------------------------------------------.dataReadFromFile_1 DWORD ?            ; 已读字节数.code    INVOKE ReadFile,        eax,                      ; 文件句柄        edx,                      ; 缓冲区指针        ecx,                      ; 读取的最大字节数        ADDR ReadFromFile_1,      ; 已读字节数        0                         ; 覆盖执行标志    mov    eax,ReadFromFile_1    retReadFromFile ENDP;--------------------------------------------------------CloseFile PROC; 使用句柄为标识符关闭一个文件; 接收: EAX = 文件句柄; 返回: EAX = 非 0，如果文件被成功关闭;--------------------------------------------------------    INVOKE CloseHandle, eax    retCloseFile ENDP</code></pre><h2 id="汇编语言实例：文件I-O（输入-输出）过程"><a href="#汇编语言实例：文件I-O（输入-输出）过程" class="headerlink" title="汇编语言实例：文件I/O（输入/输出）过程"></a>汇编语言实例：文件I/O（输入/输出）过程</h2><p>下面通过两个实例程序来演示文件I/O（输入/输出）的过程。</p><h4 id="1-CreatFile-程序示例"><a href="#1-CreatFile-程序示例" class="headerlink" title="1) CreatFile 程序示例"></a>1) CreatFile 程序示例</h4><p>下面的程序用输岀模式创建一个文件，要求用户输入一些文本，将这些文本写到输出文件，并报告已写入的字节数，然后关闭文件。在试图创建文件后，程序要进行错误检查：</p><pre><code>; 创建一个文件    (CreateFile.asm)INCLUDE Irvine32.inc BUFFER_SIZE = 501.databuffer BYTE BUFFER_SIZE DUP(?)filename     BYTE "output.txt",0fileHandle   HANDLE ?stringLength DWORD ?bytesWritten DWORD ?str1 BYTE "Cannot create file",0dh,0ah,0str2 BYTE "Bytes written to file [output.txt]: ",0str3 BYTE "Enter up to 500 characters and press "     BYTE "[Enter]: ",0dh,0ah,0.codemain PROC; 创建一个新文本文件    mov    edx,OFFSET filename    call    CreateOutputFile    mov    fileHandle,eax; 错误检查    cmp    eax, INVALID_HANDLE_VALUE      ; 发现错误?    jne    file_ok                        ; 否: 跳过    mov    edx,OFFSET str1                ; 显示错误    call    WriteString    jmp    quitfile_ok:; 提示用户输入字符串    mov    edx,OFFSET str3                 ; "Enter up to ...."    call    WriteString    mov    ecx,BUFFER_SIZE                 ; 输入字符串    mov    edx,OFFSET buffer    call    ReadString    mov    stringLength,eax                ; 计算输入字符数; 将缓冲区写入输出文件    mov    eax,fileHandle    mov    edx,OFFSET buffer    mov    ecx,stringLength    call    WriteToFile    mov    bytesWritten,eax                ; 保存返回值    call    CloseFile; 显示返回值    mov    edx,OFFSET str2                 ; "Bytes written"    call    WriteString    mov    eax,bytesWritten    call    WriteDec    call    Crlfquit:    exitmain ENDPEND main</code></pre><h4 id="2-ReacIFile-程序示例"><a href="#2-ReacIFile-程序示例" class="headerlink" title="2) ReacIFile 程序示例"></a>2) ReacIFile 程序示例</h4><p>下面的程序打开一个文件进行输入，将文件内容读入缓冲区，并显示该缓冲区。所有过程都从 Irvine32 链接库调用：</p><pre><code>; 读文件      (ReadFile.asm); 使用 Irvine32.lib 的过程打开，读取并显示一个文本文件INCLUDE Irvine32.incINCLUDE macros.incBUFFER_SIZE = 5000.databuffer BYTE BUFFER_SIZE DUP(?)filename    BYTE 80 DUP(0)fileHandle  HANDLE ?.codemain PROC; 用户输入文件名    mWrite "Enter an input filename: "    mov    edx,OFFSET filename    mov    ecx,SIZEOF filename    call    ReadString; 打开文件进行输入    mov    edx,OFFSET filename    call    OpenInputFile    mov    fileHandle,eax; 错误检查    cmp    eax,INVALID_HANDLE_VALUE           ; 错误打开文件?    jne    file_ok                            ; 否: 跳过    mWrite &lt;"Cannot open file",0dh,0ah&gt;    jmp    quit                               ; 退出file_ok:; 将文件读入缓冲区    mov    edx,OFFSET buffer    mov    ecx,BUFFER_SIZE    call    ReadFromFile    jnc    check_buffer_size                ; 错误读取?    mWrite "Error reading file. "           ; 是: 显示错误消息    call    WriteWindowsMsg    jmp    close_filecheck_buffer_size:    cmp    eax,BUFFER_SIZE                    ; 缓冲区足够大?    jb    buf_size_ok                         ; 是    mWrite &lt;"Error: Buffer too small for the file",0dh,0ah&gt;    jmp    quit                               ; 退出buf_size_ok:       mov    buffer[eax],0                    ; 插入空结束符    mWrite "File size: "    call    WriteDec                        ; 显示文件大小    call    Crlf; 显示缓冲区    mWrite &lt;"Buffer:",0dh,0ah,0dh,0ah&gt;    mov    edx,OFFSET buffer                ; 显示缓冲区    call    WriteString    call    Crlfclose_file:    mov    eax,fileHandle    call    CloseFilequit:    exitmain ENDPEND main</code></pre><p>如果文件不能打开，则程序报告错误：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226484914297" alt="img"></p><p>如果程序不能从文件读取，则报告错误。比如，假设有一个错误为在读文件时使用了不正确的文件句柄：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226510143299" alt="img"></p><p>缓冲区可能太小，无法容纳文件：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226518517301" alt="img"></p><h2 id="汇编语言控制台窗口操作"><a href="#汇编语言控制台窗口操作" class="headerlink" title="汇编语言控制台窗口操作"></a>汇编语言控制台窗口操作</h2><p>Win32 API 提供了对控制台窗口及其缓冲区相当大的控制权。下图显示了屏幕缓冲区可以大于控制台窗口当前显示的行数。控制台窗口就像是一个“视窗”，显示部分缓冲区。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226571769303" alt="img"></p><p>下列函数影响的是控制台窗口及其相对于屏幕缓冲区的位置：</p><ul><li><p>SetConsoleWindowInfo：设置控制台窗口相对于屏幕缓冲区的大小和位置。</p></li><li><p>GetConsoleScreenBufferInfo：返回（还包括其他一些信息）控制台窗口相对于屏幕缓冲区的矩形坐标。</p></li><li><p>SetConsoleCursorPosition：将光标设置在屏幕缓冲区内的任何位置；如果区域不可见，则移动控制台窗口直到光标可见。</p></li><li><p>ScrollConsoleScreenBuffer：移动屏幕缓冲区中的一些或全部文本，本函数会影响控制台窗口显示的文本。</p></li></ul><h4 id="1-SetConsoleTitle"><a href="#1-SetConsoleTitle" class="headerlink" title="1) SetConsoleTitle"></a>1) SetConsoleTitle</h4><p>函数 SetConsoleTitle 可以改变控制台窗口的标题。示例如下：</p><pre><code>.data.titleStr BYTE "Console title", 0.codeINVOKE SetConsoleTitle, ADDR titleStr</code></pre><h4 id="2-GetConsoleScreenBufferInfo"><a href="#2-GetConsoleScreenBufferInfo" class="headerlink" title="2) GetConsoleScreenBufferInfo"></a>2) GetConsoleScreenBufferInfo</h4><p>函数 GetConsoleScreenBufferInfo 返回控制台窗口的当前状态信息。它有两个参数：控制台屏幕的句柄和指向该函数填充的结构的指针：</p><pre><code>GetConsoleScreenBufferInfo PROTO,   hConsoleOutput:HANDLE,   lpConsoleScreenBufferInfo:PTR CONSOLE_SCREEN_BUFFER_INFO</code></pre><p>CONSOLE_SCREEN_BUFFER_INFO 结构如下：</p><pre><code>CONSOLE_SCREEN_BUFFER_INFO STRUCT    dwSize COORD &lt;&gt;    dwCursorPosition COORD &lt;&gt;    wAttributes WORD ?    srWindow SMALL_RECT &lt;&gt;    dwMaximumWindowSize COORD &lt;&gt;CONSOLE_SCREEN_BUFFER_INFO ENDS</code></pre><p>dwSize 按字符行列数返回屏幕缓冲区大小。dwCursorPosition 返回光标的位置。这两个字段都是 COORD 结构。</p><p>wAttributes 返回字符的前景色和背景色，字符由诸如 WriteConsole 和 WriteFile 等函数写到控制台。srWindow 返回控制台窗口相对于屏幕缓冲区的坐标。</p><p>dwMaximumWindowSize 以当前屏幕缓冲区的大小、字体和视频显示大小为基础，返回控制台窗口的最大尺寸。函数示例调用如下所示：</p><pre><code>.dataconsoleInfo CONSOLE_SCREEN_BUFFER_INFO &lt;&gt;outHandle HANDLE ?.codeINVOKE GetConsoleScreenBufferInfo, outHandle,   ADDR consoleInfo</code></pre><h4 id="3-SetConsoleWindowInfo-函数"><a href="#3-SetConsoleWindowInfo-函数" class="headerlink" title="3) SetConsoleWindowInfo 函数"></a>3) SetConsoleWindowInfo 函数</h4><p>函数 SetConsoleWindowInfo 可以设置控制台窗口相对于其屏幕缓冲区的大小和位置。函数原型如下：</p><pre><code>SetConsoleWindowInfo PROTO,   hConsoleOutput:HANDLE,         ;屏幕缓冲区句柄   bAbsolute:DWORD,               ;坐标类型   lpConsoleWindow:PTR SMALL_RECT ;矩形窗口指针</code></pre><p>bAbsolute 说明如何使用结构中由 lpConsoleWindow 指出的坐标。如果 bAbsolute 为真，则坐标定义控制台窗口新的左上角和右下角。如果 bAbsolute 为假，则坐标与当前窗口坐标相加。</p><p>下面的程序向屏幕缓冲区写 50 行文本。然后重定义控制台窗口的大小和位置，有效地向后滚动文本。该程序使用了函数 SetConsoleWindowInfo：</p><pre><code>; 滚动控制台窗口    (Scroll.asm)INCLUDE Irvine32.inc.datamessage BYTE ":  This line of text was written "        BYTE "to the screen buffer",0dh,0ahmessageSize DWORD ($-message)outHandle     HANDLE 0                     ; 标准输出句柄bytesWritten  DWORD ?                      ; 已写入字节数lineNum DWORD 0windowRect    SMALL_RECT &lt;0,0,60,11&gt;       ; 上，下，左，右.codemain PROC    INVOKE GetStdHandle, STD_OUTPUT_HANDLE    mov outHandle,eax.REPEAT      mov    eax,lineNum      call    WriteDec                     ; 显示每行编号    INVOKE WriteConsole,      outHandle,                           ; 控制台输出句柄      ADDR message,                        ; 字符串指针      messageSize,                         ; 字符串长度      ADDR bytesWritten,                   ; 返回已写字节数      0                                    ; 未使用      inc  lineNum                         ; 下一行编号.UNTIL lineNum &gt; 50; 调整控制台窗口相对于屏幕缓冲区的大小和位置    INVOKE SetConsoleWindowInfo,      outHandle,      TRUE,      ADDR windowRect    call    Readchar                      ; 等待按键    call    Clrscr                        ; 清除屏幕缓冲区    call    Readchar                      ; 等待第二次按键    INVOKE ExitProcess,0main ENDPEND main</code></pre><p>最好能直接从 MS-Windows Exlporer 中，或者直接以命令行形式运行程序，而不使用集成的编辑环境。否则，编辑器可能会影响控制台窗口的行为和外观。在程序结束时需要两次按键：第一次清除屏幕缓冲区，第二次结束程序。</p><h4 id="4-SetConsoleScreenBufferSize-函数"><a href="#4-SetConsoleScreenBufferSize-函数" class="headerlink" title="4) SetConsoleScreenBufferSize 函数"></a>4) SetConsoleScreenBufferSize 函数</h4><p>函数 SetConsoleScreenBufferSize 可以将屏幕缓冲区设置为 X 列 * Y 行。其原型如下：</p><pre><code>SetConsoleScreenBufferSize PROTO,   hConsoleOutput:HANDLE,                ;屏幕缓冲区句柄   dwSize:COORD                  ;新屏幕缓冲区大小</code></pre><h2 id="汇编语言控制台光标设置函数简述"><a href="#汇编语言控制台光标设置函数简述" class="headerlink" title="汇编语言控制台光标设置函数简述"></a>汇编语言控制台光标设置函数简述</h2><p>Win32 API 提供了函数用于设置控制台应用光标的大小、可见度和屏幕位置。与这些函数相关的重要数据结构是 CONSOLE_CURSOR_INFO，其中包含了控制台光标的大小和可见度信息：</p><pre><code>CONSOLE_CURSOR_INFO STRUCT   dwSize DWORD ?   bVisible DWORD ?CONSOLE_CURSOR_INFO ENDS</code></pre><p>dwSize 为光标填充的字符单元格的百分比（从 1 到 100）。如果光标可见，则 bVisible 等于 TRUE(1)。</p><h4 id="1-GetConsoleCursorInfo-函数"><a href="#1-GetConsoleCursorInfo-函数" class="headerlink" title="1) GetConsoleCursorInfo 函数"></a>1) GetConsoleCursorInfo 函数</h4><p>函数 GetConsoleCursorInfo 返回控制台光标的大小和可见度。需向其传递指向结构 CONSOLE_CURSOR_INFO 的指针：</p><pre><code>GetConsoleCursorInfo PROTO,   hConsoleOutput:HANDLE,   lpConsoleCursorInfo:PTR CONSOLE_CURSOR_INFO</code></pre><p>默认情况下，光标大小为 25，这表示光标占据了 25% 的字符单元格。</p><h4 id="2-SetConsoleCursorInfo-函数"><a href="#2-SetConsoleCursorInfo-函数" class="headerlink" title="2) SetConsoleCursorInfo 函数"></a>2) SetConsoleCursorInfo 函数</h4><p>函数 SetConsoleCursorInfo 设置光标的大小和可见度。需向其传递指向结构 CONSOLE_CURSOR_INFO 的指针：</p><pre><code>SetConsoleCursorInfo PROTO,   hConsoleOutput:HANDLE,   lpConsoleCursorInfo:PTR CONSOLE_CURSOR_INFO</code></pre><h4 id="3-SetConsoleCursorPosition"><a href="#3-SetConsoleCursorPosition" class="headerlink" title="3) SetConsoleCursorPosition"></a>3) SetConsoleCursorPosition</h4><p>函数 SetConsoleCursorPosition 设置光标的 X、Y 位置。向其传递一个 COORD 结构和控制台输岀句柄：</p><pre><code>SetConsoleCursorPosition PROTO,   hConsoleOutput:DWORD,   ;输入模式句柄   dwCursorPosition:COORD   ;屏幕 X、Y 坐标</code></pre><h2 id="汇编语言SetConsoleTextAttribute和WriteConsoleOutputAttribute函数：控制文本颜色"><a href="#汇编语言SetConsoleTextAttribute和WriteConsoleOutputAttribute函数：控制文本颜色" class="headerlink" title="汇编语言SetConsoleTextAttribute和WriteConsoleOutputAttribute函数：控制文本颜色"></a>汇编语言SetConsoleTextAttribute和WriteConsoleOutputAttribute函数：控制文本颜色</h2><p>控制台窗口中的文本颜色有两种控制方法。</p><ul><li><p>通过调用 SetConsoleTextAttribute 来改变当前文本颜色，这种方法会影响控制台中所有后续输出文本。</p></li><li><p>调用 WriteConsoleOutputAttribute 来设置指定单元格的属性。函数 GetConsoleScreenBufferlnfo 返回当前屏幕的颜色以及其他控制台信息。</p></li></ul><h4 id="1-SetConsoleTextAttribute-函数"><a href="#1-SetConsoleTextAttribute-函数" class="headerlink" title="1) SetConsoleTextAttribute 函数"></a>1) SetConsoleTextAttribute 函数</h4><p>函数 SetConsoleTextAttribute 可以设置控制台窗口所有后续输出文本的前景色和背景色。原型如下：</p><pre><code>SetConsoleTextAttribute PROTO,   hConsoleOutput:HANDLE,          ;控制台输出句柄   wAttributes : WORD           ;颜色属性</code></pre><p>颜色值保存在 wAttributes 参数的低字节中。</p><h4 id="2-WriteConsoleOutputAttribute-函数"><a href="#2-WriteConsoleOutputAttribute-函数" class="headerlink" title="2) WriteConsoleOutputAttribute 函数"></a>2) WriteConsoleOutputAttribute 函数</h4><p>函数 WriteConsoleOutputAttribute 从指定位置开始，向控制台屏幕缓冲区的连续单元格复制一组属性值。原型如下：</p><pre><code>WriteConsoleOutputAttribute PROTO,   hConsoleOutput:DWORD,                ;输出句柄   lpAttribute:PTR WORD,                  ;写属性   nLength:DWORD,                      ;单元格数   dwWriteCoord :COORD,                 ;第一个单元格坐标   lpNumberOfAttrsWritten:PTR DWORD          ;输出计数</code></pre><p>其中：</p><ul><li><p>lpAttribute 指向属性数组，其中每个字节的低字节都包含了颜色值；</p></li><li><p>nLength 为数组长度；</p></li><li><p>dwWriteCoord 为接收属性的开始屏幕单元格；</p></li><li><p>lpNumberOfAttrsWritten 指向一个变量，其中保存的是已写单元格的数量。</p></li></ul><h4 id="3-示例：写文本颜色"><a href="#3-示例：写文本颜色" class="headerlink" title="3) 示例：写文本颜色"></a>3) 示例：写文本颜色</h4><p>为了演示颜色和属性的用法，程序 WriteColors.asm 创建了一个字符数组和一个属性数组， 属性数组中的每个元素都对应一个字符。程序调用 WriteConsoleOutputAttribute 将属性复制到屏幕缓冲区，调用 WriteConsoleOutputCharacter 将字符复制到相同的屏幕缓冲区单元格：</p><pre><code>; 写文本颜色      (WriteColors.asm)INCLUDE Irvine32.inc.dataoutHandle    HANDLE ?cellsWritten DWORD ?xyPos COORD &lt;10,2&gt;; 字符编号数组buffer BYTE 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15       BYTE 16,17,18,19.20BufSize DWORD ($ - buffer); 属性数组attributes WORD 0Fh,0Eh,0Dh,0Ch,0Bh,0Ah,9,8,7,6           WORD 5,4,3,2,1,0F0h,0E0h,0D0h,0C0h,0B0h.codemain PROC; 获取控制台标准输出句柄    INVOKE GetStdHandle,STD_OUTPUT_HANDLE    mov outHandle,eax; 设置相邻单元格颜色INVOKE WriteConsoleOutputAttribute,      outHandle, ADDR attributes,      BufSize, xyPos,      ADDR cellsWritten; 写 1 到 20 号字符    INVOKE WriteConsoleOutputCharacter,      outHandle, ADDR buffer, BufSize,      xyPos, ADDR cellsWritten    INVOKE ExitProcess,0main ENDPEND main</code></pre><p>下图是程序输岀的快照，其中 1 到 20 号显示为图形字符。虽然印刷页面为灰度显示，但每个字符都是不同的颜色。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226603127305" alt="img"></p><h2 id="汇编语言Win32时间与日期函数"><a href="#汇编语言Win32时间与日期函数" class="headerlink" title="汇编语言Win32时间与日期函数"></a>汇编语言Win32时间与日期函数</h2><p>Win32 API 有相当多的时间和日期函数可供选择。最常见的是，用户想要用这些函数来获得和设置当前日期与时间。这里只能讨论这些函数的一小部分，不过在 Platform SDK 文档中可以查阅到下表列出的 Win32 函数。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>CompareFileTime</td><td>比较两个 64 位的文件时间</td></tr><tr><td>DosDateTimeToFileTime</td><td>把 MS-DOS 日期和时间值转换为一个 64 位的文件时间</td></tr><tr><td>FileTimeToDosDateTime</td><td>把 64 位文件时间转换为 MS-DOS 日期和时间值</td></tr><tr><td>FileTimeToLocalFileTime</td><td>把 UTC（通用协调时间）文件时间转换为本地文件时间</td></tr><tr><td>FileTimeToSystemTime</td><td>把 64 位文件时间转换为系统时间格式</td></tr><tr><td>GetFileTime</td><td>检索文件创建、最后访问和最后修改的日期与时间</td></tr><tr><td>GetLocalTime</td><td>检索当前本地日期和时间</td></tr><tr><td>GetSystemTime</td><td>以 UTC 格式检索当前系统日期和时间</td></tr><tr><td>GetSystemTimeAdjustment</td><td>决定系统是否对其日历钟进行周期性时间调整</td></tr><tr><td>GetSystemTimeAsFileTime</td><td>以 UTC 格式检索当前系统日期和时间</td></tr><tr><td>GetTickCount</td><td>检索自系统启动后经过的毫秒数</td></tr><tr><td>GetTimeZoneInformation</td><td>检索当前时区参数</td></tr><tr><td>LocalFileTimeToFileTime</td><td>把本地文件时间转换为基于 UTC 的文件时间</td></tr><tr><td>SetFileTime</td><td>设置文件创建、最后访问和最后修改的日期与时间</td></tr><tr><td>SetLocalTime</td><td>设置当前本地时间与日期</td></tr><tr><td>SetSystemTime</td><td>设置当前系统时间与日期</td></tr><tr><td>SetSystemTimeAdjustment</td><td>启用或禁用对系统日历钟进行周期性时间调整</td></tr><tr><td>SetTimeZoneInformation</td><td>设置当前时区参数</td></tr><tr><td>SystemTimeToFileTime</td><td>把系统时间转换为文件时间</td></tr><tr><td>SystemTimeToTzSpecificLocalTime</td><td>把 UTC 时间转换为指定时区对应的本地时间</td></tr></tbody></table><h4 id="SYSTEMTIME-结构"><a href="#SYSTEMTIME-结构" class="headerlink" title="SYSTEMTIME 结构"></a>SYSTEMTIME 结构</h4><p>SYSTEMTIME 结构由 Windows API 的日期和时间函数使用：</p><pre><code>SYSTEMTIME STRUCT   wYear WORD ?          ;年（4 个数子）   wMonth WORD ?        ;月（1 ~ 12）   wDayOfWeek WORD ?   ;星期（0 ~ 6）   wDay WORD ?          ;日（1 ~ 31）   wHour WORD ?         ;小时（0 ~ 23）   wMinute WORD ?            ;分钟（0 ~ 59）   wSecond WORD ?            ;秒（0 ~ 59）   wMilliseconds WORD ?   ;毫秒（0 ~ 999）SYSTEMTIME ENDS</code></pre><p>字段 wDayOfWeek 的值依序为星期天 = 0，星期一 = 1，以此类推。wMilliseconds 中的值不确定，因为系统可以与时钟源同步周期性地刷新时间。</p><h3 id="GetLocalTime-和-SetLocalTime"><a href="#GetLocalTime-和-SetLocalTime" class="headerlink" title="GetLocalTime 和 SetLocalTime"></a>GetLocalTime 和 SetLocalTime</h3><p>函数 GetLocalTime 根据系统时钟返回日期和当前时间。时间要调整为本地时区。调用该函数时，需向其传递一个指针指向 SYSTEMTIME 结构：</p><pre><code>GetLocalTime PROTO,   lpSystemTime:PTR SYSTEMTIME</code></pre><p>函数 GetLocalTime 调用示例如下：</p><pre><code>.datasysTime SYSTEMTIME &lt;&gt;.codeINVOKE GetLocalTime, ADDR sysTime</code></pre><p>函数 SetLocalTime 设置系统的本地日期和时间。调用时，需向其传递一个指针指向包含了期望日期和时间的 SYSTEMTIME 结构：</p><pre><code>SetLocalTime PROTO,   lpSystemTime:PTR SYSTEMTIME</code></pre><p>如果函数执行成功，则返回非零整数；如果失败，则返回零。</p><h3 id="GetTickCount-函数"><a href="#GetTickCount-函数" class="headerlink" title="GetTickCount 函数"></a>GetTickCount 函数</h3><p>函数 GetTickCount 返回从系统启动起经过的毫秒数：</p><pre><code>GetTickCount PROTO              ; EAX 为返回值</code></pre><p>由于返回值为一个双字，因此当系统连续运行 49.7 天后，时间将会回绕归零。可以使用这个函数监视循环经过的时间，并在达到时间限制时终止循环。</p><p>下面的程序 Timer.asm 计算两次调用 GetTickCount 之间的时间间隔。程序尝试确定计时器没有回绕（超过 49.7 天）。相似的代码可以用于各种程序：</p><pre><code>;计算经过的时间    （Timer.asm）;用Win32函数GetTickCount演示一个简单的秒表计时器。INCLUDE Irvine32.incINCLUDE macros.inc.datastartTime DWORD ?.codemain PROC    INVOKE GetTickCount         ; 获取开始时间计数    mov    startTime,eax        ; 保存开始时间计数; Create a useless calculation loop.    mov    ecx,10000100hL1:    imul    ebx    imul    ebx    imul    ebx    loop    L1    INVOKE GetTickCount         ; 获得新的时间计数    cmp    eax,startTime        ; 比开始时间计数小    jb    error                 ; 时间回绕    sub    eax,startTime        ; 计算时间间隔    call    WriteDec            ; 显示时间间隔    mWrite &lt;" milliseconds have elapsed",0dh,0ah&gt;    jmp    quiterror:    mWrite "Error: GetTickCount invalid--system has "    mWrite &lt;"been active for more than 49.7 days",0dh,0ah&gt;quit:    exitmain ENDPEND main</code></pre><h3 id="Sleep-函数"><a href="#Sleep-函数" class="headerlink" title="Sleep 函数"></a>Sleep 函数</h3><p>有些时候程序需要暂停或延迟一小段时间。虽然可以通过构造一个计算循环或忙循环来保持处理器工作，但是不同的处理器会使得执行时间不同。另外，忙循环还不必要地占用了处理器，这会降低在同一时间执行程序的速度。</p><p>Win32 函数 Sleep 按照指定毫秒数暂停当前执行的线程：</p><pre><code>Sleep PROTO,   dwMilliseconds:DWORD</code></pre><p>由于本教程中汇编语言程序是单线程的，因此假设一个线程就等同于一个程序。当线程休眠时，它不会消耗处理器时间。</p><h3 id="GetDateTime-过程"><a href="#GetDateTime-过程" class="headerlink" title="GetDateTime 过程"></a>GetDateTime 过程</h3><p>Irvine32 链接库中的过程 GetDateTime 以 100 纳秒为间隔，返回从 1601 年 1 月 1 日起经过的时间间隔数。这看起来有点奇怪，因为那个时候计算机还是未知的。对任何事件，Microsoft 都用这个值来跟踪文件日期和时间。</p><p>如果想要为日期计算准备系统日期/时间值，Win32 SDK 建议采用如下步骤：</p><ul><li><p>调用函数，如 GetLocalTime，填充 SYSTEMTIME 结构。</p></li><li><p>调用函数 SystemTimeToFileTime，将 SYSTEMTIME 结构转换为 FILETIME 结构。</p></li><li><p>将得到的 FILETIME 结构复制到 64 位的四字。</p></li></ul><p>FILETIME 结构把 64 位四字分割为两个双字：</p><pre><code>FILETIME STRUCT   loDateTime DWORD ?   hiDateTime DWORD ?FILETIME ENDS</code></pre><p>下面的 GetDateTime 过程接收一个指针，指向 64 位四字变量。它用 Win32 FILETIME 格式将当前日期和时间保存到变量中：</p><pre><code>;--------------------------------------------------GetDateTime PROC,    pDateTime:PTR QWORD    LOCAL sysTime:SYSTEMTIME, flTime:FILETIME;; 以64位整数形式 ( 按 Win32 FILETIME 格式 ) 获得并保存当前本地时间/日期;--------------------------------------------------; 获得系统本地时间    INVOKE GetLocalTime,      ADDR sysTime; SYSTEMTIME 转换为 FILETIME.    INVOKE SystemTimeToFileTime,      ADDR sysTime,      ADDR flTime; 把 FILETIME 复制到一个64位整数    mov esi,pDateTime    mov eax,flTime.loDateTime    mov DWORD PTR [esi],eax    mov eax,flTime.hiDateTime    mov DWORD PTR [esi+4],eax    retGetDateTime ENDP</code></pre><h2 id="汇编语言64位Windows-API使用简述"><a href="#汇编语言64位Windows-API使用简述" class="headerlink" title="汇编语言64位Windows API使用简述"></a>汇编语言64位Windows API使用简述</h2><p>任何对 Windows API 的 32 位调用都可以重新编写为 64 位调用。只需要记住几个关键 点就可以：</p><p>\1) 输入与输出句柄是 64 位的。</p><p>\2) 调用系统函数前，主调程序必须保留至少 32 字节的影子空间，其方法是将堆栈指针（RSP）寄存器减去 32。这使得系统函数能利用这个空间保存 RCX、RDX、R8 和 R9 寄存器的临时副本。</p><p>\3) 调用系统函数时，RSP 需对齐 16 字节地址边界（基本上，任何十六进制地址的最低位数字都是 0）。幸运的是，Win64 API 似乎没有强制执行这条规则，而且在应用程序中对堆栈对齐进行精确控制往往是比较困难的。</p><p>\4) 系统调用返回后，主调方必须回复 RSP 的初始值，方法是加上在函数调用前减去的数值。如果是在子程序中调用 Win64 API，那么这一点非常重要，因为在执行 RET 指令时，ESP 最终须指向子程序的返回地址。</p><p>\5) 整数参数利用 64 位寄存器传递。</p><p>\6) 不允许使用 INVOKE。取而代之，前 4 个参数要按照从左到右的顺序，依次放入这 4 个寄存器：RCX、RDX、R8 和 R9。其他参数则压入运行时堆栈。</p><p>\7) 系统函数用 RAX 存放返回的 64 位整数值。</p><p>下面的代码行演示了如何从 Irvine64 链接库中调用 64 位 GetStdHandle 函数：</p><pre><code>.dataSTD_OUTPUT_HANDLE EQU -11consoleOutHandle QWORD ?.codesub rsp, 40                  ;预留影子空间 &amp; 对齐 RSPmov rex,STD_OUTPUT_HANDLEcall GetstdHandle   -mov consoleOutHandle,raxadd rsp,40</code></pre><p>一旦控制台输出句柄被初始化，可以用后面的代码来演示如何调用 64 位 WriteConsoleA 函数。</p><p>这里有 5 个参数：RCX（控制台句柄）、RDX（字符串指针）、R8（字符串长度）、 R9（byteWritten 变量指针），以及最后一个虚拟零参数，它位于 RSP 上面的第 5 个堆栈位置。</p><pre><code>WriteString proc uses rex rdx r8 r9    sub rsp, (5*8)            ;为 5 个参数预留空间    movr cx,rdx    call Str_length           ;用 EAX 返回字符串长度    mov rcx,consoleOutHandle    mov rdx, rdx              ;字符串指针    mov r8, rax               ;字符串长度    lea r9,bytesWritten    mov qword ptr [rsp + 4 * SIZEOF QWORD], 0 ; 总是 0    call WriteConsoleA    add rsp,(5*8)             ;恢复 RSP    retWriteString ENDP</code></pre><h2 id="汇编语言如何编写图形化的Windows应用程序"><a href="#汇编语言如何编写图形化的Windows应用程序" class="headerlink" title="汇编语言如何编写图形化的Windows应用程序"></a>汇编语言如何编写图形化的Windows应用程序</h2><p>本节将展示如何为 32 位 Microsoft Windows 编写简单的图形化应用程序。该程序创建并显示一个主窗口，显示消息框，并响应鼠标事件。本节内容为简介性质，如果希望了解更多信息，请参阅 Platform SDK 文档</p><p>下表列出了编写该程序时需要的各种链接库和头文件。</p><table><thead><tr><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>WinApp.asm</td><td>程序源代码</td></tr><tr><td>GraphWin.asm</td><td>头文件，包含程序要使用的结构、常量和函数原型</td></tr><tr><td>kernel32.lib</td><td>前面使用的 MS-Windows API 链接库</td></tr><tr><td>user32.lib</td><td>其他 MS-Windows API 函数</td></tr></tbody></table><p>/SUBSYSTEM:WINDOWS 代替了之前章节中使用的 /SUBSYSTEM:CONSOLE。程序从 kernel32.lib 和 user32.lib 这两个标准 MS-Windows 链接库中调用函数。</p><h4 id="主窗口"><a href="#主窗口" class="headerlink" title="主窗口"></a>主窗口</h4><p>本程序显示一个全屏主窗口。为了让窗口适合本书页面，这里缩小了它的尺寸</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226626101307" alt="img"></p><h4 id="必要的结构"><a href="#必要的结构" class="headerlink" title="必要的结构"></a>必要的结构</h4><p>结构 POINT 以像素为单位，定义屏幕上一个点的 X 坐标和 Y 坐标。它可以用于定位图形对象、窗口和鼠标点击：</p><pre><code>POINT STRUCT   ptX DWORD ?   ptY DWORD ?POINT ENDS</code></pre><p>结构 RECT 定义矩形边界。成员 left 为矩形左边的 X 坐标，成员 top为矩形上边的 Y 坐标。成员 right 和 bottom 保存矩形类似的值：</p><pre><code>RECT STRUCT   left DWORD ?   top DWORD ?   right DWORD ?   bottom DWORD ?RECT ENDS</code></pre><p>结构 MSGStruct 定义 MS-Windows 需要的数据：</p><pre><code>MSGStruct STRUCT   msgWnd DWORD ?   msgMessage DWORD ?   msgWparam DWORD ?   msgLparam DWORD ?   msgTime   DWORD ?   msgPt POINT &lt;&gt;MSGStruct ENDS</code></pre><p>结构 WNDCLASS 定义窗口类。程序中的每个窗口都必须属于一个类，并且每个程序都必须为其主窗口定义一个窗口类。在主窗口可以显示之前，这个类必须要注册到操作系统：</p><pre><code>WNDCLASS STRUC   style DWORD ?                ;窗口样式选项   lpfnWndProc DWORD ?                ; winProc 函数指针   cbClsExtra DWORD ?           ;共享内存   cbWndExtra DWORD ?          ;附加字节数   hlnstance DWORD ?            ;当前程序句柄   hlcon DWORD ?               ;图标句柄   hCursor DWORD ?             ;光标句柄   hbrBackground DWORD ?       ;背景刷句柄   IpszMenuName DWORD ?       ;菜单名指针   IpszClassName DWORD ?       ; WinCZLass 名指针WNDCLASS ENDS</code></pre><p>下面对上述参数进行简单小结：</p><ul><li><p>style 是不同样式选项的集合，比如 WS_CAPTION 和 WS_BORDER，用于控制窗口外观和行为。</p></li><li><p>lpfnWndProc 是指向函数的指针，该函数接收并处理由用户触发的事件消息。</p></li><li><p>cbClsExtra 指向一个类中所有窗口使用的共享内存。可以为空。</p></li><li><p>cbWndExtra 指定分配给后面窗口实例的附加字节数。</p></li><li><p>hInstance 为当前程序实例的句柄。</p></li><li><p>hIcon 和 hCursor 分别为当前程序中图标资源和光标资源的句柄。</p></li><li><p>hbrBackground 为背景（颜色）刷的句柄。</p></li><li><p>lpszMenuName 指向一个菜单名。</p></li><li><p>lpszClassName 指向一个空字节结束的字符串，该字符串中包含了窗口的类名称。</p></li></ul><h2 id="汇编语言MessageBox函数：显示一个简单的消息框"><a href="#汇编语言MessageBox函数：显示一个简单的消息框" class="headerlink" title="汇编语言MessageBox函数：显示一个简单的消息框"></a>汇编语言MessageBox函数：显示一个简单的消息框</h2><p>对程序而言，显示文本最简单的方法是将文本放入弹出消息框中，并等待用户点击按钮。Win32 API 链接库的 MessageBox 函数能显示一个简单的消息框。其函数原型如下：</p><pre><code>MessageBox PROTO,hWnd:DWORD,lpText:PTR BYTE,lpCaption:PTR BYTE,uType:DWORD</code></pre><p>其中：</p><ul><li><p>hWnd 是当前窗口的句柄。</p></li><li><p>lpText 指向一个空字节结束的字符串，该字符串将在消息框中显示。</p></li><li><p>lpCaption 指向一个空字节结束的字符串，该字符串将在消息框的标题栏中显示。</p></li><li><p>style 是一个整数，用于描述对话框的图标（可选）和按钮（必选）。</p></li></ul><p>按钮由常数标识，如 MB_OK 和 MB_YESNO。图标也由常数标识，如 MB_ICONQUESTION。</p><p>显示消息框时, 可以同时添加图标常数和按钮常数：</p><pre><code>INVOKE MessageBox, hWnd, ADDR QuestionText,  ADDR QuestionTitle, MB_OK + MB_ICONQUESTION</code></pre><h2 id="汇编语言WinMain过程：应用程序的启动过程"><a href="#汇编语言WinMain过程：应用程序的启动过程" class="headerlink" title="汇编语言WinMain过程：应用程序的启动过程"></a>汇编语言WinMain过程：应用程序的启动过程</h2><p>每个 Windows 应用程序都需要一个启动过程，通常将其命名为 WinMain，该过程负责下述任务：</p><ul><li><p>得到当前程序的句柄。</p></li><li><p>加载程序的图标和光标。</p></li><li><p>注册程序的主窗口类，并标识处理该窗口事件消息的过程。</p></li><li><p>创建主窗口。</p></li><li><p>显示并更新主窗口。</p></li><li><p>开始接收和发送消息的循环，直到用户关闭应用程序窗口。</p></li></ul><p>WinMain 包含一个名为 GetMessage 的消息处理循环，从程序的消息队列中取出下一条可用消息。如果 GetMessage 取出的消息是 WM_QUIT，则返回零，即通知 WinMain 暂停程序。</p><p>对于其他消息，WinMain 将它们传递给 DispatchMessage 函数，该函数再将消息传递给程序的 WinProc 过程。若想进一步了解消息，请查阅 Platform SDK 文档的 Windows Messages。</p><h2 id="汇编语言WinProc过程：接收并处理所有与窗口有关的事件消息"><a href="#汇编语言WinProc过程：接收并处理所有与窗口有关的事件消息" class="headerlink" title="汇编语言WinProc过程：接收并处理所有与窗口有关的事件消息"></a>汇编语言WinProc过程：接收并处理所有与窗口有关的事件消息</h2><p>WinProc 程接收并处理所有与窗口有关的事件消息。这些事件绝大多数是由用户通过点击和拖动鼠标、按下键盘按键等操作发起的。这个过程的工作就是解码每个消息，如果消息得以识别，则在应用程序中执行与该消息相关的任务。</p><p>过程声明如下：</p><pre><code>WinProc PROC,hWnd: DWORD,     ;窗口句柄localMsg: DWORD,  ;消息 IDwParam:DWORD,    ;参数 1 （可变）lParam: DWORD     ;参数 2 （可变）</code></pre><p>根据具体的消息 ID，第三个和第四个参数的内容可变。比如，若点击鼠标，那么 lParam 就为点击位置的 X 坐标和 Y 坐标。在后面的示例程序中，WinProc 过程处理了三种特定的消息：</p><ul><li><p>WM_LBUTTONDOWN，用户按下鼠标左键时产生该消息</p></li><li><p>WM_CREATE，表示刚刚创建主窗口</p></li><li><p>WM_CLOSE，表示将要关闭应用程序主窗口</p></li></ul><p>比如，下面的代码行通过调用 MessageBox 向用户显示一个弹出消息框来处理 WM_LBUTTONDOWN:</p><pre><code>.IF eax == WM_LBUTTONDOWNINVOKE MessageBox, hWnd, ADDR PopupText,    ADDR PopupTitle, MB_OKjmp WinProcExit</code></pre><p>用户所见的结果消息如下图所示。其他不希望被处理的消息都会被传递给 DefWindow-Proc（MS-Windows 默认的消息处理程序）。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226663614309" alt="img"></p><h2 id="汇编语言ErrorHandler过程：获取错误信息"><a href="#汇编语言ErrorHandler过程：获取错误信息" class="headerlink" title="汇编语言ErrorHandler过程：获取错误信息"></a>汇编语言ErrorHandler过程：获取错误信息</h2><p>过程 ErrorHandler 是可选的，如果在注册和创建程序主窗口的过程中系统报错，则调用该过程。</p><p>比如，如果成功注册程序主窗口，则函数 RegisterClass 返回非零值。但是，如果该函数返回值为零，那么就调用 ErrorHandler( 显示一条消息 ) 并退出程序：</p><pre><code>INVOKE RegisterClass, ADDR MainWin.IF eax == 0   call ErrorHandler   jmp Exit_Program.ENDIF</code></pre><p>过程 ErrorHandler 需要执行几个重要任务：</p><ul><li><p>调用 GetLastError 取得系统错误号。</p></li><li><p>调用 FormatMessage 取得合适的系统格式化的错误消息字符串。</p></li><li><p>调用 MessageBox 显示包含错误消息字符串的弹出消息框。</p></li><li><p>调用 LocalFree 释放错误消息字符串使用的内存空间。</p></li></ul><h2 id="汇编语言实例：Windows图形化程序"><a href="#汇编语言实例：Windows图形化程序" class="headerlink" title="汇编语言实例：Windows图形化程序"></a>汇编语言实例：Windows图形化程序</h2><p>下面通过实例来演示一下如何通过汇编语言来创建 Windows 图形化程序。不要担心这个程序的长度，其中大部分的代码在任何 MS-Windows 应用程序中都是一样的：</p><pre><code>; Windows 应用程序           (WinApp.asm); 本程序显示一个可调大小的应用程序窗口和几个弹出消息框.386INCLUDE Irvine32.incINCLUDE GraphWin.inc;==================== DATA =======================.dataAppLoadMsgTitle BYTE "Application Loaded",0AppLoadMsgText  BYTE "This window displays when the WM_CREATE "                BYTE "message is received",0PopupTitle BYTE "Popup Window",0PopupText  BYTE "This window was activated by a "           BYTE "WM_LBUTTONDOWN message",0GreetTitle BYTE "Main Window Active",0GreetText  BYTE "This window is shown immediately after "           BYTE "CreateWindow and UpdateWindow are called.",0CloseMsg   BYTE "WM_CLOSE message received",0ErrorTitle  BYTE "Error",0WindowName  BYTE "ASM Windows App",0className   BYTE "ASMWin",0; 定义应用程序的窗口类结构MainWin WNDCLASS &lt;NULL,WinProc,NULL,NULL,NULL,NULL,NULL, \    COLOR_WINDOW,NULL,className&gt;msg          MSGStruct &lt;&gt;winRect   RECT &lt;&gt;hMainWnd  DWORD ?hInstance DWORD ?;=================== CODE =========================.codeWinMain PROC; 获得当前过程的句柄    INVOKE GetModuleHandle, NULL    mov hInstance, eax    mov MainWin.hInstance, eax; 加载程序的图标和光标    INVOKE LoadIcon, NULL, IDI_APPLICATION    mov MainWin.hIcon, eax    INVOKE LoadCursor, NULL, IDC_ARROW    mov MainWin.hCursor, eax; 注册窗口类    INVOKE RegisterClass, ADDR MainWin    .IF eax == 0      call ErrorHandler      jmp Exit_Program    .ENDIF; 创建应用程序的主窗口    INVOKE CreateWindowEx, 0, ADDR className,      ADDR WindowName,MAIN_WINDOW_STYLE,      CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,      CW_USEDEFAULT,NULL,NULL,hInstance,NULL    mov hMainWnd,eax; 若 CreateWindowEx 失败，则显示消息并退出    .IF eax == 0      call ErrorHandler      jmp  Exit_Program    .ENDIF; 保存窗口句柄，显示并绘制窗口    INVOKE ShowWindow, hMainWnd, SW_SHOW    INVOKE UpdateWindow, hMainWnd; 显示欢迎消息    INVOKE MessageBox, hMainWnd, ADDR GreetText,      ADDR GreetTitle, MB_OK; 启动程序的连续消息处理循环Message_Loop:    ; 从队列中取出下一条消息    INVOKE GetMessage, ADDR msg, NULL,NULL,NULL    ; 若没有其他消息则退出    .IF eax == 0      jmp Exit_Program    .ENDIF    ; 将消息传递给程序的 WinProc    INVOKE DispatchMessage, ADDR msg    jmp Message_LoopExit_Program:      INVOKE ExitProcess,0WinMain ENDP;-----------------------------------------------------WinProc PROC,    hWnd:DWORD, localMsg:DWORD, wParam:DWORD, lParam:DWORD; 应用程序的消息处理过程，处理应用程序特定的消息。; 其他所有消息则传递给默认的 windows 消息处理过程;-----------------------------------------------------    mov eax, localMsg    .IF eax == WM_LBUTTONDOWN          ; 鼠标按钮?      INVOKE MessageBox, hWnd, ADDR PopupText,        ADDR PopupTitle, MB_OK      jmp WinProcExit    .ELSEIF eax == WM_CREATE           ; 创建窗口?      INVOKE MessageBox, hWnd, ADDR AppLoadMsgText,        ADDR AppLoadMsgTitle, MB_OK      jmp WinProcExit    .ELSEIF eax == WM_CLOSE            ; 关闭窗口?      INVOKE MessageBox, hWnd, ADDR CloseMsg,        ADDR WindowName, MB_OK      INVOKE PostQuitMessage,0      jmp WinProcExit    .ELSE                              ; 其他消息?      INVOKE DefWindowProc, hWnd, localMsg, wParam, lParam      jmp WinProcExit    .ENDIFWinProcExit:    retWinProc ENDP;---------------------------------------------------ErrorHandler PROC; 显示合适的系统错误消息;---------------------------------------------------.datapErrorMsg  DWORD ?         ; 错误消息指针messageID  DWORD ?.code    INVOKE GetLastError    ; 用EAX返回消息ID    mov messageID,eax    ; 获取相应的消息字符串    INVOKE FormatMessage, FORMAT_MESSAGE_ALLOCATE_BUFFER + \      FORMAT_MESSAGE_FROM_SYSTEM,NULL,messageID,NULL,      ADDR pErrorMsg,NULL,NULL    ; 显示错误消息    INVOKE MessageBox,NULL, pErrorMsg, ADDR ErrorTitle,      MB_ICONERROR+MB_OK    ; 释放错误消息字符串    INVOKE LocalFree, pErrorMsg    retErrorHandler ENDPEND WinMain</code></pre><h4 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h4><p>第一次加载程序时，显示如下消息框：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226692567311" alt="img"></p><p>当用户点击 OK 来关闭 Application Loaded 消息框时，则显示另一个消息框：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226700864313" alt="img"></p><p>当用户关闭 Main Window Active 消息框时，就会显示程序的主窗口 ：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226711048315" alt="img"></p><p>当用户在主窗口的任何位置点击鼠标时，显示如下消息框：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226722568317" alt="img"></p><p>当用户关闭该消息框，并点击主窗口右上角上的 X 时，那么在窗口关闭之前将显示如下消息框：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226732890319" alt="img"></p><p>当用户关闭了这个消息框后，则程序结束。</p><h2 id="汇编语言动态内存分配"><a href="#汇编语言动态内存分配" class="headerlink" title="汇编语言动态内存分配"></a>汇编语言动态内存分配</h2><p>动态内存分配 (dynamic memory allocation)，又被称为堆分配 (heap allocation)，是编程语言使用的一种技术，用于在创建对象、数组和其他结构时预留内存。比如在 Java 语言中，下面的语句就会为 String 对象保留内存：</p><pre><code>String str = new String("abcde");</code></pre><p>同样的，在 C++ 中，对变量使用大小属性就可以为一个整数数组分配空间：</p><pre><code>int size;cin &gt;&gt; size;    //用户输入大小int array[] = new int[size];</code></pre><p>C、C++ 和 Java 都有内置运行时堆管理器来处理程序请求的存储分配和释放。程序启动时，堆管理器常常从操作系统中分配一大块内存，并为存储块指针创建空闲列表 (free list)。</p><p>当接收到一个分配请求时，堆管理器就把适当大小的内存块标识为已预留，并返回指向该块的指针。之后，当接收到对同一个块的删除请求时，堆就释放该内存块，并将其返回到空闲列表。每次接收到新的分配请求，堆管理器就会扫描空闲列表，寻找第一个可用的、且容量足够大的内存块来响应请求。</p><p>汇编语言程序有两种方法进行动态分配：</p><ul><li><p>方法一：通过系统调用从操作系统获得内存块。</p></li><li><p>方法二：实现自己的堆管理器来服务更小的对象提出的请求。</p></li></ul><p>利用下表中的几个 Win32 API 函数就可以从 Windows 中请求多个不同大小的内存块。表中所有的函数都会覆盖通用寄存器，因此程序可能想要创建封装过程来实现重要寄存器的入栈和出栈操作。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>GetProcessHeap</td><td>用 EAX 返回程序现存堆区域的 32 位整数句柄。如果函数成功，则 EAX 中的返回值为堆句柄。 如果函数失败，则 EAX 中的返回值为 NULL</td></tr><tr><td>HeapAlloc</td><td>从堆中分配内存块。如果成功，EAX 中的返回值就为内存块的地址。如果失败，则 EAX 中的返 回值为 NULL</td></tr><tr><td>HeapCreate</td><td>创建新堆，并使其对调用程序可用。如果函数成功，则 EAX 中的返回值为新创建堆的句柄。如果失败，则 EAX 的返回值为 NULL</td></tr><tr><td>HeapDestroy</td><td>销毁指定堆对象，并使其句柄无效。如果函数成功，则 EAX 中的返回值为非零</td></tr><tr><td>HeapFree</td><td>释放之前从堆中分配的内存块，该堆由其地址和堆句柄进行标识。如果内存块释放成功，则返回值为非零</td></tr><tr><td>HeapReAlloc</td><td>对堆中内存块进行再分配和调整大小。如果函数成功，则返回值为指向再分配内存块的指针。如果函数失败，且没有指定 HEAP GENERATE EXCEPTIONS，则返回值为 NULL</td></tr><tr><td>HeapSize</td><td>返回之前通过调用 HeapAlloc 或 HeapReAlloc 分配的内存块的大小。如果函数成功，则 EAX 包含被分配内存块的字节数。如果函数失败，则返回值为 SIZE_T-1 ( SIZE_T 等于指针能指向的最大字节数 )</td></tr></tbody></table><h4 id="GetProcessHeap"><a href="#GetProcessHeap" class="headerlink" title="GetProcessHeap"></a>GetProcessHeap</h4><p>如果使用的是当前程序的默认堆，那么 GetProcessHeap 就足够了。这个函数没有参数，EAX 中的返回值就是堆句柄：</p><p>GetProcessHeap PROTO</p><p>示例调用：</p><pre><code>.datahHeap HANDLE ?.codeINVOKE GetProcessHeap.IF eax == NULL           ;不能获取句柄    jmp quit.ELSE    mov hHeap,eax         ;句柄 ok.ENDIF</code></pre><h4 id="HeapCreate"><a href="#HeapCreate" class="headerlink" title="HeapCreate"></a>HeapCreate</h4><p>HeapCreate 能为当前程序创建一个新的私有堆：</p><pre><code>HeapCreate PROTO,   flOptions:DWORD,          ;堆分配选项   dwInitialSize:DWORD,        ;按字节初始化堆大小   dwMaximumSize:DWORD       ;最大堆字节数</code></pre><p>flOptions 设置为 NULL。dwInitialSize 设置为初始堆字节数，其值的上限为下一页的边界。如果 HeapAlloc 的调用超过了初始堆大小，那么堆最大可以扩展到 dwMaximumSize 参数中指定的大小（上限为下一页的边界）。调用后，EAX 中的返回值为空就表示堆未创建成 功。HeapCreate 的调用示例如下：</p><pre><code>HEAP_START = 2000000 ; 2 MBHEAP_MAX = 400000000 ; 400 MB.datahHeap HANDLE ?       ; 堆句柄.codeINVOKE HeapCreate, 0, HEAP_START, HEAP_MAX.IF eax == NULL      ; 堆未创建    call WriteWindowsMsg ; 显示错误消息    jmp quit.ELSE    mov hHeap,eax    ; 句柄 OK.ENDIF</code></pre><h4 id="HeapDestroy"><a href="#HeapDestroy" class="headerlink" title="HeapDestroy"></a>HeapDestroy</h4><p>HeapDeatroy 销毁一个已存在的私有堆（由 HeapCreate 创建）。需向其传递堆句柄：</p><pre><code>HeapDestroy PROTO,   hHeap:DWORD         ;堆句柄</code></pre><p>如果堆销毁失败，则 EAX 等于 NULL。下面为示例调用，其中使用了 WriteWindowsMsg 过程：</p><pre><code>.datahHeap HANDLE ?                ;堆句柄.codeINVOKE HeapDestroy, hHeap.IF eax == NULL    call WriteWindowsMsg      ;显示错误消息.ENDIF</code></pre><h4 id="HeapAlloc"><a href="#HeapAlloc" class="headerlink" title="HeapAlloc"></a>HeapAlloc</h4><p>HeapAlloc 从已存在堆中分配一个内存块：</p><pre><code>HeapAlloc PROTO,   hHeap:HANDLE,    ;现有堆内存块的句柄   dwFlags :DWORD,   ;堆分配控制标志   dwBytes:DWORD   ;分配的字节数</code></pre><p>需传递下述参数：</p><ul><li><p>hHeap：32 位堆句柄，该堆由 GetProcessHeap 或 HeapCreate 初始化。</p></li><li><p>dwFlags：一个双字，包含了一个或多个标志值。可以选择将其设置为 HEAP_ZERO_MEMORY，即设置内存块为全零。</p></li><li><p>dwBytes：一个双字，表示堆分配的字节数。</p></li></ul><p>如果 HeapAlloc 成功，则 EAX 包含指向新存储区的指针；如果失败，则 EAX 中的返回值为 NULL。下面的代码用 hHeap 标识一个堆，从该堆中分配了一个 1000 字节的数组，并将数组初始化为全零：</p><pre><code>.datahHeap HANDLE ?    ;堆句柄pArray DWORD ?    ;数组指针.codeINVOKE HeapAlloc, hHeap, HEAP_ZERO_MEMORY, 1000.IF eax == NULL    mWrite "HeapAlloc failed"    jmp quit.ELSE    mov pArray,eax.ENDIF</code></pre><h4 id="HeapFree"><a href="#HeapFree" class="headerlink" title="HeapFree"></a>HeapFree</h4><p>函数 HeapFree 释放之前从堆中分配的一个内存块，该堆由其地址和堆句柄标识：</p><pre><code>HeapFree PROTO,   hHeap:HANDLE,   dwFlags:DWORD,   lpMem:DWORD</code></pre><p>第一个参数是包含该内存块的堆的句柄。第二个参数通常为零，第三个参数是指向将被释放内存块的指针。如果内存块释放成功，则返回值非零。如果该块不能被释放，则函数返回零。</p><p>示例调用如下：</p><pre><code>INVOKE HeapFree, hHeap, 0, pArray</code></pre><h4 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h4><p>若在调用 HeapCreate、HeapDestroy 或 GetProcessHeap 时遇到错误，可以通过调用 API 函数 GetLastError 来获得详细信息。还可以调用 Irvine32 链接库的函数 WriteWindowsMsg。</p><p>HeapCreate 调用示例如下：</p><pre><code>INVOKE HeapCreate, 0, HEAP_START, HEAP_MAX.IF eax == NULL                    ;失败？    call WriteWindowsMsg           ;显示错误信息.ELSE    mov    hHeap,eax               ;成功.ENDIF</code></pre><p>反之，函数 HeapAlloc 在失败时不会设置系统错误码，因此也就无法调用 GetLastError 或 WriteWindowsMsg。</p><h2 id="汇编语言实例：动态内存分配"><a href="#汇编语言实例：动态内存分配" class="headerlink" title="汇编语言实例：动态内存分配"></a>汇编语言实例：动态内存分配</h2><p>下面的示例程序使用动态内存分配创建并填充了一个 1000 字节的数组：</p><pre><code>; 堆测试 #1        (Heaptest1.asm)INCLUDE Irvine32.inc; 使用动态内存分配，本程序分配并填充一个字节数据.dataARRAY_SIZE = 1000FILL_VAL EQU 0FFhhHeap   DWORD ?        ; 程序堆句柄pArray  DWORD ?        ; 内存块指针newHeap DWORD ?        ; 新堆句柄str1 BYTE "Heap size is: ",0.codemain PROC    INVOKE GetProcessHeap          ; 获取程序堆句柄    .IF eax == NULL                ; 如果失败，显示消息    call    WriteWindowsMsg    jmp    quit    .ELSE    mov    hHeap,eax                ; 成功    .ENDIF    call    allocate_array    jnc    arrayOk                  ; 失败 (CF = 1)?    call    WriteWindowsMsg    call    Crlf    jmp    quitarrayOk:                            ; 成功填充数组    call    fill_array    call    display_array    call    Crlf    ; 释放数组    INVOKE HeapFree, hHeap, 0, pArrayquit:    exitmain ENDP;--------------------------------------------------------allocate_array PROC USES eax;; 动态分配数组空间; 接收: EAX = 程序堆句柄; 返回: 如果内存分配成功，则 CF = 0;--------------------------------------------------------    INVOKE HeapAlloc, hHeap, HEAP_ZERO_MEMORY, ARRAY_SIZE    .IF eax == NULL       stc                    ; 返回 CF = 1    .ELSE       mov  pArray,eax        ; 保存指针       clc                    ; 返回 CF = 0    .ENDIF    retallocate_array ENDP;--------------------------------------------------------fill_array PROC USES ecx edx esi;; 用一个字符填充整个数组; 接收: 无; 返回: 无;--------------------------------------------------------    mov    ecx,ARRAY_SIZE             ; 循环计数器    mov    esi,pArray                 ; 指向数组L1:    mov    BYTE PTR [esi],FILL_VAL ; 填充每个字节    inc    esi                        ; 下一个位置    loop    L1    retfill_array ENDP;--------------------------------------------------------display_array PROC USES eax ebx ecx esi;; 显示数组; 接收: 无; 返回: 无;--------------------------------------------------------    mov    ecx,ARRAY_SIZE     ; 循环计数器    mov    esi,pArray         ; 指向数组L1:    mov    al,[esi]        ; 取出一个字节    mov    ebx,TYPE BYTE    call    WriteHexB         ; 显示该字节    inc    esi                ; 下一个位置    loop    L1    retdisplay_array ENDPEND main</code></pre><p>下面的示例采用动态内存分配重复分配大块内存，直到超过堆大小。</p><pre><code>; 堆测试 #2      (Heaptest2.asm)INCLUDE Irvine32.inc.dataHEAP_START =   2000000    ;   2 MBHEAP_MAX  =  400000000    ; 400 MBBLOCK_SIZE =    500000    ;  0.5 MBhHeap DWORD ?             ; 堆句柄pData DWORD ?             ; 块指针str1 BYTE 0dh,0ah,"Memory allocation failed",0dh,0ah,0.codemain PROC    INVOKE HeapCreate, 0,HEAP_START, HEAP_MAX    .IF eax == NULL          ; 失败?    call    WriteWindowsMsg    call    Crlf    jmp    quit    .ELSE    mov    hHeap,eax          ; 成功    .ENDIF    mov    ecx,2000           ; 循环计数器L1:    call allocate_block    ; 分配一个块    .IF Carry?                ; 失败?    mov    edx,OFFSET str1    ; 显示消息    call    WriteString    jmp    quit    .ELSE                     ; 否: 打印一个点来显示进度    mov    al,'.'    call    WriteChar    .ENDIF    ;call free_block          ; 允许/禁止本行    loop    L1quit:    INVOKE HeapDestroy, hHeap      ; 销毁堆    .IF eax == NULL                ; 失败?    call    WriteWindowsMsg        ; 是: 错误消息    call    Crlf    .ENDIF    exitmain ENDPallocate_block PROC USES ecx    INVOKE HeapAlloc, hHeap, HEAP_ZERO_MEMORY, BLOCK_SIZE    .IF eax == NULL       stc                        ; 返回 CF = 1    .ELSE       mov  pData,eax             ; 保存指针       clc                        ; 返回 CF = 0    .ENDIF    retallocate_block ENDPfree_block PROC USES ecx    INVOKE HeapFree, hHeap, 0, pData    retfree_block ENDPEND main</code></pre><h2 id="汇编语言x86存储管理简述"><a href="#汇编语言x86存储管理简述" class="headerlink" title="汇编语言x86存储管理简述"></a>汇编语言x86存储管理简述</h2><p>本节将对 Windows 32 位存储管理进行简要说明，展示它是如何使用 x86 处理器直接内置功能的。重点关注的是存储管理的两个主要方面：</p><ul><li><p>将逻辑地址转换为线性地址</p></li><li><p>将线性地址转换为物理地址 ( 分页 )</p></li></ul><p>下面先简单回顾一下第2章《x86处理器架构》介绍过的一些 x86 存储管理术语：</p><ul><li><p>多任务处理 (multitasking) 允许多个程序（或任务）同时运行。处理器在所有运行程序中划分其时间。</p></li><li><p>段 (segments) 是可变大小的内存区，用于让程序存放代码或数据。</p></li><li><p>分段 (segmentation) 提供了分隔内存段的方法。它允许多个程序同时运行又不会相互干扰。</p></li><li><p>段描述符 (segment descriptor) 是一个 64 位的值，用于标识和描述一个内存段。它包含的信息有段基址、访问权限、段限长、类型和用法。</p></li></ul><p>现在再增加两个新术语：</p><ul><li><p>段选择符 (segment selector) 是保存在段寄存器 (CS、DS、SS、ES、FS 或 GS) 中的一个 16 位数值。</p></li><li><p>逻辑地址 (logical address) 就是段选择符加上一个 32 位的偏移量。</p></li></ul><h2 id="汇编语言线性地址简述"><a href="#汇编语言线性地址简述" class="headerlink" title="汇编语言线性地址简述"></a>汇编语言线性地址简述</h2><p>在上一节《x86存储管理》中提到了线性地址，接下来为大家简单介绍一下线性地址。</p><h3 id="逻辑地址转换为线性地址"><a href="#逻辑地址转换为线性地址" class="headerlink" title="逻辑地址转换为线性地址"></a>逻辑地址转换为线性地址</h3><p>多任务操作系统允许几个程序（任务）同时在内存中运行。每个程序都有自己唯一的数据区。假设现有 3 个程序，每个程序都有一个变量的偏移地址为 200h，那么，怎样区分这 3 个变量而不进行共享？</p><p>x86 解决这个问题的方法是，用一步或两步处理过程将每个变量的偏移量转换为唯一的内存地址。</p><p>第一步，将段值加上变量偏移量形成线性地址 (linear address)。这个线性地址可能就是该变量的物理地址。但是像 MS-Windows 和 Linux 这样的操作系统采用了分页 (paging) 功能，它使得程序能使用比可用物理空间更大的线性空间。这种情况下，就必需采用第二步页转换 (page translation)，将线性地址转换为物理地址。</p><p>首先了解一下处理器如何用段和选择符来确定变量的线性地址。每个段选择符都指向一个段描述符（位于描述符表中），其中包含了该内存段的基地址。如下图所示，逻辑地址中的 32 位偏移量加上段基址就形成了 32 位的线性地址。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226767498321" alt="img"></p><p>线性地址是一个 32 位整数，其范围为 0FFFFFFFFh，它表示一个内存位置。如果禁止分页功能，那么线性地址也就是目标数据的物 理地址。</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>分页是 x86 处理器的一个重要功能，它使得计算机能运行在其他情况下无法装入内存的一组程序。处理器初始只将部分程序加载到内存，而程序的其他部分仍然留在硬盘上。</p><p>程序使用的内存被分割成若干小区域，称为页 (page)，通常一页大小为 4KB。当每个程序运行时，处理器会选择内存中不活跃的页面替换出去，而将立即会被请求的页加载到内存。</p><p>操作系统通过维护一个页目录 (page directory) 和一组页表 (page table) 来持续跟踪当前内存中所有程序使用的页面。当程序试图访问线性地址空间内的一个地址时，处理器会自动将线性地址转换为物理地址。这个过程被称为页转换 (page translation)。</p><p>如果被请求页当前不在内存中，则处理器中断程序并产生一个页故障 (page fault)。操作系统将被请求页从硬盘复制到内存，然后程序继续执行。从应用程序的角度看，页故障和页转换都是自动发生的。</p><p>使用 Microsoft Windows 工具任务管理器（task manager）就可以查看物理内存和虚拟内存的区别。如下图所示计算机的物理内存为 256MB。任务管理器的 Commit Charge 框内为当前可用的虚拟内存总量。虚拟内存的限制为 633MB，大大高于计算机的物理内存。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226779995323" alt="img"></p><h3 id="描述符表"><a href="#描述符表" class="headerlink" title="描述符表"></a>描述符表</h3><p>段描述符可以在两种表内找到：全局描述符表（global description table）和局部描述符表（local description table）。</p><p>全局描述符表（GDT）开机过程中，当操作系统将处理器切换到保护模式时，会创建唯——张 GDT，其基址保存在 GDTR（全局描述符表寄存器）中。表中的表项（称为段描述符）指向段。操作系统可以选择将所有程序使用的段保存在 GDT 中。</p><p>局部描述符表（LDT）在多任务操作系统中，每个任务或程序通常都分配有自己的段描述符表，称为 LDT。LDTR 寄存器保存的是程序 LDT 的地址。每个段描述符都包含了段在线性地址空间内的基地址。</p><p>一般，段与段之间是相互区分的。如下图所示，图中有三个不同的逻辑地址，这些地址选择了 LDT 中三个不同的表项。这里，假设禁止分页，因此， 线性地址空间也是物理地址空间。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226791980325" alt="img"></p><h3 id="段描述符详细信息"><a href="#段描述符详细信息" class="headerlink" title="段描述符详细信息"></a>段描述符详细信息</h3><p>除了段基址，段描述符还包含了位映射字段来说明段限长和段类型。只读类型段的一个例子就是代码段。如果程序试图修改只读段，则会产生处理器故障。</p><p>段描述符可以包含保护等级，以便保护操作系统数据不被应用程序访问。下面是对每个描述符字段的说明：</p><h4 id="1-基址"><a href="#1-基址" class="headerlink" title="1) 基址"></a>1) 基址</h4><p>一个 32 位整数，定义段在 4GB 线性地址空间中的起始地址。</p><h4 id="2-特权级"><a href="#2-特权级" class="headerlink" title="2) 特权级"></a>2) 特权级</h4><p>每个段都可以分配一个特权级，特权级范围从 0 到 3，其中 0 级为最高级，一般用于操作系统核心代码。如果特权级数值高的程序试图访问特权级数值低的段，则发生处理器故障。</p><h4 id="3-段类型"><a href="#3-段类型" class="headerlink" title="3) 段类型"></a>3) 段类型</h4><p>说明段的类型并指定段的访问类型以及段生长的方向（向上或向下）。数据（包括堆栈）段可以是可读类型或读/写类型，其生长方向可以是向上的也可以是向下的。代码段可以是只执行类型或执行/只读类型。</p><h4 id="4-段存在标志"><a href="#4-段存在标志" class="headerlink" title="4) 段存在标志"></a>4) 段存在标志</h4><p>这一位说明该段当前是否在物理内存中。</p><h4 id="5-粒度标志"><a href="#5-粒度标志" class="headerlink" title="5) 粒度标志"></a>5) 粒度标志</h4><p>确定对段限长字段的解释。如果该位清零，则段限长以字节为单位。如果该 位置 1，则段限长的解释单位为 4096 字节。</p><h4 id="6-段限长："><a href="#6-段限长：" class="headerlink" title="6) 段限长："></a>6) 段限长：</h4><p>这个 20 位的整数指定段大小。按照粒度标志，这个字段有两种解释：</p><ul><li><p>该段有多少字节，范围为 1〜1MB。</p></li><li><p>该段包含多少个 4096 字节，允许段大小的范围为 4KB〜4GB。</p></li></ul><h2 id="汇编语言页转换：线性地址转换位物理地址"><a href="#汇编语言页转换：线性地址转换位物理地址" class="headerlink" title="汇编语言页转换：线性地址转换位物理地址"></a>汇编语言页转换：线性地址转换位物理地址</h2><p>若允许分页，则处理器必须将 32 位线性地址转换为 32 位物理地址。这个过程会用到 3 种结构：</p><ul><li><p>页目录：一个数组，最多可包含 1024 个 32 位页目录项。</p></li><li><p>页表：一个数组，最多可包含 1024 个 32 位页表项。</p></li><li><p>页：4KB 或 4MB 的地址空间。</p></li></ul><p>为了简化下面的叙述，假设页面大小为 4KB：</p><p>线性地址分为三个字段：页目录表项指针、页表项指针和页内偏移量。控制寄存器（CR3）保存了页目录的起始地址。如下图所示，处理器在进行线性地址到物理地址的转换时，采用如下步骤：</p><p>\1) 线性地址引用线性地址空间中的一个位置。</p><p>\2) 线性地址中 10 位的目录字段是页目录项的索引。页目录项包含了页表的基址。</p><p>\3) 线性地址中 10 位的页表字段是页表的索引，该页表由页目录项指定。索引到的页表项包含了物理内存中页面的基址。</p><p>\4) 线性地址中 12 位的偏移量字段与页面基址相加，生成的恰好是操作数的物理地址。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226810557327" alt="img"></p><p>操作系统可以选择让所有的运行程序和任务使用一个页目录，或者选择让每个任务使用一个页目录，还可以选择为两者的组合。</p><h4 id="Windows-虚拟机管理器"><a href="#Windows-虚拟机管理器" class="headerlink" title="Windows 虚拟机管理器"></a>Windows 虚拟机管理器</h4><p>现在对 IA-32 如何管理内存已经有了总体了解，那么看看 Windows 如何处理内存管理可能也会令人感兴趣。</p><p>虚拟机管理器（VMM）是 Windows 内核中的 32 位保护模式操作系统。它创建、运行、监视和终止虚拟机。它管理内存、进程、中断和异常。它与虚拟设备（virtual device）一起工作，使得它们能拦截中断和故障，以此来控制对硬件和已安装软件的访问。</p><p>VMM 和虚拟设备运行在特权级为 0 的单一 32 位平坦模式地址空间中。系统创建两个全局描述符表项（段描述符），一个是代码段的，一个是数据段的。段固定在线性地址 0。VMM 提供多线程和抢先多任务处理。通过共享运行应用程序的虚拟机之间的 CPU 时间，它可以同时运行多个应用程序。</p><p>在上面的文字中，可以将虚拟机解释为 Intel 中的过程或任务。它包含了程序代码、支撑软件、内存和寄存器。每个虚拟机都被分配了自己的地址空间、I/O 端口空间、中断向量表和局部描述符表。运行于虚拟 8086 模式的应用程序特权级为 3。Windows 中保护模式程序的特权级为 0 和 3。</p><h1 id="浮点数处理与指令编码"><a href="#浮点数处理与指令编码" class="headerlink" title="浮点数处理与指令编码"></a>浮点数处理与指令编码</h1><h2 id="汇编语言IEEE二进制浮点数表示"><a href="#汇编语言IEEE二进制浮点数表示" class="headerlink" title="汇编语言IEEE二进制浮点数表示"></a>汇编语言IEEE二进制浮点数表示</h2><p>x86 处理器使用的三种浮点数二进制存储格式都是由 IEEE 标准 754-1985。二进制浮点数运算 (Standard 754-1985 for Binary Floating-Point Arithmetic) 所指定。</p><p>下表列出了它们的特点。</p><table><thead><tr><th>单精度</th><th>32 位：1 位符号位，8 位阶码，23 位为有效数字的小数部分。大致的规格化范围：2-126 〜2127 。也被称为短实数 (short real)</th></tr></thead><tbody><tr><td>双精度</td><td>64 位：1 位符号位，11 位阶码，52 位为有效数字的小数部分。大致的规格化范围：2-1022 〜21023 。也被称为长实数 (longreal)</td></tr><tr><td>扩展双精度</td><td>80 位：1 位符号位，15 位阶码，1 位为整数部分，63 位为有效数字的小数部分。大致的规格化范围：2-16382〜216383。也被称为扩展实数 (extended real)</td></tr></tbody></table><p>由于三种格式比较相似，因此本节将重点关注单精度格式，如下图所示。32 位数值的最高有效位(MSB) 在最左边。标注为小数 (fraction) 的字段表示的是有效数字的小数部分。如同预想的一样，各个字节按照小端顺序（最低有效位 (LSB) 在起始地址上）存放在内存中</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226832580329" alt="img"></p><h4 id="1-符号位"><a href="#1-符号位" class="headerlink" title="1) 符号位"></a>1) 符号位</h4><p>如果符号位为 1，则该数为负；如果符号位为 0，则该数为正。零被认为是正数。</p><h4 id="2-有效数字"><a href="#2-有效数字" class="headerlink" title="2) 有效数字"></a>2) 有效数字</h4><p>在浮点数表达式 m*be  中，m 称为有效数字或尾数；b 为基数；e 为阶码。浮点数的有效数字（或尾数）由小数点左右的十进制数字构成。同样的概念也可以扩展到浮点数的小数部分。例如，十进制数 123.154 可以表示为下面的累加和形式：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226847613331" alt="img"></p><p>小数点左边数字的阶码都为正，右边数字的阶码都为负。</p><p>二进制浮点数也可以使用加权位计数法。浮点数十进制数值 11.1011 表示为：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226873174333" alt="img"></p><p>小数点右边的数字还有一种表达方式，即将它们列为分数之和，其中分母为 2 的幂。上例的和为 11/16 ( 或 0.6875)：</p><p>.1011 = 1/2+0/4+1/8+1/16=11/16</p><p>生成的小数部分非常直观。十进制分子 (11) 表示的就是二进制位组合 1011。如果小数点右边的有效位个数为 e 则十进制分母就为 2e ：上例中，e=4，则有 2e=16。下表列出了更多的例子，来展示将二进制浮点数转换为以 10 为基数的分数。</p><table><thead><tr><th>二进制浮点数</th><th>基数为 10 的分数</th><th>二进制浮点数</th><th>基数为 10 的分数</th></tr></thead><tbody><tr><td>11.11</td><td>3 3/4</td><td>0.00101</td><td>5/32</td></tr><tr><td>101.0011</td><td>5 3/16</td><td>1.011</td><td>1 3/8</td></tr><tr><td>1101.100101</td><td>13 37/64</td><td>1E-23</td><td>1/8388608</td></tr></tbody></table><p>表中最后一项为 23 位规格化有效数字可以保存的最小分数。为便于参考，下表列出了二进制浮点数及其等价的十进制分数和十进制数值。</p><table><thead><tr><th>二进制</th><th>十进制分数</th><th>十进制数值</th><th>二进制</th><th>十进制分数</th><th>十进制数值</th></tr></thead><tbody><tr><td>0.1</td><td>1月2日</td><td>0.5</td><td>0.0001</td><td>1月16日</td><td>0.0625</td></tr><tr><td>0.01</td><td>1月4日</td><td>0.25</td><td>0.00001</td><td>1/32</td><td>0.03125</td></tr><tr><td>0.001</td><td>1月8日</td><td>0.125</td><td></td><td></td><td></td></tr></tbody></table><h4 id="3-有效数字的精度"><a href="#3-有效数字的精度" class="headerlink" title="3) 有效数字的精度"></a>3) 有效数字的精度</h4><p>用有限位数表示的任何浮点数格式都无法表示完整连续的实数。例如，假设一个简单的浮点数格式有 5 位有效数字，那么将无法表示范围在 1.1111〜10.000 之间的二进制数。比如，二进制数 1.11111 就需要更精确的有效数字。将这个思想扩展到 IEEE 双精度格式，就会发现其 53 位有效数字无法表示需要 54 位或更多位的二进制数值。</p><h2 id="汇编语言阶码简介"><a href="#汇编语言阶码简介" class="headerlink" title="汇编语言阶码简介"></a>汇编语言阶码简介</h2><p>单精度数用 8 位无符号整数存放阶码，引入的偏差为 127，因此必须在数的实际阶码上再加 127。考虑二进制数值 1.101 x 25 ：将实际阶码 (5) 加上 127 后，形成的偏移码 (132) 保存到数据表示形式中。</p><p>下表给出了阶码的有符号十进制、偏移十进制，以及最后一列的无符号二进制。</p><table><thead><tr><th>阶码(E)</th><th>偏移码(E+127)</th><th>二进制</th><th>阶码(E)</th><th>偏移码(E+127)</th><th>二进制</th></tr></thead><tbody><tr><td>5</td><td>132</td><td>10000100</td><td>127</td><td>254</td><td>11111110</td></tr><tr><td>0</td><td>127</td><td>1111111</td><td>-126</td><td>1</td><td>1</td></tr><tr><td>-10</td><td>117</td><td>1110101</td><td>-1</td><td>126</td><td>1111110</td></tr></tbody></table><p>偏移码总是正数，范围为 1〜254。如前所述，实际阶码的范围为 -126〜+127。这个经过选择的范围，使得最小可能阶码的倒数也不会发生溢出。</p><h2 id="汇编语言规格化二进制浮点数"><a href="#汇编语言规格化二进制浮点数" class="headerlink" title="汇编语言规格化二进制浮点数"></a>汇编语言规格化二进制浮点数</h2><p>大多数二进制浮点数都以规格化格式 (normalized form) 存放，以便将有效数字的精度最大化。给定任意二进制浮点数，都可以进行规格化，方法是将二进制小数点移位，直到小数点左边只有一个“1”。</p><p>阶码表示的是二进制小数点向左（正阶码）或向右（负阶码）移动的位数。示例如下：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226898217335" alt="img"></p><h4 id="反规格化数"><a href="#反规格化数" class="headerlink" title="反规格化数"></a>反规格化数</h4><p>规格化操作的逆操作是将二进制浮点数反规格化 (denormalize) ( 或非规格化 (unnormalize))。移动二进制小数点，直到阶码为 0。如果阶码为正数 n，则将二进制小数点右移 n 位；如果阶码为负数 n，则将二进制小数点左移 n 位，并在需要位置填充刖导数 0。</p><h4 id="实数编码"><a href="#实数编码" class="headerlink" title="实数编码"></a>实数编码</h4><p>一旦符号位、阶码和有效数字字段完成规格化和编码后，生成一个完整的二进制 IEEE 段实数就很容易了。首先将设置符号位，然后是阶码字段，最后是有效数字的小数部分。例如，下面表示的是二进制 </p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226910512337" alt="img"></p><ul><li><p>符号位：0</p></li><li><p>阶码：01111111</p></li><li><p>小数部分：10100000000000000000000</p></li></ul><p>偏移码 (01111111) 是十进制数 127 的二进制形式。所有规格化有效数字在二进制小数点的左边都有个 1，因此，不需要对这一位进行显式编码。更多的例子参见下表。</p><table><thead><tr><th>二进制数值</th><th>偏移阶码</th><th>符号、阶码、小数部分</th></tr></thead><tbody><tr><td>-1.11</td><td>127</td><td>1 01111111 11000000000000000000000</td></tr><tr><td>1101.101</td><td>130</td><td>0 10000010 10110100000000000000000</td></tr><tr><td>-0.00101</td><td>124</td><td>1 0111110001000000000000000000000</td></tr><tr><td>100111</td><td>132</td><td>0 10000100 00111000000000000000000</td></tr><tr><td>0.00000011</td><td>120</td><td>001111000 10101100000000000000000</td></tr></tbody></table><p>IEEE 规范包含了多种实数和非数字编码。</p><ul><li><p>正零和负零</p></li><li><p>非规格化有限数</p></li><li><p>规格化有限数</p></li><li><p>正无穷和负无穷</p></li><li><p>非数字 (NaN，即不是一个数字 (Not a Number))</p></li><li><p>不定</p></li></ul><p>不定数被浮点单元 (FPU) 用于响应一些无效的浮点操作。</p><h4 id="规格化和非规格化"><a href="#规格化和非规格化" class="headerlink" title="规格化和非规格化"></a>规格化和非规格化</h4><p>规格化有限数 (nonnalized finite numbers) 是指所有非零有限值，这些数能被编码为零到无穷之间的规格化实数。尽管看上去全部有限非零浮点数都应被规格化，但是若数值接近于零，则无法规格化。</p><p>当阶码范围造成的限制使得 FPU 不能将二进制小数点移动到规格化位置时，就会发生这种情况。假设 FPU 计算结果为 </p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226925762339" alt="img"></p><p>其阶码太小，无法用单精度数形式存放。此时产生一个下溢异常，数值则每次将二进制小数点左移一位逐步进行非规格化，直到阶码达到有效范围：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226935271341" alt="img"></p><p>在这个例子中，移动二进制小数点导致有效数字损失了精度。</p><h4 id="正无穷和负无穷"><a href="#正无穷和负无穷" class="headerlink" title="正无穷和负无穷"></a>正无穷和负无穷</h4><p>正无穷 (+∞) 表示最大正实数，负无穷 (-∞) 表示最大负实数。无穷可以与其他数值比较：-∞ 小于 +∞，-∞ 小于任意有限数，+∞ 大于任意有限数。任一无穷都可以表示浮点溢出条件。运算结果不能规格化的原因是，结果的阶码太大而无法用有效阶码位数来表示。</p><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>NaN 是不表示任何有效实数的位模式。x86 有两种 NaN：quiet NaN 能够通过大多数算术运算来传递，而不会引起异常。signaling NaN 则被用于产生一个浮点无效操作异常。</p><p>编译器可以用 signaling NaN 填充未初始化数组，那么，任何试图在这个数组上执行的运算都会引发异常。quiet NaN 可以用于存在调试期间生成的诊断信息。程序可根据需要自由地在 NaN 中编入任何信息。FPU 不会尝试在 NaN 上执行操作。Intel 手册有一组规则确定了以这两种 NaN 为操作数的指令结果。</p><h4 id="特定编码"><a href="#特定编码" class="headerlink" title="特定编码"></a>特定编码</h4><p>在浮点运算中，常常会出现一些特定的数值编码，如下表所示。字母 x 表示的位，其值可以为 1，也可以为 0。 QNaN 是 quiet NaN, SNaN 是 signaling NaN。</p><table><thead><tr><th>数值</th><th>符号、阶码、有效数字</th></tr></thead><tbody><tr><td>Positive zero</td><td>0 00000000 00000000000000000000000</td></tr><tr><td>Negative zero</td><td>1 00000000 00000000000000000000000</td></tr><tr><td>Positive infinity</td><td>0 11111111 00000000000000000000000</td></tr><tr><td>Negative infinity</td><td>1 11111111 00000000000000000000000</td></tr><tr><td>QNaN</td><td>x 11111111 1xxxxxxxxxxxxxxxxxxxxxx</td></tr><tr><td>SNaN</td><td>x 11111111 0xxxxxxxxxxxxxxxxxxxxxx</td></tr></tbody></table><h2 id="汇编语言十进制小数转换为二进制实数"><a href="#汇编语言十进制小数转换为二进制实数" class="headerlink" title="汇编语言十进制小数转换为二进制实数"></a>汇编语言十进制小数转换为二进制实数</h2><p>当十进制小数可以表示为形如 (1/2+1/4+1/8+…) 的分数之和时，发现与之对应的二进制实数就非常容易了。如下表所示，左列中的大多数分数不容易转换为二进制。不过，可以将它们写成第二列的形式。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226951621343" alt="img"></p><p>很多实数，如 1/10（0.1）或 1/100（0.01），不能表示为有限位的二进制数，它们只能近似地表示为一组以 2 的幂为分母的分数之和。想想看，像 $39.95 这样的货币值受到了怎样的影响！</p><h4 id="使用二进制长除法"><a href="#使用二进制长除法" class="headerlink" title="使用二进制长除法"></a>使用二进制长除法</h4><p>当十进制数比较小的时候，将十进制分数转换为二进制的一个简单方法就是：先将分子与分母转换为二进制，再执行长除。例如，十进制数 0.5 表示为分数就是 5/10，那么十进制 5 等于二进制 0101，十进制 10 等于二进制 1010。执行了长除之后，商为二进制数 0.1：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226960656345" alt="img"></p><p>当被除数减去除数 1010 的结果为 0 时，除法完成。因此，十进制分数 5/10 等于二进制数 0.1。这种方法被称为二进制长除法（binary long division method）。</p><p>下面用二进制长除法将十进制数 0.2（2/10）转换为二进制数。首先，用二进制 10 除以二进制 1010（十进制 10）：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226969651347" alt="img"></p><p>第一个足够大到能上商的数是 10000。从 10000 减去 1010 后，余数为 110。添加一个 0 后，形成新的被除数 1100。从 1100 减去 1010 后，余数为 10。添加三个 0 后，形成新的被除数 10000。</p><p>这个数与第一个被除数相同。从这里开始，商的位序列出现重复（0011…），由此可知，不会得到确定的商，所以，0.2 也不能表示为有限位的数。其单精度编码的有效数字为 10011001100110011001100。</p><h4 id="单精度数转换为十进制"><a href="#单精度数转换为十进制" class="headerlink" title="单精度数转换为十进制"></a>单精度数转换为十进制</h4><p>IEEE 单精度数转换为十进制时，建议步骤如下：</p><p>\1) 若 MSB 为 1，该数为负；否则，该数为正。</p><p>\2) 其后 8 位为阶码。从中减去二进制值 01111111（十进制数 127），生成无偏差阶码。将无偏差阶码转换为十进制。</p><p>\3) 其后 23 位表示有效数字。添加“1.”，后面紧跟有效数字位，尾随零可以忽略。用形成的有效数字、第一步得到的符号和第二步计算出来的阶码，就构成一个二进制浮点数。</p><p>\4) 对第三步生成的二进制数进行非规格化。（按照阶码的值移动二进制小数点。如果阶码为正，则右移；如果阶码为负，则左移。）</p><p>\5) 利用加权位计数法，从左到右，将二进制浮点数转换为 2 的幂之和，形成十进制数。</p><p>【示例】IEEE（0 10000010 01011000000000000000000）转换为十进制</p><p>\1) 该数为正数。</p><p>\2) 无偏差阶码的二进制值为 00000011，十进制值为 3。</p><p>\3) 将符号、阶码和有效数字组合起来即得该二进制数为 +1.01011 x2³。</p><p>\4) 非规格化二进制数为 +1010.11。</p><p>\5) 则该数的十进制值为 +10 3/4，或 +10.75。</p><h2 id="汇编语言FPU寄存器栈（register-stack）"><a href="#汇编语言FPU寄存器栈（register-stack）" class="headerlink" title="汇编语言FPU寄存器栈（register stack）"></a>汇编语言FPU寄存器栈（register stack）</h2><p>FPU 不使用通用寄存器 (EAX、EBX 等等)。反之，它有自己的一组寄存器，称为寄存器栈 (register stack)。数值从内存加载到寄存器栈，然后执行计算，再将堆栈数值保存到内存。</p><p>FPU 指令用后缀 (postfix) 形式计算算术表达式，这和惠普计算器的方法大致相同。比如，现有一个中缀表达式 (infix expression)：(5*6)+4,其后缀表达式为：</p><pre><code>5 6 * 4 +</code></pre><p>中缀表达式 (A+B)*C 要用括号来覆盖默认的优先级规则（乘法在加法之前）。与之等效的后缀表达式则不需要括号：</p><h4 id="表达式堆栈"><a href="#表达式堆栈" class="headerlink" title="表达式堆栈"></a>表达式堆栈</h4><p>在计算后缀表达式的过程中，用堆栈来保存中间结果。下图展示了计算后缀表达式 56*4- 所需的步骤。堆栈条目被标记为 ST(0) 和 ST(1)，其中 ST(0) 表示堆栈指针通常所指位置。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226986395349" alt="img"></p><p>中缀表达式转换为后缀表达式的常见方法在互联网以及计算机科学入门读物中都可以查阅到，此处不再赘述。下表给岀了一些等价表达式。</p><table><thead><tr><th>中缀</th><th>后缀</th><th>中缀</th><th>后缀</th></tr></thead><tbody><tr><td>A+B</td><td>AB+</td><td>(A+B)*(C+D)</td><td>AB+CD+*</td></tr><tr><td>(A-B)/D</td><td>AB-D/</td><td>((A+B)/C)*(E—F)</td><td>AB+C/EF-*</td></tr></tbody></table><h3 id="FPU-数据寄存器"><a href="#FPU-数据寄存器" class="headerlink" title="FPU 数据寄存器"></a>FPU 数据寄存器</h3><p>FPU 有 8 个独立的、可寻址的 80 位数据寄存器 R0〜R7，如下图所示，这些寄存器合称为寄存器栈。FPU 状态字中名为 TOP 的一个 3 位字段给出了当前处于栈顶的寄存器编号。例如，在下图中，TOP 等于二进制数 011，这表示栈顶为 R3。在编写浮点指令时，这个位置也称为 ST(0)（或简写为 ST）。最后一个寄存器为 ST(7)。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627226999707351" alt="img"></p><p>如同所想的一样，入栈（push）操作（也称为加载）将 TOP 减 1，并把操作数复制到标识为 ST(0) 的寄存器中。如果在入栈之前，TOP 等于 0，那么 TOP 就回绕到寄存器 R7。</p><p>出栈（pop）操作（也称为保存）把 ST(0) 的数据复制到操作数，再将TOP加1。如果在出栈之前，TOP 等于 7，则 TOP 就回绕到寄存器 R0。</p><p>如果加载到堆栈的数值覆盖了寄存器栈内原有的数据，就会产生一个浮点异常（floating-point exception）。下图展示了数据 1.0 和 2.0 入栈后的堆栈情况。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627227009123353" alt="img"></p><p>尽管理解 FPU 如何用一组有限数量的寄存器实现堆栈很有意思，但这里只需关注 ST(n)，其中 ST(0) 总是表示栈顶。从这里开始，引用栈寄存器时将使用 ST(0)，ST(1)，以此类推。指令操作数不能直接引用寄存器编号。</p><p>寄存器中浮点数使用的是 IEEE 10 字节扩展实数格式（也被称为临时实数（temporary real））。当 FPU 把算术运算结果存入内存时，它会把结果转换成如下格式之一：整数、长整</p><p>数、单精度（短实数）、双精度（长实数），或者压缩二进制编码的十进制数（BCD）。</p><h3 id="专用寄存器"><a href="#专用寄存器" class="headerlink" title="专用寄存器"></a>专用寄存器</h3><p>FPU 有 6 个专用（special-purpose）寄存器，如下图所示：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627227018211355" alt="img"></p><ul><li><p>操作码寄存器：保存最后执行的非控制指令的操作码。</p></li><li><p>控制寄存器：执行运算时，控制精度以及 FPU 使用的舍入方法。还可以用这个寄存器来屏蔽（隐藏）单个浮点异常。</p></li><li><p>状态寄存器：包含栈顶指针、条件码和异常警告。</p></li><li><p>标识寄存器：指明 FPU 数据寄存器栈内每个寄存器的内容。其中，每个寄存器都用两位来表示该寄存器包含的是一个有效数、零、特殊数值 (NaN、无穷、非规格化，或不支持的格式 )，还是为空。</p></li><li><p>最后指令指针寄存器：保存指向最后执行的非控制指令的指针。</p></li><li><p>最后数据（操作数）指针寄存器：保存指向数据操作数的指针，如果存在，那么该数被最后执行的指令所使用。</p></li></ul><p>操作系统使用这些专用寄存器在任务切换时保存状态信息。</p><h2 id="汇编语言FPU舍入：计算浮点数的精确结果"><a href="#汇编语言FPU舍入：计算浮点数的精确结果" class="headerlink" title="汇编语言FPU舍入：计算浮点数的精确结果"></a>汇编语言FPU舍入：计算浮点数的精确结果</h2><p>FPU 尝试从浮点计算中产生非常精确的结果。但是，在很多情况下这是不可能的，因为目标操作数可能无法精确表示计算结果。比如，假设现有一特定存储格式只允许 3 个小数位。那么，该格式可以保存形如 1.011 或 1.101 的数值，而不能保存形如 1.0101 的数值。</p><p>若计算的精确结果为 +1.0111 (十进制数 1.4375)，那么，既可以通过加 0.0001 向上舍入该数，也可以通过减 0.0001 向下舍入：</p><p>(a) 1.0111 -&gt; 1.100</p><p>(b) 1.0111 -&gt; 1.011</p><p>若精确结果是负数，那么加 -0.0001 会使舍入结果更接近 -∞。而减去 -0.0001 会使舍入结果更接近 0 和 +8：</p><p>(a) -1.0111 -&gt; -1.100</p><p>(b) -1.0111 -&gt; -1.011</p><p>FPU 可以在四种舍入方法中进行选择：</p><p>\1) 舍入到最接近的偶数 (round to nearest even):舍入结果最接近无限精确的结果。如果有两个值近似程度相同，则取偶数值 (LSB=0)。</p><p>\2) 向 -∞ 舍入 (round down to -∞ )：舍入结果小于或等于无限精确结果。</p><p>\3) 向 +∞ 舍入 (round down to +∞ )：舍入结果大于或等于无限精确结果。</p><p>\4) 向 0 舍入 (round toward zero)：也被称为截断法，舍入结果的绝对值小于或等于无限精确结果。</p><h4 id="FPU-控制字"><a href="#FPU-控制字" class="headerlink" title="FPU 控制字"></a>FPU 控制字</h4><p>FPU 控制字用两位指明使用的舍入方法，这两位被称为 RC 字段，字段数值（二进制）如下：</p><ul><li><p>00：舍入到最接近的偶数（默认）。</p></li><li><p>01：向负无穷舍入。</p></li><li><p>10：向正无穷舍入。</p></li><li><p>11：向 0 舍入（截断）。</p></li></ul><p>舍入到最接近的偶数是默认选择，它被认为是最精确的，也最适合大多数应用程序。下表以二进制数 +1.0111 为例，展示了四种舍入方法。</p><table><thead><tr><th>方法</th><th>精确结果</th><th>舍入结果</th><th>方法</th><th>精确结果</th><th>舍入结果</th></tr></thead><tbody><tr><td>舍入到最接近的偶数</td><td>1.0111</td><td>1.1</td><td>向 +∞ 舍入</td><td>1.0111</td><td>1.1</td></tr><tr><td>向 -∞ 舍入</td><td>1.0111</td><td>1.011</td><td>向 0 舍入</td><td>1.0111</td><td>1.011</td></tr></tbody></table><p>同样，下表展示了二进制数 -1.0111 的舍入结果。</p><h2 id="汇编语言浮点数异常与常用指令集"><a href="#汇编语言浮点数异常与常用指令集" class="headerlink" title="汇编语言浮点数异常与常用指令集"></a>汇编语言浮点数异常与常用指令集</h2><p>每个程序都可能出错，而 FPU 就需要处理这些结果。因而，它要识别并检测 6 种类型的异常条件：</p><ul><li><p>无效操作（#I）</p></li><li><p>除零（#Z）</p></li><li><p>非规格化操作数（#D）</p></li><li><p>数字上溢（#O）</p></li><li><p>数字下溢（#U）</p></li><li><p>模糊精度（#P）</p></li></ul><p>前三个（#I、#Z 和 #D）在全部运算操作发生前进行检测，后三个（#O、#U 和 #P）则在操作发生后检测。</p><p>每种异常都有对应的标志位和屏蔽位。当检测到浮点异常时，处理器将与之匹配的标志位置 1。每个被处理器标记的异常都有两种可能的操作：</p><ul><li><p>如果相应的屏蔽位置 1，那么处理器自动处理异常并继续执行程序。</p></li><li><p>如果相应的屏蔽位清 0，那么处理器将调用软件异常处理程序。</p></li></ul><p>大多数程序普遍都可以接受处理器的屏蔽（自动）响应。如果应用程序需要特殊响应，那么可以使用自定义异常处理程序。一条指令能触发多个异常，因此处理器要持续保存自上一次异常清零后所发生的全部异常。完成一系列计算后，可以检测是否发生了异常。</p><h3 id="浮点数指令集"><a href="#浮点数指令集" class="headerlink" title="浮点数指令集"></a>浮点数指令集</h3><p>FPU 指令集有些复杂，因此这里只对其功能进行概述，并用具体例子给出编译器通常会生成的代码。此外，大家还将看到如何通过改变舍入模式来控制 FPU。指令集包括如下基本指令类型：</p><ul><li><p>数据传送</p></li><li><p>基本算术运算</p></li><li><p>比较</p></li><li><p>超越函数</p></li><li><p>常数加载（仅对专门预定义的常数）</p></li><li><p>x87 FPU 控制</p></li><li><p>x87 FPU 和 SIMD 状态管理</p></li></ul><p>浮点指令名用字母 F 开头，以区别于 CPU 指令。指令助记符的第二个字母（通常为 B 或 I）指明如何解释内存操作数：B 表示 BCD 操作数，I 表示二进制整数操作数。</p><p>如果这两个字母都没有使用，则内存操作数将被认为是实数。比如，FBLD 操作对象为 BCD 数值， FILD 操作对象为整数，而 FLD 操作对象为实数。</p><h4 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h4><p>浮点指令可以包含零操作数、单操作数和双操作数。如果是双操作数，那么其中一个必然为浮点寄存器。指令中没有立即操作数，但是某些预定义常数（如 0.0，π 和 log210）可以加载到堆栈。</p><p>通用寄存器 EAX、EBX、ECX 和 EDX 不能作为操作数。（唯一的例外是 FSTSW，它将 FPU 状态字保存在 AX 中。）不允许内存-内存操作。</p><p>整数操作数从内存（不是从 CPU 寄存器）加载到 FPU，并自动转换为浮点格式。同样，将浮点数保存到整数内存操作数时，该数值也会被自动截断或舍入为整数。</p><h3 id="初始化（FINIT）"><a href="#初始化（FINIT）" class="headerlink" title="初始化（FINIT）"></a>初始化（FINIT）</h3><p>FINIT 指令对 FPU 进行初始化。将 FPU 控制字设置为 037Fh，即屏蔽（隐藏）了所有浮点异常；舍入模式设置为最近偶数，计算精度设置为 64 位。建议在程序开始时调用 FINIT, 这样就可以了解处理器的起始状态。</p><h3 id="浮点数据类型"><a href="#浮点数据类型" class="headerlink" title="浮点数据类型"></a>浮点数据类型</h3><p>现在快速回顾一下 MASM 支持的浮点数据类型（QWORD、TBYTE、REAL4、REAL8 和 REAL10）,如下表所示。</p><table><thead><tr><th>类型</th><th>用法</th></tr></thead><tbody><tr><td>QWORD</td><td>64 位整数</td></tr><tr><td>TBYTE</td><td>80 位（10 字节）整数</td></tr><tr><td>REAL4</td><td>32 位（4 字节）IEEE 短实数</td></tr><tr><td>REAL8</td><td>64 位（8 字节）IEEE 长实数</td></tr><tr><td>REAL10</td><td>80 位（10 字节）IEEE 扩展实数</td></tr></tbody></table><p>在定义 FPU 指令 的内存操作数时，将会使用到这些类型。例如，加载一个浮点变量到 FPU 堆栈，这个变量可以定义为 REAL4，REAL8 或 REAL10：</p><pre><code>.databigVal REAL10 1.212342342234234243E+864.codefld bigVal             ;加载变量到堆栈</code></pre><h3 id="加载浮点数值（FLD）"><a href="#加载浮点数值（FLD）" class="headerlink" title="加载浮点数值（FLD）"></a>加载浮点数值（FLD）</h3><p>FLD（加载浮点数值）指令将浮点操作数复制到 FPU 堆栈栈顶（称为 ST(0)）。操作数可以是 32 位、64 位、80 位的内存操作数（REAL4、REAL8、REAL10）或另一个 FPU 寄存器：</p><pre><code>FLD m32fpFLD m64fpFLD m80fpFLD ST(i)</code></pre><p>内存操作数类型 FLD 支持的内存操作数类型与 MOV 指令一样。示例如下：</p><pre><code>.dataarray REAL8 10 DUP (?).codefid array                         ;直接寻址fid [array+16 ]                    ;直接偏移fid REAL8 PTR[esi]                 ;间接寻址fid array[esi]                      ;变址寻址fid array[esi*8]                    ;带比例因子的变址fid array[esi*TYPE array]             ;带比例因子的变址fid REAL8 PTR[ebx+esi]             ;基址-变址fid array[ebx+esi]                  ;基址-变址-偏移量fid array[ebx+esi*TYPE array]         ;带比例因子的基址-变址-偏移量</code></pre><p>【示例】下面的例子加载两个直接操作数到 FPU 堆栈：</p><pre><code>.datadblOne REAL8 234.56dblTwo REAL8 10.1.codefid dblOne           ; ST(0) = dblOnefid dblTwo           ; ST(0) = dblTwo, ST(1) = dblOne</code></pre><p>每条指令执行后的堆栈情况如下图所示：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmM0MDYxYTQzNDhjNzZlMTg2ZTAxNTJlNzE0YjhiZDJfTTRPUm9SbjlybllROVZlNWExQ3BMS041aGxoYkVEQXZfVG9rZW46Ym94Y25SczFpR3FBNk1zNjN3aEJnRXhOTXZkXzE2MjcyMTY3MjU6MTYyNzIyMDMyNV9WNA" alt="img"></p><p>执行第二条 FLD 时，TOP 减 1，这使得之前标记为 ST(0) 的堆栈元素变为了 ST(1)。</p><h4 id="FILD"><a href="#FILD" class="headerlink" title="FILD"></a>FILD</h4><p>FILD（加载整数）指令将 16 位、32 位或 64 位有符号整数源操作数转换为双精度浮点数，并加载到 ST(0)。源操作数符号保留。FILD 支持的内存操作数类型与 MOV 指令一致（间接、变址、基址-变址等）。</p><h4 id="加载常数"><a href="#加载常数" class="headerlink" title="加载常数"></a>加载常数</h4><p>下面的指令将特定常数加载到堆栈。这些指令没有操作数：</p><ul><li><p>FLD1 指令将 1.0 压入寄存器堆栈。</p></li><li><p>FLDL2T 指令将 log210 压入寄存器堆栈。</p></li><li><p>FLDL2E 指令将 log2e 压入寄存器堆栈。</p></li><li><p>FLDPI 指令将 π 压入寄存器堆栈。</p></li><li><p>FLDLG2 指令将 log102 压入寄存器堆栈。</p></li><li><p>FLDLN2 指令将 loge2压入寄存器堆栈。</p></li><li><p>FLDZ（加载零）指令将 0.0 压入 FPU 堆栈。</p></li></ul><h3 id="保存浮点数值（FST-FSTP）"><a href="#保存浮点数值（FST-FSTP）" class="headerlink" title="保存浮点数值（FST, FSTP）"></a>保存浮点数值（FST, FSTP）</h3><p>FST（保存浮点数值）指令将浮点操作数从 FPU 栈顶复制到内存。FST 支持的内存操作数类型与 FLD 一致。操作数可以为 32 位、64 位、80 位内存操作数（REAL4、REAL8、 REAL10）或另一个 FPU 寄存器：</p><pre><code>FST m32fp FST m80fpFST m64fp FST ST(i)</code></pre><p>FST 不是弹出堆栈。下面的指令将 ST(0) 保存到内存。假设 ST(0) 等于 10.1，ST(1) 等于 234.56：</p><pre><code>fst dblThree  ; 10.1fst dblFour    ; 10.1</code></pre><p>直观地说，代码段期望 dblFour 等于 234.56。但是第一条 FST 指令把 10.1 留在 ST(0) 中。如果代码段的意图是把 ST(1) 复制到 dblFour，那么就要用 FSTP 指令。</p><h4 id="FSTP"><a href="#FSTP" class="headerlink" title="FSTP"></a>FSTP</h4><p>FSTP（保存浮点值并将其出栈）指令将 ST(0) 的值复制到内存并将 ST(0) 弹出堆栈。假设执行下述指令前 ST(0) 等于 10.1，ST(1) 等于 234.56：</p><pre><code>fstp dblThree ; 10.1fstp dblFour ; 234.56</code></pre><p>指令执行后，这两个数值会从堆栈中逻辑移除。从物理上看，每次执行 FSTP，TOP 指针都会减 1，修改 ST(0) 的位置。</p><p>FIST（保存整数）指令将 ST(0) 的值转换为有符号整数，并把结果保存到目标操作数。保存的值可以为字或双字。FIST 支持的内存操作数类型与 FST 一致。</p><h2 id="汇编语言浮点数算术运算指令"><a href="#汇编语言浮点数算术运算指令" class="headerlink" title="汇编语言浮点数算术运算指令"></a>汇编语言浮点数算术运算指令</h2><p>下表列出了基本算术运算操作。所有算术运算指令支持的内存操作数类型与 FLD （加载）和 FST（保存）一致，因此，操作数可以是间接操作数、变址操作数和基址-变址操作数等等。</p><table><thead><tr><th>FCHS</th><th>修改符号</th></tr></thead><tbody><tr><td>FADD</td><td>源操作数与目的操作数相加</td></tr><tr><td>FSUB</td><td>从目的操作数中减去源操作数</td></tr><tr><td>FSUBR</td><td>从源操作数中减去目的操作数</td></tr><tr><td>FMUL</td><td>源操作数与目的操作数相乘</td></tr><tr><td>FDIV</td><td>目的操作数除以源操作数</td></tr><tr><td>FDIVR</td><td>源操作数除以目的操作数</td></tr></tbody></table><h3 id="FCHS-和-FABS"><a href="#FCHS-和-FABS" class="headerlink" title="FCHS 和 FABS"></a>FCHS 和 FABS</h3><p>FCHS( 修改符号 ) 指令将 ST(0) 中浮点数值的符号取反。FABS ( 绝对值 ) 指令清除 ST(0) 中数值的符号，以得到它的绝对值。这两条指令都没有操作数：</p><pre><code>FCHSFABS</code></pre><h3 id="FADD、FADDP、FIADD"><a href="#FADD、FADDP、FIADD" class="headerlink" title="FADD、FADDP、FIADD"></a>FADD、FADDP、FIADD</h3><p>FADD（加法）指令格式如下，其中，m32fp 是 REAL4 内存操作数，m64fp 即是 REAL8 内存操作数，i 是寄存器编号：</p><pre><code>FADDFADD m32fpFADD m64fpFADD ST(0), ST(i)FADD ST(i) , ST(0)</code></pre><h4 id="无操作数"><a href="#无操作数" class="headerlink" title="无操作数"></a>无操作数</h4><p>如果 FADD 没有操作数，则 ST(0)与 ST(1)相加，结果暂存在 ST(l)。然后 ST(0) 弹出堆栈，把加法结果保留在栈顶。假设堆栈已经包含了两个数值，下图展示了 FADD 的操作：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627227043626357" alt="img"></p><h4 id="寄存器操作数"><a href="#寄存器操作数" class="headerlink" title="寄存器操作数"></a>寄存器操作数</h4><p>从同样的栈开始，如下所示将 ST(0) 加到 ST(1)：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627227052509359" alt="img"></p><h4 id="内存操作数"><a href="#内存操作数" class="headerlink" title="内存操作数"></a>内存操作数</h4><p>如果使用的是内存操作数，FADD 将操作数与 ST(0) 相加。示例如下：</p><pre><code>fadd mySingle      ; ST(0) += mySinglefadd REAL8 PTR[esi]  ; ST(0) += [esi]</code></pre><h4 id="FADDP"><a href="#FADDP" class="headerlink" title="FADDP"></a>FADDP</h4><p>FADDP（相加并出栈）指令先执行加法操作，再将 ST(0) 弹出堆栈。MASM 支持如下格式：</p><pre><code>FADDP ST(i),ST(0)</code></pre><p>下图演示了 FADDP 的操作过程：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627227068518361" alt="img"></p><h4 id="FIADD"><a href="#FIADD" class="headerlink" title="FIADD"></a>FIADD</h4><p>FIADD（整数加法）指令先将源操作数转换为扩展双精度浮点数，再与 ST(0) 相加。指令语法如下：</p><pre><code>FIADD ml6intFIADD m32int</code></pre><p>示例：</p><pre><code>.datamyInteger DWORD 1.codefiadd myInteger         ; ST(0) += myInteger</code></pre><h3 id="FSUB、FSUBP、FISUB"><a href="#FSUB、FSUBP、FISUB" class="headerlink" title="FSUB、FSUBP、FISUB"></a>FSUB、FSUBP、FISUB</h3><p>FSUB 指令从目的操作数中减去源操作数，并把结果保存在目的操作数中。目的操作数总是一个 FPU 寄存器，源操作数可以是 FPU 寄存器或者内存操作数。该指令操作数类型与 FADD 指令一致：</p><pre><code>FSUBFSUB m32fpFSUB m64fpFSUB ST(0), ST(i)FSUB ST(i), ST(0)</code></pre><p>FSUB 的操作与 FADD 相似，只不过它进行的是减法而不是加法。比如，无参数 FSUB 实现 ST(1) - ST(0)，结果暂存于 ST(1)。然后 ST(0) 弹出堆栈，将减法结果留在栈顶。若 FSUB 使用内存操作数，则从 ST(0) 中减去内存操作数，且不再弹出堆栈。</p><pre><code>fsub mySingle      ; ST(0) -= mySinglefsub array[edi*8]  ; ST(0) -= array[edi*8]</code></pre><h4 id="FSUBP"><a href="#FSUBP" class="headerlink" title="FSUBP"></a>FSUBP</h4><p>FSUBP（相减并出栈）指令先执行减法，再将 ST(0) 弹出堆栈。MASM 支持如下格式：</p><pre><code>FSUBP ST(i),ST(0)</code></pre><h4 id="FISUB"><a href="#FISUB" class="headerlink" title="FISUB"></a>FISUB</h4><p>FISUB（整数减法）指令先把源操作数转换为扩展双精度浮点数，再从 ST(0) 中减去该操作数：</p><pre><code>FISUB m16intFISUB m32int</code></pre><h3 id="FMUL、FMULP、FIMUL"><a href="#FMUL、FMULP、FIMUL" class="headerlink" title="FMUL、FMULP、FIMUL"></a>FMUL、FMULP、FIMUL</h3><p>FMUL 指令将源操作数与目的操作数相乘，乘积保存在目的操作数中。目的操作数总是一个 FPU 寄存器，源操作数可以为寄存器或者内存操作数。其语法与 FADD 和 FSUB 相同：</p><pre><code>FMULFMUL m32fpFMUL m64fpFMUL ST(0), ST(i)FMUL ST(i), ST(0)</code></pre><p>除了执行的是乘法而不是加法外，FMUL 的操作与 FADD 相同。比如，无参数 FMUL 将 ST(O) 与 ST(1) 相乘，乘积暂存于 ST(1)。然后 ST(0) 弹出堆栈，将乘积留在栈顶。同样，使用内存操作数的 FMUL 则将内存操作数与 ST(0) 相乘：</p><pre><code>fmul mySingle   ; ST(0) *= mySingle</code></pre><h4 id="FMULP"><a href="#FMULP" class="headerlink" title="FMULP"></a>FMULP</h4><p>FMULP（相乘并出栈）指令先执行乘法，再将 ST(0) 弹出堆栈。MASM 支持如下格式：</p><pre><code>FMULP ST(i),ST(O)</code></pre><p>FIMUL 与 FIADD 相同，只是它执行的是乘法而不是加法：</p><pre><code>FIMUL ml6intFIMUL m32int</code></pre><h3 id="FDIV、FDIVP、FIDIV"><a href="#FDIV、FDIVP、FIDIV" class="headerlink" title="FDIV、FDIVP、FIDIV"></a>FDIV、FDIVP、FIDIV</h3><p>FDIV 指令执行目的操作数除以源操作数，被除数保存在目的操作数中。目的操作数总是一个寄存器，源操作数可以为寄存器或者内存操作数。其语法与 FADD 和 FSUB 相同：</p><pre><code>FDIVFDIV m32fpFDIV m64fpFDIV ST(O), ST(i)FDIV ST(i), ST(O)</code></pre><p>除了执行的是除法而不是加法外，FDIV 的操作与 FADD 相同。比如，无参数 FDIV 执行 ST(1) 除以 ST(0)。然后 ST(0) 弹出堆栈，将被除数留在栈顶。使用内存操作数的 FDIV 将 ST(0) 除以内存操作数。下面的代码将 dblOne 除以 dblTwo，并将商保存到 dblQuot：</p><pre><code>.datadblOne REAL8 1234.56dblTwo REAL8 10.0dblQuot REAL8 ?.codefid dblOne      ; 加载到 ST (0)fdiv dblTwo     ; ST(0) 除以 dblTwofstp dblQuot      ; 将 ST(0) 保存到 dblQuot</code></pre><p>若源操作数为 0，则产生除零异常。若源操作数等于正、负无穷，零或 NaN，则使用一些特殊情况。</p><h4 id="FIDIV"><a href="#FIDIV" class="headerlink" title="FIDIV"></a>FIDIV</h4><p>FIDIV 指令先将整数源操作数转换为扩展双精度浮点数，再执行与 ST(0) 的除法。其语法如下：</p><pre><code>FIDIV ml6intFIDIV m32int</code></pre><h2 id="汇编语言FCOM指令：比较浮点数值"><a href="#汇编语言FCOM指令：比较浮点数值" class="headerlink" title="汇编语言FCOM指令：比较浮点数值"></a>汇编语言FCOM指令：比较浮点数值</h2><p>浮点数不能使用 CMP 指令进行比较，因为后者是通过整数减法来执行比较的。取而代之，必须使用 FCOM 指令。</p><p>执行 FCOM 指令后，还需要采取特殊步骤，然后再使用逻辑 IF 语句中的条件跳转指令（JA、JB、JE 等）。由于所有的浮点数都为隐含的有符号数，因此，FCOM 执行的是有符号比较。</p><h4 id="FCOM、FCOMP、FCOMPP"><a href="#FCOM、FCOMP、FCOMPP" class="headerlink" title="FCOM、FCOMP、FCOMPP"></a>FCOM、FCOMP、FCOMPP</h4><p>FCOM（比较浮点数）指令将其源操作数与 ST(0) 进行比较。源操作数可以为内存操作数或 FPU 寄存器。</p><p>FCOMP 指令的操作数类型和执行的操作与 FCOM 指令相同，但是它要将 ST(0) 弹岀堆栈。FCOMPP 指令与 FCOMP 相同，但是它有两次出栈操作。</p><h4 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h4><p>FPU 条件码标识有 3 个，C3、C2 和 C0，用以说明浮点数比较的结果，如下表所示。由于 C3、C2 和 C0 的功能分别与零标志位 (ZF)、奇偶标志位 (PF) 和进位标志位 (CF) 相同，因此表中列标题给出了与之等价的 CPU 状态标识。</p><table><thead><tr><th>条件</th><th>C3（零标志位）</th><th>C2（奇偶标志位）</th><th>C0（进位标志位）</th><th>使用的条件跳转指令</th></tr></thead><tbody><tr><td>ST(0) &gt; SPC</td><td>0</td><td>0</td><td>0</td><td>JA.JNBE</td></tr><tr><td>ST(0) &lt; SPC</td><td>0</td><td>0</td><td>1</td><td>JB.JNAE</td></tr><tr><td>ST(0) = SPC</td><td>1</td><td>0</td><td>0</td><td>JE.JZ</td></tr><tr><td>无序</td><td>1</td><td>1</td><td>1</td><td>（无）</td></tr></tbody></table><blockquote><p>提示：如果出现无效算术运算操作数异常（无效操作数），且该异常被屏蔽，则 C3、C2 和 C0 按照标记为“无序”的行来设置。</p></blockquote><p>在比较了两个数值并设置了 FPU 条件码之后，遇到的主要挑战就是怎样根据条件分支到相应标号。这包括了两个步骤：</p><ul><li><p>用 FNSTSW 指令把 FPU 状态字送入 AX。</p></li><li><p>用 SAHF 指令把 AH 复制到 EFLAGS 寄存器。</p></li></ul><p>条件码送入 EFLAGS 之后，就可以根据 ZF、PF 和 CF 进行条件跳转。上表列出了每种标志位组合所对应的条件跳转。根据该表还可以推出其他跳转：如果 CF=0，则可以使用 JAE 指令引发控制转移；如果 CF=1 或 ZF=1，则可使用 JBE 指令引发控制转移；如果 ZF=0，则可使用 JNE 指令。</p><p>【示例】现有如下 C++ 代码段：</p><pre><code>double X = 1.2;double Y = 3.0;int N = 0;if( X &lt; Y )N = 1;</code></pre><p>与之等效的汇编语言代码如下：</p><pre><code>.dataX REAL8 1.2Y REAL8 3.0N DWORD 0.codeif( X &lt; Y )   ; N = 1   fid X       ; ST(0) = X   fcomp Y    ;比较 ST (0)和 Y   fnstsw ax   ;状态字送入AX   sahf       ;AH 复制至！) EFLAGS   jnb L1      ;X不小于Y?跳过   mov Nz1      ; N = 1L1:</code></pre><h4 id="P6-处理器的改进"><a href="#P6-处理器的改进" class="headerlink" title="P6 处理器的改进"></a>P6 处理器的改进</h4><p>对上面的例子需要说明一点的是浮点数比较的运行时开销大于整数比较。考虑到这一点，Intel P6 系列引入了 FCOMI 指令。该指令比较浮点数值，并直接设置 ZF、PF 和 CF。P6 系列以 Pentium Pro 和 Pentium II 处理器为起点。) FCOMI 的语法如下：</p><p>FCOMI 指令代替了之前代码段中的三条指令，但是增加了一条 FLD 指令。FCOMI 指令不使用内存操作数。</p><h4 id="相等比较"><a href="#相等比较" class="headerlink" title="相等比较"></a>相等比较</h4><p>几乎所有的编程入门教材都会警告读者不要进行浮点数相等的比较，其原因是在计算</p><p>过程中出现的舍入误差。现在通过计算表达式 (sqrt(2.0)*sqrt(2.0)) -2.0 来对这个问题进行说明。从数学上看，这个表达式应 该等于0,但计算结果却相差甚远（约等于 4.4408921E-016）。 使用如下数据，下表列出了每一步计算后FPU堆栈的情况：</p><pre><code>vail REAL8 2.0</code></pre><table><thead><tr><th>指令</th><th>FPU堆栈</th></tr></thead><tbody><tr><td>fidvall</td><td>ST(0) : +2.0000000E+000</td></tr><tr><td>fsqrt</td><td>ST(0) : +1.4142135E+000</td></tr><tr><td>fmul</td><td>ST(0), ST(0) ST(0) : +2.0000000E+000</td></tr><tr><td>fsub vail</td><td>ST(0) : +4.4408921E-016</td></tr></tbody></table><p>比较两个浮点数 n 和 y 的正确方法是取它们差值的绝对值|x-y|，再将其与用户定义的误差值 epsilon 进行比较。汇编语言代码如下，其中，epsilon 为两数差值允许的最大值，不 大于该值则认为这两个浮点数相等：</p><pre><code>.dataepsilon REAL8 1.0E-12val2 REAL8 0.0           ;比较的数值val3 REAL8 1.01E —13         ;认为等于^&amp;丄2.code;如果 (val2 == val3 )，显示"Values are equal".fid epsilonfid val2fsu val3fabsfcomi ST(0)ZST(1)ja skipmWrite &lt;"Values are equal",Odh,0ah&gt;skip:</code></pre><p>下表跟踪程序执行过程，显示了前四条指令执行后的堆栈情况。</p><table><thead><tr><th>指令</th><th>FPU堆栈</th><th>指令</th><th>FPU堆栈</th></tr></thead><tbody><tr><td>fid epsilon</td><td>ST(0): +1.0000000E-012</td><td></td><td>ST(1): +1.0000000E-012</td></tr><tr><td>fid val2</td><td>ST(0): +0.0000000E+000</td><td>fabs</td><td>ST(0): +1.0010000E-013</td></tr><tr><td></td><td>ST(1): +1.0000000E-012</td><td></td><td>ST(1): +1.0000000E-012</td></tr><tr><td>fsub val3</td><td>ST(0): -1.0010000E-013</td><td>fcomi ST(0), ST(1)</td><td>ST(0)&lt;ST(1), so CF=1, ZF=0</td></tr></tbody></table><p>如果将 val3 重新定义为大于 epsilon，它就不会等于 val2：</p><p>val3 REAL8 1.001E-12   ;不相等·</p><h2 id="汇编语言读写浮点数值"><a href="#汇编语言读写浮点数值" class="headerlink" title="汇编语言读写浮点数值"></a>汇编语言读写浮点数值</h2><p>链接库有两个浮点数输入输出过程，如下所示：</p><ul><li><p>ReadFloat：从键盘读取一个浮点数，并将其压入浮点堆栈。</p></li><li><p>WriteFloat：将 ST(0) 中的浮点数以阶码形式写到控制台窗口。</p></li></ul><p>ReadFloat 接收各种形式的浮点数，示例如下：</p><pre><code>35+35.-3.5.353.5E53.5E005-3.5E+53.5E-4+3.5E-4</code></pre><p>ShowFPUStack 另一个有用的过程，能够显示 FPU 堆栈。调用该过程不需要参数：</p><pre><code>call ShowFPUStack</code></pre><p>【示例】下面的示例程序把两个浮点数压入 FPU 堆栈并显示，再由用户输入两个数，将它们相乘并显示乘积：</p><pre><code>; 32位浮点数 I/O 测试      (floatTest32.asm)INCLUDE Irvine32.incINCLUDE macros.inc.datafirst  REAL8 123.456second REAL8 10.0third  REAL8 ?.codemain PROC    finit                    ; 初始化 FPU; 两个浮点数入栈，并显示 FPU 堆栈.    fld    first    fld    second    call    ShowFPUStack; 输入两个浮点数，并显示它们的乘机    mWrite "Please enter a real number: "    call    ReadFloat    mWrite "Please enter a real number: "    call    ReadFloat    fmul    ST(0),ST(1)            ; 相乘    mWrite "Their product is: "    call    WriteFloat    call    Crlf    exitmain ENDPEND main</code></pre><p>示例输入/输出（用户输入显示为粗体）如下：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627227126748363" alt="img"></p><h2 id="汇编语言FWAIT（WAIT）指令：异常同步"><a href="#汇编语言FWAIT（WAIT）指令：异常同步" class="headerlink" title="汇编语言FWAIT（WAIT）指令：异常同步"></a>汇编语言FWAIT（WAIT）指令：异常同步</h2><p>整数 (CPU) 和 FPU 是相互独立的单元，因此，在执行整数和系统指令的同时可以执行浮点指令。这个功能被称为并行性 (concurrency)，当发生未屏蔽的浮点异常时，它可能是个潜在的问题。反之，已屏蔽异常则不成问题，因为，FPU 总是可以完成当前操作并保存结果。</p><p>发生未屏蔽异常时，中断当前的浮点指令，FPU 发异常事件信号。当下一条浮点指令或 FWAIT(WAIT) 指令将要执行时，FPU 检查待处理的异常。如果发现有这样的异常，FPU 就调用浮点异常处理程序（子程序）。</p><p>如果引发异常的浮点指令后面跟的是整数或系统指令，情况又会是怎样的呢？很遗憾，指令不会检查待处理异常，它们会立即执行。假设第一条指令将其输出送入一个内存操作数，而第二条指令又要修改同一个内存操作数，那么异常处理程序就不能正确执行。示例如下：</p><pre><code>.dataintVal DWORD 25.codefild intVal ;将整数加载到 ST(0)inc intVal ;整数加 1</code></pre><p>设置 WAIT 和 FWAIT 指令是为了在执行下一条指令之前，强制处理器检查待处理且未屏蔽的浮点异常。这两条指令中的任一条都可以解决这种潜在的同步问题，直到异常处理程序结束，才执行 INC 指令。</p><pre><code>fild intVal ;将整数加载到 ST(0)fwait     ;等待待处理异常inc intVal ;整数加 1</code></pre><p>下面将用几个简短的例子来演示浮点算术运算指令。一个很好的学习方法是用 <a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a> 编写表达式，编译后，再检查由编译器生成的代码。</p><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p>现在编写代码，计算表达式 valD=-valA+(valB*valC)。下面给出一种可能的循序渐进的方法：将 valA 加载到堆栈，并取其负数；将 valB 加载到 ST(0)，则 valA 成为 ST(1)；将 ST(0) 和 valC 相乘，乘积保存在 ST(0) 中；将 ST(1) 与 ST(0) 相加，和数保存到 valD：</p><pre><code>.datavalA REAL8 1.5valB REAL8 2.5valC REAL8 3.0valD REAL8 ?; +6.0.codefld valA    ; ST(0) = valAfchs        ;修改 ST(0) 的符号fld valB    ; 将 valB 加载到 ST(0)fmul valC   ; ST(0) *= valCfadd        ; ST(0) += ST(1)fstp valD   ; 将 ST(0) 保存到 valD</code></pre><h4 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h4><p>下面的代码计算并显示一个双精度实数数组之和:</p><pre><code>ARRAY_SIZE = 20.datasngArray REAL8 ARRAY_SIZE DUP(?).code    mov    esi, 0            ;数组索引    fldz                     ; 0.0 入栈    mov ecx,ARRAY_SIZEL1: fld    sngArray[esi]     ;将内存操作数加载到ST(0)    fadd                     ; ST(0) 加 ST(1),出栈    add esi,TYPE REAL8       ;移至!I 下一个元素    loop L1    call WriteFloat          ;显示 ST(0) 中的和数</code></pre><h4 id="平方根之和"><a href="#平方根之和" class="headerlink" title="平方根之和"></a>平方根之和</h4><p>FSQRT 指令对 ST(0) 中的数值求平方根，并将结果送回 ST(0)。下面的代码计算了两个数的平方根之和：</p><pre><code>.datavalA REAL8 25.0valB REAL8 36.0.codefid valA        ; valA 入栈fsqrt           ; ST(0) = sqrt(valA)fid valB        ; valB 入栈fsqrt           ; ST(0) = sqrt(valB)fadd            ; ST (0)+ST(1)</code></pre><h4 id="数组点积"><a href="#数组点积" class="headerlink" title="数组点积"></a>数组点积</h4><p>下面的代码计算了表达式 (airay[0]<em>airay[l]) + (array[2]</em>array[3])。该计算有时也被称为点积 (dot product)。</p><pre><code>.dataarray REAL4 6.0, 2.0, 4.5, 3.2</code></pre><p>下表列出了每条指令执行后，FPU 堆栈的情况。输入数据如下：</p><table><thead><tr><th>指令</th><th>FPU堆栈</th><th>指令</th><th>FPU堆栈</th></tr></thead><tbody><tr><td>fld array</td><td>ST(0)：+6.0000000E+000</td><td>fmul [array+12]</td><td>ST(0)：+1.4400000E+001</td></tr><tr><td>fmul [array+4]</td><td>ST(0)：+1.2000000E+001</td><td></td><td>ST(1)：+1.2000000E+001</td></tr><tr><td>fld [array+8]</td><td>ST(0)：+4.5000000E+000</td><td>fadd</td><td>ST(0)：+2.6400000E+001</td></tr><tr><td></td><td>ST(1)：+1.2000000E+001</td><td></td><td></td></tr></tbody></table><h2 id="汇编语言混合模式运算简述"><a href="#汇编语言混合模式运算简述" class="headerlink" title="汇编语言混合模式运算简述"></a>汇编语言混合模式运算简述</h2><p>应用程序通常执行的是包含了整数与实数的混合模式运算。整数运算指令，如 ADD 和 MUL，不能操作实数，因此只能选择用浮点指令。Intel指令集提供指令将整数转换为实数，并将数值加载到浮点堆栈。</p><p>【示例 1】下面的 C++ 代码将一个整数与一个双精度数相加，并把和数保存为双精度数。C++ 在执行加法前，把整数自动转换为实数：</p><pre><code>int N = 20;double X = 3.5;double Z = N + X;</code></pre><p>与之等效的汇编代码如下：</p><pre><code>.dataN SDWORD 20X REAL8 3.5Z REAL8 ?.codefild n     ;整数加载到ST(0)fadd X      ;将内存操作数与ST(0)相加fstp z       ;将ST(0)保存到内存操作数</code></pre><p>【示例 2】下面的 C++ 程序把 N 转换为双精度数后，计算一个实数表达式，再将结果保存为整数变量：</p><pre><code>int N = 20;double X = 3.5;int Z = (int)(N + X);</code></pre><p>Visual C++ 生成的代码先调用转换函数 (ftol)，再把截断的结果保存到 Z。如果在表达式的汇编代码中使用 FIST，那么就可以避免函数调用，不过Z (默认) 会向上舍入为 24：</p><pre><code>fild N  ;整数加载到ST(0)fadd X ;将内存操作数与ST(0)相加fist Z  ;将ST(0)保存为整型内存操作数</code></pre><h4 id="修改舍入模式"><a href="#修改舍入模式" class="headerlink" title="修改舍入模式"></a>修改舍入模式</h4><p>FPU 控制字的 RC 字段指定使用的舍入类型。可以先用 FSTCW 把控制字保存为一个变量，再修改 RC 字段（位 10 和 11）,最后用 FLDCW 指令把这个变量加载回控制字：</p><pre><code>fstew ctrlWord             ;保存控制字or ctrlWord, 110000000000b ;设置眈=截断fldcw ctrlWord             ;加载控制字</code></pre><p>之后采用截断执行计算，生成结果为 Z=23：</p><pre><code>fild N  ;整数加载到ST(0)fadd X ;将内存整数与ST(0)相加fist Z   ;将ST(0)保存为整型内存操作数</code></pre><p>或者，把舍入模式重新设置为默认选项（舍入到最接近的偶数）：</p><pre><code>fstcw ctrlWord               ;保存控制字and ctrlWord, 001111111111b   ;重置舍入模式为默认fldcw ctrlWord               ;加载控制字 </code></pre><h2 id="汇编语言异常的屏蔽与未屏蔽简述"><a href="#汇编语言异常的屏蔽与未屏蔽简述" class="headerlink" title="汇编语言异常的屏蔽与未屏蔽简述"></a>汇编语言异常的屏蔽与未屏蔽简述</h2><p>默认情况下，异常是被屏蔽的，因此，当出现浮点异常时，处理器分配一个默认值为结果，并继续平稳地工作。例如，一个浮点数除以 0 生成结果为无穷，但不会中断程序：</p><pre><code>.dataval1 DWORD 1val2 REAL8 0.0.codefild val1    ;整数加载到ST(0)fdiv val2      ;ST(0) =正无穷</code></pre><p>如果 FPU 控制字没有屏蔽异常，那么处理器就会试着执行合适的异常处理程序。清除 FPU 控制字中的相应位就可以实现异常的未屏蔽操作，如下表所示。</p><table><thead><tr><th>位</th><th>说明</th><th>位</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>无效操作异常屏蔽位</td><td>5</td><td>精度异常屏蔽位</td></tr><tr><td>1</td><td>非规格化操作数异常屏蔽位</td><td>8〜9</td><td>精度控制位</td></tr><tr><td>2</td><td>除零异常屏蔽位</td><td>10〜11</td><td>舍入控制位</td></tr><tr><td>3</td><td>上溢异常屏蔽位</td><td>12</td><td>无穷控制位</td></tr><tr><td>4</td><td>下溢异常屏蔽位</td><td></td><td></td></tr></tbody></table><p>假设不想屏蔽除零异常， 则需要如下步骤：</p><p>\1) 将 FPU 控制字保存到 16 位变量。</p><p>\2) 清除位 2（除零标志位）。</p><p>\3) 将变量加载回控制字。</p><p>下面的代码实现了浮点异常的未屏蔽操作：</p><pre><code>.datactrlWord WORD ?.codefstcw ctrlWord                   ;获取控制字and ctrlWord, 1111111111111011b   ;不屏蔽除零异常fldcw ctrlWord                   ;结果加载回 FPU</code></pre><p>现在，如果执行除零代码，那么就会产生一个未屏蔽异常：</p><pre><code>fild val1fdiv val2 ;除零fst val2</code></pre><p>只要 FST 指令开始执行，MS-Windows 就会显示错误信息。</p><h4 id="屏蔽异常"><a href="#屏蔽异常" class="headerlink" title="屏蔽异常"></a>屏蔽异常</h4><p>要屏蔽一个异常，就把 FPU 控制字中的相应位置 1。下面的代码屏蔽了除零异常：</p><pre><code>.datactrlWord WORD ?.codefstcw ctrlWord    ;获取控制字or ctrlWord, 100b ;屏蔽除零异常fldcw ctrlWord    ;结果力口载回 FPU</code></pre><h2 id="汇编语言x86指令编码简述"><a href="#汇编语言x86指令编码简述" class="headerlink" title="汇编语言x86指令编码简述"></a>汇编语言x86指令编码简述</h2><p>若要完全理解汇编语言操作码和操作数，就需要花些时间了解汇编指令翻译成机器语言的方法。由于 Intel 指令集使用了丰富多样的指令和寻址模式，因此这个问题相当复杂。</p><p>Intel 8086 处理器是第一个使用复杂指令集计算机（Complex Instruction Set Computer, CISC）设计的处理器。这种指令集中包含了各种各样的内存寻址、移位、算术运算、数据传送和逻辑操作</p><p>与 RISC（精简指令集计算机，Reduced Instruction Set Computer）指令相比，Intel 指令在编码和解码方面有些复杂。</p><p>指令编码（encode）是指将汇编语言指令及其操作数转换为机器码。指令解码（decode）是指将机器指令转换为汇编语言。对 Intel 指令编码和解码的逐步解释至少将有助于唤起对 MASM 作者们辛苦工作的理解和欣赏。</p><h4 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h4><p>一般的 x86 机器指令格式，如下图所示。包含了一个指令前缀字节、操作码、Mod R/M 字节、伸缩索引字节（SIB）、地址位移和立即数。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627227154519365" alt="img"></p><p>指令按小端顺序存放，因此前缀字节位于指令的起始地址。每条指令都有一个操作码，而其他字段则是可选的。少数指令包含了全部字段，平均来看，绝大多数指令都有 2 个或 3 个字节。</p><p>下面是对指令字段的简介：</p><p>\1) 指令前缀覆盖默认操作数大小。</p><p>\2) 操作码（操作代码）指定指令的特定变体。比如，按照使用的参数类型，指令 ADD 有 9 种不同的操作码。</p><p>\3) Mod R/M 字段指定寻址模式和操作数。符号 “R/M” 代表的是寄存器和模式。下表列出了 Mod 字段。</p><table><thead><tr><th>Mod</th><th>位移</th></tr></thead><tbody><tr><td>0</td><td>DISP=0，位移低半部分和高半部分都无定义（除非r/m = 110）</td></tr><tr><td>1</td><td>DISP= 位移低半部分符号扩展到 16 位，位移高半部分无定义</td></tr><tr><td>10</td><td>DISP= 位移高半部分和低半部分都有效</td></tr><tr><td>11</td><td>R/M 字段包含的是寄存器编号</td></tr></tbody></table><p>下表给出了当 Mod=10b 时 16 位应用程序的 R/M 字段。</p><table><thead><tr><th>R/M</th><th>有效地址</th><th>R/M</th><th>有效地址</th></tr></thead><tbody><tr><td>0</td><td>[BX+SIJ+D16</td><td>100</td><td>[SI]+D16</td></tr><tr><td>1</td><td>[BX+DI]+D16</td><td>101</td><td>[DI]+D16</td></tr><tr><td>10</td><td>[BP+SI]+D16</td><td>110</td><td>[BP]+D16</td></tr><tr><td>11</td><td>[BP+DIJ+D16</td><td>111</td><td>[BX]+D16</td></tr></tbody></table><p>\4) 伸缩索引字节（scale index byte, SIB）用于计算数组索引偏移量。</p><p>\5) 地址位移字段保存了操作数的偏移量，在基址-偏移量或基址-变址-偏移量寻址模式中，该字段还可以与基址或变址寄存器相加。</p><p>\6) 立即数字段保存了常量操作数。</p><h2 id="汇编语言单字节指令与立即操作数简述"><a href="#汇编语言单字节指令与立即操作数简述" class="headerlink" title="汇编语言单字节指令与立即操作数简述"></a>汇编语言单字节指令与立即操作数简述</h2><p>没有操作数或只有一个隐含操作数的指令是最简单的指令。这种指令只需要操作码字段，字段值由处理器的指令集预先确定。下表列出了几个常见的单字节指令。</p><table><thead><tr><th>指令</th><th>操作码</th><th>指令</th><th>操作码</th></tr></thead><tbody><tr><td>AAA</td><td>37</td><td>LODSB</td><td>AC</td></tr><tr><td>AAS</td><td>3F</td><td>XLAT</td><td>D7</td></tr><tr><td>CBW</td><td>98</td><td>INC DX</td><td>42</td></tr></tbody></table><p>在这些指令中，INC DX 指令好像是不应该岀现的，它出现的原因是：指令集的设计者决定为某些常用指令提供独特的操作码。其结果是，为了代码量和执行速度要对寄存器增量操作进行优化。</p><h4 id="立即数送寄存器"><a href="#立即数送寄存器" class="headerlink" title="立即数送寄存器"></a>立即数送寄存器</h4><p>立即操作数（常数）按照小端顺序（起始地址为最低字节）添加到指令。首先关注的是立即数送寄存器指令，暂不考虑内存寻址的复杂性。将一个立即字送寄存器的 MOV 指令的编码格式为：B8+rw dw，其中操作码字节的值为 B8+rw，表示将一个寄存器编号（0〜7）与 B8 相加；dw 为立即字操作数，低字节在低地址。</p><p>下表列出了操作码使用的寄存器编号。</p><table><thead><tr><th>寄存器</th><th>编号</th><th>寄存器</th><th>编号</th></tr></thead><tbody><tr><td>AX/A1</td><td>0</td><td>SP/AH</td><td>4</td></tr><tr><td>CX/CL</td><td>1</td><td>BP/CH</td><td>5</td></tr><tr><td>DX/DL</td><td>2</td><td>SI/DH</td><td>6</td></tr><tr><td>BX/BL</td><td>3</td><td>DI/BH</td><td>7</td></tr></tbody></table><p>下面例子中出现的所有数值都为十六进制。</p><p>【示例 1】PUSH CX 机器指令为 51。编码步骤如下：</p><p>\1) 带一个 16 位寄存器操作数的 PUSH 指令编码为 50。</p><p>\2) CX的寄存器编码为1,因此1+50得到操作码为51。</p><p>【示例 2】MOV AX, 1 机器指令为 B8 01 00（十六进制）。编码过程如下：</p><p>\1) 立即数送 16 位寄存器的操作码为 B8</p><p>\2) AX 的寄存器编号为 0，将 0 加上 B8（参见上表所示）。</p><p>\3) 立即操作数（0001）按小端顺序添加到指令（01, 00 ）。</p><p>【示例 3】MOV BX, 1234h 机器指令为 BB 34 12。编码过程如下：</p><p>\1) 立即数送 16 位寄存器的操作码为 B8。</p><p>\2) BX 的寄存器编号为 3，将 3 加上 B8 得到操作码 BB。</p><p>\3) 立即操作数字节为 34 12。</p><p>从实践的角度出发，建议手动汇编一些 MOV 立即数指令来提高能力，然后通过 MASM 的源列表文件中的生成代码来检查汇编结果。</p><h2 id="汇编语言寄存器模式指令简述"><a href="#汇编语言寄存器模式指令简述" class="headerlink" title="汇编语言寄存器模式指令简述"></a>汇编语言寄存器模式指令简述</h2><p>在使用寄存器操作数的指令中，ModR/M 字节用一个 3 位的标识符来表示寄存器操作数。下表列岀了寄存器的位编码。操作码字段的位 0 用于选择 8 位或 16 位寄存器：1 表示 16 位寄存器，0 表示 8 位寄存器。</p><table><thead><tr><th>R/M</th><th>寄存器</th><th>R/M</th><th>寄存器</th></tr></thead><tbody><tr><td>0</td><td>AX or AL</td><td>100</td><td>SP or AH</td></tr><tr><td>1</td><td>CX or CL</td><td>101</td><td>BP or CH</td></tr><tr><td>10</td><td>DX or DL</td><td>110</td><td>SI or DH</td></tr><tr><td>11</td><td>BX or BL</td><td>111</td><td>DI or BH</td></tr></tbody></table><p>比如，MOV AX, BX 的机器码为 89 D8。寄存器送其他操作数的 16 位 MOV 指令的 Intel 编码为 89/r，其中 /r 表示操作码后面带一个 Mod R/M 字节。</p><p>Mod R/M 字节有三个字段（mod. reg 和 r/m）。例如，若 Mod R/M 的值为 D8，则它包含如下字段</p><table><thead><tr><th>mod</th><th>reg</th><th>r/m</th></tr></thead><tbody><tr><td>11</td><td>11</td><td>0</td></tr></tbody></table><ul><li><p>位 6〜7 是 mod 字段，指定寻址模式。mod 字段为 11 表示 r/m 字段包含的是一个寄存器编号。</p></li><li><p>位 3〜5 是 eg 字段，指定源操作数。在本例中，BX 就是编号为 011 的寄存器。</p></li><li><p>位 0〜2 是 r/m 字段，指定目的操作数。本例中，AX 是编号为 000 的寄存器。</p></li></ul><p>下表列出了更多使用 8 位和 16 位寄存器操作数的例子。</p><table><thead><tr><th>指令</th><th>操作码</th><th>mod</th><th>reg</th><th>r/m</th></tr></thead><tbody><tr><td>mov ax, dx</td><td>8B</td><td>11</td><td>0</td><td>10</td></tr><tr><td>mov al, dl</td><td>8A</td><td>11</td><td>0</td><td>10</td></tr><tr><td>mov ex, dx</td><td>8B</td><td>11</td><td>1</td><td>10</td></tr><tr><td>mov cl, dl</td><td>8A</td><td>11</td><td>1</td><td>10</td></tr></tbody></table><h2 id="汇编语言处理器操作数大小前缀作用及意义"><a href="#汇编语言处理器操作数大小前缀作用及意义" class="headerlink" title="汇编语言处理器操作数大小前缀作用及意义"></a>汇编语言处理器操作数大小前缀作用及意义</h2><p>现在将注意力转回到 x86 处理器（IA-32）的指令编码。有些指令以操作数大小前缀开始，覆盖了其修改指令的默认段属性。问题是，为什么有指令前缀？在编写 8088/8086 指令集时，几乎所有 256 个可能的操作码都用于处理带有 8 位和 16 位操作数的指令。</p><p>当 Intel 开发 32 位处理器时，就需要想办法发明新的操作码来处理 32 位操作数，而同时还要保持与之前处理器的兼容性。对于面向 16 位处理器的程序，所有使用 32 位操作数的指令都添加一个前缀字节。</p><p>对于面向 32 位处理器的程序，默认为 32 位操作数，因此所有使用 16 位操作数的指令添加一个前缀字节。8 位操作数不需要前缀。</p><p>【示例】16 位操作数，现在对 MOV 指令进行汇编，以此为例来看看在 16 位模式下前缀字节是如何起作用的。.286 伪指令指明编译代码的目标处理器，确保不使用 32 位寄存器。下面的每条 MOV 指令都给岀了其指令编码：</p><pre><code>.model small.286.stack 100h.codemain PROC    mov ax, dx    ; 8B C2    mov al, dl    ; 8A C2</code></pre><p>现在对 32 位处理器汇编相同的指令，使用 .386 伪指令，默认操作数为 32 位。指令将包括 16 位和 32 位操作数。第一条 MOV 指令（EAX、EDX）使用的是 32 位操作数，因此不需要前缀。第二条 MOV（AX、DX）指令由于使用的是 16 位操作数，因此需要操作数大小前缀（66）：</p><pre><code>.model small.386.stack 100h.codemain PROC    mov    eax,edx ; 8B C2    mov    ax,dx   ; 66 8B C2    mov    al,dl   ; 8A C2</code></pre><h2 id="汇编语言内存模式指令简述"><a href="#汇编语言内存模式指令简述" class="headerlink" title="汇编语言内存模式指令简述"></a>汇编语言内存模式指令简述</h2><p>如果 Mod R/M 字节只用于标识寄存器操作数，那么 Intel 指令编码就会相对简单。实际上，Intel 汇编语言有着各种各样的内存寻址模式，这就使得 Mod R/M 字节编码相当复杂。（指令集的复杂性是 RISC 设计支持者常见的批评理由。）</p><p>Mod R/M 字节正好可以指定 256 个不同组合的操作数。下表列岀了 Mod 00 时的 Mod R/M 字节（十六进制）。</p><table><thead><tr><th>字节</th><th>AL</th><th>CL</th><th>DL</th><th>BL</th><th>AH</th><th>CH</th><th>DH</th><th>BH</th><th></th><th></th></tr></thead><tbody><tr><td>字</td><td>AX</td><td>CX</td><td>DX</td><td>BX</td><td>SP</td><td>BP</td><td>SI</td><td>DI</td><td></td><td></td></tr><tr><td>寄存器ID</td><td>0</td><td>1</td><td>10</td><td>11</td><td>100</td><td>101</td><td>110</td><td>111</td><td></td><td></td></tr><tr><td>Mod</td><td>R/M</td><td>Mod R/M 值</td><td>有效地址</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td>0</td><td>0</td><td>8</td><td>10</td><td>18</td><td>20</td><td>28</td><td>30</td><td>38</td><td>[BX+SI]</td></tr><tr><td></td><td>1</td><td>1</td><td>9</td><td>11</td><td>19</td><td>21</td><td>29</td><td>31</td><td>39</td><td>[BX+DI]</td></tr><tr><td></td><td>10</td><td>2</td><td>0A</td><td>12</td><td>1A</td><td>22</td><td>2A</td><td>32</td><td>3A</td><td>[BP+SI]</td></tr><tr><td></td><td>11</td><td>3</td><td>0B</td><td>13</td><td>1B</td><td>23</td><td>2B</td><td>33</td><td>3B</td><td>[BP+DI]</td></tr><tr><td></td><td>100</td><td>4</td><td>0C</td><td>14</td><td>1C</td><td>24</td><td>2C</td><td>34</td><td>3C</td><td>[SI]</td></tr><tr><td></td><td>101</td><td>5</td><td>0D</td><td>15</td><td>1D</td><td>25</td><td>2D</td><td>35</td><td>3D</td><td>[DI]</td></tr><tr><td></td><td>110</td><td>6</td><td>0E</td><td>16</td><td>1E</td><td>26</td><td>2E</td><td>36</td><td>3E</td><td>16 位偏移量</td></tr><tr><td></td><td>111</td><td>7</td><td>0F</td><td>17</td><td>1F</td><td>27</td><td>2F</td><td>37</td><td>3F</td><td>[BX]</td></tr></tbody></table><p>Mod R/M 字节编码的作用如下：Mod 列中的两位指定寻址模式的集合。比如，Mod 00 有 8 种可能的 R/M 数值（000b〜111b），有效地址列给岀了这些数值标识的操作数类型。</p><p>假设想要编码 MOV AX, [Si], Mod 位为 00b, R/M 位为 100b。从《x86指令编码》一节中的 16 位 RM 表中可知 AX 的寄存器编号为 000b，因此完整的 Mod R/M 字节为 00 000 100b 或 04h：</p><table><thead><tr><th>mod</th><th>reg</th><th>r/m</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>100</td></tr></tbody></table><p>十六进制字节 04 在上表（Mod R/M）的 AX 列第 5 行。</p><p>MOV [SI], AL 的 Mod R/M 字节还是一样的（04h），因为寄存器 AL 的编号也是 000。现在对指令 MOV [SI], AL 进行编码。8 位寄存器的传送操作码为 88。Mod R/M 字节为 04h，则机器码为 88 04。</p><h4 id="MOV-指令示例"><a href="#MOV-指令示例" class="headerlink" title="MOV 指令示例"></a>MOV 指令示例</h4><p>下表列出了 8 位和 16 位 MOV 指令所有的指令格式和操作码。</p><table><thead><tr><th>操作码</th><th>指令</th><th>说明</th><th>操作码</th><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>88/r</td><td>MOV eb, rb</td><td>字节寄存器送 EA 字节操作数</td><td>8E/2</td><td>MOV SS, rw</td><td>字寄存器送 SS</td></tr><tr><td>89/r</td><td>MOV ew, rw</td><td>字寄存器送 EA 字操作数</td><td>8E/3</td><td>MOV DS, mw</td><td>内存字送 DS</td></tr><tr><td>8A/r</td><td>MOV rb, eb</td><td>EA 字节操作数送字节寄存器</td><td>8E/3</td><td>MOV DS, rw</td><td>字寄存器送 DS</td></tr><tr><td>8B/r</td><td>MOV rw, ew</td><td>EA 字操作数送字寄存器</td><td>A0 dw</td><td>MOV AL, xb</td><td>字节变量（偏移量为 dw）送 AL</td></tr><tr><td>8C/0</td><td>MOV ew, ES</td><td>ES 送 EA 字操作数</td><td>A1 dw</td><td>MOV AX, xw</td><td>字变量（偏移量为 dw）送 AX</td></tr><tr><td>8C/1</td><td>MOV ew, CS</td><td>CS 送 EA 字操作数</td><td>A2 dw</td><td>MOV xb, AL</td><td>AL 送字节变量（偏移量为 dw）</td></tr><tr><td>8C/2</td><td>MOV ew, SS</td><td>SS 送 EA 字操作数</td><td>A3 dw</td><td>MOV xw, AX</td><td>AX 送字寄存器（偏移量为 dw）</td></tr><tr><td>8C/3</td><td>MOV ew, DS</td><td>DS 送 EA 字操作数</td><td>B0+rb db</td><td>MOV rb, db</td><td>字节立即数送字节寄存器</td></tr><tr><td>8E/0</td><td>MOV ES, mw</td><td>内存字送 ES</td><td>B8+rw dw</td><td>MOV rw, dw</td><td>字立即数送字寄存器</td></tr><tr><td>8E/0</td><td>MOV ES, rw</td><td>字寄存器送 ES</td><td>C6 /0 db</td><td>MOV eb, db</td><td>字节立即数送 EA 字节操作数</td></tr><tr><td>8E/2</td><td>MOV SS, mw</td><td>内存字送 SS</td><td>C7 /0 dw</td><td>MOV ew, dw</td><td>字立即数送 EA 字操作数</td></tr></tbody></table><p>下面两表给出了上表中缩写符号的补充信息。手动汇编 MOV 指令时可以用这些表作为参考。</p><table><thead><tr><th>/n:</th><th>操作码后面跟一个 Mod R/M 字节，该字节后面可能再跟立即数和偏移量字段。数字 n（ 0〜7 ）为 Mod R/ M 字节中 reg 字段的值</th></tr></thead><tbody><tr><td>/r:</td><td>操作码后面跟一个 Mod R/M 字节，该字节后面可能再跟立即数和偏移量字段</td></tr><tr><td>db:</td><td>操作码和 Mod R/M 字节后面跟一个字节立即操作数</td></tr><tr><td>dw:</td><td>操作码和 Mod R/M 字节后面跟一个字立即操作数</td></tr><tr><td>+rb:</td><td>8 位寄存器的编号（0〜7 ），与前面的十六进制字节一起构成 8 位操作码</td></tr><tr><td>+rw:</td><td>16 位寄存器的编号（0〜7 ），与前面的十六进制字节一起构成 8 位操作码</td></tr></tbody></table><table><thead><tr><th>db</th><th>-128〜+127 之间的有符号数。若操作数为字类型，则该数值进行符号扩展</th></tr></thead><tbody><tr><td>dw</td><td>指令操作数为字类型的立即数</td></tr><tr><td>eb</td><td>字节类型操作数，可以是寄存器也可以是内存操作数</td></tr><tr><td>ew</td><td>字类型操作数，可以是寄存器也可以是内存操作数</td></tr><tr><td>rb</td><td>用数值（0〜7 ）标识的 8 位寄存器</td></tr><tr><td>rw</td><td>用数值（0〜7 ）标识的 16 位寄存器</td></tr><tr><td>xb</td><td>无基址或变址寄存器的简单字节内存变量</td></tr><tr><td>xw</td><td>无基址或变址寄存器的简单字内存变量</td></tr></tbody></table><p>下表列出了更多的 MOV 指令，这些指令能手动汇编，且可以与表中的机器代码比较。假设 myWord 的起始地址偏移量为 0102h。</p><table><thead><tr><th>指令</th><th>机器码</th><th>寻址模式</th></tr></thead><tbody><tr><td>mov ax, my Word</td><td>A1 02 01</td><td>直接（为 AX 优化）</td></tr><tr><td>mov my Word,bx</td><td>89 IE 02 01</td><td>直接</td></tr><tr><td>mov[di],bx</td><td>89 ID</td><td>变址</td></tr><tr><td>mov[bx+2],ax</td><td>89 47 02</td><td>基址 - 偏移量</td></tr><tr><td>mov[bx+si],ax</td><td>89 00</td><td>基址 - 变址</td></tr><tr><td>mov word prt [bx+di+2], 1234h</td><td>C7 41 02 34 12</td><td>基址 - 变址 - 偏移量</td></tr></tbody></table><h1 id="高级语言接口"><a href="#高级语言接口" class="headerlink" title="高级语言接口"></a>高级语言接口</h1><h2 id="高级语言调用汇编语言的接口规范"><a href="#高级语言调用汇编语言的接口规范" class="headerlink" title="高级语言调用汇编语言的接口规范"></a>高级语言调用汇编语言的接口规范</h2><p>从高级语言中调用汇编过程时，需要解决一些常见的问题。</p><p>首先，一种语言使用的命名规范（naming convention）是指与变量和过程命名相关的规则和特性。比如，一个需要回答的重要问题是：汇编器或编译器会修改目标文件中的标识符名称吗？如果是，如何修改？</p><p>其次，段名称必须与高级语言使用的名称兼容。</p><p>第三，程序使用的内存模式（微模式、小描述、紧凑模式、中模式、大模式、巨模式，或平坦模式）决定了段大小（16 或 32 位），以及调用或引用是近（同一段内）还是远（不同段之间）。</p><h4 id="调用规范"><a href="#调用规范" class="headerlink" title="调用规范"></a>调用规范</h4><p>调用规范（calling convention）是指调用过程的底层细节。下面列出了需要考虑的细节信息：</p><ul><li><p>调用过程需要保存哪些寄存器</p></li><li><p>传递参数的方法：用寄存器、用堆栈、共享内存，或者其他方法</p></li><li><p>主调程序调用过程时，参数传递的顺序</p></li><li><p>参数传递方法是传值还是传引用</p></li><li><p>过程调用后，如何恢复堆栈指针</p></li><li><p>函数如何向主调程序返回结果</p></li></ul><h4 id="命名规范与外部标识符"><a href="#命名规范与外部标识符" class="headerlink" title="命名规范与外部标识符"></a>命名规范与外部标识符</h4><p>当从其他语言程序中调用汇编过程时，外部标识符必须与命名规范（命名规则）兼容。外部标识符（external identifier）是放在模块目标文件中的名称，链接器使得这些名称能够被其他程序模块使用。链接器解析对外部标识符的引用，但是仅适用于命名规范一致的情况。</p><p>例如，假设 C 程序 Main.c 调用外部过程 ArraySum。如下图所示，C 编译器自动保留大小写，并为外部名称添加前导下划线，将其修改为 _ArraySum：</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627227271257367" alt="img"></p><p>Array.asm 模块用汇编语言编写，由于其 .MODEL 伪指令使用的选项为 Pascal 语言，因此输出 ArraySum 过程的名称就是 ARRAYSUM。由于两个输出的名称不同，因此链接器无法生成可执行程序。</p><p>早期编程语言，如 COBOL 和 PASCAL，其编译器一般将标识符全部转换为大写字母。近期的语言，如 C、C++ 和 Java 则保留了标识符的大小写。</p><p>此外，支持函数重载的语言（如 C++）还使用名称修饰 (name decoration) 的技术为函数名添加更多字符。比如，若函数名为 MySub (int n, double b)，则其输出可能为 MySub#int#double。</p><p>在汇编语言模块中，通过 .MODEL 伪指令选择语言说明符来控制大小写。</p><h4 id="段名称"><a href="#段名称" class="headerlink" title="段名称"></a>段名称</h4><p>汇编语言过程与高级语言程序链接时，段名称必须是兼容的。本章使用 Microsoft 简化段伪指令 .CODE、.STACK 和 .DATA，它们与 Microsoft C++ 编译器生成的段名称兼容。</p><h4 id="内存模式"><a href="#内存模式" class="headerlink" title="内存模式"></a>内存模式</h4><p>主调程序与被调过程使用的内存模式必须相同。比如，实地址模式下可选择小模式、中模式、紧凑模式、大模式和巨模式。保护模式下必须使用平坦模式。</p><h2 id="汇编语言-MODEL伪指令：确定程序的特性"><a href="#汇编语言-MODEL伪指令：确定程序的特性" class="headerlink" title="汇编语言.MODEL伪指令：确定程序的特性"></a>汇编语言.MODEL伪指令：确定程序的特性</h2><p>16 位和 32 位模式中，MASM 使用 .MODEL 伪指令确定若干重要的程序特性：内存模式类型、过程命名模式以及参数传递规则。若汇编代码被其他编程语言程序调用，那么后两者就尤其重要。</p><p>.MODEL 伪指令的语法如下：</p><pre><code>.MODEL memorymodel [,modeloptions]</code></pre><h4 id="MemoryModel"><a href="#MemoryModel" class="headerlink" title="MemoryModel"></a>MemoryModel</h4><p>下表列出了 memorymodel 字段可选择的模式。除了平坦模式之外，其他所有模式都可以用于 16 位实地址编程。</p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>微模式</td><td>一个既包含代码又包含数据的段。文件扩展名为 .com 的程序使用该模式</td></tr><tr><td>小模式</td><td>一个代码段和一个数据段。默认情况下，所有代码和数据都为近属性</td></tr><tr><td>中模式</td><td>多个代码段，一个数据段</td></tr><tr><td>紧凑模式</td><td>一个代码段，多个数据段</td></tr><tr><td>大模式</td><td>多个代码段和数据段</td></tr><tr><td>巨模式</td><td>与大模式相同，但是各个数据项可以大于单个段</td></tr><tr><td>平坦模式</td><td>保护模式。代码与数据使用 32 位偏移量。所有的数据和代码（包括系统资源）都在一个 32 位段内</td></tr></tbody></table><p>32 位程序使用平坦内存模式，其偏移量为 32 位，代码和数据最大可达 4GB。比如，Irvine32.inc 文件包含了如下 .MODEL 伪指令：</p><pre><code>.model flat, STDCALL</code></pre><h4 id="ModelOptions"><a href="#ModelOptions" class="headerlink" title="ModelOptions"></a>ModelOptions</h4><p>.MODEL 伪指令中的 ModelOptions 字段可以包含一个语言说明符和一个栈距离。语言说明符指定过程与公共符号的调用和命名规范。栈距离可以是 NEARSTACK（默认值）或者 FARSTACK。</p><h4 id="1-语言说明符"><a href="#1-语言说明符" class="headerlink" title="1) 语言说明符"></a>1) 语言说明符</h4><p>伪指令 .MODEL 有几种不同的可选语言说明符，其中的一些很少使用（比如 BASIC、FORTRAN 和 PASCAL）。反之，C 和 STDCALL 则十分常见。结合平坦内存模式，示例如下：</p><pre><code>.model flat, C.model flat, STDCALL</code></pre><p>语言说明符 STDCALL 用于 Windows 系统函数调用。本章在链接汇编代码和 C 与 C++ 程序时，使用 C 语言说明符。</p><h4 id="2-STDCALL"><a href="#2-STDCALL" class="headerlink" title="2) STDCALL"></a>2) STDCALL</h4><p>STDCALL 语言说明符将子程序参数按逆序（从后往前）压入堆栈。为了便于说明，首先用高级语言编写如下函数调用：</p><pre><code>AddTwo(5, 6);</code></pre><p>若 STDCALL 被选为语言说明符，则等效的汇编语言代码如下：</p><pre><code>push 6push 5call AddTwo</code></pre><p>另一个重要的考虑是，过程调用后如何从堆栈中移除参数。STDCALL 要求在 RET 指令中带一个常量操作数。返回地址从堆栈中弹出后，该常数为 RET 执行与 ESP 相加的数值：</p><pre><code>AddTwo PROC  push ebp  mov ebp,esp  mov eax, [ebp + 12]   ;第二个参数  add eax, [ebp + 8]    ;第一个参数  pod ebpret 8                 ;清除堆栈AddTwo ENDPP</code></pre><p>堆栈指针加上 8 后，就指回了主调程序参数入栈之前指针的位置。</p><p>最后，STDCALL 通过将输出（公共）过程名保存为如下格式来修改这些名称：</p><pre><code>_name@nn</code></pre><p>前导下划线添加到过程名，@ 符号后面的整数指定了过程参数的字节数（向上舍入到 4 的倍数）。例如，假设过程 AddTwo 带有两个双字参数，那么汇编器传递给链接器的名称就为 _AddTwo@8。</p><p>Microsoft 链接器是区分大小写的，因此 _MYSUB@8 和 _MySub@8 是两个不同的名称。要查看 OBJ 文件中所有的过程名，使用 Visual Studio 中的 DUMPBIN 工具，选项为 /SYMBOLS。</p><h4 id="3-C-说明符"><a href="#3-C-说明符" class="headerlink" title="3) C 说明符"></a>3) C 说明符</h4><p>和 STDCALL 一样，C 语言说明符也要求将过程参数按从后往前的顺序压入堆栈。对于过程调用后从堆栈中移除参数的问题，C 语言说明符将这个责任留给了主调方。在主调程序中，ESP 与一个常数相加，将其再次设置为参数入栈之前的位置：</p><pre><code>push 6      ;第二个参数push 5      ;第一个参数call AddTwoadd esp,8      ;清除堆栈</code></pre><p>C 语言说明符在外部过程名的前面添加前导下划线。示例如下:</p><pre><code>_AddTwo</code></pre><h2 id="查看C语言-C-编译器生成的汇编语言代码"><a href="#查看C语言-C-编译器生成的汇编语言代码" class="headerlink" title="查看C语言/C++编译器生成的汇编语言代码"></a>查看C语言/C++编译器生成的汇编语言代码</h2><p>长久以来，C 和 C++ 编译器都会生成汇编语言源代码，但是程序员通常看不到。这是因为，汇编语言代码只是产生可执行文件过程的一个中间步骤。幸运的是，大多数编译器都可以应要求生成汇编语言源代码文件。 例如，下表列出了 Visual Studio 控制汇编源代码输出的命令行选项。</p><table><thead><tr><th>命令行</th><th>列表文件内容</th></tr></thead><tbody><tr><td>/FA</td><td>仅汇编文件</td></tr><tr><td>/FAc</td><td>汇编文件与机器码</td></tr><tr><td>/FAs</td><td>汇编文件与源代码</td></tr><tr><td>/FAcs</td><td>汇编文件、机器码和源代码</td></tr></tbody></table><p>检查编译器生成的代码文件有助于理解底层信息，比如堆栈帧结构、循环和逻辑编码，并且还有可能找到低级编程错误。另一个好处是更加便于发现不同编译器生成代码的差异。</p><p>现在来看看 C++ 编译器生成优化代码的一种方法。由于是第一个例子，因此先编写一个简单的 C 方法 Array Sum，并在 Visual Studio 2012 中进行编译，其设置如下：</p><ul><li><p>Optimization=Disabled ( 使用调试器时需要 )</p></li><li><p>Favor Size or Speed=Favor fast code</p></li><li><p>Assembler Output=Assembly With Source Code</p></li></ul><p>下面是用 ANSI C 编写的 arraysum 源代码：</p><pre><code>int arraySum( int array[], int count ){    int i;    int sum = 0;    for(i = 0; i &lt; count; i++)        sum += array[i];    return sum;}</code></pre><p>现在来查看由编译器生成的 arraysum 的汇编代码，如下所示。</p><pre><code>_sum$ = -8        ; size = 4_i$ = -4          ; size = 4_array$ = 8       ; size = 4_count$ = 12      ; size = 4_arraySum PROC    ; COMDAT;4    : {    push ebp    mov    ebp, esp    sub    esp, 72    ; 00000048H    push ebx    push esi    push edi;5    : int i;;6    : int sum = 0;    mov DWORD PTR _sum$[ebp], 0;7    :;8    : for(i =    0; i &lt; count; i++)    mov DWORD PTR _i$[ebp], 0    jmp SHORT $LN3@arraySum$LN2@arraySum:    mov eax, DWORD PTR _i$[ebp]    add eax, 1    mov DWORD PTR _i$[ebp], eax$LN3@arraySum:    mov eax, DWORD PTR _i$[ebp]    cmp eax, DWORD PTR _count$[ebp]    jge SHORT $LN1@arraySum;9    : sum += array[i];    mov eax, DWORD PTR _i$[ebp]    mov ecx, DWORD PTR _array$[ebp]    mov edx, DWORDPTR _sum$[ebp]    add edx, DWORD PTR [ecx+eax*4]    mov DWORD PTR _sum$[ebp], edx    jmp SHORT $LN2@arraySum$LNl@arraySum:;10    :;11    : return sum;    mov eax, DWORD PTR _sum$[ebp];12    : }    pop edi    pop esi    pop ebx    mov esp, ebp    pop ebp    ret 0_arraySum ENDP</code></pre><p>1〜4 行定义了两个局部变量 (sum 和 i) 的负数偏移量，以及输入参数 array 和 count 的正数偏移量：</p><pre><code>_sum$ = -8       ; size = 4_i$ = -4       ; size = 4_array$ = 8    ; size = 4_count$ = 12   ; size = 4</code></pre><p>9〜10 行设置 ESP 为帧指针：</p><pre><code>push ebpmov ebp,esp</code></pre><p>之后，11〜14 行从 ESP 中减去 72，为局部变量预留堆栈空间。同时，把将会被函数修改的三个寄存器保存到堆栈。</p><pre><code>sub esp, 72push ebxpush esipush edi</code></pre><p>19 行把局部变量 sum 定位到堆栈帧，并将其初始化为 0。由于符号 _sum$ 定义为数值 -8，因此它就位于当前 EBP 下面 8 个字节的位置：</p><pre><code>mov DWORD PTR _sum$[ebp],0</code></pre><p>24 和 25 行将变量 i 初始化为 0，再转移到 30 行，跳过后面循环计数器递增的语句：</p><pre><code>mov DWORD PTR _i$[ebp], 0jmp SHORT $LN3@arraySum</code></pre><p>26〜29 行标记循环开端以及循环计数器递增的位置。从 C 源代码来看，递增操作 (i++) 是在循环末尾执行，但是编译器却将这部分代码移到了循环顶部：</p><pre><code>$LN2@arraySum:   mov eax, DWORD PTR _i$[ebp]   add eax, 1   mov DWORD PTR _i$[ebp], eax</code></pre><p>30〜33 行比较变量 i 和 count，如果 i 大于或等于 count，则跳岀循环：</p><pre><code>$LN3@arraySum:   mov eax, DWORD PTR _i$[ebp]   cmp eax, DWORD PTR _count$[ebp]   jge SHORT $LN1@arraySum</code></pre><p>37〜41 行计算表达式 sum+=array[i]。Array[i] 复制到 ECX，sum 复制到 EDX，执行加法运算后，EDX 的内容再复制回 sum：</p><pre><code>mov eax, DWORD PTR _i$[ebp]mov ecx, DWORD PTR _array$[ebp]   ; array [i]mov edx, DWORD PTR _sum$[ebp]     ; sumadd edx, DWORD PTR [ecx+eax*4]mov DWORD PTR _sum$[ebp], edx</code></pre><p>42 行将控制转回循环顶部：</p><pre><code>jmp SHORT $LN2@arraySum</code></pre><p>43 行的标号正好位于循环之外，该位置便于作为循环结束时进行跳转的目标地址：</p><pre><code>$LN1@arraySum:</code></pre><p>48 行将变量 sum 送入 EAX，准备返回主调程序。52〜56 行恢复之前被保存的寄存器，其中，ESP 必须指向主调程序在堆栈中的返回地址。</p><pre><code>mov eax, DWORD PTR _sum$[ebp];   12 : }pop edipop esipop ebxmov esp, ebppop ebpret 0_arraySum ENDP</code></pre><p>可以写出比上例更快的代码，这种想法不无道理。上例中的代码是为了进行交互式调试，因此为了可读性而牺牲了速度。如果针对确定目标编译同样的程序，并选择完全优化，那么结果代码的执行速度将会非常快，但同时，程序对人类而言基本上是无法阅读和理解的。</p><h4 id="调试器设置"><a href="#调试器设置" class="headerlink" title="调试器设置"></a>调试器设置</h4><p>用 Visual Studio 调试 C 和 C++ 程序时，若想查看汇编语言源代码，就在 Tools 菜单中选择 Options 以显示如下图的对话框窗口，再选择箭头所指的选项。上述设置要在启动调试器之前完成。接着，在调试会话开始后，右键点击源代码窗口，从弹出菜单中选择 Go to Disassembly。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627227300058369" alt="img"></p><p>本章目标是熟悉由 C 和 C++ 编译器产生的最直接和简单的代码生成例子。此外，认识到编译器有多种方法生成代码也是很重要的。比如，它们可以将代码优化为尽可能少的机器代码字节。或者，可以尝试生成尽可能快的代码，即使要用大量机器代码字节来输出结果 ( 常见的情况 )。</p><p>最后，编译器还可以在代码量和速度的优化间进行折中。为速度进行优化的代码可能包含更多指令，其原因是，为了追求更快的执行速度会展开循环。机器代码还可以拆分为两部分以便利用双核处理器，这些处理器能同时执行两条并行代码。</p><h2 id="Visual-C-asm伪指令：C语言-C-内嵌汇编语言代码"><a href="#Visual-C-asm伪指令：C语言-C-内嵌汇编语言代码" class="headerlink" title="Visual C++ __asm伪指令：C语言/C++内嵌汇编语言代码"></a>Visual C++ __asm伪指令：C语言/C++内嵌汇编语言代码</h2><p>内嵌汇编代码 (inline assembly code) 是指直接插入高级语言程序中的汇编源代码。大多数 C 和 <a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a> 编译器都支持这一功能。</p><p>本节将展示如何在运行于 32 位保护模式，并采用平坦内存模式的 Microsoft Visual C++ 中编写内嵌汇编代码。其他高级语言编译器也支持内嵌汇编代码，但其语法会发生变化。</p><p>内嵌汇编代码是把汇编代码编写为外部模块的一种直接替换方式。编写内嵌代码最突岀的优点就是简单性，因为不用考虑外部链接，命名以及参数传递协议等问题。</p><p>但使用内嵌汇编代码最大的缺点是缺少兼容性。高级语言程序针对不同目的平台进行编译时，这就成了一个问题。比如，在 Intel Pentium 处理器上运行的内嵌汇编代码就不能在 RISC 处理器上运行。</p><p>一定程度上，在程序源代码中插入条件定义可以解决这个问题，插入的定义针对不同目标系统可以启用函数的不同版本。不过，容易看出，维护仍然是个问题。另一方面，外部汇编过程的链接库容易被为不同目标机器设计的相似链接库所代替。</p><h3 id="asm-伪指令"><a href="#asm-伪指令" class="headerlink" title="__asm 伪指令"></a>__asm 伪指令</h3><p>在 Visual C++ 中，伪指令 __asm 可以放在一条语句之前，也可以放在一个汇编语句块（称为 asm 块）之前。语法如下：</p><pre><code>__asm statement__asm {  statement-1  statement-2  ....  statement-n}</code></pre><blockquote><p>提示：在“asm”的前面有两个下划线。</p></blockquote><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>注释可以放在 asm 块内任何语句的后面，使用汇编语法或 C/C++ 语法。Visual C++ 手册建议不要使用汇编风格的注释，以防与 C 宏混淆，因为 C 宏会在单个逻辑行上进行扩展。下面是可用注释的例子：</p><pre><code>mov esi,buf ; initialize index registermov esi,buf // initialize index registermov esi,buf /* initialize index register */</code></pre><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>编写内嵌汇编代码时允许：</p><ul><li><p>使用 x86 指令集内的大多数指令。</p></li><li><p>使用寄存器名作为操作数。</p></li><li><p>通过名字引用函数参数。</p></li><li><p>引用在 asm 块之外定义的代码标号和变量。（这点很重要，因为局部函数变量必须在 asm 块的外面定义。）</p></li><li><p>使用包含在汇编风格或 C 风格基数表示法中的数字常数。比如，0A26h 和 0xA26 是等价的，且都能使用。</p></li><li><p>在语句中使用 PTR 运算符，比如 inc BYTE PTR[esi]。</p></li><li><p>使用 EVEN 和 ALIGN 伪指令。</p></li></ul><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><p>编写内嵌汇编代码时不允许：</p><ul><li><p>使用数据定义伪指令，如 DB（BYTE）和 DW（WORD）。</p></li><li><p>使用汇编运算符（除了 PTR 之外）。</p></li><li><p>使用 STRUCT、RECORD, WIDTH 和 MASK。</p></li><li><p>使用宏伪指令，包括 MACRO、REPT、IRC、IRP 和 ENDM，以及宏运算符（&lt;&gt;、!、&amp;、% 和 .TYPE）。</p></li><li><p>通过名字引用段。（但是，可以用段寄存器名作为操作数。）</p></li></ul><h4 id="寄存器值"><a href="#寄存器值" class="headerlink" title="寄存器值"></a>寄存器值</h4><p>不能在一个 asm 块开始的时候对寄存器值进行任何假设。寄存器有可能被 asm 块前面的执行代码修改。Microsoft Visual C++ 的关键字 __fastcall 会使编译器用寄存器来传递参数，为了避免寄存器冲突，不要同时使用 __fastcall 和 __asm。</p><p>一般情况下，可以在内嵌代码中修改 EAX、EBX、ECX 和 EDX，因为编译器并不期望在语句之间保留这些寄存器值。但是，如果修改的寄存器太多，那么编译器就无法对同一过程中的 C++ 代码进行完全优化，因为优化要用到寄存器。</p><p>虽然不能使用 OFFSET 运算符，但是用 LEA 指令也可以得到变量的偏移地址。比如，下面的指令将 buffer 的偏移地址送入 ESI：</p><pre><code>lea esi,buffer</code></pre><h4 id="长度、类型和大小"><a href="#长度、类型和大小" class="headerlink" title="长度、类型和大小"></a>长度、类型和大小</h4><p>内嵌汇编代码还可以使用 LENGTH、SIZE 和 TYPE 运算符。LENGTH 运算符返回数组内元素的个数。按照不同的对象，TYPE 运算符返回值如下：</p><ul><li><p>对 C 或 C++ 类型以及标量变量，返回其字节数。</p></li><li><p>对结构，返回其字节数。</p></li><li><p>对数组，返回其单个元素的大小。</p></li></ul><p>SIZE 运算符返回 LENGTH*TYPE 的值。下面的程序片段演示了内嵌汇编程序对各种 C++ 类型的返回值。</p><p>Microsoft Visual C++ 内嵌汇编程序不支持 SIZEOF 和 LENGHTOF 运算符。</p><h3 id="使用-LENGTH、TYPE-和-SIZE-运算符"><a href="#使用-LENGTH、TYPE-和-SIZE-运算符" class="headerlink" title="使用 LENGTH、TYPE 和 SIZE 运算符"></a>使用 LENGTH、TYPE 和 SIZE 运算符</h3><p>下面程序包含的内嵌汇编代码使用 LENGTH、TYPE 和 SIZE 运算符对 C++ 变量求值。每个表达式的返回值都在同一行的注释中给出：</p><pre><code>struct Package {  long originZip;        // 4  long destinationZip;   // 4  float shippingPrice;   // 4};   char myChar;   bool myBool;   short myShort;   int  myInt;   long myLong;   float myFloat;   double myDouble;   Package myPackage;   long double myLongDouble;   long myLongArray[10];__asm {   mov  eax,myPackage.destinationZip;   mov  eax,LENGTH myInt;         // 1   mov  eax,LENGTH myLongArray;   // 10   mov  eax,TYPE myChar;          // 1   mov  eax,TYPE myBool;          // 1   mov  eax,TYPE myShort;         // 2   mov  eax,TYPE myInt;           // 4   mov  eax,TYPE myLong;          // 4   mov  eax,TYPE myFloat;         // 4   mov  eax,TYPE myDouble;        // 8   mov  eax,TYPE myPackage;       // 12   mov  eax,TYPE myLongDouble;    // 8   mov  eax,TYPE myLongArray;     // 4   mov  eax,SIZE myLong;          // 4   mov  eax,SIZE myPackage;       // 12   mov  eax,SIZE myLongArray;     // 40}</code></pre><h2 id="C语言-C-内嵌汇编代码实例：文件加密"><a href="#C语言-C-内嵌汇编代码实例：文件加密" class="headerlink" title="C语言/C++内嵌汇编代码实例：文件加密"></a>C语言/C++内嵌汇编代码实例：文件加密</h2><p>现在查看的简短程序实现如下操作：读取一个文件，对其进行加密，再将其输出到另一个文件。函数 TranslateBuffer 用一个 __asm 块定义语句，在一个字符数组内进行循环，并把每个字符与预定义值进行 XOR 运算。</p><p>内嵌语言可以使用函数形参、局部变量和代码标号。由于本例是由 Microsoft Visual C++ 编译的 Win32 控制台应用，因此其无符号整数类型为 32 位：</p><pre><code>void TranslateBuffer(char * buf,    unsigned count, unsigned char eChar){    __asm {        mov esi, buf        mov ecx, count        mov al, eChar    L1:        xor [esi],al        inc esi        loop L1    }    // asm}</code></pre><h4 id="C-模块"><a href="#C-模块" class="headerlink" title="C++ 模块"></a>C++ 模块</h4><p>C++ 启动程序从命令行读取输入和输出文件名。在循环内调用 TranslateBuffer 从文件读取数据块，加密，再将转换后的缓冲区写入新文件：</p><pre><code>// ENCODE.CPP    复制并加密文件。#include &lt;iostream&gt;#include &lt;fstream&gt;#include "translat.h"using namespace std;int main( int argcount, char * args[] ){     // 从命令行读取输入和输出文件    if( argcount &lt; 3 ) {        cout &lt;&lt; "Usage: encode infile outfile" &lt;&lt; endl;        return -1;    }    const int BUFSIZE = 2000;    char buffer[BUFSIZE];    unsigned int count;            // 字符计算    unsigned char encryptCode;    cout &lt;&lt; "Encryption code [0-255]? ";    cin &gt;&gt; encryptCode;    ifstream infile( args[1], ios::binary );    ofstream outfile( args[2], ios::binary );    cout &lt;&lt; "Reading " &lt;&lt; args[1] &lt;&lt; " and creating "        &lt;&lt; args[2] &lt;&lt; endl;    while (!infile.eof() )    {        infile.read(buffer, BUFSIZE );        count = infile.gcount();        TranslateBuffer(buffer, count, encryptCode);        outfile.write(buffer, count);    }    return 0;}</code></pre><p>用命令提示符运行该程序，并传递输入和输岀文件名是最容易的。比如，下面的命令行读取 infile.txt，生成 encoded.txt：</p><p>encode infile.txt encoded.txt</p><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><p>头文件 translat.h 包含了 TranslateBuffer 的一个函数原型：void TranslateBuffer(char * buf, unsigned count, unsigned char eChar);</p><h4 id="过程调用的开销"><a href="#过程调用的开销" class="headerlink" title="过程调用的开销"></a>过程调用的开销</h4><p>如果在调试器调试程序时查看 Disassembly 窗口，那么，看到函数调用和返回究竟有多少开销是很有趣的。下面的语句将三个实参送入堆栈，并调用 TranslateBuffer。在 Visual C++ 的 Disassembly 窗口，激活 Show Source Code 和 Show Symbol Names 选项：</p><pre><code>; TranslateBuffer(buffer, count, encryptCode)mov al,byte ptr [encryptCode]push eaxmov ecx,dword ptr [count]push ecxlea edx,[buffer]push edxcall TranslateBuffer (4159BFh)add esp, 0Ch</code></pre><p>下面的代码对 TranslateBuffer 进行反汇编。编译器自动插入了一些语句用于设置 EBP，以及保存标准寄存器集合，集合内的寄存器不论是否真的会被过程修改，总是被保存。</p><pre><code>push ebpmov ebp, espsub esp,40hpush ebxpush esipush edi;内嵌代码从这里开始。mov esi,dword ptr [buf]mov ecx,dword ptr [count]mov al,byte ptr [eChar]L1:    xor byte ptr [esi],al    inc esi    loop L1 (41D762h);内嵌代码结束。pop edipop esipop ebxmov esp,ebppop ebpret</code></pre><p>若关闭了调试器 Disassembly 窗口的 Display Symbol Names 选项，则将参数送入寄存器的三条语句如下：</p><pre><code>mov esi,dword ptr [ebp+8]mov ecx,dword ptr [ebp+0Ch]mov al,byte ptr [ebp+10h]</code></pre><p>编译器按要求生成 Debug 目标代码，这是非优化代码，适合于交互式调试。如果选择 Release 目标代码，那么编译器生成的代码就会更加有效（但易读性更差）。</p><h4 id="忽略过程调用"><a href="#忽略过程调用" class="headerlink" title="忽略过程调用"></a>忽略过程调用</h4><p>本节前面给出的 TranslateBuffer 中有 6 条内嵌指令，其执行总共需要 8 条指令。</p><p>如果函数被调用几千次，那么其执行时间就比较可观了。为了消除这种开销，把内嵌代码插入调用 TranslateBuffer 的循环，得到更为有效的程序：</p><pre><code>while (!infile.eof() )  {    infile.read(buffer, BUFSIZE );    count = infile.gcount();    __asm {       lea esi,buffer       mov ecx,count       mov al, encryptCode    L1:       xor [esi],al       inc  esi       Loop L1   } // asm    outfile.write(buffer, count);  }</code></pre><h2 id="C语言-C-调用汇编语言函数"><a href="#C语言-C-调用汇编语言函数" class="headerlink" title="C语言/C++调用汇编语言函数"></a>C语言/C++调用汇编语言函数</h2><p>为设备驱动器和嵌入式系统编码的程序员常常需要把 C/C++ 模块与用汇编语言编写的专门代码集成起来。汇编语言特别适合于直接硬件访问、位映射，以及对寄存器和 CPU 状态标识进行底层访问。</p><p>整个应用程序都用汇编语言编写是很乏味的，比较有用的方法是，用 C/C++ 编写主程序，而那些不太好用 C 编写的代码则用汇编语言。现在来讨论一下从 32 位 C/ C++ 程序调用汇编程序的一些标准要求。</p><p>C/C++ 程序从右到左传递参数，与参数列表的顺序一致。函数返回后，主调程序负责将堆栈恢复到调用前的状态。这可以采用两种方法：一种是将堆栈指针加上一个数值，该值等于参数大小；还有一种是从堆栈中弹出足够多的数。</p><p>在汇编源代码中，需要在 .MODEL 伪指令中指定 C 调用规范，并为外部 C/C++ 程序调用的每个过程创建原型。示例如下：</p><pre><code>.586.model flat,CIndexOf PROTO,   srchVal:DWORD, arrayPtr:PTR DWORD, count:DWORD</code></pre><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>在 C 程序中，声明外部汇编过程时要使用 extern 限定符。比如，下面的语句声明了 IndexOf：</p><pre><code>extern long IndexOf(long n, long array[], unsigned count);</code></pre><p>如果过程会被 C++ 程序调用，就要添加“C”限定符，以防止 C++ 的名称修饰：</p><pre><code>extern "C" long IndexOf(long n, long array[], unsigned count);</code></pre><p>名称修饰 (name decoration) 是一种标准 C++ 编译技术，通过添加字符来修改函数名，添加的字符指明了每个函数参数的确切类型。任何支持函数重载（多个函数有相同的函数名、不同的参数列表）的语言都需要这个技术。</p><p>从汇编语言程序员的角度来看，名称修饰存在的问题是：C++ 编译器让链接器去找的是修饰过的名称，而不是生成可执行文件时的原始名称。</p><h4 id="IndexOf-示例"><a href="#IndexOf-示例" class="headerlink" title="IndexOf 示例"></a>IndexOf 示例</h4><p>现在新建一个简单汇编函数，对数组实现线性搜索，找到与样本整数匹配的第一个实例。如果搜索成功，则返回匹配元素的索引位置；否则，返回 -1。该函数将被 C++ 程序调用。在 C++ 中，编写程序段如下：</p><pre><code>long IndexOf(long searchVal, long array[], unsigned count){    for(unsigned i = 0; i &lt; count; i++) {        if(array[i] == searchVal )            return i;    }    return -1;}</code></pre><p>参数包括：希望被找到的数值、一个数组指针，以及数组大小。</p><p>用汇编语言编写该函数显然是很容易的。编写好的汇编代码放入自己的源代码文件 IndexOf.asm。这个文件将被编译为目标代码文件 IndexOf.obj。使用 Visual Studio 实现主调 C++ 程序与汇编模块的编译和链接。C++ 项目将用 Win32 控制台作为其输出类型，虽然也没有理由不让它成为图形应用程序。</p><p>下面为 IndexOf 模块的源代码清单。</p><pre><code>;IndexOf 函数    （IndexOf . asm）.586.model flat,CIndexOf PROTO,    srchVal:DWORD, arrayPtr:PTR DWORD, count:DWORD.code;-------------------------------------------IndexOf PROC USES ecx esi edi,    srchVal:DWORD, arrayPtr:PTR DWORD, count:DWORD;;对 32 位整数数组执行线性搜索，;寻找指定数值。如果发现匹配数值，;用EAX返回该数值的索引位置；;否则，EAX 返回 -1。;-------------------------------------------    NOT_FOUND = -1    mov    eax, srchVal      ;搜索数值    mov    ecx, count        ;数组大小    mov    esi, arrayPtr     ;数组指针    mov    edi, 0            ;索引L1:cmp [esi+edi*4],eax    je found    inc edi    loop L1notFound:    mov eax,NOT_FOUND    jmp short exitfound:    mov eax,ediexit:    retIndexOf ENDPEND</code></pre><p>首先，注意到用于测试循环的汇编代码 25〜28 行，虽然代码量小，但是高效。对要执行很多次的循环，应试图使其循环体内的指令条数尽可能少：</p><pre><code>L1: cmp [esi+edi*4],eax   je found   inc edi   loop L1</code></pre><p>如果找到匹配项，程序跳转到 34 行，将 EDI 复制到 EAX，该寄存器用于存放函数返回值。在搜索期间，EDI 为当前索引位置。</p><pre><code>found:   mov eax,edi</code></pre><p>如果没有找到匹配项，则把 -1 赋值给 EAX 并返回：</p><pre><code>notFound:   mov eax,NOT_FOUND   jmp short exit</code></pre><p>下面为主调 C++ 程序清单。</p><pre><code>#include &lt;iostream&gt;#include &lt;time.h&gt;#include "indexof.h"using namespace std;int main()  {    // 用伪随机数填充数组    const unsigned ARRAY_SIZE = 100000;    const unsigned LOOP_SIZE = 100000;    char* boolstr[] = {"false","true"};    long array[ARRAY_SIZE];    for(unsigned i = 0; i &lt; ARRAY_SIZE; i++)     array[i] = rand();    long searchVal;    time_t startTime, endTime;    cout &lt;&lt; "Enter an integer value to find: ";    cin &gt;&gt; searchVal;    cout &lt;&lt; "Please wait...\n";    // 测试汇编函数    time( &amp;startTime );    long count = 0;    for( unsigned n = 0; n &lt; LOOP_SIZE; n++)         count = IndexOf( searchVal, array, ARRAY_SIZE );    bool found = count != -1;    time( &amp;endTime );    cout &lt;&lt; "Elapsed ASM time: " &lt;&lt; long(endTime - startTime)          &lt;&lt; " seconds. Found = " &lt;&lt; boolstr[found] &lt;&lt; endl;    return 0;}</code></pre><p>首先，用伪随机数值对数组进行初始化：</p><pre><code>long array [ARRAY_SIZE];for(unsigned i = 0; i &lt; ARRAY_SIZE; i++)   array[i] = rand();</code></pre><p>18〜19 行提示用户输入在数组中搜索的数值：</p><pre><code>cout &lt;&lt; "Enter an integer value to find：";cin &gt;&gt; searchVal;23 行调用 C 链接库的 time 函数（在 time.h 中），把从 1970 年 1 月 1 日起已经过的秒数保存到变量 startTime：time(&amp;startTime);</code></pre><p>26 和 27 行按照 LOOP_SIZE 的值 (100 000)，反复执行相同的搜索：</p><pre><code>for(unsigned n = 0; n &lt; LOOP_SIZE; n++)   count = IndexOf(searchVal, array, ARRAY_SIZE);</code></pre><p>由于数组大小也约为 100 000，因此执行步骤的总数可以多达 100 000 x 100 000，或 100 亿。31〜33 行再次检查时间，并显示循环运行所耗的秒数：</p><pre><code>time(&amp;endTime);cout &lt;&lt; "Elapsed ASM time: " &lt;&lt; long(endTime - startTime)    &lt;&lt; "seconds. Found = " &lt;&lt; boolstr[found] &lt;&lt; endl;</code></pre><p>在高速计算机上测试时，循环执行时间为 6 秒。对 100 亿次迭代而言，这个时间不算多，每秒约有 16.7 亿次迭代。重要的是，需要意识到程序重复过程调用的开销（参数入栈，执行 CALL 和 RET 指令）也是 100 000 次。过程调用导致了相当多的额外处理。</p><h2 id="汇编语言调用C语言-C-函数"><a href="#汇编语言调用C语言-C-函数" class="headerlink" title="汇编语言调用C语言/C++函数"></a>汇编语言调用C语言/C++函数</h2><p>可以编写汇编程序来调用 C 和 C++ 函数。这样做的理由至少有两个：</p><ul><li><p>C 和 C++ 有丰富的输入-输出库，因此输入-输出有更大的灵活性。处理浮点数时，这是相当有用的。</p></li><li><p>两种语言都有丰富的数学库。</p></li></ul><p>调用标准 C 库（或 C++ 库）函数时，必须从 C 或 C++ 的 main() 过程启动程序，以便运行库初始化代码。</p><h4 id="1-函数原型"><a href="#1-函数原型" class="headerlink" title="1) 函数原型"></a>1) 函数原型</h4><p>汇编语言代码调用的 C++ 函数，必须用“C”和关键字 extern 定义。其基本语法如下：</p><pre><code>extern "C" returnType funcName(paramlist){...}</code></pre><p>示例如下：</p><pre><code>extern "C" int askForlnteger(){  cout &lt;&lt; "Please enter an integer:";  //...}</code></pre><p>与其修改每个函数定义，把多个函数原型放在一个块内显得更容易。然后，还可以省略单个函数实现的 extern 和“C”：</p><pre><code>extern "C" {  int askForlnteger();  int showInt(int value, unsigned outwidth);  //etc.}</code></pre><h4 id="2-汇编语言模块"><a href="#2-汇编语言模块" class="headerlink" title="2) 汇编语言模块"></a>2) 汇编语言模块</h4><p>如果汇编语言模块调用 Irvine32 链接库过程，就要使用如下 .MODEL 伪指令：</p><pre><code>.model flat, STDCALL</code></pre><p>虽然 STDCALL 与 Win32 API 兼容，但是它与 C 程序的调用规范不匹配。因此，在声明由汇编模块调用的外部 C 或 C++ 函数时，必须给 PROTO 伪指令加上 C 限定符：</p><pre><code>INCLUDE Irvine32.incaskForlnteger PROTO CshowInt PROTO C, value:SDWORD, outWidth:DWORD</code></pre><p>C 限定符是必要的，因为链接器必须把函数名与 C++ 模块输出的参数列表匹配起来。此外，使用了 C 调用规范，汇编器必须生成正确的代码以便在函数调用后清除堆栈。</p><p>C++ 程序调用的汇编过程也必须使用 C 限定符，这样汇编器使用的命名规则将能被链接器识别。比如，下面的 SetTextColor 过程有一个双字参数：</p><pre><code>SetTextOutColor PROC C,color:DWORD...SetTextOutColor ENDP</code></pre><p>最后，如果汇编代码调用其他汇编过程，C 调用规范要求在每个过程调用后，把参数从堆栈中移除。</p><p>如果汇编代码不调用 Irvine32 过程，就可以在 .MODEL 伪指令中使用 C 调用规范：</p><pre><code>;(do not INCLUDE Irvine32.inc).586.model flat,C此时不再需要为 PROTO 和 PROC 伪指令添加 C 限定符：askForInteger PROTOshowInt PROTO, value:SDWORD, outWidth:DWORDSetTextOutColor PROC,  color:DWORD  ...SetTextOutColor ENDP3) 函数返回值</code></pre><p>C++ 语言规范没有提及代码实现细节，因此没有规定标准方法让 C 和 C++ 函数返回数值。当编写的汇编代码调用这些语言的函数时，要检查编译器文件以便了解它们的函数是如何返回数值的。</p><p>下面列出了一些可能的情况，但并非全部：</p><ul><li><p>整数用单个寄存器或寄存器组返回。</p></li><li><p>主调程序可以在堆栈中为函数返回值预留空间。函数在返回前，可以将返回值存入堆栈。</p></li><li><p>函数返回前，浮点数值通常被压入处理器的浮点数堆栈。</p></li></ul><p>下面列出了 Microsoft Visual C++ 函数怎样返回数值：</p><ul><li><p>bool 和 char 值用 AL 返回。</p></li><li><p>short int 值用 AX 返回。</p></li><li><p>int 和 long int 值用 EAX 返回。</p></li><li><p>指针用 EAX 返回。</p></li><li><p>float、double 和 long double 值分别以 4 字节、8 字节和 10 字节数值压入浮点堆栈。</p></li></ul><h2 id="汇编语言调用C语言-C-实例：乘法表"><a href="#汇编语言调用C语言-C-实例：乘法表" class="headerlink" title="汇编语言调用C语言/C++实例：乘法表"></a>汇编语言调用C语言/C++实例：乘法表</h2><p>现在编写一个简单的应用程序，提示用户输入整数，通过移位的方式将其与 2 的幕 (2¹〜2ⁿ) 相乘，并用填充前导空格的形式再次显示每个乘积。输入-输出使用 C++。汇编模块将调用 3 个 C++ 编写的函数。程序将由 C++ 模块启动。</p><h4 id="汇编语言模块"><a href="#汇编语言模块" class="headerlink" title="汇编语言模块"></a>汇编语言模块</h4><p>汇编模块包含一个函数 DisplayTable。它调用 C++ 函数 askForInteger 从用户输入一个整数。它还使用循环结构把整数 intVal 重复左移，并调用 showInt 进行显示。</p><pre><code>; C++ 调用ASM函数.INCLUDE Irvine32.inc;外部C++函数askForInteger PROTO CshowInt PROTO C, value:SDWORD, outWidth:DWORDOUT_WIDTH = 8ENDING_POWER = 10.dataintVal DWORD ?.code;---------------------------------------------SetTextOutColor PROC C,    color:DWORD;; 设置文本颜色，并清除控制台窗口; 调用 Irvine32 库函数;---------------------------------------------    mov    eax,color    call    SetTextColor    call    Clrscr    retSetTextOutColor ENDP;---------------------------------------------DisplayTable PROC C;; 输入一个整数 n 并显示范围为 n * 2^1 ~ n * 2^10的乘法表;----------------------------------------------    INVOKE askForInteger                 ; 调用 C++ 函数    mov    intVal,eax                    ; 保存整数    mov    ecx,ENDING_POWER              ; 循环计数器L1:    push ecx                          ; 保存循环计数器    shl  intVal,1                        ; 乘以 2    INVOKE showInt,intVal,OUT_WIDTH    call    Crlf    pop    ecx                           ; 恢复循环计数器    loop    L1    retDisplayTable ENDPEND在 DisplayTable 过程中，必须在调用 showInt 和 newLine 之前将 ECX 入栈，并在调用后将 ECX 出栈，这是因为 Visual C++ 函数不会保存和恢复通用寄存器。函数 askForInteger 用 EAX 寄存器返回结果。</code></pre><p>DisplayTable 在调用 C++ 函数时不一定要用 INVOKE。PUSH 和 CALL 指令也能得到同样的结果。对 showInt 的调用如下所示：</p><pre><code>push OUT_WIDTH ;最后一个参数首先入栈push intValcall showInt       ;调用函数add esp,8        ;清除堆栈</code></pre><p>必须遵守 C 语言调用规范，其参数按照逆序入栈，且主调方负责在调用后从堆栈移除实参。</p><h4 id="C-测试程序"><a href="#C-测试程序" class="headerlink" title="C++ 测试程序"></a>C++ 测试程序</h4><p>下面查看启动程序的 C++ 模块。其入口为 main()，保证执行所需 C++ 语言的初始化代码。它包含了外部汇编过程和三个输岀函数的原型：</p><pre><code>// main.cpp// 演示C++程序和外部汇编模块的函数调用#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;extern "C" {    // 外部 ASM 过程:    void DisplayTable();    void SetTextOutColor( unsigned color );    // 局部 C++ 函数:    int askForInteger();    void showInt( int value, int width );}// 程序入口int main(){    SetTextOutColor( 0x1E );       // 蓝底黄字    DisplayTable();                // 调用 ASM 过程    return 0;}// 提示用户输入一个整数int askForInteger(){    int n;    cout &lt;&lt; "Enter an integer between 1 and 90,000: ";    cin &gt;&gt; n;    return n;}// 按特定宽度显示一个有符号整数void showInt( int value, int width ){    cout &lt;&lt; setw(width) &lt;&lt; value;}</code></pre><h4 id="生成项目"><a href="#生成项目" class="headerlink" title="生成项目"></a>生成项目</h4><p>将 C++ 和汇编模块添加到 Visual Studio 项目，并在 Project 菜单中选择 Build Solution。</p><h4 id="程序输出"><a href="#程序输出" class="headerlink" title="程序输出"></a>程序输出</h4><p>当用户输入为 90 000 时，乘法表程序产生的输出如下</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627227334071371" alt="img"></p><h4 id="Visual-Studio-项目属性"><a href="#Visual-Studio-项目属性" class="headerlink" title="Visual Studio 项目属性"></a>Visual Studio 项目属性</h4><p>如果使用 Visual Studio 生成集成了 C++ 和汇编代码的程序，并且调用 Irvine32 链接库，就需要修改某些项目设置。以 Multiplication_Table 程序为例。</p><p>在 Project 菜单中选择 Properties，在窗口左边的 Configuration Properties 条目下，选择 Linker。在右边面板的 Additional Library Directories 条目中输入 c:\Irvine。</p><p>示例如下图所示。点击OK关闭 Project Property Pages 窗口。现在 Visual Studio 就可以找到 Irvine32 链接库了。</p><p><img src="/images/loading.gif" data-original="images/asm-language/-1627227351980373" alt="img"></p><h2 id="汇编语言调用C语言-C-库函数"><a href="#汇编语言调用C语言-C-库函数" class="headerlink" title="汇编语言调用C语言/C++库函数"></a>汇编语言调用C语言/C++库函数</h2><p>C 语言有标准函数集合，被称为标准 C 库 (Standard C Library)。同样的函数还可以用于 C++ 程序，因此，也可用于与 C 和 C++ 程序连接的汇编模块。</p><p>汇编模块调用 C 函数时，就必须包含函数的原型。一般通过访问 C++ 编译器的帮助系统可以找到 C 函数原型。程序调用 C 函数时，需要先将 C 函数原型转换为汇编语言原型。</p><h4 id="printf-函数"><a href="#printf-函数" class="headerlink" title="printf 函数"></a>printf 函数</h4><p>下面是 printf 函数的 C/C++ 语言原型，第一个参数为字符指针，其后跟了一组可变数量的参数：</p><pre><code>int printf(   const char * format [, argument]...);</code></pre><p>C/C++ 编译器的帮助库可以查阅到 printf 函数文档。汇编语言中与之等效的函数原型将 char* 改为 PTR BYTE，将可变长度参数列表的类型改为 VARARG：</p><pre><code>printf PROTO C, pString:PTR BYTE, args:VARARG</code></pre><p>另一个有用的函数是 scanf，用于从标准输入（键盘）接收字符、数字和字符串，并将输入数值分配给变量：</p><pre><code>scanf PROTO C, format:PTR BYTE, args:VARARG</code></pre><h3 id="用-printf-函数显示格式化实数"><a href="#用-printf-函数显示格式化实数" class="headerlink" title="用 printf 函数显示格式化实数"></a>用 printf 函数显示格式化实数</h3><p>编写汇编函数格式化并显示浮点数不是一件容易的事。与其由程序员自行编码，还不如利用 C 库的 printf 函数。需要创建 C 或 C++ 的启动模块，并将其与汇编代码链接</p><p>下面给出了用 Visual C++.NET 创建这种程序的过程：</p><p>\1) 用 Visual C++ 创建一个 Win32 控制台程序。创建文件 main.cpp，并插入函数 main，该函数调用了 asmMain：</p><pre><code>extern "C" void asmMain();int main(){   asmMain();   return 0;}</code></pre><p>\2) 在 main.cpp 所在的文件夹中，创建一个汇编模块 asmMain.asm。该模块包含过程 asmMain，并声明使用 C 调用规范：</p><pre><code>; asmMain.asm.386.model flat,stdcall.stack 2000.codeasmMain PROC C   retasmMain ENDPEND</code></pre><p>\3) 汇编 asmMain.asm（但不进行链接），生成 asmMain.obj。</p><p>\4) 将 asmMain.obj 添加到 C++ 项目。</p><p>\5) 构建并运行项目。如果修改了 asmMain.asm，则在运行前，需要再一次汇编和构建项目。</p><p>一旦程序正确建立，就可以向 asmMain.asm 添加代码来调用 C/C++ 函数。</p><p>显示双精度数值</p><p>下面是 asmMain 中的汇编代码，它通过调用 printf 输岀了一个类型为 REAL8 的数值：</p><pre><code>.datadouble1 REAL8 1234567.890123formatStr BYTE "%.3f", 0dh, 0ah, 0.codeINVOKE printf, ADDR formatStr, double1</code></pre><p>相应的输出如下：</p><p>1234567.890</p><p>这里，传递给 printf 的格式化字符串与 C++ 中的略有不同：不是插入转义字符，如 \n，而是必须插入 ASCII 字符（0dh, 0ah）。</p><p>传递给 printf 的浮点参数应声明为 REAL8 类型。不过传递的数值也可能是 REAL4 类型，这需要相当的编程技巧。若想了解 C++ 编译器是如何工作的，可以声明一个 float 类型的变量，并将其传递给 printf。编译程序，并用调试器跟踪该程序的反汇编代码。</p><h4 id="多参数"><a href="#多参数" class="headerlink" title="多参数"></a>多参数</h4><p>printf 函数接收可变数量的参数，因此很容易在一次函数调用中对两个数进行格式化并显示它们：</p><pre><code>TAB = 9.dataformatTwo BYTE "%.2f",TAB,"%.3f",0dh,0ah,0val1 REAL8 456.789val2 REAL8 864.231.codeINVOKE printf, ADDR formatTwo, val1, val2</code></pre><p>相应的输岀如下：</p><p>456.79  864.231</p><h3 id="用-scanf-函数输入实数"><a href="#用-scanf-函数输入实数" class="headerlink" title="用 scanf 函数输入实数"></a>用 scanf 函数输入实数</h3><p>调用 scanf 可以从用户输入浮点数。SmallWin.inc（包括在 Irvine32.inc 内）定义的函数原型如下所示：</p><pre><code>scanf PROTO C,   format:PTR BYTE, args:VARARG</code></pre><p>传递给它的参数包括：格式化字符串的偏移量，一个或多个 REAL4、REAL8 类型变量的偏移量（这些变量存放了用户输入的数值）。调用示例如下：</p><pre><code>.datastrSingle BYTE "%f", 0strDouble BYTE "%lf",0single1 REAL4 ?double1 REAL8 ?.codeINVOKE scanf, ADDR strSingle, ADDR single1INVOKE scanf, ADDR strDouble, ADDR double1</code></pre><p>必须从 C 或 C++ 启动程序中调用汇编语言代码。</p><h2 id="C-C-调用汇编语言实例：目录表程序"><a href="#C-C-调用汇编语言实例：目录表程序" class="headerlink" title="C/C++调用汇编语言实例：目录表程序"></a>C/C++调用汇编语言实例：目录表程序</h2><p>现在编写一个简短的程序，清除屏幕，显示当前磁盘目录，并请求用户输入文件名。程序员可能希望扩展该程序，以打开并显示被选中文件。</p><h4 id="C-根模块"><a href="#C-根模块" class="headerlink" title="C++ 根模块"></a>C++ 根模块</h4><p>C++ 模块只有一个对 asm_main 的调用，因此可以将其称为根模块 (stub module)：</p><pre><code>// main.cpp//根模块：启动汇编程序extern "C" void asm_main() ; // asm 启动过程void main(){  asm_main();}</code></pre><h4 id="ASM-模块"><a href="#ASM-模块" class="headerlink" title="ASM 模块"></a>ASM 模块</h4><p>汇编语言模块包括了函数原型、若干字符串和一个 fileName 变量。模块两次调用 system 函数，向其传递“cls”和“dir”命令。然后调用 printf，显示请求文件名的提示行，再调用 scanf，使用户输入文件名。</p><p>程序不调用 Irvine32 库中的任何函数，因此可以将 .MODEL 伪指令设置为 C 语言规范：</p><pre><code>; 从 C++ 启动的 ASM 程序 (asmMain.asm).586.MODEL flat,C; 标准 C 库函数system PROTO, pCommand:PTR BYTEprintf PROTO, pString:PTR BYTE, args:VARARGscanf  PROTO, pFormat:PTR BYTE,pBuffer:PTR BYTE, args:VARARGfopen  PROTO, mode:PTR BYTE, filename:PTR BYTEfclose PROTO, pFile:DWORDBUFFER_SIZE = 5000.datastr1 BYTE "cls",0str2 BYTE "dir/w",0str3 BYTE "Enter the name of a file: ",0str4 BYTE "%s",0str5 BYTE "cannot open file",0dh,0ah,0str6 BYTE "The file has been opened and closed",0dh,0ah,0modeStr BYTE "r",0fileName BYTE 60 DUP(0)pBuf  DWORD ?pFile DWORD ?.codeasm_main PROC    ; 清除屏幕，显示磁盘目录    INVOKE system,ADDR str1    INVOKE system,ADDR str2    ; 清除文件名    INVOKE printf,ADDR str3    INVOKE scanf, ADDR str4, ADDR fileName    ; 尝试打开文件    INVOKE fopen, ADDR fileName, ADDR modeStr    mov pFile,eax    .IF eax == 0                ; 不能打开文件      INVOKE printf,ADDR str5      jmp quit    .ELSE      INVOKE printf,ADDR str6    .ENDIF    ; 关闭文件    INVOKE fclose, pFilequit:    ret                         ; 返回 C++ 主程序asm_main ENDPEND</code></pre><p>函数 scanf 需要两个参数：第一个是格式化字符串（“%s”）的指针，第二个是输入字符串变量（fileName）的指针。因为互联网上有丰富的文档，因此这里不再浪费时间来解释标准 C 函数。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Asm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gradle详解</title>
      <link href="/posts/8af5.html"/>
      <url>/posts/8af5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Gradle安装配置"><a href="#Gradle安装配置" class="headerlink" title="Gradle安装配置"></a>Gradle安装配置</h1><h2 id="mac环境下安装配置"><a href="#mac环境下安装配置" class="headerlink" title="mac环境下安装配置"></a>mac环境下安装配置</h2><p>从<a href="https://gradle.org/install/" target="_blank" rel="noopener">Gradle官网</a>的安装指导可以知道, (最新的gradle版本)要求jdk的版本是1.8, 或者更高.</p><pre><code>PrerequisitesGradle runs on all major operating systems and requires only a Java JDK or JRE version 8 or higher to be installed. To check, run java -version:// 使用以下命令可以查看自己电脑的jdk版本是否满足要求$ java -versionjava version "1.8.0_121"</code></pre><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a><strong>下载安装</strong></h4><p> <a href="https://gradle.org/install/" target="_blank" rel="noopener">Gradle官网</a></p><p> <a href="https://gradle.org/releases/" target="_blank" rel="noopener">gradle下载地址</a></p><ul><li>macOS可以使用brew安装—— <a href="http://brew.sh/" target="_blank" rel="noopener">Homebrew</a> is “the missing package manager for macOS”.</li></ul><pre><code>brew install gradle</code></pre><ul><li><p>手动安装—— </p><p>gradle官网安装说明-Step 1. Download &amp;&amp; Step 2. Unpack the distribution</p><ul><li>下载</li></ul></li></ul><p><a href="https://gradle.org/next-steps/?version=6.2.2&amp;format=bin" target="_blank" rel="noopener">gradle6.2.2版本下载</a></p><p>选择自己想安装的版本，以6.2.2为例，选择Binary-only下载</p><ul><li>安装</li></ul><p>对于 Linux &amp; MacOS 用户, 可以打开 <strong>终端(命令行工具)</strong> 使用以下命令</p><pre><code>// 在根目录下的opt目录下, 创建gradle文件夹// 有可能没有权限, 或者没有目录, 可以使用 "sudo mkdir -p /opt/gradle" 命令(注: 命令需要密码, 同时输入的密码不会显示)$ mkdir /opt/gradle// 将安装包, 解压到指定目录(/opt/gradle)下// 如果提示: Permission denied, 可以使用 "sudo unzip -d /opt/gradle gradle-6.2.2-bin.zip"// 注: 此命令是进入到了安装包的当前目录下的命令// 如果不知道当前的安装包的路径, 可以将安装包拖入终端, 终端会自动显示此安装包的当前路径$ unzip -d /opt/gradle gradle-6.2.2-bin.zip// 查看安装包是否解压成功$ ls /opt/gradle/gradle-6.2.2LICENSE  NOTICE  bin  getting-started.html  init.d  lib  media// ps: 没有media文件(夹), 不影响</code></pre><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a><strong>配置环境变量</strong></h4><p> mac的环境变量的配置—— <a href="https://gradle.org/install/" target="_blank" rel="noopener">gradle官网操作说明-Step 3. Configure your system environment</a></p><ul><li>对于 Linux &amp; MacOS 用户, 使用以下命令配置环境变量</li></ul><pre><code># 进入用户目录下的配置文件vim ~/.bash_profile# 修改.bash_profile文件, 在文件的最后加上如下配置: export PATH=$PATH:/opt/gradle/gradle-6.2.2/bin# 如果了解配置文件的运行规则的, 可以自己看着改, 例如: # export GRADLE=/opt/gradle/gradle-6.2.2# export PATH=$PATH:$GRADLE/bin# 修改后, 按[Esc], 命令":wq"保存退出, 并在终端使用如下命令使配置生效:source ~/.bash_profile</code></pre><h4 id="检查安装结果"><a href="#检查安装结果" class="headerlink" title="检查安装结果"></a><strong>检查安装结果</strong></h4><p> 检查mac的安装结果—— <a href="https://gradle.org/install/" target="_blank" rel="noopener">gradle官网操作说明-Step 4. Verify your installation</a></p><ul><li>使用命令查看gradle安装的结果</li></ul><pre><code>gradle -v# 有出现如下的信息, 说明安装成功, 环境配置成功------------------------------------------------------------Gradle 6.2.2------------------------------------------------------------</code></pre><h4 id="找不到gradle错误解决方案："><a href="#找不到gradle错误解决方案：" class="headerlink" title="找不到gradle错误解决方案："></a>找不到gradle错误解决方案：</h4><p><strong>问题：</strong>Mac 每次都要执行source ~/.bash_profile 后，配置的环境变量才生效</p><p><strong>解决：</strong></p><p>在.zshrc文件夹中添加source ~/.bash_profile,方法如下</p><p>进入主目录 cd ~</p><p>显示隐藏文件，找到.zshrc文件夹 输入ls -a（显示所有文件包括隐藏文件）如果没有可以自己创建 命令为 touch .zshrc</p><p>编辑文件 vi .zshrc</p><p>按i进入编辑模式，加入source ~/.bash_profile后，esc，再输入：wq保存退出</p><h1 id="Gradle-概述"><a href="#Gradle-概述" class="headerlink" title="Gradle 概述"></a>Gradle 概述</h1><h2 id="特性说明"><a href="#特性说明" class="headerlink" title="特性说明"></a>特性说明</h2><p>下面是一些 Gradle 特性的列表。</p><h3 id="基于声明的构建和基于约定的构建"><a href="#基于声明的构建和基于约定的构建" class="headerlink" title="基于声明的构建和基于约定的构建"></a>基于声明的构建和基于约定的构建</h3><p>Gradle 的核心在于基于 Groovy 的丰富而可扩展的域描述语言(DSL)。 Groovy 通过声明性的语言元素将基于声明的构建推向下层，你可以按你想要的方式进行组合。 这些元素同样也为支持 Java， Groovy，OSGi，Web 和 Scala 项目提供了基于约定的构建。 并且，这种声明性的语言是可以扩展的。你可以添加新的或增强现有的语言元素。 因此，它提供了简明、可维护和易理解的构建。</p><h3 id="为以依赖为基础的编程方式提供语言支持"><a href="#为以依赖为基础的编程方式提供语言支持" class="headerlink" title="为以依赖为基础的编程方式提供语言支持"></a>为以依赖为基础的编程方式提供语言支持</h3><p>声明性语言优点在于通用任务图，你可以将其充分利用在构建中. 它提供了最大限度的灵活性，以让 Gradle 适应你的特殊需求。</p><h3 id="构建结构化"><a href="#构建结构化" class="headerlink" title="构建结构化"></a>构建结构化</h3><p>Gradle 的灵活和丰富性最终能够支持在你的构建中应用通用的设计模式。 例如，它可以很容易地将你的构建拆分为多个可重用的模块，最后再进行组装，但不要强制地进行模块的拆分。 不要把原本在一起的东西强行分开（比如在你的项目结构里），从而避免让你的构建变成一场噩梦。 最后，你可以创建一个结构良好，易于维护，易于理解的构建。</p><h3 id="深度-API"><a href="#深度-API" class="headerlink" title="深度 API"></a>深度 API</h3><p>Gradle 允许你在构建执行的整个生命周期，对它的核心配置及执行行为进行监视并自定义。</p><h3 id="Gradle-的扩展"><a href="#Gradle-的扩展" class="headerlink" title="Gradle 的扩展"></a>Gradle 的扩展</h3><p>Gradle 有非常良好的扩展性。 从简单的单项目构建，到庞大的多项目构建，它都能显著地提升你的效率。 这才是真正的结构化构建。通过最先进的增量构建功能，它可以解决许多大型企业所面临的性能瓶颈问题。</p><h3 id="多项目构建"><a href="#多项目构建" class="headerlink" title="多项目构建"></a>多项目构建</h3><p>Gradle 对多项目构建的支持非常出色。项目依赖是首先需要考虑的问题。 我们允许你在多项目构建当中对项目依赖关系进行建模，因为它们才是你真正的问题域。 Gradle 遵守你的布局。</p><p>Gradle 提供了局部构建的功能。 如果你在构建一个单独的子项目，Gradle 也会帮你构建它所依赖的所有子项目。 你也可以选择重新构建依赖于特定子项目的子项目。 这种增量构建将使得在大型构建任务中省下大量时间。</p><h3 id="多种方式管理依赖"><a href="#多种方式管理依赖" class="headerlink" title="多种方式管理依赖"></a>多种方式管理依赖</h3><p>不同的团队喜欢用不同的方式来管理他们的外部依赖。 从 Maven 和 Ivy 的远程仓库的传递依赖管理，到本地文件系统的 jar 包或目录，Gradle 对所有的管理策略都提供了方便的支持。</p><h3 id="Gradle-是第一个构建集成工具"><a href="#Gradle-是第一个构建集成工具" class="headerlink" title="Gradle 是第一个构建集成工具"></a>Gradle 是第一个构建集成工具</h3><p>Ant tasks 是最重要的。而更有趣的是，Ant projects 也是最重要的。 Gradle 对任意的 Ant 项目提供了深度导入，并在运行时将 Ant 目标(target)转换为原生的 Gradle 任务(task)。 你可以从 Gradle 上依赖它们(Ant targets)，增强它们，甚至在你的 build.xml 上定义对 Gradle tasks 的依赖。Gradle 为属性、路径等等提供了同样的整合。</p><p>Gradle 完全支持用于发布或检索依赖的 Maven 或 Ivy 仓库。 Gradle 同样提供了一个转换器，用于将一个 Maven pom.xml 文件转换为一个 Gradle 脚本。Maven 项目的运行时导入的功能将很快会有。</p><h2 id="易于移植"><a href="#易于移植" class="headerlink" title="易于移植"></a>易于移植</h2><p>Gradle 能适应你已有的任何结构。因此，你总可以在你构建项目的同一个分支当中开发你的 Gradle 构建脚本，并且它们能够并行进行。 我们通常建议编写测试，以保证生成的文件是一样的。 这种移植方式会尽可能的可靠和减少破坏性。这也是重构的最佳做法。</p><h3 id="Groovy"><a href="#Groovy" class="headerlink" title="Groovy"></a>Groovy</h3><p>Gradle 的构建脚本是采用 Groovy 写的，而不是用 XML。 但与其他方法不同，它并不只是展示了由一种动态语言编写的原始脚本的强大。 那样将导致维护构建变得很困难。 Gradle 的整体设计是面向被作为一门语言，而不是一个僵化的框架。 并且 Groovy 是我们允许你通过抽象的 Gradle 描述你个人的 story 的黏合剂。 Gradle 提供了一些标准通用的 story。这是我们相比其他声明性构建系统的主要特点。 我们的 Groovy 支持也不是简单的糖衣层，整个 Gradle 的 API 都是完全 groovy 化的。只有通过 Groovy才能去运用它并对它提高效率。</p><h3 id="The-Gradle-wrapper"><a href="#The-Gradle-wrapper" class="headerlink" title="The Gradle wrapper"></a>The Gradle wrapper</h3><p>Gradle Wrapper 允许你在没有安装 Gradle 的机器上执行 Gradle 构建。 这一点是非常有用的。比如，对一些持续集成服务来说。 它对一个开源项目保持低门槛构建也是非常有用的。 Wrapper 对企业来说也很有用，它使得对客户端计算机零配置。 它强制使用指定的版本，以减少兼容支持问题。</p><h3 id="自由和开源"><a href="#自由和开源" class="headerlink" title="自由和开源"></a>自由和开源</h3><p>Gradle 是一个开源项目，并遵循 ASL 许可。</p><h2 id="为什么使用-Groovy"><a href="#为什么使用-Groovy" class="headerlink" title="为什么使用 Groovy?"></a>为什么使用 Groovy?</h2><p>我们认为内部 DSL（基于一种动态语言）相比 XML 在构建脚本方面优势非常大。它们是一对动态语言。 为什么使用 Groovy？答案在于 Gradle 内部的运行环境。 虽然 Gradle 核心目的是作为通用构建工具，但它还是主要面向 Java 项目。 这些项目的团队成员显然熟悉 Java。我们认为一个构建工具应该尽可能地对所有团队成员透明。</p><p>你可能会想说，为什么不能使用 Java 来作为构建脚本的语言。 我认为这是一个很有意义的问题。对你们的团队来讲，它确实会有最高的透明度和最低的学习曲线。 但由于 Java 本身的局限性，这种构建语言可能就不会那样友善、 富有表现力和强大。 这也是为什么像 Python，Groovy 或者 Ruby 这样的语言在这方面表现得更好的原因。 我们选择了 Groovy，因为它向 Java 人员提供了目前为止最大的透明度。 其基本的语法，类型，包结构和其他方面都与 Java 一样，Groovy 在这之上又增加了许多东西。但是和 Java 也有着共同点。</p><p>对于那些分享和乐于去学习 Python 知识的 Java 团队而言，上述论点并不适用。 Gradle 的设计非常适合在 JRuby 或 Jython 中创建另一个构建脚本引擎。 那时候，对我们而言，它只是不再是最高优先级的了。我们很高兴去支持任何社区努力创建其他的构建脚本引擎。</p><h1 id="Gradle-构建基础"><a href="#Gradle-构建基础" class="headerlink" title="Gradle 构建基础"></a>Gradle 构建基础</h1><h2 id="Projects-和-tasks"><a href="#Projects-和-tasks" class="headerlink" title="Projects 和 tasks"></a>Projects 和 tasks</h2><p>projects 和 tasks是 Gradle 中最重要的两个概念。</p><p>任何一个 Gradle 构建都是由一个或多个 projects 组成。每个 project 包括许多可构建组成部分。 这完全取决于你要构建些什么。举个例子，每个 project 或许是一个 jar 包或者一个 web 应用，它也可以是一个由许多其他项目中产生的 jar 构成的 zip 压缩包。一个 project 不必描述它只能进行构建操作。它也可以部署你的应用或搭建你的环境。不要担心它像听上去的那样庞大。 Gradle 的 build-by-convention 可以让您来具体定义一个 project 到底该做什么。</p><p>每个 project 都由多个 tasks 组成。每个 task 都代表了构建执行过程中的一个原子性操作。如编译，打包，生成 javadoc，发布到某个仓库等操作。</p><p>到目前为止，可以发现我们可以在一个 project 中定义一些简单任务，后续章节将会阐述多项目构建和多项目多任务的内容。</p><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>你可以通过在命令行运行 gradle 命令来执行构建，gradle 命令会从当前目录下寻找 build.gradle 文件来执行构建。我们称 build.gradle 文件为构建脚本。严格来说这其实是一个构建配置脚本，后面你会了解到这个构建脚本定义了一个 project 和一些默认的 task。</p><p>你可以创建如下脚本到 build.gradle 中 To try this out，create the following build script named build.gradle。</p><h3 id="第一个构建脚本"><a href="#第一个构建脚本" class="headerlink" title="第一个构建脚本"></a>第一个构建脚本</h3><p>build.gradle</p><pre><code>task hello {    doLast {        println 'Hello world!'    }}</code></pre><p>然后在该文件所在目录执行 gradle -q hello</p><blockquote><p>-q 参数的作用是什么?</p></blockquote><blockquote><p>该文档的示例中很多地方在调用 gradle 命令时都加了 -q 参数。该参数用来控制 gradle 的日志级别，可以保证只输出我们需要的内容。</p></blockquote><pre><code>Output of gradle -q hello&gt; gradle -q helloHello world!</code></pre><p>上面的脚本定义了一个叫做 hello 的 task，并且给它添加了一个动作。当执行 gradle hello 的时候, Gralde 便会去调用 hello 这个任务来执行给定操作。这些操作其实就是一个用 groovy 书写的闭包。</p><p>如果你觉得它看上去跟 Ant 中的 targets 很像，那么是对的。Gradle 的 tasks 就相当于 Ant 中的 targets。不过你会发现他功能更加强大。我们只是换了一个比 target 更形象的另外一个术语。不幸的是这恰巧与 Ant 中的术语有些冲突。ant 命令中有诸如 javac、copy、tasks。所以当该文档中提及 tasks 时，除非特别指明 ant task。否则指的均是指 Gradle 中的 tasks。</p><h2 id="快速定义任务"><a href="#快速定义任务" class="headerlink" title="快速定义任务"></a>快速定义任务</h2><p>用一种更简洁的方式来定义上面的 hello 任务。</p><h3 id="快速定义任务-1"><a href="#快速定义任务-1" class="headerlink" title="快速定义任务"></a>快速定义任务</h3><p>build.gradle</p><pre><code>task hello {    println 'Hello world!'}</code></pre><p>上面的脚本又一次采用闭包的方式来定义了一个叫做 hello 的任务。</p><blockquote><p> 注：&lt;&lt;在Gradle4.x中被弃用，在Gradle 5.0中被移除，详情见：<a href="https://docs.gradle.org/4.0/release-notes.html#setting-the-compiler-executable-is-no-longer-deprecated" target="_blank" rel="noopener">Gradle 4.x官网</a></p></blockquote><blockquote><p>例：task &lt;&lt;{ println ‘Hello world!’}  解决方法：直接去掉或使用doLast解决。</p></blockquote><h3 id="代码即脚本"><a href="#代码即脚本" class="headerlink" title="代码即脚本"></a>代码即脚本</h3><p>Gradle 脚本采用 Groovy 书写，看下下面这个例子。</p><h3 id="在-gradle-任务中采用-groovy"><a href="#在-gradle-任务中采用-groovy" class="headerlink" title="在 gradle 任务中采用 groovy"></a>在 gradle 任务中采用 groovy</h3><p>build.gradle</p><pre><code>task upper &lt;&lt; {    String someString = 'mY_nAmE'    println "Original: " + someString    println "Upper case: " + someString.toUpperCase()}Output of gradle -q upper&gt; gradle -q upperOriginal: mY_nAmEUpper case: MY_NAME</code></pre><p>或者</p><h3 id="在-gradle-任务中采用-groovy-1"><a href="#在-gradle-任务中采用-groovy-1" class="headerlink" title="在 gradle 任务中采用 groovy"></a>在 gradle 任务中采用 groovy</h3><p>build.gradle</p><pre><code>task count &lt;&lt; {    4.times { print "$it " }}Output of gradle -q count&gt; gradle -q count0 1 2 3</code></pre><h2 id="任务依赖"><a href="#任务依赖" class="headerlink" title="任务依赖"></a>任务依赖</h2><p>你可以按如下方式创建任务间的依赖关系</p><h3 id="在两个任务之间指明依赖关系"><a href="#在两个任务之间指明依赖关系" class="headerlink" title="在两个任务之间指明依赖关系"></a>在两个任务之间指明依赖关系</h3><p>build.gradle</p><pre><code>task hello &lt;&lt; {    println 'Hello world!'}task intro(dependsOn: hello) &lt;&lt; {    println "I'm Gradle"}</code></pre><p>gradle -q intro 的输出结果</p><pre><code>Output of gradle -q intro\&gt; gradle -q introHello world!I'm Gradle</code></pre><p>添加依赖 task 也可以不必首先声明被依赖的 task。</p><h2 id="延迟依赖"><a href="#延迟依赖" class="headerlink" title="延迟依赖"></a>延迟依赖</h2><p>build.gradle</p><pre><code>task taskX(dependsOn: 'taskY') &lt;&lt; {    println 'taskX'}task taskY &lt;&lt; {    println 'taskY'}</code></pre><p>Output of gradle -q taskX</p><pre><code> \&gt; gradle -q taskXtaskYtaskX</code></pre><p>可以看到，taskX 是 在 taskY 之前定义的，这在多项目构建中非常有用。</p><p>注意:当引用的任务尚未定义的时候不可使用短标记法来运行任务。</p><h2 id="动态任务"><a href="#动态任务" class="headerlink" title="动态任务"></a>动态任务</h2><p>借助 Groovy 的强大不仅可以定义简单任务还能做更多的事。例如，可以动态定义任务。</p><h3 id="创建动态任务"><a href="#创建动态任务" class="headerlink" title="创建动态任务"></a>创建动态任务</h3><p>build.gradle</p><pre><code>4.times { counter -&gt;    task "task$counter" &lt;&lt; {        println "I'm task number $counter"    }}</code></pre><p>gradle -q task1 的输出结果。</p><pre><code>\&gt; gradle -q task1I'm task number 1</code></pre><h2 id="任务操纵"><a href="#任务操纵" class="headerlink" title="任务操纵"></a>任务操纵</h2><p>一旦任务被创建后，任务之间可以通过 API 进行相互访问。这也是与 Ant 的不同之处。比如可以增加一些依赖。</p><h3 id="通过-API-进行任务之间的通信-增加依赖"><a href="#通过-API-进行任务之间的通信-增加依赖" class="headerlink" title="通过 API 进行任务之间的通信 - 增加依赖"></a>通过 API 进行任务之间的通信 - 增加依赖</h3><p>build.gradle</p><pre><code>4.times { counter -&gt;    task "task$counter" &lt;&lt; {        println "I'm task number $counter"    }}task0.dependsOn task2, task3</code></pre><p>gradle -q task0的输出结果。</p><pre><code>Output of gradle -q task0\&gt; gradle -q task0I'm task number 2I'm task number 3I'm task number 0</code></pre><p>为已存在的任务增加行为。</p><h3 id="通过-API-进行任务之间的通信-增加任务行为"><a href="#通过-API-进行任务之间的通信-增加任务行为" class="headerlink" title="通过 API 进行任务之间的通信 - 增加任务行为"></a>通过 API 进行任务之间的通信 - 增加任务行为</h3><p>build.gradle</p><pre><code>task hello &lt;&lt; {    println 'Hello Earth'}hello.doFirst {    println 'Hello Venus'}hello.doLast {    println 'Hello Mars'}hello &lt;&lt; {    println 'Hello Jupiter'}Output of gradle -q hello&gt; gradle -q helloHello VenusHello EarthHello MarsHello Jupiter</code></pre><p>doFirst 和 doLast 可以进行多次调用。他们分别被添加在任务的开头和结尾。当任务开始执行时这些动作会按照既定顺序进行。其中 &lt;&lt; 操作符 是 doLast 的简写方式。</p><h2 id="短标记法"><a href="#短标记法" class="headerlink" title="短标记法"></a>短标记法</h2><p>你早就注意到了吧，没错，每个任务都是一个脚本的属性，你可以访问它:</p><h3 id="以属性的方式访问任务"><a href="#以属性的方式访问任务" class="headerlink" title="以属性的方式访问任务"></a>以属性的方式访问任务</h3><p>build.gradle</p><pre><code>task hello &lt;&lt; {    println 'Hello world!'}hello.doLast {    println "Greetings from the $hello.name task."}</code></pre><p>gradle -q hello 的输出结果</p><pre><code>Output of gradle -q hello\&gt; gradle -q helloHello world!Greetings from the hello task.</code></pre><p>对于插件提供的内置任务。这尤其方便(例如:complie)</p><h2 id="增加自定义属性"><a href="#增加自定义属性" class="headerlink" title="增加自定义属性"></a>增加自定义属性</h2><p>你可以为一个任务添加额外的属性。例如,新增一个叫做 myProperty 的属性，用 ext.myProperty 的方式给他一个初始值。这样便增加了一个自定义属性。</p><h3 id="为任务增加自定义属性"><a href="#为任务增加自定义属性" class="headerlink" title="为任务增加自定义属性"></a>为任务增加自定义属性</h3><p>build.gradle</p><pre><code>task myTask {    ext.myProperty = "myValue"}task printTaskProperties &lt;&lt; {    println myTask.myProperty}</code></pre><p>gradle -q printTaskProperties 的输出结果</p><pre><code>Output of gradle -q printTaskProperties\&gt; gradle -q printTaskPropertiesmyValue</code></pre><p>自定义属性不仅仅局限于任务上，还可以做更多事情。</p><h2 id="调用-Ant-任务"><a href="#调用-Ant-任务" class="headerlink" title="调用 Ant 任务"></a>调用 Ant 任务</h2><p>Ant 任务是 Gradle 中的一等公民。Gradle 借助 Groovy 对 Ant 任务进行了优秀的整合。Gradle 自带了一个 AntBuilder，在 Gradle 中调用 Ant 任务比在 build.xml 中调用更加的方便和强大。 通过下面的例子你可以学到如何调用一个 Ant 任务以及如何与 Ant 中的属性进行通信。</p><h3 id="利用-AntBuilder-执行-ant-loadfile"><a href="#利用-AntBuilder-执行-ant-loadfile" class="headerlink" title="利用 AntBuilder 执行 ant.loadfile"></a>利用 AntBuilder 执行 ant.loadfile</h3><p>build.gradle</p><pre><code>task loadfile &lt;&lt; {    def files = file('../antLoadfileResources').listFiles().sort()    files.each { File file -&gt;        if (file.isFile()) {            ant.loadfile(srcFile: file, property: file.name)            println " *** $file.name ***"            println "${ant.properties[file.name]}"        }    }}</code></pre><p>gradle -q loadfile 的输出结果</p><pre><code>Output of gradle -q loadfile\&gt; gradle -q loadfile*** agile.manifesto.txt ***Individuals and interactions over processes and toolsWorking software over comprehensive documentationCustomer collaboration  over contract negotiationResponding to change over following a plan *** gradle.manifesto.txt ***Make the impossible possible, make the possible easy and make the easy elegant.(inspired by Moshe Feldenkrais)</code></pre><p>在你脚本里还可以利用 Ant 做更多的事情。想了解更多请参阅在 Gradle 中调用 Ant。</p><h2 id="方法抽取"><a href="#方法抽取" class="headerlink" title="方法抽取"></a>方法抽取</h2><p>Gradle 的强大要看你如何编写脚本逻辑。针对上面的例子，首先要做的就是要抽取方法。</p><h3 id="利用方法组织脚本逻辑"><a href="#利用方法组织脚本逻辑" class="headerlink" title="利用方法组织脚本逻辑"></a>利用方法组织脚本逻辑</h3><p>build.gradle</p><pre><code>task checksum &lt;&lt; {    fileList('../antLoadfileResources').each {File file -&gt;        ant.checksum(file: file, property: "cs_$file.name")        println "$file.name Checksum: ${ant.properties["cs_$file.name"]}"    }}task loadfile &lt;&lt; {    fileList('../antLoadfileResources').each {File file -&gt;        ant.loadfile(srcFile: file, property: file.name)        println "I'm fond of $file.name"    }}File[] fileList(String dir) {    file(dir).listFiles({file -&gt; file.isFile() } as FileFilter).sort()}</code></pre><p>gradle -q loadfile 的输出结果</p><pre><code>Output of gradle -q loadfile\&gt; gradle -q loadfileI'm fond of agile.manifesto.txtI'm fond of gradle.manifesto.txt</code></pre><p>在后面的章节你会看到类似出去出来的方法可以在多项目构建中的子项目中调用。无论构建逻辑多复杂，Gradle 都可以提供给你一种简便的方式来组织它们。</p><h2 id="定义默认任务"><a href="#定义默认任务" class="headerlink" title="定义默认任务"></a>定义默认任务</h2><p>Gradle 允许在脚本中定义多个默认任务。</p><h2 id="定义默认任务-1"><a href="#定义默认任务-1" class="headerlink" title="定义默认任务"></a>定义默认任务</h2><p>build.gradle</p><pre><code>defaultTasks 'clean', 'run'task clean &lt;&lt; {    println 'Default Cleaning!'}task run &lt;&lt; {    println 'Default Running!'}task other &lt;&lt; {    println "I'm not a default task!"}</code></pre><p>gradle -q 的输出结果。</p><pre><code>Output of gradle -q\&gt; gradle -qDefault Cleaning!Default Running!</code></pre><p>这与直接调用 gradle clean run 效果是一样的。在多项目构建中，每个子项目都可以指定单独的默认任务。如果子项目未进行指定将会调用父项目指定的的默认任务。</p><h2 id="Configure-by-DAG"><a href="#Configure-by-DAG" class="headerlink" title="Configure by DAG"></a>Configure by DAG</h2><p>稍后会对 Gradle 的配置阶段和运行阶段进行详细说明 配置阶段后，Gradle 会了解所有要执行的任务 Gradle 提供了一个钩子来捕获这些信息。一个例子就是可以检查已经执行的任务中有没有被释放。借由此，你可以为一些变量赋予不同的值。</p><p>在下面的例子中，为 distribution 和 release 任务赋予了不同的 version 值。</p><h3 id="依赖任务的不同输出"><a href="#依赖任务的不同输出" class="headerlink" title="依赖任务的不同输出"></a>依赖任务的不同输出</h3><p>build.gradle</p><pre><code>task distribution &lt;&lt; {    println "We build the zip with version=$version"}task release(dependsOn: 'distribution') &lt;&lt; {    println 'We release now'}gradle.taskGraph.whenReady {taskGraph -&gt;    if (taskGraph.hasTask(release)) {        version = '1.0'    } else {        version = '1.0-SNAPSHOT'    }}</code></pre><p>gradle -q distribution 的输出结果</p><pre><code>Output of gradle -q distribution\&gt; gradle -q distributionWe build the zip with version=1.0-SNAPSHOT</code></pre><p>gradle -q release 的输出结果</p><pre><code>Output of gradle -q release\&gt; gradle -q releaseWe build the zip with version=1.0We release now</code></pre><p>whenReady 会在已发布的任务之前影响到已发布任务的执行。即使已发布的任务不是主要任务(也就是说，即使这个任务不是通过命令行直接调用)</p><h1 id="Gradle-Java-构建入门"><a href="#Gradle-Java-构建入门" class="headerlink" title="Gradle Java 构建入门"></a>Gradle Java 构建入门</h1><h2 id="Java-插件"><a href="#Java-插件" class="headerlink" title="Java 插件"></a>Java 插件</h2><p>如你所见，Gradle 是一个通用工具。它可以通过脚本构建任何你想要实现的东西，真正实现开箱即用。但前提是你需要在脚本中编写好代码才行。</p><p>大部分 Java 项目基本流程都是相似的：编译源文件，进行单元测试，创建 jar 包。使用 Gradle 做这些工作不必为每个工程都编写代码。Gradle 已经提供了完美的插件来解决这些问题。插件就是 Gradle 的扩展，简而言之就是为你添加一些非常有用的默认配置。Gradle 自带了很多插件，并且你也可以很容易的编写和分享自己的插件。Java plugin 作为其中之一，为你提供了诸如编译，测试，打包等一些功能。</p><p>Java 插件为工程定义了许多默认值，如Java源文件位置。如果你遵循这些默认规则，那么你无需在你的脚本文件中书写太多代码。当然，Gradle 也允许你自定义项目中的一些规则，实际上，由于对 Java 工程的构建是基于插件的，那么你也可以完全不用插件自己编写代码来进行构建。</p><h2 id="一个基本-Java-项目"><a href="#一个基本-Java-项目" class="headerlink" title="一个基本 Java 项目"></a>一个基本 Java 项目</h2><p>来看一下下面这个小例子，想用 Java 插件，只需增加如下代码到你的脚本里。</p><h3 id="采用-Java-插件"><a href="#采用-Java-插件" class="headerlink" title="采用 Java 插件"></a>采用 Java 插件</h3><pre><code>build.gradleapply plugin: 'java'</code></pre><p>备注:示例代码可以在 Gralde 发行包中的 samples/java/quickstart 下找到。</p><p>定义一个 Java 项目只需如此而已。这将会为你添加 Java 插件及其一些内置任务。</p><blockquote><p>添加了哪些任务?</p></blockquote><blockquote><p>你可以运行 gradle tasks 列出任务列表。这样便可以看到 Java 插件为你添加了哪些任务。</p></blockquote><p>标准目录结构如下:</p><pre><code>project      +build      +src/main/java      +src/main/resources      +src/test/java      +src/test/resources  </code></pre><p>Gradle 默认会从 <code>src/main/java</code> 搜寻打包源码，在 <code>src/test/java</code> 下搜寻测试源码。并且 <code>src/main/resources</code> 下的所有文件按都会被打包，所有 <code>src/test/resources</code> 下的文件 都会被添加到类路径用以执行测试。所有文件都输出到 build 下，打包的文件输出到 build/libs 下。</p><h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><p>Java 插件为你添加了众多任务。但是它们只是在你需要构建项目的时候才能发挥作用。最常用的就是 build 任务,这会构建整个项目。当你执行 gradle build 时，Gralde 会编译并执行单元测试，并且将 <code>src/main/*</code> 下面 class 和资源文件打包。</p><h3 id="构建-Java-项目"><a href="#构建-Java-项目" class="headerlink" title="构建 Java 项目"></a>构建 Java 项目</h3><p>运行 gradle build 的输出结果</p><pre><code>Output of gradle build&gt; gradle build:compileJava:processResources:classes:jar:assemble:compileTestJava:processTestResources:testClasses:test:check:buildBUILD SUCCESSFULTotal time: 1 secs</code></pre><p>其余一些较常用的任务有如下几个:</p><h4 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h4><p>删除 build 目录以及所有构建完成的文件。</p><h4 id="assemble"><a href="#assemble" class="headerlink" title="assemble"></a>assemble</h4><p>编译并打包 jar 文件，但不会执行单元测试。一些其他插件可能会增强这个任务的功能。例如，如果采用了 War 插件，这个任务便会为你的项目打出 War 包。</p><h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p>编译并测试代码。一些其他插件也可能会增强这个任务的功能。例如，如果采用了 Code-quality 插件，这个任务会额外执行 Checkstyle。</p><h3 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h3><p>通常，一个 Java 项目拥有许多外部依赖。你需要告诉 Gradle 如何找到并引用这些外部文件。在 Gradle 中通常 Jar 包都存在于仓库中。仓库可以用来搜寻依赖或发布项目产物。下面是一个采用 Maven 仓库的例子。</p><h3 id="添加-Maven-仓库"><a href="#添加-Maven-仓库" class="headerlink" title="添加 Maven 仓库"></a>添加 Maven 仓库</h3><pre><code>build.gradlerepositories {    mavenCentral()}</code></pre><p>添加依赖。这里声明了编译期所需依赖 commons-collections 和测试期所需依赖 junit。</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><pre><code>build.gradledependencies {    compile group: 'commons-collections', name: 'commons-collections', version: '3.2'    testCompile group: 'junit', name: 'junit', version: '4.+'}</code></pre><h3 id="自定义项目"><a href="#自定义项目" class="headerlink" title="自定义项目"></a>自定义项目</h3><p>Java 插件为你的项目添加了众多默认配置。这些默认值通常对于一个普通项目来说已经足够了。但如果你觉得不适用修改起来也很简单。看下面的例子，我们为 Java 项目指定了版本号以及所用的 JDK 版本，并且添加一些属性到 mainfest 中。</p><h3 id="自定义-MANIFEST-MF"><a href="#自定义-MANIFEST-MF" class="headerlink" title="自定义 MANIFEST.MF"></a>自定义 MANIFEST.MF</h3><pre><code>build.gradlesourceCompatibility = 1.5version = '1.0'jar {    manifest {        attributes 'Implementation-Title': 'Gradle Quickstart', 'Implementation-Version': version    }}</code></pre><blockquote><p>都有哪些可用属性?</p></blockquote><blockquote><p>可以执行 gradle propertie s来得到项目的属性列表。用这条命令可以看到插件添加的属性以及默认值。</p></blockquote><p>Java 插件添加的都是一些普通任务，如同他们写在 Build 文件中一样。这意味着前面章节展示的机制都可以用来修改这些任务的行为。例如，可以设置任务的属性，添加任务行为，更改任务依赖，甚至是重写覆盖整个任务。在下面的例子中，我们将修改 test 任务，这是一个 Test 类型任务。让我们来在它执行时为它添加一些系统属性。</p><h3 id="为-test-添加系统属性"><a href="#为-test-添加系统属性" class="headerlink" title="为 test 添加系统属性"></a>为 test 添加系统属性</h3><pre><code>build.gradletest {    systemProperties 'property': 'value'}</code></pre><h3 id="发布-jar-包"><a href="#发布-jar-包" class="headerlink" title="发布 jar 包"></a>发布 jar 包</h3><p>如何发布 jar 包?你需要告诉 Gradle 发布到到哪。在 Gradle 中 jar 包通常被发布到某个仓库中。在下面的例子中，我们会将 jar 包发布到本地目录。当然你也可以发布到远程仓库或多个远程仓库中。</p><h3 id="发布-jar-包-1"><a href="#发布-jar-包-1" class="headerlink" title="发布 jar 包"></a>发布 jar 包</h3><pre><code>build.gradleuploadArchives {    repositories {       flatDir {           dirs 'repos'       }    }}</code></pre><p>执行 gradle uploadArchives 以发布 jar 包。</p><h3 id="创建-Eclipse-文件"><a href="#创建-Eclipse-文件" class="headerlink" title="创建 Eclipse 文件"></a>创建 Eclipse 文件</h3><p>若要把项目导入 Eclipse 中，你需要添加另外一个插件到你的脚本文件中。</p><h3 id="Eclipse-plugin"><a href="#Eclipse-plugin" class="headerlink" title="Eclipse plugin"></a>Eclipse plugin</h3><pre><code>build.gradleapply plugin: 'eclipse'</code></pre><p>执行 gradle eclipse 来生成 Eclipse 项目文件。</p><h3 id="示例汇总"><a href="#示例汇总" class="headerlink" title="示例汇总"></a>示例汇总</h3><p>这是示例代码汇总得到的一个完整脚本：</p><h3 id="Java-示例-一个完整构建脚本"><a href="#Java-示例-一个完整构建脚本" class="headerlink" title="Java 示例 - 一个完整构建脚本"></a>Java 示例 - 一个完整构建脚本</h3><pre><code>build.gradleapply plugin: 'java'apply plugin: 'eclipse'sourceCompatibility = 1.5version = '1.0'jar {    manifest {        attributes 'Implementation-Title': 'Gradle Quickstart', 'Implementation-Version': version    }}repositories {    mavenCentral()}dependencies {    compile group: 'commons-collections', name: 'commons-collections', version: '3.2'    testCompile group: 'junit', name: 'junit', version: '4.+'}test {    systemProperties 'property': 'value'}uploadArchives {    repositories {       flatDir {           dirs 'repos'       }    }}</code></pre><h2 id="多项目构建-1"><a href="#多项目构建-1" class="headerlink" title="多项目构建"></a>多项目构建</h2><p>现在来看一个典型的多项目构建的例子。项目结构如下：</p><h3 id="多项目构建-项目结构"><a href="#多项目构建-项目结构" class="headerlink" title="多项目构建-项目结构"></a>多项目构建-项目结构</h3><pre><code>Build layoutmultiproject/  api/  services/webservice/  shared/备注: 本示例代码可在 Gradle 发行包的 samples/java/multiproject 位置找到</code></pre><p>此处有三个工程。api 工程用来生成给客户端用的 jar 文件，这个 jar 文件可以为 XML webservice 提供 Java 客户端。webservice 是一个 web 应用，生成 XML。shared 工程包含的是前述两个工程共用的代码。</p><h3 id="多项目构建定义"><a href="#多项目构建定义" class="headerlink" title="多项目构建定义"></a>多项目构建定义</h3><p>定义一个多项目构建工程需要在根目录(本例中与 multiproject 同级)创建一个<em>setting</em> 配置文件来指明构建包含哪些项目。并且这个文件必需叫 settings.gradle 本例的配置文件如下:</p><h3 id="多项目构建中的-settings-gradle"><a href="#多项目构建中的-settings-gradle" class="headerlink" title="多项目构建中的 settings.gradle"></a>多项目构建中的 settings.gradle</h3><pre><code>settings.gradleinclude "shared", "api", "services:webservice", "services:shared"</code></pre><h3 id="公共配置"><a href="#公共配置" class="headerlink" title="公共配置"></a>公共配置</h3><p>对多项目构建而言，总有一些共同的配置.在本例中，我们会在根项目上采用配置注入的方式定义一些公共配置。根项目就像一个容器，子项目会迭代访问它的配置并注入到自己的配置中。这样我们就可以简单的为所有工程定义主配置单了：</p><h3 id="多项目构建-公共配置"><a href="#多项目构建-公共配置" class="headerlink" title="多项目构建-公共配置"></a>多项目构建-公共配置</h3><pre><code>build.gradlesubprojects {    apply plugin: 'java'    apply plugin: 'eclipse-wtp'    repositories {       mavenCentral()    }    dependencies {        testCompile 'junit:junit:4.11'    }    version = '1.0'    jar {        manifest.attributes provider: 'gradle'    }}</code></pre><p>值得注意的是我们为每个子项目都应用了 Java 插件。这意味着我们在前面章节学习的内容在子项目中也都是可用的。所以你可以在根项目目录进行编译，测试，打包等所有操作。</p><h3 id="工程依赖"><a href="#工程依赖" class="headerlink" title="工程依赖"></a>工程依赖</h3><p>同一个构建中可以建立工程依赖，一个工程的 jar 包可以提供给另外一个工程使用。例如我们可以让 api 工程以依赖于 shared 工程的 jar 包。这样 Gradle 在构建 api 之前总是会先构建 shared 工程。</p><h3 id="多项目构建-工程依赖"><a href="#多项目构建-工程依赖" class="headerlink" title="多项目构建-工程依赖"></a>多项目构建-工程依赖</h3><pre><code>api/build.gradledependencies {    compile project(':shared')}</code></pre><h3 id="多项目构建-发布"><a href="#多项目构建-发布" class="headerlink" title="多项目构建-发布"></a>多项目构建-发布</h3><pre><code>api/build.gradletask dist(type: Zip) {    dependsOn spiJar    from 'src/dist'    into('libs') {        from spiJar.archivePath        from configurations.runtime    }}artifacts {   archives dist}</code></pre><h1 id="Gradle-依赖管理基础"><a href="#Gradle-依赖管理基础" class="headerlink" title="Gradle 依赖管理基础"></a>Gradle 依赖管理基础</h1><h2 id="什么是依赖管理"><a href="#什么是依赖管理" class="headerlink" title="什么是依赖管理?"></a>什么是依赖管理?</h2><p>通俗来讲，依赖管理由如下两部分组成。首先，Gradle 需要知道项目构建或运行所需要的一些文件，以便于找到这些需要的文件。我们称这些输入的文件为项目的依赖。其次，你可能需要构建完成后自动上传到某个地方。我们称这些输出为发布。下面来仔细介绍一下这两部分：</p><p>大部分工程都不太可能完全自给自足，一般你都会用到其他工程的文件。比如需要 Hibernate 就得把它的类库加进来，比如测试的时候可能需要某些额外 jar 包，例如 JDBC 驱动或 Ehcache 之类的 Jar 包。</p><p>这些文件就是工程的依赖。Gradle 需要你告诉它工程的依赖是什么，它们在哪，然后帮你加入构建中。依赖可能需要去远程库下载，比如 Maven 或者 Ivy 库。也可以是本地库，甚至可能是另一个工程。我们称这个过程叫<em>依赖解决</em>。</p><p>通常，依赖的自身也有依赖。例如，Hibernate 核心类库就依赖于一些其他的类库。所以，当 Gradle 构建你的工程时，会去找到这些依赖。我们称之为<em>依赖传递</em>。</p><p>大部分工程构建的主要目的是脱离工程使用。例如，生成 jar 包，包括源代码、文档等，然后发布出去。</p><p>这些输出的文件构成了项目的发布内容。Gralde 也会为你分担这些工作。你声明了发布到到哪，Gradle 就会发布到哪。“发布”的意思就是你想做什么。比如，复制到某个目录，上传到 Maven 或 Ivy 仓库。或者在其它项目里使用，这些都可以称之为<em>发行</em>。</p><h2 id="依赖声明"><a href="#依赖声明" class="headerlink" title="依赖声明"></a>依赖声明</h2><p>来看一下这个脚本里声明依赖的部分：</p><h3 id="声明依赖"><a href="#声明依赖" class="headerlink" title="声明依赖"></a>声明依赖</h3><p>build.gradle</p><pre><code>apply plugin: 'java'repositories {    mavenCentral()}dependencies {    compile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'    testCompile group: 'junit', name: 'junit', version: '4.+'}</code></pre><p>这是什么意思呢？这段脚本是这么个意思。首先，Hibernate-core.3.6.7.final.jar 这货是编译期必需的依赖。并且这货相关的依赖也会一并被加载进来，该段脚本同时还声明项目测试阶段需要 4.0 版本以上的 Junit。同时告诉 Gradle 可以去 Maven 中央仓库去找这些依赖。下面的章节会进行更详细的描述。</p><h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><p>Gradle 中依赖以组的形式来划分不同的<em>配置<em>。每个配置都只是一组指定的依赖。我们称之为</em>依赖配置</em> 。你也可以借由此声明外部依赖。后面我们会了解到，这也可用用来声明项目的发布。</p><p>Java 插件定义了许多标准配置项。这些配置项形成了插件本身的 classpath。</p><h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><p>编译范围依赖在所有的 classpath 中可用，同时它们也会被打包</p><h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><p>runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要 JDBC API JAR，而只有在运行的时候才需要 JDBC 驱动实现</p><h3 id="testCompile"><a href="#testCompile" class="headerlink" title="testCompile"></a>testCompile</h3><p>测试器编译需要的附加依赖</p><h3 id="testRuntime"><a href="#testRuntime" class="headerlink" title="testRuntime"></a>testRuntime</h3><p>测试运行期需要</p><p>不同的插件提供了不同的标准配置，你甚至也可以定义属于自己的配置项。</p><h2 id="外部依赖-1"><a href="#外部依赖-1" class="headerlink" title="外部依赖"></a>外部依赖</h2><p>依赖的类型有很多种，其中有一种类型称之为<em>外部依赖</em>。这种依赖由外部构建或者在不同的仓库中，例如 Maven 中央仓库或 Ivy 仓库中抑或是本地文件系统的某个目录中。</p><p>定义外部依赖需要像下面这样进行依赖配置</p><h3 id="定义外部依赖"><a href="#定义外部依赖" class="headerlink" title="定义外部依赖"></a>定义外部依赖</h3><p>build.gradle</p><pre><code>dependencies {    compile group: 'org.hibernate', name: 'hibernate-core', version: '3.6.7.Final'}</code></pre><p>外部依赖包含 group，name 和 version 几个属性。根据选取仓库的不同，group 和 version 也可能是可选的。</p><p>当然，也有一种更加简洁的方式来声明外部依赖。采用：将三个属性拼接在一起即可。”group:name:version”</p><h3 id="快速定义外部依赖"><a href="#快速定义外部依赖" class="headerlink" title="快速定义外部依赖"></a>快速定义外部依赖</h3><p>build.gradle</p><pre><code>dependencies {    compile 'org.hibernate:hibernate-core:3.6.7.Final'}</code></pre><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>Gradle 是在一个被称之为<em>仓库</em>的地方找寻所需的外部依赖。仓库即是一个按 group，name 和 version 规则进行存储的一些文件。Gradle 可以支持不同的仓库存储格式，如 Maven 和 Ivy，并且还提供多种与仓库进行通信的方式，如通过本地文件系统或 HTTP。</p><p>默认情况下，Gradle 没有定义任何仓库，你需要在使用外部依赖之前至少定义一个仓库，例如 Maven 中央仓库。</p><h3 id="使用-Maven-中央仓库"><a href="#使用-Maven-中央仓库" class="headerlink" title="使用 Maven 中央仓库"></a>使用 Maven 中央仓库</h3><p>build.gradle</p><pre><code>repositories {    mavenCentral()}</code></pre><p>或者其它远程 Maven 仓库：</p><h3 id="使用-Maven-远程仓库"><a href="#使用-Maven-远程仓库" class="headerlink" title="使用 Maven 远程仓库"></a>使用 Maven 远程仓库</h3><p>build.gradle</p><pre><code>repositories {    maven {        url "http://repo.mycompany.com/maven2"    }}</code></pre><p>或者采用 Ivy 远程仓库</p><h3 id="采用-Ivy-远程仓库"><a href="#采用-Ivy-远程仓库" class="headerlink" title="采用 Ivy 远程仓库"></a>采用 Ivy 远程仓库</h3><p>build.gradle</p><pre><code>repositories {    ivy {        url "http://repo.mycompany.com/repo"    }}</code></pre><p>或者在指定本地文件系统构建的库。</p><h3 id="采用本地-Ivy-目录"><a href="#采用本地-Ivy-目录" class="headerlink" title="采用本地 Ivy 目录"></a>采用本地 Ivy 目录</h3><p>build.gradle</p><pre><code>repositories {    ivy {        // URL can refer to a local directory        url "../local-repo"    }}</code></pre><p>一个项目可以采用多个库。Gradle 会按照顺序从各个库里寻找所需的依赖文件，并且一旦找到第一个便停止搜索。</p><h2 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h2><p>依赖配置也被用于发布文件我们称之为<em>打包发布</em>或<em>发布</em>。</p><p>插件对于打包提供了完美的支持，所以通常而言无需特别告诉 Gradle 需要做什么。但是你需要告诉 Gradle 发布到哪里。这就需要在 uploadArchives 任务中添加一个仓库。下面的例子是如何发布到远程 Ivy 仓库的：</p><h3 id="发布到-Ivy-仓库"><a href="#发布到-Ivy-仓库" class="headerlink" title="发布到 Ivy 仓库"></a>发布到 Ivy 仓库</h3><p>build.gradle</p><pre><code>uploadArchives {    repositories {        ivy {            credentials {                username "username"                password "pw"            }            url "http://repo.mycompany.com"        }    }}</code></pre><p>执行 <strong>gradle uploadArchives</strong>，Gradle 便会构建并上传你的 jar 包，同时会生成一个 ivy.xml 一起上传到目标仓库。</p><p>当然你也可以发布到 Maven 仓库中。语法只需稍微一换就可以了。</p><p>p.s：发布到 Maven 仓库你需要 Maven 插件的支持，当然，Gradle 也会同时产生 pom.xml 一起上传到目标仓库。</p><h3 id="发布到-Maven-仓库"><a href="#发布到-Maven-仓库" class="headerlink" title="发布到 Maven 仓库"></a>发布到 Maven 仓库</h3><p>build.gradle</p><pre><code>apply plugin: 'maven'uploadArchives {    repositories {        mavenDeployer {            repository(url: "file://localhost/tmp/myRepo/")        }    }}</code></pre><h1 id="Gradle-Groovy-快速入门"><a href="#Gradle-Groovy-快速入门" class="headerlink" title="Gradle Groovy 快速入门"></a>Gradle Groovy 快速入门</h1><p>要构建一个 Groovy 项目，你需要使用 Groovy 插件。该插件扩展了 Java 插件，对你的项目增加了 Groovy 的编译功能. 你的项目可以包含 Groovy 源码，Java 源码，或者两者都包含。在其他各方面，Groovy 项目与我们在第七章 Java 快速入门中所看到的Java 项目几乎相同。</p><h2 id="一个基本的-Groovy-项目"><a href="#一个基本的-Groovy-项目" class="headerlink" title="一个基本的 Groovy 项目"></a>一个基本的 Groovy 项目</h2><p>要使用 Groovy 插件，你需要在构建脚本文件当中添加以下内容：</p><p>例子 Groovy plugin</p><p>build.gradle</p><pre><code>apply plugin: 'groovy'   </code></pre><p>注意： 此例子的代码可以在 Gradle 的二进制文件或源码中的 <code>samples/groovy/quickstart</code> 里看到。</p><p>这段代码同时会将 Java 插件应用到 project 中，如果 Java 插件还没被应用的话。Groovy 插件继承了 compile 任务 ，在 <code>src/main/groovy</code> 目录中查找源文件；且继承了 compileTest 任务，在 <code>src/test/groovy</code> 目录中查找测试的源文件。这些编译任务对这些目录使用了联合编译，这意味着它们可以同时包含 java 和 groovy 源文件。</p><p>要使用 groovy 编译任务，还必须声明要使用的 Groovy 版本以及从哪里获取 Groovy 库。你可以通过在 groovy 配置中添加依赖来完成。compile 配置继承了这个依赖,从而在编译 Groovy和 Java 源代码时，groovy 库也会被包含在类路径中。下面例子中，我们会使用 Maven 中央仓库中的 Groovy 2.2.0 版本。</p><p>例子 Dependency on Groovy 2.2.0</p><p>build.gradle</p><pre><code>repositories {    mavenCentral()}dependencies {    compile 'org.codehaus.groovy:groovy-all:2.2.0'}  </code></pre><p>这里是我们写好的构建文件：</p><p>例子 Groovy example - complete build file</p><p>build.gradle</p><pre><code>apply plugin: 'eclipse'apply plugin: 'groovy'repositories {    mavenCentral()}dependencies {    compile 'org.codehaus.groovy:groovy-all:2.2.0'    testCompile 'junit:junit:4.11'}  </code></pre><p>运行 gradle build 将会对你的项目进行编译，测试和打成 jar 包。</p><h1 id="Gradle-Web-工程构建"><a href="#Gradle-Web-工程构建" class="headerlink" title="Gradle Web 工程构建"></a>Gradle Web 工程构建</h1><h2 id="打-War-包"><a href="#打-War-包" class="headerlink" title="打 War 包"></a>打 War 包</h2><p>需要打包 War 文件，需要在脚本中使用 War plugin：</p><h3 id="War-plugin"><a href="#War-plugin" class="headerlink" title="War plugin"></a>War plugin</h3><p>build.gradle</p><pre><code>apply plugin: 'war'</code></pre><p>备注：本示例代码可以在 Gradle 发行包中的 samples/webApplication/quickstart 路径下找到。</p><p>由于继承自 Java 插件，当你执行 <strong>gradle build</strong> 时，将会编译、测试、打包你的工程。Gradle 会在 <code>src/main/webapp</code> 下寻找 Web 工程文件。编译后的 classes 文件以及运行时依赖也都会被包含在 War 包中。</p><blockquote><p>Groovy web构建</p></blockquote><blockquote><p>在一个工程中你可以采用多个插件。比如你可以在 web 工程中同时使用 War plugin 和 Groovy plugin。插件会将 Gradle 依赖添加到你的 War 包中。</p></blockquote><h2 id="Web-工程启动"><a href="#Web-工程启动" class="headerlink" title="Web 工程启动"></a>Web 工程启动</h2><p>要启动 Web 工程，只需使用 Jetty plugin 即可：</p><h3 id="采用-Jetty-plugin-启动-web-工程"><a href="#采用-Jetty-plugin-启动-web-工程" class="headerlink" title="采用 Jetty plugin 启动 web 工程"></a>采用 Jetty plugin 启动 web 工程</h3><p>build.gradle</p><pre><code>apply plugin: 'jetty'</code></pre><p>由于 Jetty plugin 继承自 War plugin。调用 gradle jettyRun 将会把你的工程启动部署到 jetty 容器中。调用 gradle jettyRunWar 会打包并启动部署到 jetty 容器中。</p><p>待添加：使用哪个 URL，配置端口，使用源文件的地方，可编辑你的文件，以及重新加载的内容。</p><h1 id="Gradle-Gradle-命令行的基本使用"><a href="#Gradle-Gradle-命令行的基本使用" class="headerlink" title="Gradle Gradle 命令行的基本使用"></a>Gradle Gradle 命令行的基本使用</h1><h2 id="多任务调用"><a href="#多任务调用" class="headerlink" title="多任务调用"></a>多任务调用</h2><p>你可以以列表的形式在命令行中一次调用多个任务。例如 gradle compile test 命令会依次调用，并且每个任务仅会被调用一次。compile 和 test 任务以及它们的依赖任务。无论它们是否被包含在脚本中：即无论是以命令行的形式定义的任务还是依赖于其它任务都会被调用执行。来看下面的例子。</p><p>下面定义了四个任务。dist 和 test 都依赖于 compile，只用当 compile 被调用之后才会调用 gradle dist test 任务。</p><h3 id="任务依赖-1"><a href="#任务依赖-1" class="headerlink" title="任务依赖"></a>任务依赖</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGViNzVjNTIzOGU3ZmM5Y2E5MjQ3NTY3ZTk4NDUyODNfY3B0ektKQ1Q1QjBXaVd4dTRoekhhakJTRmlUelJGdGJfVG9rZW46Ym94Y25UNnoxaFBKUmxTYlBBUk41UkJQM01jXzE2MjcxNDczNzQ6MTYyNzE1MDk3NF9WNA" alt="img"></p><h3 id="多任务调用-1"><a href="#多任务调用-1" class="headerlink" title="多任务调用"></a>多任务调用</h3><p>build.gradle</p><pre><code>task compile &lt;&lt; {    println 'compiling source'}task compileTest(dependsOn: compile) &lt;&lt; {    println 'compiling unit tests'}task test(dependsOn: [compile, compileTest]) &lt;&lt; {    println 'running unit tests'}task dist(dependsOn: [compile, test]) &lt;&lt; {    println 'building the distribution'}</code></pre><p><strong>gradle dist test</strong> 的输出结果。</p><pre><code>\&gt; gradle dist test:compilecompiling source:compileTestcompiling unit tests:testrunning unit tests:distbuilding the distributionBUILD SUCCESSFULTotal time: 1 secs</code></pre><p>由于每个任务仅会被调用一次，所以调用 <strong>gradle test test</strong> 与调用 <strong>gradle test</strong> 效果是相同的。</p><h2 id="排除任务"><a href="#排除任务" class="headerlink" title="排除任务"></a>排除任务</h2><p>你可以用命令行选项 -x 来排除某些任务，让我们用上面的例子来示范一下。</p><h3 id="排除任务-1"><a href="#排除任务-1" class="headerlink" title="排除任务"></a>排除任务</h3><p><strong>gradle dist -x test</strong> 的输出结果。</p><pre><code>\&gt; gradle dist -x test:compilecompiling source:distbuilding the distributionBUILD SUCCESSFULTotal time: 1 secs</code></pre><p>可以看到，test 任务并没有被调用，即使他是 dist 任务的依赖。同时 test 任务的依赖任务 compileTest 也没有被调用，而像 compile 被 test 和其它任务同时依赖的任务仍然会被调用。</p><h2 id="失败后继续执行"><a href="#失败后继续执行" class="headerlink" title="失败后继续执行"></a>失败后继续执行</h2><p>默认情况下只要有任务调用失败 Gradle 就是中断执行。这可能会使调用过程更快，但那些后面隐藏的错误不会被发现。所以你可以使用–continue 在一次调用中尽可能多的发现所有问题。</p><p>采用了–continue 选项，Gradle会调用<em>每一个</em>任务以及它们依赖的任务。而不是一旦出现错误就会中断执行。所有错误信息都会在最后被列出来。</p><p>一旦某个任务执行失败,那么所有依赖于该任务的子任务都不会被调用。例如由于 test 任务依赖于 complie 任务，所以如果 compile 调用出错，test 便不会被直接或间接调用。</p><h2 id="简化任务名"><a href="#简化任务名" class="headerlink" title="简化任务名"></a>简化任务名</h2><p>当你试图调用某个任务的时候，无需输入任务的全名。只需提供足够的可以唯一区分出该任务的字符即可。例如，上面的例子你也可以这么写。用 <strong>gradle di</strong> 来直接调用 dist 任务。</p><h3 id="简化任务名-1"><a href="#简化任务名-1" class="headerlink" title="简化任务名"></a>简化任务名</h3><p><strong>gradle di</strong> 的输出结果</p><pre><code>\&gt; gradle di:compilecompiling source:compileTestcompiling unit tests:testrunning unit tests:distbuilding the distributionBUILD SUCCESSFULTotal time: 1 secs</code></pre><p>你也可以用驼峰命名的任务中每个单词的首字母进行调用。例如，可以执行 <strong>gradle compTest</strong> or even <strong>gradle cT</strong> 来调用 compileTest 任务。</p><h3 id="简化驼峰任务名"><a href="#简化驼峰任务名" class="headerlink" title="简化驼峰任务名"></a>简化驼峰任务名</h3><p><strong>gradle cT</strong> 的输出结果。</p><pre><code>\&gt; gradle cT:compilecompiling source:compileTestcompiling unit testsBUILD SUCCESSFULTotal time: 1 secs</code></pre><p>简化后你仍然可以使用 -x 参数。</p><h2 id="选择构建位置"><a href="#选择构建位置" class="headerlink" title="选择构建位置"></a>选择构建位置</h2><p>调用 gradle 时，默认情况下总是会构建当前目录下的文件，可以使用-b 参数选择构建的文件，并且当你使用此参数时settings。gradle 将不会生效,看下面的例子:</p><h3 id="选择文件构建"><a href="#选择文件构建" class="headerlink" title="选择文件构建"></a>选择文件构建</h3><p>subdir/myproject.gradle</p><pre><code>task hello &lt;&lt; {    println "using build file '$buildFile.name' in '$buildFile.parentFile.name'."}</code></pre><p><strong>gradle -q -b subdir/myproject.gradle hello</strong> 的输出结果</p><pre><code>Output of gradle -q -b subdir/myproject.gradle hello\&gt; gradle -q -b subdir/myproject.gradle hellousing build file 'myproject.gradle' in 'subdir'.</code></pre><p>另外，你可以使用 -p 参数来指定构建的目录，例如在多项目构建中你可以用 -p 来替代 -b 参数。</p><h3 id="选择构建目录"><a href="#选择构建目录" class="headerlink" title="选择构建目录"></a>选择构建目录</h3><p><strong>gradle -q -p subdir hello</strong> 的输出结果</p><pre><code>\&gt; gradle -q -p subdir hellousing build file 'build.gradle' in 'subdir'.</code></pre><h2 id="获取构建信息"><a href="#获取构建信息" class="headerlink" title="获取构建信息"></a>获取构建信息</h2><p>Gradle 提供了许多内置任务来收集构建信息。这些内置任务对于了解依赖结构以及解决问题都是很有帮助的。</p><h3 id="项目列表"><a href="#项目列表" class="headerlink" title="项目列表"></a>项目列表</h3><p>执行 <strong>gradle projects</strong> 会为你列出子项目名称列表。如下例。</p><h3 id="收集项目信息"><a href="#收集项目信息" class="headerlink" title="收集项目信息"></a>收集项目信息</h3><p><strong>gradle -q projects</strong> 的输出结果</p><pre><code>\&gt; gradle -q projects\------------------------------------------------------------Root project\------------------------------------------------------------Root project 'projectReports'+--- Project ':api' - The shared API for the application\--- Project ':webapp' - The Web application implementationTo see a list of the tasks of a project, run gradle &lt;project-path&gt;:tasksFor example, try running gradle :api:tasks</code></pre><p>这份报告展示了每个项目的描述信息。当然你可以在项目中用 description 属性来指定这些描述信息。</p><h3 id="为项目添加描述信息"><a href="#为项目添加描述信息" class="headerlink" title="为项目添加描述信息."></a>为项目添加描述信息.</h3><p>build.gradle</p><pre><code>description = 'The shared API for the application'</code></pre><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>执行 gradle tasks 会列出项目中所有任务。这会显示项目中所有的默认任务以及每个任务的描述。如下例</p><h3 id="获取任务信息"><a href="#获取任务信息" class="headerlink" title="获取任务信息"></a>获取任务信息</h3><p><strong>gradle -q tasks</strong>的输出结果：</p><pre><code>\&gt; gradle -q tasks\------------------------------------------------------------All tasks runnable from root project\------------------------------------------------------------Default tasks: distsBuild tasks\-----------clean - Deletes the build directory (build)dists - Builds the distributionlibs - Builds the JARBuild Setup tasks\-----------------init - Initializes a new Gradle build. [incubating]wrapper - Generates Gradle wrapper files. [incubating]Help tasks\----------dependencies - Displays all dependencies declared in root project 'projectReports'.dependencyInsight - Displays the insight into a specific dependency in root project 'projectReports'.help - Displays a help messageprojects - Displays the sub-projects of root project 'projectReports'.properties - Displays the properties of root project 'projectReports'.tasks - Displays the tasks runnable from root project 'projectReports' (some of the displayed tasks may belong to subprojects).To see all tasks and more detail, run with --all.</code></pre><p>默认情况下，这只会显示那些被分组的任务。你可以通过为任务设置 group 属性和 description 来把 这些信息展示到结果中。</p><h3 id="更改任务报告内容"><a href="#更改任务报告内容" class="headerlink" title="更改任务报告内容"></a>更改任务报告内容</h3><p>build.gradle</p><pre><code>dists {    description = 'Builds the distribution'    group = 'build'}</code></pre><p>当然你也可以用–all 参数来收集更多任务信息。这会列出项目中所有任务以及任务之间的依赖关系。</p><h3 id="Obtaining-more-information-about-tasks"><a href="#Obtaining-more-information-about-tasks" class="headerlink" title="Obtaining more information about tasks"></a>Obtaining more information about tasks</h3><p><strong>gradle -q tasks –all</strong>的输出结果：</p><pre><code>\&gt; gradle -q tasks --all\------------------------------------------------------------All tasks runnable from root project\------------------------------------------------------------Default tasks: distsBuild tasks\-----------clean - Deletes the build directory (build)api:clean - Deletes the build directory (build)webapp:clean - Deletes the build directory (build)dists - Builds the distribution [api:libs, webapp:libs]    docs - Builds the documentationapi:libs - Builds the JAR    api:compile - Compiles the source fileswebapp:libs - Builds the JAR [api:libs]    webapp:compile - Compiles the source filesBuild Setup tasks\-----------------init - Initializes a new Gradle build. [incubating]wrapper - Generates Gradle wrapper files. [incubating]Help tasks\----------dependencies - Displays all dependencies declared in root project 'projectReports'.dependencyInsight - Displays the insight into a specific dependency in root project 'projectReports'.help - Displays a help messageprojects - Displays the sub-projects of root project 'projectReports'.properties - Displays the properties of root project 'projectReports'.tasks - Displays the tasks runnable from root project 'projectReports' (some of the displayed tasks may belong to subprojects).</code></pre><h3 id="获取任务帮助信息"><a href="#获取任务帮助信息" class="headerlink" title="获取任务帮助信息"></a>获取任务帮助信息</h3><p>执行 <strong>gradle help –task someTask</strong> 可以显示指定任务的详细信息。或者多项目构建中相同任务名称的所有任务的信息。如下例。</p><h3 id="获取任务帮助"><a href="#获取任务帮助" class="headerlink" title="获取任务帮助"></a>获取任务帮助</h3><p><strong>gradle -q help –task libs</strong> 的输出结果</p><pre><code>\&gt; gradle -q help --task libsDetailed task information for libsPaths     :api:libs     :webapp:libsType     Task (org.gradle.api.Task)Description     Builds the JAR</code></pre><p>这些结果包含了任务的路径、类型以及描述信息等。</p><h3 id="获取依赖列表"><a href="#获取依赖列表" class="headerlink" title="获取依赖列表"></a>获取依赖列表</h3><p>执行 <strong>gradle dependencies</strong> 会列出项目的依赖列表，所有依赖会根据任务区分，以树型结构展示出来。如下例。</p><h3 id="获取依赖信息"><a href="#获取依赖信息" class="headerlink" title="获取依赖信息"></a>获取依赖信息</h3><p><strong>gradle -q dependencies api:dependencies webapp:dependencies</strong> 的输出结果</p><pre><code>\&gt; gradle -q dependencies api:dependencies webapp:dependencies\------------------------------------------------------------Root project\------------------------------------------------------------No configurations\------------------------------------------------------------Project :api - The shared API for the application\------------------------------------------------------------compile\--- org.codehaus.groovy:groovy-all:2.2.0testCompile\--- junit:junit:4.11     \--- org.hamcrest:hamcrest-core:1.3\------------------------------------------------------------Project :webapp - The Web application implementation\------------------------------------------------------------compile+--- project :api|    \--- org.codehaus.groovy:groovy-all:2.2.0\--- commons-io:commons-io:1.2testCompileNo dependencies</code></pre><p>虽然输出结果很多，但这对于了解构建任务十分有用，当然你可以通过<strong>–configuration</strong> 参数来查看 指定构建任务的依赖情况。</p><h3 id="过滤依赖信息"><a href="#过滤依赖信息" class="headerlink" title="过滤依赖信息"></a>过滤依赖信息</h3><p><strong>gradle -q api:dependencies –configuration testCompile</strong> 的输出结果</p><pre><code>\&gt; gradle -q api:dependencies --configuration testCompile\------------------------------------------------------------Project :api - The shared API for the application\------------------------------------------------------------testCompile\--- junit:junit:4.11     \--- org.hamcrest:hamcrest-core:1.3</code></pre><h3 id="查看特定依赖"><a href="#查看特定依赖" class="headerlink" title="查看特定依赖"></a>查看特定依赖</h3><p>执行 Running gradle dependencyInsight 可以查看指定的依赖情况。如下例。</p><h3 id="获取特定依赖"><a href="#获取特定依赖" class="headerlink" title="获取特定依赖"></a>获取特定依赖</h3><p><strong>gradle -q webapp:dependencyInsight –dependency groovy –configuration compile</strong> 的输出结果</p><pre><code>\&gt; gradle -q webapp:dependencyInsight --dependency groovy --configuration compileorg.codehaus.groovy:groovy-all:2.2.0\--- project :api     \--- compile</code></pre><p>这对于了解依赖关系、了解为何选择此版本作为依赖十分有用。了解更多请参阅<a href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.api.tasks.diagnostics.DependencyInsightReportTask.html" target="_blank" rel="noopener">依赖检查报告</a>。</p><p>dependencyInsight 任务是’Help’任务组中的一个。这项任务需要进行配置才可以。如果用了 Java 相关的插件，那么 dependencyInsight 任务已经预先被配置到’Compile’下了。你只需要通过’–dependency’参数来制定所需查看的依赖即可。如果你不想用默认配置的参数项你可以通过 ‘–configuration’ 参数来进行指定。了解更多请参阅<a href="http://gradledoc.qiniudn.com/1.12/dsl/org.gradle.api.tasks.diagnostics.DependencyInsightReportTask.html" target="_blank" rel="noopener">依赖检查报告</a>。</p><h3 id="获取项目属性列表"><a href="#获取项目属性列表" class="headerlink" title="获取项目属性列表"></a>获取项目属性列表</h3><p>执行 <strong>gradle properties</strong> 可以获取项目所有属性列表。如下例。</p><h3 id="属性信息"><a href="#属性信息" class="headerlink" title="属性信息"></a>属性信息</h3><p><strong>gradle -q api:properties</strong> 的输出结果</p><pre><code>\&gt; gradle -q api:properties\------------------------------------------------------------Project :api - The shared API for the application\------------------------------------------------------------allprojects: [project ':api']ant: org.gradle.api.internal.project.DefaultAntBuilder@12345antBuilderFactory: org.gradle.api.internal.project.DefaultAntBuilderFactory@12345artifacts: org.gradle.api.internal.artifacts.dsl.DefaultArtifactHandler@12345asDynamicObject: org.gradle.api.internal.ExtensibleDynamicObject@12345buildDir: /home/user/gradle/samples/userguide/tutorial/projectReports/api/buildbuildFile: /home/user/gradle/samples/userguide/tutorial/projectReports/api/build.gradle</code></pre><h3 id="构建日志"><a href="#构建日志" class="headerlink" title="构建日志"></a>构建日志</h3><p><strong>–profile</strong> 参数可以收集一些构建期间的信息并保存到 build/reports/profile 目录下并且以构建时间命名这些文件。</p><p>下面这份日志记录了总体花费时间以及各过程花费的时间，并以时间大小倒序排列，并且记录了任务的执行情况。</p><p>如果采用了 buildSrc，那么在 buildSrc/build 下同时也会生成一份日志记录记录。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjAyMDg3MTdhZWU0MTRhNTRhNGU4NDNjMGM2YzQxOWZfRFlmMzRsTjd5WjYyVGl5VzZtWGhTNHFOdmdYSUJxUURfVG9rZW46Ym94Y25NUTRrZmxlUkpwVVBacUEyMzI0MUxmXzE2MjcxNDczNzQ6MTYyNzE1MDk3NF9WNA" alt="img"></p><h2 id="Dry-Run"><a href="#Dry-Run" class="headerlink" title="Dry Run"></a>Dry Run</h2><p>有时可能你只想知道某个任务在一个任务集中按顺序执行的结果，但并不想实际执行这些任务。那么你可以用-m 参数。例如 <strong>gradle -m clean compile</strong> 会调用 clean 和 compile，这与 tasks 可以形成互补，让你知道哪些任务可以用于执行。</p><h1 id="使用-Gradle-图形用户界面"><a href="#使用-Gradle-图形用户界面" class="headerlink" title="使用 Gradle 图形用户界面"></a>使用 Gradle 图形用户界面</h1><p>除了支持传统的命令行界面，Gradle 也提供了一个图形用户界面（GUI）。这是一个独立的用户界面，可以通过加上 <strong>–gui</strong> 参数来启动。</p><h2 id="Launching-the-GUI"><a href="#Launching-the-GUI" class="headerlink" title="Launching the GUI"></a>Launching the GUI</h2><pre><code>gradle --gui  </code></pre><p>注意：此命令行窗口被将锁定，直到 Gradle GUI 被关闭。如果是在 linux/unix 系统下，则可以通过(gradle –gui&amp;)让它作为后台任务运行。</p><p>如果你在你的 Gradle 项目目录下运行 Gradle GUI，你应该会看到一个任务树。</p><p><strong>GUI Task Tree</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGVlNDMwODI4MjRiYWNkMjU2ZDg5MDA4YWQzYTljNDJfZEViVzRmbmZ6RWN2WDNYTDZnamQyeWNOd2U5TDI3cEVfVG9rZW46Ym94Y25WZDltektoQXlWakV4Y1VsRlU2OHhlXzE2MjcxNDczNzQ6MTYyNzE1MDk3NF9WNA" alt="img"></p><p>最好是从 Gradle 项目目录运行此命令，这样对 UI 的设置就可以存储在你的项目目录中。当然，你也可以先运行它，然后通过在 UI 中的设置（Setup）选项卡，改变工作目录。</p><p>在 Gradle 的用户界面（UI）中，上面是 4 个选项卡，下面则是输出窗口。</p><h2 id="任务树"><a href="#任务树" class="headerlink" title="任务树"></a>任务树</h2><p>任务树显示了所有项目和它们的任务的层次结构。双击一个任务可以执行它。</p><p>这里还提供了一个过滤器，可以把比较少用的任务隐藏。你可以通过过滤器（Filter）按钮切换是否进行过滤。通过编辑过滤器，你可以对哪些任务和项目要显示进行配置。隐藏的任务显示为红色。注意：新创建的任务默认情况下是显示状态（而不是隐藏状态）</p><p>任务树的上下文菜单会提供以下选项：</p><ul><li><p>执行忽略依赖关系。这使得重新构建时不去依赖项目（与 -a 选项一样）</p></li><li><p>将任务添加到收藏夹（见收藏夹（Favourites）选项卡）</p></li><li><p>隐藏选择的任务。这将会把它们添加到过滤器中。</p></li><li><p>编辑 build.gradle 文件。注意：该操作需要 Java 1.6 或更高的版本，并且要求在你的操作系统中关联 gradle 文件。</p></li></ul><h2 id="收藏夹"><a href="#收藏夹" class="headerlink" title="收藏夹"></a>收藏夹</h2><p>收藏夹选项卡用来储存经常执行的命令。这些命令可以是复杂的命令（只要它们符合 Gradle 的语法），你可以给它们设置一个显示名称。它用于创建一个自定义的命令，来显示地跳过测试，文档，例子。你可以称之为“快速构建”。</p><p>你可以根据自己的喜好，对收藏夹进行排序，甚至可以把它们导出到磁盘，并在其他地方导入。如果你在编辑它们的时候，选上“始终显示实时输出”，它只有在你选上“当发生错误时才显示输出”时有效。它会始终强制显示输出。</p><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>命令行选项卡是直接执行单个的 Gradle 命令的地方。你只需要输入命令行中你经常在“Gradle”后面输入的命令即可。它也对要添加到收藏夹的命令提供了先去尝试的地方。</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>设置（Setup）选项卡允许你配置一些常规的设置</p><p><strong>GUI Setup</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJhYjkwMmFjYjA2ZjNmMjk2MjE0Yzk0NDZmYTgzYTZfVEl5alhMVHBITmxDcjh4ZkV4dkhqVDZ6T3FvUkt6VlBfVG9rZW46Ym94Y25NS1UxNmV0SzdoRWZSTmpUQTNJTEhmXzE2MjcxNDczNzQ6MTYyNzE1MDk3NF9WNA" alt="img"></p><ul><li><p>当前目录 定义了你的 Gradle 项目（通常是 build.gradle 所在的位置）的根目录。</p></li><li><p>堆栈跟踪输出 这决定了当出现错误时，有多少信息定到堆栈跟踪。注意：如果你在命令行或收藏夹选项卡上指定了堆栈跟踪级别，将会覆盖这里的设置。</p></li><li><p>只在出现错误时显示输出 启用此选项将在任务执行时隐藏任何输出，除非构建失败。</p></li><li><p>使用自定义的 Gradle 执行器 - 高级功能 这为你提供了启动 Gradle 命令行的替代方法。这是很有用的。如果你的项目需要在另一个批处理文件或 shell 脚本中做一些额外的配置（比如指定一个初始化脚本）。</p></li></ul><h1 id="Gradle-编写构建脚本"><a href="#Gradle-编写构建脚本" class="headerlink" title="Gradle 编写构建脚本"></a>Gradle 编写构建脚本</h1><h2 id="Gradle-构建语言"><a href="#Gradle-构建语言" class="headerlink" title="Gradle 构建语言"></a>Gradle 构建语言</h2><p>Gradle 提供一种领域特定语言或者说是 DSL，来描述构建。这种构建语言基于 Groovy 中，并进行了一些补充，使其易于描述构建。</p><h2 id="Project-API"><a href="#Project-API" class="headerlink" title="Project API"></a>Project API</h2><p>之前使用了 apply ()方法。这方法从何而来？我们之前说在 Gradle 中构建脚本定义了一个项目（project）。在构建的每一个项目中，Gradle 创建了一个 Project 类型的实例，并在构建脚本中关联此 Project 对象。当构建脚本执行时，它会配置此 Project 对象：</p><ul><li><p>在构建脚本中，你所调用的任何一个方法，如果在构建脚本中未定义，它将被委托给 Project 对象。</p></li><li><p>在构建脚本中，你所访问的任何一个属性，如果在构建脚本里未定义，它也会被委托给 Project 对象。</p></li></ul><p>下面我们来试试这个，试试访问 Project 对象的 name 属性。</p><p><strong>访问 Project 对象的属性</strong></p><p>build.gradle</p><pre><code>println nameprintln project.name  </code></pre><p>gradle -q check 的输出结果</p><pre><code>&gt; gradle -q checkprojectApiprojectApi  </code></pre><p>这两个 println 语句打印出相同的属性。在生成脚本中未定义的属性，第一次使用时自动委托到 Project 对象。其他语句使用了在任何构建脚本中可以访问的 project 属性，则返回关联的 Project 对象。只有当您定义的属性或方法 Project 对象的一个成员相同名字时，你才需要使用 project 属性。</p><h2 id="标准-project-属性"><a href="#标准-project-属性" class="headerlink" title="标准 project 属性"></a>标准 project 属性</h2><p>Project对象提供了一些在构建脚本中可用的标准的属性。下表列出了常用的几个属性。</p><p><strong>表 Project 属性</strong></p><p>无法复制加载中的内容</p><h2 id="Script-API"><a href="#Script-API" class="headerlink" title="Script API"></a>Script API</h2><p>当 Gradle 执行一个脚本时，它将脚本编译为一个实现了 Script 接口的类。这意味着所有由该Script 接口声明的属性和方法在您的脚本中是可用的。</p><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>有两类可以在生成脚本中声明的变量： 局部变量和额外属性。</p><h3 id="局部变量局部"><a href="#局部变量局部" class="headerlink" title="局部变量局部"></a>局部变量局部</h3><p>局部变量是用 def 关键字声明的。它们只在定义它们的范围内可以被访问。局部变量是 Groovy 语言底层的一个特征。</p><p><strong>示例 使用局部变量</strong></p><p>build.gradle</p><pre><code>def dest = "dest"task copy(type: Copy) {    from "source"    into dest}  </code></pre><h3 id="额外属性"><a href="#额外属性" class="headerlink" title="额外属性"></a>额外属性</h3><p>Gradle 的域模型中，所有增强的对象都可以容纳用户定义的额外的属性。这包括但并不限于项目（project）、任务（task）和源码集（source set）。额外的属性可以通过所属对象的 ext 属性进行添加，读取和设置。或者，可以使用 ext 块同时添加多个属性。</p><p><strong>例子. 使用额外属性</strong></p><p>build.gradle</p><pre><code>apply plugin: "java"ext {    springVersion = "3.1.0.RELEASE"    emailNotification = "build@master.org"}sourceSets.all { ext.purpose = null }sourceSets {    main {        purpose = "production"    }    test {        purpose = "test"    }    plugin {        purpose = "production"    }}task printProperties &lt;&lt; {    println springVersion    println emailNotification    sourceSets.matching { it.purpose == "production" }.each { println it.name }}   </code></pre><p>gradle -q printProperties的输出结果</p><pre><code>&gt; gradle -q printProperties3.1.0.RELEASEbuild@master.orgmainplugin  </code></pre><p>在此示例中， 一个 ext 代码块将两个额外属性添加到 project 对象中。此外，通过将ext.purpose 设置为 null（null是一个允许的值），一个名为 purpose 的属性被添加到每个源码集（source set）。一旦属性被添加，他们就可以像预定的属性一样被读取和设置。</p><p>通过添加属性所要求特殊的语法，Gradle 可以在你试图设置 （预定义的或额外的） 的属性，但该属性拼写错误或不存在时 fail fast。额外属性在任何能够访问它们所属的对象的地方都可以被访问，这使它们有着比局部变量更广泛的作用域。父项目上的额外属性，在子项目中也可以访问。</p><h2 id="一些-Groovy-的基础知识"><a href="#一些-Groovy-的基础知识" class="headerlink" title="一些 Groovy 的基础知识"></a>一些 Groovy 的基础知识</h2><p>Groovy 提供了用于创建 DSL 的大量特点，并且 Gradle 构建语言利用了这些特点。了解构建语言是如何工作的，将有助于你编写构建脚本，特别是当你开始写自定义插件和任务的时候。</p><h3 id="Groovy-JDK"><a href="#Groovy-JDK" class="headerlink" title="Groovy JDK"></a>Groovy JDK</h3><p>Groovy 对 JVM 的类增加了很多有用的方法。例如， iterable 新增的 each 方法，会对iterable 的元素进行遍历：</p><p><strong>Groovy JDK 的方法</strong></p><p>build.gradle</p><pre><code>// Iterable gets an each() methodconfigurations.runtime.each { File f -&gt; println f }  </code></pre><h3 id="属性访问器"><a href="#属性访问器" class="headerlink" title="属性访问器"></a>属性访问器</h3><p>Groovy 会自动地把一个属性的引用转换为对适当的 getter 或 setter 方法的调用。</p><p><strong>属性访问器</strong></p><p>build.gradle</p><pre><code>// Using a getter methodprintln project.buildDirprintln getProject().getBuildDir()// Using a setter methodproject.buildDir = 'target'getProject().setBuildDir('target')   </code></pre><h3 id="括号可选的方法调用"><a href="#括号可选的方法调用" class="headerlink" title="括号可选的方法调用"></a>括号可选的方法调用</h3><p>调用方法时括号是可选的。</p><p><strong>不带括号的方法调用</strong></p><p>build.gradle</p><pre><code>test.systemProperty 'some.prop', 'value'test.systemProperty('some.prop', 'value')  </code></pre><h3 id="List-和-Map"><a href="#List-和-Map" class="headerlink" title="List 和 Map"></a>List 和 Map</h3><p>Groovy 提供了一些定义 List 和 Map 实例的快捷写法。</p><p><strong>List and map</strong></p><p>build.gradle</p><pre><code>// List literaltest.includes = ['org/gradle/api/**', 'org/gradle/internal/**']List&lt;String&gt; list = new ArrayList&lt;String&gt;()list.add('org/gradle/api/**')list.add('org/gradle/internal/**')test.includes = list// Map literalapply plugin: 'java'Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;()map.put('plugin', 'java')apply(map)  </code></pre><h3 id="作为方法最后一个参数的闭包"><a href="#作为方法最后一个参数的闭包" class="headerlink" title="作为方法最后一个参数的闭包"></a>作为方法最后一个参数的闭包</h3><p>Gradle DSL 在很多地方使用闭包。你可以在这里查看更多有关闭包的资料。当方法的最后一个参数是一个闭包时，你可以把闭包放在方法调用之后：</p><p><strong>作为方法参数的闭包</strong></p><p>build.gradle</p><pre><code>repositories {    println "in a closure"}repositories() { println "in a closure" }repositories({ println "in a closure" })   </code></pre><h3 id="闭包委托（delegate）"><a href="#闭包委托（delegate）" class="headerlink" title="闭包委托（delegate）"></a>闭包委托（delegate）</h3><p>每个闭包都有一个委托对象，Groovy 使用它来查找变量和方法的引用，而不是作为闭包的局部变量或参数。Gradle 在配置闭包中使用到它，把委托对象设置为被配置的对象。</p><p><strong>闭包委托</strong></p><p>build.gradle</p><pre><code>dependencies {    assert delegate == project.dependencies    compile('junit:junit:4.11')    delegate.compile('junit:junit:4.11')}  </code></pre><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p>有一个常见的情况是，多个任务都依赖于某个目录的存在。当然，你可以在这些任务的开始加入 mkdir 来解决这个问题。但这是种臃肿的解决方法。这里有一个更好的解决方案 (仅适用于这些需要这个目录的任务有着 dependsOn 的关系的情况)：</p><p><strong>使用 mkdir 创建目录</strong></p><p>build.gradle</p><pre><code>classesDir = new File('build/classes')task resources &lt;&lt; {    classesDir.mkdirs()    // do something}task compile(dependsOn: 'resources') &lt;&lt; {    if (classesDir.isDirectory()) {        println 'The class directory exists. I can operate'    }    // do something}  </code></pre><p>gradle -q compile的输出结果</p><pre><code>&gt; gradle -q compileThe class directory exists. I can operate  </code></pre><h2 id="Gradle-属性和系统属性"><a href="#Gradle-属性和系统属性" class="headerlink" title="Gradle 属性和系统属性"></a>Gradle 属性和系统属性</h2><p>Gradle 提供了许多方式将属性添加到您的构建中。 从Gradle 启动的 JVM，你可以使用 -D 命令行选项向它传入一个系统属性。 <strong>Gradle</strong> 命令的-D选项和 <strong>java</strong> 命令的 -D 选项有着同样的效果。</p><p>此外，您也可以通过属性文件向您的 project 对象添加属性。您可以把一个 gradle.properties 文件放在 Gradle 的用户主目录（默认为 USER_HOME/.gradle），或您的项目目录中。对于多项目构建，您可以将 gradle.properties 文件放在任何子项目的目录中。通过 project 对象，可以访问到 gradle.properties 里的属性。用户的主目录中的属性文件比项目目录中的属性文件更先被访问到。</p><p>你也可以通过使用-P命令行选项来直接向您的项目对象添加属性。在更多的用法中，您甚至可以通过系统和环境属性把属性直接传给项目对象。例如，如果你在一个持续集成服务器上运行构建，但你没有这台机器的管理员权限，而你的构建脚本需要一些不能让其他人知道的属性值，那么，您就不能使用 -P 选项。在这种情况下，您可以在项目管理部分 （对普通用户不可见） 添加一个环境属性。如果环境属性遵循 ORG_GRADLE_PROJECT_propertyName= somevalue 的模式，这里的 propertyName 会被添加到您的项目对象中。对系统属性我们也支持相同的机制。唯一的区别是，它是 org.gradle.projectpropertyName 的模式。</p><p>通过 gradle.properties 文件，你还可以设置系统属性。如果此类文件中的属性有一个systemProp.的前缀，该属性和它的值会被添加到系统属性，且不带此前缀。在多项目构建中，除了在根项目之外的任何项目里的 systemProp. 属性集都将被忽略。也就是，只有根项目gradle.properties 文件里的 systemProp. 属性会被作为系统属性。</p><p><strong>使用 gradle.properties 文件设置属性</strong></p><p>gradle.properties</p><pre><code>gradlePropertiesProp=gradlePropertiesValuesystemProjectProp=shouldBeOverWrittenBySystemPropenvProjectProp=shouldBeOverWrittenByEnvPropsystemProp.system=systemValue  </code></pre><p>build.gradle</p><pre><code>task printProps &lt;&lt; {    println commandLineProjectProp    println gradlePropertiesProp    println systemProjectProp    println envProjectProp    println System.properties['system']}  </code></pre><p><code>gradle -q -PcommandLineProjectProp=commandLineProjectPropValue -Dorg.gradle.project.systemProjectProp=systemPropertyValue printProps</code>的输出结果</p><pre><code>&gt; gradle -q -PcommandLineProjectProp=commandLineProjectPropValue -Dorg.gradle.project.systemProjectProp=systemPropertyValue printPropscommandLineProjectPropValuegradlePropertiesValuesystemPropertyValueenvPropertyValuesystemValue  </code></pre><h3 id="检查项目的属性"><a href="#检查项目的属性" class="headerlink" title="检查项目的属性"></a>检查项目的属性</h3><p>当你要使用一个变量时，你可以仅通过其名称在构建脚本中访问一个项目的属性。如果此属性不存在，则会引发异常，并且构建失败。如果您的构建脚本依赖于一些可选属性，而这些属性用户可能在比如 gradle.properties 文件中设置，您就需要在访问它们之前先检查它们是否存在。你可以通过使用方法 hasProperty(‘propertyName’) 来进行检查，它返回 true 或 false。</p><h2 id="使用外部构建脚本配置项目"><a href="#使用外部构建脚本配置项目" class="headerlink" title="使用外部构建脚本配置项目"></a>使用外部构建脚本配置项目</h2><p>您可以使用外部构建脚本来配置当前项目。Gradle 构建语言的所有内容在外部脚本中也可以使用。您甚至可以在外部脚本中应用其他脚本。</p><p><strong>使用外部构建脚本配置项目</strong></p><p>build.gradle</p><pre><code>apply from: 'other.gradle'  </code></pre><p>other.gradle</p><pre><code>println "configuring $project"task hello &lt;&lt; {    println 'hello from other script'}  </code></pre><p>gradle -q hello的输出结果</p><pre><code>&gt; gradle -q helloconfiguring root project 'configureProjectUsingScript'hello from other script  </code></pre><h2 id="配置任意对象"><a href="#配置任意对象" class="headerlink" title="配置任意对象"></a>配置任意对象</h2><p>您可以用以下非常易理解的方式配置任意对象。</p><p><strong>配置任意对象</strong></p><p>build.gradle</p><pre><code>task configure &lt;&lt; {    pos = configure(new java.text.FieldPosition(10)) {        beginIndex = 1        endIndex = 5    }    println pos.beginIndex    println pos.endIndex}  </code></pre><p>gradle -q configure 的输出结果</p><pre><code>&gt; gradle -q configure15  </code></pre><h2 id="使用外部脚本配置任意对象"><a href="#使用外部脚本配置任意对象" class="headerlink" title="使用外部脚本配置任意对象"></a>使用外部脚本配置任意对象</h2><p>你还可以使用外部脚本配置任意对象</p><p><strong>使用脚本配置任意对象</strong></p><p>build.gradle</p><pre><code>task configure &lt;&lt; {    pos = new java.text.FieldPosition(10)    // Apply the script    apply from: 'other.gradle', to: pos    println pos.beginIndex    println pos.endIndex}  </code></pre><p>other.gradle</p><pre><code>beginIndex = 1;endIndex = 5;  </code></pre><p>gradle -q configure 的输出结果</p><pre><code>&gt; gradle -q configure15  </code></pre><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>为了提高响应速度，默认情况下 Gradle 会缓存所有已编译的脚本。这包括所有构建脚本，初始化脚本和其他脚本。你第一次运行一个项目构建时， Gradle 会创建 .gradle 目录，用于存放已编译的脚本。下次你运行此构建时， 如果该脚本自它编译后没有被修改，Gradle 会使用这个已编译的脚本。否则该脚本会重新编译，并把最新版本存在缓存中。如果您通过 –recompile-scripts 选项运行 Gradle ，会丢弃缓存的脚本，然后重新编译此脚本并将其存在缓存中。通过这种方式，您可以强制 Gradle 重新生成缓存。</p><h1 id="Gradle-任务详述"><a href="#Gradle-任务详述" class="headerlink" title="Gradle 任务详述"></a>Gradle 任务详述</h1><h2 id="定义任务"><a href="#定义任务" class="headerlink" title="定义任务"></a>定义任务</h2><p>在构建基础中我们已经看到如何通过关键字这种风格来定义任务。在某些情况中，你可能需要使用这种关键字风格的几种不同的变式。例如，在表达式中不能用这种关键字风格。</p><p><strong>定义任务</strong></p><p>build.gradle</p><pre><code>task(hello) &lt;&lt; {    println "hello"}task(copy, type: Copy) {    from(file('srcDir'))    into(buildDir)}  </code></pre><p>您还可以使用字符串作为任务名称：</p><p><strong>定义任务 — — 使用字符串作为任务名称</strong></p><p>build.gradle</p><pre><code>task('hello') &lt;&lt;{    println "hello"}task('copy', type: Copy) {    from(file('srcDir'))    into(buildDir)}  </code></pre><p>对于定义任务，有一种替代的语法你可能更愿意使用：</p><p><strong>使用替代语法定义任务</strong></p><p>build.gradle</p><pre><code>tasks.create(name: 'hello') &lt;&lt; {    println "hello"}tasks.create(name: 'copy', type: Copy) {    from(file('srcDir'))    into(buildDir)}  </code></pre><p>在这里我们将任务添加到 tasks 集合。关于 create() 方法的更多变化可以看看 TaskContainer。</p><h2 id="定位任务"><a href="#定位任务" class="headerlink" title="定位任务"></a>定位任务</h2><p>你经常需要在构建文件中查找你所定义的任务，例如，为了去配置或是依赖它们。对这样的情况，有很多种方法。首先，每个任务都可作为项目的一个属性，并且使用任务名称作为这个属性名称：</p><p><strong>以属性方式访问任务</strong></p><p>build.gradle</p><pre><code>task helloprintln hello.nameprintln project.hello.name  </code></pre><p>任务也可以通过 tasks 集合来访问。</p><p><strong>通过 tasks 集合访问任务</strong></p><p>build.gradle</p><pre><code>task helloprintln tasks.hello.nameprintln tasks['hello'].name  </code></pre><p>您可以从任何项目中，使用 tasks.getByPath() 方法获取任务路径并且通过这个路径来访问任务。你可以用任务名称，相对路径或者是绝对路径作为参数调用 getByPath() 方法。</p><p><strong>通过路径访问任务</strong></p><p>build.gradle</p><pre><code>project(':projectA') {    task hello}task helloprintln tasks.getByPath('hello').pathprintln tasks.getByPath(':hello').pathprintln tasks.getByPath('projectA:hello').pathprintln tasks.getByPath(':projectA:hello').path  </code></pre><p>gradle -q hello的输出结果</p><pre><code>&gt; gradle -q hello:hello:hello:projectA:hello:projectA:hello  </code></pre><p>有关查找任务的更多选项，可以看一下 TaskContainer。</p><h2 id="配置任务"><a href="#配置任务" class="headerlink" title="配置任务"></a>配置任务</h2><p>作为一个例子，让我们看看由 Gradle 提供的 Copy 任务。若要创建 Copy 任务，您可以在构建脚本中声明：</p><p><strong>创建一个复制任务</strong></p><p>build.gradle</p><pre><code>task myCopy(type: Copy)  </code></pre><p>上面的代码创建了一个什么都没做的复制任务。可以使用它的 API 来配置这个任务（见 Copy）。下面的示例演示了几种不同的方式来实现相同的配置。</p><p><strong>配置任务的几种方式</strong></p><p>build.gradle</p><pre><code>Copy myCopy = task(myCopy, type: Copy)myCopy.from 'resources'myCopy.into 'target'myCopy.include('**/*.txt', '**/*.xml', '**/*.properties')  </code></pre><p>这类似于我们通常在 Java 中配置对象的方式。您必须在每一次的配置语句重复上下文 （myCopy）。这显得很冗余并且很不好读。</p><p>还有另一种配置任务的方式。它也保留了上下文，且可以说是可读性最强的。它是我们通常最喜欢的方式。</p><p><strong>配置任务-使用闭包</strong></p><p>build.gradle</p><pre><code>task myCopy(type: Copy)myCopy {   from 'resources'   into 'target'   include('**/*.txt', '**/*.xml', '**/*.properties')}  </code></pre><p>这种方式适用于任何任务。该例子的第 3 行只是 tasks.getByName() 方法的简洁写法。特别要注意的是，如果您向 getByName() 方法传入一个闭包，这个闭包的应用是在配置这个任务的时候，而不是任务执行的时候。</p><p>您也可以在定义一个任务的时候使用一个配置闭包。</p><p><strong>使用闭包定义任务</strong></p><p>build.gradle</p><pre><code>task copy(type: Copy) {   from 'resources'   into 'target'   include('**/*.txt', '**/*.xml', '**/*.properties')}  </code></pre><h2 id="对任务添加依赖"><a href="#对任务添加依赖" class="headerlink" title="对任务添加依赖"></a>对任务添加依赖</h2><p>定义任务的依赖关系有几种方法。任务的名称可以指向同一个项目中的任务，或者其他项目中的任务。要引用另一个项目中的任务，你需要把它所属的项目的路径作为前缀加到它的名字中。下面是一个示例，添加了从 projectA:taskX 到 projectB:taskY 的依赖关系：</p><p><strong>从另一个项目的任务上添加依赖</strong></p><p>build.gradle</p><pre><code>project('projectA') {    task taskX(dependsOn: ':projectB:taskY') &lt;&lt; {        println 'taskX'    }}project('projectB') {    task taskY &lt;&lt; {        println 'taskY'    }}  </code></pre><p>gradle -q taskX 的输出结果</p><pre><code>&gt; gradle -q taskXtaskYtaskX  </code></pre><p>您可以使用一个 Task 对象而不是任务名称来定义依赖，如下：</p><p><strong>使用 task 对象添加依赖</strong></p><p>build.gradle</p><pre><code>task taskX &lt;&lt; {    println 'taskX'}task taskY &lt;&lt; {    println 'taskY'}taskX.dependsOn taskY  </code></pre><p>gradle -q taskX的输出结果</p><pre><code>&gt; gradle -q taskXtaskYtaskX  </code></pre><p>对于更高级的用法，您可以使用闭包来定义任务依赖。在计算依赖时，闭包会被传入正在计算依赖的任务。这个闭包应该返回一个 Task 对象或是 Task 对象的集合，返回值会被作为这个任务的依赖项。下面的示例是从 taskX 加入了项目中所有名称以 lib 开头的任务的依赖：</p><p><strong>使用闭包添加依赖</strong></p><p>build.gradle</p><pre><code>task taskX &lt;&lt; {    println 'taskX'}taskX.dependsOn {    tasks.findAll { task -&gt; task.name.startsWith('lib') }}task lib1 &lt;&lt; {    println 'lib1'}task lib2 &lt;&lt; {    println 'lib2'}task notALib &lt;&lt; {    println 'notALib'}  </code></pre><p>gradle -q taskX 的输出结果</p><pre><code>&gt; gradle -q taskXlib1lib2taskX  </code></pre><p>有关任务依赖的详细信息，请参阅 Task 的 API。</p><h2 id="任务排序"><a href="#任务排序" class="headerlink" title="任务排序"></a>任务排序</h2><p>任务排序还是一个孵化中的功能。请注意此功能在以后的 Gradle 版本中可能会改变。</p><p>在某些情况下，控制两个任务的执行的顺序，而不引入这些任务之间的显式依赖，是很有用的。任务排序和任务依赖之间的主要区别是，排序规则不会影响那些任务的执行，而仅将执行的顺序。</p><p>任务排序在许多情况下可能很有用：</p><ul><li><p>强制任务顺序执行： 如，’build’ 永远不会在 ‘clean’ 前面执行。</p></li><li><p>在构建中尽早进行构建验证：如，验证在开始发布的工作前有一个正确的证书。</p></li><li><p>通过在长久验证前运行快速验证以得到更快的反馈：如，单元测试应在集成测试之前运行。</p></li><li><p>一个任务聚合了某一特定类型的所有任务的结果：如，测试报告任务结合了所有执行的测试任务的输出。</p></li></ul><p>有两种排序规则是可用的：”必须在之后运行”和”应该在之后运行”。</p><p>通过使用 “ 必须在之后运行”的排序规则，您可以指定 taskB 必须总是运行在 taskA 之后，无论 taskA 和 taskB 这两个任务在什么时候被调度执行。这被表示为 taskB.mustRunAfter(taskA) 。“应该在之后运行”的排序规则与其类似，但没有那么严格，因为它在两种情况下会被忽略。首先是如果使用这一规则引入了一个排序循环。其次，当使用并行执行，并且一个任务的所有依赖项除了任务应该在之后运行之外所有条件已满足，那么这个任务将会运行，不管它的“应该在之后运行”的依赖项是否已经运行了。当倾向于更快的反馈时，会使用“应该在之后运行”的规则，因为这种排序很有帮助但要求不严格。</p><p>目前使用这些规则仍有可能出现 taskA 执行而 taskB 没有执行，或者 taskB 执行而 taskA 没有执行。</p><p><strong>添加 ‘必须在之后运行 ‘ 的任务排序</strong></p><p>build.gradle</p><pre><code>task taskX &lt;&lt; {    println 'taskX'}task taskY &lt;&lt; {    println 'taskY'}taskY.mustRunAfter taskX  </code></pre><p>gradle -q taskY taskX 的输出结果</p><pre><code>&gt; gradle -q taskY taskXtaskXtaskY  </code></pre><p><strong>添加 ‘应该在之后运行 ‘ 的任务排序</strong></p><p>build.gradle</p><pre><code>task taskX &lt;&lt; {    println 'taskX'}task taskY &lt;&lt; {    println 'taskY'}taskY.shouldRunAfter taskX  </code></pre><p>gradle -q taskY taskX 的输出结果</p><pre><code>&gt; gradle -q taskY taskXtaskXtaskY  </code></pre><p>在上面的例子中，它仍有可能执行 taskY 而不会导致 taskX 也运行：</p><p><strong>任务排序并不意味着任务执行</strong></p><p>gradle -q taskY 的输出结果</p><pre><code>&gt; gradle -q taskYtaskY  </code></pre><p>如果想指定两个任务之间的“必须在之后运行”和“应该在之后运行”排序，可以使用 Task.mustRunAfter() 和 Task.shouldRunAfter() 方法。这些方法接受一个任务实例、 任务名称或 Task.dependsOn()所接受的任何其他输入作为参数。</p><p>请注意”B.mustRunAfter(A)”或”B.shouldRunAfter(A)”并不意味着这些任务之间的任何执行上的依赖关系：</p><ul><li><p>它是可以独立地执行任务 A 和 B 的。排序规则仅在这两项任务计划执行时起作用。</p></li><li><p>当–continue 参数运行时，可能会是 A 执行失败后B执行了。</p></li></ul><p>如之前所述，如果“应该在之后运行”的排序规则引入了排序循环，那么它将会被忽略。</p><p><strong>当引入循环时，“应该在其之后运行”的任务排序会被忽略</strong></p><p>build.gradle</p><pre><code>task taskX &lt;&lt; {    println 'taskX'}task taskY &lt;&lt; {    println 'taskY'}task taskZ &lt;&lt; {    println 'taskZ'}taskX.dependsOn taskYtaskY.dependsOn taskZtaskZ.shouldRunAfter taskX  </code></pre><p>gradle -q taskX 的输出结果</p><pre><code>&gt; gradle -q taskXtaskZtaskYtaskX  </code></pre><h2 id="向任务添加描述"><a href="#向任务添加描述" class="headerlink" title="向任务添加描述"></a>向任务添加描述</h2><p>你可以向你的任务添加描述。例如，当执行 gradle tasks 时显示这个描述。</p><p><strong>向任务添加描述</strong></p><p>build.gradle</p><pre><code>task copy(type: Copy) {   description 'Copies the resource directory to the target directory.'   from 'resources'   into 'target'   include('**/*.txt', '**/*.xml', '**/*.properties')}  </code></pre><h2 id="替换任务"><a href="#替换任务" class="headerlink" title="替换任务"></a>替换任务</h2><p>有时您想要替换一个任务。例如，您想要把通过 Java 插件添加的一个任务与不同类型的一个自定义任务进行交换。你可以这样实现：</p><p><strong>重写任务</strong></p><p>build.gradle</p><pre><code>task copy(type: Copy)task copy(overwrite: true) &lt;&lt; {    println('I am the new one.')}  </code></pre><p>gradle -q copy 的输出结果</p><pre><code>&gt; gradle -q copyI am the new one.  </code></pre><p>在这里我们用一个简单的任务替换 Copy 类型的任务。当创建这个简单的任务时，您必须将 overwrite 属性设置为 true。否则 Gradle 将抛出异常，说这种名称的任务已经存在。</p><h2 id="跳过任务"><a href="#跳过任务" class="headerlink" title="跳过任务"></a>跳过任务</h2><p>Gradle 提供多种方式来跳过任务的执行。</p><h3 id="使用断言"><a href="#使用断言" class="headerlink" title="使用断言"></a>使用断言</h3><p>你可以使用 onlyIf()方法将断言附加到一项任务中。如果断言结果为 true，才会执行任务的操作。你可以用一个闭包来实现断言。闭包会作为一个参数传给任务，并且任务应该执行时返回 true，或任务应该跳过时返回 false。断言只在任务要执行前才计算。</p><p><strong>使用断言跳过一个任务</strong></p><p>build.gradle</p><pre><code>task hello &lt;&lt; {    println 'hello world'}hello.onlyIf { !project.hasProperty('skipHello') }  </code></pre><p>gradle hello -PskipHello 的输出结果</p><pre><code>&gt; gradle hello -PskipHello:hello SKIPPEDBUILD SUCCESSFULTotal time: 1 secs  </code></pre><h3 id="使用-StopExecutionException"><a href="#使用-StopExecutionException" class="headerlink" title="使用 StopExecutionException"></a>使用 StopExecutionException</h3><p>如果跳过任务的规则不能与断言同时表达，您可以使用 StopExecutionException。如果一个操作（action）抛出了此异常，那么这个操作（action）接下来的行为和这个任务的其他 操作（action）都会被跳过。构建会继续执行下一个任务。</p><p><strong>使用 StopExecutionException 跳过任务</strong></p><p>build.gradle</p><pre><code>task compile &lt;&lt; {    println 'We are doing the compile.'}compile.doFirst {    // Here you would put arbitrary conditions in real life. But we use this as an integration test, so we want defined behavior.    if (true) { throw new StopExecutionException() }}task myTask(dependsOn: 'compile') &lt;&lt; {   println 'I am not affected'}  </code></pre><p>gradle -q myTask 的输出结果</p><pre><code>&gt; gradle -q myTaskI am not affected  </code></pre><p>如果您使用由 Gradle 提供的任务，那么此功能将非常有用。它允许您向一个任务的内置操作中添加执行条件。</p><h3 id="启用和禁用任务"><a href="#启用和禁用任务" class="headerlink" title="启用和禁用任务"></a>启用和禁用任务</h3><p>每一项任务有一个默认值为 true 的 enabled 标记。将它设置为 false，可以不让这个任务的任何操作执行。</p><p><strong>启用和禁用任务</strong></p><p>build.gradle</p><pre><code>task disableMe &lt;&lt; {    println 'This should not be printed if the task is disabled.'}disableMe.enabled = false  </code></pre><p>Gradle disableMe 的输出结果</p><pre><code>&gt; gradle disableMe:disableMe SKIPPEDBUILD SUCCESSFULTotal time: 1 secs  </code></pre><h2 id="跳过处于最新状态的任务"><a href="#跳过处于最新状态的任务" class="headerlink" title="跳过处于最新状态的任务"></a>跳过处于最新状态的任务</h2><p>如果您使用 Gradle 自带的任务，如 Java 插件所添加的任务的话，你可能已经注意到 Gradle 将跳过处于最新状态的任务。这种行在您自己定义的任务上也有效，而不仅仅是内置任务。</p><h3 id="声明一个任务的输入和输出"><a href="#声明一个任务的输入和输出" class="headerlink" title="声明一个任务的输入和输出"></a>声明一个任务的输入和输出</h3><p>让我们来看一个例子。在这里我们的任务从一个 XML 源文件生成多个输出文件。让我们运行它几次。</p><p><strong>一个生成任务</strong></p><p>build.gradle</p><pre><code>task transform {    ext.srcFile = file('mountains.xml')    ext.destDir = new File(buildDir, 'generated')    doLast {        println "Transforming source file."        destDir.mkdirs()        def mountains = new XmlParser().parse(srcFile)        mountains.mountain.each { mountain -&gt;            def name = mountain.name[0].text()            def height = mountain.height[0].text()            def destFile = new File(destDir, "${name}.txt")            destFile.text = "$name -&gt; ${height}\n"        }    }}  </code></pre><p>gradle transform 的输出结果</p><pre><code>&gt; gradle transform:transformTransforming source file.  </code></pre><p>gradle transform的输出结果</p><pre><code>&gt; gradle transform:transformTransforming source file.  </code></pre><p>请注意 Gradle 第二次执行执行这项任务时，即使什么都未作改变，也没有跳过该任务。我们的示例任务被用一个操作（action）闭包来定义。Gradle 不知道这个闭包做了什么，也无法自动判断这个任务是否为最新状态。若要使用 Gradle 的最新状态（up-to-date）检查，您需要声明这个任务的输入和输出。</p><p>每个任务都有一个 inputs 和 outputs 的属性，用来声明任务的输入和输出。下面，我们修改了我们的示例，声明它将 XML 源文件作为输入，并产生输出到一个目标目录。让我们运行它几次。</p><p><strong>声明一个任务的输入和输出</strong></p><p>build.gradle</p><pre><code>task transform {    ext.srcFile = file('mountains.xml')    ext.destDir = new File(buildDir, 'generated')    inputs.file srcFile    outputs.dir destDir    doLast {        println "Transforming source file."        destDir.mkdirs()        def mountains = new XmlParser().parse(srcFile)        mountains.mountain.each { mountain -&gt;            def name = mountain.name[0].text()            def height = mountain.height[0].text()            def destFile = new File(destDir, "${name}.txt")            destFile.text = "$name -&gt; ${height}\n"        }    }}  </code></pre><p>gradle transform 的输出结果</p><pre><code>&gt; gradle transform:transformTransforming source file.  </code></pre><p>gradle transform 的输出结果</p><pre><code>&gt; gradle transform:transform UP-TO-DATE  </code></pre><p>现在，Gradle 知道哪些文件要检查以确定任务是否为最新状态。</p><p>任务的 inputs 属性是 TaskInputs 类型。任务的 outputs 属性是 TaskOutputs 类型。</p><p>一个没有定义输出的任务将永远不会被当作是最新的。对于任务的输出并不是文件的场景，或者是更复杂的场景， TaskOutputs.upToDateWhen() 方法允许您以编程方式计算任务的输出是否应该被判断为最新状态。</p><p>一个只定义了输出的任务，如果自上一次构建以来它的输出没有改变，那么它会被判定为最新状态。</p><h3 id="它是怎么实现的？"><a href="#它是怎么实现的？" class="headerlink" title="它是怎么实现的？"></a>它是怎么实现的？</h3><p>在第一次执行任务之前，Gradle 对输入进行一次快照。这个快照包含了输入文件集和每个文件的内容的哈希值。然后 Gradle 执行该任务。如果任务成功完成，Gradle 将对输出进行一次快照。该快照包含输出文件集和每个文件的内容的哈希值。Gradle 会保存这两个快照，直到任务的下一次执行。</p><p>之后每一次，在执行任务之前，Gradle 会对输入和输出进行一次新的快照。如果新的快照和前一次的快照一样，Gradle 会假定这些输出是最新状态的并跳过该任务。如果它们不一则， Gradle 则会执行该任务。Gradle 会保存这两个快照，直到任务的下一次执行。</p><p>请注意，如果一个任务有一个指定的输出目录，在它上一次执行之后添加到该目录的所有文件都将被忽略，并且不会使这个任务成为过时状态。这是不相关的任务可以在不互相干扰的情况下共用一个输出目录。如果你因为一些理由而不想这样，请考虑使用 TaskOutputs.upToDateWhen()</p><h2 id="任务规则"><a href="#任务规则" class="headerlink" title="任务规则"></a>任务规则</h2><p>有时你想要有这样一项任务，它的行为依赖于参数数值范围的一个大数或是无限的数字。任务规则是提供此类任务的一个很好的表达方式：</p><p><strong>任务规则</strong></p><p>build.gradle</p><pre><code>tasks.addRule("Pattern: ping&lt;ID&gt;") { String taskName -&gt;    if (taskName.startsWith("ping")) {        task(taskName) &lt;&lt; {            println "Pinging: " + (taskName - 'ping')        }    }}  </code></pre><p>Gradle q pingServer1 的输出结果</p><pre><code>&gt; gradle -q pingServer1Pinging: Server1  </code></pre><p>这个字符串参数被用作这条规则的描述。当对这个例子运行 gradle tasks 的时候，这个描述会被显示。</p><p>规则不只是从命令行调用任务才起作用。你也可以对基于规则的任务创建依赖关系：</p><p><strong>基于规则的任务依赖</strong></p><p>build.gradle</p><pre><code>tasks.addRule("Pattern: ping&lt;ID&gt;") { String taskName -&gt;    if (taskName.startsWith("ping")) {        task(taskName) &lt;&lt; {            println "Pinging: " + (taskName - 'ping')        }    }}task groupPing {    dependsOn pingServer1, pingServer2}  </code></pre><p>Gradle q groupPing 的输出结果</p><pre><code>&gt; gradle -q groupPingPinging: Server1Pinging: Server2  </code></pre><h2 id="析构器任务"><a href="#析构器任务" class="headerlink" title="析构器任务"></a>析构器任务</h2><p>析构器任务是一个孵化中的功能 。当最终的任务准备运行时，析构器任务会自动地添加到任务图中。</p><p><strong>添加一个析构器任务</strong></p><p>build.gradle</p><pre><code>task taskX &lt;&lt; {    println 'taskX'}task taskY &lt;&lt; {    println 'taskY'}taskX.finalizedBy taskY  </code></pre><p>gradle -q taskX 的输出结果</p><pre><code>&gt; gradle -q taskXtaskXtaskY  </code></pre><p>即使最终的任务执行失败，析构器任务也会被执行。</p><p><strong>执行失败的任务的任务析构器</strong></p><p>build.gradle</p><pre><code>task taskX &lt;&lt; {    println 'taskX'    throw new RuntimeException()}task taskY &lt;&lt; {    println 'taskY'}taskX.finalizedBy taskY  </code></pre><p>gradle -q taskX 的输出结果</p><pre><code>&gt; gradle -q taskXtaskXtaskY  </code></pre><p>另一方面，如果最终的任务什么都不做的话，比如由于失败的任务依赖项或如果它被认为是最新的状态，析构任务不会执行。</p><p>在不管构建成功或是失败，都必须清理创建的资源的情况下，析构认为是很有用的。这样的资源的一个例子是，一个 web 容器会在集成测试任务前开始，并且在之后关闭，即使有些测试失败。</p><p>你可以使用 Task.finalizedBy()方法指定一个析构器任务。这个方法接受一个任务实例、任务名称或<code>&lt;a4&gt;&lt;c5&gt;Task.dependsOn()&lt;/c5&gt;&lt;/a4&gt;</code>所接受的任何其他输入作为参数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你是从 Ant 转过来的，像 Copy 这种增强的 Gradle 任务，看起来就像是一个 Ant 目标（target）和一个 Ant 任务（task）之间的混合物。实际上确实是这样子。Gradle 没有像 Ant 那样对任务和目标进行分离。简单的 Gradle 任务就像 Ant 的目标，而增强的 Gradle 任务还包括 Ant 任务方面的内容。Gradle 的所有任务共享一个公共 API，您可以创建它们之间的依赖性。这样的一个任务可能会比一个 Ant 任务更好配置。它充分利用了类型系统，更具有表现力而且易于维护。</p><h1 id="Gradle-使用文件"><a href="#Gradle-使用文件" class="headerlink" title="Gradle 使用文件"></a>Gradle 使用文件</h1><h2 id="使用文件"><a href="#使用文件" class="headerlink" title="使用文件"></a>使用文件</h2><p>大多数构建工作都要使用到文件。Gradle 添加了一些概念和 API 来帮助您实现这一目标。</p><h2 id="定位文件"><a href="#定位文件" class="headerlink" title="定位文件"></a>定位文件</h2><p>你可以使用 Project.file()方法来找到一个相对于项目目录的文件 。</p><p><strong>查找文件</strong></p><p>build.gradle</p><pre><code>// Using a relative pathFile configFile = file('src/config.xml')// Using an absolute pathconfigFile = file(configFile.absolutePath)// Using a File object with a relative pathconfigFile = file(new File('src/config.xml'))  </code></pre><p>您可以把任何对象传递给 file()方法，而它将尝试将其转换为一个绝对路径的 File 对象。通常情况下，你会传给它一个 String 或 File 的实例。而所提供的这个对象的 tostring() 方法的值会作为文件路径。如果这个路径是一个绝对路径，它会用于构构一个 File 实例。否则，会通过先计算所提供的路径相对于项目目录的相对路径来构造 File 实例。这个 file()方法也可以识别URL，例如是 <code>file:/some/path.xml</code>。</p><p>这是把一些用户提供的值转换为一个相对路径的 File 对象的有用方法。由于 file()方法总是去计算所提供的路径相对于项目目录的路径，最好是使用 new File(somePath)，因为它是一个固定的路径，而不会因为用户运行 Gradle 的具体工作目录而改变。</p><h2 id="文件集合"><a href="#文件集合" class="headerlink" title="文件集合"></a>文件集合</h2><p>一个文件集合只是表示一组文件。它通过 FileCollection 接口来表示。Gradle API 中的许多对象都实现了此接口。比如，依赖配置 就实现了 FileCollection 这一接口。</p><p>使用 Project.files()方法是获取一个 FileCollection 实例的其中一个方法。你可以向这个方法传入任意个对象，而它们会被转换为一组 File 对象。这个 Files() 方法接受任何类型的对象作为其参数。它的结果会被计算为相对于项目目录的相对路径。你也可以将集合，迭代变量，map 和数组传递给 files() 方法。它们会被展开，并且内容会转换为 File 实例。</p><p><strong>创建一个文件集合</strong></p><p>build.gradle</p><pre><code>FileCollection collection = files('src/file1.txt', new File('src/file2.txt'), ['src/file3.txt', 'src/file4.txt'])  </code></pre><p>一个文件集合是可迭代的，并且可以使用 as 操作符转换为其他类型的对象集合。您还可以使用+运算符把两个文件集合相加，或使用-运算符减去一个文件集合。这里是一些使用文件集合的例子。</p><p><strong>使用一个文件集合</strong></p><p>build.gradle</p><pre><code>// Iterate over the files in the collectioncollection.each {File file -&gt;    println file.name}// Convert the collection to various typesSet set = collection.filesSet set2 = collection as SetList list = collection as ListString path = collection.asPathFile file = collection.singleFileFile file2 = collection as File// Add and subtract collectionsdef union = collection + files('src/file3.txt')def different = collection - files('src/file3.txt')  </code></pre><p>你也可以向 files()方法传一个闭包或一个 Callable 实例。它会在查询集合内容，并且它的返回值被转换为一组文件实例时被调用。这个闭包或 Callable 实例的返回值可以是 files() 方法所支持的任何类型的对象。这是 “实现” FileCollection 接口的简单方法。</p><p><strong>实现一个文件集合</strong></p><p>build.gradle</p><pre><code>task list &lt;&lt; {    File srcDir    // Create a file collection using a closure    collection = files { srcDir.listFiles() }    srcDir = file('src')    println "Contents of $srcDir.name"    collection.collect { relativePath(it) }.sort().each { println it }    srcDir = file('src2')    println "Contents of $srcDir.name"    collection.collect { relativePath(it) }.sort().each { println it }}  </code></pre><p>gradle -q list 的输出结果</p><pre><code>&gt; gradle -q listContents of srcsrc/dir1src/file1.txtContents of src2src2/dir1src2/dir2  </code></pre><p>你可以向 files() 传入一些其他类型的对象：</p><p><strong>FileCollection</strong></p><p>它们会被展开，并且内容会被包含在文件集合内。</p><p><strong>Task</strong></p><p>任务的输出文件会被包含在文件集合内。</p><p><strong>TaskOutputs</strong></p><p>TaskOutputs 的输出文件会被包含在文件集合内。</p><p>要注意的一个地方是，一个文件集合的内容是缓计算的，它只在需要的时候才计算。这意味着您可以，比如创建一个 FileCollection 对象而里面的文件会在以后才创建，比方说在一些任务中才创建。</p><h2 id="文件树"><a href="#文件树" class="headerlink" title="文件树"></a>文件树</h2><p>文件树是按层次结构排序的文件集合。例如，文件树可能表示一个目录树或 ZIP 文件的内容。它通过 FileTree 接口表示。FileTree 接口继承自 FileCollection，所以你可以用对待文件集合一样的方式来对待文件树。Gradle 中的几个对象都实现了 FileTree 接口，例如 source sets。</p><p>使用 Project.fileTree()方法是获取一个 FileTree 实例的其中一种方法。它将定义一个基目录创建 FileTree 对象，并可以选择加上一些 Ant 风格的包含与排除模式。</p><p><strong>创建一个文件树</strong></p><p>build.gradle</p><pre><code>// Create a file tree with a base directoryFileTree tree = fileTree(dir: 'src/main')// Add include and exclude patterns to the treetree.include '**/*.java'tree.exclude '**/Abstract*'// Create a tree using pathtree = fileTree('src').include('**/*.java')// Create a tree using closuretree = fileTree('src') {    include '**/*.java'}// Create a tree using a maptree = fileTree(dir: 'src', include: '**/*.java')tree = fileTree(dir: 'src', includes: ['**/*.java', '**/*.xml'])tree = fileTree(dir: 'src', include: '**/*.java', exclude: '**/*test*/**')  </code></pre><p>你可以像使用一个文件集合的方式一样来使用一个文件树。你也可以使用 Ant 风格的模式来访问文件树的内容或选择一个子树：</p><p><strong>使用文件树</strong></p><p>build.gradle</p><pre><code>// Iterate over the contents of a treetree.each {File file -&gt;    println file}// Filter a treeFileTree filtered = tree.matching {    include 'org/gradle/api/**'}// Add trees togetherFileTree sum = tree + fileTree(dir: 'src/test')// Visit the elements of the treetree.visit {element -&gt;    println "$element.relativePath =&gt; $element.file"}  </code></pre><h2 id="使用归档文件的内容作为文件树"><a href="#使用归档文件的内容作为文件树" class="headerlink" title="使用归档文件的内容作为文件树"></a>使用归档文件的内容作为文件树</h2><p>您可以使用档案的内容，如 ZIP 或者 TAR 文件，作为一个文件树。你可以通过使用 Project.zipTree() 或 Project.tarTree()方法来实现这一过程。这些方法返回一个 FileTree 实例，您可以像使用任何其他文件树或文件集合一样使用它。例如，您可以用它来通过复制内容扩大归档，或把一些档案合并到另一个归档文件中。</p><p><strong>使用归档文件作为文件树</strong></p><p>build.gradle</p><pre><code>// Create a ZIP file tree using pathFileTree zip = zipTree('someFile.zip')// Create a TAR file tree using pathFileTree tar = tarTree('someFile.tar')//tar tree attempts to guess the compression based on the file extension//however if you must specify the compression explicitly you can:FileTree someTar = tarTree(resources.gzip('someTar.ext'))  </code></pre><h2 id="指定一组输入文件"><a href="#指定一组输入文件" class="headerlink" title="指定一组输入文件"></a>指定一组输入文件</h2><p>Gradle 中的许多对象都有一个接受一组输入文件的属性。例如，JavaCompile 任务有一个 source 属性，定义了要编译的源代码文件。你可以使用上面所示的 files()方法所支持的任意类型的对象设置此属性。这意味着您可以通过如 File、String、集合、FileCollection 对象，或甚至是一个闭包来设置此属性。这里有一些例子：</p><p><strong>指定一组文件</strong></p><p>build.gradle</p><pre><code>// Use a File object to specify the source directorycompile {    source = file('src/main/java')}// Use a String path to specify the source directorycompile {    source = 'src/main/java'}// Use a collection to specify multiple source directoriescompile {    source = ['src/main/java', '../shared/java']}// Use a FileCollection (or FileTree in this case) to specify the source filescompile {    source = fileTree(dir: 'src/main/java').matching { include 'org/gradle/api/**' }}// Using a closure to specify the source files.compile {    source = {        // Use the contents of each zip file in the src dir        file('src').listFiles().findAll {it.name.endsWith('.zip')}.collect { zipTree(it) }    }}  </code></pre><p>通常情况下，有一个与属性相同名称的方法，可以追加这个文件集合。再者，这个方法接受 files()方法所支持的任何类型的参数。</p><p><strong>指定一组文件</strong></p><p>build.gradle</p><pre><code>compile {    // Add some source directories use String paths    source 'src/main/java', 'src/main/groovy'    // Add a source directory using a File object    source file('../shared/java')    // Add some source directories using a closure    source { file('src/test/').listFiles() }}  </code></pre><h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><p>你可以使用 Copy 任务来复制文件。复制任务非常灵活，并允许您进行，比如筛选要复制的文件的内容，或映射文件的名称。</p><p>若要使用 Copy 任务，您必须提供用于复制的源文件和目标目录。您还可以在复制文件的时候指定如何转换文件。你可以使用一个复制规范来做这些。一个复制规范通过 CopySpec 接口来表示。Copy 任务实现了此接口。你可以使用 CopySpec.from()方法指定源文件，使用 CopySpec.into()方法使用目标目录。</p><p><strong>使用 copy 任务复制文件</strong></p><p>build.gradle</p><pre><code>task copyTask(type: Copy) {    from 'src/main/webapp'    into 'build/explodedWar'}  </code></pre><p>from() 方法接受和 files() 方法一样的任何参数。当参数解析为一个目录时，该目录下的所有文件（不包含目录本身） 都会递归复制到目标目录。当参数解析为一个文件时，该文件会复制到目标目录中。当参数解析为一个不存在的文件时，参数会被忽略。如果参数是一个任务，那么任务的输出文件 （即该任务创建的文件）会被复制，并且该任务会自动添加为 Copy 任务的依赖项。into() 方法接受和 files() 方法一样的任何参数。这里是另一个示例：</p><p><strong>示例 16.11. 指定复制任务的源文件和目标目录</strong></p><p>build.gradle</p><pre><code>task anotherCopyTask(type: Copy) {    // Copy everything under src/main/webapp    from 'src/main/webapp'    // Copy a single file    from 'src/staging/index.html'    // Copy the output of a task    from copyTask    // Copy the output of a task using Task outputs explicitly.    from copyTaskWithPatterns.outputs    // Copy the contents of a Zip file    from zipTree('src/main/assets.zip')    // Determine the destination directory later    into { getDestDir() }}  </code></pre><p>您可以使用 Ant 风格的包含或排除模式，或使用一个闭包，来选择要复制的文件：</p><p><strong>选择要复制的文件</strong></p><p>build.gradle</p><pre><code>task copyTaskWithPatterns(type: Copy) {    from 'src/main/webapp'    into 'build/explodedWar'    include '**/*.html'    include '**/*.jsp'    exclude { details -&gt; details.file.name.endsWith('.html') &amp;&amp; details.file.text.contains('staging') }}  </code></pre><p>此外，你也可以使用 Project.copy()方法来复制文件。它是与任务一样的工作方式，尽管它有一些主要的限制。首先， copy()不能进行增量操作。</p><p><strong>使用没有最新状态检查的 copy() 方法复制文件</strong></p><p>build.gradle</p><pre><code>task copyMethod &lt;&lt; {    copy {        from 'src/main/webapp'        into 'build/explodedWar'        include '**/*.html'        include '**/*.jsp'    }}  </code></pre><p>第二，当一个任务用作复制源（即作为 from() 的参数）的时候，copy()方法不能建立任务依赖性，因为它是一个方法，而不是一个任务。因此，如果您在任务的 action 里面使用 copy()方法，必须显式声明所有的输入和输出以得到正确的行为。</p><p><strong>使用有最新状态检查的 copy() 方法复制文件</strong></p><p>build.gradle</p><pre><code>task copyMethodWithExplicitDependencies{    inputs.file copyTask // up-to-date check for inputs, plus add copyTask as dependency    outputs.dir 'some-dir' // up-to-date check for outputs    doLast{        copy {            // Copy the output of copyTask            from copyTask            into 'some-dir'        }    }}  </code></pre><p>在可能的情况下，最好是使用 Copy 任务，因为它支持增量构建和任务依赖关系推理，而不需要你额外付出。copy()方法可以作为一个任务执行的部分来复制文件。即，这个 copy() 方法旨在用于自定义任务中，需要文件复制作为其一部分功能的时候。在这种情况下，自定义任务应充分声明与复制操作有关的输入/输出。</p><h3 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h3><p><strong>重命名复制的文件</strong></p><p>build.gradle</p><pre><code>task rename(type: Copy) {    from 'src/main/webapp'    into 'build/explodedWar'    // Use a closure to map the file name    rename { String fileName -&gt;        fileName.replace('-staging-', '')    }    // Use a regular expression to map the file name    rename '(.+)-staging-(.+)', '$1$2'    rename(/(.+)-staging-(.+)/, '$1$2')}  </code></pre><h3 id="过滤文件"><a href="#过滤文件" class="headerlink" title="过滤文件"></a>过滤文件</h3><p><strong>过滤要复制的文件</strong></p><p>build.gradle</p><pre><code>import org.apache.tools.ant.filters.FixCrLfFilterimport org.apache.tools.ant.filters.ReplaceTokenstask filter(type: Copy) {    from 'src/main/webapp'    into 'build/explodedWar'    // Substitute property references in files    expand(copyright: '2009', version: '2.3.1')    expand(project.properties)    // Use some of the filters provided by Ant    filter(FixCrLfFilter)    filter(ReplaceTokens, tokens: [copyright: '2009', version: '2.3.1'])    // Use a closure to filter each line    filter { String line -&gt;        "[$line]"    }}  </code></pre><h3 id="使用-CopySpec-类"><a href="#使用-CopySpec-类" class="headerlink" title="使用 CopySpec 类"></a>使用 CopySpec 类</h3><p>复制规范用来组织一个层次结构。一个复制规范继承其目标路径，包含模式，排除模式，复制操作，名称映射和过滤器。</p><p><strong>嵌套的复制规范</strong></p><p>build.gradle</p><pre><code>task nestedSpecs(type: Copy) {    into 'build/explodedWar'    exclude '**/*staging*'    from('src/dist') {        include '**/*.html'    }    into('libs') {        from configurations.runtime    }}  </code></pre><h2 id="使用-Sync-任务"><a href="#使用-Sync-任务" class="headerlink" title="使用 Sync 任务"></a>使用 Sync 任务</h2><p>Sync 任务继承了 Copy 任务。当它执行时，它会将源文件复制到目标目录中，然后从目标目录移除所有不是它复制的文件。这可以用来做一些事情，比如安装你的应用程序、 创建你的归档文件的 exploded 副本，或维护项目的依赖项的副本。</p><p>这里是一个例子，维护在 build/libs 目录中的项目运行时依赖的副本。</p><p><strong>使用同步任务复制依赖项</strong></p><p>build.gradle</p><pre><code>task libs(type: Sync) {    from configurations.runtime    into "$buildDir/libs"}  </code></pre><h2 id="创建归档文件"><a href="#创建归档文件" class="headerlink" title="创建归档文件"></a>创建归档文件</h2><p>一个项目可以有你所想要的一样多的 JAR 文件。您也可以将 WAR、 ZIP 和 TAG 文件添加到您的项目。使用各种归档任务可以创建以下的归档文件： Zip, Tar, Jar, War, and Ear. 他们的工作方式都一样，所以让我们看看如何创建一个 ZIP 文件。</p><p><strong>创建一个 ZIP 文件</strong></p><p>build.gradle</p><pre><code>apply plugin: 'java'task zip(type: Zip) {    from 'src/dist'    into('libs') {        from configurations.runtime    }}  </code></pre><p>为什么要用 Java 插件？</p><p>Java 插件对归档任务添加了一些默认值。如果你愿意，使用归档任务时可以不需要 Java 插件。您需要提供一些值给附加的属性。</p><p>归档任务与 Copy 任务的工作方式一样，并且实现了相同的 CopySpec 接口。像使用 Copy 任务一样，你需要使用 from() 的方法指定输入的文件，并可以选择是否通过 into() 方法指定最终在存档中的位置。您可以通过一个复制规范来筛选文件的内容、 重命名文件和进行其他你可以做的事情。</p><h3 id="归档命名"><a href="#归档命名" class="headerlink" title="归档命名"></a>归档命名</h3><p>生成的归档的默认名称是 projectName-version.type。举个例子：</p><p><strong>创建 ZIP 文件</strong></p><p>build.gradle</p><pre><code>apply plugin: 'java'version = 1.0task myZip(type: Zip) {    from 'somedir'}println myZip.archiveNameprintln relativePath(myZip.destinationDir)println relativePath(myZip.archivePath)  </code></pre><p>gradle -q myZip 的输出结果</p><pre><code>&gt; gradle -q myZipzipProject-1.0.zipbuild/distributionsbuild/distributions/zipProject-1.0.zip  </code></pre><p>它添加了一个名称为 myZip 的ZIP归档任务，产生 ZIP 文件 zipProject 1.0.zip。区分归档任务的名称和归档任务生成的归档文件的名称是很重要的。归档的默认名称可以通过项目属性 archivesBaseName 来更改。还可以在以后的任何时候更改归档文件的名称。</p><p>这里有很多你可以在归档任务中设置的属性。它们在以下的表 16.1，”存档任务-命名属性”中列出。你可以，比方说，更改归档文件的名称：</p><p><strong>配置归档任务-自定义归档名称</strong></p><p>build.gradle</p><pre><code>apply plugin: 'java'version = 1.0task myZip(type: Zip) {    from 'somedir'    baseName = 'customName'}println myZip.archiveName  </code></pre><p>gradle -q myZip 的输出结果</p><blockquote><p>gradle -q myZip customName-1.0.zip</p></blockquote><p>您可以进一步自定义存档名称：</p><p><strong>配置归档任务 - appendix &amp; classifier</strong></p><p>build.gradle</p><pre><code>apply plugin: 'java'archivesBaseName = 'gradle'version = 1.0task myZip(type: Zip) {    appendix = 'wrapper'    classifier = 'src'    from 'somedir'}println myZip.archiveName  </code></pre><p>gradle -q myZip 的输出结果</p><pre><code>&gt; gradle -q myZipgradle-wrapper-1.0-src.zip  </code></pre><p>表 归档任务-命名属性</p><p>无法复制加载中的内容</p><h3 id="共享多个归档之间的内容"><a href="#共享多个归档之间的内容" class="headerlink" title="共享多个归档之间的内容"></a>共享多个归档之间的内容</h3><p>你可以使用 Project.copySpec()方法在归档之间共享内容。</p><p>你经常会想要发布一个归档文件，这样就可从另一个项目中使用它。</p><h1 id="从-Gradle-中调用-Ant"><a href="#从-Gradle-中调用-Ant" class="headerlink" title="从 Gradle 中调用 Ant"></a>从 Gradle 中调用 Ant</h1><h2 id="在构建中使用-Ant-任务和类型"><a href="#在构建中使用-Ant-任务和类型" class="headerlink" title="在构建中使用 Ant 任务和类型"></a>在构建中使用 Ant 任务和类型</h2><p>在构建脚本中，Gradle 提供了一个名为 ant 的属性。它指向一个 AntBuilder 实例。AntBuilder 用于从你的构建脚本中访问 Ant 任务、 类型和属性。从 Ant 的 build.xml 格式到 Groovy 之间有一个非常简单的映射，下面解释。</p><p>通过调用 AntBuilder实例上的一个方法，可以执行一个 Ant 任务。你可以把任务名称当作方法名称使用。例如，你可以通过调用ant.echo()方法执行 Ant 的 echo 任务。Ant 任务的属性会作为 Map 参数传给该方法。下面是执行 echo 任务的例子。请注意我们还可以混合使用 Groovy 代码和 Ant 任务标记。这将会非常强大。</p><p><strong>使用 Ant 任务</strong></p><p>build.gradle</p><pre><code>task hello &lt;&lt; {    String greeting = 'hello from Ant'    ant.echo(message: greeting)}  </code></pre><p>gradle hello 的输出结果</p><pre><code>&gt; gradle hello:hello[ant:echo] hello from AntBUILD SUCCESSFULTotal time: 1 secs  </code></pre><p>你可以把一个嵌套文本，通过作为任务方法调用的参数，把它传给一个 Ant 任务。在此示例中，我们将把作为嵌套文本的消息传给 echo 任务：</p><p><strong>向 Ant 任务传入嵌套文本</strong></p><p>build.gradle</p><pre><code>task hello &lt;&lt; {    ant.echo('hello from Ant')}  </code></pre><p>gradle hello 的输出结果</p><pre><code>&gt; gradle hello:hello[ant:echo] hello from AntBUILD SUCCESSFULTotal time: 1 secs  </code></pre><p>你可以在一个闭包里把嵌套的元素传给一个 Ant 任务。嵌套元素的定义方式与任务相同，通过调用与我们要定义的元素一样的名字的方法。</p><p><strong>向 Ant 任务传入嵌套元素</strong></p><p>build.gradle</p><pre><code>task zip &lt;&lt; {    ant.zip(destfile: 'archive.zip') {        fileset(dir: 'src') {            include(name: '**.xml')            exclude(name: '**.java')        }    }}    </code></pre><p>您可以用访问任务同样的方法，把类型名字作为方法名称，访问 Ant 类型。方法调用返回 Ant 数据类型，然后可以在构建脚本中直接使用。在以下示例中，我们创建一个 Ant 的 path 对象，然后循环访问它的内容。</p><p><strong>使用 Ant 类型</strong></p><p>build.gradle</p><pre><code>task list &lt;&lt; {    def path = ant.path {        fileset(dir: 'libs', includes: '*.jar')    }    path.list().each {        println it    }}  </code></pre><h3 id="在您的构建中使用自定义-Ant-任务"><a href="#在您的构建中使用自定义-Ant-任务" class="headerlink" title="在您的构建中使用自定义 Ant 任务"></a>在您的构建中使用自定义 Ant 任务</h3><p>要使自定义任务在您的构建中可用，你可以使用 Ant 任务 taskdef（通常更容易） 或typedef，就像在 build.xml 文件中一样。然后，您可以像引用内置的 Ant 任务一样引用自定义 Ant 任务。</p><p><strong>使用自定义 Ant 任务</strong></p><p>build.gradle</p><pre><code>task check &lt;&lt; {    ant.taskdef(resource: 'checkstyletask.properties') {        classpath {            fileset(dir: 'libs', includes: '*.jar')        }    }    ant.checkstyle(config: 'checkstyle.xml') {        fileset(dir: 'src')    }}  </code></pre><p>你可以使用 Gradle 的依赖管理组合类路径，以用于自定义任务。要做到这一点，你需要定义一个自定义配置的类路径中，然后将一些依赖项添加到配置中。</p><p><strong>声明用于自定义 Ant 任务的类路径</strong></p><p>build.gradle</p><pre><code>configurations {    pmd}dependencies {    pmd group: 'pmd', name: 'pmd', version: '4.2.5'}  </code></pre><p>若要使用类路径配置，请使用自定义配置里的 asPath 属性。</p><p><strong>同时使用自定义 Ant 任务和依赖管理</strong></p><p>build.gradle</p><pre><code>task check &lt;&lt; {    ant.taskdef(name: 'pmd', classname: 'net.sourceforge.pmd.ant.PMDTask', classpath: configurations.pmd.asPath)    ant.pmd(shortFilenames: 'true', failonruleviolation: 'true', rulesetfiles: file('pmd-rules.xml').toURI().toString()) {        formatter(type: 'text', toConsole: 'true')        fileset(dir: 'src')    }}  </code></pre><h2 id="导入-Ant-构建"><a href="#导入-Ant-构建" class="headerlink" title="导入 Ant 构建"></a>导入 Ant 构建</h2><p>你可以使用 ant.importBuild()方法来向 Gradle 项目导入一个 Ant 构建。当您导入一个 Ant 构建时，每个 Ant 目标被视为一个 Gradle 任务。这意味着你可以用与 Gradle 任务完全相机的方式操纵和执行 Ant 目标。</p><p><strong>导入 Ant 构建</strong></p><p>build.gradle</p><pre><code>ant.importBuild 'build.xml'build.xml&lt;project&gt;    &lt;target name="hello"&gt;        &lt;echo&gt;Hello, from Ant&lt;/echo&gt;    &lt;/target&gt;&lt;/project&gt;  </code></pre><p>gradle hello 的输出结果</p><pre><code>&gt; gradle hello:hello[ant:echo] Hello, from AntBUILD SUCCESSFULTotal time: 1 secs  </code></pre><p>您可以添加一个依赖于 Ant 目标的任务：</p><p><strong>依赖于 Ant 目标的任务</strong></p><p>build.gradle</p><pre><code>ant.importBuild 'build.xml'task intro(dependsOn: hello) &lt;&lt; {    println 'Hello, from Gradle'}  </code></pre><p>gradle intro 的输出结果</p><pre><code>&gt; gradle intro:hello[ant:echo] Hello, from Ant:introHello, from GradleBUILD SUCCESSFULTotal time: 1 secs  </code></pre><p>或者，您可以将行为添加到 Ant 目标中：</p><p><strong>将行为添加到 Ant 目标</strong></p><p>build.gradle</p><pre><code>ant.importBuild 'build.xml'hello &lt;&lt; {    println 'Hello, from Gradle'}  </code></pre><p>gradle hello 的输出结果</p><pre><code>&gt; gradle hello:hello[ant:echo] Hello, from AntHello, from GradleBUILD SUCCESSFULTotal time: 1 secs  </code></pre><p>它也可以用于一个依赖于 Gradle 任务的 Ant 目标：</p><p><strong>依赖于 Gradle 任务的 Ant 目标</strong></p><p>build.gradle</p><pre><code>ant.importBuild 'build.xml'task intro &lt;&lt; {    println 'Hello, from Gradle'}build.xml&lt;project&gt;    &lt;target name="hello" depends="intro"&gt;        &lt;echo&gt;Hello, from Ant&lt;/echo&gt;    &lt;/target&gt;&lt;/project&gt;  </code></pre><p>gradle hello 的输出结果</p><pre><code>&gt; gradle hello:introHello, from Gradle:hello[ant:echo] Hello, from AntBUILD SUCCESSFULTotal time: 1 secs  </code></pre><h2 id="Ant-属性和引用"><a href="#Ant-属性和引用" class="headerlink" title="Ant 属性和引用"></a>Ant 属性和引用</h2><p>有几种方法来设置 Ant 属性，以便使该属性被 Ant 任务使用。你可以直接在 AntBuilder 实例上设置属性。Ant 属性也可以从一个你可以修改的 Map 中获得。您还可以使用 Ant property 任务。下面是一些如何做到这一点的例子。</p><p><strong>Ant 属性设置</strong></p><p>build.gradle</p><pre><code>ant.buildDir = buildDirant.properties.buildDir = buildDirant.properties['buildDir'] = buildDirant.property(name: 'buildDir', location: buildDir)build.xml&lt;echo&gt;buildDir = ${buildDir}&lt;/echo&gt;  </code></pre><p>许多 Ant 任务在执行时会设置一些属性。有几种方法来获取这些属性值。你可以直接从AntBuilder 实例获得属性。Ant 属性也可作为一个 Map。下面是一些例子。</p><p><strong>获取 Ant 属性</strong></p><p>build.xml</p><pre><code>&lt;property name="antProp" value="a property defined in an Ant build"/&gt;build.gradleprintln ant.antPropprintln ant.properties.antPropprintln ant.properties['antProp']  </code></pre><p>有几种方法可以设置 Ant 引用：</p><p><strong>Ant 引用设置</strong></p><p>build.gradle</p><pre><code>ant.path(id: 'classpath', location: 'libs')ant.references.classpath = ant.path(location: 'libs')ant.references['classpath'] = ant.path(location: 'libs')build.xml&lt;path refid="classpath"/&gt;  </code></pre><p>有几种方法可以获取 Ant 引用：</p><p><strong>获取 Ant 引用</strong></p><p>build.xml</p><pre><code>&lt;path id="antPath" location="libs"/&gt;build.gradleprintln ant.references.antPathprintln ant.references['antPath']</code></pre><h1 id="Gradle-日志"><a href="#Gradle-日志" class="headerlink" title="Gradle 日志"></a>Gradle 日志</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>日志是构建工具的主要界面。如果日志太多，真正的警告和问题容易被隐藏。另一方面，如果出了错，你需要找出相关的信息。Gradle 定义了6个日志级别，如表，“日志级别”所示。除了那些您通过可能会看到的日志级别之外，有两个 Gradle 特定日志级别。这两个级别分别是 QUIET 和 LIFECYCLE. 默认使用后面的这个日志级别，用于报告构建进度。</p><p>表 日志级别</p><p>无法复制加载中的内容</p><h2 id="选择一个日志级别"><a href="#选择一个日志级别" class="headerlink" title="选择一个日志级别"></a>选择一个日志级别</h2><p>“日志级别的命令行选项”中所示的命令行开关来选择不同的日志级别。在表中，“栈跟踪的命令行选项”中，你可以看到影响栈跟踪日志的命令行开关。</p><p>表  日志级别的命令行选项</p><p>无法复制加载中的内容</p><p>表 栈跟踪的命令行选项</p><p>无法复制加载中的内容</p><h2 id="编写自己的日志消息"><a href="#编写自己的日志消息" class="headerlink" title="编写自己的日志消息"></a>编写自己的日志消息</h2><p>在构建文件，打印日志的一个简单方法是把消息写到标准输出中。Gradle 会把写到标准输出的所有内容重定向到它的日志系统的 QUIET 级别中。</p><p><strong>使用标准输出写日志</strong></p><p>build.gradle</p><pre><code>println 'A message which is logged at QUIET level'  </code></pre><p>Gradle 还提供了一个 logger 属性给构建脚本，它是一个 Logger 实例。该接口扩展自 SLF4J的 Logger 接口，并添加了几个 Gradle 的特有方法。下面是关于如何在构建脚本中使用它的示例：</p><p><strong>编写自己的日志消息</strong></p><p>build.gradle</p><pre><code>logger.quiet('An info log message which is always logged.')logger.error('An error log message.')logger.warn('A warning log message.')logger.lifecycle('A lifecycle info log message.')logger.info('An info log message.')logger.debug('A debug log message.')logger.trace('A trace log message.')  </code></pre><p>您也可以在构建脚本中通过其他使用的类挂钩到 Gradle 的日志系统中（例如 buildSrc 目录中的类）。只需使用一个 SLF4J 的 logger 对象。你可以在构建脚本中，用与内置的 logger 同样的方式使用这个 logger。</p><p><strong>使用 SLF4J 编写日志消息</strong></p><p>build.gradle</p><pre><code>import org.slf4j.Loggerimport org.slf4j.LoggerFactoryLogger slf4jLogger = LoggerFactory.getLogger('some-logger')slf4jLogger.info('An info log message logged using SLF4j')  </code></pre><h2 id="使用外部工具和库记录日志"><a href="#使用外部工具和库记录日志" class="headerlink" title="使用外部工具和库记录日志"></a>使用外部工具和库记录日志</h2><p>Gradle 内部使用 Ant 和 Ivy。它们都有自己的日志系统。Gradle 将其日志输出重定向到 Gradle 的日志系统。从 Ant/Ivy 的日志级别到 Gradle 的日志级别是一对一的映射，除了 Ant/Ivy 的 TRACE 级别之外，它是映射到 Gradle 的 DEBUG 级别的。这意味着默认情况下， Gradle 日志级别将不会显示任何 Ant/Ivy 的输出，除非是错误或警告信息。</p><p>有很多的工具仍然在使用标准输出日志记录。默认情况下，Gradle 将标准输出重定向到QUIET日志级别，把标准错误输出重写向到 ERROR 级别。这种行为是可配置的。Project 对象提供了一个LoggingManager，它允许您在计算构建脚本时，修改标准输出和错误重定向的日志级别。</p><p><strong>配置标准输出捕获</strong></p><p>build.gradle</p><pre><code>logging.captureStandardOutput LogLevel.INFOprintln 'A message which is logged at INFO level'  </code></pre><p>为能在任务执行过程中更改标准输出或错误的日志级别，task 也提供了一个 LoggingManager。</p><p><strong>对任务配置标准输出捕获</strong></p><p>build.gradle</p><pre><code>task logInfo {    logging.captureStandardOutput LogLevel.INFO    doFirst {        println 'A task message which is logged at INFO level'    }}  </code></pre><p>Gradle 还提供了对 Java Util Logging，Jakarta Commons Logging 和 Log4j 的日志工具的集成。你生成的类使用这些日志记录工具输出的任何日志消息，都将被重定向到 Gradle 的日志系统。</p><h2 id="改变-Gradle-日志"><a href="#改变-Gradle-日志" class="headerlink" title="改变 Gradle 日志"></a>改变 Gradle 日志</h2><p>您可以用您自己的 logging UI 大量地替换 Gradle 的。你可以这样做，例如，如果您想要以某种方式自定义 UI ——以输出更多或更少的信息，或修改日志格式您可以使用 Gradle.useLogger() 方法替换这个 logging。它可以在构建脚本，或 init 脚本，或通过内嵌的 API 访问。请注意它完全禁用 Gradle 的默认输出。下面是一个示例，在 init 脚本中修改任务执行和构建完成的日志打印。</p><p><strong>自定义 Gradle 日志</strong></p><p>init.gradle</p><pre><code>useLogger(new CustomEventLogger())class CustomEventLogger extends BuildAdapter implements TaskExecutionListener {    public void beforeExecute(Task task) {        println "[$task.name]"    }    public void afterExecute(Task task, TaskState state) {        println()    }    public void buildFinished(BuildResult result) {        println 'build completed'        if (result.failure != null) {            result.failure.printStackTrace()        }    }}  </code></pre><p>gradle -I init.gradle build 的输出结果</p><pre><code>&gt; gradle -I init.gradle build[compile]compiling source[testCompile]compiling test source[test]running unit tests[build]build completed  </code></pre><p>你的 logger 可以实现下面列出的任何监听器接口。当你注册一个 logger 时，只能替换它实现的接口的日志记录。其他接口的日志记录是不变的。</p><ul><li><p>BuildListener</p></li><li><p>ProjectEvaluationListener</p></li><li><p>TaskExecutionGraphListener</p></li><li><p>TaskExecutionListener</p></li><li><p>TaskActionListener</p></li></ul><h1 id="Gradle-守护进程"><a href="#Gradle-守护进程" class="headerlink" title="Gradle 守护进程"></a>Gradle 守护进程</h1><h2 id="走进守护进程"><a href="#走进守护进程" class="headerlink" title="走进守护进程"></a>走进守护进程</h2><p>Gradle 守护进程（有时也称为构建守护进程） 的目的是改善 Gradle 的启动和执行时间。</p><p>我们准备了几个守护进程非常有用的用例。对于一些工作流，用户会多次调用 Gradle，以执行少量的相对快速的任务。举个例子：</p><ul><li><p>当使用测试驱动开发时，单元测试会被执行多次。</p></li><li><p>当开发一个 web 应用程序中，应用程序会被组装多次。</p></li><li><p>当发现构建能做什么，在 gradle tasks 在哪里会执行多次。</p></li></ul><p>对以上各种工作流来说，让调用 Gradle 的启动成本尽可能小会很重要。</p><p>此外，如果可以相对较快地建立 Gradle 模型，用户界面可以提供一些有趣的功能。例如，该守护进程可能用于以下情形：</p><ul><li><p>在 IDE 中的内容帮助</p></li><li><p>在 GUI 中的实时可视化构建</p></li><li><p>在 CLI 中的 tab 键完成</p></li></ul><p>一般情况下，构建工具的敏捷行为总是可以派上用场。如果你尝试在你的本地构建中使用守护进程的话，它会变得让你很难回到正常的 Gradle 使用。</p><p>Tooling API 在整个过程当中都使用守护进程。如，你无法在没有守护进程时正式地使用 Tooling API。这意味着当您在 Eclipse 中使用 STS Gradle 或在 Intellij IDEA 中使用 Gradle 支持时，您已经在使用 Gradle 守护进程。</p><p>未来，该守护进程还会提供更多的功能：</p><ul><li><p>敏捷的 up-to-date 检查：使用本地文件系统修改通知（例如，通过 jdk7 nio.2）预先执行 up-to-date 分析。</p></li><li><p>更快的构建： 预评估项目，这样当用户接下来调用 Gradle 时，模型就准备好了。</p></li><li><p>我们提到了更快的构建吗？守护进程可以预先下载依赖项或进行快照依赖的新版本检查。</p></li><li><p>使用可用于编译和测试的一个可复用线程池。例如，Groovy 和 Scala 的编译器启动开销都很大。构建守护进程可以维持一个已下载的 Groovy 和 （或） Scala 进程。</p></li><li><p>预先执行某些任务，比如编译。更快的反馈。</p></li><li><p>快速、 准确的 bash 的 tab 键完成。</p></li><li><p>Gradle 缓存的定期垃圾收集。</p></li></ul><h2 id="重用和失效的守护程序"><a href="#重用和失效的守护程序" class="headerlink" title="重用和失效的守护程序"></a>重用和失效的守护程序</h2><p>基本的思想是， gradle 命令会 fork 一个守护进程，用于执行实际的构建。Gradle 命令的后续调用将重用该守护进程，以避免启动开销。有时我们不能使用现有的守护进程，是因为它正忙或其 java 版本或 jvm 参数不同。守护进程将在空闲3小时后自动失效。</p><p>以下是我们 fork 一个新的守护进程的所有情况：</p><ul><li><p>如果该守护进程当前正忙于运行一些作业，将启动一个全新的守护进程。</p></li><li><p>对每个 java home，我们会 fork 一个单独的守护进程。所以即使有一些闲置的守护进程等待构建请求，但你碰巧通过不同的 java HOME 运行构建，那么一个全新的守护进程将会被 fork。</p></li><li><p>如果用于构建的jvm的参数足够不同，我们会 fork 一个单独的守护进程。例如，如果某些系统属性已经更改，我们不会 fork 一个新的守护进程。然而，如果 -Xmx 内存设置更改了，或一些基本的不变的系统属性更改了 （例如 file.encoding），那么将 fork 新的守护进程。</p></li><li><p>在这一刻，守护进程会被加上 Gradle 的特定版本号。这意味着即使一些守护进程处于空闲状态，但您正在运行的构建与 Gradle 不同版本，也将启动一个新的守护进程。这也有一种 –stop 命令行指令的结果： 当运行 –stop 时，您仅可以停止以你的 Gradle 版本启动的守护进程。</p></li></ul><p>我们计划在将来改进守护进程的 managing / pooling 的方法。</p><h2 id="用法和故障排除"><a href="#用法和故障排除" class="headerlink" title="用法和故障排除"></a>用法和故障排除</h2><p>以下是有关 Gradle 守护进程的故障排除的一些方面：</p><ul><li><p>如果你的构建有问题，请尝试暂时禁用守护进程 （您可以通过使用命令行开关–no-daemon)。</p></li><li><p>有时候，您可能想要通过–stop命令行选项或更有力的方式停止守护程序。</p></li><li><p>默认情况下位于 Gradle 用户主目录有一个守护进程的日志文件。</p></li><li><p>你可能想要以–foreground 模式启动守护程序，以观察构建是怎么执行的。</p></li></ul><h2 id="配置守护进程"><a href="#配置守护进程" class="headerlink" title="配置守护进程"></a>配置守护进程</h2><p>可以配置一些守护进程的设置，例如 JVM 参数、内存设置或 Java home 目录。</p><h1 id="Gradle-构建环境"><a href="#Gradle-构建环境" class="headerlink" title="Gradle 构建环境"></a>Gradle 构建环境</h1><h2 id="通过-gradle-properties-配置构建环境"><a href="#通过-gradle-properties-配置构建环境" class="headerlink" title="通过 gradle.properties 配置构建环境"></a>通过 gradle.properties 配置构建环境</h2><p>Gradle 提供了几个选项，可以很容易地配置将用于执行您的构建的 Java 进程。当可以通过 GRADLE_OPTS 或 JAVA_OPTS 在你的本地环境中配置这些选项时，如果某些设置如 JVM 内存设置，Java home，守护进程的开/关，它们可以和你的项目在你的版本控制系统中被版本化的话，将会更有用，这样整个团队就可以使用一致的环境了。在你的构建当中，建立一致的环境，就和把这些配置放进 gradle.properties 文件一样简单。这些配置将会按以下顺序被应用（以防在多个地方都有配置时只有最后一个 生效）：</p><ul><li><p>位于项目构建目录的gradle.properties。</p></li><li><p>位于gradle 用户主目录的gradle.properties。</p></li><li><p>系统属性，例如当在命令行中使用 -Dsome.property 时。</p></li></ul><p>下面的属性可以用于配置 Gradle 构建环境：</p><p>org.gradle.daemon</p><p>当设置为 true 时，Gradle 守护进程会运行构建。对于本地开发者的构建而言，这是我们最喜欢的属性。开发人员的环境在速度和反馈上会优化，所以我们几乎总是使用守护进程运行 Gradle 作业。由于 CI 环境在一致性和可靠性上的优化，我们不通过守护进程运行 CI 构建（即长时间运行进程）。</p><p>org.gradle.java.home 为 Gradle 构建进程指定 java home 目录。这个值可以设置为 jdk 或 jre 的位置，不过，根据你的构建所做的，选择 jdk 会更安全。如果该设置未指定，将使用合理的默认值。</p><p>org.gradle.jvmargs 指定用于该守护进程的 jvmargs。该设置对调整内存设置特别有用。目前的内存上的默认设置很大方。</p><p>org.gradle.configureondemand</p><p>启用新的孵化模式，可以在配置项目时使得 Gradle 具有选择性。只适用于相关的项目被配置为在大型多项目中更快地构建。</p><p>org.gradle.parallel</p><p>如果配置了这一个，Gradle 将在孵化的并行模式下运行。</p><h3 id="Forked-java-进程"><a href="#Forked-java-进程" class="headerlink" title="Forked java 进程"></a>Forked java 进程</h3><p>许多设置（如 java 版本和最大堆大小）可以在启动一个新的 JVM 构建进程时指定。这意味着 Gradle 在分析了各种 gradle.properties 文件之后，必须启动一个单独的 JVM 进程，以执行构建操作。当通过守护进程运行时，带有正确参数的 JVM 会启动一次，并在每次的守护进程构建执行时复用。当不通过守护进程执行 Gradle 时，在每次构建执行中都必须启动一个新的 JVM ，除非 JVM 是由 Gradle 启动脚本启动的，并且恰好具有相同的参数。</p><p>在执行每个构建时运行一个额外的 JVM 的代价是非常昂贵的，这就是为什么我们强烈推荐您使用 Gradle 守护进程，如果你指定了 org.gradle.java.home 或 org.gradle.jvmargs。</p><h2 id="通过代理访问网站"><a href="#通过代理访问网站" class="headerlink" title="通过代理访问网站"></a>通过代理访问网站</h2><p>配置 HTTP 代理服务器 （例如用于下载依赖） 是通过标准的 JVM 系统属性来做的。这些属性可以直接在构建脚本中设置；例如设置代理主机为 System.setProperty （’http.proxyHost’, ‘<a href="http://www.somehost.org'）。或者，可以在构建的根目录或" target="_blank" rel="noopener">www.somehost.org'）。或者，可以在构建的根目录或</a> Gradle 主目录中的 gradle.properties 文件中指定这些属性。</p><p><strong>配置 HTTP 代理服务器</strong></p><p>gradle.properties</p><pre><code>systemProp.http.proxyHost=www.somehost.orgsystemProp.http.proxyPort=8080systemProp.http.proxyUser=useridsystemProp.http.proxyPassword=passwordsystemProp.http.nonProxyHosts=*.nonproxyrepos.com|localhost  </code></pre><p>对于 HTTPS 有单独的设置。</p><p><strong>配置 HTTPS 代理服务器</strong></p><p>gradle.properties</p><pre><code>systemProp.https.proxyHost=www.somehost.orgsystemProp.https.proxyPort=8080systemProp.https.proxyUser=useridsystemProp.https.proxyPassword=passwordsystemProp.https.nonProxyHosts=*.nonproxyrepos.com|localhost   </code></pre><p>我们无法很好地概述所有可能的代理服务器设置。其中可以去看的一个地方是 Ant 项目的一个文件中的常量。这里是SVN的视图的链接。另一个地方是 JDK 文档的网络属性页。如果有人知道更好的概述，请发邮件让我们知道。</p><h3 id="NTLM-身份验证"><a href="#NTLM-身份验证" class="headerlink" title="NTLM 身份验证"></a>NTLM 身份验证</h3><p>如果您的代理服务器需要 NTLM 身份验证，您可能需要提供验证域，以及用户名和密码。有两种方法可以向 NTLM 代理提供验证域：</p><ul><li><p>将 http.proxyUser 系统属性设置为一个这样的值：域/用户名。</p></li><li><p>通过 http.auth.ntlm.domain 系统属性提供验证域。</p></li></ul><h1 id="Gradle-插件"><a href="#Gradle-插件" class="headerlink" title="Gradle 插件"></a>Gradle 插件</h1><h2 id="Gradle-插件-1"><a href="#Gradle-插件-1" class="headerlink" title="Gradle 插件"></a>Gradle 插件</h2><p>Gradle 在它的核心中有意地提供了一些小但有用的功能，用于在真实世界中的自动化。所有有用的功能，例如以能够编译 Java 代码为例，都是通过插件进行添加的。插件添加了新任务 （例如JavaCompile），域对象 （例如SourceSet），约定（例如主要的 Java 源代码是位于 src/main/java），以及扩展的核心对象和其他插件的对象。</p><p>在这一章中，我们将讨论如何使用插件以及术语和插件相关的概念。</p><h2 id="应用插件"><a href="#应用插件" class="headerlink" title="应用插件"></a>应用插件</h2><p>插件都认为是被应用，通过 Project.apply() 方法来完成。</p><p><strong>应用插件</strong></p><p>build.gradle</p><pre><code>apply plugin: 'java'  </code></pre><p>插件都有表示它们自己的一个短名称。. 在上述例子中，我们使用短名称 java 去应用 JavaPlugin。</p><p>我们还可以使用下面的语法：</p><p><strong>通过类型应用插件</strong></p><p>build.gradle</p><pre><code>apply plugin: org.gradle.api.plugins.JavaPlugin  </code></pre><p>由于 Gradle 的默认导入，您还可以这样写：</p><p><strong>通过类型应用插件</strong></p><p>build.gradle</p><pre><code>apply plugin: JavaPlugin  </code></pre><p>插件的应用是幂等的。也就是说，一个插件可以被应用多次。如果以前已应用了该插件，任何进一步的应用都不会再有任何效果。</p><p>一个插件是任何实现了 Plugin 接口的简单的类。Gradle 提供了核心插件作为其发行包的一部分，所以简单地应用如上插件是你所需要做的。然而，对于第三方插件，你需要进行配置以使插件在构建类路径中可用。有关如何进行此操作的详细信息。</p><h2 id="插件都做了什么"><a href="#插件都做了什么" class="headerlink" title="插件都做了什么"></a>插件都做了什么</h2><p>把插件应用到项目中可以让插件来扩展项目的功能。它可以做的事情如：</p><ul><li><p>将任务添加到项目 （如编译、 测试）</p></li><li><p>使用有用的默认设置对已添加的任务进行预配置。</p></li><li><p>向项目中添加依赖配置 。</p></li><li><p>通过扩展对现有类型添加新的属性和方法。</p></li></ul><p>让我们来看看：</p><p><strong>通过插件添加任务</strong></p><p>build.gradle</p><pre><code>apply plugin: 'java'task show &lt;&lt; {    println relativePath(compileJava.destinationDir)    println relativePath(processResources.destinationDir)}  </code></pre><p>gradle -q show 的输出结果</p><pre><code>&gt; gradle -q showbuild/classes/mainbuild/resources/main  </code></pre><p>Java 插件已经向项目添加了 compileJava 任务和 processResources 任务，并且配置了这两个任务的 destinationDir 属性。</p><h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>插件可以通过智能的方法对项目进行预配置以支持约定优于配置。Gradle 对此提供了机制和完善的支持，而它是强大-然而-简洁的构建脚本中的一个关键因素。</p><p>在上面的示例中我们看到，Java 插件添加了一个任务，名字为 compileJava ，有一个名为 destinationDir 的属性（即配置编译的 Java 代码存放的地方）。Java 插件默认此属性指向项目目录中的 build/classes/main。这是通过一个合理的默认的约定优于配置的例子。</p><p>我们可以简单地通过给它一个新的值来更改此属性。</p><p><strong>更改插件的默认设置</strong></p><p>build.gradle</p><pre><code>apply plugin: 'java'compileJava.destinationDir = file("$buildDir/output/classes")task show &lt;&lt; {    println relativePath(compileJava.destinationDir)}  </code></pre><p>gradle -q show 的输出结果</p><pre><code>&gt; gradle -q showbuild/output/classes  </code></pre><p>然而，compileJava 任务很可能不是唯 一需要知道类文件在哪里的任务。</p><p>Java 插件添加了 source sets 的概念 （见SourceSet） 来描述的源文件集的各个方面，其中一个方面是在编译的时候这些类文件应该被写到哪个地方。Java 插件将 compileJava 任务的 destinationDir 属性映射到源文件集的这一个方面。</p><p>我们可以通过这个源码集修改写入类文件的位置。</p><p><strong>插件中的约定对象</strong></p><p>build.gradle</p><pre><code>apply plugin: 'java'sourceSets.main.output.classesDir = file("$buildDir/output/classes")task show &lt;&lt; {    println relativePath(compileJava.destinationDir)}  </code></pre><p>gradle -q show 的输出结果</p><pre><code>&gt; gradle -q showbuild/output/classes  </code></pre><p>在上面的示例中，我们应用 Java 插件，除其他外，还做了下列操作：</p><ul><li><p>添加了一个新的域对象类型： SourceSet</p></li><li><p>通过属性的默认（即常规）配置了 main 源码集</p></li><li><p>配置支持使用这些属性来执行工作的任务</p></li></ul><p>所有这一切都发生在 apply plugin: “java” 这一步过程中。在上面例子中，我们在约定配置被执行之后，修改了类文件所需的位置。在上面的示例中可以注意到，compileJava.destinationDir 的值也被修改了，以反映出配置的修改。</p><p>考虑一下另一种消费类文件的任务的情况。如果这个任务使用 sourceSets.main.output.classesDir 的值来配置，那么修改了这个位置的值，无论它是什么时候被修改，将同时更新 compileJava 任务和这一个消费者任务。</p><p>这种配置对象的属性以在所有时间内（甚至当它更改的时候）反映另一个对象的任务的值的能力被称为“映射约定”。它可以令 Gradle 通过约定优于配置及合理的默认值来实现简洁的配置方式。而且，如果默认约定需要进行修改时，也不需要进行完全的重新配置。如果没有这一点，在上面的例子中，我们将不得不重新配置需要使用类文件的每个对象。</p><h1 id="标准的-Gradle-插件"><a href="#标准的-Gradle-插件" class="headerlink" title="标准的 Gradle 插件"></a>标准的 Gradle 插件</h1><h2 id="语言插件"><a href="#语言插件" class="headerlink" title="语言插件"></a>语言插件</h2><p>这些插件添加了让各种语言可以被编译和在 JVM 执行的支持。</p><p>语言插件</p><p>无法复制加载中的内容</p><h2 id="正在孵化的语言插件"><a href="#正在孵化的语言插件" class="headerlink" title="正在孵化的语言插件"></a>正在孵化的语言插件</h2><p>这些插件添加了对多种语言的支持：</p><p>语言插件</p><p>无法复制加载中的内容</p><h2 id="集成插件"><a href="#集成插件" class="headerlink" title="集成插件"></a>集成插件</h2><p>以下这些插件提供了一些与各种运行时技术的集成。</p><p>集成插件</p><p>无法复制加载中的内容</p><h2 id="孵化中的集成插件"><a href="#孵化中的集成插件" class="headerlink" title="孵化中的集成插件"></a>孵化中的集成插件</h2><p>以下这些插件提供了一些与各种运行时技术的集成。</p><p>孵化中的集成插件</p><p>无法复制加载中的内容</p><h2 id="软件开发插件"><a href="#软件开发插件" class="headerlink" title="软件开发插件"></a>软件开发插件</h2><p>这些插件提供一些软件开发过程上的帮助。</p><p>软件开发插件</p><p>无法复制加载中的内容</p><h2 id="孵化中的软件开发插件"><a href="#孵化中的软件开发插件" class="headerlink" title="孵化中的软件开发插件"></a>孵化中的软件开发插件</h2><p>这些插件提供一些软件开发过程上的帮助。</p><p>软件开发插件</p><p>无法复制加载中的内容</p><h2 id="基本插件"><a href="#基本插件" class="headerlink" title="基本插件"></a>基本插件</h2><p>这些插件组成了基本的构建块，其他插件都由此组装而来。它们可供你在你的构建文件中使用，并在此处完整列出。然而，请注意它们都不被认为是 Gradle 公共 API 的一部分。因此，这些插件都不在用户指南中记录。您可能会引用他们的 API 文档，以了解更多关于它们的信息。</p><p>基本插件</p><p>无法复制加载中的内容</p><h2 id="第三方插件"><a href="#第三方插件" class="headerlink" title="第三方插件"></a>第三方插件</h2><p>你可以在维基上找到外部插件的列表。</p><h1 id="Java-插件-1"><a href="#Java-插件-1" class="headerlink" title="Java 插件"></a>Java 插件</h1><h2 id="Java-插件-2"><a href="#Java-插件-2" class="headerlink" title="Java 插件"></a>Java 插件</h2><p>Java 插件向一个项目添加了 Java 编译、 测试和 bundling 的能力。它是很多其他 Gradle 插件的基础服务。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>要使用 Java 插件，请在构建脚本中加入：</p><p><strong>使用 Java 插件</strong></p><p>build.gradle</p><pre><code>apply plugin: 'java'  </code></pre><h2 id="源集"><a href="#源集" class="headerlink" title="源集"></a>源集</h2><p>Java 插件引入了一个源集的概念。一个源集只是一组用于编译并一起执行的源文件。这些源文件可能包括 Java 源代码文件和资源文件。其他有一些插件添加了在源集里包含 Groovy 和 Scala 的源代码文件的能力。一个源集有一个相关联的编译类路径和运行时类路径。</p><p>源集的一个用途是，把源文件进行逻辑上的分组，以描述它们的目的。例如，你可能会使用一个源集来定义一个集成测试套件，或者你可能会使用单独的源集来定义你的项目的 API 和实现类。</p><p>Java 插件定义了两个标准的源集，分别是 main 和 test。main 源集包含你产品的源代码，它们将被编译并组装成一个 JAR 文件。test 源集包含你的单元测试的源代码，它们将被编译并使用 JUnit 或 TestNG 来执行。</p><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>Java 插件向你的项目添加了大量的任务，如下所示。</p><p>Java 插件-任务</p><p>无法复制加载中的内容</p><p>对于每个你添加到该项目中的源集，Java 插件将添加以下的编译任务：</p><p>Java 插件-源集任务</p><p>无法复制加载中的内容</p><p>Java 插件还增加了大量的任务构成该项目的生命周期：</p><p>Java 插件-生命周期任务</p><p>无法复制加载中的内容</p><p>uploadConfigurationName 使用配置 ConfigurationName 上传构件的任务。 Upload 组装并上传指定配置的构件。该任务由 Base 插件添加，并由 Java 插件隐式实现。 下图显示了这些任务之间的关系。</p><h2 id="项目布局"><a href="#项目布局" class="headerlink" title="项目布局"></a>项目布局</h2><p>Java 插件会假定如下所示的项目布局。这些目录都不需要一定存在，或者是里面有什么内容。Java 插件将会进行编译，不管它发现什么，并处理缺少的任何东西。</p><p>Java 插件-默认项目布局</p><p>无法复制加载中的内容</p><h2 id="更改项目布局"><a href="#更改项目布局" class="headerlink" title="更改项目布局"></a>更改项目布局</h2><p>你可以通过配置适当的源集，来配置项目的布局。这一点将在以下各节中详细讨论。这里是如何更改 main Java 和资源源目录的一个简短的例子。</p><p><strong>自定义 Java 源代码布局</strong></p><p>build.gradle</p><pre><code>sourceSets {    main {        java {            srcDir 'src/java'        }        resources {            srcDir 'src/resources'        }    }}  </code></pre><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>Java 插件向项目添加了许多依赖配置，如下图所示。它对一些任务指定了这些配置，如 compileJava 和 test。</p><p> Java插件 - 依赖配置</p><p>无法复制加载中的内容</p><p>对于每个你添加到项目中的源集，Java 插件都会添加以下的依赖配置：</p><p>Java 插件 - 源集依赖配置</p><p>无法复制加载中的内容</p><h2 id="常规属性"><a href="#常规属性" class="headerlink" title="常规属性"></a>常规属性</h2><p>Java 插件向项目添加了许多常规属性。可以在构建脚本中使用这些属性，就像它们是 project 对象的属性一样。</p><p>Java 插件 - 目录属性</p><p>无法复制加载中的内容</p><p>Java 插件 - 其他属性</p><p>无法复制加载中的内容</p><p>这些属性由 JavaPluginConvention， BasePluginConvention 和 ReportingBasePluginConvention 这些类型的常规对象提供。</p><h2 id="使用源集"><a href="#使用源集" class="headerlink" title="使用源集"></a>使用源集</h2><p>你可以使用 sourceSets 属性访问项目的源集。这是项目的源集的容器，它的类型是 SourceSetContainer。除此之后，还有一个 sourceSets {}的脚本块，可以传入一个闭包来配置源集容器。源集容器的使用方式几乎与其他容器一样，例如 tasks。</p><p><strong>访问源集</strong></p><p>build.gradle</p><pre><code>// Various ways to access the main source setprintln sourceSets.main.output.classesDirprintln sourceSets['main'].output.classesDirsourceSets {    println main.output.classesDir}sourceSets {    main {        println output.classesDir    }}// Iterate over the source setssourceSets.all {    println name}  </code></pre><p>要配置一个现有的源集，你只需使用上面的其中一种访问方法来设置源集的属性。这些属性将在下文中进行介绍。下面是一个配置 main 的 Java 和资源目录的例子：</p><p><strong>配置源集的源代码目录</strong></p><p>build.gradle</p><pre><code>sourceSets {    main {        java {            srcDir 'src/java'        }        resources {            srcDir 'src/resources'        }    }}  </code></pre><h2 id="源集属性"><a href="#源集属性" class="headerlink" title="源集属性"></a>源集属性</h2><p>下表列出了一些重要的源集属性。你可以在 SourceSet 的 API 文档中查看更多的详细信息。</p><p>表 23.9. Java 插件 - 源集属性</p><p>无法复制加载中的内容</p><h3 id="定义新的源集"><a href="#定义新的源集" class="headerlink" title="定义新的源集"></a>定义新的源集</h3><p>要定义一个新的源集，你只需在 sourceSets {}块中引用它。下面是一个示例：</p><p><strong>定义一个源集</strong></p><p>build.gradle</p><pre><code>sourceSets {    intTest}  </code></pre><p>当您定义一个新的源集时，Java 插件会为该源集添加一些依赖配置，如表 23.6，“Java 插件 - 源集依赖项配置”所示。你可以使用这些配置来定义源集的编译和运行时的依赖。</p><p><strong>定义源集依赖</strong></p><p>build.gradle</p><pre><code>sourceSets {    intTest}dependencies {    intTestCompile 'junit:junit:4.11'    intTestRuntime 'org.ow2.asm:asm-all:4.0'}  </code></pre><p>Java 插件还添加了大量的任务，用于组装源集的类，如表 23.2，“Java 插件 - 源设置任务”所示。例如，对于一个被叫做 intTest 的源集，你可以运行 gradle intTestClasses 来编译 int 测试类。</p><p><strong>编译源集</strong></p><p>gradle intTestClasses的输出结果</p><pre><code>&gt; gradle intTestClasses:compileIntTestJava:processIntTestResources:intTestClassesBUILD SUCCESSFULTotal time: 1 secs  </code></pre><h2 id="一些源集的范例"><a href="#一些源集的范例" class="headerlink" title="一些源集的范例"></a>一些源集的范例</h2><p>添加一个包含了源集的类的 JAR 包</p><p><strong>示例：为一个源集装配一个JAR文件</strong></p><p>build.gradle</p><pre><code>task intTestJar(type: Jar) {    from sourceSets.intTest.output}  </code></pre><p>为一个源集生成 Javadoc：</p><p><strong>示例：为一个源集生成 Javadoc：</strong></p><p>build.gradle</p><pre><code>task intTestJavadoc(type: Javadoc) {    source sourceSets.intTest.allJava}  </code></pre><p>添加一个测试套件以运行一个源集里的测试</p><p><strong>示例 ：运行源集里的测试</strong></p><p>build.gradle</p><pre><code>task intTest(type: Test) {    testClassesDir = sourceSets.intTest.output.classesDir    classpath = sourceSets.intTest.runtimeClasspath}  </code></pre><h2 id="Javadoc"><a href="#Javadoc" class="headerlink" title="Javadoc"></a>Javadoc</h2><p>Javadoc 任务是 Javadoc 的一个实例。它支持核心的 javadoc 参数选项，以及在 Javadoc 可执行文件的参考文档中描述的标准 doclet 参数选项。对于支持的 Javadoc 参数选项的完整列表，请参考下面的类的 API 文档： CoreJavadocOptions 和StandardJavadocDocletOptions。</p><p>Java 插件 - Javadoc 属性</p><p>无法复制加载中的内容</p><h2 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h2><p>clean 任务是 Delete 的一个实例。它只是删除由其 dir 属性表示的目录。</p><p>Java 插件 - Clean 性能</p><p>无法复制加载中的内容</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>Java 插件使用 Copy 任务进行资源的处理。它为该 project 里的每个源集添加一个实例。“复制文件”中找到关于 copy 任务的更多信息。</p><p> Java 插件-ProcessResources 属性</p><p>无法复制加载中的内容</p><h2 id="CompileJava"><a href="#CompileJava" class="headerlink" title="CompileJava"></a>CompileJava</h2><p>Java 插件为该 project 里的每个源集添加一个 JavaCompile 实例。一些最常见的配置选项如下所示。</p><p>Java 插件- Compile 属性</p><p>无法复制加载中的内容</p><p>compile 任务委派了 Ant 的 javac 任务。将 options.useAnt 设置为 false 将绕过 Ant 任务，而激活 Gradle 的直接编译器集成。在未来的 Gradle 版本中，将把它作为默认设置。</p><p>默认情况下，Java 编译器在 Gradle 过程中运行。将 options.fork 设置为 true 将会使编译出现在一个单独的进程中。在 Ant javac 任务中，这意味着将会为每一个 compile 任务fork 一个新的进程，而这将会使编译变慢。相反，Gradle 的直接编译器集成 （见上文） 将尽可能多地重用相同的编译器进程。在这两种情况下，使用 options.forkOptions 指定的所有fork 选项都将得到重视。</p><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>test 任务是 Test 的一个实例。它会自动检测和执行 test 源集中的所有单元测试。测试执行完成后，它还会生成一份报告。同时支持 JUnit 和 TestNG。可以看一看Test的完整的 API。</p><h3 id="测试执行"><a href="#测试执行" class="headerlink" title="测试执行"></a>测试执行</h3><p>测试在单独的 JVM 中执行，与 main 构建进程隔离。Test 任务的 API 可以让你控制什么时候开始。</p><p>有大量的属性用于控制测试进程的启动。这包括系统属性、 JVM 参数和使用的 Java 可执行文件。</p><p>你可以指定是否要并行运行你的测试。Gradle 通过同时运行多个测试进程来提供并行测试的执行。每个测试进程会依次执行一个单一的测试，所以你一般不需要对你的测试做任何的配置来利用这一点。 MaxParallelForks 属性指定在给定的时间可以运行的测试进程的最大数。它的默认值是 1，也就是说，不并行执行测试。</p><p>测试进程程会为其将 org.gradle.test.worker 系统属性设置为一个唯一标识符，这个标识符可以用于文件名称或其他资源标识符。</p><p>你可以指定在执行了一定数量的测试类之后，重启那个测试进程。这是一个很有用的替代方案，让你的测试进程可以有很大的堆内存。forkEvery 属性指定了要在测试进程中执行的测试类的最大数。默认是每个测试进程中执行的测试数量不限。</p><p>该任务有一个 ignoreFailures 属性，用以控制测试失败时的行为。test 会始终执行它检测到的每一个测试。如果 ignoreFailures 为 false，并且有测试不通过，那它会停止继续构建。IgnoreFailures 的默认值为 false。</p><p>testLogging 属性可以配置哪些测试事件需要记录，并且使用什么样的日志级别。默认情况下，对于每个失败的测试都只会打印一个简洁的消息。请参阅 TestLoggingContainer，查看如何把你的测试日志打印调整为你的偏好设置。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>test 任务提供了一个 Test.getDebug()属性，可以设置为启动，使 JVM 在执行测试之前，等待一个 debugger 连接到它的 5005 端口上。</p><p>这也可以在调用时通过–debug-vm task 选项进行启用。</p><h3 id="测试过滤"><a href="#测试过滤" class="headerlink" title="测试过滤"></a>测试过滤</h3><p>从 Gradle 1.10 开始，可以根据测试的名称模式，只包含指定的测试。过滤，相对于测试类的包含或排除，是一个不同的机制。它将在接下来的段落中进行描述（-Dtest.single， test.include 和 friends）。后者基于文件，比如测试实现类的物理位置。file-level 的测试选择不支持的很多有趣的情况，都可以用 test-level 过滤来做到。以下这些场景中，有一些 Gradle 现在就可以处理，而有一些则将在未来得到实现：</p><ul><li><p>在指定的测试的方法级别上进行过滤；执行单个测试方法</p></li><li><p>基于自定义注解（以后实现）进行过滤</p></li><li><p>基于测试层次结构进行过滤 ；执行所有继承了某一基类（以后实现） 的测试</p></li><li><p>基于一些自定义的运行时的规则进行过滤，例如某个系统属性或一些静态的特定值（以后实现）</p></li></ul><p>测试过滤功能具有以下的特征：</p><ul><li><p>支持完整的限定类名称或完整的限定的方法名称，例如“org.gradle.SomeTest”、“org.gradle.SomeTest.someMethod”</p></li><li><p>通配符 “*” 支付匹配任何字符</p></li><li><p>提供了“–tests”的命令行选项，以方便地设置测试过滤器。这对“单一测试方法的执行”的经典用例特别有用。当使用该命令行选项选项时，在构建脚本中声明的列入过滤器的测试将会被忽略。</p></li><li><p>Gradle 尽最大努力对有着特定的测试框架 API 的局限的测试进行过滤。一些高级的、 综合的测试可能不完全符合过滤条件。然而，绝大多数的测试和用例都会被很好地处理。</p></li><li><p>测试过滤将会取代基于文件的测试选择。后者可能在将来会被完全地取代掉。我们将会继续改进测试过滤的 API，并添加更多种类的过滤器。</p></li></ul><p><strong>在构建脚本中过滤测试</strong></p><p>build.gradle</p><pre><code>test {    filter {        //include specific method in any of the tests        includeTestsMatching "*UiCheck"        //include all tests from package        includeTestsMatching "org.gradle.internal.*"        //include all integration tests        includeTestsMatching "*IntegTest"    }}  </code></pre><p>有关更多的详细信息和示例，请参阅 TestFilter 的文档。</p><p>使用命令行选项的一些示例：</p><ul><li><p>gradle test –tests org.gradle.SomeTest.someSpecificFeature</p></li><li><p>gradle test –tests *SomeTest.someSpecificFeature</p></li><li><p>gradle test –tests *SomeSpecificTest</p></li><li><p>gradle test –tests all.in.specific.package*</p></li><li><p>gradle test –tests *IntegTest</p></li><li><p>gradle test –tests <em>IntegTest*ui</em></p></li><li><p>gradle someTestTask –tests <em>UiTest someOtherTestTask –tests</em> WebTest*ui</p></li></ul><h3 id="通过系统属性执行单一的测试"><a href="#通过系统属性执行单一的测试" class="headerlink" title="通过系统属性执行单一的测试"></a>通过系统属性执行单一的测试</h3><p>这种机制已经被上述的“测试过滤”所取代。 设置一个 taskName.single = testNamePattern 的系统属性将会只执行匹配 testNamePattern 的那些测试。这个 taskName 可以是一个完整的多项目路径，比如“sub1:sub2:test”，或者仅是一个任务名称。testNamePattern 将用于形成一个“<em>*/testNamePattern</em>.class” 的包含模式。如果这个模式无法找到任何测试，那么将会抛出一个异常。这是为了使你不会误以为测试通过。如果执行了一个以上的子项目的测试，该模式会被应用于每一个子项目中。如果在一个特定的子项目中，找不到测试用例，那么将会抛出异常。在这种情况下你可以使用路径标记法的模式，这样该模式就会只应用于特定的子项目的测试任务中。或者你可以指定要执行的任务的完整限定名称。你还可以指定多个模式。示例：</p><ul><li><p>gradle -Dtest.single=ThisUniquelyNamedTest test</p></li><li><p>gradle -Dtest.single=a/b/ test</p></li><li><p>gradle -DintegTest.single=*IntegrationTest integTest</p></li><li><p>gradle -Dtest.single=:proj1:test:Customer build</p></li><li><p>gradle -DintegTest.single=c/d/ :proj1:integTest</p></li></ul><h3 id="测试检测"><a href="#测试检测" class="headerlink" title="测试检测"></a>测试检测</h3><p>Test 任务通过检查编译过的测试类来检测哪些类是测试类。默认情况下它会扫描所有的.class 文件。您可以设置自定义的 includes 或 excludes，这样就只有这些类才会被扫描。根据所使用的测试框架 （JUnit 或 TestNG），会使用不同的标准进行测试类的检测。</p><p>当使用 JUnit 时，我们扫描 JUnit 3 和 4 的测试类。如果满足以下的任何一个条件，这个类就被认为是一个 JUnit 测试类：</p><ul><li><p>类或超类继承自 TestCase 或 GroovyTestCase</p></li><li><p>类或超类使用了 @RunWith 进行注解</p></li><li><p>类或超类含有一个带 @Test 注解的方法</p></li></ul><p>当使用 TestNG 时，我们扫描所有带有 @Test 注解的方法。</p><p>请注意，抽象类不会被执行。Gradle 还将扫描测试类路径中的 jar 文件里的继承树。</p><p>如果你不想要使用测试类检测，可以通过设置 scanForTestClasses 为 false 来禁用它。这将使test任务只使用 includes / excludes 来找到测试类。如果 scanForTestClasses 为disabled，并且没有指定 include 或 exclude 模式，则使用各自的默认值。对于 include 的默认值是 “<strong>/*Tests.class”， “****</strong>/<strong>***Test.class”，而对于exclude它的默认值是 “</strong>/Abstract*.class”。</p><h3 id="测试分组"><a href="#测试分组" class="headerlink" title="测试分组"></a>测试分组</h3><p>JUnit 和 TestNG 可以对测试方法进行复杂的分组。</p><p>为对 Junit 测试类和方法进行分组，JUnit 4.8 引入了类别的概念。test 任务可以实现一个规范，让你 include 和 exclude 想要的 JUnit 类别。</p><p><strong>JUnit 类别</strong></p><p>build.gradle</p><pre><code>test {    useJUnit {        includeCategories 'org.gradle.junit.CategoryA'        excludeCategories 'org.gradle.junit.CategoryB'    }}  </code></pre><p>TestNG 框架有一个非常相似的概念。在 TestNG 中你可以指定不同的测试组。应从测试执行中 include 或 exclude 的测试组，可以在 test 任务中配置。</p><p><strong>对 TestNG 测试分组</strong></p><p>build.gradle</p><pre><code>test {    useTestNG {        excludeGroups 'integrationTests'        includeGroups 'unitTests'    }}  </code></pre><h3 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h3><p>test 任务默认情况下会生成以下结果。</p><ul><li><p>一个 HTML 测试报告。</p></li><li><p>与 Ant Junit report 任务兼容的 XML 格式的结果。这种格式可以被许多工具所支持，比如CI服务器。</p></li><li><p>有效二进制格式的结果。这个任务会从这些二进制结果生成其他的结果。</p></li></ul><p>您可以使用 Test.setTestReport()方法来禁用 HTML 测试报告。目前不能禁用其他的结果。</p><p>这里还有一个独立的 TestReport 任务类型，它可以从一个或多个 Test 任务实例生成的二进制结果中生成 HTML 测试报告。要使用这个任务类型，你需要定义一个 destinationDir 和要包含到报告的测试结果。这里是一个范例，从子项目的单元测试中生成一个联合报告：</p><p><strong>为多个子项目创建一个单元测试报告</strong></p><p>build.gradle</p><pre><code>subprojects {    apply plugin: 'java'    // Disable the test report for the individual test task    test {        reports.html.enabled = false    }}task testReport(type: TestReport) {    destinationDir = file("$buildDir/reports/allTests")    // Include the results from the `test` task in all subprojects    reportOn subprojects*.test}  </code></pre><p>你应该注意到，TestReport 类型组合了多个测试任务的结果，并且需要聚合各个测试类的结果。这意味着，如果一个给定的测试类被多个 test 任务所执行，那么测试报告将包括那个类的所有执行结果，但它难以区分那个类的每次执行和它们的输出。</p><h3 id="TestNG-参数化方法和报告"><a href="#TestNG-参数化方法和报告" class="headerlink" title="TestNG 参数化方法和报告"></a>TestNG 参数化方法和报告</h3><p>TestNG 支持参数化测试方法，允许一个特定的测试方法使用不同的输入执行多次。Gradle 会在这个方法的执行报告中包含进它的参数值。</p><p>给定一个带有两个参数，名为 aParameterizedTestMethod 参数化测试方法，它将使用名称这个名称进行报告 ：aParameterizedTestMethod(toStringValueOfParam1, toStringValueOfParam2)。这使得在特定的迭代过程，很容易确定参数值。</p><h3 id="常规值"><a href="#常规值" class="headerlink" title="常规值"></a>常规值</h3><p>Java 插件 - test 属性</p><p>无法复制加载中的内容</p><h2 id="Jar"><a href="#Jar" class="headerlink" title="Jar"></a>Jar</h2><p>Jar 任务创建一个包含类文件和项目资源的 JAR 文件。JAR 文件在 archives 依赖配置中被声明为一个构件。这意味着这个 JAR 文件被包含在一个依赖它的项目的类路径中。如果你把你的项目上传到仓库，这个 JAR 文件会被声明为依赖描述符的一部分。 </p><h3 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h3><p>每个 jar 或 war 对象都有一个单独的 Manifest 实例的 manifest 属性。当生成 archive 时，相应的 MANIFEST.MF 文件也会被写入进去。</p><p><strong>自定义的 MANIFEST.MF</strong></p><p>build.gradle</p><pre><code>jar {    manifest {        attributes("Implementation-Title": "Gradle", "Implementation-Version": version)    }}  </code></pre><p>您可以创建一个单独的 Manifest 实例。它可以用于共享两个 jar 包的 manifest 信息。</p><p><strong>创建一个 manifest 对象。</strong></p><p>build.gradle</p><pre><code>ext.sharedManifest = manifest {    attributes("Implementation-Title": "Gradle", "Implementation-Version": version)}task fooJar(type: Jar) {    manifest = project.manifest {        from sharedManifest    }}  </code></pre><p>你可以把其他的 manifest 合并到任何一个 Manifest 对象中。其他的 manifest 可能使用文件路径来描述，像上面的例子，使用对另一个 Manifest 对象的引用。</p><p><strong>指定 archive 的单独 MANIFEST.MF</strong></p><p>build.gradle</p><pre><code>task barJar(type: Jar) {    manifest {        attributes key1: 'value1'        from sharedManifest, 'src/config/basemanifest.txt'        from('src/config/javabasemanifest.txt', 'src/config/libbasemanifest.txt') {            eachEntry { details -&gt;                if (details.baseValue != details.mergeValue) {                    details.value = baseValue                }                if (details.key == 'foo') {                    details.exclude()                }            }        }    }}  </code></pre><p>Manifest 会根据在 from 语句中所声明的顺序进行合并。如果基本的 manifest 和要合并的 manifest 都定义了同一个 key 的值，那么默认情况下会采用要合并的 manifest 的值。你可以通过添加 eachEntry action 来完全自定义合并行为，它可以让你对每一项生成的 manifest 访问它的一个 ManifestMergeDetails 实例。这个合并操作不会在 from 语句中就马上被触发。它是懒执行的，不管是对于生成一个 jar 包，还是调用了 writeTo 或者 effectiveManifest</p><p>你可以很轻松地把一个 manifest 写入磁盘中。</p><p><strong>指定 archive 的单独 MANIFEST.MF</strong></p><p>build.gradle</p><pre><code>jar.manifest.writeTo("$buildDir/mymanifest.mf")  </code></pre><h1 id="Gradle-Groovy-插件"><a href="#Gradle-Groovy-插件" class="headerlink" title="Gradle Groovy 插件"></a>Gradle Groovy 插件</h1><h2 id="Groovy-插件"><a href="#Groovy-插件" class="headerlink" title="Groovy 插件"></a>Groovy 插件</h2><p>Groovy 的插件继承自 Java 插件并添加了对 Groovy 项目的支持。它可以处理 Groovy 代码，以及混合的 Groovy 和 Java 代码，甚至是纯 Java 代码（尽管我们不一定推荐使用）。该插件支持联合编译，可以任意地混合及匹配 Groovy 和 Java 代码各自的依赖。例如，一个 Groovy 类可以继承自一个 Java 类，而这个 Java 类也可以继承自一个 Groovy 类。这样一来，我们就能够在项目中使用最适合的语言，并且在有需要的情况下用其他的语言重写其中的任何类。</p><h2 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h2><p>要使用 Groovy 的插件，请在构建脚本中包含以下语句：</p><p><strong>使用 Groovy 插件</strong></p><p>build.gradle</p><pre><code>apply plugin: 'groovy'  </code></pre><h2 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h2><p>Groovy 的插件向 project 中添加了以下任务。</p><p>Groovy 插件 - 任务</p><p>无法复制加载中的内容</p><p>Groovy 的插件向 Java 插件所加入的 tasks 添加了以下的依赖。</p><p>Groovy 插件 - 额外的 task 依赖</p><p>无法复制加载中的内容</p><p>图 Groovy 插件 - tasks</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDY0ZWI1NDU2NTBjNGIzY2M3ZGE3OThkYTZkMGE0NjJfMktmaWx3VGhheEtxNzBnYWhheUtVNFZ6ZEdsUnhQWG1fVG9rZW46Ym94Y25YY3NQMlVvNGwzS0FVbFpwNXF4eHdnXzE2MjcxNDczNzU6MTYyNzE1MDk3NV9WNA" alt="img"></p><h2 id="项目布局-1"><a href="#项目布局-1" class="headerlink" title="项目布局"></a>项目布局</h2><p>Groovy 的插件会假定项目的布局如表 24.3，“Groovy 插件 - 项目布局”中所示。所有 Groovy 的源目录都可以包含 Groovy 和 Java 代码。Java 源目录只能包含 Java 源代码。这些目录不一定得存在或是里面包含有什么内容；Groovy 的插件只会进行编译，而不管它发现什么。</p><p>Groovy 插件 - 项目布局</p><p>无法复制加载中的内容</p><h3 id="更改项目布局-1"><a href="#更改项目布局-1" class="headerlink" title="更改项目布局"></a>更改项目布局</h3><p>和 Java 插件一样，Groovy 插件允许把 Groovy 的 production 和 test 的源文件配置为自定义的位置。</p><p><strong>自定义 Groovy 自定义源文件布局</strong></p><p>build.gradle</p><pre><code>sourceSets {    main {        groovy {            srcDirs = ['src/groovy']        }    }    test {        groovy {            srcDirs = ['test/groovy']        }    }}  </code></pre><h2 id="依赖管理-1"><a href="#依赖管理-1" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>由于 Gradle 的构建语言基于 Groovy 的，且部分的 Groovy 使用 Groovy 实现，因此 Gradle 已经带有了一个 Groovy 库 （截至 Gradle 1.6 所带的 Groovy 库的版本是 1.8.6）。然而，Groovy 项目需要显式地声明一个 Groovy 依赖。这个依赖会在编译和运行的类路径时用到。它还将用于分别获取 Groovy 编译器及 Groovydoc 工具。</p><p>如果 Groovy 用于 production 代码，Groovy 依赖应该添加到 compile 配置中：</p><p><strong>Groovy 的依赖配置</strong></p><pre><code>build.gradlerepositories {    mavenCentral()}dependencies {    compile 'org.codehaus.groovy:groovy-all:2.2.0'}  </code></pre><p>如果 Groovy 仅用于测试代码，Groovy 的依赖应该被添加到 testCompile 配置中：</p><p><strong>配置 Groovy 测试依赖</strong></p><p>build.gradle</p><pre><code>dependencies {    testCompile "org.codehaus.groovy:groovy-all:2.2.0"}   </code></pre><p>如果要使用 Gradle 所带的 Groovy 库，请声明 localGroovy()依赖。注意，不同 Gradle 版本附带的 Groovy 版本不同；因此，声明一个固定的 Groovy 依赖要比使用 localGroovy()更安全一些。</p><p><strong>配置捆绑的 Groovy 依赖</strong></p><p>build.gradle</p><pre><code>dependencies {    compile localGroovy()}  </code></pre><p>Groovy 库不一定得从远程仓库中获取。它也可以获取自本地中可能检入版本控制的 lib 目录：</p><p><strong>配置 Groovy 文件依赖</strong></p><p>build.gradle</p><pre><code>repositories {    flatDir { dirs 'lib' }}dependencies {    compile module('org.codehaus.groovy:groovy:1.6.0') {        dependency('asm:asm-all:2.2.3')        dependency('antlr:antlr:2.7.7')        dependency('commons-cli:commons-cli:1.2')        module('org.apache.ant:ant:1.9.3') {            dependencies('org.apache.ant:ant-junit:1.9.3@jar', 'org.apache.ant:ant-launcher:1.9.3')        }    }}  </code></pre><h2 id="groovyClasspath-的自动配置"><a href="#groovyClasspath-的自动配置" class="headerlink" title="groovyClasspath 的自动配置"></a>groovyClasspath 的自动配置</h2><p>GroovyCompile 和 Groovydoc tasks 会以两种方式使用 Groovy： 在它们的 classpath 以及它们的groovyClasspath上。前者用于在源代码中查找类的引用，通常会包含 Groovy 库和其他库。后者用来分别加载和执行 Groovy 编译器和 Groovydoc 工具，并且应该只包含 Groovy 库及其依赖项。</p><p>除非显式配置了一个 task 的 groovyClasspath ，否则 Groovy（基础）插件会尝试推断该 task 的 classpath。以如下方式进行：</p><ul><li><p>如果在在 classpath 中找到 groovy-all(-indy) Jar，相同的 Jar 将添加到groovyClasspath 中。</p></li><li><p>如果在 classpath 中找到 groovy(-indy) Jar ，并且该项目已经在至少一个仓库中声明了它，那么相应的 groovy(-indy)的仓库依赖将添加到 groovyClasspath 中。</p></li><li><p>其他情况，该 task 将执行失败，并提示无法推断 groovyClasspath。</p></li></ul><h2 id="常规属性-1"><a href="#常规属性-1" class="headerlink" title="常规属性"></a>常规属性</h2><p>Groovy 的插件没有向 project 添加任何的常规属性。</p><h2 id="source-set-属性"><a href="#source-set-属性" class="headerlink" title="source set 属性"></a>source set 属性</h2><p>Groovy 的插件向 project 的每一个source set 添加了下列的常规属性。你可以在你的构建脚本中，把这些属性当成是 source set 对象中的属性一样使用。</p><p>Groovy 插件 - source set 属性</p><p>无法复制加载中的内容</p><p>这些属性由一个 GroovySourceSet 的约定对象提供。</p><p>Groovy 的插件还修改了一些 source set 的属性：</p><p>Groovy 的插件 - source set 属性</p><p>无法复制加载中的内容</p><h2 id="GroovyCompile"><a href="#GroovyCompile" class="headerlink" title="GroovyCompile"></a>GroovyCompile</h2><p>Java 插件向 project 里的每个 source set 添加了一个 JavaCompile task。这个 task 的类型继承自 JavaCompile task。除非 groovyOptions.useAnt 设置为 true，否则将使用 Gradle 集成的本地的 Groovy 编译器。对于大多数项目而言，这相比基于 Ant 编译器，是个更好的选择。GroovyCompile task 支持官方的 Groovy 编译器的大多数配置选项。</p><p>Groovy 插件 - GroovyCompile 属性</p><p>无法复制加载中的内容</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Decompile </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gradle | Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HarmonyOS开发：Java应用</title>
      <link href="/posts/e634.html"/>
      <url>/posts/e634.html</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-API"><a href="#JAVA-API" class="headerlink" title="JAVA API"></a>JAVA API</h1><p><a href="https://developer.harmonyos.com/cn/docs/documentation/overview-0000001054518434" target="_blank" rel="noopener">《Java API参考》</a></p><h1 id="开发概述"><a href="#开发概述" class="headerlink" title="开发概述"></a>开发概述</h1><h2 id="通用开发历程"><a href="#通用开发历程" class="headerlink" title="通用开发历程"></a>通用开发历程</h2><p>各类设备（手机/平板、智能穿戴、智慧屏等）通用的用户应用程序开发历程如下表所示。</p><p>任务简介相关资源开发AbilityAbility是HarmonyOS应用程序的重要组成部分，分为FA（Feature Ability）和PA（Particle Ability）两种类型：FA支持Page Ability：Page模板是FA唯一支持的模板，用于提供与用户交互的能力。PA支持Service Ability和Data Ability：Service模板用于提供后台运行任务的能力；Data模板用于对外部提供统一的数据访问抽象。进行HarmonyOS应用开发，首先要了解Ability如何使用。<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-page-concept-0000000000033573" target="_blank" rel="noopener">Page Ability</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-service-concept-0000000000044457" target="_blank" rel="noopener">Service Ability</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-data-concept-0000000000043058" target="_blank" rel="noopener">Data Ability</a>开发UIFA需要提供UI用于与用户进行交互，HarmonyOS提供了Java UI和JS UI两种UI框架：Java UI提供了细粒度的UI编程接口，使应用开发更加灵活；JS UI提供了相对高层的UI描述，使应用开发更加简单。说明针对轻量级智能穿戴（Lite Wearable），现阶段只使用JS语言进行应用开发，详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/lite-wearable-experience-0000001056083157" target="_blank" rel="noopener">轻量级智能穿戴开发</a>。<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-overview-0000000000500404" target="_blank" rel="noopener">Java UI框架</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/overview-0000001054199972" target="_blank" rel="noopener">Java API参考</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-js-overview-0000000000500376" target="_blank" rel="noopener">JS UI框架</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-apis-overview-0000001056361791" target="_blank" rel="noopener">JS API参考</a>开发业务功能媒体：视频、音频、图像、相机等功能的开发。安全：权限、生物特征识别等功能的开发。AI：图像超分、语音识别、码生成等功能的开发。网络连接：NFC、蓝牙、WLAN等功能的开发。设备管理：传感器、控制类小器件、位置等功能的开发。数据管理：数据库、分布式数据/文件服务、数据搜索等功能的开发。线程：线程管理、线程间通信等功能的开发。IDL：声明系统服务和Ability对外提供的服务接口，并生成相关代码。<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/media-video-overview-0000000000031748" target="_blank" rel="noopener">媒体开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-overview-0000000000029883" target="_blank" rel="noopener">安全开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ai-overview-0000001051150122" target="_blank" rel="noopener">AI开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/connectivity-nfc-overview-0000000000030030" target="_blank" rel="noopener">网络与连接开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/device-sensors-overview-0000001050197918" target="_blank" rel="noopener">设备管理开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-relational-overview-0000000000030046" target="_blank" rel="noopener">数据管理开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/thread-mgmt-overview-0000000000032127" target="_blank" rel="noopener">线程开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/idl-overview-0000001050762835" target="_blank" rel="noopener">IDL接口使用指南</a></p><h2 id="原子化服务开发历程"><a href="#原子化服务开发历程" class="headerlink" title="原子化服务开发历程"></a>原子化服务开发历程</h2><p>HarmonyOS除支持传统方式的需要安装的应用外，还支持提供特定功能的免安装的应用（即原子化服务），供用户在合适的场景、合适的设备上便捷使用。</p><p>原子化服务相对于传统方式的需要安装的应用更加轻量，同时提供更丰富的入口、更精准的分发。原子化服务的详细介绍请参见“<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/atomic-service-definition-0000001090840664" target="_blank" rel="noopener">原子化服务</a>”。</p><p>其基本开发历程如下表所示。</p><p>任务开发历程相关内容了解HarmonyOS了解HarmonyOS的系统定位、技术特性、应用开发的基本概念和基础知识，熟悉HarmonyOS应用开发通用流程。<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-overview-0000000000011903" target="_blank" rel="noopener">HarmonyOS概述</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-fundamentals-0000000000041611" target="_blank" rel="noopener">开发基础知识</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/start-overview-0000000000029602" target="_blank" rel="noopener">快速入门</a>设计原子化服务在设计阶段，需要满足原子化服务的设计规范，包括图标、卡片、分布式等规范。<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/service-overview-0000001139795693" target="_blank" rel="noopener">原子化服务设计</a>掌握原子化服务约束了解原子化服务之间的调用管控机制。<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/mgmt-over-invocations-among-third-party-user-apps-0000001091596272" target="_blank" rel="noopener">三方应用调用管控机制</a>开发原子化服务基础体验了解原子化服务总体开发规则、如何开发服务卡片等基础体验。<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/atomic-service-development-requirements-0000001105286996" target="_blank" rel="noopener">原子化服务总体开发要求</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-service-widget-overview-0000001062607955" target="_blank" rel="noopener">服务卡片开发指南</a>开发原子化服务分布式体验了解如何开发流转、分享等分布式体验。<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/hop-overview-0000001092995092" target="_blank" rel="noopener">流转开发指南</a><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/huawei-share-service-sharing-overview-0000001127181719" target="_blank" rel="noopener">华为分享接入指南</a></p><h1 id="Ability"><a href="#Ability" class="headerlink" title="Ability"></a>Ability</h1><h2 id="Ability概述"><a href="#Ability概述" class="headerlink" title="Ability概述"></a>Ability概述</h2><p>Ability是应用所具备能力的抽象，也是应用程序的重要组成部分。一个应用可以具备多种能力（即可以包含多个Ability），HarmonyOS支持应用以Ability为单位进行部署。Ability可以分为FA（Feature Ability）和PA（Particle Ability）两种类型，每种类型为开发者提供了不同的模板，以便实现不同的业务功能。</p><ul><li><p>FA支持<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-page-concept-0000000000033573" target="_blank" rel="noopener">Page Ability</a>：Page模板是FA唯一支持的模板，用于提供与用户交互的能力。一个Page实例可以包含一组相关页面，每个页面用一个AbilitySlice实例表示。</p></li><li><p>PA支持</p><p>Service Ability</p><p>和</p><p>Data Ability</p><p>：</p><ul><li>Service模板：用于提供后台运行任务的能力。</li></ul></li><li><p>Data模板：用于对外部提供统一的数据访问抽象。</p></li></ul><p>在<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-config-file-overview-0000000000011951" target="_blank" rel="noopener">配置文件</a>（config.json）中注册Ability时，可以通过配置Ability元素中的“type”属性来指定Ability模板类型，示例如下。</p><p>其中，“type”的取值可以为“page”、“service”或“data”，分别代表Page模板、Service模板、Data模板。为了便于表述，后文中我们将基于Page模板、Service模板、Data模板实现的Ability分别简称为Page、Service、Data。</p><pre><code>{    "module": {        ...        "abilities": [            {                ...                "type": "page"                ...            }        ]        ...    }    ...}</code></pre><h3 id="相关实例"><a href="#相关实例" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对Ability开发，有以下Codelabs可供参考：</p><ul><li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-EducationSystem" target="_blank" rel="noopener">分布式亲子早教系统</a>基于分布式能力，实现一个多屏互动、跨设备协同的亲子早教系统。</p></li><li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-NewsClient" target="_blank" rel="noopener">分布式新闻客户端</a>基于HarmonyOS应用中Service Ability和Page Ability的使用，实现跨设备FA拉起。</p></li><li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-DistributedVideo" target="_blank" rel="noopener">跨设备视频播放</a>基于分布式能力和IDL跨进程通信，实现视频跨设备播放、控制。</p></li><li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-DistributedInput" target="_blank" rel="noopener">分布式输入法</a>基于分布式能力，将手机作为智慧屏的虚拟控制器，控制文字输入和遥控播放。</p></li><li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-DistributedGamepad" target="_blank" rel="noopener">分布式游戏手柄</a>基于分布式能力，将手机作为智慧屏的虚拟手柄终端，组成全新的多人娱乐场景</p></li></ul><h2 id="Page-Ability"><a href="#Page-Ability" class="headerlink" title="Page Ability"></a>Page Ability</h2><h3 id="Page与AbilitySlice"><a href="#Page与AbilitySlice" class="headerlink" title="Page与AbilitySlice"></a>Page与AbilitySlice</h3><p>Page模板（以下简称“Page”）是FA唯一支持的模板，用于提供与用户交互的能力。一个Page可以由一个或多个AbilitySlice构成，AbilitySlice是指应用的单个页面及其控制逻辑的总和。</p><p>当一个Page由多个AbilitySlice共同构成时，这些AbilitySlice页面提供的业务能力应具有高度相关性。例如，新闻浏览功能可以通过一个Page来实现，其中包含了两个AbilitySlice：一个AbilitySlice用于展示新闻列表，另一个AbilitySlice用于展示新闻详情。Page和AbilitySlice的关系如<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-page-concept-0000000000033573#ZH-CN_TOPIC_0000001083176865__fig1379095813590" target="_blank" rel="noopener">图1</a>所示。</p><p><strong>图1</strong> Page与AbilitySlice</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDk3ODEyYjliYThiMWY5YjA5OTJjZTQ4ZGI3NWEwZGFfdHR2QUFkZVdyR2E1QmQ0cUhxSVJQdXh1VngxWkxXN1VfVG9rZW46Ym94Y25lbjFFNmZaWnJZMExYeFV4UU0wM3NiXzE2MjcxNDcyMTM6MTYyNzE1MDgxM19WNA" alt="img"></p><p>相比于桌面场景，移动场景下应用之间的交互更为频繁。通常，单个应用专注于某个方面的能力开发，当它需要其他能力辅助时，会调用其他应用提供的能力。例如，外卖应用提供了联系商家的业务功能入口，当用户在使用该功能时，会跳转到通话应用的拨号页面。与此类似，HarmonyOS支持不同Page之间的跳转，并可以指定跳转到目标Page中某个具体的AbilitySlice。</p><h3 id="AbilitySlice路由配置"><a href="#AbilitySlice路由配置" class="headerlink" title="AbilitySlice路由配置"></a>AbilitySlice路由配置</h3><p>虽然一个Page可以包含多个AbilitySlice，但是Page进入前台时界面默认只展示一个AbilitySlice。默认展示的AbilitySlice是通过<strong>setMainRoute()</strong>方法来指定的。如果需要更改默认展示的AbilitySlice，可以通过<strong>addActionRoute()</strong>方法为此AbilitySlice配置一条路由规则。此时，当其他Page实例期望导航到此AbilitySlice时，可以在<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-intent-0000000000038799" target="_blank" rel="noopener">Intent</a>中指定Action，详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-page-switching-0000000000037999#ZH-CN_TOPIC_0000001076963678__section1862412142519" target="_blank" rel="noopener">不同Page间导航</a>。</p><p>setMainRoute()方法与addActionRoute()方法的使用示例如下：</p><pre><code>public class MyAbility extends Ability {    @Override    public void onStart(Intent intent) {        super.onStart(intent);        // set the main route        setMainRoute(MainSlice.class.getName());        // set the action route        addActionRoute("action.pay", PaySlice.class.getName());        addActionRoute("action.scan", ScanSlice.class.getName());    }}</code></pre><p>addActionRoute()方法中使用的动作命名，需要在应用配置文件（config.json）中注册：</p><pre><code>{    "module": {        "abilities": [            {                "skills":[                    {                        "actions":[                            "action.pay",                            "action.scan"                        ]                    }                ]                ...            }        ]        ...    }    ...}</code></pre><h2 id="Page-Ability生命周期"><a href="#Page-Ability生命周期" class="headerlink" title="Page Ability生命周期"></a>Page Ability生命周期</h2><p>系统管理或用户操作等行为均会引起Page实例在其生命周期的不同状态之间进行转换。Ability类提供的回调机制能够让Page及时感知外界变化，从而正确地应对状态变化（比如释放资源），这有助于提升应用的性能和稳健性。</p><h3 id="Page生命周期回调"><a href="#Page生命周期回调" class="headerlink" title="Page生命周期回调"></a>Page生命周期回调</h3><p>Page生命周期的不同状态转换及其对应的回调，如<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-page-lifecycle-0000000000029840#ZH-CN_TOPIC_0000001083455837__fig3655123011010" target="_blank" rel="noopener">图1</a>所示。</p><p><strong>图1</strong> Page生命周期</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTFiNjAxNTQwZGY0MTNmYmQwZjQ5MDUyZTFiZTVkZmFfVDBjVVhRWTRKYmcxZGgwQkFla0F1STJJbkdOTEJzUTlfVG9rZW46Ym94Y24xVG5ORFdKcVdMek5VRWlMMUFBa2V2XzE2MjcxNDcyMTM6MTYyNzE1MDgxM19WNA" alt="img"></p><ul><li><strong>onStart()</strong>当系统首次创建Page实例时，触发该回调。对于一个Page实例，该回调在其生命周期过程中仅触发一次，Page在该逻辑后将进入INACTIVE状态。开发者必须重写该方法，并在此配置默认展示的AbilitySlice。</li></ul><pre><code>    @Override    public void onStart(Intent intent) {        super.onStart(intent);        super.setMainRoute(FooSlice.class.getName());    }</code></pre><ul><li><p><strong>onActive()</strong>Page会在进入INACTIVE状态后来到前台，然后系统调用此回调。Page在此之后进入ACTIVE状态，该状态是应用与用户交互的状态。Page将保持在此状态，除非某类事件发生导致Page失去焦点，比如用户点击返回键或导航到其他Page。当此类事件发生时，会触发Page回到INACTIVE状态，系统将调用onInactive()回调。此后，Page可能重新回到ACTIVE状态，系统将再次调用onActive()回调。因此，开发者通常需要成对实现onActive()和onInactive()，并在onActive()中获取在onInactive()中被释放的资源。</p></li><li><p><strong>onInactive()</strong>当Page失去焦点时，系统将调用此回调，此后Page进入INACTIVE状态。开发者可以在此回调中实现Page失去焦点时应表现的恰当行为。</p></li><li><p><strong>onBackground()</strong>如果Page不再对用户可见，系统将调用此回调通知开发者用户进行相应的资源释放，此后Page进入BACKGROUND状态。开发者应该在此回调中释放Page不可见时无用的资源，或在此回调中执行较为耗时的状态保存操作。</p></li><li><p><strong>onForeground()</strong>处于BACKGROUND状态的Page仍然驻留在内存中，当重新回到前台时（比如用户重新导航到此Page），系统将先调用onForeground()回调通知开发者，而后Page的生命周期状态回到INACTIVE状态。开发者应当在此回调中重新申请在onBackground()中释放的资源，最后Page的生命周期状态进一步回到ACTIVE状态，系统将通过onActive()回调通知开发者用户。</p></li><li><p>onStop()</p><p>系统将要销毁Page时，将会触发此回调函数，通知用户进行系统资源的释放。销毁Page的可能原因包括以下几个方面：</p><ul><li>用户通过系统管理能力关闭指定Page，例如使用任务管理器关闭Page。</li></ul></li><li><p>用户行为触发Page的terminateAbility()方法调用，例如使用应用的退出功能。</p></li><li><p>配置变更导致系统暂时销毁Page并重建。</p></li><li><p>系统出于资源管理目的，自动触发对处于BACKGROUND状态Page的销毁。</p></li></ul><h3 id="AbilitySlice生命周期"><a href="#AbilitySlice生命周期" class="headerlink" title="AbilitySlice生命周期"></a>AbilitySlice生命周期</h3><p>AbilitySlice作为Page的组成单元，其生命周期是依托于其所属Page生命周期的。AbilitySlice和Page具有相同的生命周期状态和同名的回调，当Page生命周期发生变化时，它的AbilitySlice也会发生相同的生命周期变化。此外，AbilitySlice还具有独立于Page的生命周期变化，这发生在同一Page中的AbilitySlice之间导航时，此时Page的生命周期状态不会改变。</p><p>AbilitySlice生命周期回调与Page的相应回调类似，因此不再赘述。由于AbilitySlice承载具体的页面，开发者必须重写AbilitySlice的onStart()回调，并在此方法中通过setUIContent()方法设置页面，如下所示：</p><pre><code>    @Override    protected void onStart(Intent intent) {        super.onStart(intent);        setUIContent(ResourceTable.Layout_main_layout);    }</code></pre><p>AbilitySlice实例创建和管理通常由应用负责，系统仅在特定情况下会创建AbilitySlice实例。例如，通过导航启动某个AbilitySlice时，是由系统负责实例化；但是在同一个Page中不同的AbilitySlice间导航时则由应用负责实例化。</p><h3 id="Page与AbilitySlice生命周期关联"><a href="#Page与AbilitySlice生命周期关联" class="headerlink" title="Page与AbilitySlice生命周期关联"></a>Page与AbilitySlice生命周期关联</h3><p>当AbilitySlice处于前台且具有焦点时，其生命周期状态随着所属Page的生命周期状态的变化而变化。当一个Page拥有多个AbilitySlice时，例如：MyAbility下有FooAbilitySlice和BarAbilitySlice，当前FooAbilitySlice处于前台并获得焦点，并即将导航到BarAbilitySlice，在此期间的生命周期状态变化顺序为：</p><ol><li>FooAbilitySlice从ACTIVE状态变为INACTIVE状态。</li><li>BarAbilitySlice则从INITIAL状态首先变为INACTIVE状态，然后变为ACTIVE状态（假定此前BarAbilitySlice未曾启动）。</li><li>FooAbilitySlice从INACTIVE状态变为BACKGROUND状态。</li></ol><p>对应两个slice的生命周期方法回调顺序为：</p><pre><code>FooAbilitySlice.onInactive() --&gt; BarAbilitySlice.onStart() --&gt; BarAbilitySlice.onActive() --&gt; FooAbilitySlice.onBackground()</code></pre><p>在整个流程中，MyAbility始终处于ACTIVE状态。但是，当Page被系统销毁时，其所有已实例化的AbilitySlice将联动销毁，而不仅是处于前台的AbilitySlice</p><h2 id="AbilitySlice间导航"><a href="#AbilitySlice间导航" class="headerlink" title="AbilitySlice间导航"></a>AbilitySlice间导航</h2><h3 id="同一Page内导航"><a href="#同一Page内导航" class="headerlink" title="同一Page内导航"></a>同一Page内导航</h3><p>当发起导航的AbilitySlice和导航目标的AbilitySlice处于同一个Page时，您可以通过present()方法实现导航。如下代码片段展示通过点击按钮导航到其他AbilitySlice的方法：</p><pre><code>@Overrideprotected void onStart(Intent intent) {    ...    Button button = ...;    button.setClickedListener(listener -&gt; present(new TargetSlice(), new Intent()));    ...}</code></pre><p>如果开发者希望在用户从导航目标AbilitySlice返回时，能够获得其返回结果，则应当使用presentForResult()实现导航。用户从导航目标AbilitySlice返回时，系统将回调onResult()来接收和处理返回结果，开发者需要重写该方法。返回结果由导航目标AbilitySlice在其生命周期内通过setResult()进行设置。</p><pre><code>@Overrideprotected void onStart(Intent intent) {    ...    Button button = ...;    button.setClickedListener(listener -&gt; presentForResult(new TargetSlice(), new Intent(), 0));    ...}@Overrideprotected void onResult(int requestCode, Intent resultIntent) {    if (requestCode == 0) {        // Process resultIntent here.    }}</code></pre><p>系统为每个Page维护了一个AbilitySlice实例的栈，每个进入前台的AbilitySlice实例均会入栈。当开发者在调用present()或presentForResult()时指定的AbilitySlice实例已经在栈中存在时，则栈中位于此实例之上的AbilitySlice均会出栈并终止其生命周期。前面的示例代码中，导航时指定的AbilitySlice实例均是新建的，即便重复执行此代码（此时作为导航目标的这些实例是同一个类），也不会导致任何AbilitySlice出栈。</p><h3 id="不同Page间导航"><a href="#不同Page间导航" class="headerlink" title="不同Page间导航"></a>不同Page间导航</h3><p>AbilitySlice作为Page的内部单元，以Action的形式对外暴露，因此可以通过配置Intent的Action导航到目标AbilitySlice。Page间的导航可以使用startAbility()或startAbilityForResult()方法，获得返回结果的回调为onAbilityResult()。在Ability中调用setResult()可以设置返回结果。详细用法可参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-intent-0000000000038799#ZH-CN_TOPIC_0000001076675608__section854420303150" target="_blank" rel="noopener">根据Operation的其他属性启动应用</a>中的示例</p><h2 id="跨设备迁移"><a href="#跨设备迁移" class="headerlink" title="跨设备迁移"></a>跨设备迁移</h2><p>跨设备迁移（下文简称“迁移”）支持将Page在同一用户的不同设备间迁移，以便支持用户无缝切换的诉求。以Page从设备A迁移到设备B为例，迁移动作主要步骤如下：</p><ol><li>设备A上的Page请求迁移。</li><li>HarmonyOS处理迁移任务，并回调设备A上Page的保存数据方法，用于保存迁移必须的数据。</li><li>HarmonyOS在设备B上启动同一个Page，并回调其恢复数据方法。</li></ol><p>开发者可以参考以下详细步骤开发具有迁移功能的Page。</p><h3 id="实现IAbilityContinuation接口"><a href="#实现IAbilityContinuation接口" class="headerlink" title="实现IAbilityContinuation接口"></a>实现IAbilityContinuation接口</h3><p>说明</p><p>一个应用可能包含多个Page，仅需要在支持迁移的Page中通过以下方法实现IAbilityContinuation接口。同时，此Page所包含的所有AbilitySlice也需要实现此接口。</p><ul><li><p><strong>onStartContinuation()</strong>Page请求迁移后，系统首先回调此方法，开发者可以在此回调中决策当前是否可以执行迁移，比如，弹框让用户确认是否开始迁移。</p></li><li><p><strong>onSaveData()</strong>如果onStartContinuation()返回true，则系统回调此方法，开发者在此回调中保存必须传递到另外设备上以便恢复Page状态的数据。</p></li><li><p><strong>onRestoreData()</strong>源侧设备上Page完成保存数据后，系统在目标侧设备上回调此方法，开发者在此回调中接受用于恢复Page状态的数据。注意，在目标侧设备上的Page会重新启动其生命周期，无论其启动模式如何配置。且系统回调此方法的时机在onStart()之前。</p></li><li><p><strong>onCompleteContinuation()</strong>目标侧设备上恢复数据一旦完成，系统就会在源侧设备上回调Page的此方法，以便通知应用迁移流程已结束。开发者可以在此检查迁移结果是否成功，并在此处理迁移结束的动作，例如，应用可以在迁移完成后终止自身生命周期。</p></li><li><p><strong>onRemoteTerminated()</strong>如果开发者使用continueAbilityReversibly()而不是continueAbility()，则此后可以在源侧设备上使用reverseContinueAbility()进行回迁。这种场景下，相当于同一个Page（的两个实例）同时在两个设备上运行，迁移完成后，如果目标侧设备上Page因任何原因终止，则源侧Page通过此回调接收终止通知。</p></li></ul><h3 id="请求迁移"><a href="#请求迁移" class="headerlink" title="请求迁移"></a>请求迁移</h3><p>实现IAbilityContinuation的Page可以在其生命周期内，调用continueAbility()或continueAbilityReversibly()请求迁移。两者的区别是，通过后者发起的迁移此后可以进行回迁。</p><pre><code>try {    continueAbility();} catch (IllegalStateException e) {    // Maybe another continuation in progress.    ...}</code></pre><p>以Page从设备A迁移到设备B为例，详细的流程如下：</p><ol><li>设备A上的Page请求迁移。</li><li>系统回调设备A上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onStartContinuation()方法，以确认当前是否可以立即迁移。</li><li>如果可以立即迁移，则系统回调设备A上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onSaveData()方法，以便保存迁移后恢复状态必须的数据。</li><li>如果保存数据成功，则系统在设备B上启动同一个Page，并恢复AbilitySlice栈，然后回调IAbilityContinuation.onRestoreData()方法，传递此前保存的数据；此后设备B上此Page从onStart()开始其生命周期回调。</li><li>系统回调设备A上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onCompleteContinuation()方法，通知数据恢复成功与否。</li></ol><h3 id="请求回迁"><a href="#请求回迁" class="headerlink" title="请求回迁"></a>请求回迁</h3><p>使用continueAbilityReversibly()请求迁移并完成后，源侧设备上已迁移的Page可以发起回迁，以便使用户活动重新回到此设备。</p><pre><code>try {    reverseContinueAbility();} catch (IllegalStateException e) {    // Maybe another continuation in progress.    ...}</code></pre><p>以Page从设备A迁移到设备B后并请求回迁为例，详细的流程如下：</p><ol><li>设备A上的Page请求回迁。</li><li>系统回调设备B上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onStartContinuation()方法，以确认当前是否可以立即迁移。</li><li>如果可以立即迁移，则系统回调设备B上Page及其AbilitySlice栈中所有AbilitySlice实例的IAbilityContinuation.onSaveData()方法，以便保存回迁后恢复状态必须的数据。</li><li>如果保存数据成功，则系统在设备A上Page恢复AbilitySlice栈，然后回调IAbilityContinuation.onRestoreData()方法，传递此前保存的数据。</li><li>如果数据恢复成功，则系统终止设备B上Page的生命周期。</li></ol><h3 id="相关实例-1"><a href="#相关实例-1" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对Page Ability开发，有以下示例工程可供参考：</p><ul><li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/PageAbility" target="_blank" rel="noopener">PageAbility</a>本示例演示了同一Page Ability内和不同Page间的AbilitySlice导航，以及Page Ability的跨端迁移。</li></ul><p>针对跨设备迁移开发，有以下Codelabs可供参考：</p><ul><li><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/Distributed-Mail" target="_blank" rel="noopener">分布式邮件编辑</a>基于跨设备迁移和分布式文件能力，实现邮件的跨设备编辑和附件的调用</li></ul><h2 id="Service-Ability"><a href="#Service-Ability" class="headerlink" title="Service Ability"></a>Service Ability</h2><p>基于Service模板的Ability（以下简称“Service”）主要用于后台运行任务（如执行音乐播放、文件下载等），但不提供用户交互界面。Service可由其他应用或Ability启动，即使用户切换到其他应用，Service仍将在后台继续运行。</p><p>Service是单实例的。在一个设备上，相同的Service只会存在一个实例。如果多个Ability共用这个实例，只有当与Service绑定的所有Ability都退出后，Service才能够退出。由于Service是在主线程里执行的，因此，如果在Service里面的操作时间过长，开发者必须在Service里创建新的线程来处理（详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/inter-thread-overview-0000000000038958" target="_blank" rel="noopener">线程间通信</a>），防止造成主线程阻塞，应用程序无响应。</p><h3 id="创建Service"><a href="#创建Service" class="headerlink" title="创建Service"></a>创建Service</h3><p>介绍如何创建一个Service。</p><ol><li>创建Ability的子类，实现Service相关的生命周期方法。Service也是一种Ability，Ability为Service提供了以下生命周期方法，用户可以重写这些方法，来添加其他Ability请求与Service Ability交互时的处理方法。</li></ol><ul><li><p>onStart()该方法在创建Service的时候调用，用于Service的初始化。在Service的整个生命周期只会调用一次，调用时传入的Intent应为空。</p></li><li><p>onCommand()在Service创建完成之后调用，该方法在客户端每次启动该Service时都会调用，用户可以在该方法中做一些调用统计、初始化类的操作。</p></li><li><p>onConnect()在Ability和Service连接时调用，该方法返回IRemoteObject对象，用户可以在该回调函数中生成对应Service的IPC通信通道，以便Ability与Service交互。Ability可以多次连接同一个Service，系统会缓存该Service的IPC通信对象，只有第一个客户端连接Service时，系统才会调用Service的onConnect方法来生成IRemoteObject对象，而后系统会将同一个RemoteObject对象传递至其他连接同一个Service的所有客户端，而无需再次调用onConnect方法。</p></li><li><p>onDisconnect()在Ability与绑定的Service断开连接时调用。</p></li><li><p>onStop()在Service销毁时调用。Service应通过实现此方法来清理任何资源，如关闭线程、注册的侦听器等。</p></li></ul><p>创建Service的代码示例如下：</p><pre><code>public class ServiceAbility extends Ability {    @Override    public void onStart(Intent intent) {        super.onStart(intent);    }    @Override    public void onCommand(Intent intent, boolean restart, int startId) {        super.onCommand(intent, restart, startId);    }    @Override    public IRemoteObject onConnect(Intent intent) {        return super.onConnect(intent);    }    @Override    public void onDisconnect(Intent intent) {        super.onDisconnect(intent);    }    @Override    public void onStop() {        super.onStop();    }}</code></pre><ol><li>注册Service。Service也需要在应用配置文件中进行注册，注册类型type需要设置为service。</li></ol><pre><code>{    "module": {        "abilities": [                     {                    "name": ".ServiceAbility",                "type": "service",                "visible": true                ...            }        ]        ...    }    ...}</code></pre><h3 id="启动Service"><a href="#启动Service" class="headerlink" title="启动Service"></a>启动Service</h3><p>介绍通过startAbility()启动Service以及对应的停止方法。</p><ul><li>启动ServiceAbility为开发者提供了startAbility()方法来启动另外一个Ability。因为Service也是Ability的一种，开发者同样可以通过将<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-intent-0000000000038799" target="_blank" rel="noopener">Intent</a>传递给该方法来启动Service。不仅支持启动本地Service，还支持启动远程Service。</li></ul><p>开发者可以通过构造包含DeviceId、BundleName与AbilityName的Operation对象来设置目标Service信息。这三个参数的含义如下：</p><ul><li><p>DeviceId：表示设备ID。如果是本地设备，则可以直接留空；如果是远程设备，可以通过ohos.distributedschedule.interwork.DeviceManager提供的getDeviceList获取设备列表，详见《API参考》。</p></li><li><p>BundleName：表示包名称。</p></li><li><p>AbilityName：表示待启动的Ability名称。</p></li></ul><p>启动本地设备Service的代码示例如下：</p><pre><code>Intent intent = new Intent();Operation operation = new Intent.OperationBuilder()        .withDeviceId("")        .withBundleName("com.domainname.hiworld.himusic")        .withAbilityName("com.domainname.hiworld.himusic.ServiceAbility")        .build();intent.setOperation(operation);startAbility(intent);</code></pre><p>启动远程设备Service的代码示例如下：</p><pre><code>Intent intent = new Intent();Operation operation = new Intent.OperationBuilder()        .withDeviceId("deviceId")        .withBundleName("com.domainname.hiworld.himusic")        .withAbilityName("com.domainname.hiworld.himusic.ServiceAbility")        .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE) // 设置支持分布式调度系统多设备启动的标识        .build();intent.setOperation(operation);startAbility(intent);</code></pre><p>执行上述代码后，Ability将通过startAbility() 方法来启动Service。</p><ul><li><p>如果Service尚未运行，则系统会先调用onStart()来初始化Service，再回调Service的onCommand()方法来启动Service。</p></li><li><p>如果Service正在运行，则系统会直接回调Service的onCommand()方法来启动Service。</p></li><li><p>停止ServiceService一旦创建就会一直保持在后台运行，除非必须回收内存资源，否则系统不会停止或销毁Service。开发者可以在Service中通过terminateAbility()停止本Service或在其他Ability调用stopAbility()来停止Service。</p></li></ul><p>停止Service同样支持停止本地设备Service和停止远程设备Service，使用方法与启动Service一样。一旦调用停止Service的方法，系统便会尽快销毁Service</p><h3 id="连接Service"><a href="#连接Service" class="headerlink" title="连接Service"></a>连接Service</h3><p>如果Service需要与Page Ability或其他应用的Service Ability进行交互，则须创建用于连接的Connection。Service支持其他Ability通过connectAbility()方法与其进行连接。</p><p>在使用connectAbility()处理回调时，需要传入目标Service的<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-intent-0000000000038799" target="_blank" rel="noopener">Intent</a>与IAbilityConnection的实例。IAbilityConnection提供了两个方法供开发者实现：onAbilityConnectDone()是用来处理连接Service成功的回调，onAbilityDisconnectDone()是用来处理Service异常死亡的回调。</p><p>创建连接Service回调实例的代码示例如下：</p><pre><code>// 创建连接Service回调实例private IAbilityConnection connection = new IAbilityConnection() {    // 连接到Service的回调    @Override    public void onAbilityConnectDone(ElementName elementName, IRemoteObject iRemoteObject, int resultCode) {        // Client侧需要定义与Service侧相同的IRemoteObject实现类。开发者获取服务端传过来IRemoteObject对象，并从中解析出服务端传过来的信息。    }    // Service异常死亡的回调    @Override    public void onAbilityDisconnectDone(ElementName elementName, int resultCode) {    }};</code></pre><p>连接Service的代码示例如下：</p><pre><code>// 连接ServiceIntent intent = new Intent();Operation operation = new Intent.OperationBuilder()        .withDeviceId("deviceId")        .withBundleName("com.domainname.hiworld.himusic")        .withAbilityName("com.domainname.hiworld.himusic.ServiceAbility")        .build();intent.setOperation(operation);connectAbility(intent, connection);</code></pre><p>同时，Service侧也需要在onConnect()时返回IRemoteObject，从而定义与Service进行通信的接口。onConnect()需要返回一个IRemoteObject对象，HarmonyOS提供了IRemoteObject的默认实现，用户可以通过继承LocalRemoteObject来创建自定义的实现类。Service侧把自身的实例返回给调用侧的代码示例如下：</p><pre><code>// 创建自定义IRemoteObject实现类private class MyRemoteObject extends LocalRemoteObject {    MyRemoteObject(){    }}// 把IRemoteObject返回给客户端@Overrideprotected IRemoteObject onConnect(Intent intent) {    return new MyRemoteObject();}相关实例</code></pre><p>针对Service Ability开发，有以下示例工程可供参考：</p><ul><li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/ServiceAbility" target="_blank" rel="noopener">ServiceAbility</a>本示例演示了Service Ability的启动、停止、连接、断开连接等操作，支持对跨设备的Service Ability进行操作</li></ul><h3 id="Service-Ability生命周期"><a href="#Service-Ability生命周期" class="headerlink" title="Service Ability生命周期"></a>Service Ability生命周期</h3><p>与Page类似，Service也拥有生命周期，如<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-service-lifecycle-0000000000044472#ZH-CN_TOPIC_0000001077123656__fig49671548164217" target="_blank" rel="noopener">图1</a>所示。根据调用方法的不同，其生命周期有以下两种路径：</p><ul><li><p>启动Service该Service在其他Ability调用startAbility()时创建，然后保持运行。其他Ability通过调用stopAbility()来停止Service，Service停止后，系统会将其销毁。</p></li><li><p>连接Service该Service在其他Ability调用connectAbility()时创建，客户端可通过调用disconnectAbility()断开连接。多个客户端可以绑定到相同Service，而且当所有绑定全部取消后，系统即会销毁该Service。</p></li></ul><p><strong>图1</strong> Service生命周期</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDVkMDNkMTBmMTFkYzk2MzhiNGE5ZjNjNWQwMmU4ZmNfbml3eWJvVDZ3SWw0Qks2VGJwbUtWNDd1aW13WmN5UU1fVG9rZW46Ym94Y253b3JySUYyaGhLN1FlSVNiMEF1TGVlXzE2MjcxNDcyMTM6MTYyNzE1MDgxM19WNA" alt="img"></p><h3 id="前台Service"><a href="#前台Service" class="headerlink" title="前台Service"></a>前台Service</h3><p>一般情况下，Service都是在后台运行的，后台Service的优先级都是比较低的，当资源不足时，系统有可能回收正在运行的后台Service。</p><p>在一些场景下（如播放音乐），用户希望应用能够一直保持运行，此时就需要使用前台Service。前台Service会始终保持正在运行的图标在系统状态栏显示。</p><p>使用前台Service并不复杂，开发者只需在Service创建的方法里，调用keepBackgroundRunning()将Service与通知绑定。调用keepBackgroundRunning()方法前需要在配置文件中声明ohos.permission.KEEP_BACKGROUND_RUNNING权限，同时还需要在配置文件中添加对应的backgroundModes参数。在onStop()方法中调用cancelBackgroundRunning()方法可停止前台Service。</p><p>使用前台Service的onStart()代码示例如下：</p><pre><code>// 创建通知，其中1005为notificationIdNotificationRequest request = new NotificationRequest(1005);NotificationRequest.NotificationNormalContent content = new NotificationRequest.NotificationNormalContent();content.setTitle("title").setText("text");NotificationRequest.NotificationContent notificationContent = new NotificationRequest.NotificationContent(content);request.setContent(notificationContent);// 绑定通知，1005为创建通知时传入的notificationIdkeepBackgroundRunning(1005, request);</code></pre><p>在配置文件中，“module &gt; abilities”字段下对当前Service做如下配置：</p><pre><code>{        "name": ".ServiceAbility",    "type": "service",    "visible": true,    "backgroundModes": ["dataTransfer", "location"]}</code></pre><h2 id="Data-Ability"><a href="#Data-Ability" class="headerlink" title="Data Ability"></a>Data Ability</h2><p>使用Data模板的Ability（以下简称“Data”）有助于应用管理其自身和其他应用存储数据的访问，并提供与其他应用共享数据的方法。Data既可用于同设备不同应用的数据共享，也支持跨设备不同应用的数据共享。</p><p>数据的存放形式多样，可以是数据库，也可以是磁盘上的文件。Data对外提供对数据的增、删、改、查，以及打开文件等接口，这些接口的具体实现由开发者提供。</p><h4 id="URI介绍"><a href="#URI介绍" class="headerlink" title="URI介绍"></a>URI介绍</h4><p>Data的提供方和使用方都通过URI（Uniform Resource Identifier）来标识一个具体的数据，例如数据库中的某个表或磁盘上的某个文件。HarmonyOS的URI仍基于URI通用标准，格式如下：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTFmNDhjZWQxYTgzMjExNDY3YTU2ZjA0N2VhOGE5ZWRfUzYwUzYwWHJDZjEzVGVaNmhPOGlEa05LY2Iwc2hja2tfVG9rZW46Ym94Y25NNERGZWNtaUljS3FNWTVTT2hvNWtlXzE2MjcxNDcyMTM6MTYyNzE1MDgxM19WNA" alt="img"></p><ul><li><p>scheme：协议方案名，固定为“dataability”，代表Data Ability所使用的协议类型。</p></li><li><p>authority：设备ID。如果为跨设备场景，则为目标设备的ID；如果为本地设备场景，则不需要填写。</p></li><li><p>path：资源的路径信息，代表特定资源的位置信息。</p></li><li><p>query：查询参数。</p></li><li><p>fragment：可以用于指示要访问的子资源。</p></li></ul><p>URI示例：</p><ul><li><p>跨设备场景：dataability://<em>device_id</em>/<em>com.domainname.dataability.persondata</em>/<em>person</em>/<em>10</em></p></li><li><p>本地设备：dataability:///<em>com.domainname.dataability.persondata</em>/<em>person</em>/<em>10</em></p></li></ul><h3 id="创建Data"><a href="#创建Data" class="headerlink" title="创建Data"></a>创建Data</h3><p>使用Data模板的Ability形式仍然是Ability，因此，开发者需要为应用添加一个或多个Ability的子类，来提供程序与其他应用之间的接口。Data为结构化数据和文件提供了不同API接口供用户使用，因此，开发者需要首先确定好使用何种类型的数据。本章节主要讲述了创建Data的基本步骤和需要使用的接口。</p><p><strong>Data提供方可以自定义数据的增、删、改、查，以及文件打开等功能，并对外提供这些接口。</strong></p><h4 id="确定数据存储方式"><a href="#确定数据存储方式" class="headerlink" title="确定数据存储方式"></a>确定数据存储方式</h4><p>确定数据的存储方式，Data支持以下两种数据形式：</p><ul><li><p>文件数据：如文本、图片、音乐等。</p></li><li><p>结构化数据：如数据库等。</p></li></ul><h4 id="实现UserDataAbility"><a href="#实现UserDataAbility" class="headerlink" title="实现UserDataAbility"></a>实现UserDataAbility</h4><p>UserDataAbility用于接收其他应用发送的请求，提供外部程序访问的入口，从而实现应用间的数据访问。</p><p>实现UserDataAbility，需要在“Project”窗口当前工程的主目录（“entry &gt; src &gt; main &gt; java &gt; com.xxx.xxx”）选择“File &gt; New &gt; Ability &gt; Empty Data Ability”，设置“Data Name”后完成UserDataAbility的创建。</p><p>Data提供了文件存储和数据库存储两组接口供用户使用。</p><p><strong>文件存储</strong></p><p>开发者需要在Data中重写FileDescriptor openFile(Uri uri, String mode)方法来操作文件：uri为客户端传入的请求目标路径；mode为开发者对文件的操作选项，可选方式包含“r”(读), “w”(写), “rw”(读写)等。</p><p>ohos.rpc.MessageParcel类提供了一个静态方法，用于获取MessageParcel实例。开发者可通过获取到的MessageParcel实例，使用dupFileDescriptor()函数复制待操作文件流的文件描述符，并将其返回，供远端应用访问文件。</p><p>示例：根据传入的uri打开对应的文件</p><pre><code>private static final HiLogLabel LABEL_LOG = new HiLogLabel(HiLog.LOG_APP, 0xD00201, "Data_Log");@Overridepublic FileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {    // 创建messageParcel    MessageParcel messageParcel = MessageParcel.obtain();    File file = new File(uri.getDecodedPathList().get(0)); //get(0)是获取URI完整字段中查询参数字段。    if (mode == null || !"rw".equals(mode)) {        file.setReadOnly();    }    FileInputStream fileIs = new FileInputStream(file);    FileDescriptor fd = null;    try {        fd = fileIs.getFD();    } catch (IOException e) {        HiLog.info(LABEL_LOG, "failed to getFD");    }    // 绑定文件描述符    return messageParcel.dupFileDescriptor(fd);}</code></pre><p><strong>数据库存储</strong></p><ol><li>初始化数据库连接。系统会在应用启动时调用onStart()方法创建Data实例。在此方法中，开发者应该创建数据库连接，并获取连接对象，以便后续和数据库进行操作。为了避免影响应用启动速度，开发者应当尽可能将非必要的耗时任务推迟到使用时执行，而不是在此方法中执行所有初始化。</li></ol><p>示例：初始化的时候连接数据库</p><pre><code>private static final String DATABASE_NAME = "UserDataAbility.db";private static final String DATABASE_NAME_ALIAS = "UserDataAbility";private static final HiLogLabel LABEL_LOG = new HiLogLabel(HiLog.LOG_APP, 0xD00201, "Data_Log");private OrmContext ormContext = null;@Overridepublic void onStart(Intent intent) {    super.onStart(intent);    DatabaseHelper manager = new DatabaseHelper(this);    ormContext = manager.getOrmContext(DATABASE_NAME_ALIAS, DATABASE_NAME, BookStore.class);}</code></pre><ol><li>编写数据库操作方法。Ability定义了6个方法供用户处理对数据库表数据的增删改查。这6个方法在Ability中已默认实现，开发者可按需重写。</li></ol><p>无法复制加载中的内容</p><p>这些方法的使用说明如下：</p><ul><li>query()该方法接收三个参数，分别是查询的目标路径，查询的列名，以及查询条件，查询条件由类DataAbilityPredicates构建。根据传入的列名和查询条件查询用户表的代码示例如下：</li></ul><pre><code>public ResultSet query(Uri uri, String[] columns, DataAbilityPredicates predicates) {    if (ormContext == null) {        HiLog.error(LABEL_LOG, "failed to query, ormContext is null");        return null;    }    // 查询数据库    OrmPredicates ormPredicates = DataAbilityUtils.createOrmPredicates(predicates,User.class);    ResultSet resultSet = ormContext.query(ormPredicates, columns);    if (resultSet == null) {        HiLog.info(LABEL_LOG, "resultSet is null");    }    // 返回结果    return resultSet;}</code></pre><p>insert()该方法接收两个参数，分别是插入的目标路径和插入的数据值。其中，插入的数据由ValuesBucket封装，服务端可以从该参数中解析出对应的属性，然后插入到数据库中。此方法返回一个int类型的值用于标识结果。接收到传过来的用户信息并把它保存到数据库中的代码示例如下：</p><pre><code>public int insert(Uri uri, ValuesBucket value) {    // 参数校验    if (ormContext == null) {        HiLog.error(LABEL_LOG, "failed to insert, ormContext is null");        return -1;    }    // 构造插入数据    User user = new User();    user.setUserId(value.getInteger("userId"));    user.setFirstName(value.getString("firstName"));    user.setLastName(value.getString("lastName"));    user.setAge(value.getInteger("age"));    user.setBalance(value.getDouble("balance"));    // 插入数据库    boolean isSuccessful = ormContext.insert(user);    if (!isSuccessful) {        HiLog.error(LABEL_LOG, "failed to insert");        return -1;    }    isSuccessful = ormContext.flush();    if (!isSuccessful) {        HiLog.error(LABEL_LOG, "failed to insert flush");        return -1;    }    DataAbilityHelper.creator(this, uri).notifyChange(uri);    int id = Math.toIntExact(user.getRowId());    return id;}</code></pre><ul><li><p>batchInsert()该方法为批量插入方法，接收一个ValuesBucket数组用于单次插入一组对象。它的作用是提高插入多条重复数据的效率。该方法系统已实现，开发者可以直接调用。</p></li><li><p>delete()该方法用来执行删除操作。删除条件由类DataAbilityPredicates构建，服务端在接收到该参数之后可以从中解析出要删除的数据，然后到数据库中执行。根据传入的条件删除用户表数据的代码示例如下：</p></li></ul><pre><code>public int delete(Uri uri, DataAbilityPredicates predicates) {    if (ormContext == null) {        HiLog.error(LABEL_LOG, "failed to delete, ormContext is null");        return -1;    }    OrmPredicates ormPredicates = DataAbilityUtils.createOrmPredicates(predicates,User.class);    int value = ormContext.delete(ormPredicates);    DataAbilityHelper.creator(this, uri).notifyChange(uri);    return value;}</code></pre><ul><li>update()此方法用来执行更新操作。用户可以在ValuesBucket参数中指定要更新的数据，在DataAbilityPredicates中构建更新的条件等。更新用户表的数据的代码示例如下：</li></ul><pre><code>public int update(Uri uri, ValuesBucket value, DataAbilityPredicates predicates) {    if (ormContext == null) {       HiLog.error(LABEL_LOG, "failed to update, ormContext is null");       return -1;   }   OrmPredicates ormPredicates = DataAbilityUtils.createOrmPredicates(predicates,User.class);   int index = ormContext.update(ormPredicates, value);   HiLog.info(LABEL_LOG, "UserDataAbility update value:" + index);   DataAbilityHelper.creator(this, uri).notifyChange(uri);   return index;}</code></pre><ul><li>executeBatch()此方法用来批量执行操作。DataAbilityOperation中提供了设置操作类型、数据和操作条件的方法，用户可自行设置自己要执行的数据库操作。该方法系统已实现，开发者可以直接调用。</li></ul><p>说明</p><p>上述代码示例中，初始化了数据库类BookStore.class，并通过实体类User.class对该数据库的表User进行增删改查操作。</p><p>关于对象关系映射数据库的具体逻辑，以及示例中BookStore.class与User.class的逻辑关系，可参考“<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-orm-guidelines-0000000000030063" target="_blank" rel="noopener">对象关系映射数据库开发指导</a>”。</p><h4 id="注册UserDataAbility"><a href="#注册UserDataAbility" class="headerlink" title="注册UserDataAbility"></a>注册UserDataAbility</h4><p>和Service类似，开发者必须在配置文件中注册Data。</p><p>配置文件中该字段在创建Data Ability时会自动创建，name与创建的Data Ability一致。</p><p>需要关注以下属性：</p><ul><li><p>type: 类型设置为data</p></li><li><p>uri: 对外提供的访问路径，全局唯一</p></li><li><p>permissions: 访问该data ability时需要申请的访问权限</p></li></ul><p>说明</p><p>如果权限非系统权限，需要在配置文件中进行自定义。请参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886" target="_blank" rel="noopener">权限开发指导</a>中关于“自定义权限”的相关说明。</p><pre><code>{    "name": ".UserDataAbility",     "type": "data",     "visible": true,     "uri": "dataability://com.example.myapplication5.DataAbilityTest",     "permissions": [        "com.example.myapplication5.DataAbility.DATA"     ]}</code></pre><h3 id="访问Data"><a href="#访问Data" class="headerlink" title="访问Data"></a>访问Data</h3><p>开发者可以通过DataAbilityHelper类来访问当前应用或其他应用提供的共享数据。DataAbilityHelper作为客户端，与提供方的Data进行通信。Data接收到请求后，执行相应的处理，并返回结果。DataAbilityHelper提供了一系列与Data Ability对应的方法。</p><p>下面介绍DataAbilityHelper具体的使用步骤。</p><h4 id="声明使用权限"><a href="#声明使用权限" class="headerlink" title="声明使用权限"></a>声明使用权限</h4><p>如果待访问的Data声明了访问需要权限，则访问此Data需要在配置文件中声明需要此权限。声明请参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886#ZH-CN_TOPIC_0000001072906209__table73291742539" target="_blank" rel="noopener">权限申请字段说明</a>。</p><pre><code>"reqPermissions": [    {        "name": "com.example.myapplication5.DataAbility.DATA"    },    // 访问文件还需要添加访问存储读写权限    {        "name": "ohos.permission.READ_USER_STORAGE"    },    {        "name": "ohos.permission.WRITE_USER_STORAGE"    }]</code></pre><h4 id="创建DataAbilityHelper"><a href="#创建DataAbilityHelper" class="headerlink" title="创建DataAbilityHelper"></a>创建DataAbilityHelper</h4><p>DataAbilityHelper为开发者提供了creator()方法来创建DataAbilityHelper实例。该方法为静态方法，有多个重载。最常见的方法是通过传入一个context对象来创建DataAbilityHelper对象。</p><p>获取helper对象示例：</p><ol><li>DataAbilityHelper helper = DataAbilityHelper.creator(this);</li></ol><h4 id="访问Data-Ability"><a href="#访问Data-Ability" class="headerlink" title="访问Data Ability"></a>访问Data Ability</h4><p>DataAbilityHelper为开发者提供了一系列的接口来访问不同类型的数据（文件、数据库等）。</p><ul><li><strong>访问文件</strong>DataAbilityHelper为开发者提供了FileDescriptor openFile(Uri uri, String mode)方法来操作文件。此方法需要传入两个参数，其中uri用来确定目标资源路径，mode用来指定打开文件的方式，可选方式包含“r”(读), “w”(写), “rw”(读写)，“wt”(覆盖写)，“wa”(追加写)，“rwt”(覆盖写且可读)。</li></ul><p>该方法返回一个目标文件的FD（文件描述符），把文件描述符封装成流，开发者就可以对文件流进行自定义处理。</p><p>访问文件示例：</p><pre><code>// 读取文件描述符FileDescriptor fd = helper.openFile(uri, "r");FileInputStream fis = new FileInputStream(fd);// 使用文件描述符封装成的文件流，进行文件操作</code></pre><ul><li><strong>访问数据库</strong>DataAbilityHelper为开发者提供了增、删、改、查以及批量处理等方法来操作数据库。</li></ul><p>说明</p><p>对数据库的操作方法，详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-relational-overview-0000000000030046" target="_blank" rel="noopener">数据管理</a>中各数据库类型的开发指南。</p><p>无法复制加载中的内容</p><p>这些方法的使用说明如下：</p><ul><li>query()查询方法，其中uri为目标资源路径，columns为想要查询的字段。开发者的查询条件可以通过DataAbilityPredicates来构建。查询用户表中id在101-103之间的用户，并把结果打印出来，代码示例如下：</li></ul><pre><code>DataAbilityHelper helper = DataAbilityHelper.creator(this);// 构造查询条件DataAbilityPredicates predicates = new DataAbilityPredicates();predicates.between("userId", 101, 103);// 进行查询ResultSet resultSet = helper.query(uri, columns, predicates);// 处理结果resultSet.goToFirstRow();do {    // 在此处理ResultSet中的记录;} while(resultSet.goToNextRow());</code></pre><ul><li>insert()新增方法，其中uri为目标资源路径，ValuesBucket为要新增的对象。插入一条用户信息的代码示例如下：</li></ul><pre><code>DataAbilityHelper helper = DataAbilityHelper.creator(this);// 构造插入数据ValuesBucket valuesBucket = new ValuesBucket();valuesBucket.putString("name", "Tom");valuesBucket.putInteger("age", 12);helper.insert(uri, valuesBucket);</code></pre><ul><li>batchInsert(）批量插入方法，和insert()类似。批量插入用户信息的代码示例如下：</li></ul><pre><code>DataAbilityHelper helper = DataAbilityHelper.creator(this);// 构造插入数据ValuesBucket[] values = new ValuesBucket[2];values[0] = new ValuesBucket();values[0].putString("name", "Tom");values[0].putInteger("age", 12);values[1] = new ValuesBucket();values[1].putString("name", "Tom1");values[1].putInteger("age", 16);helper.batchInsert(uri, values);</code></pre><ul><li>delete()删除方法，其中删除条件可以通过DataAbilityPredicates来构建。删除用户表中id在101-103之间的用户，代码示例如下：</li></ul><pre><code>DataAbilityHelper helper = DataAbilityHelper.creator(this);// 构造删除条件DataAbilityPredicates predicates = new DataAbilityPredicates();predicates.between("userId", 101, 103);helper.delete(uri, predicates);</code></pre><ul><li>update()更新方法，更新数据由ValuesBucket传入，更新条件由DataAbilityPredicates来构建。更新id为102的用户，代码示例如下：</li></ul><pre><code>DataAbilityHelper helper = DataAbilityHelper.creator(this);// 构造更新条件DataAbilityPredicates predicates = new DataAbilityPredicates();predicates.equalTo("userId", 102);// 构造更新数据ValuesBucket valuesBucket = new ValuesBucket();valuesBucket.putString("name", "Tom");valuesBucket.putInteger("age", 12);helper.update(uri, valuesBucket, predicates);</code></pre><ul><li>executeBatch()此方法用来执行批量操作。DataAbilityOperation中提供了设置操作类型、数据和操作条件的方法，开发者可自行设置自己要执行的数据库操作。插入多条数据的代码示例如下：</li></ul><pre><code>DataAbilityHelper helper = DataAbilityHelper.creator(abilityObj, insertUri);// 构造批量操作ValuesBucket value1 = initSingleValue();DataAbilityOperation opt1 = DataAbilityOperation.newInsertBuilder(insertUri).withValuesBucket(value1).build();ValuesBucket value2 = initSingleValue2();DataAbilityOperation opt2 = DataAbilityOperation.newInsertBuilder(insertUri).withValuesBucket(value2).build();ArrayList&lt;DataAbilityOperation&gt; operations = new ArrayList&lt;DataAbilityOperation&gt;();operations.add(opt1);operations.add(opt2);DataAbilityResult[] result = helper.executeBatch(insertUri, operations);</code></pre><h4 id="相关实例-2"><a href="#相关实例-2" class="headerlink" title="相关实例"></a>相关实例</h4><p>针对Data Ability开发，有以下示例工程可供参考：</p><ul><li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/DataAbility" target="_blank" rel="noopener">DataAbility</a>本示例演示了如何使用Data Ability对数据库进行增、删、改、查，以及读取文本文件。</li></ul><p>针对Data Ability开发，有以下Codelabs可供参考：</p><ul><li><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-Relational-Database" target="_blank" rel="noopener">关系型数据库</a>基于Data Ability的关系型数据库和数据管理能力，实现数据库相关应用服务的快速开发。</li></ul><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Intent是对象之间传递信息的载体。例如，当一个Ability需要启动另一个Ability时，或者一个AbilitySlice需要导航到另一个AbilitySlice时，可以通过Intent指定启动的目标同时携带相关数据。Intent的构成元素包括Operation与Parameters，具体描述参见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-intent-0000000000038799#ZH-CN_TOPIC_0000001076675608__table610715348476" target="_blank" rel="noopener">表1</a>。</p><p>无法复制加载中的内容</p><p>当Intent用于发起请求时，根据指定元素的不同，分为两种类型：</p><ul><li><p>如果同时指定了BundleName与AbilityName，则根据Ability的全称（例如“com.demoapp.FooAbility”）来直接启动应用。</p></li><li><p>如果未同时指定BundleName和AbilityName，则根据Operation中的其他属性来启动应用。</p></li></ul><p>说明</p><p>Intent设置属性时，必须先使用Operation来设置属性。如果需要新增或修改属性，必须在设置Operation后再执行操作。</p><p>关于Intent最简单的使用方法，可参见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/start-overview-0000000000029602" target="_blank" rel="noopener">快速入门</a>的示例代码。其中“<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/start-page-redirection-0000001051242367" target="_blank" rel="noopener">实现页面跳转</a>”重点描述了使用Intent实现两个页面跳转关系的操作。</p><h3 id="根据Ability的全称启动应用"><a href="#根据Ability的全称启动应用" class="headerlink" title="根据Ability的全称启动应用"></a>根据Ability的全称启动应用</h3><p>通过构造包含BundleName与AbilityName的Operation对象，可以启动一个Ability、并导航到该Ability。示例代码如下：</p><pre><code>Intent intent = new Intent();// 通过Intent中的OperationBuilder类构造operation对象，指定设备标识（空串表示当前设备）、应用包名、Ability名称Operation operation = new Intent.OperationBuilder()        .withDeviceId("")        .withBundleName("com.demoapp")        .withAbilityName("com.demoapp.FooAbility")        .build();// 把operation设置到intent中intent.setOperation(operation);startAbility(intent);</code></pre><p>作为处理请求的对象，会在相应的回调方法中接收请求方传递的Intent对象。以导航到另一个Ability为例，导航的目标Ability可以在其onStart()回调的参数中获得Intent对象。</p><h3 id="根据Operation的其他属性启动应用"><a href="#根据Operation的其他属性启动应用" class="headerlink" title="根据Operation的其他属性启动应用"></a>根据Operation的其他属性启动应用</h3><p>有些场景下，开发者需要在应用中使用其他应用提供的某种能力，而不感知提供该能力的具体是哪一个应用。例如开发者需要通过浏览器打开一个链接，而不关心用户最终选择哪一个浏览器应用，则可以通过Operation的其他属性（除BundleName与AbilityName之外的属性）描述需要的能力。如果设备上存在多个应用提供同种能力，系统则弹出候选列表，由用户选择由哪个应用处理请求。以下示例展示使用Intent跨Ability查询天气信息。</p><p><strong>请求方</strong></p><p>在Ability中构造Intent以及包含Action的Operation对象，并调用startAbilityForResult()方法发起请求。然后重写onAbilityResult()回调方法，对请求结果进行处理。</p><pre><code>private void queryWeather() {    Intent intent = new Intent();    Operation operation = new Intent.OperationBuilder()            .withAction(Intent.ACTION_QUERY_WEATHER)            .build();    intent.setOperation(operation);    startAbilityForResult(intent, REQ_CODE_QUERY_WEATHER);}@Overrideprotected void onAbilityResult(int requestCode, int resultCode, Intent resultData) {    switch (requestCode) {        case REQ_CODE_QUERY_WEATHER:            // Do something with result.            ...            return;        default:            ...    }}</code></pre><p><strong>处理方</strong></p><ol><li>作为处理请求的对象，首先需要在配置文件中声明对外提供的能力，以便系统据此找到自身并作为候选的请求处理者。</li></ol><pre><code>{    "module": {        ...        "abilities": [            {                ...                "skills":[                    {                        "actions":[                            "ability.intent.QUERY_WEATHER"                        ]                    }                ]                ...            }        ]        ...    }    ...}</code></pre><ol><li>在Ability中配置路由以便支持以此action导航到对应的AbilitySlice。</li></ol><pre><code>@Overrideprotected void onStart(Intent intent) {    ...    addActionRoute(Intent.ACTION_QUERY_WEATHER, DemoSlice.class.getName());    ...}</code></pre><ol><li>在Ability中处理请求，并调用setResult()方法暂存返回结果。</li></ol><pre><code>@Overrideprotected void onActive() {    ...    Intent resultIntent = new Intent();    setResult(0, resultIntent);   //0为当前Ability销毁后返回的resultCode。    ...}</code></pre><h3 id="相关实例-3"><a href="#相关实例-3" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对Intent开发，有以下示例工程可供参考：</p><ul><li><p><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/Intent" target="_blank" rel="noopener">Intent</a>本示例演示了如何根据Ability的全称启动应用和根据Operation的其他属性启动应用。</p></li><li><p><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/AbilityIntent" target="_blank" rel="noopener">AbilityIntent</a>本示例通过Ability的全称和Operation的其他属性两种方式实现界面跳转以及数据传递</p></li></ul><h2 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h2><p>在HarmonyOS中，分布式任务调度平台对搭载HarmonyOS的多设备构筑的“超级虚拟终端”提供统一的组件管理能力，为应用定义统一的能力基线、接口形式、数据结构、服务描述语言，屏蔽硬件差异；支持远程启动、远程调用、业务无缝迁移等分布式任务。</p><p>分布式任务调度平台在底层实现<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-ability-overview-0000000000029852" target="_blank" rel="noopener">Ability</a>（分布式任务调度的基本组件）跨设备的启动/关闭、连接及断开连接以及迁移等能力，实现跨设备的组件管理：</p><ul><li><p>启动和关闭：向开发者提供管理远程Ability的能力，即支持启动Page模板的Ability，以及启动、关闭Service和Data模板的Ability。</p></li><li><p>连接和断开连接：向开发者提供跨设备控制服务（Service和Data模板的Ability）的能力，开发者可以通过与远程服务连接及断开连接实现获取或注销跨设备管理服务的对象，达到和本地一致的服务调度。</p></li><li><p>迁移能力：向开发者提供跨设备业务的无缝迁移能力，开发者可以通过调用Page模板Ability的迁移接口，将本地业务无缝迁移到指定设备中，打通设备间壁垒。</p></li></ul><h3 id="约束与限制"><a href="#约束与限制" class="headerlink" title="约束与限制"></a>约束与限制</h3><ul><li><p>开发者需要在Intent中设置支持分布式的标记（例如：Intent.FLAG_ABILITYSLICE_MULTI_DEVICE表示该应用支持分布式调度），否则将无法获得分布式能力。</p></li><li><p>开发者通过在config.json中的reqPermissions字段里添加多设备协同访问的权限申请：三方应用使用{“name”: “ohos.permission.DISTRIBUTED_DATASYNC”}。</p></li><li><p>PA（Particle Ability，Service和Data模板的Ability）的调用支持连接及断开连接、启动及关闭这四类行为，在进行调度时：</p><ul><li>开发者必须在Intent中指定PA对应的bundleName和abilityName。</li></ul></li><li><p>当开发者需要跨设备启动、关闭或连接PA时，需要在Intent中指定对端设备的deviceId。开发者可通过如设备管理类DeviceManager提供的getDeviceList获取指定条件下匿名化处理的设备列表，实现对指定设备PA的启动/关闭以及连接管理。</p></li><li><p>FA（Feature Ability，Page模板的Ability）的调用支持启动和迁移行为，在进行调度时：</p><ul><li>当启动FA时，需要开发者在Intent中指定对端设备的deviceId、bundleName和abilityName。</li></ul></li><li><p>FA的迁移实现相同bundleName和abilityName的FA跨设备迁移，因此需要指定迁移设备的deviceId。</p></li><li><p>DevEco Studio远程模拟设备的功能无法调测分布式任务调度，需要在真机环境下进行测试</p></li></ul><h3 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h3><p>开发者在应用中集成分布式调度能力，通过调用指定能力的分布式接口，实现跨设备能力调度。根据Ability模板及意图的不同，分布式任务调度向开发者提供以下六种能力：启动远程FA、启动远程PA、关闭远程PA、连接远程PA、断开连接远程PA和FA跨设备迁移。下面以设备A（本地设备）和设备B（远端设备）为例，进行场景介绍：</p><ol><li>设备A启动设备B的FA：在设备A上通过本地应用提供的启动按钮，启动设备B上对应的FA。例如：设备A控制设备B打开相册，只需开发者在启动FA时指定打开相册的意图即可。</li><li>设备A启动设备B的PA：在设备A上通过本地应用提供的启动按钮，启动设备B上指定的PA。例如：开发者在启动远程服务时通过意图指定音乐播放服务，即可实现设备A启动设备B音乐播放的能力。</li><li>设备A关闭设备B的PA：在设备A上通过本地应用提供的关闭按钮，关闭设备B上指定的PA。类似启动的过程，开发者在关闭远程服务时通过意图指定音乐播放服务，即可实现关闭设备B上该服务的能力。</li><li>设备A连接设备B的PA：在设备A上通过本地应用提供的连接按钮，连接设备B上指定的PA。连接后，通过其他功能相关按钮实现控制对端PA的能力。通过连接关系，开发者可以实现跨设备的同步服务调度，实现如大型计算任务互助等价值场景。</li><li>设备A与设备B的PA断开连接：在设备A上通过本地应用提供断开连接的按钮，将之前已连接的PA断开连接。</li><li>设备A的FA迁移至设备B：设备A上通过本地应用提供的迁移按钮，将设备A的业务无缝迁移到设备B中。通过业务迁移能力，打通设备A和设备B间的壁垒，实现如文档跨设备编辑、视频从客厅到房间跨设备接续播放等场景。</li></ol><h3 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h3><p>分布式调度平台提供的连接和断开连接PA、启动远程FA、启动和关闭PA以及迁移FA的能力，是实现更多价值性场景的基础。</p><p><strong>连接远程PA</strong></p><p>connectAbility(Intent intent, IAbilityConnection conn)接口提供连接指定设备上PA的能力，Intent中指定待连接PA的设备deviceId、bundleName和abilityName。当连接成功后，通过在conn定义的onAbilityConnectDone回调中获取对端PA的服务代理，两者的连接关系则由conn维护。具体的参数定义如下表所示：</p><p>无法复制加载中的内容</p><p><strong>启动远程FA/PA</strong></p><p>startAbility(Intent intent)接口提供启动指定设备上FA和PA的能力，Intent中指定待启动FA/PA的设备deviceId、bundleName和abilityName。具体参数定义如下表所示：</p><p>无法复制加载中的内容</p><p>分布式调度平台还会提供与上述功能相对应的断开远程PA的连接和关闭远程PA的接口，相关的参数与连接、启动的接口类似。</p><ul><li><p>断开远程PA连接：disconnectAbility(IAbilityConnection conn)。</p></li><li><p>关闭远程PA：stopAbility(Intent intent)。</p></li></ul><p><strong>迁移FA</strong></p><p>continueAbility(String deviceId)接口提供将本地FA迁移到指定设备上的能力，需要开发者在调用时指定目标设备的deviceId。具体参数定义如下表所示：</p><p>说明</p><p>Ability和AbilitySlice类均需要实现IAbilityContinuation及其方法，才可以实现FA迁移。</p><p>无法复制加载中的内容</p><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><ol><li>导入功能依赖的包。</li></ol><pre><code>// 以下依赖包含分布式调度平台开放的接口// 用于：连接/断开连接远程PA、启动远程FA、通过连接关系实现对PA的控制import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.ability.IAbilityConnection;import ohos.aafwk.content.Intent;import ohos.aafwk.content.Operation;import ohos.bundle.ElementName;// 为了实现迁移能力，需要引入传递迁移所需数据的包以及实现迁移能力的接口import ohos.aafwk.ability.IAbilityContinuation;import ohos.aafwk.content.IntentParams;// 为了实现跨设备指令及数据通信，需要使用RPC接口import ohos.rpc.IRemoteObject;import ohos.rpc.IRemoteBroker;import ohos.rpc.MessageParcel;import ohos.rpc.MessageOption;import ohos.rpc.RemoteException;import ohos.rpc.RemoteObject;//（可选）多设备场景下涉及设备选择，为此需要引入组网设备发现的能力import ohos.distributedschedule.interwork.DeviceInfo;import ohos.distributedschedule.interwork.DeviceManager;// (可选）设计界面相关的包函数，对FA界面及按钮进行绘制import ohos.agp.components.Button;import ohos.agp.components.Component;import ohos.agp.components.Component.ClickedListener;import ohos.agp.components.ComponentContainer.LayoutConfig;import ohos.agp.components.element.ShapeElement;import ohos.agp.components.PositionLayout;</code></pre><ol><li>（可选）编写一个基本的FA用于使用分布式能力。</li></ol><pre><code>// 调用AbilitySlice模板实现一个用于控制基础功能的FA，AbilitySlice的代码示例如下：public class SampleSlice extends AbilitySlice {    @Override    public void onStart(Intent intent) {        super.onStart(intent);        // 开发者可以自行进行界面设计        // 为按钮设置统一的背景色        // 例如通过PositionLayout可以实现简单界面        PositionLayout layout = new PositionLayout(this);        LayoutConfig config = new LayoutConfig(LayoutConfig.MATCH_PARENT, LayoutConfig.MATCH_PARENT);        layout.setLayoutConfig(config);        ShapeElement buttonBg = new ShapeElement();        buttonBg.setRgbColor(new RgbColor(0, 125, 255));        addComponents(layout, buttonBg, config);        super.setUIContent(layout);    }    @Override    public void onInactive() {        super.onInactive();    }    @Override    public void onActive() {        super.onActive();    }    @Override    public void onBackground() {        super.onBackground();    }    @Override    public void onForeground(Intent intent) {        super.onForeground(intent);    }    @Override    public void onStop() {        super.onStop();    }}</code></pre><p>说明</p><p>此步骤展示了一个简单FA的实现过程，实际开发中请开发者根据需要进行设计。</p><ol><li>使用分布式能力要求开发者在Ability对应的config.json中声明多设备协同访问的权限：三方应用使用{“name”: “ohos.permission.DISTRIBUTED_DATASYNC”}。一个三方应用部署的示例如下：</li></ol><pre><code>{    "reqPermissions": [        {            "name": "ohos.permission.DISTRIBUTED_DATASYNC"        }    ]}</code></pre><p>此外，对于三方应用还要求在实现Ability的代码中显式声明需要使用的权限，如下所示：</p><pre><code>public class SampleSlice extends AbilitySlice {    @Override    public void onStart(Intent intent) {        // 开发者显示声明需要使用的权限        requestPermissionsFromUser(new String[]{"ohos.permission.DISTRIBUTED_DATASYNC"}, 0);        super.onStart(intent);            }}</code></pre><ol><li>（可选）为不同的能力设置相应的控制按钮。</li></ol><pre><code>// 建议开发者按照自己的界面进行按钮设计// 开发者可以自行实现如下createButton的方法，新建一个显示文字text，背景色为buttonBg以及大小尺寸位置符合config设置的按钮，用来与用户交互// private Button createButton(String text, ShapeElement buttonBg, LayoutConfig config)// 按照顺序在PositionLayout中依次添加按钮的示例private void addComponents(PositionLayout linear, ShapeElement buttonBg, LayoutConfig config) {    // 构建远程启动FA的按钮    btnStartRemoteFA = createButton("StartRemoteFA", buttonBg, config);    btnStartRemoteFA.setClickedListener(mStartRemoteFAListener);    linear.addComponent(btnStartRemoteFA);    // 构建远程启动PA的按钮    btnStartRemotePA = createButton("StartRemotePA", buttonBg, config);    btnStartRemotePA.setClickedListener(mStartRemotePAListener);    linear.addComponent(btnStartRemotePA);    // 构建远程关闭PA的按钮    btnStopRemotePA = createButton("StopRemotePA", buttonBg, config);    btnStopRemotePA.setClickedListener(mStopRemotePAListener);    linear.addComponent(btnStopRemotePA);    // 构建连接远程PA的按钮    btnConnectRemotePA = createButton("ConnectRemotePA", buttonBg, config);    btnConnectRemotePA.setClickedListener(mConnectRemotePAListener);    linear.addComponent(btnConnectRemotePA);    // 构建控制连接PA的按钮    btnControlRemotePA = createButton("ControlRemotePA", buttonBg, config);    btnControlRemotePA.setClickedListener(mControlPAListener);    linear.addComponent(btnControlRemotePA);    // 构建与远程PA断开连接的按钮    btnDisconnectRemotePA = createButton("DisconnectRemotePA", buttonBg, config);    btnDisconnectRemotePA.setClickedListener(mDisconnectRemotePAListener);    linear.addComponent(btnDisconnectRemotePA);    // 构建迁移FA的按钮    btnContinueRemoteFA = createButton("ContinueRemoteFA", buttonBg, config);    btnContinueRemoteFA.setClickedListener(mContinueAbilityListener);    linear.addComponent(btnContinueRemoteFA);}</code></pre><p>说明</p><p>此处只展示了基于按钮控制的能力调度方法，实际开发中请开发者根据需要选择能力调度方式。代码示例中未体现按钮如位置、样式等具体的设置方法，详请参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-overview-0000000000500404" target="_blank" rel="noopener">JAVA UI框架</a>。</p><ol><li>通过设备管理DeviceManager提供的getDeviceList接口获取设备列表，用于指定目标设备。</li></ol><pre><code>// ISelectResult是一个自定义接口，用来处理指定设备deviceId后执行的行为 interface ISelectResult {     void onSelectResult(String deviceId); }// 获得设备列表，开发者可在得到的在线设备列表中选择目标设备执行操作private void scheduleRemoteAbility(ISelectResult listener) {    // 调用DeviceManager的getDeviceList接口，通过FLAG_GET_ONLINE_DEVICE标记获得在线设备列表    List&lt;DeviceInfo&gt; onlineDevices = DeviceManager.getDeviceList(DeviceInfo.FLAG_GET_ONLINE_DEVICE);    // 判断组网设备是否为空    if (onlineDevices.isEmpty()) {        listener.onSelectResult(null);        return;    }    int numDevices = onlineDevices.size();    List&lt;String&gt; deviceIds = new ArrayList&lt;&gt;(numDevices);    onlineDevices.forEach((device) -&gt; {        deviceIds.add(device.getDeviceId());    });    // 以选择首个设备作为目标设备为例    // 开发者也可按照具体场景，通过别的方式进行设备选择    String selectDeviceId = deviceIds.get(0);    listener.onSelectResult(selectDeviceId);    }</code></pre><p>上述实例中涉及对在线组网设备的查询，该项能力需要开发者在对应的config.json中声明获取设备列表及设备信息的权限，如下所示：</p><pre><code>{    "reqPermissions": [        {            "name": "ohos.permission.DISTRIBUTED_DEVICE_STATE_CHANGE"        },         {            "name": "ohos.permission.GET_DISTRIBUTED_DEVICE_INFO"        },         {            "name": "ohos.permission.GET_BUNDLE_INFO"        }    ]}</code></pre><ol><li>为启动远程FA的按钮设置点击回调，实现启动远程FA的能力。</li></ol><pre><code>// 启动一个指定bundleName和abilityName的FAprivate ClickedListener mStartRemoteFAListener = new ClickedListener() {    @Override    public void onClick(Component arg0) {        // 启动远程PA        scheduleRemoteAbility(new ISelectResult() {            @Override            void onSelectResult(String deviceId) {                if (deviceId != null) {                    // 通过scheduleRemoteAbility指定目标设备deviceId                    // 指定待启动FA的bundleName和abilityName                    // 例如：bundleName = "com.helloworld"                    //       abilityName = "com.helloworld.SampleFeatureAbility"                    // 设置分布式标记，表明当前涉及分布式能力                    Operation operation = new Intent.OperationBuilder()                            .withDeviceId(deviceId)                            .withBundleName(bundleName)                            .withAbilityName(abilityName)                            .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE)                            .build();                    Intent intent = new Intent();                    intent.setOperation(operation);                    // 通过AbilitySlice包含的startAbility接口实现跨设备启动FA                    startAbility(intent);                }            }        });    }};</code></pre><ol><li>为启动和关闭PA定义回调，实现启动和关闭PA的能力。对于PA的启动、关闭、连接等操作都需要开发者提供目标设备的deviceId。开发者可以通过DeviceManager相关接口得到当前组网下的设备列表，并以弹窗的形式供用户选择，也可以按照实际需要实现其他个性化的处理方式。在点击事件回调函数中，需要开发者指定得到deviceId后的处理逻辑，即实现类似上例中listener.onSelectResult(String deviceId)的方法，代码示例如下：</li></ol><pre><code>// 启动远程PAprivate ClickedListener mStartRemotePAListener = new ClickedListener() {    @Override    public void onClick(Component arg0) {        // 启动远程PA        scheduleRemoteAbility(new ISelectResult() {            @Override            void onSelectResult(String deviceId) {                if (deviceId != null) {                    // bundleName和abilityName与待启动PA对应                    // 例如：bundleName = "com.helloworld"                    //       abilityName = "com.helloworld.SampleParticleAbility"                    Operation operation = new Intent.OperationBuilder()                            .withDeviceId(deviceId)                            .withBundleName(bundleName)                            .withAbilityName(abilityName)                            .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE)                            .build();                    Intent intentToStartPA = new Intent();                    intentToStartPA.setOperation(operation);                    startAbility(intentToStartPA);                }            }        });    }};// 关闭远程PA，和启动类似开发者需要指定待关闭PA对应的bundleName和abilityNameprivate ClickedListener mStopRemotePAListener = new ClickedListener() {    @Override    public void onClick(Component arg0) {        scheduleRemoteAbility(new ISelectResult() {            @Override            void onSelectResult(String deviceId) {                if (deviceId != null) {                    // bundleName和abilityName与待关闭PA对应                    // 例如：bundleName = "com.helloworld"                    //       abilityName = "com.helloworld.SampleParticleAbility"                    Operation operation = new Intent.OperationBuilder()                            .withDeviceId(deviceId)                            .withBundleName(bundleName)                            .withAbilityName(abilityName)                            .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE)                            .build();                    Intent intentToStopPA = new Intent();                    intentToStopPA.setOperation(operation);                    stopAbility(intentToStopPA);                }            }        });    }};</code></pre><p>说明</p><p>启动和关闭的行为类似，开发者只需在Intent中指定待调度PA的deviceId、bundleName和abilityName，并以operation的形式封装到Intent内。通过AbilitySlice（Ability）包含的startAbility()和stopAbility()接口即可实现相应功能。</p><ol><li>设备A连接设备B侧的PA，利用连接关系调用该PA执行特定任务，以及断开连接。</li></ol><pre><code>// 当连接完成时，用来提供管理已连接PA的能力private MyRemoteProxy mProxy = null;// 用于管理连接关系private IAbilityConnection mConn = new IAbilityConnection() {    @Override    public void onAbilityConnectDone(ElementName element, IRemoteObject remote, int resultCode) {        // 跨设备PA连接完成后，会返回一个序列化的IRemoteObject对象        // 通过该对象得到控制远端服务的代理        mProxy = new MyRemoteProxy(remote);        btnConnectRemotePA.setText("connectRemoteAbility done");    }    @Override    public void onAbilityDisconnectDone(ElementName element, int resultCode) {        // 当已连接的远端PA关闭时，会触发该回调        // 支持开发者按照返回的错误信息进行PA生命周期管理        disconnectAbility(mConn);    }};</code></pre><p>仅通过启动/关闭两种方式对PA进行调度无法应对需长期交互的场景，因此，分布式任务调度平台向开发者提供了跨设备PA连接及断开连接的能力。为了对已连接PA进行管理，开发者需要实现一个满足IAbilityConnection接口的连接状态检测实例，通过该实例可以对连接及断开连接完成时设置具体的处理逻辑，例如：获取控制对端PA的代理等。进一步为了使用该代理跨设备调度PA，开发者需要在本地及对端分别实现对外接口一致的代理。一个具备加法能力的代理示例如下：</p><pre><code>// 以连接提供加法计算能力的PA为例。为了提供跨设备连接能力，需要在本地发起连接侧和对端被连接侧分别实现代理// 发起连接侧的代理示例如下：public class MyRemoteProxy implements IRemoteBroker {    private static final int ERR_OK = 0;    private static final int COMMAND_PLUS = IRemoteObject.MIN_TRANSACTION_ID;    private final IRemoteObject remote;    public MyRemoteProxy(IRemoteObject remote) {        this.remote = remote;    }    @Override    public IRemoteObject asObject() {        return remote;    }    public int plus(int a, int b) throws RemoteException {        MessageParcel data = MessageParcel.obtain();        MessageParcel reply = MessageParcel.obtain();        // option不同的取值，决定采用同步或异步方式跨设备控制PA        // 本例需要同步获取对端PA执行加法的结果，因此采用同步的方式，即MessageOption.TF_SYNC        // 具体MessageOption的设置，可参考相关API文档        MessageOption option = new MessageOption(MessageOption.TF_SYNC);        data.writeInt(a);        data.writeInt(b);        try {            remote.sendRequest(COMMAND_PLUS, data, reply, option);            int errCode = reply.readInt();            if (errCode != ERR_OK) {                throw new RemoteException();            }            int result = reply.readInt();            return result;        }finally {            data.reclaim();            reply.reclaim();        }    }}</code></pre><p>此外，对端待连接的PA需要实现对应的客户端，代码示例如下所示：</p><pre><code>// 以计算加法为例，对端实现的客户端如下public class MyRemote extends RemoteObject implements IRemoteBroker{    private static final int ERR_OK = 0;    private static final int ERROR = -1;    private static final int COMMAND_PLUS = IRemoteObject.MIN_TRANSACTION_ID;    public MyRemote() {        super("MyService_Remote");    }    @Override    public IRemoteObject asObject() {        return this;    }    @Override    public boolean onRemoteRequest(int code, MessageParcel data, MessageParcel reply, MessageOption option) {        if (code != COMMAND_PLUS) {            reply.writeInt(ERROR);            return false;        }        int value1 = data.readInt();        int value2 = data.readInt();        int sum = value1 + value2;        reply.writeInt(ERR_OK);        reply.writeInt(sum);        return true;    }}</code></pre><p>对端除了要实现如上所述的客户端外，待连接的PA还需要作如下修改：</p><pre><code>// 为了返回给连接方可调用的代理，需要在该PA中实例化客户端，例如作为该PA的成员变量private MyRemote remote = new MyRemote();// 当该PA接收到连接请求时，即将该客户端转化为代理返回给连接发起侧@Overrideprotected IRemoteObject onConnect(Intent intent) {    super.onConnect(intent);    return remote.asObject();}</code></pre><p>完成上述步骤后，可以通过点击事件实现连接、利用连接关系控制PA以及断开连接等行为，代码示例如下：</p><pre><code>// 连接远程PAprivate ClickedListener mConnectRemotePAListener = new ClickedListener() {    @Override    public void onClick(Component arg0) {        scheduleRemoteAbility(new ISelectResult() {            @Override            void onSelectResult(String deviceId) {                if (deviceId != null) {                    Intent connectPAIntent = new Intent();                    // bundleName和abilityName与待连接的PA一一对应                    // 例如：bundleName = "com.helloworld"                    //       abilityName = "com.helloworld.SampleParticleAbility"                    Operation operation = new Intent.OperationBuilder()                            .withDeviceId(deviceId)                            .withBundleName(bundleName)                            .withAbilityName(abilityName)                            .withFlags(Intent.FLAG_ABILITYSLICE_MULTI_DEVICE)                            .build();                    connectPAIntent.setOperation(operation);                    connectAbility(connectPAIntent, mConn);                }            }        });    }};// 控制已连接PA执行加法private ClickedListener mControlPAListener = new ClickedListener() {    @Override    public void onClick(Component arg0) {        if (mProxy != null) {            int ret = -1;            try {                ret = mProxy.plus(10, 20);            } catch (RemoteException e) {                HiLog.error(LABEL, "ControlRemotePA error");            }            btnControlRemotePA.setText("ControlRemotePA result = " + ret);        }    }};// 与远程PA断开连接private ClickedListener mDisconnectRemotePAListener = new ClickedListener() {    @Override    public void onClick(Component arg0) {        // 按钮复位        btnConnectRemotePA.setText("ConnectRemotePA");        btnControlRemotePA.setText("ControlRemotePA");        disconnectAbility(mConn);    }};</code></pre><p>说明</p><p>通过连接/断开连接远程PA，与跨设备PA建立长期的管理关系。例如在本例中，通过连接关系得到远程PA的控制代理后，实现跨设备计算加法并将结果返回到本地显示。在实际开发中，开发者可以根据需要实现多种分布式场景，例如：跨设备位置/电量等信息的采集、跨设备计算资源互助等。</p><ol><li>设备A将运行时的FA迁移到设备B，实现业务在设备间无缝迁移。</li></ol><pre><code>// 跨设备迁移FA// 本地FA设置当前运行任务private ClickedListener mContinueAbilityListener = new ClickedListener() {    @Override    public void onClick(Component arg0) {        // 用户选择设备后实现业务迁移        scheduleRemoteAbility(new ISelectResult() {            @Override            public void onSelectResult(String deviceId) {                continueAbility(deviceId);            }        });    }};</code></pre><p>FA的迁移还涉及到状态数据的传递，需要继承IAbilityContinuation接口，供开发者实现迁移过程中特定事件的管理能力，代码示例如下：</p><pre><code>public class SampleSlice extends AbilitySlice implements IAbilityContinuation {    @Override    public boolean onSaveData(IntentParams saveData) {        String exampleData = String.valueOf(System.currentTimeMillis());        saveData.setParam("continueParam", exampleData);        return true;    }    @Override    public boolean onRestoreData(IntentParams restoreData) {        // 远端FA迁移传来的状态数据，开发者可以按照特定的场景对这些数据进行处理        Object data = restoreData.getParam("continueParam");        return true;    }    @Override    public void onCompleteContinuation(int result) {        btnContinueRemoteFA.setText("ContinueAbility Done");    }}</code></pre><p>通过自定义迁移事件相关的行为，最终实现对Ability的迁移。具体的定义可以参考相关的API文档，此处主要以较为常用的两个事件，包括迁移发起端完成迁移的回调onCompleteContinuation(int result)以及接收到远端迁移行为传递数据的回调onRestoreData(IntentParams restoreData)。其他还包括迁移到远端设备的FA关闭的回调onRemoteTerminated()、用于本地迁移发起时保存状态数据的回调onSaveData(IntentParams saveData)和本地发起迁移的回调onStartContinuation()。按照实际应用自定义特定场景对应的回调，可以完成多种场景下FA的迁移任务。</p><p>说明</p><ul><li><p>FA迁移可以打通设备间的壁垒，有助于不同能力的设备进行互助。前文以一个简单的例子介绍如何通过分布式任务调度提供的能力，实现FA跨设备的迁移（包括FA启动及状态数据的同步）。</p></li><li><p>FA迁移过程中，远端FA首先接收到发起端FA传输的数据，再执行启动，即onRestoreData()发生在onStart()之前，详见API参考。</p></li></ul><h3 id="相关实例-4"><a href="#相关实例-4" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对分布式任务调度，有以下示例工程可供参考：</p><ul><li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/DistributedScheduler" target="_blank" rel="noopener">DistributedScheduler</a>本示例演示了分布式任务调度的六种场景：启动远程FA，启动远程PA，关闭远程PA，连接远程PA，断开连接远程PA， 和FA跨端迁移。</li></ul><p>针对分布式任务调度，有以下Codelabs可供参考：</p><ul><li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-Distributed-scheduling" target="_blank" rel="noopener">分布式调度启动远程FA</a>基于分布式调度的能力，实现远程FA的启动。</p></li><li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-EducationSystem" target="_blank" rel="noopener">分布式亲子早教系统</a>基于分布式能力，实现一个多屏互动、跨设备协同的亲子早教系统。</p></li><li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-DistributedInput" target="_blank" rel="noopener">分布式输入法</a>基于分布式能力，将手机作为智慧屏的虚拟控制器，控制文字输入和遥控播放。</p></li><li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-Distributed-map-navigation" target="_blank" rel="noopener">分布式地图导航</a>基于分布式能力，实现地图导航信息在手机-车机-智能穿戴设备之间流转</p></li></ul><h2 id="公共事件与通知"><a href="#公共事件与通知" class="headerlink" title="公共事件与通知"></a>公共事件与通知</h2><p>armonyOS通过CES（Common Event Service，公共事件服务）为应用程序提供订阅、发布、退订公共事件的能力，通过ANS（Advanced Notification Service，即通知增强服务）系统服务来为应用程序提供发布通知的能力。</p><ul><li><p>公共事件可分为系统公共事件和自定义公共事件。</p><ul><li>系统公共事件：系统将收集到的事件信息，根据系统策略发送给订阅该事件的用户程序。 例如：用户可感知亮灭屏事件，系统关键服务发布的系统事件（例如：USB插拔，网络连接，系统升级等）。</li></ul></li><li><p>自定义公共事件：应用自定义一些公共事件用来处理业务逻辑。</p></li><li><p>通知提供应用的即时消息或通信消息，用户可以直接删除或点击通知触发进一步的操作。</p></li><li><p>IntentAgent封装了一个指定行为的Intent，可以通过IntentAgent启动Ability和发布公共事件。</p></li></ul><p>应用如果需要接收公共事件，需要订阅相应的事件。</p><h3 id="约束与限制-1"><a href="#约束与限制-1" class="headerlink" title="约束与限制"></a>约束与限制</h3><p><strong>公共事件的约束与限制</strong></p><ul><li><p>目前公共事件仅支持动态订阅。部分系统事件需要具有指定的权限，具体的权限见API参考。</p></li><li><p>目前公共事件订阅不支持多用户。</p></li><li><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li1490625910238" target="_blank" rel="noopener">ThreadMode</a>表示线程模型，目前仅支持HANDLER模式，即在当前UI线程上执行回调函数。</p></li><li><p>deviceId用来指定订阅本地公共事件还是远端公共事件。deviceId为null、空字符串或本地设备deviceId时，表示订阅本地公共事件，否则表示订阅远端公共事件。</p></li></ul><p><strong>通知的约束与限制</strong></p><ul><li><p>通知目前支持六种样式：普通文本、长文本、图片、社交、多行文本和媒体样式。创建通知时必须包含一种样式。</p></li><li><p>通知支持快捷回复。</p></li></ul><p><strong>IntentAgent的限制</strong></p><p>使用IntentAgent启动Ability时，Intent必须指定Ability的包名和类名</p><h3 id="场景介绍-1"><a href="#场景介绍-1" class="headerlink" title="场景介绍"></a>场景介绍</h3><p>每个应用都可以订阅自己感兴趣的公共事件，订阅成功后且公共事件发布后，系统会把其发送给应用。这些公共事件可能来自系统、其他应用和应用自身。HarmonyOS提供了一套完整的API，支持用户订阅、发布和接收公共事件。发布公共事件需要借助CommonEventData对象，接收公共事件需要继承CommonEventSubscriber类并实现onReceiveEvent回调函数。</p><h3 id="接口说明-1"><a href="#接口说明-1" class="headerlink" title="接口说明"></a>接口说明</h3><p>公共事件相关基础类包含<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li14451163813234" target="_blank" rel="noopener">CommonEventData</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li29381475233" target="_blank" rel="noopener">CommonEventPublishInfo</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li1490625910238" target="_blank" rel="noopener">CommonEventSubscribeInfo</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li75811198246" target="_blank" rel="noopener">CommonEventSubscriber</a>和<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li18241142552416" target="_blank" rel="noopener">CommonEventManager</a>。基础类之间的关系如下图所示：</p><p><strong>图1</strong> 公共事件基础类关系图</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDhhOGUwYzI0OGQ0NTE0YTdjNTcxYmU1ZmYwNjQzMmVfOFR6Y2Rva29WNk9zeE8zWVp2cjhFblFDTnUwZDBpdXVfVG9rZW46Ym94Y25SYXJqQk1BNHFIMU9oRXA3VzZOYTRjXzE2MjcxNDcyMTM6MTYyNzE1MDgxM19WNA" alt="img"></p><ul><li><p>CommonEventData</p><p>CommonEventData封装公共事件相关信息。用于在发布、分发和接收时处理数据。在构造CommonEventData对象时，相关参数需要注意以下事项：</p><ul><li>code为有序公共事件的结果码，data为有序公共事件的结果数据，仅用于<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li1559091484011" target="_blank" rel="noopener">有序公共事件</a>场景。</li></ul></li><li><p>intent不允许为空，否则发布公共事件失败。</p></li></ul><p>无法复制加载中的内容</p><ul><li><p>CommonEventPublishInfo</p><p>CommonEventPublishInfo封装公共事件发布相关属性、限制等信息，包括公共事件类型（有序或粘性）、接收者权限等。</p><ul><li>有序公共事件：主要场景是多个订阅者有依赖关系或者对处理顺序有要求，例如：高优先级订阅者可修改公共事件内容或处理结果，包括终止公共事件处理；或者低优先级订阅者依赖高优先级的处理结果等。有序公共事件的订阅者可以通过<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li1490625910238" target="_blank" rel="noopener">CommonEventSubscribeInfo</a>.setPriority()方法指定优先级，缺省为0，优先级范围[-1000, 1000]，值越大优先级越高。</li></ul></li><li><p>粘性公共事件：指公共事件的订阅动作是在公共事件发布之后进行，订阅者也能收到的公共事件类型。主要场景是由公共事件服务记录某些系统状态，如蓝牙、WLAN、充电等事件和状态。不使用粘性公共事件机制时，应用可以通过直接访问系统服务获取该状态；在状态变化时，系统服务、硬件需要提供类似observer等方式通知应用。发布粘性公共事件可以通过setSticky()方法设置， 发布粘性公共事件需要申请如下权限。声明请参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886#ZH-CN_TOPIC_0000001072906209__table73291742539" target="_blank" rel="noopener">权限开发指导表1 reqPermissions权限申请字段说明</a>。</p></li></ul><pre><code>"reqPermissions": [  {    "name": "ohos.permission.COMMONEVENT_STICKY",    "reason": "Obtain the required permission",    "usedScene": {      "ability": [        ".MainAbility"      ],      "when": "inuse"    }  },  {    ...  }]</code></pre><p>无法复制加载中的内容</p><ul><li><strong>CommonEventSubscribeInfo</strong>CommonEventSubscribeInfo封装公共事件订阅相关信息，比如优先级、线程模式、事件范围等。</li></ul><p>线程模式（ThreadMode）：设置订阅者的回调方法执行的线程模式。ThreadMode有HANDLER，POST，ASYNC，BACKGROUND四种模式，目前只支持HANDLER模式。</p><ul><li><p>HANDLER：在Ability的主线程上执行。</p></li><li><p>POST：在事件分发线程执行。</p></li><li><p>ASYNC：在一个新创建的异步线程执行。</p></li><li><p>BACKGROUND：在后台线程执行。</p></li></ul><p>无法复制加载中的内容</p><ul><li><p>CommonEventSubscriber</p><p>CommonEventSubscriber封装公共事件订阅者及相关参数。</p><ul><li>CommonEventSubscriber.AsyncCommonEventResult类处理有序公共事件异步执行，详见API参考。</li></ul></li><li><p>目前只能通过调用<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-common-event-0000000000029871#ZH-CN_TOPIC_0000001050988893__li18241142552416" target="_blank" rel="noopener">CommonEventManager</a>的subscribeCommonEvent()进行订阅。</p></li></ul><p>无法复制加载中的内容</p><ul><li><strong>CommonEventManager</strong>CommonEventManager是为应用提供订阅、退订和发布公共事件的静态接口类。</li></ul><p>无法复制加载中的内容</p><h3 id="发布公共事件"><a href="#发布公共事件" class="headerlink" title="发布公共事件"></a>发布公共事件</h3><p>开发者可以发布四种公共事件：无序的公共事件、带权限的公共事件、有序的公共事件、粘性的公共事件。</p><p><strong>发布无序的公共事件：</strong>构造CommonEventData对象，设置Intent，通过构造operation对象把需要发布的公共事件信息传入intent对象。然后调用 CommonEventManager.publishCommonEvent(CommonEventData) 接口发布公共事件。</p><pre><code>try {    Intent intent = new Intent();       Operation operation = new Intent.OperationBuilder()            .withAction("com.my.test")            .build();    intent.setOperation(operation);    CommonEventData eventData = new CommonEventData(intent);    CommonEventManager.publishCommonEvent(eventData);     HiLog.info(LABEL_LOG, "Publish succeeded"); } catch (RemoteException e) {    HiLog.error(LABEL_LOG, "Exception occurred during publishCommonEvent invocation."); }</code></pre><p><strong>发布携带权限的公共事件：</strong>构造CommonEventPublishInfo对象，设置订阅者的权限。</p><ul><li>订阅者在config.json中申请所需的权限，各字段含义详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886#ZH-CN_TOPIC_0000001072906209__table73291742539" target="_blank" rel="noopener">权限申请字段说明</a>。</li></ul><p>说明</p><p>非系统已定义的权限，需要先在config.json中自定义，才可以申请使用。详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886#ZH-CN_TOPIC_0000001072906209__table16180174018340" target="_blank" rel="noopener">权限定义字段说明</a></p><pre><code>"reqPermissions": [  {    "name": "com.example.MyApplication.permission",    "reason": "Obtain the required permission",    "usedScene": {      "ability": [        ".MainAbility"      ],      "when": "inuse"    }  },   {    ...  }]</code></pre><ul><li>发布带权限的公共事件示例代码如下：</li></ul><pre><code>Intent intent = new Intent();Operation operation = new Intent.OperationBuilder()        .withAction("com.my.test")        .build();intent.setOperation(operation);CommonEventData eventData = new CommonEventData(intent);CommonEventPublishInfo publishInfo = new CommonEventPublishInfo();String[] permissions = {"com.example.MyApplication.permission"};publishInfo.setSubscriberPermissions(permissions); // 设置权限try {       CommonEventManager.publishCommonEvent(eventData, publishInfo);     HiLog.info(LABEL_LOG, "Publish succeeded"); } catch (RemoteException e) {    HiLog.error(LABEL_LOG, "Exception occurred during publishCommonEvent invocation."); }</code></pre><p><strong>发布有序的公共事件：</strong>构造CommonEventPublishInfo对象，通过setOrdered(true)指定公共事件属性为有序公共事件，也可以指定一个最后的公共事件接收者。</p><pre><code>CommonEventSubscriber resultSubscriber = new MyCommonEventSubscriber();CommonEventPublishInfo publishInfo = new CommonEventPublishInfo();publishInfo.setOrdered(true); // 设置属性为有序公共事件try {       CommonEventManager.publishCommonEvent(eventData, publishInfo, resultSubscriber); // 指定resultSubscriber为有序公共事件最后一个接收者。} catch (RemoteException e) {    HiLog.error(LABEL_LOG, "Exception occurred during publishCommonEvent invocation."); }发布粘性公共事件：构造CommonEventPublishInfo对象，通过setSticky(true)指定公共事件属性为粘性公共事件。</code></pre><ol><li>发布者首先在config.json中申请发布粘性公共事件所需的权限，各字段含义详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886#ZH-CN_TOPIC_0000001072906209__table73291742539" target="_blank" rel="noopener">权限申请字段说明</a>。</li></ol><pre><code>{    "reqPermissions": [{        "name": "ohos.permission.COMMONEVENT_STICKY",        "reason": "Obtain the required permission",        "usedScene": {           "ability": [            ".MainAbility"           ],           "when": "inuse"        }    }, {    ...    }]}</code></pre><ol><li>发布粘性公共事件。</li></ol><pre><code>CommonEventPublishInfo publishInfo = new CommonEventPublishInfo();publishInfo.setSticky(true); // 设置属性为粘性公共事件try {       CommonEventManager.publishCommonEvent(eventData, publishInfo); } catch (RemoteException e) {    HiLog.error(LABEL, "Exception occurred during publishCommonEvent invocation."); }</code></pre><h3 id="订阅公共事件"><a href="#订阅公共事件" class="headerlink" title="订阅公共事件"></a>订阅公共事件</h3><ol><li>创建CommonEventSubscriber派生类，在onReceiveEvent()回调函数中处理公共事件。</li></ol><p>说明</p><p>此处不能执行耗时操作，否则会阻塞UI线程，产生用户点击没有反应等异常。</p><pre><code>class MyCommonEventSubscriber extends CommonEventSubscriber {     MyCommonEventSubscriber(CommonEventSubscribeInfo info) {         super(info);       }    @Override     public void onReceiveEvent(CommonEventData commonEventData) {    } }</code></pre><ol><li>构造MyCommonEventSubscriber对象，调用CommonEventManager.subscribeCommonEvent()接口进行订阅。</li></ol><pre><code>String event = "com.my.test";MatchingSkills matchingSkills = new MatchingSkills();matchingSkills.addEvent(event); // 自定义事件matchingSkills.addEvent(CommonEventSupport.COMMON_EVENT_SCREEN_ON); // 亮屏事件CommonEventSubscribeInfo subscribeInfo = new CommonEventSubscribeInfo(matchingSkills);MyCommonEventSubscriber subscriber = new MyCommonEventSubscriber(subscribeInfo);try {    CommonEventManager.subscribeCommonEvent(subscriber); } catch (RemoteException e) {    HiLog.error(LABEL, "Exception occurred during subscribeCommonEvent invocation."); }</code></pre><p>如果订阅拥有指定权限应用发布的公共事件，发布者需要在config.json中申请权限，各字段含义详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886#ZH-CN_TOPIC_0000001072906209__table73291742539" target="_blank" rel="noopener">权限申请字段说明</a>。</p><pre><code>"reqPermissions": [    {        "name": "ohos.abilitydemo.permission.PROVIDER",        "reason": "Obtain the required permission",        "usedScene": {            "ability": ["com.hmi.ivi.systemsetting.MainAbility"],            "when": "inuse"        }    }]</code></pre><p>如果订阅的公共事件是有序的，可以调用setPriority(）指定优先级。</p><pre><code>String event = "com.my.test";MatchingSkills matchingSkills = new MatchingSkills();matchingSkills.addEvent(event); // 自定义事件CommonEventSubscribeInfo subscribeInfo = new CommonEventSubscribeInfo(matchingSkills);subscribeInfo.setPriority(100); // 设置优先级，优先级取值范围[-1000，1000]，值默认为0。MyCommonEventSubscriber subscriber = new MyCommonEventSubscriber(subscribeInfo);try {     CommonEventManager.subscribeCommonEvent(subscriber); } catch (RemoteException e) {     HiLog.error(LABEL, "Exception occurred during subscribeCommonEvent invocation."); }</code></pre><ol><li>针对在onReceiveEvent中不能执行耗时操作的限制，可以使用CommonEventSubscriber的goAsyncCommonEvent()来实现异步操作，函数返回后仍保持该公共事件活跃，且执行完成后必须调用AsyncCommonEventResult .finishCommonEvent()来结束。</li></ol><pre><code>EventRunner runner = EventRunner.create(); // EventRunner创建新线程，将耗时的操作放到新的线程上执行MyEventHandler myHandler = new MyEventHandler(runner); // MyEventHandler为EventHandler的派生类，在不同线程间分发和处理事件和Runnable任务@Overridepublic void onReceiveEvent(CommonEventData commonEventData){    final AsyncCommonEventResult result = goAsyncCommonEvent();    Runnable task = new Runnable() {        @Override        public void run() {            ........         // 待执行的操作，由开发者定义            result.finishCommonEvent(); // 调用finish结束异步操作        }    };    myHandler.postTask(task);} </code></pre><h3 id="退订公共事件"><a href="#退订公共事件" class="headerlink" title="退订公共事件"></a>退订公共事件</h3><p>在Ability的onStop()中调用CommonEventManager.unsubscribeCommonEvent()方法来退订公共事件。调用后，之前订阅的所有公共事件均被退订。</p><pre><code>try {     CommonEventManager.unsubscribeCommonEvent(subscriber); } catch (RemoteException e) {    HiLog.error(LABEL, "Exception occurred during unsubscribeCommonEvent invocation."); }</code></pre><h3 id="相关实例-5"><a href="#相关实例-5" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对公共事件开发，有以下示例工程可供参考：</p><ul><li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/CommonEvent" target="_blank" rel="noopener">CommonEvent</a>本示例演示了公共事件的订阅、发布和退订。</li></ul><p>针对公共事件，有以下Codelabs可供参考：</p><ul><li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-EducationSystem" target="_blank" rel="noopener">分布式亲子早教系统</a>基于分布式能力，实现一个多屏互动、跨设备协同的亲子早教系统。</p></li><li><p><a href="https://developer.huawei.com/consumer/cn/codelabsPortal/carddetails/HarmonyOS-DistributedInput" target="_blank" rel="noopener">分布式输入法</a>基于分布式能力，将手机作为智慧屏的虚拟控制器，控制文字输入和遥控播放</p></li></ul><h2 id="通知开发指导"><a href="#通知开发指导" class="headerlink" title="通知开发指导"></a>通知开发指导</h2><h3 id="场景介绍-2"><a href="#场景介绍-2" class="headerlink" title="场景介绍"></a>场景介绍</h3><p>HarmonyOS提供了通知功能，即在一个应用的UI界面之外显示的消息，主要用来提醒用户有来自该应用中的信息。当应用向系统发出通知时，它将先以图标的形式显示在通知栏中，用户可以下拉通知栏查看通知的详细信息。常见的使用场景：</p><ul><li><p>显示接收到短消息、即时消息等。</p></li><li><p>显示应用的推送消息，如广告、版本更新等。</p></li><li><p>显示当前正在进行的事件，如播放音乐、导航、下载等。</p></li></ul><h3 id="接口说明-2"><a href="#接口说明-2" class="headerlink" title="接口说明"></a>接口说明</h3><p>通知相关基础类包含<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-notification-0000000000038804#ZH-CN_TOPIC_0000001050988895__li1552717269392" target="_blank" rel="noopener">NotificationSlot</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-notification-0000000000038804#ZH-CN_TOPIC_0000001050988895__li10626853134015" target="_blank" rel="noopener">NotificationRequest</a>和<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-notification-0000000000038804#ZH-CN_TOPIC_0000001050988895__li8128174954415" target="_blank" rel="noopener">NotificationHelper</a>。基础类之间的关系如下所示：</p><p><strong>图1</strong> 通知基础类关系图</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDIyODQyNjdhYmEzYWU5MjIyOTNmOTYwYjhhYWZlMWRfaG5rSUpZUFJ4U0w2MEh0Q2ttRm5MYzdrRllidkEzSlFfVG9rZW46Ym94Y250Ukx2cjJnaXNsb254QWJVN0FkMUZkXzE2MjcxNDcyMTM6MTYyNzE1MDgxM19WNA" alt="img"></p><ul><li><strong>NotificationSlot</strong>NotificationSlot可以对提示音、振动、锁屏显示和重要级别等进行设置。一个应用可以创建一个或多个NotificationSlot，在发布通知时，通过绑定不同的NotificationSlot，实现不同用途。</li></ul><p>说明</p><p>NotificationSlot需要先通过NotificationHelper的addNotificationSlot(NotificationSlot)方法发布后，通知才能绑定使用；所有绑定该NotificationSlot的通知在发布后都具备相应的特性，对象在创建后，将无法更改这些设置，对于是否启动相应设置，用户有最终控制权。</p><p>不指定NotificationSlot时，当前通知会使用默认的NotificationSlot，默认的NotificationSlot优先级为LEVEL_DEFAULT。</p><p>无法复制加载中的内容</p><p>NotificationSlot的级别目前支持如下几种， 由低到高：</p><ul><li><p>LEVEL_NONE： 表示通知不发布。</p></li><li><p>LEVEL_MIN：表示通知可以发布，但是不显示在通知栏，不自动弹出，无提示音；该级别不适用于前台服务的场景。</p></li><li><p>LEVEL_LOW：表示通知可以发布且显示在通知栏，不自动弹出，无提示音。</p></li><li><p>LEVEL_DEFAULT：表示通知发布后可在通知栏显示，不自动弹出，触发提示音。</p></li><li><p>LEVEL_HIGH：表示通知发布后可在通知栏显示，自动弹出，触发提示音。</p></li><li><p><strong>NotificationRequest</strong>NotificationRequest用于设置具体的通知对象，包括设置通知的属性，如：通知的分发时间、小图标、大图标、自动删除等参数，以及设置具体的通知类型，如普通文本、长文本等。</p></li></ul><p>无法复制加载中的内容</p><p><strong>具体的通知类型：</strong>目前支持六种类型，包括普通文本NotificationNormalContent、长文本NotificationLongTextContent、图片NotificationPictureContent、多行NotificationMultiLineContent、社交NotificationConversationalContent、媒体NotificationMediaContent。</p><p>无法复制加载中的内容</p><p>说明</p><p>通知发布后，通知的设置不可修改。如果下次发布通知使用相同的id，就会更新之前发布的通知。</p><ul><li><strong>NotificationHelper</strong>NotificationHelper封装了发布、更新、删除通知等静态方法。</li></ul><p>无法复制加载中的内容</p><h3 id="开发步骤-1"><a href="#开发步骤-1" class="headerlink" title="开发步骤"></a>开发步骤</h3><p>通知的开发指导分为创建NotificationSlot、发布通知和取消通知等开发场景。</p><p><strong>创建NotificationSlot</strong></p><p>NotificationSlot可以设置公共通知的震动，锁屏模式，重要级别等，并通过调用NotificationHelper.addNotificationSlot()发布NotificationSlot对象。</p><pre><code>NotificationSlot slot = new NotificationSlot("slot_001", "slot_default", NotificationSlot.LEVEL_MIN); // 创建notificationSlot对象slot.setDescription("NotificationSlotDescription");slot.setEnableVibration(true); // 设置振动提醒slot.setLockscreenVisibleness(NotificationRequest.VISIBLENESS_TYPE_PUBLIC);// 设置锁屏模式slot.setEnableLight(true); // 设置开启呼吸灯提醒slot.setLedLightColor(Color.RED.getValue());// 设置呼吸灯的提醒颜色try {   NotificationHelper.addNotificationSlot(slot);} catch (RemoteException ex) {   HiLog.error(LABEL, "Exception occurred during addNotificationSlot invocation.");}</code></pre><p><strong>发布通知</strong></p><ol><li>构建NotificationRequest对象，应用发布通知前，通过NotificationRequest的setSlotId()方法与NotificationSlot绑定，使该通知在发布后都具备该对象的特征。</li></ol><pre><code>int notificationId = 1;NotificationRequest request = new NotificationRequest(notificationId);request.setSlotId(slot.getId());</code></pre><ol><li>调用setContent()设置通知的内容。</li></ol><pre><code>String title = "title";String text = "There is a normal notification content.";NotificationNormalContent content = new NotificationNormalContent();content.setTitle(title)       .setText(text);NotificationRequest.NotificationContent notificationContent = new NotificationRequest.NotificationContent(content);request.setContent(notificationContent); // 设置通知的内容</code></pre><ol><li>调用publishNotification()发布通知。</li></ol><pre><code>try {   NotificationHelper.publishNotification(request);} catch (RemoteException ex) {   HiLog.error(LABEL, "Exception occurred during publishNotification invocation.");}</code></pre><p><strong>取消通知</strong></p><p>取消通知分为取消指定单条通知和取消所有通知，应用只能取消自己发布的通知。</p><ul><li>调用cancelNotification()取消指定的单条通知。</li></ul><pre><code>int notificationId = 1;try {    NotificationHelper.cancelNotification(notificationId);} catch (RemoteException ex) {    HiLog.error(LABEL, "Exception occurred during cancelNotification invocation.");}</code></pre><ul><li>调用cancelAllNotifications()取消所有通知。</li></ul><pre><code>try {    NotificationHelper.cancelAllNotifications();} catch (RemoteException ex) {    HiLog.error(LABEL, "Exception occurred during cancelAllNotifications invocation.");}</code></pre><h3 id="相关实例-6"><a href="#相关实例-6" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对通知开发，有以下示例工程可供参考：</p><ul><li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/Notification" target="_blank" rel="noopener">Notification</a>通知功能，即在一个应用的UI界面之外显示的消息，主要用来提醒用户有来自该应用中的信息。本示例演示了如何发布通知和取消通知</li></ul><h2 id="IntentAgent开发指导"><a href="#IntentAgent开发指导" class="headerlink" title="IntentAgent开发指导"></a>IntentAgent开发指导</h2><h3 id="场景介绍-3"><a href="#场景介绍-3" class="headerlink" title="场景介绍"></a>场景介绍</h3><p>IntentAgent封装了一个指定行为的<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-intent-0000000000038799" target="_blank" rel="noopener">Intent</a>，可以通过triggerIntentAgent接口主动触发，也可以与通知绑定被动触发。具体的行为包括：启动Ability和发布公共事件。例如：收到通知后，在点击通知后跳转到一个新的Ability，不点击则不会触发。</p><h3 id="接口说明-3"><a href="#接口说明-3" class="headerlink" title="接口说明"></a>接口说明</h3><p>IntentAgent相关基础类包括<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-intentagent-0000001050764907#ZH-CN_TOPIC_0000001050764907__li1179174919115" target="_blank" rel="noopener">IntentAgentHelper</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-intentagent-0000001050764907#ZH-CN_TOPIC_0000001050764907__li1717915251523" target="_blank" rel="noopener">IntentAgentInfo</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-intentagent-0000001050764907#ZH-CN_TOPIC_0000001050764907__li48031552527" target="_blank" rel="noopener">IntentAgentConstant</a>和<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-notification-fwk-intentagent-0000001050764907#ZH-CN_TOPIC_0000001050764907__li1637513341734" target="_blank" rel="noopener">TriggerInfo</a>，基础类之间的关系如下图所示：<strong>图1</strong> IntentAgent基础类关系图</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmU2YzAzY2ExMDcwMzViNWJkOGU5N2ZhZDc5NDhiNTRfM0xDS3RhWGljNzg5dE9NWUFRdm5OWmF0ZDBEc0ZxWWVfVG9rZW46Ym94Y25ZRFpnZ0duZ0VUa2lGblpyV0FzaHllXzE2MjcxNDcyMTM6MTYyNzE1MDgxM19WNA" alt="img"></p><ul><li><strong>IntentAgentHelper</strong>IntentAgentHelper封装了获取、激发、取消IntentAgent等静态方法。</li></ul><p>无法复制加载中的内容</p><ul><li><p>IntentAgentInfo</p><p>IntentAgentInfo类封装了获取一个IntentAgent实例所需的数据。使用构造函数IntentAgentInfo(int requestCode, OperationType operationType, List<flags> flags, List<intent> intents, IntentParams extraInfo)获取IntentAgentInfo对象。</intent></flags></p><ul><li>requestCode：使用者定义的一个私有值。</li></ul></li><li><p>operationType：为IntentAgentConstant.OperationType枚举中的值。</p></li><li><p>flags：为IntentAgentConstant.Flags枚举中的值。</p></li><li><p>intents：将被执行的意图列表。operationType的值为START_ABILITY，START_SERVICE和SEND_COMMON_EVENT时，intents列表只允许包含一个Intent；operationType的值为START_ABILITIES时，intents列表允许包含多个Intent</p></li><li><p>extraInfo：表明如何启动一个有页面的ability，可以为null，只在operationType的值为START_ABILITY和START_ABILITIES时有意义。</p></li><li><p><strong>IntentAgentConstant</strong>IntentAgentConstant类中包含OperationType和Flags两个枚举类：</p></li></ul><p>无法复制加载中的内容</p><ul><li><p>TriggerInfo</p><p>TriggerInfo类封装了主动激发一个IntentAgent实例所需的数据，使用构造函数TriggerInfo(String permission, IntentParams extraInfo, Intent intent, int code)获取TriggerInfo对象。</p><ul><li>permission：IntentAgent的接收者的权限名称，只在operationType的值为SEND_COMMON_EVENT时，该参数才有意义。</li></ul></li><li><p>extraInfo：激发IntentAgent时用户自定义的额外数据。</p></li><li><p>intent：额外的Intent。如果IntentAgentInfo成员变量flags包含CONSTANT_FLAG，则忽略该参数；如果flags包含REPLACE_ELEMENT，REPLACE_ACTION，REPLACE_URI，REPLACE_ENTITIES或REPLACE_BUNDLE，则使用额外Intent的element，action，uri，entities或bundleName属性替换原始Intent中对应的属性。如果intent是空，则不替换原始Intent的属性。</p></li><li><p>code：提供给IntentAgent目标的结果码。</p></li></ul><h3 id="开发步骤-2"><a href="#开发步骤-2" class="headerlink" title="开发步骤"></a>开发步骤</h3><p>获取IntentAgent的代码示例如下：</p><pre><code>// 指定要启动的Ability的BundleName和AbilityName字段// 将Operation对象设置到Intent中Operation operation = new Intent.OperationBuilder()        .withDeviceId("")        .withBundleName("com.testintentagent")        .withAbilityName("com.testintentagent.entry.IntentAgentAbility")        .build();intent.setOperation(operation);List&lt;Intent&gt; intentList = new ArrayList&lt;&gt;();intentList.add(intent);// 定义请求码int requestCode = 200;// 设置flagsList&lt;IntentAgentConstant.Flags&gt; flags = new ArrayList&lt;&gt;();flags.add(IntentAgentConstant.Flags.UPDATE_PRESENT_FLAG);// 指定启动一个有页面的AbilityIntentAgentInfo paramsInfo = new IntentAgentInfo(requestCode, IntentAgentConstant.OperationType.START_ABILITY, flags, intentList, null);// 获取IntentAgent实例IntentAgent agent = IntentAgentHelper.getIntentAgent(this, paramsInfo);通知中添加IntentAgent的代码示例如下:int notificationId = 1;NotificationRequest request = new NotificationRequest(notificationId);String title = "title";String text = "There is a normal notification content.";NotificationRequest.NotificationNormalContent content = new NotificationRequest.NotificationNormalContent();content.setTitle(title)       .setText(text);NotificationContent notificationContent = new NotificationContent(content);request.setContent(notificationContent); // 设置通知的内容request.setIntentAgent(agent); // 设置通知的IntentAgent主动激发IntentAgent的代码示例如下：int code = 100;IntentAgentHelper.triggerIntentAgent(this, agent, null, null, new TriggerInfo(null, null, null, code));</code></pre><h3 id="相关实例-7"><a href="#相关实例-7" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对IntentAgent开发指导，有以下示例工程可供参考：</p><ul><li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/IntentAgent" target="_blank" rel="noopener">IntentAgent</a>本示例演示了如何通过IntentAgent启动Ability和发布公共事件。</li></ul><h2 id="服务卡片"><a href="#服务卡片" class="headerlink" title="服务卡片"></a>服务卡片</h2><p>服务卡片（以下简称“卡片”）是<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/glossary-0000000000029587#ZH-CN_TOPIC_0000001050749051__section5406185415236" target="_blank" rel="noopener">FA</a>的一种界面展示形式，将FA的重要信息或操作前置到卡片，以达到服务直达，减少体验层级目的。</p><p>卡片常用于嵌入到其他应用（当前只支持系统应用）中作为其界面的一部分显示，并支持拉起页面，发送消息等基础的交互功能。卡片使用方负责显示卡片。</p><p>示例如下图所示。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjk3MTFhMjcwZWZiYjczZDEwODkwNGM1MTFlY2Y2OThfcHpLb09hWENDOWdTSTZPWnRRSE1RNUo5ZEFIVXc1SGVfVG9rZW46Ym94Y254TUF0WWoweXk1Mldianp4ZnpTVTZaXzE2MjcxNDcyMTM6MTYyNzE1MDgxM19WNA" alt="img"></p><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><p><strong>卡片使用方</strong>显示卡片内容的宿主应用，控制卡片在宿主中展示的位置。</p></li><li><p><strong>卡片管理服务</strong>用于管理系统中所添加卡片的常驻代理服务，包括卡片对象的管理与使用，以及卡片周期性刷新等。</p></li><li><p><strong>卡片提供方</strong>提供卡片显示内容的HarmonyOS应用或原子化服务，控制卡片的显示内容、控件布局以及控件点击事件。</p></li></ul><p>说明</p><p>卡片使用方和提供方不要求常驻运行，在需要添加/删除/请求更新卡片时，卡片管理服务会拉起卡片提供方获取卡片信息。</p><h4 id="运作机制"><a href="#运作机制" class="headerlink" title="运作机制"></a>运作机制</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjVmYjkzNDJkMmFkZTdjN2Y0Nzc5ODc4NzA0OTQxYjBfRVNpM084SHlNMVVnamhSZ2RhYjlVdUlLQ1ZoRElWMldfVG9rZW46Ym94Y25ld2NMdkJORTZLWHQ3SVdjckdkN3ZiXzE2MjcxNDcyMTM6MTYyNzE1MDgxM19WNA" alt="img"></p><p><strong>卡片管理服务包含以下模块：</strong></p><ul><li><p>周期性刷新：在卡片添加后，根据卡片的刷新策略启动定时任务周期性触发卡片的刷新。</p></li><li><p>卡片缓存管理：在卡片添加到卡片管理服务后，对卡片的视图信息进行缓存，以便下次获取卡片时可以直接返回缓存数据，降低时延。</p></li><li><p>卡片生命周期管理：对于卡片切换到后台或者被遮挡时，暂停卡片的刷新；以及卡片的升级/卸载场景下对卡片数据的更新和清理。</p></li><li><p>卡片使用方对象管理：对卡片使用方的RPC对象进行管理，用于使用方请求进行校验以及对卡片更新后的回调处理。</p></li><li><p>通信适配层：负责与卡片使用方和提供方进行RPC通信。</p></li></ul><p><strong>卡片提供方包含以下模块：</strong></p><ul><li><p>卡片服务：由卡片提供方开发者实现，开发者实现onCreateForm、onUpdateForm和onDeleteForm处理创建卡片、更新卡片以及删除卡片等请求，提供相应的卡片服务。</p></li><li><p>卡片提供方实例管理模块：由卡片提供方开发者实现，负责对卡片管理服务分配的卡片实例进行持久化管理。</p></li><li><p>通信适配层：由HarmonyOS SDK提供，负责与卡片管理服务通信，用于将卡片的更新数据主动推送到卡片管理服务</p></li></ul><h4 id="场景介绍-4"><a href="#场景介绍-4" class="headerlink" title="场景介绍"></a>场景介绍</h4><p>卡片提供方控制卡片实际显示的内容、控件布局以及控件点击事件。开发者可以通过集成以下接口来提供卡片服务。</p><h4 id="接口说明-4"><a href="#接口说明-4" class="headerlink" title="接口说明"></a>接口说明</h4><p>HarmonyOS中的服务卡片为卡片提供方开发者提供以下接口能力。</p><p>无法复制加载中的内容</p><p>其中，onEventNotify仅系统应用才会回调，其他接口回调时机如下图：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTgxNTZlZDMyM2FmMGUyNWU1Yzk1ZTE0ZTM3YjY2NzdfanRQYXZhMkh5RnZYSjNtRnRjS0txUG1qMXBaU3R3VnFfVG9rZW46Ym94Y25ic3VESWxTMExFZE5JcGgyNkdpdklnXzE2MjcxNDcyMTM6MTYyNzE1MDgxM19WNA" alt="img"></p><p>说明</p><p>卡片管理服务不负责保持卡片的活跃状态（设置了定时更新的除外），当使用方作出相应的请求时，管理服务会拉起提供方并回调相应接口。</p><h4 id="Java卡片与JS卡片选型指导"><a href="#Java卡片与JS卡片选型指导" class="headerlink" title="Java卡片与JS卡片选型指导"></a>Java卡片与JS卡片选型指导</h4><p>Java/JS卡片场景能力差异如下表所示：</p><p>无法复制加载中的内容</p><p>综上所述，JS卡片比JAVA卡片支持的控件和能力都更丰富：</p><p>Java卡片：适合作为一个直达入口，没有复杂的页面和事件。</p><p>JS卡片：适合有复杂界面的卡片。</p><h4 id="约束与限制-2"><a href="#约束与限制-2" class="headerlink" title="约束与限制"></a>约束与限制</h4><p>对于同一个Page ability，在config.json中最多支持配置16张卡片</p><h3 id="Java卡片开发指导"><a href="#Java卡片开发指导" class="headerlink" title="Java卡片开发指导"></a>Java卡片开发指导</h3><ol><li>使用DevEco Studio创建卡片工程。卡片应用是一款特殊的元能力服务，其配置文件config.json中声明以下几项，系统能够识别该应用为一款卡片应用，并与系统进行绑定。</li></ol><p>config.json文件”abilities”配置forms模块细节如下，各属性详情可见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-service-widget-provider-java-0000001104082220#ZH-CN_TOPIC_0000001104082220__table163531914131311" target="_blank" rel="noopener">表1</a>。</p><pre><code>"forms": [  {    "name": "Form_Java",    "description": "form_description",    "type": "Java",    "colorMode": "auto",    "isDefault": true,    "updateEnabled": true,    "scheduledUpateTime": "10:30",    "updateDuration": 1,    "defaultDimension": "2*2",    "formVisibleNotify": true,    "supportDimensions": [      "1*2",      "2*2",      "2*4",      "4*4"    ],    "landscapeLayouts": [      "$layout:form_ability_layout_1_2",      "$layout:form_ability_layout_2_2",      "$layout:form_ability_layout_2_4",      "$layout:form_ability_layout_4_4"    ],    "portraitLayouts": [      "$layout:form_ability_layout_1_2",      "$layout:form_ability_layout_2_2",      "$layout:form_ability_layout_2_4",      "$layout:form_ability_layout_4_4"    ],    "formConfigAbility": "ability://SecondFormAbility",    "metaData": {      "customizeData": [        {          "name": "originWidgetName",          "value": "com.huawei.weather.testWidget"        }      ]    }  }]</code></pre><p>说明</p><p>“forms”模块中的name为卡片名，即在onCreateForm中根据AbilitySlice.PARAM_FORM_NAME_KEY可取到的值。</p><p>除此之外，在卡片所在的”abilities”中还需要配置”visible”: true和”formsEnabled”: true。</p><p>无法复制加载中的内容</p><ol><li>创建一个FormAbility，覆写卡片相关回调函数。</li></ol><ul><li><p>onCreateForm(Intent intent)</p></li><li><p>onUpdateForm(long formId)</p></li><li><p>onDeleteForm(long formId)</p></li><li><p>onCastTempForm(long formId)</p></li><li><p>onEventNotify(Map&lt;Long, Integer&gt; formEvents)</p></li></ul><p>在onCreateForm(Intent intent)中，当卡片使用方请求获取卡片时，卡片提供方会被拉起并调用onCreateForm(Intent intent)回调，intent中会带有卡片ID，卡片名称，临时卡片标记和卡片外观规格信息，分别通过AbilitySlice.PARAM_FORM_IDENTITY_KEY、AbilitySlice.PARAM_FORM_NAME_KEY、AbilitySlice.PARAM_FORM_TEMORARY_KEY和AbilitySlice.PARAM_FORM_DIMENSION_KEY按需获取。</p><p>提供方可以通过AbilitySlice.PARAM_FORM_CUSTOMIZE_KEY获取卡片使用方设置的自定义数据。</p><pre><code>public class FormAbility extends Ability {    ......    @Override    public void onStart(Intent intent) {        super.onStart(intent);        ......    }    @Override    protected ProviderFormInfo onCreateForm(Intent intent) {        long formId = intent.getLongParam(AbilitySlice.PARAM_FORM_IDENTITY_KEY, 0);        String formName = intent.getStringParam(AbilitySlice.PARAM_FORM_NAME_KEY);        int specificationId = intent.getIntParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY, 0);        boolean tempFlag = intent.getBooleanParam(AbilitySlice.PARAM_FORM_TEMPORARY_KEY, false);        // 获取自定义数据        IntentParams intentParams = intent.getParam(AbilitySlice.PARAM_FORM_CUSTOMIZE_KEY);        HiLog.info(LABEL_LOG, "onCreateForm: " + formId + " " + formName + " " + specificationId);        // 开发者需要根据卡片的名称以及外观规格获取对应的xml布局并构造卡片对象，此处ResourceTable.Layout_form_ability_layout_2_2仅为示例        ProviderFormInfo formInfo = new ProviderFormInfo(ResourceTable.Layout_form_ability_layout_2_2, this);        // 获取卡片信息        String formData = getInitFormData(formName, specificationId);        ComponentProvider componentProvider = new ComponentProvider();        componentProvider.setText(ResourceTable.Id_title, "formData-" + formData);        formInfo.mergeActions(componentProvider);        ......        HiLog.info(LABEL_LOG, "onCreateForm finish.......");        return formInfo;    }    @Override    protected void onDeleteForm(long formId) {        super.onDeleteForm(formId);        // 删除卡片实例数据，需要由开发者实现        deleteFormInfo(formId);        ......    }    @Override    // 若卡片支持定时更新/定点更新/卡片使用方主动请求更新功能，则提供方需要覆写该方法以支持数据更新    protected void onUpdateForm(long formId) {        super.onUpdateForm(formId);        // 更新卡片信息，由开发者实现        ......    }    @Override    protected void onCastTempForm(long formId) {        // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理，将数据持久化。        super.onCastTempForm (formId);        ......    }    @Override    protected void onEventNotify(Map&lt;Long, Integer&gt; formEvents) {        // 使用方发起可见或者不可见通知触发，提供方需要做相应的处理，比如卡片可见时刷新卡片，仅系统应用能收到该回调。        super.onEventNotify(formEvents);        ......    }}</code></pre><ol><li>卡片信息持久化。因大部分卡片提供方都不是常驻服务，只有在需要使用时才会被拉起获取卡片信息。且卡片框架支持对卡片进行多实例管理，卡片ID对应实例ID，因此若卡片提供方支持对卡片数据进行配置，则需要提供方对卡片的业务数据按照卡片ID进行持久化管理，以便在后续获取、更新以及拉起时能获取到正确的卡片业务数据。</li></ol><p>同时，需要适配onDeleteForm(int formId)卡片删除通知接口，在其中实现卡片实例数据的删除。和JS卡片相同，需要注意卡片使用方在请求卡片时传递给提供方应用的Intent数据中存在临时标记字段，表示此次请求的卡片是否为临时卡片，由于临时卡片的数据不会持久化的特殊性，某些场景比如卡片服务框架死亡重启，此时临时卡片数据在卡片服务框架中已经删除，且对应的卡片ID不会通知到提供方，所以卡片提供方需要自己负责清理长时间未删除的临时卡片数据。同时对应的卡片使用方可能会将之前请求的临时卡片转换为常态卡片。如果转换成功，卡片提供方也需要对对应的临时卡片ID进行处理，把卡片提供方记录的临时卡片数据转换为常态卡片数据，防止提供方在清理长时间未删除的临时卡片时，把已经转换为常态卡片的临时卡片信息删除，导致卡片信息丢失。</p><pre><code>@Overrideprotected ProviderFormInfo onCreateForm(Intent intent) {    long formId = intent.getLongParam(AbilitySlice.PARAM_FORM_ID_KEY, -1L);    String formName = intent.getStringParam(AbilitySlice.PARAM_FORM_NAME_KEY);    int specificationId = intent.getIntParam(AbilitySlice.PARAM_FORM_DIMENSION_KEY, 0);    boolean tempFlag = params.getBooleanParam(AbilitySlice.PARAM_FORM_TEMPORARY_KEY, false);    HiLog.info(LABEL_LOG, "onCreateForm: " + formId + " " + formName + " " + specificationId);    .......    // 将创建的卡片信息持久化，以便在下次获取/更新该卡片实例时进行使用，该方法需要由开发者实现。    storeFormInfo(formId, formName, specificationId, formData);    ......    HiLog.info(LABEL_LOG, "onCreateForm finish.......");    return formInfo;}@Overrideprotected void onDeleteForm(long formId) {    super.onDeleteForm(formId);    // 由开发人员自行实现，删除卡片实例数据    deleteFormInfo(formId);    ......}@Overrideprotected void onCastTempForm(long formId) {    // 使用方将临时卡片转换为常态卡片触发，提供方需要做相应的处理    super.onCastTempForm (formId);    ......}</code></pre><ol><li>卡片数据更新。当需要卡片提供方更新数据时（如触发了定时更新，定点更新，或者卡片使用方主动请求更新），卡片提供方获取最新数据，并调用updateForm接口更新卡片。示例如下：</li></ol><pre><code>@Overrideprotected void onUpdateForm(long formId) {    super.onUpdateForm(formId);    ComponentProvider componentProvider = new ComponentProvider(ResourceTable.Layout_form_ability_layout_2_2, this);    // 获取卡片实例需要更新的卡片数据，需要由开发者实现    String formData = getUpdateFormData(formId);    componentProvider.setText(ResourceTable.Id_title, "update formData-" + formData);    updateForm(formId, componentProvider);    ......}</code></pre><p>卡片使用方点击拉起卡片页面，会在onStart(Intent intent)中携带formId（通过AbilitySlice.PARAM_FORM_IDENTITY_KEY获取），若需要在AbilitySlice中更新，也可以使用updateForm接口进行更新，示例如下：</p><pre><code>public class FormAbilitySlice extends AbilitySlice {    ......    @Override    public void onStart(Intent intent) {        super.onStart(intent);        ......        Button button = new Button(this);        button.setText("Update form data");        button.setClickedListener(component -&gt; {            ......            if (intent.hasParameter(AbilitySlice.PARAM_FORM_IDENTITY_KEY)) {                int formId = intent.getIntParam(AbilitySlice.PARAM_FORM_ID_KEY, -1);                ComponentProvider componentProvider = new ComponentProvider(ResourceTable.Layout_form_ability_layout_2_2, context);                String formData = getUpdateFormData(formId);                componentProvider.setText(ResourceTable.Id_modifylayout, "update formData-" + formData);                getAbility().updateForm(formId, componentProvider);            }        });        ......    }}</code></pre><ol><li>Java卡片控制事件。Java卡片当前通过IntentAgent能力支持对卡片控制设置事件，例如可以使用START_ABILITY、START_SERVICE这两类能力，在点击整张卡片时，跳转到提供卡片的ability。</li></ol><p>示例如下：</p><pre><code>@Overrideprotected ProviderFormInfo onCreateForm(Intent intent) {    ......    ProviderFormInfo formInfo = new ProviderFormInfo(ResourceTable.Layout_form_ability_layout_2_2, this);    ComponentProvider componentProvider = new ComponentProvider();    // 针对title控件设置事件    componentProvider.setIntentAgent(ResourceTable.Id_title, startAbilityIntentAgent());    formInfo.mergeActions(componentProvider);    ......    return formInfo;}// 设置触发的事件为系统预置的HarmonyOS betaApp应用private IntentAgent startAbilityIntentAgent() {    Intent intent = new Intent();    Operation operation = new Intent.OperationBuilder()            .withDeviceId("")            .withBundleName("com.huawei.ohos.betaapp.link")            .withAbilityName("com.huawei.ohos.betaapp.link.MainAbility")            .build();    intent.setOperation(operation);    List&lt;Intent&gt; intentList = new ArrayList&lt;&gt;();    intentList.add(intent);    List&lt;Flags&gt; flags = new ArrayList&lt;&gt;();    flags.add(Flags.UPDATE_PRESENT_FLAG);    IntentAgentInfo paramsInfo = new IntentAgentInfo(200, IntentAgentConstant.OperationType.START_ABILITY, flags, intentList, null);    IntentAgent intentAgent = IntentAgentHelper.getIntentAgent(this, paramsInfo);    return intentAgent;}</code></pre><ol><li>开发Java卡片布局。在使用DevEco Studio创建模块时会生成对应的Java UI xml布局文件，具体规则请参考《<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-component-layout-xml-0000000000500395" target="_blank" rel="noopener">XML创建布局</a>》，需要注意设置ohos:remote=”true”。</li></ol><p>以下是天气卡片xml布局示例，供参考：</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;DependentLayout xmlns:ohos="http://schemas.huawei.com/res/ohos"                 ohos:width="match_parent"                 ohos:height="match_parent"                 ohos:id="$+id:background"                 ohos:orientation="vertical"                 ohos:background_element="$media:weather"                 ohos:remote="true"&gt;        &lt;Text                ohos:id="$+id:title"                ohos:text="天气1"                ohos:text_size="39px"                ohos:text_color="#b0c4de"                ohos:top_margin="42px"                ohos:left_margin="20px"                ohos:width="match_content"                ohos:height="match_content"/&gt;        &lt;Text                ohos:id="$+id:temperature"                ohos:text="35°"                ohos:text_size="100px"                ohos:text_color="#b0c4de"                ohos:top_margin="25px"                ohos:left_margin="20px"                ohos:below="$id:title"                ohos:width="match_content"                ohos:height="match_content"/&gt;        &lt;Text                ohos:id="$+id:location"                ohos:text="上海"                ohos:text_size="39px"                ohos:text_color="#b0c4de"                ohos:top_margin="24px"                ohos:left_margin="20px"                ohos:below="$id:temperature"                ohos:width="match_content"                ohos:height="match_content"/&gt;        &lt;Text                ohos:id="$+id:textView4"                ohos:text="9月4号 星期五"                ohos:text_size="39px"                ohos:text_color="#b0c4de"                ohos:top_margin="10px"                ohos:left_margin="20px"                ohos:below="$id:location"                ohos:width="match_content"                ohos:height="match_content"/&gt;        &lt;Text                ohos:id="$+id:textView5"                ohos:text="多云"                ohos:text_size="39px"                ohos:text_color="#b0c4de"                ohos:top_margin="10px"                ohos:left_margin="150px"                ohos:below="$id:location"                ohos:end_of="$id:textView4"                ohos:align_parent_end="true"                ohos:width="match_content"                ohos:height="match_content"/&gt;        &lt;Image                ohos:id="$+id:imageView"                ohos:width="160px"                ohos:height="150px"                ohos:top_margin="20px"                ohos:left_margin="150px"                ohos:below="$id:title"                ohos:end_of="$id:temperature"                ohos:image_src="$media:clouds"/&gt;&lt;/DependentLayout&gt;</code></pre><h2 id="剪贴板"><a href="#剪贴板" class="headerlink" title="剪贴板"></a>剪贴板</h2><p>用户通过系统剪贴板服务，可实现应用之间的简单数据传递。例如：在应用A中复制的数据，可以在应用B中粘贴，反之亦可。</p><ul><li><p>HarmonyOS提供系统剪贴板服务的操作接口，支持用户程序从系统剪贴板中读取、写入和查询剪贴板数据，以及添加、移除系统剪贴板数据变化的回调。</p></li><li><p>HarmonyOS提供剪贴板数据的对象定义，包含内容对象和属性对象</p></li></ul><h3 id="场景介绍-5"><a href="#场景介绍-5" class="headerlink" title="场景介绍"></a>场景介绍</h3><p>同一设备的应用程序A、B之间可以借助系统剪贴板服务完成简单数据的传递，即应用程序A向剪贴板服务写入数据后，应用程序B可以从中读取出数据。</p><p><strong>图1</strong> 剪贴板服务示意图</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjNkZDIzOTA3ZDBmYWNhODM0Y2Y4M2ZjM2UwYzBmYTZfNExwN3I3MW02ckVOOENvSllpaEF1VE1wR0VlNHBwQkJfVG9rZW46Ym94Y25nenVhOFVNY0JsZUdqY0RRMThDZ2NmXzE2MjcxNDcyMTM6MTYyNzE1MDgxM19WNA" alt="img"></p><p>在使用剪贴板服务时，需要注意以下几点：</p><ul><li><p>只有在前台获取到焦点的应用才有读取系统剪贴板的权限（系统默认输入法应用除外）。</p></li><li><p>写入到剪贴板服务中的剪贴板数据不会随应用程序结束而销毁。</p></li><li><p>对同一用户而言，写入剪贴板服务的数据会被下一次写入的剪贴板数据所覆盖。</p></li><li><p>在同一设备内，剪贴板单次传递内容不应超过500KB。</p></li></ul><h3 id="接口说明-5"><a href="#接口说明-5" class="headerlink" title="接口说明"></a>接口说明</h3><p>SystemPasteboard提供系统剪贴板操作的相关接口，比如复制、粘贴、配置回调等。PasteData是剪贴板服务操作的数据对象，一个PasteData由若干个内容节点（PasteData.Record）和一个属性集合对象（PasteData.DataProperty）组成。Record是存放剪贴板数据内容信息的最小单位，每个Record都有其特定的MIME类型，如纯文本、HTML、URI、Intent。剪贴板数据的属性信息存在放PasteData.DataProperty中，包括标签、时间戳等。</p><p><strong>SystemPasteboard</strong></p><p>SystemPasteboard提供系统剪贴板服务的操作接口，比如复制、粘贴、配置回调等。</p><p>无法复制加载中的内容</p><p><strong>PasteData</strong></p><p>PasteData是剪贴板服务操作的数据对象，其中内容节点定义为PasteData.Record，属性集合定义为PasteData.DataProperty。</p><p>无法复制加载中的内容</p><p>无法复制加载中的内容</p><p><strong>PasteData.Record</strong></p><p>一个PasteData中包含若干个特定MIME类型的PasteData.Record，每个Record是存放剪贴板数据内容信息的最小单位。</p><p>无法复制加载中的内容</p><p><strong>PasteData.DataProperty</strong></p><p>每个PasteData中都有一个PasteData.DataProperty成员，其中存放着该数据对象的属性集合，例如自定义标签、MIME类型集合列表等。</p><p>无法复制加载中的内容</p><p><strong>IPasteDataChangedListener</strong></p><p>IPasteDataChangedListener是定义剪贴板数据变化回调的接口类，开发者需要实现此接口来编码触发回调时的处理逻辑。</p><p>无法复制加载中的内容</p><h3 id="开发步骤-3"><a href="#开发步骤-3" class="headerlink" title="开发步骤"></a>开发步骤</h3><ol><li>应用A获取系统剪贴板服务。</li></ol><pre><code>SystemPasteboard pasteboard = SystemPasteboard.getSystemPasteboard(appContext);</code></pre><ol><li>应用A向系统剪贴板中写入一条纯文本数据。</li></ol><pre><code>if (pasteboard != null) {    pasteboard.setPasteData(PasteData.creatPlainTextData("Hello, world!"));}</code></pre><ol><li>应用B从系统剪贴板读取数据，将数据对象中的首个文本类型（纯文本/HTML）内容信息在控件中显示，忽略其他类型内容。</li></ol><pre><code>PasteData pasteData = pasteboard.getPasteData();if (pasteData == null) {    return;}DataProperty dataProperty = pasteData.getProperty();boolean hasHtml = dataProperty.hasMimeType(PasteData.MIMETYPE_TEXT_HTML);boolean hasText = dataProperty.hasMimeType(PasteData.MIMETYPE_TEXT_PLAIN);if (hasHtml || hasText) {    Text text = (Text) findComponentById(ResourceTable.Id_text);    for (int i = 0; i &lt; pasteData.getRecordCount(); i++) {        PasteData.Record record = pasteData.getRecordAt(i);        String mimeType = record.getMimeType();        if (mimeType.equals(PasteData.MIMETYPE_TEXT_HTML)) {            text.setText(record.getHtmlText());            break;        } else if (mimeType.equals(PasteData.MIMETYPE_TEXT_PLAIN)) {            text.setText(record.getPlainText().toString());            break;        } else {            // skip records of other Mime type         }    }}</code></pre><ol><li>应用C注册添加系统剪贴板数据变化回调，当系统剪贴板数据发生变化时触发处理逻辑。</li></ol><pre><code>IPasteDataChangedListener listener = new IPasteDataChangedListener() {    @Override    public void onChanged() {        PasteData pasteData = pasteboard.getPasteData();        if (pasteData == null) {            return;        }        // Operations to handle data change on the system pasteboard    }};pasteboard.addPasteDataChangedListener(listener);</code></pre><h3 id="相关实例-8"><a href="#相关实例-8" class="headerlink" title="相关实例"></a>相关实例</h3><p>针对剪贴板开发指导，有以下示例工程可供参考：</p><ul><li><a href="https://gitee.com/openharmony/app_samples/tree/master/ability/Pasteboard" target="_blank" rel="noopener">Pasteboard</a>本示例演示了应用之间的数据剪贴</li></ul><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><h1 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a>媒体</h1><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h1 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h1><h1 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h1><h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><h1 id="原子化服务"><a href="#原子化服务" class="headerlink" title="原子化服务"></a>原子化服务</h1><h1 id="流转"><a href="#流转" class="headerlink" title="流转"></a>流转</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Harmony </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Harmony </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HarmonyOS开发：基础入门</title>
      <link href="/posts/9ee5.html"/>
      <url>/posts/9ee5.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>为了方便开发者正确获取内容，本导读基于HarmonyOS<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/document-outline-0000001064589184#ZH-CN_TOPIC_0000001064589184__section149501044202918" target="_blank" rel="noopener">通用开发历程</a>对相关资源进行了分类，并对<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/document-outline-0000001064589184#ZH-CN_TOPIC_0000001064589184__section254451314363" target="_blank" rel="noopener">原子化服务</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/document-outline-0000001064589184#ZH-CN_TOPIC_0000001064589184__section101030123017" target="_blank" rel="noopener">设备</a>相关的差异化开发历程进行了说明。</p><p>开发者可以使用HUAWEI DevEco Studio（<a href="https://developer.harmonyos.com/cn/develop/deveco-studio#download" target="_blank" rel="noopener">点击链接获取工具</a>）开发HarmonyOS用户应用程序。HUAWEI DevEco Studio是面向华为终端全场景多设备的一站式集成开发环境（IDE）。</p><p>除此之外，本导读还对<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/document-outline-0000001064589184#ZH-CN_TOPIC_0000001064589184__section642572414140" target="_blank" rel="noopener">开发者教程</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/document-outline-0000001064589184#ZH-CN_TOPIC_0000001064589184__section127698813613" target="_blank" rel="noopener">视频课程</a>等资源进行了汇总，使开发者可以直达所需资源。</p><h3 id="通用开发历程"><a href="#通用开发历程" class="headerlink" title="通用开发历程"></a>通用开发历程</h3><p>各类设备（手机/平板、智能穿戴、智慧屏等）通用的用户应用程序开发历程如下表所示。</p><p>无法复制加载中的内容</p><h3 id="原子化服务开发历程"><a href="#原子化服务开发历程" class="headerlink" title="原子化服务开发历程"></a>原子化服务开发历程</h3><p>HarmonyOS除支持传统方式的需要安装的应用外，还支持提供特定功能的免安装的应用（即原子化服务），供用户在合适的场景、合适的设备上便捷使用。</p><p>原子化服务相对于传统方式的需要安装的应用更加轻量，同时提供更丰富的入口、更精准的分发。原子化服务的详细介绍请参见“<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/atomic-service-definition-0000001090840664" target="_blank" rel="noopener">原子化服务</a>”。</p><p>其基本开发历程如下表所示。</p><p>无法复制加载中的内容</p><h3 id="设备差异化开发历程"><a href="#设备差异化开发历程" class="headerlink" title="设备差异化开发历程"></a>设备差异化开发历程</h3><p>相对于<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/document-outline-0000001064589184#ZH-CN_TOPIC_0000001064589184__section149501044202918" target="_blank" rel="noopener">通用开发历程</a>，智能穿戴、智慧屏存在一些特殊应用开发场景，其补充指导如下表所示。</p><p>无法复制加载中的内容</p><h3 id="开发者教程"><a href="#开发者教程" class="headerlink" title="开发者教程"></a>开发者教程</h3><p>针对重点功能或场景的开发者教程如下表所示。</p><p>无法复制加载中的内容</p><h3 id="视频课程"><a href="#视频课程" class="headerlink" title="视频课程"></a>视频课程</h3><p>无法复制加载中的内容</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="系统定义"><a href="#系统定义" class="headerlink" title="系统定义"></a>系统定义</h3><h4 id="系统定位"><a href="#系统定位" class="headerlink" title="系统定位"></a>系统定位</h4><p>HarmonyOS是一款面向万物互联时代的、全新的分布式操作系统。在传统的单设备系统能力基础上，HarmonyOS提出了基于同一套系统能力、适配多种终端形态的分布式理念，能够支持手机、平板、智能穿戴、智慧屏、车机等多种终端设备，提供全场景（移动办公、运动健康、社交通信、媒体娱乐等）业务能力。</p><p>HarmonyOS有三大特征：</p><ul><li><p>搭载该操作系统的设备在系统层面融为一体、形成超级终端，让设备的硬件能力可以弹性扩展，实现设备之间<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-features-0000000000011907#ZH-CN_TOPIC_0000001063953283__section3784192251716" target="_blank" rel="noopener">硬件互助，资源共享</a>。对消费者而言，HarmonyOS能够将生活场景中的各类终端进行能力整合，实现不同终端设备之间的快速连接、能力互助、资源共享，匹配合适的设备、提供流畅的全场景体验。</p></li><li><p>面向开发者，实现<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-features-0000000000011907#ZH-CN_TOPIC_0000001063953283__section35241557442" target="_blank" rel="noopener">一次开发，多端部署</a>。对应用开发者而言，HarmonyOS采用了多种分布式技术，使应用开发与不同终端设备的形态差异无关，从而让开发者能够聚焦上层业务逻辑，更加便捷、高效地开发应用。</p></li><li><p>一套操作系统可以满足不同能力的设备需求，实现<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-features-0000000000011907#ZH-CN_TOPIC_0000001063953283__section1169115112119" target="_blank" rel="noopener">统一OS，弹性部署</a>。对设备开发者而言，HarmonyOS采用了组件化的设计方案，可根据设备的资源能力和业务特征灵活裁剪，满足不同形态终端设备对操作系统的要求。</p></li></ul><p>HarmonyOS提供了支持多种开发语言的API，供开发者进行应用开发。支持的开发语言包括Java、XML（Extensible Markup Language）、C/C++ 、 JS（JavaScript）、CSS（Cascading Style Sheets）和HML（HarmonyOS Markup Language）。</p><h3 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h3><p>HarmonyOS整体遵从分层设计，从下向上依次为：内核层、系统服务层、框架层和应用层。系统功能按照“系统 &gt; 子系统 &gt; 功能/模块”逐级展开，在多设备部署场景下，支持根据实际需求裁剪某些非必要的子系统或功能/模块。HarmonyOS技术架构如下所示。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTI0YzAxNTNiNjlhYTlmNWNmZDYxMTYxNDMzMGQ5N2VfZHpWdVoyb0o5dUVFSU9UOVBXTTBlUm9ySm95NjFWZHpfVG9rZW46Ym94Y25BcWlKUDFMN2JWVDJCWnhrM0F4aDNjXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><h4 id="内核层"><a href="#内核层" class="headerlink" title="内核层"></a>内核层</h4><ul><li><p>内核子系统：HarmonyOS采用多内核设计，支持针对不同资源受限设备选用适合的OS内核。内核抽象层（KAL，Kernel Abstract Layer）通过屏蔽多内核差异，对上层提供基础的内核能力，包括进程/线程管理、内存管理、文件系统、网络管理和外设管理等。</p></li><li><p>驱动子系统：<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/glossary-0000000000029587#ZH-CN_TOPIC_0000001114162884__li1544183516475" target="_blank" rel="noopener">硬件驱动框架（HDF）</a>是HarmonyOS硬件生态开放的基础，提供统一外设访问能力和驱动开发、管理框架。</p></li></ul><h4 id="系统服务层"><a href="#系统服务层" class="headerlink" title="系统服务层"></a>系统服务层</h4><p>系统服务层是HarmonyOS的核心能力集合，通过框架层对应用程序提供服务。该层包含以下几个部分：</p><ul><li><p>系统基本能力子系统集：为分布式应用在HarmonyOS多设备上的运行、调度、迁移等操作提供了基础能力，由分布式软总线、分布式数据管理、分布式任务调度、方舟多语言运行时、公共基础库、多模输入、图形、安全、AI等子系统组成。其中，方舟运行时提供了C/C++/JS多语言运行时和基础的系统类库，也为使用方舟编译器静态化的Java程序（即应用程序或框架层中使用Java语言开发的部分）提供运行时。</p></li><li><p>基础软件服务子系统集：为HarmonyOS提供公共的、通用的软件服务，由事件通知、电话、多媒体、DFX（Design For X） 、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/glossary-0000000000029587#ZH-CN_TOPIC_0000001114162884__li1113671654618" target="_blank" rel="noopener">MSDP</a>&amp;<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/glossary-0000000000029587#ZH-CN_TOPIC_0000001114162884__li13399361415" target="_blank" rel="noopener">DV</a>等子系统组成。</p></li><li><p>增强软件服务子系统集：为HarmonyOS提供针对不同设备的、差异化的能力增强型软件服务，由智慧屏专有业务、穿戴专有业务、IoT专有业务等子系统组成。</p></li><li><p>硬件服务子系统集：为HarmonyOS提供硬件服务，由位置服务、生物特征识别、穿戴专有硬件服务、IoT专有硬件服务等子系统组成。</p></li></ul><p>根据不同设备形态的部署环境，基础软件服务子系统集、增强软件服务子系统集、硬件服务子系统集内部可以按子系统粒度裁剪，每个子系统内部又可以按功能粒度裁剪。</p><h4 id="框架层"><a href="#框架层" class="headerlink" title="框架层"></a>框架层</h4><p>框架层为HarmonyOS应用开发提供了Java/C/C++/JS等多语言的用户程序框架和<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/glossary-0000000000029587#ZH-CN_TOPIC_0000001114162884__li1373094219463" target="_blank" rel="noopener">Ability</a>框架，两种UI框架（包括适用于Java语言的Java UI框架、适用于JS语言的JS UI框架），以及各种软硬件服务对外开放的多语言框架API。根据系统的组件化裁剪程度，HarmonyOS设备支持的API也会有所不同。</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层包括系统应用和第三方非系统应用。HarmonyOS的应用由一个或多个<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/glossary-0000000000029587#ZH-CN_TOPIC_0000001114162884__li102311923104712" target="_blank" rel="noopener">FA（Feature Ability）</a>或<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/glossary-0000000000029587#ZH-CN_TOPIC_0000001114162884__li11872193812460" target="_blank" rel="noopener">PA（Particle Ability）</a>组成。其中，FA有UI界面，提供与用户交互的能力；而PA无UI界面，提供后台运行任务的能力以及统一的数据访问抽象。FA在进行用户交互时所需的后台数据访问也需要由对应的PA提供支撑。基于FA/PA开发的应用，能够实现特定的业务功能，支持跨设备调度与分发，为用户提供一致、高效的应用体验</p><h3 id="技术特性"><a href="#技术特性" class="headerlink" title="技术特性"></a>技术特性</h3><h4 id="硬件互助，资源共享"><a href="#硬件互助，资源共享" class="headerlink" title="硬件互助，资源共享"></a>硬件互助，资源共享</h4><p>多种设备之间能够实现硬件互助、资源共享，依赖的关键技术包括<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-features-0000000000011907#ZH-CN_TOPIC_0000001063953283__section19559317185" target="_blank" rel="noopener">分布式软总线</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-features-0000000000011907#ZH-CN_TOPIC_0000001063953283__section175824210187" target="_blank" rel="noopener">分布式设备虚拟化</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-features-0000000000011907#ZH-CN_TOPIC_0000001063953283__section1128391014200" target="_blank" rel="noopener">分布式数据管理</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-features-0000000000011907#ZH-CN_TOPIC_0000001063953283__section417848172013" target="_blank" rel="noopener">分布式任务调度</a>等。</p><h5 id="分布式软总线"><a href="#分布式软总线" class="headerlink" title="分布式软总线"></a>分布式软总线</h5><p>分布式软总线是手机、平板、智能穿戴、智慧屏、车机等分布式设备的通信基座，为设备之间的互联互通提供了统一的分布式通信能力，为设备之间的无感发现和零等待传输创造了条件。开发者只需聚焦于业务逻辑的实现，无需关注组网方式与底层协议。分布式软总线示意图见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-features-0000000000011907#ZH-CN_TOPIC_0000001063953283__fig161268496183" target="_blank" rel="noopener">图1</a>。</p><p>典型应用场景举例：</p><ul><li><p>智能家居场景：在烹饪时，手机可以通过碰一碰和烤箱连接，并将自动按照菜谱设置烹调参数，控制烤箱来制作菜肴。与此类似，料理机、油烟机、空气净化器、空调、灯、窗帘等都可以在手机端显示并通过手机控制。设备之间即连即用，无需繁琐的配置。</p></li><li><p>多屏联动课堂：老师通过智慧屏授课，与学生开展互动，营造课堂氛围；学生通过手机完成课程学习和随堂问答。统一、全连接的逻辑网络确保了传输通道的高带宽、低时延、高可靠。</p></li></ul><p><strong>图1</strong> 分布式软总线示意图</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTUwYzg1N2ZiMDNhZWQ0ZjNiZTNmMGY1YjkwYWY5MjNfczhyMzd1VkwwNG8xWXJQajA3SVhDT2NRRzR2NzFwOUVfVG9rZW46Ym94Y25STThlbkRISWgyeGgzejhBZW9LQ1RiXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><h5 id="分布式设备虚拟化"><a href="#分布式设备虚拟化" class="headerlink" title="分布式设备虚拟化"></a>分布式设备虚拟化</h5><p>分布式设备虚拟化平台可以实现不同设备的资源融合、设备管理、数据处理，多种设备共同形成一个<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/glossary-0000000000029587#ZH-CN_TOPIC_0000001114162884__li1133517458578" target="_blank" rel="noopener">超级虚拟终端</a>。针对不同类型的任务，为用户匹配并选择能力合适的执行硬件，让业务连续地在不同设备间流转，充分发挥不同设备的能力优势，如显示能力、摄像能力、音频能力、交互能力以及传感器能力等。分布式设备虚拟化示意图见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-features-0000000000011907#ZH-CN_TOPIC_0000001063953283__fig132695520204" target="_blank" rel="noopener">图2</a>。</p><p>典型应用场景举例：</p><ul><li><p>视频通话场景：在做家务时接听视频电话，可以将手机与智慧屏连接，并将智慧屏的屏幕、摄像头与音箱虚拟化为本地资源，替代手机自身的屏幕、摄像头、听筒与扬声器，实现一边做家务、一边通过智慧屏和音箱来视频通话。</p></li><li><p>游戏场景：在智慧屏上玩游戏时，可以将手机虚拟化为遥控器，借助手机的重力传感器、加速度传感器、触控能力，为玩家提供更便捷、更流畅的游戏体验。</p></li></ul><p><strong>图2</strong> 分布式设备虚拟化示意图</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZThiMzY0NDdjYmJjMzg0ZjIwZTliMTJhMGNmM2I0ODJfYjVRSUhOblFSU1FSUlZkNVFyQ2lPZGlENTdtRXdkZGhfVG9rZW46Ym94Y253bkc5MDk4SE53cUVPeDBsZkZ1WUswXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><h5 id="分布式数据管理"><a href="#分布式数据管理" class="headerlink" title="分布式数据管理"></a>分布式数据管理</h5><p>分布式数据管理基于分布式软总线的能力，实现应用程序数据和用户数据的分布式管理。用户数据不再与单一物理设备绑定，业务逻辑与数据存储分离，跨设备的数据处理如同本地数据处理一样方便快捷，让开发者能够轻松实现全场景、多设备下的数据存储、共享和访问，为打造一致、流畅的用户体验创造了基础条件。分布式数据管理示意图见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-features-0000000000011907#ZH-CN_TOPIC_0000001063953283__fig3742124117202" target="_blank" rel="noopener">图3</a>。</p><p>典型应用场景举例：</p><ul><li><p>协同办公场景：将手机上的文档投屏到智慧屏，在智慧屏上对文档执行翻页、缩放、涂鸦等操作，文档的最新状态可以在手机上同步显示。</p></li><li><p>家庭出游场景：一家人出游时，妈妈用手机拍了很多照片。通过家庭照片共享，爸爸可以在自己的手机上浏览、收藏和保存这些照片，家中的爷爷奶奶也可以通过智慧屏浏览这些照片。</p></li></ul><p><strong>图3</strong> 分布式数据管理示意图</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGE1NWE4YTYwN2ZjMmZjMTJjZDk5NGI0ZDhlMDNlOTlfVGFYQXFCY0pWRkVIZXhVYmd3emRCU3pmRU9teTR6M3BfVG9rZW46Ym94Y25kOEtielk1VFRUdUdpRUhySDZTYUxjXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><h5 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h5><p>分布式任务调度基于分布式软总线、分布式数据管理、分布式Profile等技术特性，构建统一的分布式服务管理（发现、同步、注册、调用）机制，支持对跨设备的应用进行远程启动、远程调用、远程连接以及迁移等操作，能够根据不同设备的能力、位置、业务运行状态、资源使用情况，以及用户的习惯和意图，选择合适的设备运行分布式任务。</p><p><a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-features-0000000000011907#ZH-CN_TOPIC_0000001063953283__fig112114152116" target="_blank" rel="noopener">图4</a>以应用迁移为例，简要地展示了分布式任务调度能力。</p><p>典型应用场景举例：</p><ul><li><p>导航场景：如果用户驾车出行，上车前，在手机上规划好导航路线；上车后，导航自动迁移到车机和车载音箱；下车后，导航自动迁移回手机。如果用户骑车出行，在手机上规划好导航路线，骑行时手表可以接续导航。</p></li><li><p>外卖场景：在手机上点外卖后，可以将订单信息迁移到手表上，随时查看外卖的配送状态。</p></li></ul><p><strong>图4</strong> 分布式任务调度示意图</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWYxZjA5NzkxMThhNzdmZmI0ZWEwNTUwZGQ3M2MwYTBfVkVNZXZDSTd5ZG5sU3Qxa3ZCSG5nUEt4Vlg2QkJOaHVfVG9rZW46Ym94Y25yRjBndjJTeWx1MmJZOExCSWNnUEdkXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><h4 id="一次开发，多端部署"><a href="#一次开发，多端部署" class="headerlink" title="一次开发，多端部署"></a>一次开发，多端部署</h4><p>HarmonyOS提供了用户程序框架、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/glossary-0000000000029587#ZH-CN_TOPIC_0000001114162884__li1373094219463" target="_blank" rel="noopener">Ability</a>框架以及UI框架，支持应用开发过程中多终端的业务逻辑和界面逻辑进行复用，能够实现应用的一次开发、多端部署，提升了跨设备应用的开发效率。一次开发、多端部署示意图见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-features-0000000000011907#ZH-CN_TOPIC_0000001063953283__fig087974703213" target="_blank" rel="noopener">图5</a>。</p><p>其中，UI框架支持Java和JS两种开发语言，并提供了丰富的多态控件，可以在手机、平板、智能穿戴、智慧屏、车机上显示不同的UI效果。采用业界主流设计方式，提供多种响应式布局方案，支持栅格化布局，满足不同屏幕的界面适配能力。</p><p><strong>图5</strong> 一次开发、多端部署示意图</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjkxOWM5YWY5NjU5YzI5YmZkNDRiMDVmYjVlMDM1YWFfZDlxVHgwckg5UkVTWG1pMm15cFZ2dkx6NnZNQlJWbUJfVG9rZW46Ym94Y242TWJDb0ExcFVlY1lVcHRrVHRJVE9oXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><h4 id="统一OS，弹性部署"><a href="#统一OS，弹性部署" class="headerlink" title="统一OS，弹性部署"></a>统一OS，弹性部署</h4><p>HarmonyOS通过组件化和小型化等设计方法，支持多种终端设备按需弹性部署，能够适配不同类别的硬件资源和功能需求。支撑通过编译链关系去自动生成组件化的依赖关系，形成组件树依赖图，支撑产品系统的便捷开发，降低硬件设备的开发门槛。</p><ul><li><p><strong>支持各组件的选择（组件可有可无）</strong>：根据硬件的形态和需求，可以选择所需的组件。</p></li><li><p><strong>支持组件内功能集的配置（组件可大可小）</strong>：根据硬件的资源情况和功能需求，可以选择配置组件中的功能集。例如，选择配置图形框架组件中的部分控件。</p></li><li><p><strong>支持组件间依赖的关联（平台可大可小）</strong>：根据编译链关系，可以自动生成组件化的依赖关系。例如，选择图形框架组件，将会自动选择依赖的图形引擎组件等。</p></li></ul><h3 id="系统安全"><a href="#系统安全" class="headerlink" title="系统安全"></a>系统安全</h3><p>在搭载HarmonyOS的分布式终端上，可以保证“<strong>正确的人，通过正确的设备，正确地使用数据</strong>”。</p><ul><li><p>通过“分布式多端协同身份认证”来保证“正确的人”。</p></li><li><p>通过“在分布式终端上构筑可信运行环境”来保证“正确的设备”。</p></li><li><p>通过“分布式数据在跨终端流动的过程中，对数据进行分类分级管理”来保证“正确地使用数据”。</p></li></ul><h4 id="正确的人"><a href="#正确的人" class="headerlink" title="正确的人"></a>正确的人</h4><p>在分布式终端场景下，“正确的人”指通过身份认证的数据访问者和业务操作者。“正确的人”是确保用户数据不被非法访问、用户隐私不泄露的前提条件。HarmonyOS通过以下三个方面来实现协同身份认证：</p><ul><li><p><strong>零信任模型</strong>：HarmonyOS基于零信任模型，实现对用户的认证和对数据的访问控制。当用户需要跨设备访问数据资源或者发起高安全等级的业务操作（例如，对安防设备的操作）时，HarmonyOS会对用户进行身份认证，确保其身份的可靠性。</p></li><li><p><strong>多因素融合认证</strong>：HarmonyOS通过用户身份管理，将不同设备上标识同一用户的认证凭据关联起来，用于标识一个用户，来提高认证的准确度。</p></li><li><p><strong>协同互助认证</strong>：HarmonyOS通过将硬件和认证能力解耦（即信息采集和认证可以在不同的设备上完成），来实现不同设备的资源池化以及能力的互助与共享，让高安全等级的设备协助低安全等级的设备完成用户身份认证。</p></li></ul><h4 id="正确的设备"><a href="#正确的设备" class="headerlink" title="正确的设备"></a>正确的设备</h4><p>在分布式终端场景下，只有保证用户使用的设备是安全可靠的，才能保证用户数据在虚拟终端上得到有效保护，避免用户隐私泄露。</p><ul><li><p><strong>安全启动</strong>确保源头每个虚拟设备运行的系统固件和应用程序是完整的、未经篡改的。通过安全启动，各个设备厂商的镜像包就不易被非法替换为恶意程序，从而保护用户的数据和隐私安全。</p></li><li><p><strong>可信执行环境</strong>提供了基于硬件的可信执行环境（TEE，Trusted Execution Environment）来保护用户的个人敏感数据的存储和处理，确保数据不泄露。由于分布式终端硬件的安全能力不同，对于用户的敏感个人数据，需要使用高安全等级的设备进行存储和处理。HarmonyOS使用基于数学可证明的形式化开发和验证的TEE微内核，获得了商用OS内核CC EAL5+的认证评级。</p></li><li><p><strong>设备证书认证</strong>支持为具备可信执行环境的设备预置设备证书，用于向其他虚拟终端证明自己的安全能力。对于有TEE环境的设备，通过预置PKI（Public Key Infrastructure）设备证书给设备身份提供证明，确保设备是合法制造生产的。设备证书在产线进行预置，设备证书的私钥写入并安全保存在设备的TEE环境中，且只在TEE内进行使用。在必须传输用户的敏感数据（例如密钥、加密的生物特征等信息）时，会在使用设备证书进行安全环境验证后，建立从一个设备的TEE到另一设备的TEE之间的安全通道，实现安全传输。如<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/harmonyos-security-0000000000011934#ZH-CN_TOPIC_0000001064631506__fig18701947894" target="_blank" rel="noopener">图1</a>所示。</p></li></ul><p><strong>图1</strong> 设备证书使用示意图</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTA0MDg5YjkwMWRiYjY2YzRkNjQ3NTFjNjM0MDc1M2RfZW83QkhSUUVQQmlFeXJteTRlUzJGazE0V01PRENlM2dfVG9rZW46Ym94Y25HbndkbEVicG5jZGNTTjdKenFEdWRiXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><h4 id="正确地使用数据"><a href="#正确地使用数据" class="headerlink" title="正确地使用数据"></a>正确地使用数据</h4><p>在分布式终端场景下，需要确保用户能够正确地使用数据<strong>。</strong>HarmonyOS围绕数据的生成、存储、使用、传输以及销毁过程进行全生命周期的保护，从而保证个人数据与隐私、以及系统的机密数据（如密钥）不泄漏。</p><ul><li><p><strong>数据生成</strong>：根据数据所在的国家或组织的法律法规与标准规范，对数据进行分类分级，并且根据分类设置相应的保护等级。每个保护等级的数据从生成开始，在其存储、使用、传输的整个生命周期都需要根据对应的安全策略提供不同强度的安全防护。虚拟超级终端的访问控制系统支持依据标签的访问控制策略，保证数据只能在可以提供足够安全防护的虚拟终端之间存储、使用和传输。</p></li><li><p><strong>数据存储：</strong>HarmonyOS通过区分数据的安全等级，存储到不同安全防护能力的分区，对数据进行安全保护，并提供密钥全生命周期的跨设备无缝流动和跨设备密钥访问控制能力，支撑分布式身份认证协同、分布式数据共享等业务。</p></li><li><p><strong>数据使用：</strong>HarmonyOS通过硬件为设备提供可信执行环境。用户的个人敏感数据仅在分布式虚拟终端的可信执行环境中进行使用，确保用户数据的安全和隐私不泄露。</p></li><li><p><strong>数据传输：</strong>为了保证数据在虚拟超级终端之间安全流转，需要各设备是正确可信的，建立了信任关系（多个设备通过华为帐号建立配对关系），并能够在验证信任关系后，建立安全的连接通道，按照数据流动的规则，安全地传输数据。当设备之间进行通信时，需要基于设备的身份凭据对设备进行身份认证，并在此基础上，建立安全的加密传输通道。</p></li><li><p><strong>数据销毁：</strong>销毁密钥即销毁数据。数据在虚拟终端的存储，都建立在密钥的基础上。当销毁数据时，只需要销毁对应的密钥即完成了数据的销毁</p></li></ul><h2 id="开发基础知识"><a href="#开发基础知识" class="headerlink" title="开发基础知识"></a>开发基础知识</h2><h3 id="应用基础知识"><a href="#应用基础知识" class="headerlink" title="应用基础知识"></a>应用基础知识</h3><h4 id="用户应用程序"><a href="#用户应用程序" class="headerlink" title="用户应用程序"></a>用户应用程序</h4><p>用户应用程序泛指运行在设备的操作系统之上，为用户提供特定服务的程序，简称“应用”。</p><p>在HarmonyOS上运行的应用，有两种形态：</p><ul><li><p>传统方式的需要安装的应用。</p></li><li><p>提供特定功能，免安装的应用（即<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/atomic-service-definition-0000001090840664" target="_blank" rel="noopener">原子化服务</a>）。</p></li></ul><p>在HarmonyOS文档中，如无特殊说明，“应用”所指代的对象包括上述两种形态。</p><h4 id="用户应用程序包结构"><a href="#用户应用程序包结构" class="headerlink" title="用户应用程序包结构"></a>用户应用程序包结构</h4><p>HarmonyOS的用户应用程序包以<strong>APP</strong> <strong>Pack</strong>（Application Package）形式发布，它是由一个或多个<strong>HAP</strong>（HarmonyOS Ability Package）以及描述每个HAP属性的pack.info组成。HAP是<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-fundamentals-0000000000041611#ZH-CN_TOPIC_0000001063248002__section121002188527" target="_blank" rel="noopener">Ability</a>的部署包，HarmonyOS应用代码围绕Ability组件展开。</p><p>一个HAP是由代码、资源、第三方库及应用配置文件组成的模块包，可分为entry和feature两种模块类型，如<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-fundamentals-0000000000041611#ZH-CN_TOPIC_0000001063248002__fig2196184212719" target="_blank" rel="noopener">图1</a>所示。</p><ul><li><p><strong>entry</strong>：应用的主模块。一个APP中，对于同一设备类型必须有且只有一个entry类型的HAP，可独立安装运行。</p></li><li><p><strong>feature</strong>：应用的动态特性模块。一个APP可以包含一个或多个feature类型的HAP，也可以不含。只有包含Ability的HAP才能够独立运行。</p></li></ul><p><strong>图1</strong> APP逻辑视图</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjE3YWZhMWQyMmFiNTE3NjZjOWQ1MDY4MWYwYWMyZDdfZlp1UGg0RkN4NXpHbVJqNXUxWEVYNzJnWDNzNXlDdkRfVG9rZW46Ym94Y25pR2pIWXA5OHl1VlFWSU5YWmRVYVVlXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><h4 id="Ability"><a href="#Ability" class="headerlink" title="Ability"></a>Ability</h4><p>Ability是应用所具备的能力的抽象，一个应用可以包含一个或多个Ability。Ability分为两种类型：FA（Feature Ability）和PA（Particle Ability）。FA/PA是应用的基本组成单元，能够实现特定的业务功能。FA有UI界面，而PA无UI界面。</p><h4 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a>库文件</h4><p>库文件是应用依赖的第三方代码（例如so、jar、bin、har等二进制文件），存放在libs目录。</p><h4 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h4><p>应用的资源文件（字符串、图片、音频等）存放于resources目录下，便于开发者使用和维护，详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-resource-file-categories-0000001052066099" target="_blank" rel="noopener">资源文件的分类</a>。</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>配置文件 (config.json) 是应用的Ability信息，用于声明应用的Ability，以及应用所需权限等信息，详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-config-file-overview-0000000000011951" target="_blank" rel="noopener">应用配置文件</a>。</p><h4 id="pack-info"><a href="#pack-info" class="headerlink" title="pack.info"></a>pack.info</h4><p>描述应用软件包中每个HAP的属性，由IDE编译生成，应用市场根据该文件进行拆包和HAP的分类存储。HAP的具体属性包括：</p><ul><li><p>delivery-with-install: 表示该HAP是否支持随应用安装。“true”表示支持随应用安装；“false”表示不支持随应用安装。</p></li><li><p>name：HAP文件名。</p></li><li><p>module-type：模块类型，entry或feature。</p></li><li><p>device-type：表示支持该HAP运行的设备类型。</p></li></ul><h4 id="HAR"><a href="#HAR" class="headerlink" title="HAR"></a>HAR</h4><p>HAR（HarmonyOS Ability Resources）可以提供构建应用所需的所有内容，包括源代码、资源文件和config.json文件。HAR不同于HAP，HAR不能独立安装运行在设备上，只能作为应用模块的依赖项被引用。</p><h3 id="应用配置文件"><a href="#应用配置文件" class="headerlink" title="应用配置文件"></a>应用配置文件</h3><p>应用的每个HAP的根目录下都存在一个“config.json”配置文件，文件内容主要涵盖以下三个方面：</p><ul><li><p>应用的全局配置信息，包含应用的包名、生产厂商、版本号等基本信息。</p></li><li><p>应用在具体设备上的配置信息，包含应用的备份恢复、网络安全等能力。</p></li><li><p>HAP包的配置信息，包含每个Ability必须定义的基本属性（如包名、类名、类型以及Ability提供的能力），以及应用访问系统或其他应用受保护部分所需的权限等。</p></li></ul><h4 id="配置文件的组成"><a href="#配置文件的组成" class="headerlink" title="配置文件的组成"></a>配置文件的组成</h4><p>配置文件“config.json”采用JSON文件格式，其中包含了一系列配置项，每个配置项由属性和值两部分构成：</p><ul><li><p><strong>属性</strong>属性出现顺序不分先后，且每个属性最多只允许出现一次。</p></li><li><p><strong>值</strong>每个属性的值为JSON的基本数据类型（数值、字符串、布尔值、数组、对象或者null类型）。如果属性值需要引用资源文件，可参见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-resource-file-categories-0000001052066099" target="_blank" rel="noopener">资源文件</a>。</p></li></ul><p>DevEco Studio提供了两种编辑“config.json”文件的方式。在“config.json”的编辑窗口中，可在右上角切换代码编辑视图或可视化编辑视图。</p><p><strong>图1</strong> config.json文件的可视化编辑视图</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGQ2MGY0N2M3ZTAzOWM2YWRjMzhkMTgwM2MzNTEzZjRfYWhlTjVoQ3VOOEFOaWpJMFBGUzYwVkVSelMyUXQ0dWhfVG9rZW46Ym94Y25pdWJOOGtoZEttWW90SWNIVW9IWHpnXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><h4 id="配置文件的内部结构"><a href="#配置文件的内部结构" class="headerlink" title="配置文件的内部结构"></a>配置文件的内部结构</h4><p>“config.json”由“app”、“deviceConfig”和“module”三个部分组成，缺一不可。配置文件的内部结构说明参见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-config-file-elements-0000000000034463#ZH-CN_TOPIC_0000001064016070__table18140155505115" target="_blank" rel="noopener">表1</a>。</p><p>无法复制加载中的内容</p><h4 id="app对象的内部结构"><a href="#app对象的内部结构" class="headerlink" title="app对象的内部结构"></a>app对象的内部结构</h4><p>app对象包含应用的全局配置信息，内部结构说明参见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-config-file-elements-0000000000034463#ZH-CN_TOPIC_0000001064016070__table88551601573" target="_blank" rel="noopener">表2</a>。</p><p>无法复制加载中的内容</p><p>app示例：</p><pre><code>"app": {    "bundleName": "com.huawei.hiworld.example",     "vendor": "huawei",     "version": {        "code": 2,         "name": "2.0"    },    "apiVersion": {        "compatible": 3,         "target": 3,        "releaseType": "Beta1"    }}</code></pre><h4 id="deviceConfig对象的内部结构"><a href="#deviceConfig对象的内部结构" class="headerlink" title="deviceConfig对象的内部结构"></a>deviceConfig对象的内部结构</h4><p>deviceConfig包含在具体设备上的应用配置信息，可以包含default、phone、tablet、tv、car、wearable、liteWearable和smartVision等属性。default标签内的配置是适用于所有设备通用，其他设备类型如果有特殊的需求，则需要在该设备类型的标签下进行配置。内部结构说明参见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-config-file-elements-0000000000034463#ZH-CN_TOPIC_0000001064016070__table34298422421" target="_blank" rel="noopener">表3</a>。</p><p>无法复制加载中的内容</p><p>default、phone、tablet、tv、car、wearable、liteWearable和smartVision等对象的内部结构说明，可参见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-config-file-elements-0000000000034463#ZH-CN_TOPIC_0000001064016070__table34321642154215" target="_blank" rel="noopener">表4</a>。</p><p>无法复制加载中的内容</p><p>无法复制加载中的内容</p><p>无法复制加载中的内容</p><p>deviceConfig示例：</p><pre><code> "deviceConfig": {    "default": {        "process": "com.huawei.hiworld.example",         "supportBackup": false,        "network": {            "cleartextTraffic": true,             "securityConfig": {                "domainSettings": {                    "cleartextPermitted": true,                     "domains": [                        {                            "subDomains": true,                             "name": "example.ohos.com"                        }                    ]                }            }        }    }}module对象的内部结构</code></pre><p>module对象包含HAP包的配置信息，内部结构说明参见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-config-file-elements-0000000000034463#ZH-CN_TOPIC_0000001064016070__table29242051154512" target="_blank" rel="noopener">表7</a>。</p><p>无法复制加载中的内容</p><p>module示例：</p><pre><code>"module": {    "mainAbility": "MainAbility",    "package": "com.example.myapplication.entry",     "name": ".MyOHOSAbilityPackage",     "description": "$string:description_application",     "supportedModes": [        "drive"    ],     "deviceType": [        "car"    ],     "distro": {        "deliveryWithInstall": true,         "moduleName": "ohos_entry",         "moduleType": "entry"    },     "abilities": [        ...    ],     "shortcuts": [        ...    ],    "js": [        ...    ],     "reqPermissions": [        ...    ],     "defPermissions": [        ...    ],    "colorMode": "light"}</code></pre><p>无法复制加载中的内容</p><p>distro示例：</p><pre><code>"distro": {    "deliveryWithInstall": true,     "moduleName": "ohos_entry",     "moduleType": "entry",    "installationFree": true} </code></pre><p>无法复制加载中的内容</p><p>metaData示例：</p><pre><code>"metaData": {    "parameters" : [{        "name" : "string",        "type" : "Float",        "description" : "$string:parameters_description"    }],    "results" : [{        "name" : "string",        "type" : "Float",        "description" : "$string:results_description"    }],    "customizeData" : [{        "name" : "string",        "value" : "string",        "extra" : "$string:customizeData_description"    }]}</code></pre><p>无法复制加载中的内容</p><p>abilities示例：</p><pre><code>"abilities": [    {        "name": ".MainAbility",        "description": "himusic main ability",        "icon": "$media:ic_launcher",        "label": "HiMusic",        "launchType": "standard",        "orientation": "unspecified",        "permissions": [        ],         "visible": true,        "skills": [            {                "actions": [                    "action.system.home"                ],                "entities": [                    "entity.system.home"                ]            }        ],        "configChanges": [            "locale",             "layout",             "fontSize",             "orientation"        ],         "type": "page"    },    {        "name": ".PlayService",        "description": "himusic play ability",        "icon": "$media:ic_launcher",        "label": "HiMusic",        "launchType": "standard",        "orientation": "unspecified",        "visible": false,        "skills": [            {                "actions": [                    "action.play.music",                    "action.stop.music"                ],                "entities": [                    "entity.audio"                ]            }        ],        "type": "service",        "backgroundModes": [            "audioPlayback"        ]    },    {        "name": ".UserADataAbility",        "type": "data",        "uri": "dataability://com.huawei.hiworld.himusic.UserADataAbility",        "visible": true    }]</code></pre><p>无法复制加载中的内容</p><p>skills示例：</p><pre><code>"skills": [    {        "actions": [            "action.system.home"        ],         "entities": [            "entity.system.home"        ],        "uris": [            {                 "scheme": "http",                 "host": "www.xxx.com",                 "port": "8080",                 "path": "query/student/name",                 "type": "text/*"             }         ]    }]</code></pre><p>无法复制加载中的内容</p><p>js示例：</p><pre><code>"js": [    {        "name": "default",         "pages": [                        "pages/index/index",            "pages/detail/detail"        ],                 "window": {            "designWidth": 750,            "autoDesignWidth": false        },        "type": "form"    }]</code></pre><p>无法复制加载中的内容</p><p>shortcuts示例：</p><pre><code>"shortcuts": [    {        "shortcutId": "id",        "label": "$string:shortcut",        "intents": [            {                "targetBundle": "com.huawei.hiworld.himusic",                "targetClass": "com.huawei.hiworld.himusic.entry.MainAbility"            }        ]    }]</code></pre><p>无法复制加载中的内容</p><p>forms示例：</p><pre><code>"forms": [    {        "name": "Form_Js",        "description": "It's Js Form",        "type": "JS",        "jsComponentName": "card",        "colorMode": "auto",        "isDefault": true,        "updateEnabled": true,        "scheduledUpdateTime": "11:00",        "updateDuration": 1,        "defaultDimension": "2*2",        "supportDimensions": [            "2*2",            "2*4",            "4*4"        ]    },    {        "name": "Form_Java",        "description": "It's Java Form",        "type": "Java",        "colorMode": "auto",        "isDefault": false,        "updateEnabled": true,        "scheduledUpdateTime": "21:05",        "updateDuration": 1,        "defaultDimension": "1*2",        "supportDimensions": [            "1*2"        ],        "landscapeLayouts": [            "$layout:ability_form"        ],        "portraitLayouts": [            "$layout:ability_form"        ],        "formConfigAbility": "ability://com.example.myapplication.fa/.MainAbility",        "metaData": {            "customizeData": [                {                    "name": "originWidgetName",                    "value": "com.huawei.weather.testWidget"                }            ]        }    }]HAP与HAR的配置文件的合并</code></pre><p>如果应用模块中调用了HAR，在编译构建HAP时，需要将HAP的“config.json”文件与一个或多个HAR的“config.json”文件，合并为一个“config.json”文件。在合并过程中，不同文件的同一个标签的取值可能发生冲突，此时，需要通过配置mergeRule来解决冲突。</p><h4 id="配置文件合并规则"><a href="#配置文件合并规则" class="headerlink" title="配置文件合并规则"></a>配置文件合并规则</h4><p>HAP与HAR的“config.json”文件合并时，需要将HAR的配置信息全部合并到HAP的配置文件。合并规则参见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-config-file-elements-0000000000034463#ZH-CN_TOPIC_0000001064016070__table64031349202317" target="_blank" rel="noopener">表15</a><strong>。</strong></p><p>HAP的优先级总是高于HAR。当HAP依赖于多个HAR时，先加载的HAR的优先级高于后加载的HAR，按照HAR的加载顺序依次合并到HAP文件。</p><p>无法复制加载中的内容</p><h4 id="mergeRule对象的使用"><a href="#mergeRule对象的使用" class="headerlink" title="mergeRule对象的使用"></a>mergeRule对象的使用</h4><p>mergeRule通常在HAP的“config.json”文件中使用，可以在“abilities”、“defPermissions”、 “reqPermissions”、“js”等属性中添加。不同属性的合并策略，详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-config-file-elements-0000000000034463#ZH-CN_TOPIC_0000001064016070__table194691504318" target="_blank" rel="noopener">表16</a>。</p><p>注意</p><ul><li><p>HAR配置文件中不能包含“action.system.home”和“entity.system.home”配置项，否则会导致编译报错。</p></li><li><p>abilities对象中“name”字段的取值，必须为完整的类名，否则会导致合并出错。</p></li></ul><p>无法复制加载中的内容</p><p>无法复制加载中的内容</p><p><strong>mergeRule的使用示例：</strong></p><p>在下面的示例中，HAP与HAR中的Ability的“name”取值相同，需要对两者“config.json”文件中的Ability进行合并。由于两个文件中的部分字段（例如“launchType”）存在冲突，需要在HAP的“abilities”标签下添加“mergeRule”。</p><ol><li>合并前HAP的“config.json”文件，如下所示：其中，remove表示合并后需要移除的子标签，replace表示合并后需要替换的子标签（HAP替换HAR）。</li></ol><pre><code>"abilities": [    {        "mergeRule": {            "remove": ["orientation"],            "replace": ["launchType"]        }        "name": "com.harmony.myapplication.entry.MainAbility",        "type": "page",        "launchType": "standard",        "visible": false    }],</code></pre><ol><li>合并前HAR的“config.json”文件，如下所示：</li></ol><pre><code>"abilities": [    {        "name": "com.harmony.myapplication.entry.MainAbility",        "type": "page",        "launchType": "singleton",        "orientation": "portrait",        "visible": false    }],</code></pre><ol><li>将上述两个“config.json”文件按照mergeRule进行合并，处理完成后mergeRule字段也会被移除。合并后的结果文件，如下所示：</li></ol><pre><code>"abilities": [    {        "name": "com.harmony.myapplication.entry.MainAbility",        "type": "page",        "launchType": "standard",        "visible": false    }],</code></pre><h4 id="bundleName占位符的使用"><a href="#bundleName占位符的使用" class="headerlink" title="bundleName占位符的使用"></a>bundleName占位符的使用</h4><p>HAR的“config.json”文件中多处需要使用包名，例如自定义权限、自定义action等场景，但是包名只有当HAR编译到HAP时才能确定下来。在编译之前，HAR中的包名可以采用占位符来表示，采用{bundleName}形式。</p><p>支持bundleName占位符的标签有actions、entities、permissions、readPermission、writePermission、defPermissions.name、uri。</p><p><strong>使用示例：</strong></p><ol><li>HAR中自定义action时，使用{bundleName}来代替包名。如下所示：</li></ol><pre><code>"skills": [    {        "actions": [            "{bundleName}.ACTION_PLAY"        ],        "entities": [            "{bundleName}.ENTITY_PLAY"        ],    }],</code></pre><ol><li>将HAP编译到bundleName为“com.huawei.hiworld”的HAP包后，原来的{bundleName}将被替换为HAP的实际包名。替换后的结果如下所示：</li></ol><pre><code>"app": {    "bundleName": "com.huawei.hiworld",    ……},"module": {    "abilities": [        {            "skills": [                {                    "actions": [                        "com.huawei.hiworld.ACTION_PLAY"                    ],                    "entities": [                        "com.huawei.hiworld.ENTITY_PLAY"                    ],                }            ],</code></pre><h4 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h4><p>以JSON文件为config.json的一个简单示例，该示例的应用声明为三个Ability。</p><pre><code>{    "app": {        "bundleName": "com.huawei.hiworld.himusic",        "vendor": "huawei",        "version": {            "code": 2,             "name": "2.0"        },        "apiVersion": {            "compatible": 3,             "target": 3,            "releaseType": "Beta1"        }    },    "deviceConfig": {        "default": {        }    },    "module": {        "mainAbility": "MainAbility",        "package": "com.huawei.hiworld.himusic.entry",        "name": ".MainApplication",        "supportedModes": [            "drive"        ],        "distro": {            "moduleType": "entry",            "deliveryWithInstall": true,            "moduleName": "hap-car"        },        "deviceType": [            "car"        ],        "abilities": [            {                "name": ".MainAbility",                "description": "himusic main ability",                "icon": "$media:ic_launcher",                "label": "HiMusic",                "launchType": "standard",                "orientation": "unspecified",                "visible": true,                "skills": [                    {                        "actions": [                            "action.system.home"                        ],                        "entities": [                            "entity.system.home"                        ]                    }                ],                "type": "page",                "formsEnabled": false            },            {                "name": ".PlayService",                "description": "himusic play ability",                "icon": "$media:ic_launcher",                "label": "HiMusic",                "launchType": "standard",                "orientation": "unspecified",                "visible": false,                "skills": [                    {                        "actions": [                            "action.play.music",                            "action.stop.music"                        ],                        "entities": [                            "entity.audio"                        ]                    }                ],                "type": "service",                "backgroundModes": [                    "audioPlayback"                ]            },            {                "name": ".UserADataAbility",                "type": "data",                "uri": "dataability://com.huawei.hiworld.himusic.UserADataAbility",                "visible": true            }        ],        "reqPermissions": [            {                "name": "ohos.permission.DISTRIBUTED_DATASYNC",                "reason": "",                "usedScene": {                    "ability": [                        "com.huawei.hiworld.himusic.entry.MainAbility",                        "com.huawei.hiworld.himusic.entry.PlayService"                    ],                    "when": "inuse"                }            }        ]    }}</code></pre><h3 id="资源文件-1"><a href="#资源文件-1" class="headerlink" title="资源文件"></a>资源文件</h3><h4 id="资源文件的分类"><a href="#资源文件的分类" class="headerlink" title="资源文件的分类"></a>资源文件的分类</h4><h5 id="resources目录"><a href="#resources目录" class="headerlink" title="resources目录"></a>resources目录</h5><p>应用的资源文件（字符串、图片、音频等）统一存放于resources目录下，便于开发者使用和维护。resources目录包括两大类目录，一类为base目录与限定词目录，另一类为rawfile目录，详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-resource-file-categories-0000001052066099#ZH-CN_TOPIC_0000001062847941__table1324121514614" target="_blank" rel="noopener">表1</a>。</p><p>资源目录示例：</p><blockquote><p>resources</p></blockquote><blockquote><p>|—base  // 默认存在的目录</p></blockquote><blockquote><p>|     |—element</p></blockquote><blockquote><p>|     |     |—string.json</p></blockquote><blockquote><p>|     |—media</p></blockquote><blockquote><p>|     |     |—icon.png</p></blockquote><blockquote><p>|—en_GB-vertical-car-mdpi // 限定词目录示例，需要开发者自行创建   </p></blockquote><blockquote><p>|     |—element</p></blockquote><blockquote><p>|     |     |—string.json</p></blockquote><blockquote><p>|     |—media</p></blockquote><blockquote><p>|     |     |—icon.png</p></blockquote><blockquote><p>|—rawfile  // 默认存在的目录</p></blockquote><p>无法复制加载中的内容</p><h5 id="限定词目录"><a href="#限定词目录" class="headerlink" title="限定词目录"></a>限定词目录</h5><p>限定词目录可以由一个或多个表征应用场景或设备特征的限定词组合而成，包括移动国家码和移动网络码、语言、文字、国家或地区、横竖屏、设备类型、颜色模式和屏幕密度等维度，限定词之间通过下划线（_）或者中划线（-）连接。开发者在创建限定词目录时，需要掌握限定词目录的命名要求以及与限定词目录与设备状态的匹配规则。</p><p><strong>限定词目录的命名要求</strong></p><ul><li><p>限定词的组合顺序：<em>移动国家码_移动网络码-语言_文字_国家或地区-横竖屏-设备类型-深色模式-屏幕密度</em>。开发者可以根据应用的使用场景和设备特征，选择其中的一类或几类限定词组成目录名称。</p></li><li><p>限定词的连接方式：语言、文字、国家或地区之间采用下划线（_）连接，移动国家码和移动网络码之间也采用下划线（_）连接，除此之外的其他限定词之间均采用中划线（-）连接。例如：<strong>zh_Hant_CN</strong>、<strong>zh_CN-car-ldpi</strong>。</p></li><li><p>限定词的取值范围：每类限定词的取值必须符合<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-resource-file-categories-0000001052066099#ZH-CN_TOPIC_0000001062847941__table5331112572518" target="_blank" rel="noopener">表2</a>中的条件，否则，将无法匹配目录中的资源文件。</p></li></ul><p>无法复制加载中的内容</p><p><strong>限定词目录与设备状态的匹配规则</strong></p><ul><li><p>在为设备匹配对应的资源文件时，限定词目录匹配的优先级从高到低依次为：移动国家码和移动网络码 &gt; 区域（语言_文字_国家或地区）&gt; 横竖屏 &gt; 设备类型 &gt; 颜色模式 &gt; 屏幕密度。</p></li><li><p>如果限定词目录中包含<strong>移动国家码和移动网络码、语言、文字、横竖屏、设备类型、颜色模式</strong>限定词，则对应限定词的取值必须与当前的设备状态完全一致，该目录才能够参与设备的资源匹配。例如，限定词目录“zh_CN-car-ldpi”不能参与“en_US”设备的资源匹配。</p></li></ul><h5 id="资源组目录"><a href="#资源组目录" class="headerlink" title="资源组目录"></a>资源组目录</h5><p>base目录与限定词目录下面可以创建资源组目录（包括element、media、animation、layout、graphic、profile），用于存放特定类型的资源文件，详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-resource-file-categories-0000001052066099#ZH-CN_TOPIC_0000001062847941__table88482216295" target="_blank" rel="noopener">表3</a>。</p><p>无法复制加载中的内容</p><h5 id="创建资源文件"><a href="#创建资源文件" class="headerlink" title="创建资源文件"></a>创建资源文件</h5><p>在resources目录下，可按照限定词目录和资源组目录的说明创建子目录和目录内的文件。</p><p>同时，DevEco Studio也提供了创建资源目录和资源文件的界面。</p><ul><li><strong>创建资源目录及资源文件</strong>在resources目录右键菜单选择“New &gt; Harmony Resource File”，此时可同时创建目录和文件。</li></ul><p>文件默认创建在base目录的对应资源组下。如果选择了限定词，则会按照命名规范自动生成限定词+资源组目录，并将文件创建在目录中。</p><p>目录名自动生成，格式固定为“限定词.资源组”，例如创建一个限定词为横竖屏类别下的竖屏，资源组为绘制资源的目录，自动生成的目录名称为“vertical.graphic”。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDkzNDQzOTRjMjI4ZDRiMGVjYjViMGJiYzJmNmFiOGRfaEdXUE1VNndxUkJFc1prTmtNb0dxd2pwSmROTER1b0lfVG9rZW46Ym94Y25vSHBYbmdsSThSb1pTcjdNQVQzbDdlXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><ul><li><strong>创建资源目录</strong>在resources目录右键菜单选择“New &gt; Harmony Resource Directory”，此时可创建资源目录。</li></ul><p>选择资源组类型，设置限定词，创建后自动生成目录名称。目录名称格式固定为“限定词.资源组”，例如创建一个限定词为横竖屏类别下的竖屏，资源组为绘制资源的目录，自动生成的目录名称为“vertical.graphic”。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzAzOTlhYjY3ZGQ2NTc2OTc4NjM4NTU3MTQzYjc3ZTBfQmhUTWhRZElEaHFveHZtc1pzUU1NQVkwZmFocks3anZfVG9rZW46Ym94Y25RQU03RElWVFRnNnVuM3NHckZMRWhmXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><ul><li><strong>创建资源文件</strong>在资源目录的右键菜单选择“New &gt; XXX Resource File”，即可创建对应资源组目录的资源文件。</li></ul><p>例如，在element目录下可新建Element Resource File</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmFmOTRlODcyOGVhOTQzMGM4OTEyOGM1MzQ5ODEwMGRfMlpoSThzOFlEYUNEaFdkZ0NZcmdjblM1Q3c5VXkySXBfVG9rZW46Ym94Y243RmVnOVFBM0pOeGxGV2dYS1ZJNEFmXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><h4 id="资源文件的使用"><a href="#资源文件的使用" class="headerlink" title="资源文件的使用"></a>资源文件的使用</h4><h5 id="资源文件的引用方法"><a href="#资源文件的引用方法" class="headerlink" title="资源文件的引用方法"></a>资源文件的引用方法</h5><p><strong>base目录与限定词目录中的资源文件</strong>：通过指定资源类型（type）和资源名称（name）来引用。</p><ul><li><p>Java文件引用资源文件的格式：</p><p>ResourceTable.</p><p><strong>type</strong></p><p>_</p><p><strong>name</strong></p><p>。特别地，如果引用的是系统资源，则采用：</p><p>ohos.global.systemres.ResourceTable.</p><p><strong>type</strong></p><p>_</p><p><strong>name</strong></p><p>。</p><ul><li>示例一：在Java文件中，引用<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-resource-file-example-0000001051733014#ZH-CN_TOPIC_0000001063096195__section1921624113243" target="_blank" rel="noopener">string.json</a>文件中类型为“String”、名称为“app_name”的资源。</li></ul></li></ul><pre><code>ohos.global.resource.ResourceManager resManager = this.getResourceManager();String result = resManager.getElement(ResourceTable.String_app_name).getString();</code></pre><ul><li>示例二：在Java文件中，引用<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-resource-file-example-0000001051733014#ZH-CN_TOPIC_0000001063096195__section39525972310" target="_blank" rel="noopener">color.json</a>文件中类型为“Color”、名称为“red”的资源。</li></ul><pre><code>ohos.global.resource.ResourceManager resManager = this.getResourceManager();int color = resManager.getElement(ResourceTable.Color_red).getColor();</code></pre><ul><li>XML文件引用资源文件的格式：<strong>$***</strong>type:name<strong>*。特别地，如果引用的是系统资源，则采用：</strong>$ohos:<strong><em>**type:name</em></strong>。在XML文件中，引用<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-resource-file-example-0000001051733014#ZH-CN_TOPIC_0000001063096195__section1921624113243" target="_blank" rel="noopener">string.json</a>文件中类型为“String”、名称为“app_name”的资源，示例如下：</li></ul><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;DirectionalLayout xmlns:ohos="http://schemas.huawei.com/res/ohos"    ohos:width="match_parent"    ohos:height="match_parent"    ohos:orientation="vertical"&gt;    &lt;Text ohos:text="$string:app_name"/&gt;&lt;/DirectionalLayout&gt;</code></pre><p><strong>rawfile目录中的资源文件</strong>：通过指定文件路径和文件名称来引用。</p><p>在Java文件中，引用一个路径为“resources/rawfile/”、名称为“example.js”的资源文件，示例如下：</p><pre><code>ohos.global.resource.ResourceManager resManager = this.getResourceManager();ohos.global.resource.RawFileEntry rawFileEntry = resManager.getRawFileEntry("resources/rawfile/example.js"); </code></pre><h5 id="系统资源文件"><a href="#系统资源文件" class="headerlink" title="系统资源文件"></a>系统资源文件</h5><p>目前支持的部分系统资源文件详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-resource-file-example-0000001051733014#ZH-CN_TOPIC_0000001063096195__table54943152412" target="_blank" rel="noopener">表1</a>。</p><p>无法复制加载中的内容</p><h5 id="颜色模式的定义"><a href="#颜色模式的定义" class="headerlink" title="颜色模式的定义"></a>颜色模式的定义</h5><p>应用可以在config.json的module字段下定义“colorMode”字段，“colorMode”字段用来定义应用自身的颜色模式，值可以是“dark”，“light”，“auto”（默认值）。示例：</p><pre><code>"colorMode": "light"</code></pre><p>当应用的颜色模式值是“dark”时，无论系统当前颜色模式是什么，应用始终会按照深色模式选取资源；同理，当应用的颜色模式值是“light”时，无论系统当前颜色模式是什么，应用始终会按照浅色模式选取资源；当应用的颜色模式值是“auto”时，应用会跟随系统的颜色模式值选取资源。应用可以在代码中通过如下方式获取应用当前的颜色模式：</p><pre><code>int colorMode = Configuration.colorMode;</code></pre><h5 id="为Element资源文件添加注释或特殊标识"><a href="#为Element资源文件添加注释或特殊标识" class="headerlink" title="为Element资源文件添加注释或特殊标识"></a>为Element资源文件添加注释或特殊标识</h5><p>Element目录下的不同种类元素的资源均采用JSON文件表示，资源的名称“name”和取值“value”是每一条资源的必备字段。</p><ul><li><p>如果需要为某一条资源备注信息，以便于资源的理解和使用，可以<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-resource-file-example-0000001051733014#ZH-CN_TOPIC_0000001063096195__section835316337575" target="_blank" rel="noopener">通过comment字段添加注释</a>。</p></li><li><p>如果value字段中的部分文本不需要被翻译人员处理，也不会被显示在应用界面上，可以<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/basic-resource-file-example-0000001051733014#ZH-CN_TOPIC_0000001063096195__section18694191515571" target="_blank" rel="noopener">通过特殊结构来标识无需翻译的内容</a>。</p></li></ul><h5 id="通过comment字段添加注释"><a href="#通过comment字段添加注释" class="headerlink" title="通过comment字段添加注释"></a>通过comment字段添加注释</h5><p>通过comment字段，可以为JSON文件的资源添加注释。示例如下：</p><pre><code>{    "string":[        {            "name":"message_arrive",            "value":"We will arrive at %s",            "comment":"Transfer Arrival Time. %s is time,like 5:00 am"        }    ]}</code></pre><h5 id="通过特殊结构来标识无需翻译的内容"><a href="#通过特殊结构来标识无需翻译的内容" class="headerlink" title="通过特殊结构来标识无需翻译的内容"></a>通过特殊结构来标识无需翻译的内容</h5><p>在string、strarray、plural这三类资源中，可以通过特殊标识来处理无需被翻译的内容。例如，一个字符串资源的Value取值为“We will arrive at %s”，其中的变量“%s”在翻译过程中希望保持不变。有以下两种方式处理：</p><ul><li>方式一：在value字段中添加{}。示例如下：</li></ul><pre><code>{    "string":[        {            "name":"message_arrive",            "value":["We will arrive at",{                "id":"time",                "example":"5:00 am",                "value":"%s"            }            ]        }    ]}</code></pre><ul><li>方式二：添加<a href="xliff:g">xliff:g</a>标记对。示例如下：</li></ul><pre><code>{    "string":[        {            "name":"message_arrive",            "value":"We will arrive at &lt;xliff:g id='time' example='5:00 am'&gt;%s&lt;/xliff:g&gt;"        }    ]}</code></pre><h5 id="boolean-json示例"><a href="#boolean-json示例" class="headerlink" title="boolean.json示例"></a>boolean.json示例</h5><pre><code>{    "boolean":[        {            "name":"boolean_1",            "value":true        },        {            "name":"boolean_ref",            "value":"$boolean:boolean_1"        }    ]}</code></pre><h5 id="color-json示例"><a href="#color-json示例" class="headerlink" title="color.json示例"></a>color.json示例</h5><pre><code>{    "color":[        {            "name":"red",            "value":"#ff0000"        },        {            "name":"red_ref",            "value":"$color:red"        }    ]}</code></pre><h5 id="float-json示例"><a href="#float-json示例" class="headerlink" title="float.json示例"></a>float.json示例</h5><pre><code>{    "float":[        {            "name":"float_1",            "value":"30.6"        },        {            "name":"float_ref",            "value":"$float:float_1"        },        {            "name":"float_px",            "value":"100px"        }    ]}</code></pre><h5 id="intarray-json示例"><a href="#intarray-json示例" class="headerlink" title="intarray.json示例"></a>intarray.json示例</h5><pre><code>{    "intarray":[        {            "name":"intarray_1",            "value":[                100,                200,                "$integer:integer_1"            ]        }    ]}</code></pre><h5 id="integer-json示例"><a href="#integer-json示例" class="headerlink" title="integer.json示例"></a>integer.json示例</h5><pre><code>{    "integer":[        {            "name":"integer_1",            "value":100        },        {            "name":"integer_ref",            "value":"$integer:integer_1"        }    ]}</code></pre><h5 id="pattern-json示例"><a href="#pattern-json示例" class="headerlink" title="pattern.json示例"></a>pattern.json示例</h5><pre><code>{    "pattern":[        {            "name":"base",            "value":[                {                    "name":"width",                    "value":"100vp"                },                {                    "name":"height",                    "value":"100vp"                },                {                    "name":"size",                    "value":"25px"                }            ]        },        {           "name":"child",           "parent":"base",           "value":[               {                   "name":"noTitile",                   "value":"Yes"               }           ]        }    ]}</code></pre><h5 id="plural-json示例"><a href="#plural-json示例" class="headerlink" title="plural.json示例"></a>plural.json示例</h5><pre><code>{    "plural":[        {            "name":"eat_apple",            "value":[                {                    "quantity":"one",                    "value":"%d apple"                },                {                    "quantity":"other",                    "value":"%d apples"                }            ]        }    ]}</code></pre><h5 id="strarray-json示例"><a href="#strarray-json示例" class="headerlink" title="strarray.json示例"></a>strarray.json示例</h5><pre><code>{    "strarray":[       {           "name":"size",           "value":[               {                   "value":"small"               },               {                   "value":"$string:hello"               },               {                   "value":"large"               },               {                   "value":"extra large"               }            ]       }    ]}</code></pre><h5 id="string-json示例"><a href="#string-json示例" class="headerlink" title="string.json示例"></a>string.json示例</h5><pre><code>{    "string":[        {            "name":"hello",            "value":"hello base"        },        {            "name":"app_name",            "value":"my application"        },        {            "name":"app_name_ref",            "value":"$string:app_name"        },        {            "name":"app_sys_ref",            "value":"$ohos:string:request_location_reminder_title"        }    ]}</code></pre><h4 id="国际化能力的支持"><a href="#国际化能力的支持" class="headerlink" title="国际化能力的支持"></a>国际化能力的支持</h4><h5 id="时间日期国际化"><a href="#时间日期国际化" class="headerlink" title="时间日期国际化"></a>时间日期国际化</h5><p>不同的区域具有不同的时间日期显示习惯。例如，英语（美国）区域short时间格式为“9:31 AM”；简体中文（中国）区域short时间格式为“上午9:31”；芬兰语（芬兰）区域short时间格式为“9.31”。因此为开发者提供了获取不同区域的时间日期规格的能力。</p><p>界面时间日期字串和时间类控件显示，应当遵循当地习惯的规则，当需要展示时间或日期时，建议获取当前地区的时间日期规格，并对显示的字串根据获取到的规格进行格式化后再使用。</p><p>示例1：</p><pre><code>Locale locale = new Locale("de", "CH");String skeleton = "MMMMd";String bestPattern = DateFormatUtil.getBestPattern(skeleton, locale); // 返回值为"d. MMMM"</code></pre><p>示例2：</p><pre><code>String languageTag = "zh";String out = DateFormatUtil.format("EEEEdMMMMy", languageTag, "Asia/Shanghai", 0, 3600 * 1000); // 返回值为"1970年1月1日星期四"</code></pre><h5 id="电话号码国际化"><a href="#电话号码国际化" class="headerlink" title="电话号码国际化"></a>电话号码国际化</h5><p>不同的区域的电话号码有不同的格式化效果，当需要展示本地电话号码时，应遵循当地电话号码的格式化原则。因此为开发者提供了对不同地区电话号码格式化的能力，以便于在显示电话号码时正确的格式化。并提供了获取电话号码归属地的能力，开发者可以使用相关接口获取电话号码的归属地信息。</p><p>示例1：</p><pre><code>InputFormatter formatter = InputFormatter.getInstance("CN");formatter.inputNumberAndRememberPosition('1'); // 返回值为"1"formatter.inputNumber('5'); // 返回值为"15"formatter.inputNumber('6'); // 返回值为"156"formatter.inputNumberAndRememberPosition('1');// 返回值为"156 1"</code></pre><p>示例2：</p><pre><code>Locale.Builder builder = new Locale.Builder();builder.setLanguage("zh");builder.setRegion("CN");builder.setScript("Hant");Locale locale = builder.build();String displayName = PhoneNumberAttribution.getAttribute("+8615611xxxxxx", "CN", locale); // x为任意数字，返回值为"北京市"文本识别</code></pre><p>提供了对地址、时间日期与电话号码的文本识别能力，可以调用相关接口识别一段文本中包含的地址、时间日期与电话号码。</p><p>示例：</p><pre><code>// 当Locale.getDefault().getLanguage()为"en"时String source = "it is 123 test St";int[] re = TextRecognitionUtils.getAddress(source);if (re[0] == 1) {    result = source.substring(re[1], re[2] + 1);// 返回值为"123 main St"}</code></pre><h5 id="度量衡格式化"><a href="#度量衡格式化" class="headerlink" title="度量衡格式化"></a>度量衡格式化</h5><p>提供了对度量衡国际化能力的支持，可支持度量衡体系和维度之间的转换，与不同国家度量衡体系的自动转换。在开发包含度量衡的功能时，可以调用此能力满足多语言和不同国家用户的需求。</p><p>示例1：</p><pre><code>Locale zhCN = Locale.CHINA;MeasureFormatter mes = MeasureFormatter.getInstance(zhCN);mes.format(MeasureOptions.Unit.AREA_UK_ACRE,           10000,           MeasureOptions.Usage.AREA_LAND_AGRICULT,           MeasureOptions.FormatStyle.WIDE,           MeasureOptions.Style.AUTO_STYLE_ON));// 返回值为"4,046.856公顷"</code></pre><p>示例2：</p><pre><code>Locale enUS = Locale.US;MeasureFormatter mes = MeasureFormatter.getInstance(enUS);mes.format(MeasureOptions.Unit.VOLUME_US_CUP,           1000,           MeasureOptions.Unit.VOLUME_SI_LITER,           MeasureOptions.FormatStyle.WIDE));// 返回值为"236.588 liters"</code></pre><h5 id="敏感禁忌"><a href="#敏感禁忌" class="headerlink" title="敏感禁忌"></a>敏感禁忌</h5><p>提供对政治敏感地区、城市、及语言的获取能力，以及对地区名称更正的能力。</p><p>示例：</p><pre><code>Locale locale = Locale.getDefault();ArrayList&lt;String&gt; result = LocaleHelperUtils.getBlockedRegions(context, locale);//返回值包含"EH"与"XK"(西撒哈拉与科索沃），这两个地区为有政治争议的地区需谨慎使用</code></pre><h3 id="应用数据管理"><a href="#应用数据管理" class="headerlink" title="应用数据管理"></a>应用数据管理</h3><p>HarmonyOS应用数据管理支持单设备的各种结构化数据的持久化，以及跨设备之间数据的同步、共享以及搜索功能。开发者通过应用数据管理，能够方便地完成应用程序数据在不同终端设备间的无缝衔接，满足用户跨设备使用数据的一致性体验。</p><h4 id="本地应用数据管理"><a href="#本地应用数据管理" class="headerlink" title="本地应用数据管理"></a>本地应用数据管理</h4><p>提供单设备上结构化数据的存储和访问能力。使用SQLite作为持久化存储引擎，提供了多种类型的本地数据库，分别是关系型数据库（Relational Database）和对象关系映射数据库（Object Relational Mapping Database），此外还提供一种轻量级偏好数据库（Light Weight Preference Database），用以满足开发人员使用不同数据模型对应用数据进行持久化和访问的需求。</p><p>有关于本地应用数据管理的详细信息，请参阅<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-relational-overview-0000000000030046" target="_blank" rel="noopener">关系型数据库</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-orm-overview-0000000000030070" target="_blank" rel="noopener">对象关系映射数据库</a>和<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-preference-overview-0000000000030086" target="_blank" rel="noopener">轻量级偏好数据库</a>。</p><h4 id="分布式数据服务"><a href="#分布式数据服务" class="headerlink" title="分布式数据服务"></a>分布式数据服务</h4><p>分布式数据库支持用户数据跨设备相互同步，为用户提供在多种终端设备上一致的数据访问体验。通过调用分布式数据接口，应用可以将数据保存到分布式数据库中。通过结合帐号、应用唯一标识和数据库三元组，分布式数据库对属于不同应用的数据进行隔离。</p><p>有关于分布式数据库的详细信息，请参阅<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-mdds-overview-0000000000030123" target="_blank" rel="noopener">分布式数据服务</a>。</p><h4 id="分布式文件服务"><a href="#分布式文件服务" class="headerlink" title="分布式文件服务"></a>分布式文件服务</h4><p>在多个终端设备间为单个设备上应用程序创建的文件提供多终端的分布式共享能力。每台设备上都存储一份全量的文件元数据，应用程序通过文件元数据中的路径，可以实现同一应用文件的跨设备访问。</p><p>有关于分布式文件的详细信息，请参阅<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-dfs-overview-0000000000030154" target="_blank" rel="noopener">分布式文件服务</a>。</p><h4 id="数据搜索服务"><a href="#数据搜索服务" class="headerlink" title="数据搜索服务"></a>数据搜索服务</h4><p>在单个设备上，为应用程序提供搜索引擎级的全文索引管理、建立索引和搜索功能。</p><p>有关于数据搜索的详细信息，请参阅<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-fusion-search-overview-0000001050191132" target="_blank" rel="noopener">融合搜索</a>。</p><h4 id="数据存储管理"><a href="#数据存储管理" class="headerlink" title="数据存储管理"></a>数据存储管理</h4><p>为应用开发者提供系统存储路径、存储设备列表，存储设备属性的查询和管理功能。</p><p>有关于数据存储的详细信息，请参阅<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-storage-overview-0000000000030212" target="_blank" rel="noopener">数据存储管理</a></p><h3 id="应用权限管理"><a href="#应用权限管理" class="headerlink" title="应用权限管理"></a>应用权限管理</h3><p>HarmonyOS中所有的应用均在应用沙盒内运行。默认情况下，应用只能访问有限的系统资源，系统负责管理应用对资源的访问权限。</p><p>应用权限管理是由接口提供方（Ability）、接口使用方（应用）、系统（包括云侧和端侧）以及用户等多方共同参与的整个流程，保证受限接口是在约定好的规则下被正常使用，避免接口被滥用而导致用户、应用和设备受损。</p><p>本节重点介绍应用权限管理的基本思想。有关权限使用的详细信息，请参阅<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-overview-0000000000029883" target="_blank" rel="noopener">权限</a>。</p><h4 id="权限声明"><a href="#权限声明" class="headerlink" title="权限声明"></a>权限声明</h4><ul><li><p>应用需要在config.json中使用“reqPermissions”属性对需要的权限逐个进行声明。</p></li><li><p>若使用到的三方库也涉及权限使用，也需统一在应用的config.json中逐个声明。</p></li><li><p>没有在config.json中声明的权限，应用就无法获得此权限的授权。</p></li></ul><h4 id="动态申请敏感权限"><a href="#动态申请敏感权限" class="headerlink" title="动态申请敏感权限"></a>动态申请敏感权限</h4><p>动态申请敏感权限基于用户可知可控的原则，需要应用在运行时主动调用系统动态申请权限的接口，系统弹框由用户授权，用户结合应用运行场景的上下文，识别出应用申请相应敏感权限的合理性，从而做出正确的选择。</p><p>即使用户向应用授予了请求的权限，应用在调用受此权限管控的接口前，也应该先检查自己有无此权限，而不能把之前授予的状态持久化，因为用户在动态授予后还可以通过设置取消应用的权限。</p><p>有关于应用动态申请敏感权限的详细信息，请参阅<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886#ZH-CN_TOPIC_0000001072906209__section7431121314439" target="_blank" rel="noopener">动态申请权限</a>。</p><h4 id="自定义权限"><a href="#自定义权限" class="headerlink" title="自定义权限"></a>自定义权限</h4><p>HarmonyOS为了保证应用对外提供的接口不被恶意调用，需要对调用接口的调用者进行鉴权。</p><p>大多情况下，系统已定义的权限满足了应用的基本需要，若有特殊的访问控制需要，应用可在config.json中以”defPermissions”: []属性来定义新的权限，并通过“availableScope”和“grantMode”两个属性分别确定权限的开放范围和授权方式，使得权限定义更加灵活且易于理解。有关HarmonyOS权限开放范围和授权方式详细的描述，请参阅<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886#ZH-CN_TOPIC_0000001072906209__table4183104093414" target="_blank" rel="noopener">权限授予方式字段说明</a>和<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-guidelines-0000000000029886#ZH-CN_TOPIC_0000001072906209__table17184134033416" target="_blank" rel="noopener">权限限制范围字段说明</a>。</p><p>为了避免应用自定义新权限出现重名的情况，建议应用对新权限的命名以包名的前两个字段开头，这样可以防止不同开发者的应用间出现自定义权限重名的情况。</p><h4 id="权限保护方法"><a href="#权限保护方法" class="headerlink" title="权限保护方法"></a>权限保护方法</h4><ul><li><p>保护Ability：通过在config.json里对应的Ability中配置”permissions”: [“<em>权限名</em>“]属性，即可实现保护整个Ability的目的，无指定权限的应用不能访问此Ability。</p></li><li><p>保护API：若Ability对外提供的数据或能力有多种，且开放范围或保护级别也不同，可以针对不同的数据或能力在接口代码实现中通过verifyPermission(String permissionName, int pid, int uid)来对uid标识的调用者进行鉴权。</p></li></ul><h4 id="权限使用原则"><a href="#权限使用原则" class="headerlink" title="权限使用原则"></a>权限使用原则</h4><ul><li><p>权限申请最小化。跟用户提供的功能无关的权限，不要申请；尽量采用其他无需权限的操作来实现相应功能（如：通过intent拉起系统UI界面由用户交互、应用自己生成uuid代替设备ID等）。</p></li><li><p>权限申请完整。应用所需权限（包括应用调用到的三方库依赖的权限）都要逐个在应用的config.json中按格式声明。</p></li><li><p>满足用户可知。应用申请的敏感权限的目的需要真实准确告知用户。</p></li><li><p>权限就近申请。应用在用户触发相关业务功能时，就近提示用户授予实现此功能所需的权限。</p></li><li><p>权限不扩散。在用户未授权的情况下，不允许提供给其他应用使用。</p></li><li><p>应用自定义权限防止重名。建议以包名为前缀来命名权限，防止跟系统定义的权限重名</p></li></ul><h3 id="应用隐私保护"><a href="#应用隐私保护" class="headerlink" title="应用隐私保护"></a>应用隐私保护</h3><p>随着移动终端及其相关业务（如移动支付、终端云等）的普及，用户隐私保护的重要性愈发突出。应用开发者在产品设计阶段就需要考虑用户隐私的保护，提高应用的安全性。HarmonyOS应用开发需要遵从其隐私保护规则，在应用上架应用市场时，应用市场会根据规则进行校验，如不满足条件则无法上架。</p><p>个人数据是指与一个身份已被识别或者身份可被识别的自然人相关的任何信息，包括但不限于个人身份信息、身份验证信息、财务和付款信息、联系方式、用户搜索、浏览记录、使用习惯、位置信息、短信和通话相关数据、麦克风数据、摄像头数据以及其他设备或应用使用情况数据等，其中敏感个人数据是个人数据的一个重要子集，指的是涉及数据主体的最私密领域的信息或者一旦泄露可能会给数据主体造成重大不利影响的数据，如导致个人名誉、身心健康受到损害或歧视性待遇等；敏感个人数据在各国家/地区相关法律法规中的定义有所不同，建议根据当地的法律法规要求处理。</p><h4 id="数据收集及使用公开透明"><a href="#数据收集及使用公开透明" class="headerlink" title="数据收集及使用公开透明"></a>数据收集及使用公开透明</h4><p>应用采集个人数据时，应清晰、明确地告知用户，并确保告知用户的个人信息将被如何使用。</p><ul><li>应用申请操作系统<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-available-0000001051089272#ZH-CN_TOPIC_0000001073014298__section1727613371109" target="_blank" rel="noopener">敏感权限</a>时，需要明确告知用户权限申请的目的和用途，并获取用户的同意；敏感权限弹框参考示例如下。权限API使用方案请参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-overview-0000000000029883" target="_blank" rel="noopener">权限</a>章节。详细的设计原则请参考<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/introduction-0000001077467612" target="_blank" rel="noopener">隐私设计</a>。<strong>图1</strong> 敏感权限获取弹框示例</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDQ3N2FkNjFmZjRjZmNjNzljYjZmMDEzMjZkOTVhYjVfTFFqRDYzUE1Xb09Xd0xXaTJEUFcweXlGUGZvMGo4c1VfVG9rZW46Ym94Y254OFJsa1hPYjhxb0MxRzdRdzBKVjJlXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><ul><li><p>开发者应制定并遵从适当的隐私政策，在收集、使用留存和第三方分享用户数据时需要符合所有适用法律、政策和规定。如在收集个人数据前，需充分告知用户处理个人数据的种类、目的、处理方式、保留期限等，满足数据主体权利等要求。</p></li><li><p>应用向第三方披露任何个人信息须在隐私政策中说明披露内容、目的和披露对象。根据以上要求，我们设计了示例以供参考。隐私通知/声明的参考示例如下：</p></li></ul><p><strong>图2</strong> 应用隐私通知与隐私声明示例图</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDAwNjBhNGRjNDdjYTAzZWY3ZDVmNTkxYzE0YmY1YjRfTmR1MFIxSXlhNXhuUGlVZjVTRzhLVEoxazllaEZycEJfVG9rZW46Ym94Y25nY3pFeHJnOG54cVFEdU4xTXZTdFVlXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><p>个人数据应当基于具体、明确、合法的目的收集，不应与此目的不相符的方式作进一步处理。对于收集目的变更和用户撤销同意后再次使用的场景都需要用户重新同意。隐私声明变更与隐私声明撤销同意如图所示。<strong>图3</strong> 隐私声明变更示例图</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTU5Zjg1YTI4NjJlNWI5ZTdhZjRhZGQxYTFmY2NiOTdfdkVDTUgwRHhpYnV4Nk1VM0xPM3hzUWliTmNpaXFBNkJfVG9rZW46Ym94Y25tUXRmamY1a2dLTTdwcEJaRDZHUUZmXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><p><strong>图4</strong> 隐私声明撤销同意示例图</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2EwMmM1YTdmMWVhZjYxMGE3NjRkNjkxY2RmYjFkZjNfSUo0Vnh2clk1OTdFcUpQMGk1Mk1razVLbTh6ZzVwT0FfVG9rZW46Ym94Y25KUlRxcXNrS0RESnRvbmo5clh0UG1mXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><ul><li>应用需要提供用户查看隐私声明的入口。例如在应用的“关于”界面提供查看隐私声明的入口，如示例图所示：<strong>图5</strong> 隐私声明的查看界面示例图</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTYzYzhiMWRiN2FmMmUxNmJkNGM4ZjBhMTRkMDY5ODJfYkdsakt1dTFiMkprdmJ0VlZBM1lnY3czdURhTjhlRUJfVG9rZW46Ym94Y25lZEtyOTdTYUFqSEZoMFNKMWRrUXRlXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><ul><li><p>应用的隐私声明应覆盖本应用所有收集的个人数据。</p></li><li><p>在后台持续读取位置信息场景时，请申请ohos.permission.LOCATION_IN_BACKGROUND权限，详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-available-0000001051089272#ZH-CN_TOPIC_0000001073014298__section1727613371109" target="_blank" rel="noopener">敏感权限</a>；</p></li><li><p>应用存在调用第三方的<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-ability-overview-0000000000029852" target="_blank" rel="noopener">元能力（Particle Ability）</a>或<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-ability-overview-0000000000029852" target="_blank" rel="noopener">元服务（Feature Ability）</a>场景时，需要在应用的隐私声明中明确第三方责任，如涉及个人数据收集则需要告知用户第三方的名称及收集的个人数据类型、目的和方式，申请的敏感权限、申请目的等。</p></li></ul><h4 id="数据收集及使用最小化"><a href="#数据收集及使用最小化" class="headerlink" title="数据收集及使用最小化"></a>数据收集及使用最小化</h4><p>应用个人数据收集应与数据处理目的相关，且是适当、必要的。开发者应尽可能对个人数据进行匿名化或假名化处理，降低数据主体的风险。仅可收集和处理与特定目的相关且必需的个人数据，不能对数据做出与特定目的不相关的处理。</p><ul><li><p>敏感权限申请的时候要满足权限最小化的要求，在进行权限申请时，只申请获取必需的信息或资源所需要的权限。如应用不需要相机权限就能够实现其功能时，则不应该向用户申请相机权限。</p></li><li><p>应用针对数据的收集要满足最小化要求，不收集与应用提供服务无关联的数据。如通信社交类应用，不应收集用户的网页浏览记录。</p></li><li><p>数据使用的功能要求能够使用户受益，收集的数据不能用于与用户正常使用无关的功能。如应用不得将“生物特征”、“健康数据”等敏感个人数据用于服务改进、投放广告或营销等非业务核心功能。</p></li><li><p>系统禁止应用在后台访问相机和麦克风的数据；</p></li><li><p>应用使用第三方支付交易过程中，如非适用法律要求或为提供第三方支付服务所必需，不得记录用户交易类鉴权信息，或向第三方批露与用户特定交易无关的用户个人信息。</p></li><li><p>应用不得仅出于广告投放或数据分析的目的而请求位置权限。</p></li><li><p>禁止在日志中打印敏感个人数据，如需要打印个人数据时，应对个人数据进行匿名化或假名化处理；</p></li><li><p>避免使用IMEI和序列号等永久性的标识符，尽量使用可以重置的标识符，如系统提供了<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/device-identifier-networkid-0000001084507694" target="_blank" rel="noopener">NetworkID</a>和<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/device-identifier-dvid-0000001131409565" target="_blank" rel="noopener">DVID</a>作为分布式场景下的设备标识符，广告业务场景下则建议使用<a href="https://developer.huawei.com/consumer/cn/doc/development/HMSCore-Guides/oaid-0000001050783198" target="_blank" rel="noopener">OAID</a>，基于应用的分析则建议使用<a href="https://developer.huawei.com/consumer/cn/doc/development/HMSCore-Guides/odid-0000001051063255" target="_blank" rel="noopener">ODID</a>和<a href="https://developer.huawei.com/consumer/cn/doc/development/HMSCore-Guides/aaid-0000001051142988" target="_blank" rel="noopener">AAID</a>，其他需要唯一标识符的场景可以使用<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/device-identifier-uuid-0000001084827280" target="_blank" rel="noopener">UUID</a>接口生成；</p></li><li><p>不再需要使用的数据需要及时清除，降低数据泄露的风险。如分布式业务场景下设备断开分布式网络，临时缓存的数据需要及时删除。</p></li></ul><h4 id="数据处理选择和控制"><a href="#数据处理选择和控制" class="headerlink" title="数据处理选择和控制"></a>数据处理选择和控制</h4><p>对个人数据处理必须要征得用户的同意或遵守适用的法律法规，用户对其个人数据要有充分的控制权。</p><ul><li><p>系统对于用户的敏感数据和系统关键资源的获取设置了对应的权限，应用访问这些数据时需要申请对应的权限。相关权限列表请参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/security-permissions-available-0000001051089272" target="_blank" rel="noopener">应用权限列表</a>章节。</p></li><li><p>应用申请使用敏感权限：应用弹窗提醒，向用户呈现应用需要获取的权限和权限使用目的、应用需要收集的数据和使用目的等，通过用户点击“同意”或“始终允许”的方式完成用户授权，让用户对应用权限的授予和个人数据的使用做到透明、可知、可控。</p></li><li><p>用户可以修改、取消授予应用的权限：当用户不同意某一权限或者数据收集时，应当允许用户使用与这部分权限和数据收集不相关的功能。如通信社交类应用，用户可以拒绝授予相机权限，不应该影响与相机无关的功能操作，如语音通话。</p></li><li><p>在进入应用的主界面之前不建议直接弹窗申请敏感权限，仅在用户使用功能时才请求对应的权限。如通信社交类应用，在没有启用位置相关的功能时，不建议在启动应用时就申请位置权限。</p></li><li><p>应用若使用个人数据用于个性化广告和精准营销，需提供独立的关闭选项。</p></li><li><p>需要向用户提供对个人数据的控制能力；如在云服务上存储了个人数据，需要提供删除数据的方法。</p></li><li><p>应用同时支持单设备和跨设备场景时，用户能够单独关闭跨设备应用场景。</p></li></ul><h4 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h4><p>从技术上保证数据处理活动的安全性，包括个人数据的加密存储、安全传输等安全机制，应默认开启或采取安全保护措施。</p><ul><li><strong>数据存储</strong></li></ul><ol><li>应用产生的密钥以及用户的敏感个人数据需要存储在应用的私有目录下。</li><li>应用可以调用系统提供的本地数据库RdbStore的加密接口对敏感个人数据进行加密存储。接口详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-relational-overview-0000000000030046" target="_blank" rel="noopener">关系型数据库</a>章节。</li><li>应用产生的分布式数据可以调用系统的分布式数据库进行存储，对于敏感个人数据需要采用分布式数据库提供的加密接口进行加密，接口详见<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/database-mdds-overview-0000000000030123" target="_blank" rel="noopener">分布式数据服务</a>章节。</li></ol><ul><li><strong>安全传输</strong>需要分别针对本地传输和远程传输采取不同的安全保护措施。</li></ul><p>本地传输：</p><ol><li>应用通过intent跨应用传输数据时避免包含敏感个人数据，防止隐式调用导致intent劫持，导致个人数据泄露。</li><li>应用内组件调用应采用安全方式，避免通过隐式方式进行调用组件，防止组件劫持。</li><li>避免使用socket方式进行本地通信，如需使用，localhost端口号随机生成，并对端口连接对象进行身份认证和鉴权。</li><li>本地IPC通信安全：作为服务提供方需要校验服务使用方的身份和访问权限，防止服务使用方进行身份仿冒或者权限绕过。</li></ol><p>远程传输：</p><ol><li>使用https代替http进行通信，并对https证书进行严格校验。</li><li>避免进行远程端口进行通信，如需使用，需要对端口连接对象进行身份认证和鉴权。</li><li>应用进行跨设备通信时，需要校验被访问设备和应用的身份信息，防止被访问方的设备和应用进行身份仿冒。</li><li>应用进行跨设备通信时，作为服务提供方需要校验服务使用方的身份和权限，防止服务使用方进行身份仿冒或者权限绕过。</li></ol><h4 id="本地化处理"><a href="#本地化处理" class="headerlink" title="本地化处理"></a>本地化处理</h4><p>应用开发的数据优先在本地进行处理，对于本地无法处理的数据上传云服务要满足最小化的原则，不能默认选择上传云服务。</p><h4 id="未成年人数据保护要求"><a href="#未成年人数据保护要求" class="headerlink" title="未成年人数据保护要求"></a>未成年人数据保护要求</h4><p>如果应用是给未成年人设计的，或者应用通过收集的用户年龄数据识别出用户是未成年人，开发者应该结合目标市场国家的相关法律，专门分析未成年人个人数据保护的问题。收集未成年人数据前需要征得监护人的同意。</p><p>专为未成年人设计的应用不建议请求获取位置权限。</p><h4 id="元服务（Feature-Ability）"><a href="#元服务（Feature-Ability）" class="headerlink" title="元服务（Feature Ability）"></a>元服务（Feature Ability）</h4><p>对于Visible=true的元服务，需要满足如下要求：</p><ul><li><p>元服务启动时，需要在明显位置展示元服务的功能名称及开发者名称/logo。</p></li><li><p>元服务如涉及个人数据的收集，应提供独立的隐私声明，并在收集个人数据前向用户告知隐私声明。</p></li><li><p>元服务应按照法律法规要求收集个人数据，基于用户同意收集的个人数据，用户有权撤销同意。</p></li><li><p>元服务需要提供隐私声明的查看入口。</p></li><li><p>元服务隐私声明发生变更时，需要用户重新同意。</p></li><li><p>禁止在元服务免安装过程中捆绑安装与本服务不相关的功能，如扫描二维码的元服务不应该支持录音功能</p></li></ul><h3 id="三方应用调用管控机制"><a href="#三方应用调用管控机制" class="headerlink" title="三方应用调用管控机制"></a>三方应用调用管控机制</h3><h4 id="为什么要进行调用管控"><a href="#为什么要进行调用管控" class="headerlink" title="为什么要进行调用管控"></a>为什么要进行调用管控</h4><p>后台进程启动过多，会消耗系统的内存、CPU等资源，造成用户设备耗电快、卡顿等现象。因此，为了保证用户体验，系统会对三方用户应用程序之间的<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/glossary-0000000000029587#ZH-CN_TOPIC_0000001050749051__section779354121411" target="_blank" rel="noopener">PA</a>调用进行管控，减少不必要的关联拉起。</p><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li><p>前台：用户应用程序有可见的FA正在显示，则认为用户应用程序在前台。</p></li><li><p>用户应用程序内调用：同一用户应用程序内的FA、PA之间的访问。</p></li></ul><h4 id="调用管控总体思路"><a href="#调用管控总体思路" class="headerlink" title="调用管控总体思路"></a>调用管控总体思路</h4><ol><li>用户应用程序内调用不管控。</li><li>三方用户应用程序间调用严格管控：禁止三方用户应用程序在后台调用其他三方应用的PA；严格管控三方用户应用程序在前台调用其他用户应用程序的PA。</li></ol><h4 id="管控规则"><a href="#管控规则" class="headerlink" title="管控规则"></a>管控规则</h4><ul><li><p>用户应用程序内调用不管控。</p></li><li><p>三方用户应用程序间调用三方应用程序A调用三方应用程序B的PA，具体限制如下：</p><ul><li>禁止A在后台调用B的PA。</li></ul></li><li><p>当B有进程存活时，允许A在前台调用B的PA；当B无进程存活时，禁止A的调用</p></li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h3><h4 id="任务说明"><a href="#任务说明" class="headerlink" title="任务说明"></a>任务说明</h4><p>本文档适用于HarmonyOS应用开发的初学者。通过构建一个简单的具有页面跳转功能的应用（如下图<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/previewer-0000001054328973#ZH-CN_TOPIC_0000001056725592__section16523172216252" target="_blank" rel="noopener">预览器</a>运行效果所示），熟悉HarmonyOS应用开发流程。</p><p>为确保运行效果，请使用最新版本的<strong>DevEco Studio</strong>完成本任务，点击<a href="https://developer.harmonyos.com/cn/develop/deveco-studio#download" target="_blank" rel="noopener">此处</a>获取下载链接。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjRlYzZjODNhMDJlOWU5OTZhODlkYWMxMDgzMTA3NmRfbHY0bWUxTG9tQlJqWXRDMERYUW5DM1BiZ0FybzVJM3JfVG9rZW46Ym94Y25MUTlyRUxRWmdIbkJXenJGMzRBcFBlXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><h4 id="开发准备-1"><a href="#开发准备-1" class="headerlink" title="开发准备"></a>开发准备</h4><ol><li>开始前请参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/software_install-0000001053582415" target="_blank" rel="noopener">下载与安装软件</a>、<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/environment_config-0000001052902427" target="_blank" rel="noopener">配置开发环境</a>，完成<strong>DevEco Studio</strong>的安装和开发环境的配置。</li><li>开发环境配置完成后，请参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/hello_world-0000001054516888" target="_blank" rel="noopener">创建和运行Hello World</a>创建一个新工程，设备类型以“Phone”为例，使用Java语言开发，模板选择“Empty Feature Ability(Java)”。</li><li>工程创建完成后，使用<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/previewer-0000001054328973#ZH-CN_TOPIC_0000001056725592__section16523172216252" target="_blank" rel="noopener">预览器</a>或Phone<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/run_simulator-0000001053303709" target="_blank" rel="noopener">模拟器</a>运行该工程。</li></ol><h3 id="编写第一个页面"><a href="#编写第一个页面" class="headerlink" title="编写第一个页面"></a>编写第一个页面</h3><p>在Java UI框架中，提供了<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-component-layout-overview-0000000000500400" target="_blank" rel="noopener">两种编写布局的方式</a>：<strong>在XML中声明UI布局</strong>和<strong>在代码中创建布局</strong>。这两种方式创建出的布局没有本质差别，为了熟悉两种方式，我们将通过XML的方式编写第一个页面，通过代码的方式<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/start-second-page-0000000000029619" target="_blank" rel="noopener">编写第二个页面</a>。</p><ol><li>在“Project”窗口，点击“entry &gt; src &gt; main &gt; resources &gt; base &gt; layout”，打开“ability_main.xml”文件。</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWU2N2FkMTczZDJlNDUwNmMxMjBmYjA2MGM3OGJhNmRfNmd1RFRpdHNvN2V3U2ZJN0p4bDF0VnNnV0NwMnhXRWZfVG9rZW46Ym94Y25CcmVBTGRXZ2o5elJUTldPY3FMb1BiXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><ol><li>第一个页面内有一个文本和一个按钮，使用<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-layout-dependentlayout-0000001050729536" target="_blank" rel="noopener">DependentLayout</a>布局，通过<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-component-text-0000001050729534" target="_blank" rel="noopener">Text</a>和<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-component-button-0000001051009585" target="_blank" rel="noopener">Button</a>组件来实现，其中<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/basic-0000001055539104" target="_blank" rel="noopener">vp和fp</a>分别表示虚拟像素和字体像素。“ability_main.xml”的示例代码如下：</li></ol><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;DependentLayout    xmlns:ohos="http://schemas.huawei.com/res/ohos"    ohos:width="match_parent"    ohos:height="match_parent"&gt;    &lt;Text        ohos:id="$+id:text"        ohos:width="match_content"        ohos:height="match_content"        ohos:text="Hello World"        ohos:text_color="#000000"        ohos:text_size="32fp"        ohos:center_in_parent="true"/&gt;    &lt;Button        ohos:id="$+id:button"        ohos:width="match_content"        ohos:height="match_content"        ohos:text="Next"        ohos:text_size="19fp"        ohos:text_color="#FFFFFF"        ohos:top_padding="8vp"        ohos:bottom_padding="8vp"        ohos:right_padding="70vp"        ohos:left_padding="70vp"        ohos:center_in_parent="true"        ohos:below="$id:text"        ohos:margin="10vp"/&gt;&lt;/DependentLayout&gt;</code></pre><ol><li>按钮的背景是蓝色胶囊样式，可以通过graphic目录下的XML文件来设置。右键点击“graphic”文件夹，选择“New &gt; File”，命名为“background_button.xml”，单击回车键。</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzZiN2VlNzk0MTViZDdhZWVkNTRlY2E0OWE0ODFiNWNfcmh6aE8yYnE4NzZsa05zSzJGcm5KSnIzN3p2Wkx5NDhfVG9rZW46Ym94Y25pb0RaV3MxU3h4VzdHMFdWaGlHQXJjXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><p>“background_button.xml”的示例代码如下：</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape    xmlns:ohos="http://schemas.huawei.com/res/ohos"    ohos:shape="rectangle"&gt;    &lt;corners        ohos:radius="100"/&gt;    &lt;solid        ohos:color="#007DFF"/&gt;&lt;/shape&gt;</code></pre><p>在layout目录下的“ability_main.xml”文件中，使用<strong>background_element=”$graphic:background_button”</strong>的方式引用“background_button.xml”文件：</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;DependentLayout    ...    &lt;Button        ohos:id="$+id:button"        ohos:width="match_content"        ohos:height="match_content"        ohos:text="Next"        ohos:text_size="19fp"        ohos:text_color="#FFFFFF"        ohos:top_padding="8vp"        ohos:bottom_padding="8vp"        ohos:right_padding="70vp"        ohos:left_padding="70vp"        ohos:center_in_parent="true"        ohos:below="$id:text"        ohos:margin="10vp"        ohos:background_element="$graphic:background_button"/&gt;&lt;/DependentLayout&gt;</code></pre><ol><li>在XML文件中添加组件后，需要在Java代码中加载XML布局。在“Project”窗口，选择“entry &gt; src &gt; main &gt; java &gt; com.example.myapplication &gt; slice” ，打开“MainAbilitySlice.java”文件，使用setUIContent方法加载“ability_main.xml”布局。</li></ol><p>说明</p><p>HarmonyOS提供了<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-page-concept-0000000000033573" target="_blank" rel="noopener">Ability和AbilitySlice</a>两个基础类，一个有界面的Ability可以由一个或多个AbilitySlice构成，AbilitySlice主要用于承载单个页面的具体逻辑实现和界面UI，是应用显示、运行和跳转的最小单元。</p><p>本文档以同一个Ability内的两个AbilitySlice之间的跳转为例，如果开发者希望实现两个Ability之间的跳转，请参考<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-page-switching-0000000000037999#ZH-CN_TOPIC_0000001050748853__section1862412142519" target="_blank" rel="noopener">不同Page间导航</a>。</p><p>“MainAbilitySlice.java”的示例代码如下：</p><pre><code>package com.example.myapplication.slice;import com.example.myapplication.ResourceTable;import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent;public class MainAbilitySlice extends AbilitySlice {    @Override    public void onStart(Intent intent) {        super.onStart(intent);        super.setUIContent(ResourceTable.Layout_ability_main); // 加载XML布局    }}</code></pre><ol><li>使用<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/previewer-0000001054328973#ZH-CN_TOPIC_0000001056725592__section16523172216252" target="_blank" rel="noopener">预览器</a>或<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/run_simulator-0000001053303709" target="_blank" rel="noopener">模拟器</a>运行项目，效果如下图所示。</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTI3M2YwYTEyYzc3MTNmMTllN2NhMGI2YmMyOWEyODZfVmViUGVzdkdpcWhNN1JaMVZFS0wwRkxwZk9sRktzaFdfVG9rZW46Ym94Y25wdEZQQnNaVjd6dGJLbzlRTXNaSVljXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><h3 id="创建另一个页面"><a href="#创建另一个页面" class="headerlink" title="创建另一个页面"></a>创建另一个页面</h3><p>在上一节中，我们用XML的方式编写了一个包含文本和按钮的页面。为了帮助开发者熟悉在代码中创建布局的方式，接下来我们使用代码的方式编写第二个页面。</p><ol><li>在“Project”窗口，打开“entry &gt; src &gt; main &gt; java &gt; com.example.myapplication”，右键点击“slice”文件夹，选择“New &gt; Java Class”，命名为“SecondAbilitySlice”，单击回车键。</li><li>第二个页面上有一个文本。在上一步创建的“SecondAbilitySlice”文件中，添加一个Text，示例代码如下：</li></ol><pre><code>package com.example.myapplication.slice;import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent;import ohos.agp.colors.RgbColor;import ohos.agp.components.DependentLayout;import ohos.agp.components.Text;import ohos.agp.components.element.ShapeElement;import ohos.agp.utils.Color;import ohos.agp.components.DependentLayout.LayoutConfig;public class SecondAbilitySlice extends AbilitySlice {    @Override    public void onStart(Intent intent) {        super.onStart(intent);        // 声明布局        DependentLayout myLayout = new DependentLayout(this);        // 设置布局宽高        myLayout.setWidth(LayoutConfig.MATCH_PARENT);        myLayout.setHeight(LayoutConfig.MATCH_PARENT);        // 设置布局背景为白色        ShapeElement background = new ShapeElement();        background.setRgbColor(new RgbColor(255, 255, 255));        myLayout.setBackground(background);        // 创建一个文本        Text text = new Text(this);        text.setText("Hi there");        text.setWidth(LayoutConfig.MATCH_PARENT);        text.setTextSize(100);        text.setTextColor(Color.BLACK);        // 设置文本的布局        DependentLayout.LayoutConfig textConfig = new DependentLayout.LayoutConfig(LayoutConfig.MATCH_CONTENT, LayoutConfig.MATCH_CONTENT);        textConfig.addRule(LayoutConfig.CENTER_IN_PARENT);        text.setLayoutConfig(textConfig);        myLayout.addComponent(text);        super.setUIContent(myLayout);    }}</code></pre><h3 id="实现页面跳转"><a href="#实现页面跳转" class="headerlink" title="实现页面跳转"></a>实现页面跳转</h3><ol><li>打开第一个页面的“MainAbilitySlice.java”文件，添加按钮的响应逻辑，实现点击按钮跳转到下一页，示例代码如下：</li></ol><pre><code>package com.example.myapplication.slice;import com.example.myapplication.ResourceTable;import ohos.aafwk.ability.AbilitySlice;import ohos.aafwk.content.Intent;import ohos.agp.components.Button;public class MainAbilitySlice extends AbilitySlice {    @Override    public void onStart(Intent intent) {        super.onStart(intent);        super.setUIContent(ResourceTable.Layout_ability_main);        Button button = (Button) findComponentById(ResourceTable.Id_button);        // 点击按钮跳转至第二个页面        button.setClickedListener(listener -&gt; present(new SecondAbilitySlice(), new Intent()));    }}</code></pre><ol><li>再次运行项目，效果如下图所示。</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGFmMjVjYzBmYTExNDk1ZmUyYWI4ZjNlOWJkMjE3MTRfTlUyVm5tVlFtcWF0MGdhODhqaTBQdURNYlFoZDdBVFFfVG9rZW46Ym94Y244UURPY25qcjNoMG9LRWpXRXozR05ZXzE2MjcxNDcxOTU6MTYyNzE1MDc5NV9WNA" alt="img"></p><p>恭喜你，至此已成功完成HarmonyOS快速入门。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Harmony </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Harmony </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HarmonyOS设计：设备详解</title>
      <link href="/posts/38d.html"/>
      <url>/posts/38d.html</url>
      
        <content type="html"><![CDATA[<h1 id="手机-折叠屏-平板设计"><a href="#手机-折叠屏-平板设计" class="headerlink" title="手机/折叠屏/平板设计"></a>手机/折叠屏/平板设计</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>HarmonyOS 手机/折叠屏/平板设计指南用于指导系统/应用设计，确保给用户提供清晰一致、简单易用的使用体验，对齐设计语言，拉通体验设计的方向，帮助设计师统一设计品质。</p><h3 id="设计原则-1"><a href="#设计原则-1" class="headerlink" title="设计原则"></a>设计原则</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmQ0YWRiYmJjNzI2MzYzM2MzNDQ1YzRlM2I4OGYyYzZfWnlFU0JMT2JkV2toWWpnVWY0MndIVkpEVDF6azdJcWRfVG9rZW46Ym94Y25SM3VjSE43c2MzbTdyUlFSTDFUbk9oXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzg2ZjYxMmRlMGQxODBiMjJiNGU1MzA3ZmI0Mjk4M2FfYXdmM0VtUW1SdHJXdmtmU1Nld1YzTnAwaHhZblpDMmJfVG9rZW46Ym94Y25RREFvTjc0WDEzRk9kWUlBSkpYQ0JmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>系统架构是系统运行的基础框架，由 AOD（Always on Display）、锁屏、负一屏、HarmonyOS 桌面、通知中心、控制中心、任务中心和应用程序组成，他们共同维持着整个用户使用手机的体验。应用可以直接使用系统架构来体现自己的服务或功能。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGI3MTM0Y2QzZGQwY2EwNzMxZTdiYzdiNGU3NmEwZjBfV2dYWHFiU2JDQ0l3NGE2UG8zSDRicXZucUxwZEc0Z3lfVG9rZW46Ym94Y25ZZXdQb25Nd29vWU9pSHlHbEZkTHJlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="AOD"><a href="#AOD" class="headerlink" title="AOD"></a>AOD</h3><p>AOD 可以在待机的情况下，显示用户最为关注的信息，例如时间、日期、重要通知的提醒。</p><h3 id="锁屏"><a href="#锁屏" class="headerlink" title="锁屏"></a>锁屏</h3><p>用户可以通过设置锁屏密码保护隐私。锁屏后，用户可以在锁屏界面查看时间、日期及通知信息。</p><p>在待机状态，用户按电源键或双击屏幕进入锁屏界面，通过手势或密码解锁。</p><h3 id="HarmonyOS-桌面"><a href="#HarmonyOS-桌面" class="headerlink" title="HarmonyOS 桌面"></a>HarmonyOS 桌面</h3><p>HarmonyOS 桌面是用户访问应用的入口，所有的应用都会在 HarmonyOS 桌面上显示，用户可以通过移动位置、加入文件夹、建立快捷方式等对应用进行管理。HarmonyOS 桌面包含应用的入口、文件夹、快捷方式和万能卡片。万能卡片是 HarmonyOS 服务的一种表现形式，用户可以在 HarmonyOS 桌面上放置万能卡片达到快速访问应用信息的目的。</p><h3 id="负一屏"><a href="#负一屏" class="headerlink" title="负一屏"></a>负一屏</h3><p>负一屏将用户最关心的内容直接呈上，一步直达。包括快递、打车信息、资讯等。用户也可以订阅自己喜欢的服务号，方便快捷的访问相关服务。</p><h3 id="控制中心"><a href="#控制中心" class="headerlink" title="控制中心"></a>控制中心</h3><p>通过控制中心可以对 1+8+N 的设备进行快捷管理。控件中心由音频播控中心、快捷开关面板、超级终端面板、智能设备面板组成。</p><ul><li><p>通过音频播控中心可以将当前正在播放的音频切换到其他设备上播放。</p></li><li><p>通过快捷开关面板可以快速的开启或关闭蓝牙、WLAN 等系统功能。</p></li><li><p>通过超级终端面板可以快速建立跟其他设备的协同，例如在手机上点击超级终端面板中的平板，可以快速开启多屏协同。</p></li><li><p>通过智能设备面板控制家庭中每一个智能设备。例如在回家的时候，提前打开家里的空调。</p></li></ul><h3 id="通知中心"><a href="#通知中心" class="headerlink" title="通知中心"></a>通知中心</h3><p>通知中心用来展示应用的通知，以及正在进行的任务。用户可以通过通知中心及时了解应用的最新信息。用户可以关掉应用的通知，因此应用应该谨慎选择发送给用户的通知。</p><h3 id="任务中心"><a href="#任务中心" class="headerlink" title="任务中心"></a>任务中心</h3><p>最近打开的应用都会在任务中心中呈现。用户可以通过任务中心来打开最近访问过的应用。</p><h3 id="系统导航"><a href="#系统导航" class="headerlink" title="系统导航"></a>系统导航</h3><p>用户通过系统导航浏览界面。HarmonyOS 中常用的系统导航有以下几种：</p><ul><li><p>虚拟三键导航</p></li><li><p>手势导航</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzE2MTQ1YjllYTY5NzAzZDBlOWI4NGQ5ZGZkNTc1NWZfRWV3YVdxdnJTYWVnRVZGYTdvSU9KY3diSTVvN2pkbFlfVG9rZW46Ym94Y25kcnpXNXBQQWF1blNENEFKWWd4SXNnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDNmZDg3ZDg4MjNjNDMyZjliNTQ2ZjIxZjgzNDQwNmJfaG5HRW5iOHB4Z055cXpaWHJCUU16M25vR1ZldERqRUlfVG9rZW46Ym94Y24zQTV5ZlR4c3hIMUJ3N2NoUGduZnNIXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="手势导航"><a href="#手势导航" class="headerlink" title="手势导航"></a>手势导航</h3><p>利用界面内手势进行导航。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjRmNGIxOGNjZTc0MmYzZTJkNGQyYjMwZmM2MTc0OTBfS0dYZ2RRUVExaFV0a3JpamdCemF0VUFkWFpkemk4RWVfVG9rZW46Ym94Y25CaFpIZE5lYjRuZXNRbjlYOVJLejNkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h2 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a>应用架构</h2><p>应用架构是一个应用对外呈现的基础结构，是系统风格的体现形式之一，除了特殊设计诉求，通常情况下，应用需要使用通用的应用架构来保持系统的一致性和用户操作的易用性。</p><h2 id="常用应用框架"><a href="#常用应用框架" class="headerlink" title="常用应用框架"></a>常用应用框架</h2><p>常用应用框架有：</p><ul><li><p>一级界面通用框架</p></li><li><p>非一级界面通用框架</p></li><li><p>子页签</p></li><li><p>编辑界面</p></li><li><p>上下结构-上方为图片</p></li><li><p>上下结构-上方为文字</p></li><li><p>侧边栏导航</p></li></ul><h3 id="一级界面通用框架"><a href="#一级界面通用框架" class="headerlink" title="一级界面通用框架"></a>一级界面通用框架</h3><p>常见结构有：</p><ul><li><p>标题栏 + 内容区 + 工具栏</p></li><li><p>标题栏 + 内容区 + 页签</p></li></ul><p>标题栏 + 内容区 + 工具栏</p><ul><li>标题栏：显示应用标题和次要操作。</li><li>内容区：显示界面内容。</li><li>工具栏：底部提供当前界面的操作时，使用工具栏。 放置用户的主要操作。（可选）</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWZjOTc4YThlNjFkMjk0MDg2OTllNGE0Yzg2ODMyMGNfT08zaHFoRnVWQ1EwWGxWc3JyUDk2VHFsdVhsNVpOTlNfVG9rZW46Ym94Y25GZXRPbkVpaGFwTERveHZrTzNqbUp4XzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>标题栏 + 内容区 + 页签</p><ul><li><p>标题栏：显示应用标题和次要操作。</p></li><li><p>内容区：显示界面内容。</p></li><li><p>底部页签：通过底部页签，用户可以快捷地访问应用的不同模块。工具栏和底部页签不能同时出现。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDcxZmVjYjYzODU4MGNlYjhlNWY4YmZhNmYwOWMyN2NfdVpnd1l6Zklaa09qU0xNWUF3Y25xdU16MmhOVWN0dTJfVG9rZW46Ym94Y243NERxYmdMZWw3a2t4OVdTVEQzSWZlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="非一级界面通用框架"><a href="#非一级界面通用框架" class="headerlink" title="非一级界面通用框架"></a>非一级界面通用框架</h3><p>带返回键的标题栏 + 内容区 + 工具栏</p><p>带返回键的标题栏：用户点击返回键，界面跳转到上一层级页面。标题栏显示应用标题和次要操作。</p><p>内容区：显示界面内容。</p><p>工具栏：底部提供当前界面的操作时，使用工具栏。 放置用户的主要操作。（可选）</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWU0NmI5N2EyNDdjZDUwNjc3Yzc1YzBlMGVlMTdmODVfbE00MkxRNWFsc3JNS3dyWkVxOTMxcUdGcUpiOTZBRndfVG9rZW46Ym94Y25HSGM0c3EyUjZ2WW16Vm95NjNBMnNlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="子页签"><a href="#子页签" class="headerlink" title="子页签"></a>子页签</h3><p>用于单个页面不同部分的内容切换。</p><p>返回键：用户点击返回键，界面跳转到上一层级页面。</p><p>标题栏：显示应用标题和次要操作。</p><p>内容区：显示界面内容。</p><p>工具栏：底部提供当前界面的操作时，使用工具栏。 放置用户的主要操作。（可选）</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmYzYjhlMWQzYWQ5YTQ0MWM1YjIwNWQxNjk3ZThlZmJfVHpHRUxoWVlJOTJXRWtWUGVIM2w4dXZOZWxVMmxkSHVfVG9rZW46Ym94Y244UjVkRXlRM2t4Q3hkME5hdHRnYnRjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjlmYTU3MzdiNWIxMzg4Yzk2YWMxMDBjYjA2YjY1NDJfc2kxNzBJTnFGUkJpZUtjazl6cjFuVzVwN1JDNnVZMndfVG9rZW46Ym94Y25ZeEZJV01sVUdYWjZFcVVZTE5uQXBjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQ1MjJmNGQ4ZTRhNTFlNzY5ZGIzNWZmYzc0ZjdhY2JfOG03c0IwazZMRmRXa0pkR0FBZHJBYU8wVmlOMWUzandfVG9rZW46Ym94Y25rWGFhY1I4VmVsTGlNQ29DeWdMTjJkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzRhOWJjNTUzOTBmZGY4OTRlZTkyMzNhN2I0YTBlYmNfNDhZT3JQaUhzaWo1cDBRQmx2MjV2VTlCc25EdnRsMWlfVG9rZW46Ym94Y25iRnZpSzJJSmVyUWdDTVRDS3paSWFkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWFhZDhkOGQzMzBmMGZlNWQxY2VmZjM3ODEzOTYwYmVfcE1vU09SRE5pdGdEN2cxZGEyaWhwWktLN1dzSFJWTFdfVG9rZW46Ym94Y25LNjFob3lFODZMdzNzNlI0NXRDWHRiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="应用中的导航结构"><a href="#应用中的导航结构" class="headerlink" title="应用中的导航结构"></a>应用中的导航结构</h3><p>导航的原则详见<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/app-navigation-0000001054723026" target="_blank" rel="noopener">“通用设计基础”&gt;“应用架构”&gt;“应用中的导航结构”</a>。</p><p>常用的应用导航：</p><ul><li><p>底部页签</p></li><li><p>侧边栏导航</p></li><li><p>返回键</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWNiNDU4N2NiOTE1Y2VmOWZkYmExZWQxOThmNDJiMzdfd05tY3F0ejY5RVZ1WXV4U2RMTTl4b3lOVlhMMVFJaTdfVG9rZW46Ym94Y255R2E2SnFkZ1B3b2lsMG5kUU1Ub2diXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTA3YzUwYTRiNTllNzczODBjOWIxMmZhMmQxMWVmMDlfZDREQUxEelozOFJna3hWcmtkTTU2OVFvdGZROTE1T3hfVG9rZW46Ym94Y240NDN0ZEp2SWtqUVRTbk82dnNIemVrXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzhjMjFmZDJlNDczYTQ0Zjk3YWY2MDZkMTJjOTFlMGVfTVFzdWlzVzlJR2p6M25yenREMVRFb1BJSWpJbmY2OE1fVG9rZW46Ym94Y245VXBwNk8zanoxOUNiUFlDakdQb3NjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h2 id="视觉风格"><a href="#视觉风格" class="headerlink" title="视觉风格"></a>视觉风格</h2><h3 id="色彩"><a href="#色彩" class="headerlink" title="色彩"></a>色彩</h3><p>HarmonyOS 在色彩体系中，根据对色彩的解读、元素的使用场景来定义系统色板以及多彩色板。保证色彩在使用场景和寓意的一致性，有利于用户在不同界面中都能准确地作出判断和选择。</p><p>针对手机的视觉风格，设计了不同的主题样式以供应用选择。</p><p>应用内，每个主题都根据具体场景定义了不同的色彩参数，便于功能区分及色彩资源管理。</p><h4 id="多彩色板"><a href="#多彩色板" class="headerlink" title="多彩色板"></a>多彩色板</h4><p>基于系统中应用的使用场景，我们定义了浅色主题、深色主题和半透明主题的三套关键色。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGE1OWNiYzI5OWVjNDFlNDJiN2E1MmM2NmIzYjMzODFfWVJLa0Z2SkZ5Vzh2aE9PSVViSVpYYUhvQ01teFYzVHFfVG9rZW46Ym94Y25ZYmRkQ3dDektUek5jcnJXN0s0dDljXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmQzM2E1YWQxN2M1ZWFiODA3YjY3MWQ1MjU0MjdjMjBfdVVxMWd6akZuQUdqcWhJd0lTckhNSVdNbUs4UGFldWhfVG9rZW46Ym94Y25LMjJTZzBIQlNDYmo2aXRURFFHUE1oXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="系统场景色使用规范"><a href="#系统场景色使用规范" class="headerlink" title="系统场景色使用规范"></a>系统场景色使用规范</h4><p>为统一系统颜色使用规范性，以及系统级换肤的一致性，系统控件按照颜色使用场景定义了一整套颜色接口。每个场景色都有对应不同主题的颜色资源（浅色主题、深色主题、半透明主题），应用使用不同的主题时，会动态引用到场景对应该主题下的具体颜色资源。</p><ul><li><p>系统色：为其他非控件场景提供的基础颜色，可配合透明度叠加使用。</p></li><li><p>控件色/图标：系统提供的图标专用场景色。</p></li><li><p>控件色/文本：系统提供的文本专用场景色。</p></li><li><p>系统蒙黑：用于辅助区分层次，弹出类场景的下层蒙黑。</p></li><li><p>系统不透明度：配合系统色或控件色使用的不透明度，不同状态对应不同的不透明度。</p></li><li><p>系统多彩色板：用于功能性分类提示作用，例如设置界面图标背板、存储数据分类等。</p></li></ul><p>注：“反色”场景适用于非纯色背景上的白色文本和图标场景，例如 banner 上的文字和图标，换肤不包含“反色”的场景。</p><h4 id="系统色"><a href="#系统色" class="headerlink" title="系统色"></a>系统色</h4><p>为其他非控件场景提供的基础颜色，可配合透明度叠加使用</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2M2ZTU1OTcxY2ZiN2RjYWUyODZlNmM4MDZhMmI5MmZfMTVoVWRyNFF4Z042ZHU3MnU3TnRIcHpQZ3lodGJzSUhfVG9rZW46Ym94Y25HczJNZFVyWVU4emRuTllQZHdwSVNnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="图标公共颜色"><a href="#图标公共颜色" class="headerlink" title="图标公共颜色"></a>图标公共颜色</h4><p>系统提供的图标专用场景色</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmI1OWFjMDgyMDQ5MzAzZGQ0YTBmZDZlYzRlM2NmMmNfZFlGWXhHTmR4N0dwQnNhRThIeVloOWhya2RYcWpEaDFfVG9rZW46Ym94Y25xRzc4MGs3THFvRGpuN04zRVJIenplXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="文本公共颜色"><a href="#文本公共颜色" class="headerlink" title="文本公共颜色"></a>文本公共颜色</h4><p>系统提供的文本专用场景色</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzI3ZmZjYTcxNTUxYjM2ZGI4YTk4MGFjM2JlOTM5ZjFfVmZPdklXNkF2ZUFlV2xoMThpc25QU3JPWERXT2VSOUlfVG9rZW46Ym94Y254MnA2bzg1d0YxZ3BjeFdjUXdOMmVkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="系统蒙黑"><a href="#系统蒙黑" class="headerlink" title="系统蒙黑"></a>系统蒙黑</h4><p>用于辅助区分层次，弹出类场景的下层蒙黑</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2U0YjEyZDgxMTcxY2YzMjBlZmFjN2ViZDNjYWE3MTlfS0hldmthUTl0RE00SHN0YVN5eTlxYkdkQlIxM1FvcjdfVG9rZW46Ym94Y25iMjg3OWZDTlRKRW12M3FyVUdXVHBoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="系统不透明度"><a href="#系统不透明度" class="headerlink" title="系统不透明度"></a>系统不透明度</h4><p>配合系统色或控件色使用的不透明度，不同状态对应不同的不透明度</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGY1ZmUxNGQ4YjUyZTI0NDg5NzgxZjFhNzRjNGQ1MTBfdmo0a0xHZXhjMXdLdW9GSHRVdE13eGhSOGlrOWxsaThfVG9rZW46Ym94Y25NaXRBZldnckpaMWxpaVBjVGhORUFjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="多彩色板-1"><a href="#多彩色板-1" class="headerlink" title="多彩色板"></a>多彩色板</h4><p>用于功能性分类提示作用，例如设置界面图标背板、存储数据分类等。</p><p><strong>1. 高饱和色板</strong></p><p>建议用于小面积、高提示性内容。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTIwMjg0YTA4MjlhZmUwNGYzNjE3YTcwYTgzYmQ5ZWNfdVZhV2lLQTU2RWJRYWhieDlQNmd5Y2kyRndkcllFV0dfVG9rZW46Ym94Y25aUUE0MENpN2lPdUtDamVRYzU3bFJjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>2. 低饱和色板</strong></p><p>建议用于小面积、低提示性内容。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQ0NzFhZjQ2YjE5MTVhY2U0NWZlNWQ0YjQzNDZhZDNfZVN3TjJycXk4Mkp6djM1ZDkwc1ZCdUk1TnhqZzk3VFpfVG9rZW46Ym94Y25lMDEzNXBBanE4N3pMWDJhSTZwcGJlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>3. 莫兰迪色板</strong></p><p>建议用于大面积背景色块。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDY0MGYzODhhNjYzNmMxNGYxMDQxMmRmZjljNTg2MTBfd1VkMmIwV1VMdmJuV0dXakQyd0VGMWIySkFGWXdXVDFfVG9rZW46Ym94Y25Qb0x2UTljcnRLdFg1N3ZxNzZGMnRnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="间隔参数"><a href="#间隔参数" class="headerlink" title="间隔参数"></a>间隔参数</h3><p>针对通用性的元素间隔进行了分类。这些公共的间隔接口后续会根据产品或新视觉风格进行统一定义。因此在设计中，针对公共的间隔，设计师需要进行特殊标注以区别普通应用自定义的间隔。</p><h4 id="间隔类型"><a href="#间隔类型" class="headerlink" title="间隔类型"></a>间隔类型</h4><ul><li><p>屏幕边缘间隔</p></li><li><p>文本间间隔</p></li><li><p>元素间间隔</p></li></ul><h4 id="屏幕边缘间隔"><a href="#屏幕边缘间隔" class="headerlink" title="屏幕边缘间隔"></a>屏幕边缘间隔</h4><p>屏幕边缘指界面元素距离屏幕左右上下的边距。可根据产品特性由软件进行系统级调整界面边距。</p><p><strong>屏幕边缘间隔类型</strong></p><p>系统定义 4 种通用窗口间隔类型。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2JjZDU1MTlhMmNkNWY4YmY2NjY2ODIwM2E1OWZmYjhfTVdqamYwRng3bzYzV2VtVjFMMGdvQXVnbW1mdkwzelNfVG9rZW46Ym94Y25RSU1MOG83OVp0WjFxa2RiemdCMTdnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>1. 屏幕左侧边距</strong></p><ul><li><p>defaultPaddingStart=12vp 用于旁边元素带热区的场景</p></li><li><p>maxPaddingStart=24vp 用于旁边元素不带热区的场景</p></li></ul><p><strong>2. 屏幕右侧边距</strong></p><ul><li><p>defaultPaddingEnd=12vp 用于旁边元素带热区的场景</p></li><li><p>maxPaddingEnd=24vp 用于旁边元素不带热区的场景</p></li></ul><p><strong>3. 屏幕顶部边距</strong></p><ul><li>defaultPaddingTop=24vp</li></ul><p><strong>4. 屏幕底部固定边距</strong></p><ul><li>defaultPaddingBottomFixed=24vp 元素距离屏幕底部边距</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDliN2U2NmExNmM4ZmRiZjE0MTQ4ODkwOGYzZGM0MGFfVndPUmxMcFlJa2ZwYUhNU3RQZk4ySktaWlBUNVJ5ckhfVG9rZW46Ym94Y253UjhtZjlZeWRoSDJXSDN4RE5xUXhlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="文本间间隔定义"><a href="#文本间间隔定义" class="headerlink" title="文本间间隔定义"></a>文本间间隔定义</h4><p>文本间间隔指界面文本之间的间隔。</p><p><strong>普通双行及以上文本中，主次文本间隔</strong></p><ul><li><p>textMarginVertical=2vp 主次文本上下间隔</p></li><li><p>textMarginHorizontal=8vp 主次文本左右间隔</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmE3YzA3MjRhMjM3OTEwYjYxNWYwMTAxNzNjMDQ1OTRfN1lsRzlIdktRTXpSaktNc2pobjN3RUJtVTB6WXd5ejNfVG9rZW46Ym94Y25oS2lzVXVvYkN3YVBXUWh5Zk5icFBjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>段落间间隔</strong></p><p>文本段落间每段文本的间隔定义</p><ul><li><p>textParagraphMarginXL=48vp 第一层级文本段落间隔</p></li><li><p>textParagrapMarginhL=24vp 第二层级文本段落间隔</p></li><li><p>textParagraphMarginM=16vp 第三层级文本段落间隔</p></li><li><p>textParagraphMarginS=8vp 第四层级文本段落间隔</p></li><li><p>textParagraphMarginXS=4vp 第五层级文本段落间隔</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDhkYjY4MmVmNGI3NDQ1NGFjZGJjMWZjMDlmZjc4Y2VfY0ZrVXFTd0xoSVlIMU9hVWJvdHk1QndHa0NSc3Y5ZnJfVG9rZW46Ym94Y245WkhSeU85b3psTElwalhvM3k3WGliXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="元素间间隔定义"><a href="#元素间间隔定义" class="headerlink" title="元素间间隔定义"></a>元素间间隔定义</h4><p>界面元素之间的间隔。这里抽取了系统中常用的几个间隔进行了定义。</p><p><strong>卡片间间隔</strong></p><ul><li>space_elements_card=12vp 卡片之间的间隔</li></ul><p><strong>一般控件间间隔</strong></p><ul><li><p>elementsMarginVerticalL=16vp 一般控件间上下方向较大间隔，一般用于有明显边界元素间间隔</p></li><li><p>elementsMarginVerticalM=8vp 一般控件间上下方向普通间隔，一般用于无明显边界元素间间隔</p></li><li><p>elementsMarginHorizontalL=16vp 一般控件间左右方向较大间隔，一般用于有明显边界元素间间隔</p></li><li><p>elementsMarginHorizontalM=8vp 一般控件间左右方向普通间隔，一般用于无明显边界元素间间隔</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGMxMmM2ZmExNmQxY2NjNzE4Y2FkZjMxYjM2MzQ2YzhfQmV6bExpb3hNb2liSnpKUmJxVzZEUE1LUVpWdkI4enZfVG9rZW46Ym94Y250OU5jVDFzZVVudmlQMm9KbjhRbUJwXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="圆角参数"><a href="#圆角参数" class="headerlink" title="圆角参数"></a>圆角参数</h3><h4 id="通用圆角场景"><a href="#通用圆角场景" class="headerlink" title="通用圆角场景"></a>通用圆角场景</h4><p>从系统层面建立参数化圆角，目前支持 5 种通用圆角大小。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjA1OWI5YmVkMzMxMDc0MmUzNmI5ZTY4YzE0NDE1YTdfUml0MmVLdWk2bm44TzRyVUt0bmlRM0pHZ2pXSXhsR0JfVG9rZW46Ym94Y25pZlV3VVFFNkhtVGV4Rjh3RkcxMkhZXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="控件圆角场景"><a href="#控件圆角场景" class="headerlink" title="控件圆角场景"></a>控件圆角场景</h4><p>控件圆角场景</p><p>不同控件会有不同的圆角大小，因此单独定义了圆角场景</p><p>无法复制加载中的内容</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="字号规范"><a href="#字号规范" class="headerlink" title="字号规范"></a>字号规范</h4><p>字号大小和粗细决定了信息的层级和主次关系。在设备上我们使用以下字号的合集为不同的控件及排版场景创造了清晰易读、层次分明的阅读体验。</p><p>HarmonyOS 采用HarmonyOS Sans作为系统默认字体，HarmonyOS Sans通过多种特征设计带来了更好的阅读体验，具体特性详见<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/font-0000001157868583" target="_blank" rel="noopener">“通用设计基础”&gt;“视觉风格”&gt;“字体”</a>。</p><p>无法复制加载中的内容</p><h4 id="字号使用实例"><a href="#字号使用实例" class="headerlink" title="字号使用实例"></a>字号使用实例</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzA3YzFiYjUxMGZjNTk2YTRjOWQ2ZDE2ZmJmM2Q3MWFfY1ZOUkRtVGxwbjlaR0VRSG1EU2FtYTlCZzhnNWE2QWlfVG9rZW46Ym94Y25qMkdNS3FlZXBTWkE5WDJtMzBKWlB0XzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><ol><li>显示效果</li><li>字号层级</li><li>实际字号大小</li></ol><h3 id="插画"><a href="#插画" class="headerlink" title="插画"></a>插画</h3><p>比起文字，插画可以用来表达更丰富的信息，通过视觉图像满足用户情感诉求的同时，更起到增强视觉冲击力和趣味性的作用。</p><p>HarmonyOS 插画是友好的、令人愉悦的，容易被理解的。包含场景型和功能型两种类型。主要使用在以下场景：帮助引导页、启动页和欢迎页。</p><p>插画的使用规则，详见<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/illustration-0000001111048116" target="_blank" rel="noopener">“通用设计基础”&gt;“视觉风格”&gt;“插画”</a>。</p><h4 id="布局规则"><a href="#布局规则" class="headerlink" title="布局规则"></a>布局规则</h4><p><strong>插画资源大小计算</strong></p><p>将屏幕一分为二后获取到较短的一边为短边；</p><p>插画资源大小用 短边x0.8 来计算适配。 （1:1 和 3:2 均适用）</p><p>插画内容大小建议用 短边x0.7左右 来计算。（允许出血，允许根据插画画面效果自定义）</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGNhYjhlYzJhOGVhNTNkM2NjYmYzN2VmM2M2MjYwMmRfNlBqSHBmMnhIdTl5WVFuNkI3Wm1KRlZmUVB5cGZDS2xfVG9rZW46Ym94Y25VRHBNOElCVmk2NVlyWUFlakwyRnNkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>插画资源显示位置</strong></p><p>无论是否有标题栏，资源从标题栏下方开始布局。</p><p>标题距离插画资源 24vp，正文距离标题 8vp。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWJhNzJmNzkyNzJhM2I1NGVlNDczNDIwOTRmMDgyNjNfU3czOURVTkVOVWRaMGl0MXJZZGlycDEweEdCWUZjMVBfVG9rZW46Ym94Y24xVXFJZlM2M3RoblFWNGk3eklhRWJkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>弹出框中的插画</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzk5MDg0MTRhNTE5Y2IyOGM0YjI2MzgxZGNjODNmMDBfZE9SbHZpS2xhRzlKU2ZNakwwNmdGNlpyUEtxOENiR29fVG9rZW46Ym94Y25uU0N3YzJxUW5RRUhwMkk4SlNncDViXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>1:1 资源 和 3:2 资源</p><h4 id="多设备布局适配"><a href="#多设备布局适配" class="headerlink" title="多设备布局适配"></a>多设备布局适配</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmI0ZTBkMzY4NTAxNDI5MzhmMWYyMWZlZWM4MzE1MWJfWERFYjRzNWlWMWlRc2pPcWo0ZVhyYmtYVm9rVUtUdWNfVG9rZW46Ym94Y25uSUl2c2Z3Q0pWbWtveGZGUkRFYlhlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>手机竖屏</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGE2MDVmZDhmMmMwYzk2MTAwOTY1OTdmZmM4ODQ1YjZfMjJjT1Fsc3NxTkdibFRSSWJ1dWZmMThlaFFERUR2czVfVG9rZW46Ym94Y254VEw5VjBZSVBSdWlBeVVJRWF0b0tkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>手机横屏</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWNkMDg5MmJiZjNmNDA2NDQ2YzQxOTI1MzY0OTk1MjVfdWlRZEpVUFFJWUNZQ1JWVDdEME0yS0hDVXhiMExzWkhfVG9rZW46Ym94Y25IV29UdzIwbk1QRzB4c3c0MjhyUUFkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>平板横屏</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmVmMjI4OTMwNGI4YjA0OTk4MGRjMDA0ZDk4NTcyZWRfZUZYUndhSFZ6T2p1MU83MU1IWHZXUFJkTXJselBQYkZfVG9rZW46Ym94Y25rWVRWWml3cmFzeDdFaTdaVkFZVm1iXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>平板竖屏</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWJjNGJmN2UzY2NiZjg5MTFlY2Q2ODJlNjU1YTUxMTRfYXNhTGtsS3JiNFR4VEpyRG4zVnd4T1QwbDRSM0RoSGhfVG9rZW46Ym94Y25BWUc2Y3JkVTZ6QW5FZHBMbW00WlJmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="系统图标"><a href="#系统图标" class="headerlink" title="系统图标"></a>系统图标</h3><p>系统图标主要用于功能性引导、系统导航、栏目聚合以及状态指示。</p><h4 id="图标样式"><a href="#图标样式" class="headerlink" title="图标样式"></a>图标样式</h4><p>在手机设备中，系统图标根据不同场景使用描边图形与填充图形两种样式，两种样式使用同一结构图形，使他们具有一致性的视觉体验。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDlkNjI1YjkxYWRkM2M2YjhkZmY5NTc4MWQ3NzlhZTZfZG1iRzczSU16YThnUjNuUjlQSzBvaXJHRjN4WHhiMzlfVG9rZW46Ym94Y251Slp3OER4ZWhPNEhxT09tUUNqOXdmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="图形大小布局"><a href="#图形大小布局" class="headerlink" title="图形大小布局"></a>图形大小布局</h4><p>在界面中，图标根据不同的场景会用不同的大小呈现。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2M5ZTc4ZWMzNDcxMGU2N2YyYWJkZjE1OGRiM2E3MTJfUkRqd1o4eXpLdlF1cDhHVThUUGEzdmFjRXdUbTlFbzBfVG9rZW46Ym94Y25rYjZIem15SjFmaTFXMFk1UnFabGdiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="阴影特性"><a href="#阴影特性" class="headerlink" title="阴影特性"></a>阴影特性</h3><p>通过不同的阴影效果，呈现信息层级的视觉空间关系。</p><h4 id="信息层级规则"><a href="#信息层级规则" class="headerlink" title="信息层级规则"></a>信息层级规则</h4><p>我们将信息层级分为了<strong>应用内层级</strong>和<strong>应用间层级</strong>。</p><ul><li><p><strong>应用内层级</strong>为单个应用内所呈现的信息内容，例如应用内的卡片、即时反馈、气泡提示等。</p></li><li><p><strong>应用间层级</strong>表示跨应用的信息之间产生层叠，例如悬浮窗口、悬浮球、横幅通知等。</p></li></ul><p>如下图所示，不同的信息之间是有显示优先级层级的，不同层级的信息空间高度不同，所以阴影也不一样。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGJhNGM0YzYyZGM4ODc5ZmIxOTc5ZTMwNjg3YWNmZTlfMFZyeTVUeGgyWWZYVHQ2TzBmMlc2T0NMODd5OHIybXFfVG9rZW46Ym94Y25NWFJpYURYRURLMDgzdlhtZjl0UlFlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="系统通用阴影接口"><a href="#系统通用阴影接口" class="headerlink" title="系统通用阴影接口"></a>系统通用阴影接口</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzUzMGI3OGEyMjQxZjZjZjVjYmVhZmY0NWY1NDQwYzVfUm9Pd0JlTlVnTXQ4c2hwQVFmU1BnTTVXWXRkcGVMN2NfVG9rZW46Ym94Y24zenNITWlSSzB3OGhUUmN2czJ6bnloXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDM0OGJiZjYyMTkxNDUyMGIzNmQ4YmRjMTI1MTc5YWRfMXVJeUdkcWJoc0VDS2pUUWlyWTMzVndZWWczOUp5YUtfVG9rZW46Ym94Y25qV3BZbmhLc0FQR2p6bWtxak5TRjBnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><h4 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h4><p>HarmonyOS 针对设备设计效果的需要，定义了2种类型的栅格系统的规格。</p><p>更多布局信息详见<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/layout-0000001111593946" target="_blank" rel="noopener">“通用设计基础”&gt;“视觉风格”&gt;“布局”</a>。</p><h5 id="基础栅格"><a href="#基础栅格" class="headerlink" title="基础栅格"></a>基础栅格</h5><p>常规的应用都可以使用基础栅格为你的内容进行大小和位置的布局。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjY3ODhhMmExNzdlZTMzM2U4YmM1MWFjMDE2YTQxYmJfVzdUOXRscm81a0hrWWQyYVJQMTBZNE1aRTZNYjZONFJfVG9rZW46Ym94Y25QUGgwSUh0WndHT0dnTVFlNDRha2doXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>基础栅格参数：margin=24vp，gutter=24vp</p><h5 id="基础栅格布局实例"><a href="#基础栅格布局实例" class="headerlink" title="基础栅格布局实例"></a>基础栅格布局实例</h5><p>使用重复布局时，内容对齐栅格。8 个 columns 时列表内容重复 1 次，12 栅格时列表内容重复 2 次。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGM2YTg5ZWIyZjFiYjJiNjc2ZDQxZmNhMzRiNDQ5YzBfcXBhMU9ndFZrWURFYm9WUTU3cExnMklVbnJ5S2dObkdfVG9rZW46Ym94Y256bXFQYVRVOVh0aVhTdzFLY3Z4Q1ZlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="卡片栅格"><a href="#卡片栅格" class="headerlink" title="卡片栅格"></a>卡片栅格</h4><p>应用内使用卡片化设计（例如通知卡片、卡片信息流等）时需要使用卡片栅格进行布局。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWRhYzZiYTZiMzkwYjY4NjI5ZWI2ZjY1NzQ3MzYyNjhfdEM4ZEpGWmdFSVVNUXhuYWd5SmMwQ3VobzZLd1R2eGZfVG9rZW46Ym94Y25Fa3o5b2xRblZrUVNsM3JkeHBXaDBlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>基础栅格参数：margin=12vp，gutter=12vp</p><h5 id="卡片栅格布局实例"><a href="#卡片栅格布局实例" class="headerlink" title="卡片栅格布局实例"></a>卡片栅格布局实例</h5><p>使用卡片栅格进行缩进布局时，4 个 columns 时卡片占 4 个 columns，8 个 columns 时卡片占 6 个 columns，12 个 columns 时卡片占 8 个 columns。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzUxMzFjOWQyZGNmNDI4ODk3MTdjNzEzNDRiYmZhYjJfdFBrMGJKWnk4b2FtYnIzd0gxN2M2dE9VSjhuZHA0OWlfVG9rZW46Ym94Y25Iak9FUEQ5UXNEY3k4TXZzdTJQN1BLXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="挖孔屏布局"><a href="#挖孔屏布局" class="headerlink" title="挖孔屏布局"></a>挖孔屏布局</h4><p>由于不同设备下挖孔的大小和位置不同，界面布局需要规避内容被挖孔遮挡。</p><h5 id="挖孔屏通用布局"><a href="#挖孔屏通用布局" class="headerlink" title="挖孔屏通用布局"></a>挖孔屏通用布局</h5><p>挖孔屏横屏的通用布局，控件需要预留空间背景允许延伸至挖孔区域，保证视觉上的屏占比最大。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjFkZmE2ZWIyYzIyODUzNGY2OWQ3NmE2NjAwZGNiODVfbUpyTlVpeXJNNkltZEFVMFJYYjV1dXpZREQ5VHJnbGNfVG9rZW46Ym94Y25nQjdoeXcydFU5Q2Q4NU5IOFU3WVBiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="挖孔屏横屏延伸布局"><a href="#挖孔屏横屏延伸布局" class="headerlink" title="挖孔屏横屏延伸布局"></a>挖孔屏横屏延伸布局</h5><p>如果应用在横屏界面可以内容左右滑动，需要允许内容在滚动或者 270 度横屏时延伸到挖孔区域。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzE3NGIxN2Y1MDc5YmM0YmI1NjU3MWE2NTNiYzkyZDZfc2lnSnhYYWxRTmoydjZyaVVTWVZrWjJDSFFYMzducXVfVG9rZW46Ym94Y25ZT0hRbU5HTjRrYXZwT25Ub2RqSWFiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h2 id="触觉"><a href="#触觉" class="headerlink" title="触觉"></a>触觉</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>触觉是感知物理世界的自然的交互方式之一。触觉体验设计（Haptic Experience Design, HaXD）是指将交互技术与一种或多种感知的触觉联系在一起的用户体验的设计。</p><p>触觉体验可以增强用户与屏幕界面交互的体验。例如在选择器中滚动的精准交互振动。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGY2ZTNlNTI2ZGNiY2MxNDMzODMyMjUwYjNmNzE1ZDRfTmlqUnN3UmswU3hpRWR4OGp5WjJBRDJ5WVRqNW5vaE9fVG9rZW46Ym94Y25JNEt6NmpYdzlBYXdXcU9ZVDZoTERnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h4><p>触觉振动目前分为三类：交互类、通知类、沉浸类。</p><p>无法复制加载中的内容</p><h4 id="多感官设计"><a href="#多感官设计" class="headerlink" title="多感官设计"></a>多感官设计</h4><p>针对三类触觉体验场景，进行差异化多感官协同设计。</p><ul><li><p>交互类：侧重触觉振动与视觉动效的匹配协同。</p></li><li><p>通知类：侧重触觉振动与声音的匹配协同。</p></li><li><p>沉浸类：通过视听触三感协同，模拟真实交互，侧重三维沉浸体验。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGQ0MTU3N2U5MTM2Y2VkODllZWY2ODBjNThjMTM4NTlfRE1aSVYxcVVHc2xyUnNCZWZteGhHb2dMNjN2aFRrSnRfVG9rZW46Ym94Y241VFhoYjRsR2tJdG5kWjA1bzFHa0JoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="交互类"><a href="#交互类" class="headerlink" title="交互类"></a>交互类</h3><p>交互类触觉反馈，是为了增强时间空间感知，提高交互效率。</p><h4 id="交互类场景规则"><a href="#交互类场景规则" class="headerlink" title="交互类场景规则"></a>交互类场景规则</h4><p>通用限制规则：</p><p>第一原则：不要过度使用振动反馈。</p><p>第二原则：振动反馈都能被用户理解。</p><p>当振动反馈同时具有以上两种类别属性时，按系统事件反馈。（因为可以提供更多的信息量）。</p><p>无法复制加载中的内容</p><h4 id="舒适触觉设计"><a href="#舒适触觉设计" class="headerlink" title="舒适触觉设计"></a>舒适触觉设计</h4><p>基于用户不同操作（点击、滑动、滑动悬停、长按），分别定义舒适触感，进行差异化设计。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGUyOTEyMzY4NWQyZjhlYTE1NDZkZGNkYjVmZDMxMWNfR1M1MTB2OU4yNzJMRUNKcUtQazhvN2VyMkJUdmNLclJfVG9rZW46Ym94Y25tMGNlTnl5VHRwMU54SDJUek5iVlBiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="协同反馈设计"><a href="#协同反馈设计" class="headerlink" title="协同反馈设计"></a>协同反馈设计</h4><p>输入法点击场景下，为保证用户操作的高效和感知同步性，反馈时延需满足以下标准：</p><ul><li>及时性（用户对触感容忍性低于音效）按压时间→触觉反馈时间：&lt;47ms</li></ul><p>按压时间→音效反馈时间：&lt;123ms</p><ul><li>同步性</li></ul><p>触觉反馈时间→音效反馈时间：&lt;89ms</p><h3 id="通知类"><a href="#通知类" class="headerlink" title="通知类"></a>通知类</h3><p>增强来电等通知场景的提示性，吸引用户注意。同时提升舒适性，保证用户的愉悦体验。</p><p>典型场景包括来电、通知消息、闹钟等。</p><h4 id="随铃声振动"><a href="#随铃声振动" class="headerlink" title="随铃声振动"></a>随铃声振动</h4><p>在来电场景中，结合铃声的节奏旋律，对振动持续时间和强度做匹配设计，铃声响起的同时会充分融合振动；在闹铃的设计中，结合舒适化的旋律进行相对舒缓的振动节奏匹配，在匹配了整体的旋律节奏的同时，尽量简化密集性的打扰。</p><p>随铃声振动，为保证同步性，振动与铃声的节拍时间应满足同步性标准：以铃声节拍为 0 点，振动起点的时间范围为-46~23ms。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzhkMTRkZDRhNmQ4MmQ3YTc3MTQ3ZGFiMDY1ZmU5ODNfbmpCV1BZNXRsampkSkFwR1QzcVBNZTFKeWdqZUZtM3lfVG9rZW46Ym94Y253cDJFaHl3S0VnVThKcTFTSjR4WjNnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="固定节奏振动"><a href="#固定节奏振动" class="headerlink" title="固定节奏振动"></a>固定节奏振动</h4><p>考虑到不同的反馈需求，我们设计了 8 种固定的振动节奏型来满足你的不同场景的需求。</p><p>8种固定节奏振动在设计时，除了字面上的拟物化表达以外，它还包含了不同的节奏紧要的考虑，同时还保留了用户已有的使用习惯。 例如经典的“标准”类型是大家熟知的，“闪烁”的单次振动，在模拟了闪动的同时，加上一定的时间间隔，紧要程度相对较缓，而“滴答”、“舞步”、“敲门”、“啄木鸟”会逐渐上升紧要的程度，可供大家对不同的通知情况进行定制。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjYxOGZlYTZhMzljN2Y3NTYzNjZhNTY1YWI0ODA2NjJfQlNUWUVYaWJOUXQ1dFh1S0NnRE9hZms3c2w0eTRxdEpfVG9rZW46Ym94Y25wMUYwUkhMdnh3blI0MkJCUDhUaVpiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="沉浸类"><a href="#沉浸类" class="headerlink" title="沉浸类"></a>沉浸类</h3><p>通过将触觉与音效、视觉动画效果协同关联，在特定场景下，增强视听触一体化的沉浸体验。</p><p>典型场景包括仿真机械键盘、Soundji 表情包等。</p><h4 id="仿真机械键盘"><a href="#仿真机械键盘" class="headerlink" title="仿真机械键盘"></a>仿真机械键盘</h4><p>对于X轴马达产品，通过触觉反馈模仿机械键盘的键程感。</p><p>在机械键盘中，我们结合不同的真实键盘的反馈效果进行了大量的调试，营造真实的触感反馈。通过界面视觉、触觉反馈与仿真音效的结合，增强用户使用机械键盘的真实感。用户还可以进行个性化振感强度和音效强度设置。</p><p>真实机械键盘通过运动过程中的卡扣阻拦滑杆运动，形成阻尼，让用户按压键盘时有清晰的力反馈。</p><p>因此，通过触觉波形设计，加上视觉效果、音效，模拟机械键盘的真实感。</p><h4 id="Soundji"><a href="#Soundji" class="headerlink" title="Soundji"></a>Soundji</h4><p>在畅连表情中，通过触觉增强表情包的情感以及语义信息。</p><p>我们通过结合拟物化的视觉动效以及拟物化声音的设计，分析不同声音节奏与强度，视觉的变化节点；设计不同的振动序列时长以及节奏甚至是强度变化</p><h2 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzhkZDI3ZTA2Yjg3OTdmZDhmMjQ1M2Q2ZThkMWY0NGJfZ3JGSFhtY3ZDZDRVWVB0QTVsQTJRUWtiM21MUkdmWmZfVG9rZW46Ym94Y25YdXd1NEhSNWNNVHVOWTQ3bWxDUmxiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmE2ODAxNmY2NDM3NzFmNDE1YWVkMWZiYzc0MjAxZjNfZWgzb3poa0ZTZGx2OU1OODdaeVVhNEY2M0Y5V0JTbU5fVG9rZW46Ym94Y25MVERlZ1pZUWM2ZzcwRGxEanVob0ZiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzZkY2U2MjZiNTkyMWZlNjUyODM4NTk1ODRlMGY5MGRfc0JNcGNXTWpZaWZZTHlrczZtYk1VT1p6MFo1UHVDbUpfVG9rZW46Ym94Y25XU2tJYTJQUkd2YzRpWGg5MnVGaUhoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGUzYzUyOTFhZjczNGIwZDVlYTUyNDgxOTAyYTMzNjJfN0hNSDB2cFE2amx2SUI2RlgxM0NGTkFqNTNSNUY1WDNfVG9rZW46Ym94Y251T240b2pSMmw0SFZoVFdrdE1nUVVRXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="标题栏"><a href="#标题栏" class="headerlink" title="标题栏"></a>标题栏</h3><p>标题栏放在界面顶部，用于呈现界面名称和操作入口。在大部分情况下，标题栏左侧显示一个文本标题，以帮助用户理解当前看的是什么界面。在二级界面，文本标题左侧还需要提供一个返回按钮，用于指示当前界面的层级，用户点击返回按钮，可以返回到上一个层级界面。标题栏右侧还可以放置常用操作的图标，用户点击执行对应的操作。所有常规设计界面都需要提供标题栏。在沉浸式界面，可以考虑不显示标题栏。</p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ul><li><p>一级界面标题栏</p></li><li><p>非一级界面标题栏</p></li><li><p>编辑／选择界面标题栏</p></li></ul><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><h5 id="一级界面标题栏"><a href="#一级界面标题栏" class="headerlink" title="一级界面标题栏"></a>一级界面标题栏</h5><p>分为普通标题栏和强调型标题栏。</p><ul><li><p>普通标题栏用于不需要突出标题的场景，一般用于工具界面或内容型界面，例如闹钟、音乐等。这类应用，更加突出功能或内容的显示，因此不需要突出标题。</p></li><li><p>强调型标题栏用于需要突出标题的场景，一般用于效率型应用界面的一级界面。例如联系人、设置等。这类应用，需要体现操作效率，因此默认会让整个页面下沉，方便用户单手操作。</p></li></ul><p><strong>普通标题栏</strong></p><p>支持单行标题、子页签型标题两种样式。</p><p>子页签型标题用于切换页面的内容，只支持在一级界面中使用。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGYyMmViNzZmOTc4YTAyM2RiYmYzODdlMzJkYjBmY2ZfakFyOG0zaUFOc3hSc2pmZjJyYUFhMkdXVHBvOVBTQU9fVG9rZW46Ym94Y25vUU1HRGFhUjFLcU1wa2V4a3l1VEhoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>强调型标题栏</strong></p><p>支持显示单行标题、双行标题以及下拉菜单型标题样式。</p><p>双行标题的第二行标题用于显示一些辅助信息。</p><p>下拉菜单型标题，用来切换页面内容的展示。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDQ1NjRjZDlmYjg4YmEzMTBlZTJhOGUyYzdhYWE1MjVfN1NrNGhNblRXcTdtUlBlOXdSYnZvOUxmMEJYeGNHajBfVG9rZW46Ym94Y25ETGNJNGNxdWllN3RaVDZTM3c5VnhiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="非一级界面标题栏"><a href="#非一级界面标题栏" class="headerlink" title="非一级界面标题栏"></a>非一级界面标题栏</h5><ul><li><p>非一级界面的标题是界面的名称。非一级界面标题的左侧需要显示“返回”图标，用于指示用户可以回到上一个视图或层级。</p></li><li><p>双行标题中的第二行标题，用于对第一行标题进行辅助说明。</p></li><li><p>【不推荐】当需要有多个视图可以切换，但除默认视图外其他视图极少使用时，可以使用下拉菜单型标题。这种做法会导致下拉菜单型标题里面的内容被隐藏，降低用户的使用，因此不推荐使用。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGYzMjBhZmNlYjU0M2Q1YzQzYzAxMTBkZTc0MGZhOTVfWWVKejY1MW53RUhRVUpJR20yNXRGSlBNOGNhbmFkMUxfVG9rZW46Ym94Y24wU0kwMGJGRzRTVDFVQ0hSdjczNHhiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzZjN2M4NTUwNTdiZDg5YTZkZjE0ZDhiMTRkY2RkNGRfTU9mdE9YdU1iQk52b0lES0VyY2V4VlZ1bFRyOEpWblpfVG9rZW46Ym94Y25ldmJOd1hnS3JWOW1tRzlwWkxlQnloXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="通用元素构成"><a href="#通用元素构成" class="headerlink" title="通用元素构成"></a>通用元素构成</h4><p>标题栏一般由左侧图标、标题、右侧功能图标组成。标题栏的元素构成分为左右两部分。</p><p>无法复制加载中的内容</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTRlYjg3MzdjNDNiNTFmM2I3ZWU3ZTQ2OWU0NzUxZGJfVVlVdTgwUGhaWjY3MkZvSzhJSjVreVVCZG1aQUpLNzlfVG9rZW46Ym94Y245TVlhYmVCc2FTYUZnTUhJckFEQ0tiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzBhNTdjNDEyMThlNzI1ZDQzMWM1YTc1ZmY2NzE3ODVfRXg3bTNLcFh6cnBzd1prbzlrVXdIVjBUS0FLTjZyUUVfVG9rZW46Ym94Y25BSFU3STV6Q3JHdVBYbmxPV3JMQzZiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="交互规则"><a href="#交互规则" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="滚动操作"><a href="#滚动操作" class="headerlink" title="滚动操作"></a>滚动操作</h5><p>在内容区滚动时，顶部标题栏可固定在界面顶部，或变化标题栏（隐藏/缩小）。提供隐藏标题栏可以带来沉浸式体验。</p><p><strong>标题栏固定在顶部</strong></p><p>内容区往上或往下滚动时，顶部标题栏不隐藏。</p><p><strong>标题栏上滑缩小</strong></p><p>内容区域滚动时，强调型标题栏可缩小成普通型标题栏</p><p>单行标题：一级界面，内容区向上滚动时，标题随着内容向上滚动，标题字体缩小。向下滚动恢复至原大小。</p><p>双行标题：在顶部标题栏缩小高度情况下，标题随着内容向上滚动而缩小（子标题的大小不变、淡出）。向下滚动内容到顶时则恢复原样。</p><h5 id="滑动操作"><a href="#滑动操作" class="headerlink" title="滑动操作"></a>滑动操作</h5><p>带有子页签的标题栏支持通过滑动切换页签；</p><p>获焦放大的页签位置，需要判断最后一个页签是否在一屏的界面内显示完整来确定位置；</p><h4 id="视觉规则"><a href="#视觉规则" class="headerlink" title="视觉规则"></a>视觉规则</h4><h5 id="主题样式"><a href="#主题样式" class="headerlink" title="主题样式"></a>主题样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGIwNzE4ZDYyNzNiOWExZWYwZjI2YzdmMzRjN2QxNThfeGFRWXZNUFhtSnJYaVpCTWtBbHdHeEFHTmwwTXBHeGxfVG9rZW46Ym94Y245T3plTUFVanZYSHM2YWxHUjJHMEIxXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTQ0OWE4Mjc3YzA4ZGNkODE3NjdlYzQ5MWIyMmMwN2RfbkZSbVVTaXFodUlCNDg1aEU2SVNOR3RqV3ZEeFdVR2lfVG9rZW46Ym94Y253WGhuTWExNk1BTzRDekJSN1g3eHliXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWI4MDg1MmY0ODYyNTZmMjI4MGUzMDA0NjIxZmZlMTdfZFdWSXR1RURFZmQ4RTFKUGtLSDR5aDR3d0ZTMjk1NnFfVG9rZW46Ym94Y243YUkzQUsxY2FNUFdTWUV1UHBoVVBoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明度主题</p><h4 id="布局样式"><a href="#布局样式" class="headerlink" title="布局样式"></a>布局样式</h4><p>横屏</p><ul><li><p>标题栏布局与竖屏一致，右侧图标为竖屏下工具栏+标题栏上所有功能图标的集合。</p></li><li><p>手机端除Launcher应用，状态栏默认不显示，标题栏紧贴屏幕开始显示，高度为 56vp。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDNlYzVjNjRmZmM5NjAyOTMxMjIxNDQwNjNmNmQ1YWJfNUY5QzZUekZ3OE9HeU1EMlJPMkhuSzdoVloxb2FmemhfVG9rZW46Ym94Y25Vb3RocmlvNTQ4a1d3QzhTV1ZkNWpmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>平板</p><ul><li><p>支持普通标题栏。</p></li><li><p>支持强调型标题栏。</p></li><li><p>规则与手机一致。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2I1YjcxNTQ1ZWM1YmJhMGYwNzI2NzQ1MzQ0ZjU3N2FfSEpYV1NwaXF0bXhORVREVnhKSUI3S2lpOHZVRU9UNEdfVG9rZW46Ym94Y24xTHkxb01RYUJ5dTYwdnAyZjlYazFjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>平板效果</p><h4 id="界面写作规则"><a href="#界面写作规则" class="headerlink" title="界面写作规则"></a>界面写作规则</h4><ul><li><p>标题简洁明了。</p></li><li><p>标题和进入该页面的上一级界面的功能选项名称保持一致。</p></li><li><p>无标点，以名词短语为主</p></li></ul><h3 id="步骤导航器"><a href="#步骤导航器" class="headerlink" title="步骤导航器"></a>步骤导航器</h3><p>完成一个任务需要多个步骤时，使用步骤导航器线型展示当前进展。通过使用步骤导航器，可以将复杂的任务分解成多个合理的步骤，每个步骤都会聚焦一个特定的小任务，小任务都会有一个清晰的名称，通过页面标题来呈现。完成这个小任务后，就跳转到下一个步骤，直到任务结束。设计步骤导航器的时候，要确保每个小任务都清晰易懂，保持界面布局一致性，从而提高用户的完成率。</p><h4 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>操作按钮为了不遮挡内容固定在底部显示。</p></li><li><p>显示输入键盘时，步骤导航按钮固定在输入键盘上方显示。</p></li><li><p>底部操作区采用“文本按钮 + 箭头”形式。</p><ul><li>针对左侧文本：点击文本按钮，如果无法返回到上一界面，那么该文本按钮左侧不加箭头。</li></ul></li><li><p>针对右侧文本：点击文本按钮出现的界面，如果无法返回到上一界面，那么该文本按钮右侧不加箭头。例如“跳过”，“开始”。</p></li><li><p>在步骤导航流程中，如果某个操作耗时，请在操作的地方进行等待反馈，例如使用<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/button-0000001156786989#ZH-CN_TOPIC_0000001156786989__section135mcpsimp" target="_blank" rel="noopener">等待按钮</a>，尽量不要弹出一个等待弹出框。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDkzOGQ1YTg4NWIzN2NmOGFiMzg4MGY2YjEzMGM3M2ZfajBIQWVPcXBsdEdnTEQ3UWw2VDNnSXVvdFFjSkRjRXVfVG9rZW46Ym94Y25pNXJLSHNSSEF5aGozRXFqSUJmckVjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="交互规则-1"><a href="#交互规则-1" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h5><p>点击“上一步”，返回到上一个界面。点击“下一步”，前进到下一个界面。点击其他按钮，执行对应的操作。如果按钮灰显，点击无响应。</p><h4 id="视觉规则-1"><a href="#视觉规则-1" class="headerlink" title="视觉规则"></a>视觉规则</h4><h5 id="主题样式-1"><a href="#主题样式-1" class="headerlink" title="主题样式"></a>主题样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDliMjJkNmM3YjdmMmVjNTg4NmUwMzZhODdmYjhhYWRfcHpra0IyT1ZSNEdQVERXaGVlUTRVQUNxNHkzVXlwNHVfVG9rZW46Ym94Y254bzg1MG91U3NzVHJSdmxEQWFDOEhnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2U0NWYyY2VmNWMwNTgwZDdkZDFmM2YyNWJkYTE2YThfc3NpcmNXN2pvaldTVzBUSnROUmU4Z1FkbHVjYTdIUk1fVG9rZW46Ym94Y25LblBSTDQ3QzJKRk5iUWNoTmE4Z2xkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDU5YzgxMTgwMzJjMGMyYzQxZDlhNDQxODg5YjYzNWFfcHhSdGRvOXNFWmZZQzlhZFBQc3hnc1RxTldUeVd6VTNfVG9rZW46Ym94Y25VOXlRbHR0bFNvR3dGMndhbWNEZnNjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><h5 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h5><p>同竖屏规则。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGEwZGM4YzM3OTg5ZjVhNmVjMTgyN2ViZGI1ZDllYjNfb0tLVEU5T1Y5S0lPb2RnUnkzV3FlMXhCaGdkN3owUFNfVG9rZW46Ym94Y24wM1RTTFlnS3BxVWxZSGNGTVJsWnhmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-container-stepper-0000001060518078" target="_blank" rel="noopener">stepper</a> (JS)</p><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>按钮是一种点击可触发对应操作的控件，在系统中的使用场景较多，常见的有：弹出框、窗口、卡片等。</p><p>它的状态必须清晰，让用户能明确知道是可被点击的。</p><h4 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h4><ul><li><p>强调按钮</p></li><li><p>普通按钮</p></li><li><p>文本按钮</p></li></ul><h4 id="如何使用-2"><a href="#如何使用-2" class="headerlink" title="如何使用"></a>如何使用</h4><p>视按钮重要程度来选择按钮类型。按钮重要程度从高到低依次为： 强调按钮&gt;普通按钮&gt;文本按钮。</p><p>强调按钮用来显示重要的操作，普通按钮用来显示一般重要的操作，文本按钮用来显示常规的操作。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2I4MThmMDYxMDdiOTgzNzI0MjFiOTI5OGQzYWYwMDlfeER5T0sxOFpNczNVdW9qRjN0dlZacEJRc3hLamxyYXlfVG9rZW46Ym94Y25xZmx0c0JFWGNTUjdxeXQxcmp1a0VoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="强调按钮"><a href="#强调按钮" class="headerlink" title="强调按钮"></a>强调按钮</h4><p>在界面上很突出，用于强调当前的重要操作。</p><p>典型使用场景：支付、订阅、安装等。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzkyYmU3OWJhZWY5MTRhMmRlN2UyYzE2NjFlZTk3NjRfSWRwUElaZlp4T2FieWVwc1VSZFdIbXVFSWlkamFPam1fVG9rZW46Ym94Y25KOUNDRnVZQTFodHVRdkRld1VjNXplXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGFiOGU4YTc0ZGUxMjVhYzkyOTEwOGNlNzBiZTI5ZGRfNVF2c0tFQmhKU3JJZngyVkRyeTNPak94YVpJOEpPZ1hfVG9rZW46Ym94Y25DYUFYWUJRWWUzY25DY2pnZXh4UnpoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="普通按钮"><a href="#普通按钮" class="headerlink" title="普通按钮"></a>普通按钮</h4><p>在界面中，用于显示一般重要的操作。</p><p>典型使用场景：应用下载、系统更新等。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjRjYjAxN2VmYmVhMDg3YTM3OWJhYThlZTRhZjBhYThfNFB6VnB0ck14THVENmNkaGhMalZPZXZhV1B0TWFIUjZfVG9rZW46Ym94Y25ETTBWS3JIMURlcWozaUl4eGxNYUlkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmI4NzI4NmQ4NmFmZGRlOTk0YjQxMTAyODQxZDAwNmFfNExXcTVCVnU1SWNaalB1RDc0WjRqOTdJSUZ0RzBEUjlfVG9rZW46Ym94Y251Z08wV3RuZFJCR3R4OGJOUGtSZkVrXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="文本按钮"><a href="#文本按钮" class="headerlink" title="文本按钮"></a>文本按钮</h4><p>纯文本的形式，可最大限度减少按钮对内容的干扰。</p><p>典型使用场景：弹窗信息、步骤导航器等页面一般信息的确认。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTJiZjRiZTBkNmRkZjk1YmMxNzY0YWM5YmYwNzU2MzlfU0tBRkR4aUdCTkNQN1FQVDVGbGhMYTZKNzJNS0o4WnpfVG9rZW46Ym94Y25ReDk4UmVROUd0QjdwWnJKWnVvcWgzXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmFlNTc5OGZiY2Q0ZjVmYmY4ZThlNTIxZmEyMTBjZDFfbzdFVXkzejljVHZkUHVDUTU0aXVPV1VMTTN2NEJNMGpfVG9rZW46Ym94Y25tUjNOOHhrT1FSeEZTRUVMNzFMM05iXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="按钮的等待状态"><a href="#按钮的等待状态" class="headerlink" title="按钮的等待状态"></a>按钮的等待状态</h4><p>等待状态用于表达正在执行或加载的过程，操作执行完成或加载完成，则进入下一界面。</p><p>强调按钮、普通按钮和文本按钮都可以使用等待状态。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDVmMGEyNDk5MjQ5ZmZhYTRhM2ViNGFjYjM1NjkwZGFfY2xDT2RhOGw1UXdmRldYZUxuWXR4Z2xpRVFrbUhpSjZfVG9rZW46Ym94Y25mdzZtMG5PdlVlWkZ6TnRkdVRnckJlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>等待状态有两种：</p><p>1.带文字的等待按钮，适用于长按钮</p><p>2.不带文字的等待按钮，适用于短按钮、步骤导航器</p><p>以下场景可用等待状态按钮替换正在加载的弹出框</p><ul><li><p>在加载极快的情况下，出现的闪现情况。</p></li><li><p>多个连续跳转的情况下，用加载按钮减少复杂度。</p></li></ul><p>禁止双加载场景（即按钮处于加载态的同时再出现加载弹出框）</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjY5NGI4NzYyN2ViNDVmNTBlMWVhMzEzMWJiYjcxM2VfWFplcHl4bzV3NU1yV3hBU1pSYUF2SVRUR0dGZk5ENmJfVG9rZW46Ym94Y25vYTE1QVZWNXFuSHVvd2Q1RXFtbGZiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>加载动效的持续时间：</p><p>为了确保人眼能够看到，加载动效的持续时间至少为 250ms。实际加载时间少于此时间的，按 250ms 显示。实际加载时间长于此时间的，按实际时间显示。</p><h4 id="视觉规则-2"><a href="#视觉规则-2" class="headerlink" title="视觉规则"></a>视觉规则</h4><h5 id="主题样式-2"><a href="#主题样式-2" class="headerlink" title="主题样式"></a>主题样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTkwN2M5ZTc2MGE0YzgxY2Y5YzAxMjZmMmU5N2NlZDdfaTR2T3hJenVncnFWY29BMkU5Tm1oYmpWQmNEM1lKWTRfVG9rZW46Ym94Y25QYk9kTW40WFdhdnBMQnNweW9uN3dlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjhmNjU1ZDcyOThhNTgwNWI3ZmUzZDA2MWMxODVmNGFfRWZKeGVROTlmNUR0dWJ0VmpldVF5ZXhrRGxweG5Na2RfVG9rZW46Ym94Y24yVkhyS256SlJDZmZzUjFHSGpnQThnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTI0MGYzYjYwM2M4YWJmMzRkYjVlNGI5ODYyMmJiMjFfZGFzcmlzRHhFd2xaMHVYdnF2bDJxUlJpekJBVFdWY0lfVG9rZW46Ym94Y25LbUF0cWNBeWY2RE41dmNuS05kZDFmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><h5 id="布局样式-1"><a href="#布局样式-1" class="headerlink" title="布局样式"></a>布局样式</h5><p>使用基础栅格，详见 <a href="https://developer.harmonyos.com/cn/docs/design/des-guides/layout-0000001110498552" target="_blank" rel="noopener">栅格系统</a></p><p><strong>单个按钮规则:</strong></p><p>4 个 columns 时，单个按钮默认长度使用 2 columns+2gutters，最⼤可占用 4 个 columns。</p><p>8 个 columns 时，单个按钮默认长度使用 3 个 columns，最⼤可占用 6 个 columns 。</p><p>12 个 columns 时，单个按钮默认长度使用 4 个 columns，最⼤可占用 8 个 columns。</p><p><strong>双按钮规则：</strong></p><p>4 个 columns 时，两个按钮默认长度使用 4 个 columns。</p><p>8 个 columns 时，两个按钮默认长度使⽤ 6 个 columns。</p><p>12 个 columns 时，两个按钮默认长度使⽤ 8 个 columns。</p><p><strong>手机竖屏</strong></p><p>无法复制加载中的内容</p><p><strong>手机横屏</strong></p><p>单个按钮，占用 3 个 columns，字符串超长往两边延伸至最大宽度 6 个 columns。</p><p>双按钮，左右布局，两者间距 12vp。</p><p>3 个以上按钮，自下而上依次排列。</p><p><strong>平板竖屏</strong></p><p>单个按钮，占用 3 个 columns，字符串超长往两边延伸至最大宽度 6 个 columns。</p><p>双按钮，左右布局，两者间距 12vp。</p><p>3 个以上按钮，自下而上依次排列。</p><p><strong>平板横屏</strong></p><p>单个按钮，占用 4 个 columns，字符串超长往两边延伸至最大宽度 8 个 columns。</p><p>双按钮，左右布局，两者间距 12vp。</p><p>3 个以上按钮，自下而上依次排列。</p><h4 id="界面写作规则-1"><a href="#界面写作规则-1" class="headerlink" title="界面写作规则"></a>界面写作规则</h4><ul><li><p>文本按钮：以词汇或短语表达，采用“动词”或“动词+名词”结构。句末无标点。能清晰判断操作对象的时候，只需保留动词，例如“删除、“新建”、“备份”。</p></li><li><p>确认操作的文字，建议使用真实的具体的操作内容，不建议使用抽象的“确认”、“是”或“否”。</p></li><li><p>询问内容，不建议使用“取消XX？”、“是否XX？”等问句。</p></li><li><p>按钮长度：中文 2-4 个字，单行显示。</p></li><li><p>进度按钮：用百分进度表示。</p></li><li><p>当操作本身就是“取消”或“停止”等跟“取消”意思相近的操作时，需采用“是”和“否”。例如询问是否取消下载，使用“是”表示取消下载，“否”表示不取消下载。</p></li><li><p>按钮处于等待状态时，字符串使用“正在XXX…”表达。</p></li></ul><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-basic-button-0000000000621726" target="_blank" rel="noopener">button</a>, <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-basic-input-0000000000611673" target="_blank" rel="noopener">input (type=button)</a> (JS) 和 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-component-button-0000001051009585" target="_blank" rel="noopener">button</a> (Java) </p><h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p>一种临时性弹出窗口，用于展示用户可执行的操作。当用户点击一个按钮或做某个操作的时候出现。菜单里显示的操作应该符合当时的语境，且易于阅读。菜单在用户不需要使用的时候可以隐藏。设计菜单时，请将相关的操作放在一起，方便用户查找。例如在文本选择菜单中，将剪切、复制、全选放在一起，他们是对文字的基本操作，而翻译、分享等操作放在一块，他们是对文字的扩展操作。</p><h4 id="类型-2"><a href="#类型-2" class="headerlink" title="类型"></a>类型</h4><ul><li><p>普通菜单</p></li><li><p>长按菜单</p></li><li><p>下拉按钮菜单</p></li><li><p>文本选择菜单</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDg1ZTRkMjY3MjViODNkNmRiZjRhMjc4NmVkMzEzYmFfS3VYbjBtZlJoR1RRVGlLNElrTmNrV0JhQnJwSzF6bEdfVG9rZW46Ym94Y25JNVlIcjFQc2d6VHBPcWlQSWJyTnI3XzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="如何使用-3"><a href="#如何使用-3" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>菜单项中提供最常使用的操作。常用的操作在不同的场景下，命名和顺序要保持一致，例如删除、分享等。</p></li><li><p>菜单项中不显示与当前内容无关的项。</p></li><li><p>菜单项的数量以 3-5 项为宜。菜单项数量过多的话，用户不能一眼看尽。</p></li><li><p>不建议在手机上使用二级菜单。二级菜单增加了手指操作的复杂度。</p></li><li><p>如果对于某个对象需要频繁操作，请考虑将操作直接放在界面上，而不要放在菜单中。</p></li><li><p>菜单顺序：最常用菜单项放在菜单顶部依次排列。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDI0MTQwMWU2MWU2ODczZTNiNjJlN2M2ZTZjNmMyYjBfQmEwQnFPTmRnZVhWSFBSaUFkWkwyczV6WldmN0hidTNfVG9rZW46Ym94Y25MODl1bkh6UkppM04wcVk2Mnl6dDZjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="交互规则-2"><a href="#交互规则-2" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="点击-1"><a href="#点击-1" class="headerlink" title="点击"></a>点击</h5><ul><li><p>点击具体的菜单项执行对应的操作。</p></li><li><p>点击菜单之外的区域，菜单消失。</p></li></ul><h5 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h5><p>若菜单内容无法全部显示，可用滚动条，此时可上下滑动菜单项。</p><h4 id="视觉规则-3"><a href="#视觉规则-3" class="headerlink" title="视觉规则"></a>视觉规则</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzVlZTU5ZTFhNDQwYjc5M2IwZDMzMTAwNGI4NGMxMTBfWWl6NHJLY1FnWGZrQUwwYmhkNHA0RmRBVXJnOTFhWHVfVG9rZW46Ym94Y241NlVvN1FXUGdYRUNWMW8yZ3FkRjdiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="主题样式-3"><a href="#主题样式-3" class="headerlink" title="主题样式"></a>主题样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWZkNzYxYjVkZTE1YTNhOWFkMDYzZDhjZWY4MzNhNjFfV1VFQURKZWxaRjhEM0tsWXN5bVhGYTZOS3I5UWM4WTBfVG9rZW46Ym94Y25GTzRSbEZaQUlmVEdDV3NDRmdtN0hjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2ZkZTVmOTEzMjUzMGU0Y2IzYTlkZjM2OGI1ODU4YjlfWUtqbUhOM2JnNkVTUTdPNlVGV0E0VUJVa3ZJdERNZEtfVG9rZW46Ym94Y25tVDZkYTlxQ0RTTEtsNXpUZUJnT01kXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmE0ODlhNTM4OTdlNmFjZWNjZGNiMjE1OWU5MWUzMTlfcFcwbWNTQWFOQTJHS2JwbWNCTzlRUnpod2RjY3B2VGxfVG9rZW46Ym94Y240QzcxU2EyR29DQ05pUEE0OVRzdTFnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><h5 id="布局样式-2"><a href="#布局样式-2" class="headerlink" title="布局样式"></a>布局样式</h5><p>使用基础栅格，具体规则：</p><p>4 个 columns 时，默认宽度使用 2 个 columns，最大可占用 4 个 columns。</p><p>8 个 columns时，默认宽度使用 2 个 columns，最大可占用 6 个 columns。</p><p>12 个 columns时，默认宽度使用 2 个 columns，最大可占用 8 个 columns。</p><p><strong>手机竖屏</strong></p><p>无法复制加载中的内容</p><p><strong>手机横屏</strong></p><p><strong>8 个 columns</strong></p><p>默认宽度：2 个 columns</p><p>最大宽度：6 个 columns</p><p><strong>平板竖屏</strong></p><p>8 个 columns</p><p>默认宽度：2 个 columns</p><p>最大宽度：6 个 columns</p><p><strong>平板横屏</strong></p><p>12 个 columns</p><p>默认宽度：2 个 columns</p><p>最大宽度：8 个 columns</p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-basic-menu-0000000000618614" target="_blank" rel="noopener">menu</a> (JS)</p><h3 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h3><p>用于从多个选项中选择一项，且仅该选中项生效，常用于单选列表。单选框所在的选项不会单独使用，而是需要和其他单选项成组使用。默认情况下，单选列表中有一项会被选中，作为默认值，用户无法清除默认值。在某些情况下，单选列表中没有任何项被选中，例如在一个流程中，应用询问你选择哪个项。但一旦选中单选列表中的一项，用户就无法清除该选择回到初始状态。</p><h4 id="如何使用-4"><a href="#如何使用-4" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>用于展示所有可选项。所有可选项处于平等的位置。</p></li><li><p>用于从列表中选择一个项目。</p></li><li><p>如有可能，请将默认选择项作为最佳选择项推荐给用户，且需确保选中项默认被用户看到。</p></li><li><p>对于开关形式的选择，例如开，关。请考虑使用开关控件而不是单选列表。</p></li></ul><h4 id="交互规则-3"><a href="#交互规则-3" class="headerlink" title="交互规则"></a>交互规则</h4><p>点击：选中该单选项，其他单选项会被取消选中状态。</p><h4 id="视觉规则-4"><a href="#视觉规则-4" class="headerlink" title="视觉规则"></a>视觉规则</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDQ4NWE2MzQ1YmE4MjI1MzMxMDRmNzFhZGNmZjAyZTNfUVpnR3g0amw1R3hCV3dQT2hiYWxaUkJIOUxiRTJYWG5fVG9rZW46Ym94Y25PUkhqejVrcGs0Mk9FUUNOM0hKa1RoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="主题样式-4"><a href="#主题样式-4" class="headerlink" title="主题样式"></a>主题样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTRmYTQ0ZDZlYmMyMzNmYmYyMTk1YzY1MDE0N2ZmYzJfVlF4b0h1NndUaDk5MFpDRTFKeUhlWXRSZEozWUVpcWdfVG9rZW46Ym94Y25yQzQwQnhUSXcxS2xjSEZuNmVDSVZnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzRjZmFhYWVhNWVmNGIzOWUzNzM0OTAxNDI1MzM0MTlfYjZDZDJENVNxUXRZdlI1c1RZNGQ4NzVRaHRxbllIYzlfVG9rZW46Ym94Y25VazNWSWg0Q1BUcXVoQUNRb3k5b3F5XzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGFlZWI1MTU4YjIyM2Q4NGE3NThmYTZmNDNjMTU3NjZfd1N1cVMzOGVDU1hYemh3eFFvTmZ1OUxncmplMFI2MEdfVG9rZW46Ym94Y25oRXE5N0o2Um5Ta3hIa3o4ODFLaWlkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-basic-input-0000000000611673" target="_blank" rel="noopener">input (type=radio)</a> (JS) 和 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-component-radiobutton-0000001060647792" target="_blank" rel="noopener">radiobutton</a> (Java)</p><h3 id="弹出框"><a href="#弹出框" class="headerlink" title="弹出框"></a>弹出框</h3><p>弹出框是一种模态窗口，在弹出框消失之前，用户无法操作其他界面内容，干扰性比较强。通常用来展示用户当前需要的或用户必须关注的信息或操作，其他情况不建议使用弹出框，可考虑通知等其他非模态窗口。</p><p>弹出框的内容通常是不同控件进行组合布局。例如文本（可带格式，如缩进、链接、粗体等）、列表、输入框、网格、图标或图片。常用于选择或确认信息。</p><h4 id="类型-3"><a href="#类型-3" class="headerlink" title="类型"></a>类型</h4><ul><li><p>选择类</p></li><li><p>确认类</p></li></ul><h4 id="选择类"><a href="#选择类" class="headerlink" title="选择类"></a>选择类</h4><p>无法复制加载中的内容</p><h3 id="确认类"><a href="#确认类" class="headerlink" title="确认类"></a>确认类</h3><p>无法复制加载中的内容</p><h4 id="如何使用-5"><a href="#如何使用-5" class="headerlink" title="如何使用"></a>如何使用</h4><h5 id="选择类-1"><a href="#选择类-1" class="headerlink" title="选择类"></a>选择类</h5><ul><li><p>弹框中以列表或网格的形式提供可选择的内容。可选一项或多项。</p></li><li><p>单选列表不超过一屏使用弹框。</p></li><li><p>数据类的，超过一屏可以使用全屏显示的方式替代弹出框。例如城市列表、铃声列表等。</p></li></ul><h5 id="确认类-1"><a href="#确认类-1" class="headerlink" title="确认类"></a>确认类</h5><p><strong>带图形确认框</strong></p><p>必要时可通过图形化方式展现确认框，以便用户更好理解或认同确认内容。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzgyMjEwMmI1NTA0YzlhNDM2YWY2ZmVlZGRlMmVjYjNfWDRNTE5LOVFKeFNONTJqRkFZWUY0V25mcFRvZ0VrRlJfVG9rZW46Ym94Y25BdlFTRmpjQUJ5RWxwUEZ3cWU3SWFnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>弹出输入框</strong></p><p>需要用户输入内容时使用。</p><p>无输入内容时，确认按钮置灰。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTkzZDU5NDdiNGYwMzIzZmQzMTQwMWQ1MjVkMzZmMDFfcFpYR1p5Z1VqeHFIWVpuZElMVDRLVEdCYWNoUGo2V3lfVG9rZW46Ym94Y254VVZWamZ6TWt4RmduaWY5dVZ6RFNkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>信息确认框</strong></p><ul><li><p>操作未正确执行（例如网络错误、电池电量过低），或未正确操作时（例如指纹录入），反馈的错误或提示信息。尽量在弹框中给出解决问题的选项、入口或帮助链接。</p></li><li><p>选择查看内容详情时。例如查看文件详情。</p></li><li><p>需要在继续操作前了解的信息。例如权限提示框。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTQ5MTM1MTRkZWIzOWJlY2ViYTQ1YzllODVjMDE2ZmVfdllFRzJlemJMRmZNa0wxbzY2bEJMMzlReEM5Z1h6OU9fVG9rZW46Ym94Y25wWmd1N1RuT3FqYXBIa0gxTTF1ZXZoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>操作确认</strong></p><ul><li><p>触发一个将产生严重后果的不可逆操作时。例如删除、重置、取消编辑、停止等。</p></li><li><p>触发的操作包含一些需用户知道的影响，或关联设置项状态会产生变化时。例如允许开发设置、设置无密码锁屏会关闭指纹校验等。</p></li><li><p>触发的操作需满足某些前提条件时，显示解决前提条件的推荐确认框。例如开启应用锁才能关联指纹、先安装某应用才能进行操作等。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTYyYjNkZDM2MzcyYmNlNzJiMzNkZDgxNGJlYTY2NTdfWUhBZmdXVzJrejhzanBBMFUyYk9mbEtqeFlRRzhGYXRfVG9rZW46Ym94Y25CczhhZmZISnc4WnJ5OXF4RXBQdEtkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>确认类操作按钮区</strong></p><ul><li><p>每个弹框都应该有一个操作目标。</p></li><li><p>确认类弹框目标直接相关操作放到操作按钮区。例如取消、确定、删除等执行操作按钮。</p></li><li><p>非直接相关操作放到弹框内容区。例如忘记密码、新建等。</p></li></ul><p>无法复制加载中的内容</p><p><strong>弹出框连续操作</strong></p><ul><li><p>一个任务分两步完成时，为减少弹框过多给用户带来的困扰，可在一个弹框显示两次操作的内容。场景：领取礼包 （选择区服–选择角色），区服与角色选择，两个操作可在一个弹框内显示。</p></li><li><p>弹框的高度根据内容的高度动态调整。</p></li><li><p>此操作适用于干扰较小的选择操作，例如操作步骤超过两步建议使用全页面操作。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjYwYmMzNWJlNDZlNzU3Zjk3NWMzYTE0Yzc0MTA1MzFfOEhkNGphSjF2eTBuN1lNMGFaNjkxZTc0U0hQdlYzYWdfVG9rZW46Ym94Y25UVnlVRExtYnJLMTBWVDRVd090SURjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="交互规则-4"><a href="#交互规则-4" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="点击-2"><a href="#点击-2" class="headerlink" title="点击"></a>点击</h5><ul><li><p>点击按钮执行对应的操作。如果按钮灰显，点击无响应。</p></li><li><p>点击弹出框之外的区域，弹出框不消失。</p></li></ul><h5 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h5><ul><li>弹出框中的内容应避免滚动。当内容超出显示范围后，内容可以滚动。标题和操作按钮不会随着内容进行滚动。</li></ul><h4 id="视觉规则-5"><a href="#视觉规则-5" class="headerlink" title="视觉规则"></a>视觉规则</h4><h5 id="弹出框构成"><a href="#弹出框构成" class="headerlink" title="弹出框构成"></a>弹出框构成</h5><p>弹出框由三部分区域构成：</p><ul><li><p>标题区</p></li><li><p>内容区</p></li><li><p>操作按钮区</p></li></ul><h5 id="组合样式"><a href="#组合样式" class="headerlink" title="组合样式"></a>组合样式</h5><p>支持以下组合：</p><ul><li><p>纯内容</p></li><li><p>内容+操作按钮</p></li><li><p>标题+内容</p></li><li><p>标题+内容+操作按钮</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDc1ZTA0ZDIyZDkxNzEyOTRmNmIyMDkxZGFhNDlhNmVfQVlrbVB4VVRaZ20wbXhiU2lESHdWSDlvemdiOHUxM3NfVG9rZW46Ym94Y243SjJKOWFrR3ZnVmU5U1pkR3RhZE1oXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="标题区"><a href="#标题区" class="headerlink" title="标题区"></a>标题区</h4><p>支持以下组合：</p><ul><li><p>纯标题（单/双行标题）</p></li><li><p>标题+操作图标</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDNkYWZiYjVmNmRjNDY5ZmNmYWVhNTgxNWUzYTc3MDVfSVBLN2paSlNnWWlTUGp6R0d2WjE1NHlkeEdxSElPbW9fVG9rZW46Ym94Y24zY1hXczZaVkMxaU9ENGJHUTV0c2xkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="操作按钮区"><a href="#操作按钮区" class="headerlink" title="操作按钮区"></a>操作按钮区</h4><ul><li><p>默认按钮宽度不超过弹框宽度，按钮左右布局。</p></li><li><p>按钮组合宽度超过弹框宽度，按钮改为上下布局。</p></li><li><p>按钮左右布局改为上下布局：三个按钮为例左中右三个按钮对应下中上三个按钮。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWRhY2U4NzJhNTI1ZTExNTRiNWVlMDBiZGQ5MWVkZmZfSUhPR0Q5R1dwcFVqVndJQWtFS1M3d2hleWR6MjZJbHdfVG9rZW46Ym94Y25YSVR5OW9LelpTb0haYTVRTVhhMmRCXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><ul><li><p>在需要强调的场景下，按钮可使用带蓝色背景填充的效果。</p></li><li><p>强调按钮支持应用自定义。</p></li><li><p>普通按钮和强调按钮之间无分割线区隔。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjgwOWRiZWMxMzMyYWE0MGMzZmQ0OTg2M2E5ZDU3OGJfckFWUXA5YzRqQ2xNM1JwR29BMUt1OUlDcWVSV0ZHZXBfVG9rZW46Ym94Y25aOFMzT3dNMDNDZVpqZnBONnRQc1BjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="内容区"><a href="#内容区" class="headerlink" title="内容区"></a>内容区</h4><p>内容区的组成比较灵活，可能由如下元素组合构成（需严格按照由上到下的顺序组合）：</p><ul><li><p>图/左图右文</p></li><li><p>输入框/列表/网格/滑动条/进度条/其他（指纹识别）</p></li><li><p>辅助文本</p></li><li><p>其他操作</p></li><li><p>勾选框</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODEyMmM5MGVjYWM0ZTFmYjU2MmRlNTM1ZDgzYmQ0NDdfWjVrOHVjWjM4SXZraVpJZnVqYnoyMUk4eWlMN0ZkVjhfVG9rZW46Ym94Y25VQncyRjlJbkNpa1BHZDFUWE55RFFlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDY2Mjc3ODE1OWIwZDQ3YzVmMzViNGRhZmZkOTMzZjdfRjdHZ1h1dERSYmVYWTBlMHU4dDJya2lzVDNYdm1HcG1fVG9rZW46Ym94Y254WVFJTndFeTNQV3FnaHUwQ3ROQUZlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="主题样式-5"><a href="#主题样式-5" class="headerlink" title="主题样式"></a>主题样式</h4><p>系统弹出框支持浅色主题、深色主题、半透明主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDQ2ZGYzOGVkNDA2Y2FjMDA4YTBjOTI0OWQ1NTUxZjJfRUtFRzhkbjg0SlhUcjkyWG96ZGNlbWJFenJVRUtwVkFfVG9rZW46Ym94Y25BVEVYMjVSTlVMUHJTQ0pyQXRUQlJmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDAzMjUyYmZmYWQ4NmVmYWY1NDgwMzRjMDQ5M2Q4OTVfOTUwUUloMlNGY3F4Ulp0b3BVNndsbFJROUN3dWhsU3VfVG9rZW46Ym94Y25GTURsaDdEc3NoVTlTZHJjUUdMeFZoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjRkZmM0NzI5ZjVmMTMxOTNlMTM0NTg0YWI3OWQ1NWZfRzBkeFRHUmEzejY2TjN3bnhBZXM3U0ZyVWdXVDhzeWRfVG9rZW46Ym94Y25VMERnd0pZZ09JUGhJdjF5aUp2YkdtXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><h4 id="高度规则与位置"><a href="#高度规则与位置" class="headerlink" title="高度规则与位置"></a>高度规则与位置</h4><p><strong>竖屏</strong></p><p>弹出框最大高度= 0.8x（屏幕高度-状态栏-导航栏）</p><p><strong>位置</strong></p><p>始终保持在导航栏上方（含导航栏隐藏场景）。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzY3M2FlY2ViNmZiZTBiOWI1YThmYWNhODY1YjBjMmZfM1Q3SUFjY2RxSnpsWnZpUHBJcTQ5Mnl0QzdtOGNlVG9fVG9rZW46Ym94Y25ueWdTSkF0Rm1QTjRpQUdkaXRkS2FoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>横屏</strong></p><p>弹出框最大高度= 0.9x（屏幕高度-状态栏）</p><p><strong>位置</strong></p><p>在减去状态栏的区域居中显示。</p><h4 id="点击效果"><a href="#点击效果" class="headerlink" title="点击效果"></a>点击效果</h4><p>整体的操作交互反馈与按钮保持一致。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTBjYjMzMTkwMGUzN2QwOGE1Y2NlMWU4OTQyNjQ0ZTVfYlVRdnY1WlJjbGNWQ25wZWN5VDIzRXRTbERnQlJINGxfVG9rZW46Ym94Y255eXJmTEVScWE0ZlBJWTd5bW9qY1ljXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="界面写作规则-2"><a href="#界面写作规则-2" class="headerlink" title="界面写作规则"></a>界面写作规则</h4><h5 id="操作确认"><a href="#操作确认" class="headerlink" title="操作确认"></a>操作确认</h5><p><strong>标题</strong></p><ul><li><p>句子短，无断句，且为陈述句时，不加句号。</p></li><li><p>感叹句、问句，需加对应标点（感叹号、问号）。</p></li><li><p>标题简明扼要，清晰描述要进行的操作。可为短语（动词+名词）。</p></li></ul><p><strong>内容文本</strong></p><ul><li>描述需用户确认的内容（确认后产生的影响、效果、影响范围等），可为疑问句或陈述句。尽量不用辅助说明，若仍需要，避免与标题重复。</li></ul><p><strong>按钮</strong></p><ul><li><p>按钮让用户选择是否进行下一步动作。操作按钮应使用真实的操作内容。</p></li><li><p>通常与标题栏中的动词一致。不要使用“是”或“否”。</p></li></ul><h5 id="信息确认"><a href="#信息确认" class="headerlink" title="信息确认"></a>信息确认</h5><p><strong>内容文本</strong></p><ul><li>以陈述语气描述需告知用户的具体事项。例如目前没有可用的更新。</li></ul><p><strong>按钮</strong></p><ul><li>只有一个，例如“知道了”。避免使用“确认”、“好”。</li></ul><h4 id="界面用语超长处理"><a href="#界面用语超长处理" class="headerlink" title="界面用语超长处理"></a>界面用语超长处理</h4><h5 id="弹出框标题"><a href="#弹出框标题" class="headerlink" title="弹出框标题"></a>弹出框标题</h5><ul><li>先逐级缩小字号到 15fp。</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Njk5YWMwOThiY2QwZTU5NGNlMWI3ZDYzZTIxNTk1YTVfVnV2QVNMOHN3eTFNSXh0RTFQRlQ2Y25LWXJJQjVxQjlfVG9rZW46Ym94Y25mc1JJZjlPaDhJb3h4enN1VGR2bG1mXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><ul><li><p>继续超长，换行处理，支持换一行。</p></li><li><p>最后，“…“截断。</p></li></ul><h5 id="弹出框按钮"><a href="#弹出框按钮" class="headerlink" title="弹出框按钮"></a>弹出框按钮</h5><ul><li><p>按钮不支持换行</p></li><li><p>字符串超长，先在均分区域自适应显示</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGM1N2FlMWQ5NDM1MDM2MDA4MDYxZjI5MmRkZjUwMGRfaEoyc3A2MnhZaTNMNUdsbUJBMkcxMzhVSFpZaUlkR0tfVG9rZW46Ym94Y25YNlJ5N1BVMWJRSjNWdEU4RkhxOHRjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><ul><li>继续超长，先考虑改变布局，左右变上下（若是上下布局，则不考虑此方式）。</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjEzMmYwNmNmNGVmNjVhYzE1N2M3NmY2MWEyNmZmYjBfODczaUZlaGJDUDdQRlZDeHA1VHlmbFh4OFdjN0xBR0JfVG9rZW46Ym94Y25tNGhwcm5lRFhMR04zMzN4Y1NBSUt0XzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><ul><li><p>其次缩小文字。按钮文本同时逐级缩小，最小字号为 9fp。</p></li><li><p>最后，“…“截断处理。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGRmMjE5N2IxZDkxODQwMjg4ZGE2YTQxODRhNDZhODJfeFdWRmM2NmpiZlpVUmZ2ZkFYWGZpa3BqVDdkaG5GWXRfVG9rZW46Ym94Y25zQW4yblB4d2lTUEVRRnhYaExIbWFiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-container-dialog-0000001050068157" target="_blank" rel="noopener">dialog</a> (JS)</p><h3 id="导航点"><a href="#导航点" class="headerlink" title="导航点"></a>导航点</h3><p>导航点用来告诉用户当前内容的数量，且指示当前内容所处位置，位于内容下方。导航点导航的内容都是处于同等重要的位置。导航点的形式取决于内容的数量。当页面数量较少时，可以使用圆点导航点。当页面数量较多时，可以使用数字导航点。用户通过在内容区左右滑动切换内容，内容切换的同时，导航点的位置或数值发生变化。</p><h4 id="类型-4"><a href="#类型-4" class="headerlink" title="类型"></a>类型</h4><ul><li><p>圆点导航点</p></li><li><p>数字导航点</p></li></ul><h4 id="如何使用-6"><a href="#如何使用-6" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>按顺序浏览多个页面或内容时，使用导航点。</p></li><li><p>自动轮播内容时，使用导航点指示轮播内容的数量和当前内容的位置。例如广告轮播图。</p></li></ul><h4 id="圆点导航点"><a href="#圆点导航点" class="headerlink" title="圆点导航点"></a>圆点导航点</h4><ul><li>用一系列小圆点表示，圆点个数代表界面数量。</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjMzYWJlNzUxMGVkNmViNTFhMTg2ZTE4YzcxMTRlNmJfbjlGVDZRVGJyZFpyMEJuWWo0ZEExZTdZNlJXb3lqQ3RfVG9rZW46Ym94Y255WlI4VUhyNGVSeE9sNloxekFsSmZmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="数字导航点"><a href="#数字导航点" class="headerlink" title="数字导航点"></a>数字导航点</h4><p>【推荐】用于数量较多页面的展示，让用户清晰的知道目前所看内容的位置。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmNiMTc4MzE2MTUxYTkyZTU0MjljMGUwODk3NzQzYjBfcDk0MXlxeUc0MGM3MXF6c2o5NnZIMEFvQWd1d2M3WjdfVG9rZW46Ym94Y25SRElVZk9UcHR4NVZuWEd2WVBGRktBXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="交互规则-5"><a href="#交互规则-5" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="滑动-1"><a href="#滑动-1" class="headerlink" title="滑动"></a>滑动</h5><ul><li><p>支持在内容区左右滑动以切换内容。仅广告轮播图提供自动循环滑动，自动滑动间隔为 5s。</p></li><li><p>支持在导航点上滑动切换内容。左滑或右滑按顺序切换页面。</p></li></ul><h5 id="点击-3"><a href="#点击-3" class="headerlink" title="点击"></a>点击</h5><ul><li>点击导航点左侧或右侧切换到上一页或下一页。</li></ul><h5 id="长按"><a href="#长按" class="headerlink" title="长按"></a>长按</h5><ul><li>支持长按左右滑动。</li></ul><h4 id="视觉规则-6"><a href="#视觉规则-6" class="headerlink" title="视觉规则"></a>视觉规则</h4><h5 id="主题样式-6"><a href="#主题样式-6" class="headerlink" title="主题样式"></a>主题样式</h5><p><strong>圆点导航点</strong></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmVjNzcyZDVkOTJkYjEwZjI0YWIwZTBiY2JkYTFlNTZfTUQ0Z3VjbG5reHdBVmNBb014NHFMeEVDTUpuVkhNZ1dfVG9rZW46Ym94Y25pdE1uTUN2TGRCcWFGbExKZDEyeDFlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTI3MmQ4MjQ4MDMzZDM2OWE1MTIxODI4ZWZkODg4ZGRfdVQ4WWF6cFRVMWlBR2RpZVg5S2xwemlCUXBmemxUdm9fVG9rZW46Ym94Y25hQ0x1OUlJaTJRaEsxNG02MmdZY3ZiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTVlZGNjNDRjODBjZmEzMmFkOTY4NzQwMGM1OWRiZGNfeWZPdWxFRWxOMmRTOUVLZ1NLaHA2SWl6NmZ1dGNkdVFfVG9rZW46Ym94Y25ucVR3blRQRHJ0UVBSY0oyY1VVcEFkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>数字导航点</strong></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGZmNmQ3NjdlZjJiZTVmM2M3YWYxY2VjZWU2Y2EzODZfOWxGV1RMWktteGxoS3VQOTJpZGpwVFlXbXVZZ2EzWWZfVG9rZW46Ym94Y25ESEdZOE5RVnVJN2hjV09XVTZCYjZjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDJkZmRjMmY3NmEzZTEwYzFiMGNlZjAxM2ExZjhjYjJfVDZtWURabTNCVGllbjNDV0h6S2VOU1dycFh1VmZ4dTZfVG9rZW46Ym94Y242b3ZXWW5tNFQza0JLZlJOREIySFplXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWNhODg2MjVmYmRhMjExZGMzMzdhNzc3MTk2MTJhNzZfY1M2ZVdCSnRLYTJSQXNKWk9PV1Q1dHRRa2dhZHJXQzVfVG9rZW46Ym94Y25NMnlobTI5T0lKS1R3TmpNQTdwdUllXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="可滑动面板"><a href="#可滑动面板" class="headerlink" title="可滑动面板"></a>可滑动面板</h3><p>用在手机上，它是一种轻量的内容展示的窗口，通常位于界面的底部，方便用户单手操作。在折叠屏展开的情况下以及平板的情况下，由于设备不适合单手操作，可滑动面板的位置和显示形式会根据场景进行调整。例如分享界面会居中显示在屏幕中间。</p><p>可滑动面板展示的内容跟当前场景相关。可以用来持续展示需要显示的内容，例如在智慧识屏界面，可滑动面板用来展示识屏的结果。也可以用来展示临时需要显示的内容，例如查单词的时候，可滑动面板用来临时显示单词的解释。</p><h4 id="类型-5"><a href="#类型-5" class="headerlink" title="类型"></a>类型</h4><ul><li><p>Minibar 类</p></li><li><p>内容持续展示类</p></li><li><p>内容临时展示类</p></li></ul><h4 id="如何使用-7"><a href="#如何使用-7" class="headerlink" title="如何使用"></a>如何使用</h4><h5 id="Minibar"><a href="#Minibar" class="headerlink" title="Minibar"></a>Minibar</h5><ul><li><p>Minibar 提供一个小的界面展示当前的进展或状态。</p></li><li><p>Minibar 可以在 Mini 状态和类全屏状态进行切换，初始状态为 Mini 状态，可切换为类全屏面板。例如天际通、音乐。</p></li></ul><h5 id="内容持续展示类"><a href="#内容持续展示类" class="headerlink" title="内容持续展示类"></a>内容持续展示类</h5><ul><li><p>用于展示关键内容或任务，可以在不同大小尺寸间切换，以方便用户浏览内容。</p></li><li><p>背景为可交互区域（可选），例如 AR 识物中，用户可以自定义选取背景需识别区域。</p></li><li><p>内容展示类可放置关闭按钮（可选），位置为面板标题右侧。</p></li></ul><h5 id="内容临时展示类"><a href="#内容临时展示类" class="headerlink" title="内容临时展示类"></a>内容临时展示类</h5><ul><li><p>用于展示详情或设置，用户用完即走的场景。</p></li><li><p>背景为不可交互区域，例如碰一碰出现的设备控制界面。</p></li><li><p>内容展示类可放置关闭按钮（可选），位置为面板标题右侧。</p></li></ul><h4 id="交互规则-6"><a href="#交互规则-6" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="Mini-bar类"><a href="#Mini-bar类" class="headerlink" title="Mini bar类"></a>Mini bar类</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDNhYTE3ZGUxODA4OWU2MDliMTFkOGFmYjBjYTMwNGZfdkQ3UEI3TlMzYjBoUVJEalU5SlE2Tno4Ym54WHZnVlhfVG9rZW46Ym94Y25LeXM1SE5td2Yzb3ZyWVFIQ1RISEFlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>滑动</strong></p><ul><li><p>在 Mini 状态，上滑切换为类全屏面板。</p></li><li><p>在类全屏面板上，下滑切换为 Mini 状态。下滑过程中，箭头有微动效体现变化过程。</p></li></ul><p><strong>点击</strong></p><ul><li><p>点击 Mini bar，切换为类全屏面板。</p></li><li><p>点击类全屏面板的箭头区域或点击系统返回按钮，切换为 Mini 状态。</p></li></ul><h5 id="内容持续展示类-1"><a href="#内容持续展示类-1" class="headerlink" title="内容持续展示类"></a>内容持续展示类</h5><p>内容展示类有小、中（类半屏）、大（类全屏）三种尺寸状态，初始状态通常为中尺寸状态。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDhhMWFhN2MxMjU3ZmY0MWRhNGM0ODliNGM5YmM2N2ZfZUU2ZG9wbHhKZUJxZVlqYUNNSlBVSWhqb0NXY1BvZktfVG9rZW46Ym94Y25hRzR4TmpGZ1JoaktsSGl3b0hjSTRkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>滑动</strong></p><ul><li><p>小尺寸状态向上滑切换为类半屏状态，继续上滑切换为类全屏状态。</p></li><li><p>类全屏状态向下滑切换为类半屏状态，继续向下滑切换为小尺寸状态。面板顶部短横杠随着状态的变化而变化。</p></li></ul><p><strong>点击</strong></p><ul><li><p>点击小尺寸面板的箭头所在区域（向上箭头），切换为半屏面板。</p></li><li><p>点击类全屏面板向下箭头所在区域（向下箭头），切换为半屏面板。</p></li><li><p>点击半屏面板横条所在区域，无响应。</p></li></ul><h5 id="内容临时展示类-1"><a href="#内容临时展示类-1" class="headerlink" title="内容临时展示类"></a>内容临时展示类</h5><p>内容展示类有中（类半屏）、大（类全屏）两态，初始状态通常为中尺寸状态。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODdjMzQzOWY2YzQyYzRjMjFjMDEzMWI2MTczMmM2NDZfSjBGbkNkMjNpY29nNlJvZlRBc0Y0ZGkySWlJMlAxdHdfVG9rZW46Ym94Y25kOUxyU096cVNMSndzSWxPaklrRVBzXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>滑动</strong></p><ul><li><p>类半屏状态上滑切换为类全屏状态。</p></li><li><p>类全屏状态向下滑关闭面板。</p></li></ul><p><strong>点击</strong></p><ul><li><p>点击半屏面板横条所在区域，无响应。</p></li><li><p>点击类全屏面板向下箭头所在区域（向下箭头），关闭面板。</p></li></ul><h4 id="视觉规则-7"><a href="#视觉规则-7" class="headerlink" title="视觉规则"></a>视觉规则</h4><h5 id="主题样式-7"><a href="#主题样式-7" class="headerlink" title="主题样式"></a>主题样式</h5><p>可滑动面板支持浅色主题、深色主题、半透明主题。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzQ0N2FmY2EzNWUzZjMyYWQxYzhhMmE4N2FjYjJmMjhfTVBuNE5BNUZvYUFqY0g4OHpKN3FmcXNZRHVJM3JaNFpfVG9rZW46Ym94Y241SXZpZFYxOG1zUEcwZ2J0SldoNzdkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzY1MDZjM2ZlY2ZiNjBhYTBlY2I3MzY3NTI1N2VhMjhfNzJEbDJick82c1BYMUZGNnRsbkhibWxybVh2OW5xWjhfVG9rZW46Ym94Y25FMjFhZTZqUHJqSVhkcXBaaWpUMGJnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTljNjdkYWNiODhkZTE0OTNhMWYxYjAyNjg1MTU4NTdfR1VwSGEyREs3RE85a0NrWmhFMVF0U3hzMk9GcDcxak1fVG9rZW46Ym94Y25aUU52dzM2RXVSR21SSHc5WklZRk9iXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><h5 id="布局样式-3"><a href="#布局样式-3" class="headerlink" title="布局样式"></a>布局样式</h5><p><strong>竖屏布局</strong></p><ul><li><p>操作条：面板最小高度 48vp，顶部显示图标为向上箭头。</p></li><li><p>半屏：面板高度为全屏高度的1/2，顶部显示图标为横条。</p></li><li><p>全屏：面板的最大高度=屏幕高度-状态栏-8vp padding，顶部显示图标为向下箭头。</p></li><li><p>高度应用可自定义，最小高度不能小于规范定义高度，最大高度不能大于规范定义高度。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTkyYjU1ZDA2ZGY3NDc1NmY2YmJmMzQ2YmI3OTQ2MzRfbWRXdFRrRlcxODFIUHc4Z1ZXbVQxNGNtZUdtc3doMmhfVG9rZW46Ym94Y25UVVloTVpNT3lzR0d0UUN1RVhXTzljXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>横屏布局</strong></p><ul><li><p>横屏时，无半屏模式，半屏直接以全屏显示。</p></li><li><p>操作条与全屏面板规则与竖屏一致。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTAxM2UxYTEwOGVjYjQzZTMxNmYwMjY4YzFmNWE2NGRfWGdlYk1BNUVYelhaS3hzNkxoclpKa3EwVHBxSFo1TFVfVG9rZW46Ym94Y25lR3RrV3BHYk9aVWlCaDduM09Zak5kXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="底部页签"><a href="#底部页签" class="headerlink" title="底部页签"></a>底部页签</h3><p>底部页签是一种常见的界面导航结构。通过底部页签，用户可以快捷地访问应用的不同模块。使用底部页签也方便用户单手操作。底部页签上的每一个页签，都是图标+文本的形式，用户单击页签时，该页签会被激活，视觉上会高亮显示。</p><p>在平板上，底部页签通常会转化为侧边页签，方便用户双手握持操作。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmVjOWJlYTA4YTc3ZjZiNzI2ZTA5MjVkZWZhNmJlNzBfb0p0clJKb3BNd25PUzg4aVpNZWdtNmkyMERpVGtDb0pfVG9rZW46Ym94Y24xYTdQdjBpZnp4YXFSVEhkcDBuY01jXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="如何使用-8"><a href="#如何使用-8" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>仅用于一级界面。</p></li><li><p>页签上允许有新事件标记，用于通知用户该页签下有新的内容或消息，详见<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/badge-0000001110627022" target="_blank" rel="noopener">“控件”&gt;“新事件标记”</a>。</p></li><li><p>页签上的文本要精练，不要使用太长的字符串。</p></li></ul><h4 id="交互规则-7"><a href="#交互规则-7" class="headerlink" title="交互规则"></a>交互规则</h4><ul><li><p>点击可切换页签。若点击当前页签，界面会回滚至页面顶部，适合长页面快速回到页面顶部。</p></li><li><p>不可通过滑动来切换底部页签，以免手势冲突。</p></li><li><p>在消息列表界面，双击底部页签，会从当前位置跳转到下一个未读消息。下一个未读消息的位置是显示在列表的第一行。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWViMzAwMGMyZDUxNTBlZTg4NTQ1OWZmYTI0MzNjZThfMHJoUjJMZ3cwaTlPQmhUWVo0Sk01RlFRNTNJY3BIUkpfVG9rZW46Ym94Y25OSEdheE5GbmI4YmZoQW9WWGpLRGpiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="视觉规则-8"><a href="#视觉规则-8" class="headerlink" title="视觉规则"></a>视觉规则</h4><p><strong>竖屏</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjIzODdhYmUyYWY0YmMwMzZmM2EwZmMwZDEzMDY2OGVfWU5qbkZ3UzlJczdUSFhiSzk1SzFCeGtYaXJnWGhMakhfVG9rZW46Ym94Y25xMVFLaTY1bE9tdlRlcmlPM2xhMVBnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>最多允许放 5 个。</p><p><strong>横屏</strong></p><p>区分手机横屏与平板横屏效果。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzI1ZTNiYjNiYzE0YWIwMTNlYzE1ZTA0YmZhZGMyMTlfZEg0NUk1Um52RHRFZ0NzdXBxVHZNNUJDQ2FUM0ZjeWJfVG9rZW46Ym94Y25IcGhhQ3pSeGphR1oxeURJUWZoOUFnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>手机横屏情况下，图片与文字采用左右布局形式。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmQxNDZlNGYwNTQ2MzZhMzY0ZmI4ZmY3Nzc0OTNhNTRfeUVsc1JhblFIcWhlWXJGVUVuR2xBU1V2SHN6MGlVTkNfVG9rZW46Ym94Y25vdlR6YUhORExuUmdXT0lUZFNGOGdjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>平板横屏情况下，底部页签变成侧边导航，侧边导航固定在页面左侧。</p><p><strong>分栏/分屏</strong></p><p>分栏/分屏情况下，工具栏在其可用区域内，按照竖屏规则布局<strong>。</strong></p><h5 id="主题样式-8"><a href="#主题样式-8" class="headerlink" title="主题样式"></a>主题样式</h5><p>只支持浅色、深色主题</p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjI0YWQzNDczZjNiZmI5YzcyYWJiNWE5YWQ1NjJjOWRfNWF6SWNrMkg3cXVHOXJZYktkY21jMlI1ZWpKdEhsZ1NfVG9rZW46Ym94Y25XY1F1c2R1TlJ4MFpIZFJLUXdvOEVnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2RjZTI4Nzg3ZjVhZTk3MzE5YTg0OGRlOWJkOTUzMWVfUnZyMFhKUlpHdUNKdmhIY1dLQXZ3RUNhMkRsOEg2SjZfVG9rZW46Ym94Y25BTWxFZzhRQzVoRFR5aU5pZzJMOVNlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="栅格布局"><a href="#栅格布局" class="headerlink" title="栅格布局"></a>栅格布局</h5><ul><li><p>页签有自动折行的效果。</p></li><li><p>定义icon( 32vp )和文字( 72vp )的判断参考值。</p></li><li><p>当单个item的容器宽度小于/等于 32vp + 72vp =104vp 时，icon 和文字就变为上下布局。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGRmOGU0MmI5ZDVkNWQ1MWE5NjFlNWVjOWJmZTYwNjhfT1lWMlMyekdEemhoS2JJRE56MVZSeGtaTFljZnlmWWhfVG9rZW46Ym94Y25MWXh4TnR5NFdqSmwwdnJUeUhReTJmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>缩进规则</strong></p><p>使⽤基础栅格。</p><p>4 个 columns 时，4 items 和 5 items 内容占比适应全屏，2 items 和 3 items 内容占比适应 4 个 columns。</p><p>8 个 columns 时，4 items 和 5 items 内容占比适应 8 个 columns，2 items 和 3 items 内容占比适应 6 个 columns。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjBiZmNiMTdiNTI1NGMzMDI0ZmEyMDZjYmFlNWI3NGVfNnc5Rnk1U2ZsQU1nOTIwNnFxSm9UVk5GSGx6UUdicEpfVG9rZW46Ym94Y255QWxnOUh2M2FGajZWM1pHbG9lWjNmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="界面写作规则-3"><a href="#界面写作规则-3" class="headerlink" title="界面写作规则"></a>界面写作规则</h4><p>页签中的文本采用短语形式（名词或名词词组），简明清晰描述页面内容，不带标点。</p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-container-tab-bar-0000000000611548" target="_blank" rel="noopener">tab-bar</a> (JS)</p><h3 id="多选"><a href="#多选" class="headerlink" title="多选"></a>多选</h3><p>用于内容项的选择，一般用于多选界面。用户可以通过点击选择某项、多项或所有项。点击某个项的时候，可以选中或取消选中该项。也可以通过手指在界面上滑动快速选择多个项。</p><p>有多种方式进入多选界面：</p><ul><li><p>长按列表项或网格项进入多选界面。</p></li><li><p>选择添加联系人或文件的时候进入多选界面。</p></li><li><p>在长按菜单中选择“多选”操作进入多选界面。</p></li><li><p>在标题栏或工具栏中选择“多选”操作进入多选界面。</p></li></ul><p>注：“多选”操作，有时候用具体的操作表示，例如仅有一个删除操作时，使用“批量删除”。</p><h4 id="如何使用-9"><a href="#如何使用-9" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>多选可以从列表中选中一项或多项。</p></li><li><p>图标多选框放左上角，图片多选框放在右下角。</p></li><li><p>页面无选择项时，标题显示“未选择”；有选择项时，标题显示“已选择”+数量标签+“项”，数量标签前后要留半角空格。</p></li><li><p>可以用多选设置多项，而不是用开关控件</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MWEzOWViOTZhYTg4YTdiNDZjZWM3ODdhZTNmMzc4NjFfaEl5bEtxQTJmbWUwRkExcDV1TzI0VXFQRHp3QWREZndfVG9rZW46Ym94Y25jcEY4RGpvcmYycHlvbnI1S0twbXJlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="交互规则-8"><a href="#交互规则-8" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="点击-4"><a href="#点击-4" class="headerlink" title="点击"></a>点击</h5><p>选中或取消选中。</p><h5 id="滑动多选"><a href="#滑动多选" class="headerlink" title="滑动多选"></a>滑动多选</h5><p>在列表项多选框上可通过上下滑动选中或取消选中。</p><p>通常情况下，列表项多选框热区分为两种：</p><ol><li>列表项可以进入下一级，多选框热区是自身。</li><li>列表项没有下一级，多选框热区是整个列表项。</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmQyMzU3YmY5NDA2MWMyYzM3YzM3Zjg1YTM4MDA4ZTdfMDM1S3JaMFRPU2RGT2xUUjRrMThmcUtORnVZTVgyenpfVG9rZW46Ym94Y256bVhIcmpLMzdIWEVHejBYZ1pQSjM4XzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><ul><li><p>网格项支持滑动快捷多选（网格界面任意滑动选择/取消，以滑动时手指起始项状态的反向状态来设置手指滑动经过项的状态）。</p></li><li><p>网格项多选热区是整个图片（包含勾选框）。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzQzNWRhNTI3NDgzYzdmMDNjZDU2MjU5ZWQ1Mjk5YWJfOEpWMFhzYXBDemdvVzcwa2lRdHhBaHVCMFp3eEd4VWlfVG9rZW46Ym94Y25nT3V5b2FIQnU4TzA5cXpjQXRnRHNiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>Grid 多选热区（特殊）热区固定 32x32vp ，与图片右下角紧贴</p><ul><li>从上往下滑动多选到页面底部，页面可自动向上滚动，继续往下多选；或者从下往上滑动多选到页面顶部，页面可自动向下滚动，继续往上多选</li></ul><h4 id="视觉规则-9"><a href="#视觉规则-9" class="headerlink" title="视觉规则"></a>视觉规则</h4><p>同<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/checkbox-0000001110467120" target="_blank" rel="noopener">“控件”&gt;“勾选”</a>。</p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-basic-input-0000000000611673" target="_blank" rel="noopener">input (type=checkbox)</a> (JS) 和 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-component-checkbox-0000001060487804" target="_blank" rel="noopener">checkbox</a> (Java)</p><h3 id="分隔器"><a href="#分隔器" class="headerlink" title="分隔器"></a>分隔器</h3><p>可用于列表或界面布局。使用分隔器包含两种类型：分隔条和分隔线。</p><p>分隔条用来将界面进行分组。分隔条可以和子标题一起使用，通过子标题告诉用户分组的内容是什么，子标题位于分隔条下方。</p><p>分隔线用来将界面元素隔开，使单个元素更加容易识别。</p><h4 id="类型-6"><a href="#类型-6" class="headerlink" title="类型"></a>类型</h4><ul><li><p>分隔条</p></li><li><p>分隔线</p></li></ul><h4 id="如何使用-10"><a href="#如何使用-10" class="headerlink" title="如何使用"></a>如何使用</h4><h5 id="分隔条"><a href="#分隔条" class="headerlink" title="分隔条"></a>分隔条</h5><ul><li><p>分隔页面中不同类型的内容。</p></li><li><p>仅用于效率型界面。</p></li><li><p>分隔条不能放在界面内容最上方。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDJlZTY1ZjNmOTc0Zjk3YzVmYzcyZjFmZGY1NTI5NDNfRW1SSFF6c01qMG9QRmVncHRFdGFrT29ramlaa1phZ2lfVG9rZW46Ym94Y25ncDgzQkM2b0M0Yk8zUVozdkNlZGhkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h4><p>分隔一组列表项。</p><p>列表上方第一行和最后一行下方不加分隔线。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWVhYTQ4YjI0MDJlZjBiZWVmNmZmZmIwYTI3NTBmYzRfYzJvbHdMMnE0QzJZUVlBalpTY2hMbWZaa1BoSzFDYUtfVG9rZW46Ym94Y25QemZ0SW9ZNmpsczVMT3NYcENweVFiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>起始位置</strong></p><p>列表左边有图标元素时，分隔线从图标元素之后开始，例如小图标、头像等。因为图标元素本身就能很好的区隔，无需重复。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzYxMWFjMWNjOTBlZmM5ZGVhMjc4YzIzN2YzZjIxN2NfM2JOYkdzbDdDTXVXa09iRGZzNHlBeEVRSjBTVTVybzFfVG9rZW46Ym94Y256UG9IOEh1cVdSMnpuWkhkYnJVbUVmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="视觉规则-10"><a href="#视觉规则-10" class="headerlink" title="视觉规则"></a>视觉规则</h4><h5 id="主题样式-9"><a href="#主题样式-9" class="headerlink" title="主题样式"></a>主题样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjI2MzcwZDE3OGM0NjQyOTI5ZGJmZTYzZDA0MzU1MTNfNTJJM0RIbDhvbkJ6dHd2cGpMZG84d1NiUHhZeUFWRDhfVG9rZW46Ym94Y24zZGpZR3ZrZVVoYlZ2WkltaVlOTkxmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><p>工具栏放在界面底部，界面内容之上，用于展示针对当前界面的操作选项。通常情况下，当界面滚动时，要保持工具栏的可见性，且工具栏不会随界面滚动。在沉浸式界面，往上滚动界面，工具栏可以处于临时消失状态，让用户看到更多的内容，往下滚动界面，工具栏恢复显示。</p><p>工具栏上的操作，都是图标+文本的形式，用户单击某个操作时，会直接触发该操作。</p><h4 id="如何使用-11"><a href="#如何使用-11" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>最多显示 5 项操作选项（含“更多”菜单，在最右边显示）。</p></li><li><p>操作选项的排序规则为：“添加”、“分享”、“收藏”、其他操作（下载、编辑、移动等）“删除”、“全选”、“更多”。</p></li><li><p>工具栏上应该只显示常用操作，当常用操作过多时，显示不下的常用操作、非常用操作以及难用图形表示的功能，放入“更多”菜单。但不允许出现工具栏只有“更多”的情况。</p></li><li><p>底部页签和工具栏不能同时使用。</p></li><li><p>功能图标优先放在工具栏上，如果界面没有工具栏，才考虑放在标题栏上。</p></li><li><p>仅有一个“设置”或“更多”操作时，需将操作放在标题栏右侧。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjM5YTRhYWY2MDRmNDlkYzI1NTc5NzNjOGU3ZWNhYjJfS3h0aU1pcjc4a3g2SWxadU1IWnF6cWsyT3VYejV1S2NfVG9rZW46Ym94Y242RTRNdktmQjc1RUIzQ0ZoRWFMMTllXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="视觉规则-11"><a href="#视觉规则-11" class="headerlink" title="视觉规则"></a>视觉规则</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjhiODU1ZDIzMWM0ZDI3NjFmNWY1ZTM0NTZlNjA1ODRfUDdnTHZGZXR3eUl6c0EzOVdmMVEzZTc4VXJMNVl1cW1fVG9rZW46Ym94Y25qR2hSS09Fb3FtSkM1ZXI1S21SaGpiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>正常状态</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTRhYmE0YjQzMDE0ODdiMDk5MTZkMDg2OGNmMTY2ODBfdGhsMHFDejdYMjJybXg5Y2h6UkJ3c0NjVG1HM0xoVTdfVG9rZW46Ym94Y25NeVgwaUpWUjVzMFZoM1VJeWFTOUFiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>不可点击状态</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjM4NWRmMzAyN2E2MjMxNGJkMDE0NTg0N2RhMDVhOWNfd0FDUTJMcGFIQXVVVUNzQ3IxSVhTRkhmZWM2S21lVW1fVG9rZW46Ym94Y256ZXlFUTVLZUVaR1B3SUc0Y1JIZ1hkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>激活状态</p><h5 id="主题样式-10"><a href="#主题样式-10" class="headerlink" title="主题样式"></a>主题样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGU3MmJiZGI2NTNlMmVjZDFkZWU5NmJjMzM2YzIyNzNfSXR4RVZSWDJWaHNNb3Roc2hrWkRHcUFjRXRqSFB1QW9fVG9rZW46Ym94Y24xWU1qQ29XRGZiaGw3Wnh3OVg3T1ZjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjZkYzM0MzA0NmE3ZTdkODlkZDAzNTkyNzI2NzY0MmRfWk1lMElCbmJHSkpSdHRYc1BDTmJsRllEQ0RuMDZyRzRfVG9rZW46Ym94Y25rVFVuWTJMaEpTZU1xYktQMWVsbUhnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQ3YWEzMTAxNjVkNjM3ZDM1MGI0MTU5NzBkZTVhMjJfMEE1R1NSM1VwdEdONHNhWU5SQVFKSFdmMm4yQzNJbHpfVG9rZW46Ym94Y24ybjhWcmo3SWxPeHlpeEJrWVVPZEhnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><h5 id="栅格布局-1"><a href="#栅格布局-1" class="headerlink" title="栅格布局"></a>栅格布局</h5><p>使⽤基础栅格。</p><p>4 个 columns 时，4 items 和 5 items 内容占比适应全屏，2 items 和 3 items 内容占比适应 4 个 columns；</p><p>8 个 columns 时，4 items 和 5 items 内容占比适应 8 个 columns，2 items 和 3 items 内容占比适应 6 个 columns。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTAzYTUzMDYwMGU4YzBhMmQ3NmM1Y2U4NjFlNDBjYzVfbTVjaWFMMENHU3RYUk5IVVhHM1dQbFplalVEU1FWeXVfVG9rZW46Ym94Y25peTlnTU1DY1JEZXlNMTNqM2FxUG5lXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>平板竖屏</p><p>内容占比适应 6 个 columns</p><p>内容占比适应 8 个 columns</p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-basic-toolbar-0000001062209279" target="_blank" rel="noopener">toolbar</a> (JS)</p><h3 id="勾选"><a href="#勾选" class="headerlink" title="勾选"></a>勾选</h3><ul><li><p>勾选用于表示用户同意该项的描述。常见的场景例例如USB连接界面的“不再提示”。</p></li><li><p>勾选在一些临时状态的场景下，也用于表示用户同意开启或关闭业务功能或设置。常见的场景例如权限界面的“禁止后不再询问”。</p></li><li><p>勾选放在描述语句或设置的前面，且跟字符串挨在一起，操作时整体响应，以方便用户查看和操作。</p></li></ul><h4 id="如何使用-12"><a href="#如何使用-12" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>勾选项是否默认开启，需考虑勾选项对用户所带来的影响，默认状态不应该对用户带来负面影响。</p></li><li><p>勾选项是界面中主要内容或操作的一个附加选项。</p></li><li><p>不要通过默认勾选这种方式，诱导用户或趁用户不注意开启或关闭某个功能。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzAwODM0OWNkYzAwOGRmZTYyNDkyMGYyZTY3MGE4NTdfSVlJT1ZKaEZPRzE3Sndvbm5uazRKYmMwQllnazJ3eWxfVG9rZW46Ym94Y25CUWpTOThvcFlnQ01TMmc4cHJFNHBmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="交互规则-9"><a href="#交互规则-9" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="点击-5"><a href="#点击-5" class="headerlink" title="点击"></a>点击</h5><p>选中或取消选中。</p><h4 id="视觉规则-12"><a href="#视觉规则-12" class="headerlink" title="视觉规则"></a>视觉规则</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjE2OGI3Y2UyODkyY2UxNTkyODMwZWVlNjcxN2YxNDVfQkFacE5Ia2lkZ2ZJTlZrWmdMSDlMNTdIS25qdlBrNFZfVG9rZW46Ym94Y25lVG9JOURCcjhtbmJzdkFpS3h4cnVjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>勾选框组合，热区区域包含说明文字</p><p>文本左对齐</p><p>文本与勾选图标上下居中对齐</p><h5 id="主题样式-11"><a href="#主题样式-11" class="headerlink" title="主题样式"></a>主题样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGI5MDFjNzY4ODcyNzFjYjljN2VjYWZjYmM4OTEwZGVfcTc0SUdOT0pVMm45c3pkTlRpRzgxM25Uc1V5TFFydDFfVG9rZW46Ym94Y25LM2JBNWxLRjhWSFRqQ0QwSXRERlhnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzliZjc1NGYxMmRiNGYzZmIwMjE1YTdkMTllZGJlZjhfUFZvVXJmazd4ZG1meW80NWJ3d1owR1dpSlBqVW1QV0NfVG9rZW46Ym94Y25yUnhEamc4SWtMTjZrdWxBN1VTdFJkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjAxZmM3ODZmNjQ3NDRhMmQ5YmMyYmE0YWUwNTcxZjJfNEJZa1dKZkU0SWNTWExYWEl0OGozWXFkYnRQSXk2WW1fVG9rZW46Ym94Y24yZ2d5WjhraDRKaGpJVzQ1U0djUlhjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><h3 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h3><p>在页面滚动时，显示滚动条。滚动条所处的位置，表示当前看到的内容处于整个界面内容的位置。滚动条支持拖拽，在页面很长的情况下，可以通过拖拽滚动条的方式来快速浏览内容。在视觉上，滚动条在拖拽的情况下会变粗。</p><h4 id="如何使用-13"><a href="#如何使用-13" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>当页面内容超出内容显示区域长度时，初次进入页面或滚动内容时，会显示竖向的滚动条。</p></li><li><p>在页面内容很多的情况下，若用户需快速定位，可拖拽滚动条。</p></li></ul><h4 id="交互规则-10"><a href="#交互规则-10" class="headerlink" title="交互规则"></a>交互规则</h4><ul><li><p>拖拽：当滚动条出现的时候，可上下拖拽滚动条快速浏览内容。</p></li><li><p>初次进入界面，若界面内容超出显示区域，显示竖向滚动条，无任何操作，2 秒后消失。</p></li><li><p>滚动条高度为动态高度：滚动条高度反映当前可视内容占整个内容的高度比例，高度是动态变化的，内容高度越高，滚动条高度越小。</p></li></ul><h4 id="动效规则"><a href="#动效规则" class="headerlink" title="动效规则"></a>动效规则</h4><ul><li><p>滚动条跟随列表下拉、触顶时、列表有回弹效果，滚动条自身有高度上的回弹效果。</p></li><li><p>滚动条触摸时有宽度上的变化。</p></li><li><p>滚动条跟随列表触底时，列表有回弹效果，滚动条自身有宽度上的变化，同时有高度上的回弹效果。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWI0ZGM2MDNjM2I5MDE1MWRmNGQ5OGRmODM2NWQ2YzZfUjU0aWl6VTZXOTRvc0V0RjAwSkp4dGFUN1oweUw0SlNfVG9rZW46Ym94Y25ydzl2TDBRbHFyR1JmRmY3clZWYkpoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="滑动条"><a href="#滑动条" class="headerlink" title="滑动条"></a>滑动条</h3><p>滑动条分为两种样式，分别应用于不同场景，具体如下：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDZiZDQwNjIwNGEwYWI1YjkwMWU3MzBkN2RiMTg3N2NfSGFXRWVBU0pYUFk5bmlWZGZHV0hZSll4dkx4S2dITDZfVG9rZW46Ym94Y25OejVvT2xOTkRTVzVaOXJnSFE0VkZnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="进度滑动条"><a href="#进度滑动条" class="headerlink" title="进度滑动条"></a>进度滑动条</h4><h5 id="类型-7"><a href="#类型-7" class="headerlink" title="类型"></a>类型</h5><ul><li><p>连续滑动条</p></li><li><p>间续滑动条</p></li></ul><h5 id="如何使用-14"><a href="#如何使用-14" class="headerlink" title="如何使用"></a>如何使用</h5><ul><li><p>手动调节进度时使用，例如视频和音频播放。</p></li><li><p>值的范围：左边－最小值，右边－最大值。</p></li></ul><p><strong>连续滑块</strong></p><ul><li><p>不求精准，以主观感觉为主的设置，使用连续滑动条。</p></li><li><p>部分场景缓冲进度，例如在线音乐播放界面。</p></li><li><p>带气泡的滑动条：通过气泡指示当前选择的值，在需要给用户展示当前选择值的时候使用。</p></li></ul><p><strong>间续滑动</strong></p><ul><li><p>在固定值中选择时，使用间续滑动。</p></li><li><p>【推荐】滑动条两边的预览文字／图标，可点击调整设置值。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2FjZGI3NjRkNTFlNWE5OWE1MmI4ZmYzMTRjYzc2YzZfeFFQWnFOQ3JkdlRqZVRyRGRmSGMyZ2VyMDJ3cWZHNkJfVG9rZW46Ym94Y25jZU9DOXA2bEgzN1ZjQ29IbFNtaTVlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="交互规则-11"><a href="#交互规则-11" class="headerlink" title="交互规则"></a>交互规则</h5><p><strong>点击</strong></p><ul><li><p>点击连续滑动条，滑块会移动到点击位置。</p></li><li><p>点击间续滑动条，滑块会吸附到最近的刻度节点上。</p></li></ul><p><strong>滑动</strong></p><ul><li><p>手指按住滑块，向左或向右滑动，按住滑块之后，手指可挪到滑动条以外区域向左或向右滑动。</p></li><li><p>某些特殊情况，可以在滑动条外直接通过滑动手势进行调节。例如视频播放过程中在视频显示区域内左右滑动调节播放进度。</p></li></ul><h5 id="视觉规则-13"><a href="#视觉规则-13" class="headerlink" title="视觉规则"></a>视觉规则</h5><p>连续滑动条</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmE4NmNiMjZjNjBkZDFlOWNiMjU4NmFjMjU2MjY5YThfeHE0TUowQzY0SHg5UmRQbUtScXc4aGV1Y0dJaU9paHNfVG9rZW46Ym94Y256Tm4wSG5rcGFJOXFYSFA1QzJ4RGxoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>气泡滑动条</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDNlNDM3NzQ0NzAxZDMyNzYyMjFiODdkZjZiN2ViNTJfbEFkeFZ1UzVJcUpmQU12RnRnbGlLcm0waVI2eEVWUkFfVG9rZW46Ym94Y25tSFZHSlo2WGp1ZkxHWlFLb0drMDJmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>间续滑动条</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDMwY2M0Njc4ZWJjZTczZGE5NTAwMDdhNDRjMGYwNDBfVll1TUlGdFh3UzYzYmpDSEVIZ1RaMTRMNmRaY3g1MU9fVG9rZW46Ym94Y25HU3Z0TzVlQkk3Yld3ZzJMcEVodGRjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTNiYWRlNmRjOGRlODQ0MDE1ZWRlMmFhZTY3MTFiOWFfaWFqbkI1WWhBd3NtN2MxZ0k2Rk9rRWhic0tzTlZNaXNfVG9rZW46Ym94Y240bTdtUzZseFlIRzVqUTVVMkxqMmpnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="设置滑动条"><a href="#设置滑动条" class="headerlink" title="设置滑动条"></a>设置滑动条</h4><h5 id="类型-8"><a href="#类型-8" class="headerlink" title="类型"></a>类型</h5><ul><li><p>连续滑动条</p></li><li><p>间续滑动条</p></li></ul><h5 id="如何使用-15"><a href="#如何使用-15" class="headerlink" title="如何使用"></a>如何使用</h5><ul><li><p>调节具体的参数值使用，例如亮度或字号大小。</p></li><li><p>值的范围：左边－最小值，右边－最大值。</p></li></ul><p>连续滑动条</p><ul><li><p>不求精准，以主观感觉为主的设置，使用连续滑动条。</p></li><li><p>部分场景缓冲进度，例如在线音乐播放界面。</p></li><li><p>带气泡的滑动条：通过气泡指示当前选择的值，在需要给用户展示当前选择值的时候使用。</p></li></ul><p>间续滑动条</p><ul><li><p>在固定值中选择时，使用间续滑动。</p></li><li><p>【推荐】滑动条两边的预览文字／图标，可点击调整设置值。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTcxZTMxZWZmNDJhNWZiMWEwNzU4ZmEzZGUxODhmMjVfdkx0SkdGVDdXWHFVSGtPSDNLaHNvdENWM1ZCNGlXRzJfVG9rZW46Ym94Y25SRllpR2FRRUVKckpNaVlwZnVPdkJmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="交互规则-12"><a href="#交互规则-12" class="headerlink" title="交互规则"></a>交互规则</h5><p><strong>点击</strong></p><ul><li><p>点击连续滑动条，滑块会移动到点击位置。</p></li><li><p>点击间续滑动条，滑块会吸附到最近的刻度节点上。</p></li></ul><p><strong>滑动</strong></p><ul><li><p>手指按住滑块，向左或向右滑动，按住滑块之后，手指可挪到滑动条以外区域向左或向右滑动。</p></li><li><p>某些特殊情况，可以在滑动条外直接通过滑动手势进行调节。例如视频播放过程中在视频显示区域内左右滑动调节播放进度。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzJkMWYzMDBmODVjYzkzOWMxZDhhOWZhMGJhMTRmZDhfNGYxVDgzZHFWeDdlTGx1S1hJcW1Jdm1XWVhjVlpBY1RfVG9rZW46Ym94Y25reHNGNEFweld6T1ZJblZYVGliM0JnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="视觉规则-14"><a href="#视觉规则-14" class="headerlink" title="视觉规则"></a>视觉规则</h5><p>连续滑动条</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDU2ZTc4MzdkMDhlODA0MGI4NTkxMTBkNDc2N2U3ZTJfVFhIc21SVWx0NEZzVlVPTFdkQWNEdDZKeFNkUklkN0tfVG9rZW46Ym94Y242c1BZQXh2cUJZWWR6ZUl3OHRDeWVnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>间续滑动条</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjliODhlZWRmZDNmYmY3NTdlZjJlYzc3ZWNiNzVkNTVfZmpsVTJvVmpZWFB5OTl2dkl1bXRBdFF1S2dmUnJ5NGtfVG9rZW46Ym94Y25FcEx5VDVndzg2bDhZclBSazVEdXVnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGNhODEyMmQ3YWQ5MzMxZThmYTUxYjc3NDZmODA5MjRfTlYyTlVhYWg5Qm1LQ2g2SU1HNWdPRlMyTXl5TFBWbkdfVG9rZW46Ym94Y24yMkk1QmJ5RWppMGFXUDI2NWY3UEJDXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="滑动选择器"><a href="#滑动选择器" class="headerlink" title="滑动选择器"></a>滑动选择器</h3><p>当需要从单个维度或多个维度单选进行组合做选择时使用。常用的滑动选择器是时间选择器，用来选择年、月、日、星期、小时、分的一项或几项的组合。滑动选择器的每个维度的值是可以预测的，例如按时间大小排序。对于值无法预测的情况，不能使用滑动选择器。滑动选择器在选择值的时候，默认伴随振动，以提升选择体验。</p><h4 id="类型-9"><a href="#类型-9" class="headerlink" title="类型"></a>类型</h4><ul><li><p>时间选择器</p></li><li><p>其他选择器</p></li></ul><h4 id="如何使用-16"><a href="#如何使用-16" class="headerlink" title="如何使用"></a>如何使用</h4><h5 id="时间选择器"><a href="#时间选择器" class="headerlink" title="时间选择器"></a>时间选择器</h5><ul><li><p>用来选择某个具体时间。一般用来选择年、月、日或者小时、分或者其他时间组合方式，例如月、日、星期、小时、分。</p></li><li><p>时间选择器使用弹出框或者内嵌的方式，在移动设备上选择单个时间（小时:分钟 的格式）。其格式可根据用户的时间设置自动调整。例如 12 小时或 24 小时格式。</p></li></ul><h5 id="其他选择器"><a href="#其他选择器" class="headerlink" title="其他选择器"></a>其他选择器</h5><ul><li>当需要从很多的单选项中做选择或有多个维度单选进行组合时，使用其他选择器。</li></ul><h4 id="时间选择器-1"><a href="#时间选择器-1" class="headerlink" title="时间选择器"></a>时间选择器</h4><h5 id="类型-10"><a href="#类型-10" class="headerlink" title="类型"></a>类型</h5><ul><li><p>月 日 星期 小时 分</p></li><li><p>小时 分</p></li><li><p>年 月 日</p></li></ul><h5 id="月-日-星期-小时-分"><a href="#月-日-星期-小时-分" class="headerlink" title="月 日 星期 小时 分"></a>月 日 星期 小时 分</h5><p><strong>构成</strong></p><ul><li><p>标题：显示“XXXX年XX月XX日星期X”。</p></li><li><p>内容区：显示月日小时分选择器和农历开关。当天显示为“今天”，可以设置今天之前的日期是否显示（场景：备忘录）。可跟随系统设置切换 12/24 小时显示小时分。可根据使用场景，自定义是否有农历开关。当界面上显示农历开关时，农历开关打开的时候，显示农历日期。农历开关关闭的时候，显示公历日期。当界面上没有显示农历开关时，可定义界面是显示公历还是农历。</p></li><li><p>操作区：操作为“取消”、“确定”。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NThhNzg3N2EyZjY4MmMyNmNiYjQ1NDZjOWMzNWM1NzBfWklHaXZSMmc0bE5QV2VJUHllUW1sTTRYd2ZINnRpTmlfVG9rZW46Ym94Y242SGlvTTI0TnQxYmx2WFM5UGVNSWVnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODBkYzc1MjViNmU1YTNlMDdmMDJlZmEwZDlhYzdlZmVfOURuSlhHcWhYV1hVTlJIQVVaUjQ4bmc3VEJhUjNySGlfVG9rZW46Ym94Y25jQVFJbTY4amJta29xZWRHOFAxYzllXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="小时-分"><a href="#小时-分" class="headerlink" title="小时 分"></a>小时 分</h5><p><strong>类别</strong></p><ul><li><p>弹出框</p></li><li><p>内嵌</p></li></ul><p><strong>弹出框</strong></p><ul><li><p>内容区：显示小时分。可跟随系统设置切换 12/24 小时显示小时分。</p></li><li><p>操作区：操作为“取消”、“确定”。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTdlOWMwMDM4MzFkOWM1NzAwNWIyMzE2ODAyMzFhMWRfUUI4aE5kUHJHbjV3WkVEU2IzSlNmb0k4MEkxaXc1QUpfVG9rZW46Ym94Y25yVWJuMWhIajJzd1RGU2NVU01xWHFkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>内嵌</strong></p><ul><li><p>标题：没有标题。</p></li><li><p>内容区：显示小时分。可跟随系统设置切换 12/24 小时显示小时分。</p></li><li><p>操作区：没有操作区。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWJmZTA5M2UyNzNmMjYzZGY3NjJmODRjNzlmMjcyNjVfMHNVYXhVSmdTT1RBeDFLak93MnFWZ1Z5YjQ4WHg4QWNfVG9rZW46Ym94Y25jSVBoc3R1VmZZVG01YUZsVGhsMlhjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="年-月-日"><a href="#年-月-日" class="headerlink" title="年 月 日"></a>年 月 日</h5><p><strong>构成</strong></p><ul><li><p>标题：显示年月日星期。可由应用根据实际场景来定义。</p></li><li><p>内容区：根据业务场景显示所有年份 还是 不显示今年以后的年份(最多显示到今年，及带一个–，表示不选择年）。例如生日场景，年份可以不选。开发可自定义是否有农历开关。当界面上显示农历开关时，农历开关打开的时候，显示农历日期。农历开关关闭的时候，显示公历日期。当界面上没有显示农历开关时，可定义界面是显示公历还是农历。</p></li><li><p>操作区：操作为“取消”、“确定”。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDI2NGFjM2VhNTRmZDk2MzI1MTBiYzg2MDg2YTFmNTRfdWVIY0NSMzJjM055bnNnaTd6YTJVSUFSaGd1SzcyZDRfVG9rZW46Ym94Y25QbTJFM1BUQTBOa3lVc0ZGS1c4NWpiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="其他选择器-1"><a href="#其他选择器-1" class="headerlink" title="其他选择器"></a>其他选择器</h4><ul><li><p>通常有两种：数字选择器、文本选择器。</p></li><li><p>数字选择器默认按从小到大排序。</p></li><li><p>根据选择项的属性选择合适的默认选项，以减少大多数用户的操作。</p></li></ul><h4 id="交互规则-13"><a href="#交互规则-13" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="滑动-2"><a href="#滑动-2" class="headerlink" title="滑动"></a>滑动</h5><ul><li><p>上下滑动来切换选择值。</p></li><li><p>选择器滚动时，默认振动并伴有音效。</p></li></ul><h5 id="点击-6"><a href="#点击-6" class="headerlink" title="点击"></a>点击</h5><p>在当前选择项之外的区域点击，所在选择项递增或递减，点击上方，选择值向下移动一格，点击下方，选择值向上方移动一格。</p><h4 id="视觉规则-15"><a href="#视觉规则-15" class="headerlink" title="视觉规则"></a>视觉规则</h4><ul><li><p>滑动选择为单独一个控件，样式如下。</p></li><li><p>滑动选择器支持多个组合，也支持显示纯文本的形式。</p></li></ul><h5 id="主题样式-12"><a href="#主题样式-12" class="headerlink" title="主题样式"></a>主题样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmVhMGEzNTU4ZTU2OTk4ZTBmNzUxNjQ5MTEwZDQ5NzRfdEFLbGxrTjFrcmZQYkh1cGZqNWdJclhPdHBXeGJiMTFfVG9rZW46Ym94Y25Md1hZU0ZiUngxZVF0MlZ1UjRBdDNiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTA5ODYwMzVhMzRiMDIwYWUwNmNjZGZlNGI1MjY0YTlfY1BPVlo1RlhTSEtFT2dNWmN6TFNYa3ZVaENZZXRkYkFfVG9rZW46Ym94Y25VcFdWbG5oVWlnc09wc3pLeTFMVFZoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGI1Zjg4OWM5YzdjMmZiOGNhZDgyZGMwMDEwYzM4OWFfNWRyd2cwdzk5VmwxUGQxVEE4Q2dwSEN4UExjdkpyV2JfVG9rZW46Ym94Y252akpQWnM4ZVFjT0V6dktjTkxJQzBjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><h5 id="布局样式-4"><a href="#布局样式-4" class="headerlink" title="布局样式"></a>布局样式</h5><ul><li><p>多个滑动选择器可组合使用，界面用语不超长时，选择器的宽度平均分。</p></li><li><p>某滑动器内容较长时，设计师需按内容设计滑动选择器的宽度。当内容超过设计宽度，截断。</p></li></ul><p><strong>页面内使用</strong></p><p>保持左右间隔：24vp</p><p><strong>弹出框内使用</strong></p><p>按照弹出框的规则，距离弹出框左右两边 24vp 间隔</p><p>选择器距离上下 8vp</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDdhNzMxYWRjNWFjYTNkZGZlNDAzNmVkODc2YjYwMzVfbGk1RmQzdmd6ajNLYUR1T1FRVWlKbUtpM0d3T01NUURfVG9rZW46Ym94Y25XaXpJMUdaZ3k1eE5HSEY3cUl4R2hjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>横屏规则</strong></p><p>横屏情况下，选择器仅显示 3 行，其他规则同竖屏一致。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQ1MGQ5NjQ1NzZiOWZmNTkyY2ZiM2QwNDI2OGMzMDBfUzNoaTZBUG42VnNyWXhFdVFxQ1l3NTdvWmxFUklFSHZfVG9rZW46Ym94Y25pZm9rNXBUTG1RS2ljZmdWSzRwc3ZjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-basic-picker-0000000000621791" target="_blank" rel="noopener">picker</a> (JS) 和 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-component-picker-0000001059807909" target="_blank" rel="noopener">picker</a>，<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-component-datepicker-0000001060237839" target="_blank" rel="noopener">datepicker</a>，<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-component-timepicker-0000001060648140" target="_blank" rel="noopener">timepicker</a> (Java)</p><h3 id="即时反馈"><a href="#即时反馈" class="headerlink" title="即时反馈"></a>即时反馈</h3><p>用于在屏幕底部或中部显示一个操作的轻量级反馈。即时反馈是一个临时的反馈，出现几秒后就会主动消失。反馈与当前操作或环境相关的提示，不支持用户与其交互。对于操作结果很明显的场景，不建议使用即时反馈，例如删除一个联系人，用户能够注意到该联系人会从界面中消失，无需用即时反馈提醒用户删除成功。</p><h4 id="类型-11"><a href="#类型-11" class="headerlink" title="类型"></a>类型</h4><ul><li><p>底部提示</p></li><li><p>指示位置提示</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDE2MGE5M2FlYjBhNTBkMDliZWQzYWI4OTgyYjk5MThfN1c5RjZ6WklvcW9aTTRGMVo2bkJ5SjdDOXpnQ2hCYkFfVG9rZW46Ym94Y25icHFqZGFITWI1U3NOTVJFQW04Z2ljXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="如何使用-17"><a href="#如何使用-17" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>希望确保用户可看到某些信息时，使用此类提示信息。</p></li><li><p>若无必要，不要对所有操作给出即时反馈。</p></li><li><p>不阻碍用户在界面上的其他操作。</p></li><li><p>超过规定时间自动消失。不能通过点击，手指在屏幕上滑动的方式使之消失。</p></li><li><p>界面上不能同时出现多个即时反馈。若一个即时反馈消失前，另一个即时反馈被触发，则第一个即时反馈应在第二个即时反馈出现前消失。</p></li><li><p>显示时长：默认显示 2秒。在文本较长的情况下，可以显示 3.5秒以便用户看完所有的文本</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzJlZGYzZDQ4ZjQ3ZjY1ZjgwOGVmODU4MjI1MzhhNjZfY2IzY3I2eUZmRUY2RWhWdnMyRFpSczRzVzlxbTZHN3RfVG9rZW46Ym94Y25FbFRvWlRLZW9NS3ptR3pZOUdnRHRlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="栅格布局-2"><a href="#栅格布局-2" class="headerlink" title="栅格布局"></a>栅格布局</h5><p>使⽤基础栅格。</p><p>4 个 columns 时默认长度使⽤ 2 个 columns，最大可占用 4 个 columns。</p><p>8 个 columns 时默认长度使用 2 个 columns，最大可占用 6 个 columns。</p><p>12个 columns 时默认长度使用 2 个 columns，最⼤可占用 6 个 columns。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjA3MjQ3OTQ0ZTc0OTNlZDkzNWE2ZGM5Zjc2YzJhYTNfa1ZyTERrb3dJTGNMUzVtdE1iZnloNVdJQm5BQkVkQnhfVG9rZW46Ym94Y253QTVvQ3lReVA5dUlBTThtSzJxSUxkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>8 个 columns</p><p>默认宽度：2 个 columns</p><p>最大宽度：6 个 columns</p><p><strong>平板竖屏</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzNhZDdiMzE4NzhiN2YyNDI0YmIzMjAzMWI5MTYyMTZfdVZTcFhnalFMZjhwbGVFWm5mQlZrdHlOZXJEUjhRMmtfVG9rZW46Ym94Y25uZlZNcHhSbnpncmpKamJ6TXZmRnZmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>8 个 columns</p><p>默认宽度：2 个 columns</p><p>最大宽度：6 个 columns</p><p><strong>平板横屏</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJiZjAzNzE0MmY1ODgwNzVlNzNiMDk4YWMzZTI4ZGVfOVE4aTA1aXhKTEp5U3IwNnVJM3VWbjdvU3hKaXVSWUFfVG9rZW46Ym94Y25ETFZzQ0NXbjRyU0J4WUVITzA4ZVhkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>12 个 columns</p><p>默认宽度：2 个 columns</p><p>最大宽度：6 个 columns</p><h4 id="界面写作规则-4"><a href="#界面写作规则-4" class="headerlink" title="界面写作规则"></a>界面写作规则</h4><ul><li><p>以陈述语气告知用户操作结果。用句子或短语，句末不加标点（英文句末加标点）。</p></li><li><p>言简意赅，避免使用大段文字。</p></li><li><p>文本可多行显示。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjI0YTNjMDFiNGZmMDllMzJmZmUzMDczNWRlYjZlNTlfNzZaclpnWk84alYzQmdWVXlmVjdTaHpaMjlZaWVKbnlfVG9rZW46Ym94Y25OeFpxYjFTalBKa2dHM0NyelhDeHhnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h3><p>用于显示内容加载或操作处理进度。用户通过进度条能看到当前任务的一个状态。例如加载内容时的等待状态；蓝牙传输文件的时候，显示当前正在传输的进度。</p><p>在使用进度条的时候，应当结合当前的场景进行设计，尽量将进度融合在界面内容中或操作的元素上，尽可能减少使用进度条弹出框，以免给用户带来复杂感。例如点击一个“安装”按钮后，在“安装”按钮上体现安装过程，而不是使用新的页面或弹出框来显示安装进度。在同一任务中，应避免连续使用进度条弹出框，应考虑整合这些进度条状态成一个状态。</p><h4 id="类型-12"><a href="#类型-12" class="headerlink" title="类型"></a>类型</h4><ul><li><p>明确进度条</p></li><li><p>无明确进度条</p></li></ul><h4 id="如何使用-18"><a href="#如何使用-18" class="headerlink" title="如何使用"></a>如何使用</h4><h5 id="明确进度条"><a href="#明确进度条" class="headerlink" title="明确进度条"></a>明确进度条</h5><ul><li><p>线性显示当前操作进展。</p></li><li><p>在弹出框中，线性进度采用“上方文本+下方线形进度指示”形式。文本为当前操作任务说明，进度“XX%”在右侧。</p></li><li><p>在弹出框中，若操作等待时间过长，需提供转后台操作按钮“隐藏”。隐藏后要在通知栏体现。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODBiNGUzMmYxYTQ0ZjUyNDA3MmI0OGNkOGEzZjdkNmNfWDFKRGFVbUlxQ1FyaFFiT21KV0dqZExoaG50aW4yanpfVG9rZW46Ym94Y24welRFdnpQS1JYdlNINVEwcEtad0tkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="无明确进度条"><a href="#无明确进度条" class="headerlink" title="无明确进度条"></a>无明确进度条</h5><p>无明确进度条（圆形）：显示当前操作正在进行。</p><h4 id="交互规则-14"><a href="#交互规则-14" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="点击-7"><a href="#点击-7" class="headerlink" title="点击"></a>点击</h5><ul><li><p>有明确进度：可终止正在进行的任务。进度条右侧显示“×”按钮。</p></li><li><p>无明确进度：点击返回键可直接终止当前操作。</p></li></ul><h4 id="视觉规则-16"><a href="#视觉规则-16" class="headerlink" title="视觉规则"></a>视觉规则</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmJlOTQxZjcwNDUzMzU1NmQ4ODU3NzViMDQ3ZGIwMzJfenBXMGpmZXlCcktHVWxzQ293bjRWdlJWNlZlZ0xEdmpfVG9rZW46Ym94Y24xRmloaEk2RkdSRVozdVBFUUJJNmpmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="布局样式-5"><a href="#布局样式-5" class="headerlink" title="布局样式"></a>布局样式</h5><p><strong>有明确进度条组合样式（线性）：</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDk0NGVlNDljOGEyZGY2ZGEzZGJhNGVhZDYxYmI3YjZfdXhIbU9sYUpSOWNIZDAxdnhqWWxSOHZHdm5KYVZENnhfVG9rZW46Ym94Y25iaUVCNzN0aTRUNHMwZWFiM3Q1SmpGXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>图标+进度条</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWMyNDhjOTYwMThkYTViMDY2YjFiYmU3ZmUwOGYwNjNfcHZCOG9wYjhlSWJPY291ZHltR3QxZVVPT0ZSMUc3VUdfVG9rZW46Ym94Y25RUVRCdmF4VHFVSm02Z3VIR2NYZzZlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>图标+标题+进度条</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDVlMjlhZDkwMDE4YjZlNzBjN2RmMDQ2MTNmZTJiODRfbHRpeGs4WkJUWW9JdmRaVWM1MmFwSkpWbHJyUFRXVm5fVG9rZW46Ym94Y25yR0x1MlZ4cDFLdEl0NmtGRDdkMTRkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>图标+标题+副文本+进度条</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzE5ODJhM2U3ODRlMTI5NzM5MjM4ZDBiZTA5MDQ4NDlfSVZYcHFpQWpHT2lnT2lpM0VsbVZQMDZUR0FBYVlMYzhfVG9rZW46Ym94Y25xM1dBQUZqNjBvU3lIQmg3b1pvQUtkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>文本+进度条+关闭</p><p><strong>有明确进度条组合样式（圆形）：</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2M2MTRhY2U5MWRmNWRkNTA0YzQwMmU5YWVkZDYzMGFfRjBFUWp0bEJJODVoSG0zdEJFak9IYUZpSWNiUXU5QUtfVG9rZW46Ym94Y25IRE50TDV5aG9sYUJsc0FvQ3ZDWWFoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTg5YzJkZWI3MjE0NWNhYWIxZDRhOTE1ZGUwNTBkMTBfekx5OHBoeXhHTkF5UVNyZTBDN1hyak1HUFBoNkR4STdfVG9rZW46Ym94Y242ZTA5eXNmV2xxOVV1and4RWFHbjFmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="界面写作规则-5"><a href="#界面写作规则-5" class="headerlink" title="界面写作规则"></a>界面写作规则</h4><ul><li><p>有明确进度：可看清任务对象和进度的，建议不用文字。若要使用，文本为：操作说明+进度“XX%”。</p></li><li><p>无明确进度：文本为“正在xx…”，不用“xx中…”。</p></li></ul><h4 id="界面用语超长处理-1"><a href="#界面用语超长处理-1" class="headerlink" title="界面用语超长处理"></a>界面用语超长处理</h4><ul><li><p>右侧文本最小宽度 1/3。</p></li><li><p>超长左右文本均可换一行。</p></li><li><p>依然超长，采用截断＋“…”方式。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmU3ZWU3M2MzNmMzNzM5ODI0Nzk4MmRkMzhjMGVkYzRfNUs2SlEyRERzbHpUbmJtWWhLanZKVWF0UzRtNE5WSUlfVG9rZW46Ym94Y25VQmFOTmVvZmJ3NmlYclVtQVpYaHBoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="卡片"><a href="#卡片" class="headerlink" title="卡片"></a>卡片</h3><p>卡片目的是处理信息集合，提升阅读效率。卡片作为一个容器，可将内容按逻辑进行分组，帮助用户快速获取信息和进行操作。</p><h4 id="类型-13"><a href="#类型-13" class="headerlink" title="类型"></a>类型</h4><ul><li><p>单体卡片</p></li><li><p>组合卡片</p></li><li><p>可滑动面板卡片</p></li></ul><h4 id="如何使用-19"><a href="#如何使用-19" class="headerlink" title="如何使用"></a>如何使用</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDAxNTA0YjBmZDFjMzA1NzgxOWJmZGQ0NjdiNmQ1ZGFfNVZheHFHaTFnczJJUjRSWHhEZzJRNnozVnprYXplcG5fVG9rZW46Ym94Y25yVW85bnJxdnY1cFcyNUJ4MWRiWHpmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjcyNDZiZDY1YWI1M2QwNjdlYWEyMTFjZDM0NzBmYTFfT2Nmem1RRXcxZ3JXb1VJcEljb3k3djJtOFd5SDdrT09fVG9rZW46Ym94Y25qS05zbGpIREF1ZENZZDBNRTZsaDNmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="视觉规则-17"><a href="#视觉规则-17" class="headerlink" title="视觉规则"></a>视觉规则</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzRkODZhNGFiM2FiMmExYTU4MjU0MzI0NTFjOGFlODNfN0EwWU1rYTJOUEc5a1NTSDJia2o4TDhEaWNEQ294OEdfVG9rZW46Ym94Y245d1prMlgyazk1eU5lVzVMazlmc0dnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="主题样式-13"><a href="#主题样式-13" class="headerlink" title="主题样式"></a>主题样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGQ4ODhlYzc2MDYxNWJhOTJhYzkwZWQ4MGI5NDNiZTVfdUtWVWkxN2ptWTdoSGtsZlpicDFPOUNtamNMcTVmeXpfVG9rZW46Ym94Y255OTdsbzZ4NGExUXQweGl0bkdMd0lkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzQ3NmRjNzQ3YTRiMjliMDM4Njc4ZmRkOGFkNjI0NjZfaDdSMkRWaXFIRGZSVnp4YUhuaEdnUW02dDNlU0VxNE5fVG9rZW46Ym94Y25od2xjdEk3c2NNbTBwWkNBSjYzd3VnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTFhZTU1MjE1MGQ4OWU4YWI0MTEwOGJhYjQ5NzllNzhfTnh3aHN3dzZrUTVnM0hDcjdHYmlKcmVYb2ptaXpWejNfVG9rZW46Ym94Y244REJjeEpTbTluOUNnSUtPMGM5SUdnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><h5 id="栅格布局-3"><a href="#栅格布局-3" class="headerlink" title="栅格布局"></a>栅格布局</h5><p>卡片栅格使用：</p><p>系统卡片都需要使用卡片栅格</p><p>卡片栅格定义：</p><p>margin=12vp，gutter=12vp，columns=4</p><p>margin=12vp，gutter=12vp，columns=8</p><p>margin=12vp，gutter=12vp，columns=12</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDAyZGEzMGQxMTliNzBiYTQ3ZTQwZWQ1ZDJjY2VhYjBfVGJacGlmQVdsQklzRmhQaFdsZnQ0MVFYOUVVMDlYY1pfVG9rZW46Ym94Y243T3BidVdNNURTR2RSUElEY01MbVpnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="栅格运用实例"><a href="#栅格运用实例" class="headerlink" title="栅格运用实例"></a>栅格运用实例</h5><p>缩进效果：</p><p>为了保证舒适的阅读性，建议利用栅格控制卡片的缩进效果。</p><p>规则：</p><p>4 个 columns 时使用 4 个 columns</p><p>8 个 columns 时使用 6 个 columns</p><p>12 个 columns 时使用 8 个 columns</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Y5NjQ4ZGMxYWNmODExMGIxOWFmNTEyYjM1ZWQ4Y2FfYnVjRVZOeDFyNTlRYzBkUlJLN21iaWd2WHloNHd4Z3JfVG9rZW46Ym94Y255YmN1T210SlcwalYxMEQ4WmpEczhjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="动效规则-1"><a href="#动效规则-1" class="headerlink" title="动效规则"></a>动效规则</h4><p>卡片主要的动效特征：</p><ol><li>共享容器，会产生自身形状的变化，随着容器形状的变化，会从一种信息状态（缩略信息）变化到另一种信息状态（详情界面）。</li><li>物理弹性，用户在点击、按压卡片时会产生物理弹性。</li><li>实体层级，卡片会产生Z轴向的变化，以表明所处的层级。</li></ol><h3 id="开关"><a href="#开关" class="headerlink" title="开关"></a>开关</h3><p>开关的位置位于所要设置项的后面，通过开关，可以开启或关闭某个功能。开关操作会使设置的状态发生变化，因此在有些场景下，从开到关或关到开，会有个状态的延迟显示。例如开启“蓝牙”功能，蓝牙从关闭到开启需要一定的时间，用户会看到一个短暂的变化过程。</p><h4 id="如何使用-20"><a href="#如何使用-20" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li>开关用于设置项的开或关。</li></ul><h4 id="交互规则-15"><a href="#交互规则-15" class="headerlink" title="交互规则"></a>交互规则</h4><ul><li><p>点击或者滑动开关：开启或关闭功能项。</p></li><li><p>点击列表其他区域：不响应开关操作。</p></li></ul><h4 id="视觉规则-18"><a href="#视觉规则-18" class="headerlink" title="视觉规则"></a>视觉规则</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmNiYTIxZDAzMTNmOWM0N2Q3NDQxMjBlNDAzN2RhNDJfQU15RjVPcjl6U1dFV3lYclYydllFbDd4czQ0M2NlU0VfVG9rZW46Ym94Y24wM0RHeWpOaHlKVGk2Skt0ZlNEQnljXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjY3OGYwYWEwYjQ0MmUzNDZhNjdlNTVlNWE0N2JhNWJfd3NNUlN6V2EyRXE1cUZpNUNUaGZ3bXNJNlU5MVdzaVpfVG9rZW46Ym94Y25VQ250b3JCamRiZklZUjV0WmEyQ0hnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表包含一系列相同宽度的列表项。适合连续、多行呈现同类数据，例如图片和文本。列表按一定的规律排序，例如按时间排序，按字母排序等。列表项可以包含文本、图片以及操作，每一项中的元素布局都应该保持一致。</p><h4 id="类型-14"><a href="#类型-14" class="headerlink" title="类型"></a>类型</h4><ul><li><p>通用列表</p></li><li><p>多选列表</p></li><li><p>可展开列表</p></li><li><p>可横滑列表</p></li></ul><h4 id="如何使用-21"><a href="#如何使用-21" class="headerlink" title="如何使用"></a>如何使用</h4><h4 id="通用列表"><a href="#通用列表" class="headerlink" title="通用列表"></a>通用列表</h4><p><strong>构成</strong></p><p>列表的布局元素分左中右三部分。左侧为图标，中间为文本，右侧为值、状态或者操作。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmRiOTA0OTQwYmNkODk4MWJlNDI4Mzk2MTNjYWQxN2VfNk9IMFFoQzJ1dlNlZlZUc2pnMFRwejdTb2dLT0I4c3BfVG9rZW46Ym94Y25PdlZpaUdVSmZaRWtVcktGaXFZV0hnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>左侧元素为表意图标，支持多个尺寸。图标与屏幕保持24vp边距，图标与中间列表内容保持16vp 间隔</p><p>中间元素为列表文本，支持单行、双行、三行和多行文本。多语言下文本支持无限换行</p><p>右侧元素分为非操作的辅助文本和可操作的按钮。右侧元素与中间列表内容保持16vp 间隔</p><p><strong>规格</strong></p><p>当列表为单行文本，且没有左侧元素时，列表高度默认为 48vp</p><p>当列表为单行文本，左侧有元素且小于 40vp 时，列表高度默认为 56vp</p><p>当列表为单行文本，左侧有元素且左侧元素为 40vp 时，列表高度默认为 72vp</p><p>当列表为双行文本，且没有左侧元素时，列表高度默认为 64vp</p><p>当列表为双行文本，左侧有元素时，列表高度默认为 72vp</p><p>当列表为三行文本，列表默认高度为 96vp</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzNmMTNmNThlYTc3YjE2N2NkOTI5ZjhlNTg0MjZkODVfbDd2QzRja01KR0JOT0dLZ0FMMktJMU41YnNLOU5XTTFfVG9rZW46Ym94Y25hSGpDc1I0QjZwYnIxbVJXTXdiN05lXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTE5NTJiNDhiMjE0ZWUyMWU5MWY1YjZhODZlMzgxODZfMk5PS3N0Z1RrWlduNDJwZDRteGZSbWZlUFAyNWhPRTlfVG9rZW46Ym94Y24wRUVvRWc1QUZIREZQVEswamVhaWhPXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>左侧元素组合：图标/头像/预览图</strong></p><ul><li><p>图标可跟列表居中对齐或顶端对齐。</p></li><li><p>左侧图标支持小圆点（小圆点应用可指定颜色）。</p></li><li><p>一般情况下，每个元素之间保持 16vp 间隔。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWQyMmExYjM0NmM2ZTE5N2U3ZWRjOGQwOWM5YzA0MDRfYVVUQTBtcm15dGtwWW5DMk55cHI4SkpFNk9xSlpvQ1VfVG9rZW46Ym94Y25CQ3dRbzc5cUp6dEE5YkFZNTNJZ2lnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>出现新消息提示的情况下，新消息元素左右两边使用12vp 间隔。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzYxMTMwZTM0MTVlN2E1MmE1OGU4NTVlNzg2YjE2NjZfckp1OTBNWjVFN1oyYVZCT0hadWJ3ZUJKYlBRM0Y5bkRfVG9rZW46Ym94Y240Yk9uYlprdGdlSDd5VDZhOXc1VVdoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjczZGNjMjJlMDE2MDdmMjI5YTA2NTBlOWQ4NzI1MjlfUlFWbUs3eDFxdFpTWTVBQW01d21FMFY3Tmh5eDBKYjVfVG9rZW46Ym94Y25oVENuOGZZcllLVjlJQUUyWDQyNE1iXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>右侧元素</strong></p><p><strong>右侧元素组合：图标/文字/功能。</strong></p><p>右侧支持功能图标或文本或图标+文本的组合。常见样式如下。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWIwMDE5Njc1NjljMmEzMmMxZTE5MWI5NmU1MGU0YjVfUDBLUFJNQ3hFdVVaVW4ySmhEckppWGsxbFhkcENpMmZfVG9rZW46Ym94Y25SSWszV2pnT3VOV3hYUGJ1SXZIZnZkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTY5MzE2NzE2ODc3ODQ2ODliODg5MDhmOTljNGZlYjVfeUxFY2ZaYWpWMVZ4VnFUZW9RSG9EVEl3c0Y4TERSR1JfVG9rZW46Ym94Y25KVVZQUW93cDZmSU01b201WnVwQmVnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>中间元素</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmUwYzg4MjM3M2VjNmZlNWQ1OTMwZWIzNTVhMjVjZTJfSEJ2T0YzRXlDNm5wMlNVM3BTYTRXdVppOGpLMjVWQXdfVG9rZW46Ym94Y24zMHZ6OFBySTZTNE1NTmJ3eUlyNWRCXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>图标/Label+中间文本</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGVmMDVhNzlmZGY4NzY5OTY3MjgyZmYwNDUyNGE3NDdfZW1EUnlDVkJDQzBxZkQzN1ZFMGUwU3BCdG5MbHlNN3NfVG9rZW46Ym94Y25qbUFNdkhGTmpwV1lFY2lVTkI1MExoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>带进度条列表</strong></p><p>进度条居中显示。上方左侧为标题，右侧为值。</p><p><strong>点击效果</strong></p><p>列表点击整行响应。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWRiMmU0Nzk5MzhmYzdhNWI1OTY1NDViM2JiMDQ4MDlfM2h1V3hDVGlwOE42b2VwMG95MFExbDNIVXhvYVJ6N2RfVG9rZW46Ym94Y25QcUhvVlNNM3g5ZEppRXlRTjB2WDFiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>点击效果列表叠加 10% 不透明，#000000</p><p><strong>悬停效果</strong></p><p>列表鼠标悬浮整行响应。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDcxYjAyMWU4ZmQ5ZmEzNzU1ZTMyMmVhNmM2OWI0MTVfUkxKUWN6OHhvUDdrMlFtMFlEUWEybHAwSTdtVkVBaEZfVG9rZW46Ym94Y25IdGdvb1ZKSFFreWZmRnJHNGU3ZGltXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>悬浮效果列表叠加 5% 不透明，#000000</p><p><strong>激活效果</strong></p><p>列表激活整行响应。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGI2MzYyMWFjYTg1NjYxOWE3NzRhZjg4OGVmOWFhMWVfa1RHN3BoWDg1ODVKOXFqTjZkMVBPUTlvR054ZWthOHlfVG9rZW46Ym94Y245QjNtNzFDN2JuV0hUM1JlSjJ4cXpmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>点击效果列表叠加 10% 不透明，#0A59F7</p><p><strong>走焦效果</strong></p><p>列表光标走焦整行响应。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTdkZWYyYjlkZGE1YjdkMTM2MjAzOTM1ZjhjMDY1ZWVfZ2NFNFVFT3VUT0FoaDVocU1SNW1OazJCMjlQekk0WlFfVG9rZW46Ym94Y25kUzFubHRxZkxnakNwakRzOEptUWtZXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>走焦效果列表叠加 2vp 粗细的描边</p><p><strong>下拉或上拉效果</strong></p><p>当整个界面充满列表时，在列表下拉到顶后继续下拉松手会有回弹效果或列表上拉到底后继续上拉松手有回弹效果。</p><p><strong>列表排序</strong></p><ul><li><p>列表在拖动编辑顺序的状态下，左侧出现拖动按钮，拖动按钮热区 48x48vp。</p></li><li><p>被拖动选项添加投影效果，悬浮于其他选项之上。</p></li><li><p>带阴影效果。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzdiNWM2NDE0MzU2MmI4ODllNWQ1MmU1NzA4ZjYwZGZfN0V0bWtYVnE4RmczMmFKYU1tamNnQ2l3VTFmQ2tTS3BfVG9rZW46Ym94Y25FakEweEJYaGNMVURiOG96TlR3NEJnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="可展开列表"><a href="#可展开列表" class="headerlink" title="可展开列表"></a>可展开列表</h4><ul><li><p>有总分关系的列表可提供展开和收拢箭头。</p></li><li><p>折叠子项要往里缩进 24vp，只允许一级缩进。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDc2YjQwZjc0NjBlNzhiY2VjZDljYmZkMThiMTY4MGJfaVpaNWxveWxhdGo5d2RYaTlhZ0g2a3N1MHpLc1NDdThfVG9rZW46Ym94Y240UEd4eEt1YWpKSm5yQjJ3OTc3N0doXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="视觉规则-19"><a href="#视觉规则-19" class="headerlink" title="视觉规则"></a>视觉规则</h4><h5 id="主题样式-14"><a href="#主题样式-14" class="headerlink" title="主题样式"></a>主题样式</h5><p>列表支持浅色主题、深色主题和半透明主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2ZkYjI1OGQxNzA4M2NiODU2OTEyZmRhMzE0ZjQ3ZWRfdVRyZGJPeXpmOGRDUWRvNEFja2lEaVR4SDVQeG1Zd3BfVG9rZW46Ym94Y25YZXh3SWhOY1I3VWtCS1ZRWWpZZk9jXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2MyODIwZTk1YWRhNTljYjFmZWM3ZWNlZGRiMjMzMmJfZjhFekNlWGp5UFZPUUI3N2ljUGF4VHFpY1VQMzViN0hfVG9rZW46Ym94Y25XbkUyOWk3dVMzM2hvanBXTkl6TUFkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTMyNmI3ODJhYzA2YWY4N2YxZTI1N2ViNmUzNmJkY2VfZ3hpenNpY0Y0UmN6Z2hkUlVlVGprNm96MHpTM2FqVWdfVG9rZW46Ym94Y25OT3Mwa2l5WFBZVmNJOHlHUW1wZTdjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><h4 id="界面写作规则-6"><a href="#界面写作规则-6" class="headerlink" title="界面写作规则"></a>界面写作规则</h4><h5 id="通用规则"><a href="#通用规则" class="headerlink" title="通用规则"></a>通用规则</h5><ul><li>尽量用一级文本（主文本），不用二级文本。一次把话说清楚。</li></ul><h5 id="二级文本写作规则"><a href="#二级文本写作规则" class="headerlink" title="二级文本写作规则"></a>二级文本写作规则</h5><ul><li><p>二级文本以短语或句子形式呈现。通常是对一级文本的补充说明，句末不加标点。</p></li><li><p>不与一级文本完全重复或部分重复。</p></li><li><p>不提及用户。</p></li></ul><h4 id="界面用语超长处理-2"><a href="#界面用语超长处理-2" class="headerlink" title="界面用语超长处理"></a>界面用语超长处理</h4><ul><li>功能说明型：文本支持无限换行，保持文本上下最小 8vp 间隔。</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWNkZTIyOWNjMmRkNWVlMjUzNWNiOWNiZWY5ZmI2YmVfNEV5MVNwVGN5aUJtS1pRV2g1c0JVV0NDYlRpNWsxeVhfVG9rZW46Ym94Y25KcVN4MW41dFM0dk0wMWRidFlwZ05lXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><ul><li>内容预览型：文本不支持换行。</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWE4MmUzYzFhOTI3MmVhYmFlM2E4NGUyOTFiYzhhMDhfTnJWSXhIREtMdXZsM2FLdG95bUtVSzRXMTBIeEpldnBfVG9rZW46Ym94Y25ZNVFhcnA4RHE2SWRITUFBd1MxaUtoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><ul><li><p>左右组合文本界面用语：优先保证左侧文本的完整度，右侧文本最小保持 1/3 的屏幕宽度。</p></li><li><p>超长支持无限换行。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmNhMWE2ZTgzZTBlZmI4MTdlODgyNmMzMjRhMTEwYzBfQkEwQmFLNHVsNGVQSzJTZUpXZ3hRMXhuZ2c1M3pyV1ZfVG9rZW46Ym94Y25vZG1jeGM0NjhxVmFyMEdFeGRSZWtnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-container-list-0000000000611496" target="_blank" rel="noopener">list</a> (JS) 和 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-component-listcontainer-0000001060007847" target="_blank" rel="noopener">listcontainer</a> (Java)</p><h3 id="评分条"><a href="#评分条" class="headerlink" title="评分条"></a>评分条</h3><p>评分条用于用户对内容、商品或物体的主观评价，分 1－5 颗星，1 星最差，5 星最好。评分条支持点击评分，也支持左右滑动评分。常见场景有应用市场、论坛等。</p><h4 id="类型-15"><a href="#类型-15" class="headerlink" title="类型"></a>类型</h4><ul><li><p>可操作评分条</p></li><li><p>不可操作评分条</p></li></ul><h4 id="如何使用-22"><a href="#如何使用-22" class="headerlink" title="如何使用"></a>如何使用</h4><p>在评分条下方，显示每个星级对应的评价，根据打分动态变化。</p><h4 id="交互规则-16"><a href="#交互规则-16" class="headerlink" title="交互规则"></a>交互规则</h4><h4 id="可操作评分条"><a href="#可操作评分条" class="headerlink" title="可操作评分条"></a>可操作评分条</h4><p><strong>点击</strong></p><p>点击星形图标对内容进行评分。</p><h4 id="不可操作评分条"><a href="#不可操作评分条" class="headerlink" title="不可操作评分条"></a>不可操作评分条</h4><p>用于展示当前内容已有的评分结果，不能直接对其进行评分操作。</p><h4 id="视觉规则-20"><a href="#视觉规则-20" class="headerlink" title="视觉规则"></a>视觉规则</h4><h5 id="主题样式-15"><a href="#主题样式-15" class="headerlink" title="主题样式"></a>主题样式</h5><p>浅色主题、深色主题、半透明主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmUxMjI5YWM0MTk0OGY2ZTY5N2IzNzM5MDgzNGI2ZDVfbWxlaEx3YlpNS25kYWY1U2o5SzU4WEFkVTI5anRjRjFfVG9rZW46Ym94Y25FUVlrN0lVeXhLTFNTRklVRUFlWU1jXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="布局样式-6"><a href="#布局样式-6" class="headerlink" title="布局样式"></a>布局样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWExOGYyNTdmOTAwNGQ2OWE0MmFjZWEwN2M0OWM0MjBfRHF1Nkp2b0lBdEZmbHBCblkyWGpvZHhJQjNPOXlQdWdfVG9rZW46Ym94Y25BWUdDa1VFWTdqRTJZaEtyeW1JQ1FlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="气泡提示"><a href="#气泡提示" class="headerlink" title="气泡提示"></a>气泡提示</h3><p>用气泡指示当前功能如何操作。当用户初次进入界面时，使用气泡提示来告知用户某个功能如何去使用，气泡指向与提示强相关的元素或区域上。气泡提示是一种轻量的提示，一般不阻碍用户的操作。在气泡提示出现的时候，用户可以点击界面上的其他区域进行操作或滚动页面或点击页面空白区域，在操作的同时，气泡提示会消失。对于带操作的气泡提示，需要用户点击操作后才能消失。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTVlM2MxMGVjZGI2NTIxNTc4NDliODdlNWNmYTJkYTlfV21JbTFMRmJNa1FHd09uaEZWbnNIQnRlbGhrNlo4OXVfVG9rZW46Ym94Y25FQXBobVdBcHBUWmRJbWZTdGo5ZktoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="如何使用-23"><a href="#如何使用-23" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>气泡提示只有向上或向下指示箭头。</p></li><li><p>提示简洁明了，避免设计复杂。</p></li><li><p>刚进入某界面时给出提示。</p></li></ul><h4 id="交互规则-17"><a href="#交互规则-17" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="点击-8"><a href="#点击-8" class="headerlink" title="点击"></a>点击</h5><p>不带操作的气泡提示：点击屏幕任何区域或导航键或界面上的操作，气泡消失。</p><p>带操作的气泡提示：必须点击气泡中的操作后，才能消失。</p><h4 id="视觉规则-21"><a href="#视觉规则-21" class="headerlink" title="视觉规则"></a>视觉规则</h4><h5 id="主题样式-16"><a href="#主题样式-16" class="headerlink" title="主题样式"></a>主题样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Yjk4MDY1ZTU5ZGUwMGVmZmM5OWU3ZGYwNTQzYjA3MGJfOGNNN0tPRjFHSkpzUUVWdlNDNkRRTXBZZ0lIdHhjWTRfVG9rZW46Ym94Y25Uc09zbmxMZWlXNTdlUDNWMmMzVHJnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="布局样式-7"><a href="#布局样式-7" class="headerlink" title="布局样式"></a>布局样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDNkYjhmMWY4NmRjMzhjOGQ5OWZiMzkwNDJiODA2Y2VfWXdrQ0k0WGc0M0xVU3daSzRNM09MR0xseUdYMUJldWlfVG9rZW46Ym94Y25Sbk1MYVlKbTMxeThiUzFMalFGZkpiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="栅格布局-4"><a href="#栅格布局-4" class="headerlink" title="栅格布局"></a>栅格布局</h5><p>使⽤基础栅格。</p><p>4个 columns 时，最大可占用 4 个 columns。</p><p>8 个 columns 时，最大可占用6 个 columns。</p><p>12 个 columns时，最⼤可占用 6 个 columns。</p><p><strong>手机竖屏</strong></p><p>最大宽度： 4 个 columns</p><p><strong>平板竖屏</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQ5NzYyYmJhZTJjNzk2YzhkODkyNjkwYTUzMDEzYTRfckRiMDZBcUNTb2czTlRxZVp2YjRMbnVyS0pmc3FhdkxfVG9rZW46Ym94Y25yamtyUHhxQUtXczd3M2hqTGpod2JoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>最大宽度： 6 个 columns</p><p><strong>平板横屏</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTFmODBhZGJlZWM4MTUyOTA0MDY5MDg2MDVhOWVkYWFfU3hRZlp1Sklmck9NTDlwTVdlZVY4U3Qycm1paHNQWTdfVG9rZW46Ym94Y25IYWhiZHZUdVpSUUtFWjJmV3FqSmFkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>最大宽度： 6 个 columns</p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-container-popup-0000000000611584" target="_blank" rel="noopener">popup</a> (JS)</p><h3 id="搜索框"><a href="#搜索框" class="headerlink" title="搜索框"></a>搜索框</h3><p>提供用户搜索内容的输入区域。通过搜索，可以快速的找到并定位到想要的内容。搜索框还可以结合搜索历史记录，输入自动补全，语音输入等功能，方便用户快速输入查询。搜索框可以和业务功能放在一起使用，例如扫一扫。在搜索框有输入内容的时候，可以点击搜索框内的清除按钮，一键清除输入。</p><h4 id="如何使用-24"><a href="#如何使用-24" class="headerlink" title="如何使用"></a>如何使用</h4><p>用户需要通过搜索功能来找到想要的内容，且该页面需要突出搜索功能时，使用搜索框（该页面不需要突出搜索功能时，使用搜索图标）。</p><h4 id="搜索框构成"><a href="#搜索框构成" class="headerlink" title="搜索框构成"></a>搜索框构成</h4><p>搜索框由左、中、右三部分组合构成。</p><p>左：返回箭头（可选）；筛选功能（可选）。</p><p>中：输入框，含放大镜图标（默认为放大镜，可根据场景自定义其他图标）+水印文字+语音图标（可选）。</p><p>右：功能图标（可选）。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWE2YThjMzI0ZWVhYzY4ZDVhNDgzYjc3MDI1MDFjMmRfdFlhSUVGaHpHZThSNHFqTzZNRkdMdUpHRjYwN1hHVGZfVG9rZW46Ym94Y241dVpBUTlqN3J1ZEg5cDBBa3c4bzliXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>使用放大镜图标的搜索框</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjAxNzA2MWE1Y2I2N2YxYTVmNzkwN2RiNDkwODZiZjFfOXlGMDJrazFpWnh2RUFrVWRUMmJSaFgzWkg0STJRV3lfVG9rZW46Ym94Y255dUhzZGZRdEYzRW80MmdkbjRYaVNoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>使用自定义图标的搜索框</p><h4 id="水印文字"><a href="#水印文字" class="headerlink" title="水印文字"></a>水印文字</h4><p>显示水印文字，帮助用户了解可搜索什么内容。</p><p>无运营需求的应用：水印文字采用动宾结构，中文为“搜索XXX、XXX、XXX…”或“搜索XXX”。</p><p>有运营需求的应用：水印文字直接显示运营文案，常见于应用市场、视频、阅读等内容类应用。直接将水印文字作为搜索关键词进行搜索。</p><h4 id="交互规则-18"><a href="#交互规则-18" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="点击-9"><a href="#点击-9" class="headerlink" title="点击"></a>点击</h5><p>点击搜索框：输入法没有显示时，点击搜索框，显示输入法。</p><h4 id="组合样式-1"><a href="#组合样式-1" class="headerlink" title="组合样式"></a>组合样式</h4><p>支持以下组合：</p><p><strong>组合方式：中</strong></p><p>搜索图标＋水印。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTIyMmM3NmYwNzRlZDQyNmE1ZmE5ZjlkODhiYzNmMGJfTktwa21SSUw0eDlzd1BMOUd6WjQ1d1ZUeUFTcFdmNGNfVG9rZW46Ym94Y25hWGFMa1J6NEJCdFdoVGlhV1d5d3JlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTEzNWI2NjBiODhjMzJmNTA4MWVhNWRhNDEyMDI4NmJfQ2VyREt0SmcwQ1pUd3V2WHFCcVRZMm44UGdSVXZrbDJfVG9rZW46Ym94Y25oVWYxY0FIYVVOaEkxeUFWZ0hiNGFlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NThkOTI5OWUzZjQxMDNmNWQ3MDhkZjg3NzU5ZWVlOTRfaVkxT1NraDJjNTdVUjJ0V1lqZDkxZWVsTGw0blpnbVBfVG9rZW46Ym94Y25vRjZwRlczckJVV0xYa0NRSzNzVzhlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="视觉规则-22"><a href="#视觉规则-22" class="headerlink" title="视觉规则"></a>视觉规则</h4><h5 id="主题样式-17"><a href="#主题样式-17" class="headerlink" title="主题样式"></a>主题样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQ1MThjNzhiYWUyZTdmNGE4ZmMwN2MyNTk0ODNlOWJfUDk2b3ExVmhVYnBSR2RXMUdNQmNJMXc5UGlKQlZ2YmZfVG9rZW46Ym94Y25kMXhJc21jTzl0bTFESTVZclg5WFZoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDc1YTYzMzIyMmFjMTkzYzliNjEwYzE3ZjkzZGJmYThfWDZjbTRyUG9ndkpTY3hsWm0xUHRnUVo3dWlTV3FnS3RfVG9rZW46Ym94Y25VYXZ4akFkdHNKcFhFRUVteHZCMDViXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzdkOGYzNzZjZDRlYjQxN2Q2ZGE3YmRhZmU0YjA4MTNfQzh2MVROMTVmTjhaVzdOaGR0M3pWY2t0UGJTcWI5eGNfVG9rZW46Ym94Y25YV3pvUDRrRkV6MTVhRzhqQmR6b1NoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-basic-search-0000000000618599" target="_blank" rel="noopener">search</a> (JS)</p><h3 id="索引条"><a href="#索引条" class="headerlink" title="索引条"></a>索引条</h3><p>对按字母顺序排序的列表可快速定位的操作条。用于快速精确定位，例如联系人列表查找联系人、天气（添加城市）、世界时钟（添加城市）。在联系人列表界面，索引条还提供二级索引来加速定位，例如在中文环境下，先通过主索引定位出以该字母开头的联系人，再将联系人的第一个汉字进行二级索引，用户通过二级索引快速定位到对应的联系人。</p><h4 id="如何使用-25"><a href="#如何使用-25" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>界面内容按字母顺序排列时，需使用索引条。界面内容不超过一屏时，索引条不显示。</p></li><li><p>当使用索引条时，横竖屏均需要显示字母索引。如果字母索引显示不下，则使用缩略的方式显示。</p></li></ul><h4 id="交互规则-19"><a href="#交互规则-19" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="点击-10"><a href="#点击-10" class="headerlink" title="点击"></a>点击</h5><p>点击字母索引条上字母，内容跳至所点击字母区域。</p><h5 id="滑动-3"><a href="#滑动-3" class="headerlink" title="滑动"></a>滑动</h5><p>在索引条上上下滑动时，界面显示内容需同步滚动，以匹配手指在索引条上的字母位置。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWI1NmNkM2UxNjY4ZDcxMjNjNmQxMDBlOGNmM2UzMGZfVmlHcUFZa0VaZVlFTEF1aHNiTzYxbG1jSGEyTDFPSldfVG9rZW46Ym94Y243TTRZUEFTbTIwRWczVk15UXFWZTZlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="视觉规则-23"><a href="#视觉规则-23" class="headerlink" title="视觉规则"></a>视觉规则</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2I4NWQxMGU4YWU4MmM4ODk3MDllMTgzYWU4MmQwNDZfVTFaVkd6RnFUVzRnQ3BEYWpuWjNZQjVkaFFsRGxNd2ZfVG9rZW46Ym94Y25qR1FQbzZtS2p1Wkw5cklvTzFseWVWXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="主题样式-18"><a href="#主题样式-18" class="headerlink" title="主题样式"></a>主题样式</h5><p>浅色主题、深色主题、半透明主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2RkN2E1ZjY5Mjk2OGY5N2IxMDRiNWQ0NDEyYzU1NDJfOXBQbWR3WUZvVEVpVTI1Q0hMNEswMXVuVHBTYzh1dUFfVG9rZW46Ym94Y25vVXJrZ3dZRW1aR2x0UXJkdm9kVHhnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="布局样式-8"><a href="#布局样式-8" class="headerlink" title="布局样式"></a>布局样式</h5><p>索引条的位置需要在界面中保持一致。通常情况下，默认索引的位置是界面总高度去除顶部状态栏+底部工具栏/底部页签，然后居中展示。</p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-container-list-0000000000611496" target="_blank" rel="noopener">list的indexer属性</a> (JS)</p><h3 id="文本框"><a href="#文本框" class="headerlink" title="文本框"></a>文本框</h3><p>文本框允许用户输入文本、选择文本。支持输入文本、数字或者混合格式的数据。</p><h4 id="类型-16"><a href="#类型-16" class="headerlink" title="类型"></a>类型</h4><ul><li><p>单行文本框</p></li><li><p>多行文本框</p></li><li><p>全宽文本框</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTU3OGU4NjBkMDZkODQzNWMwNDQ3NjkwNmUxMDdmZGNfcU5FWnZselpGTHQ1MDk3S21tdjVOWGk1aGpYM2RxbTlfVG9rZW46Ym94Y25UM3BhWEhKYnZlZFllRlFYeWswOTNnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="带图标的文本框"><a href="#带图标的文本框" class="headerlink" title="带图标的文本框"></a>带图标的文本框</h5><p>按钮对输入文本起作用：按钮显示在文本框右侧，按钮用于直接作用于文本框内的文字，最多放置1个图标。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzYwZWNlZWJlNDk0MWEyOWQ4ZTJkOGJkMzM3OWYwY2NfYWMwN2w5SnlsaDZDVEtTdjkybEYzamJSSVhtb2ZsTUhfVG9rZW46Ym94Y25xc0JwUHhzaFBQelVubDhGTkt0T2RnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="后面带单位的文本框"><a href="#后面带单位的文本框" class="headerlink" title="后面带单位的文本框"></a>后面带单位的文本框</h5><p>单位嵌套在文本框内，点击单位可切换单位。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzI4OTE4YzMwM2NiOTgwM2U5OGNlNDNiNDgxYzM1NzBfUE16VXVubml3OGQwdU1SdHdJQWJZYjNuNEkxcDFybFZfVG9rZW46Ym94Y254ajkwejFXdmpPM3lWOFZpa29oclNoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="带-号标记必填项"><a href="#带-号标记必填项" class="headerlink" title="带*号标记必填项"></a>带*号标记必填项</h5><p>多个输入框，有必填项与非必填项时，用*号标记必填项。</p><p>在输入框有小标题的情况下，*放在输入框小标题的前面。</p><p>在输入框没有小标题的情况下，*放在输入框的前面。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTM5MjA0ZWM5MjVkOWM4ZDQyYjZiOWVhYWM3YTYxOWZfQkF6UFlUVUJvYVdRWlpsWk11Vm85allJZkJlWGM5TjVfVG9rZW46Ym94Y25mTktrSVdmY0FyNDlkTGl5U3hCUWNkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="带自动推荐功能的输入框"><a href="#带自动推荐功能的输入框" class="headerlink" title="带自动推荐功能的输入框"></a>带自动推荐功能的输入框</h5><p>输入过程中，向下展开列表进行相关输入推荐，例如注册时输入邮箱地址，展示邮箱后缀推荐。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQwMzE4MDg2ZTIyMDEwY2UzZTcyM2Y0MjRjNDE4NDlfSm1nd0tobm1KcnpJRmMyTkhOQnFMRlBiNXFnRVpHd1ZfVG9rZW46Ym94Y25FY2ZnSElac3pydzJnNXlVU2xndkVjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p><strong>标题位置</strong></p><ul><li>文本框标题在输入框上方，显示输入框需输入的内容。只有当下拉按钮作为标题时，可以放在输入框左侧。</li></ul><p><strong>标题的使用</strong></p><ul><li><p>在保证用户可理解的前提下，优先考虑使用水印文本指出输入框的输入内容类型。当水印已经完整诠释了文本框的输入内容时，无需标题。</p></li><li><p>若查看的内容同时也可以编辑，可以添加标题。当用户编辑后再次进入该页面查看时，无标题将无法清晰了解各内容的属性。</p></li><li><p>若水印内容是标题内容的详细补充，可以添加标题。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWE2NWMzNmY4YTA2MjEyNThiN2IxNjgzMjY5Mzc5YWFfRnJOSGZTNnIza1JINnlQaUE4TkJzUjZUbmFabm9LcUVfVG9rZW46Ym94Y25ZZVZvMzFwS2FyclZIV1c3YnJaU2RmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="水印"><a href="#水印" class="headerlink" title="水印"></a>水印</h4><ul><li><p>水印文本显示在输入框内，对用户要输入的内容进行提示，以帮助用户理解输入目的。例如文本框里的邮件、密码提示文字。</p></li><li><p>获取焦点后，水印文字不消失，输入字符才消失。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzc3NTNmZDFkNGZkYzg5NTU1ZDRiZTA2ZWEzZjY2YjRfSEloNjZPOW5kSnpudE5WNllyajNrelh3RTZvb042dzlfVG9rZW46Ym94Y25GRjVVa21mMjBDR0s4b2MxN2RlMmViXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>水印字符串</strong></p><ul><li><p>一般情况下，输入框包含了“输入”的意思，直接使用名词作为水印文本，例如“姓名”、“邮箱”，不需使用“输入XX”的描述格式，以确保小语种界面用语不超长。</p></li><li><p>如有标题，水印文本不要与标题重复，一般是标题内容的详细补充。</p></li></ul><p><strong>水印的使用</strong></p><ul><li><p>当页面标题或弹框标题已作为输入框的标题时，若水印文本和标题表达的意思不重复，可以添加水印；如果重复，不要加水印。</p></li><li><p>若是新建内容输入，输入框内提供默认命名（例如“歌单 1”、“歌单 2”）并高亮，删除后，无水印显示。</p></li><li><p>当有一组输入框都使用水印时，需认真审视用户的可理解性，如果不好理解，就需选择使用标题来表达。</p></li></ul><p>无法复制加载中的内容</p><h4 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h4><p>指示用户当前输入的位置，并显示键盘。键盘收起时，光标消失。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjk1NTE5ZGUzNjgyZTRjZTMzMzQ1OGE3OTVkNDMzMGRfRVd5OUt5N1RqT25oMmxMSXRmb09BWmFHNWNxUjllNHhfVG9rZW46Ym94Y25LVnNDRU14a2o4RkNMNW1tNDFOQnNlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="帮助文本"><a href="#帮助文本" class="headerlink" title="帮助文本"></a>帮助文本</h4><p>在输入框下方，对输入操作进行说明。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjBiN2FhODcyMWE5Nzc1MjJlOTZmZTA2NDcyNDcyOTBfeVlKRDAyUzd5VXQ4dlRxcWdTajR4dEJCcVBhQnpDZXVfVG9rZW46Ym94Y24yTm9NdGlIbExtM3h4TGM1VDlXZHNjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h4><p>用户输入错误时，系统给出实时提示，帮助用户修正错误。</p><p><strong>错误类型</strong></p><ul><li><p>格式不对，例如邮件格式。</p></li><li><p>超出输入长度。</p></li><li><p>字符不合法，例如用户名中不允许使用某些字符。</p></li><li><p>跟已有项重复，例如已有文件名。</p></li></ul><p><strong>规则</strong></p><p>错误出现后，禁止提交输入的内容。若系统无法实时给出提示，则在内容提交后给出。输入存在错误时，可在输入框下方显示错误信息，说明如何修复。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzhiYjc5ZDg1ZmUwMTY2YWM1NmY1NzFlMDAxMzU2ZmRfcnRrTWpNTmNEOGc3UGthY2xlejNqUHc2MHJLVlVqTDFfVG9rZW46Ym94Y25Ec0tvS1RLeUFtZkVaNnNjSVN2eFNiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="字符计数器"><a href="#字符计数器" class="headerlink" title="字符计数器"></a>字符计数器</h4><ul><li><p>若文本框有最大字符长度的限制时，可以使用字符计数器。字符计数器放置在框体内（密码输入不使用字符计数器）。</p></li><li><p>右对齐，显示已输入的字符和字符限制之间的比例（格式为：已输入字符 / 字符限制）。</p></li><li><p>默认不显示字符计数器，当输入字符数接近规定字符（剩下最大字符长度的 10%）时，显示字符计数器。</p></li><li><p>若用户输入刚好达到最大字符长度，字符计数器和框体不变红；若用户继续超长输入计数器和框体抖动变红。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGQ2NThhZWQzYjJmOTNjNDdkMDMyOGVjZDRhYjdiYjhfeFJQakdQOFlicEJGY0hyNUxPRlF6em1GWEJMdEtSbE1fVG9rZW46Ym94Y25lVU51YWZCaUgzT1V6R0oxM3RPYkVoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjEwYTliOTUzZjFkNjJmMWQ4Yjc1NDMzN2I3NmE3OWZfa2VRUlhhRDN4VjF4bktocjVIeURZVGlzbnc4MnIzYkRfVG9rZW46Ym94Y25EdTc3VnlaV0JIbmdXYnBPVFh0amlMXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>超长状态与输入错误样式一致</p><h4 id="密码输入"><a href="#密码输入" class="headerlink" title="密码输入"></a>密码输入</h4><ul><li><p>不限定位数的密码输入，默认是先显示字符再转变为掩码，用“······ ”来显示密码的字符。可见性图标显示在输入框内，用来指示当前的密码是否可见。</p></li><li><p>不限定位数的密码的长度由用户自定义。</p></li><li><p>限定位数的密码输入，不会显示输入字符。</p></li></ul><p><strong>密码的显示与隐藏</strong></p><ul><li><p>隐藏密码：与帐号相关或具有很强的私密性要求的情况下，需要默认使用掩码来显示密码。</p></li><li><p>明示密码：需要对外提供公共服务时（共享WLAN热点供他人使用）或使用公共服务时（例如咖啡店提供的WLAN热点密码）用到的密码，用户需要直观的查看密码，并在设备上进行输入密码。此时密码使用明文。</p></li></ul><h4 id="格式化输入"><a href="#格式化输入" class="headerlink" title="格式化输入"></a>格式化输入</h4><p>输入的文本可以按照不同方式分组显示。例如电话号码，采用分段显示；银行卡号，采用4位分组隔开方式显示。</p><h4 id="如何使用-26"><a href="#如何使用-26" class="headerlink" title="如何使用"></a>如何使用</h4><h5 id="单行文本框"><a href="#单行文本框" class="headerlink" title="单行文本框"></a>单行文本框</h5><ul><li><p>当文本输入光标到达输入区域最右边，框中内容会自动向左推挤。</p></li><li><p>文本输入框中有默认推荐文本的操作时（例如新建文件夹、重命名等），初始状态文本全选，方便删除。若直接保存导致名称重复，使用错误提示的定义。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWM3MjU5NDY4ZmQ1MmM5YmUxMTE3MWM5NWQ4NjlmZGRfR1U3ek02bTdWZGJtYTRCcVd4bEhaZmdTYldmOUpDc0RfVG9rZW46Ym94Y25sOXBwMFNjZjd4ZXhrbFBjQTlFTHdiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>单行输入框</p><h5 id="多行文本框"><a href="#多行文本框" class="headerlink" title="多行文本框"></a>多行文本框</h5><p>文本可多行形式显示。</p><p>框体高度分为固定和可扩展两种：</p><ol><li>框体高度可扩展。例如短信输入框，高度随输入的文字扩展。</li><li>框体高度固定。默认初始时以多行文本框的样式显示，高度固定。文本高度超过框体高度时，继续输入文字，新输入的文字换行形成新的一行，文本可垂直滚动，滚动时显示滚动条。</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDk0NzQxN2Q0NTdmYzdhN2MzYmIwY2Q5M2IzZTI1NDlfdTlFV1NzMFY3OUY3WVFibjU2MXBBbUdhS3lPVmY3cHdfVG9rZW46Ym94Y25xMlVaVENKQlg4M1hJVnRqdkpyMnhkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="全宽文本框"><a href="#全宽文本框" class="headerlink" title="全宽文本框"></a>全宽文本框</h5><ul><li><p>适合多行的输入。</p></li><li><p>文本可以显示多行，不以框体或线性形式呈现。</p></li><li><p>文本可有多种样式：不同字体、大小、颜色、粗体、斜体、加下划线等。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzczMGVlYWM5ODg4ODc0MjJkMTdjNDRlOTY3YmIwZjJfZmFSQUtjWjN6bUhHTEZwaXQ2YkF5SVdnWDg0RjVVVDhfVG9rZW46Ym94Y25ZcGNBbU1GWXVWNkdkWERMWjVzQVd0XzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="交互规则-20"><a href="#交互规则-20" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h5><ul><li><p>默认获取焦点：当进入当前界面需要马上输入时，输入框默认获取焦点弹起输入键盘。</p></li><li><p>默认没有获取焦点：当进入当前界面时可能先做其他操作时，输入框默认没有焦点（有光标闪烁或文本被选中）。</p></li></ul><h5 id="点击-11"><a href="#点击-11" class="headerlink" title="点击"></a>点击</h5><p>文本框可用时，点击获取焦点并显示光标。</p><h4 id="视觉规则-24"><a href="#视觉规则-24" class="headerlink" title="视觉规则"></a>视觉规则</h4><p>跟随列表形式使用线性样式，其他场景使用框体样式。</p><h5 id="主题样式-19"><a href="#主题样式-19" class="headerlink" title="主题样式"></a>主题样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWUyMjNhMGJlM2JiYWE3MWUwNmU0MjUxMjAyZTBjNzZfdFpkeVdaR0Z4ZmxHVXBHVVVnNUpuWjZCOXN0MG1VSTdfVG9rZW46Ym94Y254R0tYekJuVnNWQk1EZjI4WkQyRlVjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjZiMGVlNzVjYmE5ZGZmNjU2NjRkNGE0MzI5ODZhMTVfTng0TnVrWUNIUVNGaURnMmplekxGU25mSmc3RnBQWVhfVG9rZW46Ym94Y25TNjVQQkdNTTMzcGpQblpmbm9vZmNlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTQzYTIyYTEwYzEzMDk3NGI2Zjc5ZmE1ZjkzOGE4ZTFfbmZMNWFDRW9FdnNIamRqMVRINGgxbVFyV1Y4eW4zaTdfVG9rZW46Ym94Y25Kb2dlMmpyaTRiTWpRYzlxQTBmVThkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-basic-textarea-0000000000611748" target="_blank" rel="noopener">textarea</a> (JS) 和 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-component-textfield-0000001061125582" target="_blank" rel="noopener">textfield</a> (Java)</p><h3 id="文本选择"><a href="#文本选择" class="headerlink" title="文本选择"></a>文本选择</h3><p>选中的文本以高亮的文字块呈现，通过手柄来调整文本的选择范围。操作菜单置于文本之上。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDdlOGU0YzM2NjI1ZDQ4MDNkNTVjZTYyYTU3YWM1NjVfS3F6RzZxWElHMXhKYnJmb1l4ZGdwNDRRQ3p2eWVUM0xfVG9rZW46Ym94Y25CZGd0YWtGUVFMdFA2SFlXNkZHdWZoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="如何使用-27"><a href="#如何使用-27" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>文本编辑界面，例如信息、邮件、备忘录等编辑界面中。</p></li><li><p>文本选择菜单支持插件。例如安装了翻译软件，菜单会支持翻译功能；安装了搜索软件，菜单会支持搜索功能。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzBkNzNjZTIyNzZiOWI4MjdiMmFlNWRkMmU2ZDgxNjlfWmZVc3RFa0ttd1ZmN2wyRUpDVVN3eFZHVFVBc2NvVUhfVG9rZW46Ym94Y25FbjljY2wzbkpBdWg1WGE3M2FEWlZhXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="文本选择菜单"><a href="#文本选择菜单" class="headerlink" title="文本选择菜单"></a>文本选择菜单</h4><ul><li><p>菜单的主要功能：剪切、复制、粘贴和更多。选择“更多”时，出现二级菜单，显示更多操作。</p></li><li><p>菜单中的功能操作，顺序依次为：剪切、复制、粘贴、全选、翻译、分享、搜索和其他操作。文本选择的强相关功能（“剪切”、“复制”、“粘贴”、“全选”）不建议放入“更多”中。</p></li><li><p>三方应用提供的操作，全部放到“更多”中。</p></li></ul><h4 id="交互规则-21"><a href="#交互规则-21" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="双击或长按输入框"><a href="#双击或长按输入框" class="headerlink" title="双击或长按输入框"></a>双击或长按输入框</h5><p>有文本时：双击或长按输入框，选中当前位置的单词并显示两个手柄。拖拽手柄可扩大或缩小范围。</p><p>没有文本时：双击只有光标。长按输入框出现手柄。</p><h5 id="点击输入框"><a href="#点击输入框" class="headerlink" title="点击输入框"></a>点击输入框</h5><p>输入框有文本时：当文本框没有焦点时，点击获取焦点，显示光标。当有焦点时，光标移动到点击的位置，并显示手柄。</p><p>输入框无文本时：点击获取焦点，获取光标。</p><h5 id="点击手柄"><a href="#点击手柄" class="headerlink" title="点击手柄"></a>点击手柄</h5><p>出现菜单。</p><h5 id="拖拽手柄"><a href="#拖拽手柄" class="headerlink" title="拖拽手柄"></a>拖拽手柄</h5><ul><li><p>手柄需要跟手。光标定位在距离手柄左侧距离最近的文字后面。</p></li><li><p>在不能落光标的地方松手，显示手柄归位效果。</p></li><li><p>光标滑动到内容区顶部和底部上时，页面要自动滚屏。</p></li><li><p>支持反向拖拽。</p></li></ul><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><ul><li>滑动浏览时停止滚动屏幕，不出现文本选择菜单。</li></ul><h4 id="视觉规则-25"><a href="#视觉规则-25" class="headerlink" title="视觉规则"></a>视觉规则</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzZmMWM3ODVjNWQ5MDQ3ODBkM2Y0MjJiMjhkMDYxNzFfdWgxclgyYzhTR1NxVGxCMHRwOVFUWjFLakluV2NXaTJfVG9rZW46Ym94Y25VaHp0RkdJdWFrRDJ1Z2ROcFVRMk5kXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="主题样式-20"><a href="#主题样式-20" class="headerlink" title="主题样式"></a>主题样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjdjYzA0NjhiYWQzNThjZjUxOTliODhlNzcwMzU4MWNfWnBLWG93bEtZTzAzbFN2S2owcEV0SmdUT2FaWE5QSm9fVG9rZW46Ym94Y25SZkJyVVh0TVpMNmxvcXJOZ1JoZ3E2XzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2NhMDhhZmE5YTEyYjkxNzc4MTlkYmRlNjQ5ZWQwNjdfcGlEd0h2VUlIU296TUZPNGNPN2t5aFl3ZFJkRnlCSmhfVG9rZW46Ym94Y25halhUYjIxZ2lIRzNqbGJWQlg1Y25mXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmM2YTQzMjIxM2M0OGJlMzA1ODdkZjFmYjYzNTlmM2NfWGhjekE5YkliYWZZb2tWOFVEZmRkZktiSWVnZ0VaQ2pfVG9rZW46Ym94Y25TSVZpRGdPWWVySHV4N21yRFVobWVjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><h3 id="下拉按钮"><a href="#下拉按钮" class="headerlink" title="下拉按钮"></a>下拉按钮</h3><p>下拉按钮可让用户在多个选项之间选择。</p><h4 id="如何使用-28"><a href="#如何使用-28" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li>需过滤当前界面内容、快速切换类型（例如存储位置）或选项内容（例如设置密保问题）时，使用下拉按钮。</li></ul><h4 id="交互规则-22"><a href="#交互规则-22" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="点击-12"><a href="#点击-12" class="headerlink" title="点击"></a>点击</h5><p>点击后显示一个选项菜单，当前的选项需用颜色标示，箭头方向向下不变。点击其中一个选项后，菜单会关闭，并在按钮上显示新的选项值。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTAyZTliYTczOTE0MDY2MTlmM2QzYmM4ZDliM2Y2OTZfWE40ekdpSW5ZYXNoNDZNOVRZV2hYV3VMWUxsWkx3R0dfVG9rZW46Ym94Y25yV0llOVdlRTM0eGJWNnFXMHBNWEZkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="组合样式-2"><a href="#组合样式-2" class="headerlink" title="组合样式"></a>组合样式</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWI0ODA4MWFlYWRjYzIxZTQzZmU3NzJmZTMxMmZmM2FfV3ZFMEZrVGczOUx4TGRBMXNxc0pxQ2ZmTVJSOFdFZGZfVG9rZW46Ym94Y25LM015cFUwV3VvRDU3QmJaNmxSdGtoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>下拉按钮和输入框</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MWQ3OWJlY2RjMmRlNWI0YzU0NzRiYWNmNjE4YWY3NmNfQzV5NmN4bmZuMk5ONWtYaEk0Zjd3cFNnUTNzMjFacjlfVG9rZW46Ym94Y25CaU5QTXFKR1dUQ1RTR0JGeUVNaWNmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>下拉按钮和搜索框</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGViMjY4MDkyNjBiNmIzYmY3ZDk3MGViZTRhYWViODJfZ1A2dG8wZjZpdkZtS2FvTW1sYzBTTVhMNm1jMmF3SFhfVG9rZW46Ym94Y24wYUNncWFwMkRxNHN3QjRMbTlJbFJoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>单位切换</p><h4 id="箭头位置"><a href="#箭头位置" class="headerlink" title="箭头位置"></a>箭头位置</h4><p><strong>跟随字符串</strong></p><p>下拉按钮单独使用的时候，此时右侧箭头一般跟随字符串。</p><p>用于过滤当前界面的内容或切换类型（例如存储位置）或切换选项的内容（例如设置密保问题）。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTE3YjUyZTNjY2IwZDYyZDI0YTAyZWMxNjMzMjkyMTBfeExncFRSZ1ZJS3lOTGpQQTE4bXZ1Yjg1ZEFiUlZrVHZfVG9rZW46Ym94Y243ZXVmWklSS0dSWXVyQUZvcTIwWHFjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>跟其他控件结合使用</strong></p><p>用于指示当前输入的类型或范围。</p><p>此时为达到界面的美观，右侧箭头一般会指定位置。如果切换选项以后，字符串长度超出指定的位置，右侧箭头需跟随字符串显示。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmYyMWE0ZWVhNzNmMTA2NzNlYTY3NzU1ZGU3OGJkMDBfZXY2RFpoUTlBZ1FFeU9WaDJWY3M2U3FnTFZoQ0dpd1FfVG9rZW46Ym94Y25hTUpiWHFEWVN6MkM3NnViNjRnekJmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDkzZWI2NDEwMWE0OGI5YjNmNjgxNWI5ODlkYzg2ODRfemZOTXYzRnBQSVU4T1lBUG9uSWV6TmU3dU9nQVVrcUNfVG9rZW46Ym94Y25vNXFjV0QyZGpwckJuTExoNk9aYm9WXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="视觉规则-26"><a href="#视觉规则-26" class="headerlink" title="视觉规则"></a>视觉规则</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDY5ZjMyNGJlNjE5MGVlZTA3MjBjMGZhMWIwM2MwNzRfOXFaeFJSclRRcFJxUk94Y29SZHhXMGtheVdXaFMwUWxfVG9rZW46Ym94Y25pZ0h4MlpqQ2xrc3dVY2NWSFNtSldmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTZjMjQ1OWFlMmMxYzU0YzU0NDI0ZDRmNzBlY2U3OTNfU2k1TUlQd3ptd1h2Nk8yU0VhVjhEek9wUlJvYTVaczVfVG9rZW46Ym94Y25BSG5JQXdRVW5EZlZNYkk5c0haekVkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDNhZTc4ZDZiZWVjYjYxMjdkZDhjZmZhNzljZjc2MWNfNFU2NzZybjdiT0NDZlZHSjlvNzBnVEdkTTBlMmtEaGVfVG9rZW46Ym94Y242R1E4UWdXS3llUkl4STBmVE1YRHJnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><h4 id="界面写作规则-7"><a href="#界面写作规则-7" class="headerlink" title="界面写作规则"></a>界面写作规则</h4><ul><li><p>下拉按钮文本以短语形式呈现，建议使用名词或名词词组。文字间无空格。不可使用多个词组。不带句末标点。</p></li><li><p>句式统一。</p></li></ul><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-basic-select-0000000000611712" target="_blank" rel="noopener">select</a> (JS)</p><h3 id="新事件标记"><a href="#新事件标记" class="headerlink" title="新事件标记"></a>新事件标记</h3><p>应用中可能有需用户关注的新事件提醒，需要采用新事件标记来标识。有多种类型新事件时，最重要（或用户最关注）的事件为主要事件，其他为次要事件。若无重要（或用户关注）事件，应用中所有事件均为次要事件。应避免对新事件标记的滥用。用户打开被标记项时，如果看到的内容跟预期不符，就会失去对新事件标记的兴趣，反而降低点击率。</p><h4 id="类型-17"><a href="#类型-17" class="headerlink" title="类型"></a>类型</h4><ul><li><p>数字标记</p></li><li><p>圆点标记</p></li></ul><h4 id="如何使用-29"><a href="#如何使用-29" class="headerlink" title="如何使用"></a>如何使用</h4><h5 id="数字标记"><a href="#数字标记" class="headerlink" title="数字标记"></a>数字标记</h5><ul><li><p>桌面图标数字标记只显示应用中的主要事件。例如应用市场中有应用更新、活动推广等多种类型的事件，其中应用更新为主要事件，因此在桌面图标上显示应用更新的数字提示。</p></li><li><p>设置里的“系统更新”用数字，与桌面设置图标的数字标记相对应。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODc0NGViOWFlMjgwMjVlNjdiMjE1ODhkMTQ1ZDM3NjJfN3UyRUJsbmpIajkxOUJjdFkwazZyOVREaGRvYmM4WDhfVG9rZW46Ym94Y25qeUdKaW5saVRCMjc1VnVIbG9sQm9nXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="圆点标记"><a href="#圆点标记" class="headerlink" title="圆点标记"></a>圆点标记</h5><ul><li><p>圆点标记适用于标识应用中的次要事件，通常出现在底部页签、列表项、工具栏图标、内容区的分类图标、头像上。点击后，圆点标记消失。</p></li><li><p>运营活动失效时，对应的圆点标记需主动消失。</p></li><li><p>纯文字时，新事件红点统一放在文字右侧。</p></li><li><p>图标＋文字时，新事件红点放在图标右上角。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWYyN2NmMmZjZGVjOTI5NDUwODVkZWIyMTIzZGQzMzBfUWY3bXIwTHpxSUVUYVI4N1BtSE95amFkOWhnWU5MTmxfVG9rZW46Ym94Y250OXZtQnpYclBDT2d3U3V5NFVuUG9jXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="视觉规则-27"><a href="#视觉规则-27" class="headerlink" title="视觉规则"></a>视觉规则</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2QzZmRkZTMyYTBhYTk1NzY0NTZhMTE1ZTg3ODhlM2JfeG9rbG8wRjNlaEU4YlFTUTlXZW5Bb3Y0QlJSWWcyOGtfVG9rZW46Ym94Y25Qd3Q0REV5S3NnSzJpSHFGQ0kyWjdnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmU1ZDI5N2NjZDE2ZDEzNjg5YTU4ZjA4MzcxNzkzNjRfd2tkbkdDeFcwQVhYUWpuS0RpUXpZd2tsMHlxY3RpYWhfVG9rZW46Ym94Y25uc0FLMEFGNHVQa2FsVFY3dFZEVUFkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="主题样式-21"><a href="#主题样式-21" class="headerlink" title="主题样式"></a>主题样式</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjU1YzA1NWJkM2FhNjI2ZWI4MTY3ZmE1MDRhMjBmZWNfRDB5ZlpqYUE3QnVkcDd2Wkk3dUlQTHZyUTAwZzdVVHhfVG9rZW46Ym94Y25yNFBpdWtKYU1qZVRRazV6b3J5UzdiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="界面写作规则-8"><a href="#界面写作规则-8" class="headerlink" title="界面写作规则"></a>界面写作规则</h4><p>数字标记显示 1-99 之间的数字，超过 99 用 99+ 表示。状态栏上通知消息数量超过 9 条，用 9+ 表示。</p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-container-badge-0000001060267851" target="_blank" rel="noopener">badge</a> (JS)</p><h3 id="状态按钮"><a href="#状态按钮" class="headerlink" title="状态按钮"></a>状态按钮</h3><p>状态按钮用于从一组选项中进行单项或多项选择，将选择项作为筛选条件，在界面上实时显示筛选出来的结果。或将选择项作为选择结果提交。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTZkYWQ2ZTVjNDAyN2VjOGFmZWQwZjRmMjBmZWY1NjhfTGt2RDNDSGpxVDI3UE9KZzVYWThxMU9WQ1FBMzU0cWxfVG9rZW46Ym94Y25QSkNXZ0V4anNiMWNtM0tvMExsa0hLXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="如何使用-30"><a href="#如何使用-30" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>状态按钮有已选择和未选择两种状态。</p></li><li><p>状态按钮不单独使用，通常由多个状态按钮组成一组选择项。</p></li><li><p>用于单项选择。多个状态按钮作为单选选择时，只能有一个状态按钮处于选择状态，并作为当前的选择。即选择一个后，另一个状态按钮就自动设置为未选择状态。</p></li><li><p>用于多项选择。多个状态按钮也可以组成多选选项，每个状态按钮都可以被选择。</p></li></ul><h4 id="交互规则-23"><a href="#交互规则-23" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="点击-13"><a href="#点击-13" class="headerlink" title="点击"></a>点击</h5><p>点击改变当前的选择状态。</p><h4 id="视觉规则-28"><a href="#视觉规则-28" class="headerlink" title="视觉规则"></a>视觉规则</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjljODc0OWY1ODUyMDcxMmYwNTAzYzZlMzhkZTlmMTNfMnJGYWg0aWJPbWFLb2NZZ3p2ZEg2TlhKWDZqUFl5amNfVG9rZW46Ym94Y256ZHo1QzdYTUNZMk1EcEhrQjVzOXFjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="主题样式-22"><a href="#主题样式-22" class="headerlink" title="主题样式"></a>主题样式</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDNhMzhiZmJkMTRhYTNhNjQ5OGVhMzRmZjE4ZWIwM2RfUUNWdk5adERJOVRYZmI5UE9MSzh1UHo4clkzNGpzT3lfVG9rZW46Ym94Y24zNXZoak9MTWRrRWdTRVkxNzZtakFMXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Yjc1M2EyNTQ4Zjk3NTcxMGRjZGE2ZDcyZGU0YzgyNzFfNWxnWFFEZjRadENYVENWOXo5UUozcWFmZWhOSkx5YWJfVG9rZW46Ym94Y25GV1BLbm5jODlLdkh4d2ZtZ0dWNnliXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODNkMmU5NjU2NzRjZjMwOTIxMTdhMzE3ODZhYzhmMWJfaEU1NEU0dFpxeWdEVHg3RWhHVmk4MmpOMHRZdm40OGNfVG9rZW46Ym94Y243TklrMkZOT2Y1WEtGWm9wZ3VsWG9jXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><h5 id="布局样式-9"><a href="#布局样式-9" class="headerlink" title="布局样式"></a>布局样式</h5><h4 id="界面写作规则-9"><a href="#界面写作规则-9" class="headerlink" title="界面写作规则"></a>界面写作规则</h4><p>每个状态按钮使用名词词组，不加标点。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDEyMTRlNDI2YzlmNjg3NzdmZTRmYzQxNmQxN2ZhNWVfazRiS0ZnTzd1MGJiUTJCMVdReFBXTHdBZWZ0bGVXYWFfVG9rZW46Ym94Y25sV2dpYVhCMVNJZ3B4RWViaTUwcGpnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-basic-toggle-0000001061155984" target="_blank" rel="noopener">toggle</a> (JS)</p><h3 id="子标题"><a href="#子标题" class="headerlink" title="子标题"></a>子标题</h3><p>用来组织界面内容，根据层级将其划成区块，并概括该区块内容。</p><h4 id="类型-18"><a href="#类型-18" class="headerlink" title="类型"></a>类型</h4><ul><li><p>列表子标题</p></li><li><p>内容子标题</p></li></ul><h4 id="如何使用-31"><a href="#如何使用-31" class="headerlink" title="如何使用"></a>如何使用</h4><h5 id="列表子标题"><a href="#列表子标题" class="headerlink" title="列表子标题"></a>列表子标题</h5><p>子标题右侧1个操作功能时，使用文本按钮。2 个功能时，使用图标，建议最多支持三个图标。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDUyZWNmYjhjZGU2ZGJmYzdmN2VhOGViMTdlZTRlYWNfZjVtcDdRZVRGamZQa1B0dk81dkRiTFp4cnl0MXp2dFlfVG9rZW46Ym94Y24zbmdwYzhHZTN3WEI3aEx5UlNYQVRkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="内容子标题"><a href="#内容子标题" class="headerlink" title="内容子标题"></a>内容子标题</h5><ul><li><p>子标题代表一个版块的开始。子标题名称用于表示一组版块（非列表）的内容。</p></li><li><p>子标题右侧 1 个操作功能时，使用文本按钮。2 个功能时，使用图标。</p></li><li><p>需要跳转新页面查看更多内容时，使用“更多+右箭头”的形式。例如播放列表场景。</p></li><li><p>子标题左侧可以加下拉按钮。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGRlM2JiOTAyMjk1MjM3ZWMyNjBjMDRmZjkzMjJmYzVfYUppdmhvNXJpb2JMNFFjcFZPQTVoRjllb0d0RUIxS1JfVG9rZW46Ym94Y240YXNJcHhQVU43WEJCcHdOa2pQWnJmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="交互规则-24"><a href="#交互规则-24" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="列表子标题-1"><a href="#列表子标题-1" class="headerlink" title="列表子标题"></a>列表子标题</h5><ul><li><p>子标题位置可固定：界面滚动时，子标题固定在屏幕顶部，直到被下一个子标题推离屏幕。用于设置列表或子标题涵盖内容很多的场景。</p></li><li><p>子标题位置跟随内容滚动：界面滚动时，子标题跟随内容滚动。用于子标题涵盖内容少的场景。</p></li></ul><h5 id="内容子标题-1"><a href="#内容子标题-1" class="headerlink" title="内容子标题"></a>内容子标题</h5><ul><li><p>右侧“更多”+右箭头：点击进入更多详情界面。</p></li><li><p>左侧下拉按钮：点击可以筛选当前子标题下的内容。</p></li></ul><h4 id="视觉规则-29"><a href="#视觉规则-29" class="headerlink" title="视觉规则"></a>视觉规则</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzEzYzA3OGMzNmVmODkxODVmY2YxMmRiYWQ5MDNkNDdfdmxkUk5mNTc2MFQ5S0Z4dWtzczgwWXRVODNXYndESmpfVG9rZW46Ym94Y25UWlFFZkVuTnJpTTh5clFsZHpBcmFmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDQyMDNkMDBhYzQ4NmNhYTRlZDVmNjY0OGU3ZGQ2MDBfOWFTVVc3akMwTjRPZmJmUmNINkdQMjY4b3VIYkxNVFFfVG9rZW46Ym94Y25vcFA2WnlhbTY5TXRmWWd3UDZiUmNmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="界面写作规则-10"><a href="#界面写作规则-10" class="headerlink" title="界面写作规则"></a>界面写作规则</h4><ul><li><p>子标题中的文本采用短语的形式呈现（名词或名词性词组），简明概括区域中列表项的内容。不带句末标点。例如无线和网络、隐私和安全、应用。</p></li><li><p>不使用“其他”等毫无意义的子标题，这种情况不使用子标题。</p></li><li><p>避免列表选项和子标题内容重复。</p></li></ul><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-basic-text-0000000000611633" target="_blank" rel="noopener">text</a> (JS)</p><h3 id="子页签-1"><a href="#子页签-1" class="headerlink" title="子页签"></a>子页签</h3><p>子页签通常放在内容区上方，展示不同的分类。页签名称应简洁明了，清晰描述分类的内容。</p><h4 id="类型-19"><a href="#类型-19" class="headerlink" title="类型"></a>类型</h4><ul><li><p>在屏幕内显示完整的页签</p></li><li><p>超出屏幕的页签</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjJkOWM5MmQxYjE0MDQzNDE1MmI1ZjNjNWNmY2QwOTRfSFBoNVJJaUFiendmTFJ2V0dUajB5UnhZQVZMSENpdkdfVG9rZW46Ym94Y25Rd2prdUZPY01scHF6eHphM3JZYWFjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="如何使用-32"><a href="#如何使用-32" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>页面内容有多个同级内容时，可通过子页签对其进行分页展示，以便快速访问。</p></li><li><p>子页签展示数量不宜过多建议 2-5 个，以免界面拥挤。分类过多的可横向滑动查看超出屏幕部分。</p></li><li><p>子页签右侧最多可放置 1 个功能入口。</p></li><li><p>子页签支持可隐藏，向上滑动页面内容时可将子页签隐藏，下滑时显示子页签。</p></li><li><p>子页签可随内容的上下滚动而滚动，滚动到一定位置后固定，只能滚动内容。</p></li><li><p>子页签上允许有新事件标记，用于通知用户该页签下有新的内容或消息，详见<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/badge-0000001110627022" target="_blank" rel="noopener">“控件”&gt;“新事件标记”</a>。</p></li></ul><h4 id="交互规则-25"><a href="#交互规则-25" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="滑动-4"><a href="#滑动-4" class="headerlink" title="滑动"></a>滑动</h5><p>在与内容区操作手势不冲突的情况下，左右滑动子页签的内容区，可切换子页签，不能循环切换。</p><p>对于超出屏幕的页签项，在页签栏上横向滑动查看超出的部分。</p><h5 id="点击-14"><a href="#点击-14" class="headerlink" title="点击"></a>点击</h5><p>点击子页签可切换到对应的页签。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDlmOGYyOWViNjI5NzkyODg0Y2RhM2YzOTA3MGQxYjRfVGVDZFhXbTZ0WlZja09pbUQyWFA5Q0VObTZ5bjFjRkhfVG9rZW46Ym94Y240MlhMZHg5ekpiaWs4ME9uVFhjbzZmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="视觉规则-30"><a href="#视觉规则-30" class="headerlink" title="视觉规则"></a>视觉规则</h4><h5 id="竖屏"><a href="#竖屏" class="headerlink" title="竖屏"></a>竖屏</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTc0NTg2Njc5OTc3M2E2MDYwYjJhYWMwOGMwZjg2YWJfMGZpcUpMdllmSDdvSGp1WUdqQmNCSFg2ZVp1WDRZc2lfVG9rZW46Ym94Y25KN3RMZ3o1QnVYRENXajFsZjhHU2tkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTkzZjljZWM1NWQyNDBmYzk4YTNiMDRiNDg3ZGMwMGVfeDA1WXN6UWR5Z3FQdldsMjQ2Um9tQTRWSUVUNmJITzlfVG9rZW46Ym94Y25saVFacVpWVjVoSGlkUmZ6cXJIUlpnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="横屏"><a href="#横屏" class="headerlink" title="横屏"></a>横屏</h5><p>适用于8栅格以上布局</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2UzMGExMWE3MGE0MWU0YTMzM2U3OTYzY2M5MjI4NmJfVnpOSUtOZHVPa3ZoTDVXRkF1ODhUNVFnS3dSaFY2WTRfVG9rZW46Ym94Y25id1l3YWx0OU4xejJpUVl4YUpUdXl5XzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>横屏规则与竖屏规则一样，但页签之间的间距为 24vp</p><h4 id="主题样式-23"><a href="#主题样式-23" class="headerlink" title="主题样式"></a>主题样式</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmM2MzI4NTIxNTUwYTgzYTM5YjExYTg1ZDQwOWE3ZGVfTmFtTERRSk1oZFlXSHE5Tm5FbEFmWEZySExTYU1RQ2VfVG9rZW46Ym94Y25ZWnEwTlAyZWNzZldZUTAyMlZLNDVnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OThlZGM3Mjg0Yzc2OTlhNTU2YzExNmMxYzc5NjlhNThfSnd4NkliQ3FqU3VkQm9vcXJXQWhhS3dKeGRZb1RLMEJfVG9rZW46Ym94Y25JM2h4cTVEUFhDT1hLZDBMbHdOQm9nXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmIxNTIyZjI0MjdmODE2MzcwMjQ1MzEzMDQwNTQ4OGNfd1NBWDFTeVRSb0dxWFZoSWdMb2EzbDVnc2FueU5HbEJfVG9rZW46Ym94Y25BMkl1d3BLNDIyMVNKZmFOT1BOcHpnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>半透明主题</p><h4 id="界面写作规则-11"><a href="#界面写作规则-11" class="headerlink" title="界面写作规则"></a>界面写作规则</h4><p>同<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/bottom-tab-0000001110467118" target="_blank" rel="noopener">“控件”&gt;“底部页签”</a>。</p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-container-tab-bar-0000000000611548" target="_blank" rel="noopener">tab-bar</a> (JS) 和 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ui-java-component-tablist-tab-0000001062229749" target="_blank" rel="noopener">tablist</a> (Java)</p><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p>将传统数据转换成可视化的图形，把隐藏在数据中的信息以更加直观、友好、视觉化的方式直接展现于用户面前，提升用户获取数据信息的效率。</p><h4 id="类别-1"><a href="#类别-1" class="headerlink" title="类别"></a>类别</h4><ul><li><p>进度类</p></li><li><p>占比类</p></li><li><p>趋势类</p></li><li><p>分布类</p></li><li><p>排名类</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGYyM2QxODBhOWU0NDViZmNhN2Y1NGQ2MjBlNGVhNmZfTjZlQVZwdkx2YUlHdFFMczd2amNTdFhBMFJmODJFbzFfVG9rZW46Ym94Y242dFBMZ0ZwRnlrajR1NWZOMWkwNkxoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="如何使用-33"><a href="#如何使用-33" class="headerlink" title="如何使用"></a>如何使用</h4><h5 id="进度类"><a href="#进度类" class="headerlink" title="进度类"></a>进度类</h5><p>进度类有两个场景：</p><ul><li><p>加载进度类，在数据无明显进度加载时使用，例如获取网络数据时的加载。</p></li><li><p>实时进度类，在数据有明显进度加载时使用，例如安装包的下载。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDFkMDcyOTAxYzhiMjlmNTM2MTYzNDc3ZGU3OGMxMjVfMVE2OEp1eUdvSVI0TTNRMmZRNmhzY3dLNmVsS0pFNllfVG9rZW46Ym94Y25SQWtQZU5tMnBVb0p1VERwZmxES3FoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="加载进度类"><a href="#加载进度类" class="headerlink" title="加载进度类"></a>加载进度类</h5><p>无明确进度，用于用户操作完成后，提示当前界面还在运行中。目的是减缓用户等待中的焦虑感。</p><h5 id="实时进度类"><a href="#实时进度类" class="headerlink" title="实时进度类"></a>实时进度类</h5><p>有明确进度，用于用户操作完成后，提示当前界面的实际进展。目的是给予用户进展的预期。</p><h5 id="占比类"><a href="#占比类" class="headerlink" title="占比类"></a>占比类</h5><p>占比类适合在有多个数据总和时使用，可突出数据总和后各个数据的占比，从而突出表现各自份额。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGQzYjUzNTA5YzM5ZDZiNThkNjIxMGM3MTc1ZWUxNjVfekVuR3dGem0wa1FrWjVubmJ6bUVzNXZCRE5RMEJWNHFfVG9rZW46Ym94Y25xRThXd3ozS0hQUlpQOERySDF1MDkxXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="趋势类"><a href="#趋势类" class="headerlink" title="趋势类"></a>趋势类</h5><p>趋势类适合用来显示一段时间内的数据变化，通过曲线的变化体现增长与下降，从而总结趋势走向。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Njk0MzlhYjM2MjlhYmRmYzA3ZGZmNTRjM2UwYjgwZjRfNFdYTGtqdjhiTUt6RXhIRkRRS3dCVlNKN2JQclF4YnpfVG9rZW46Ym94Y25uV1diY3VkaklENWxTVlZpWVlZbjlhXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="分布类"><a href="#分布类" class="headerlink" title="分布类"></a>分布类</h5><p>分布类适合用多个时间段与多个数据类型汇总时，通过直方在横轴、纵轴内的高度变化体现数据在不同区间的分布情况。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTlmOGJjYzkwYjg2OWNmMGQ3MGE5YjRkZjJiMjkyYzdfeGZyNzlwTUhNYW5jOGNGOUtYOU9KZGM3eHdydmhZSXVfVG9rZW46Ym94Y25mb1Q5cVEwVnF6d3BMQkVZMWVBRWliXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="排名类"><a href="#排名类" class="headerlink" title="排名类"></a>排名类</h5><p>排名类适合用多个数据类型汇总时，通过横线的变化体现相对排名及排名的变化。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2ZlZGU0ODM4YmIxMWQ4MWVhZDdhMTNkOTU4MmZlZjNfbXNJZ0Ftc1hpRjFKNklvb0I1dkRacHcyZFlXbzJzR2RfVG9rZW46Ym94Y25lamZGelFCUllCbjlnbVpsaW1GbDZlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="视觉规则-31"><a href="#视觉规则-31" class="headerlink" title="视觉规则"></a>视觉规则</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWY4ODg0MGJhNjhhYWEwNDI1ZjRkMmM5NDU5ZWUzNGFfN29iaTFrQkNHRlZVQlZJUnJ3dFMxZlZnOHlFQk9TMW5fVG9rZW46Ym94Y25OUG1NNkhJQWtZVm1DNWlVWEMxODlkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NGFjNTg2YjQwNGJhMzhhMzk5YzkxODQ5YjNmNzllZDZfTUNaQlhxMTVkZzVxWlRwOXE4MElOUzRmMU5vbEp0UEdfVG9rZW46Ym94Y25YM1NLek8yVExyNHBTUTJ1d2pINTg3XzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzQzMGJhZmMwY2I1ZWY5NzYxYzA2ODdlOWQ3NjUwNDRfbDlRT1o4aTlEWk9WTTVIQUZSUmFvOTBVOVNMY1F5UVBfVG9rZW46Ym94Y25zMHVTeVo3aWNQV1FaeUxiYndWU2FiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzNkMTQ0YzljZWE1MDVlZWE4MTViOWRkOTlmNDU3YjRfaEhQVXNWaDY4c0lZVEpiZEs2TVZCTmUxTkd1V0xpRzdfVG9rZW46Ym94Y24xQWRLdlZUYjFkOXM0azBNcDlPVjNjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTI0N2Q1MTZmYWExZmQxOTkxMWNlYTEwYjBjM2FiMTlfa0NwN25IR2VleEU1cmdjamswNUVCYU15ZU1yOUd6WHlfVG9rZW46Ym94Y24yQkRPZWRpSlloNEJtQzA0STNVRE9oXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmNhMTNlMjNmOTIzYzA2NWUwZTc2NDllOTVkNDA4MzRfM21LYk83RzNFdVY5emNWV1dDSzl3d2hXMHZZNnlMczVfVG9rZW46Ym94Y25KUG5Uajl0YTdKVmtKclZvbkdlRkVoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="侧边导航栏"><a href="#侧边导航栏" class="headerlink" title="侧边导航栏"></a>侧边导航栏</h3><p>侧边导航栏仅适用于平板横屏界面，用于对应用进行导航操作。</p><p>使用侧边导航栏，切换页签或入口效率更高。</p><h5 id="类型-20"><a href="#类型-20" class="headerlink" title="类型"></a>类型</h5><ul><li><p>侧边页签</p></li><li><p>侧边入口列表</p></li></ul><h4 id="如何使用-34"><a href="#如何使用-34" class="headerlink" title="如何使用"></a>如何使用</h4><h5 id="侧边页签"><a href="#侧边页签" class="headerlink" title="侧边页签"></a>侧边页签</h5><p>通常在一级界面上使用，用于快速切换不同页签的内容。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjY5YjNkMmJjY2Y5YWQ2MTYyZDVhZGMyNDNhNzAyYTRfS2lTazZKc2hzVVFDRU80YWFFWmtxaGcyeFZNSWVLOGRfVG9rZW46Ym94Y25rRmVJMTFwcUdSWnYwTUdBR0J6YU1xXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTRkNjEyODM2OWMxNjEzMWJmZDdkNzE1YWI0NDlkZDRfMWZvTEFqR2JKaUQyYVlod1l6ZWNUOWg1T2V2T1J5aWNfVG9rZW46Ym94Y25JWHl2VUg0d3BJeGdzcjM3WXF6c21lXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>侧边导航栏 和 内容区</p><p><strong>侧边导航栏</strong></p><p>使用图标+文本的形式。页签的个数和顺序对应手机底部页签的个数和顺序。</p><p><strong>内容区</strong></p><p>内容区显示选中的页签对应的内容。</p><h5 id="侧边入口列表"><a href="#侧边入口列表" class="headerlink" title="侧边入口列表"></a>侧边入口列表</h5><p>通常在一级界面上使用。适用：效率型应用。</p><ul><li><p>支持将较深层级的内容作为侧边入口。</p></li><li><p>支持用户自定义侧边入口。</p></li><li><p>支持侧边列表的编辑，例如删除、排序等。</p></li><li><p>支持拖拽内容到侧边导航栏上生成快捷访问的列表项。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzVkNzliYzQ5ODk2MmUyZmYwZjMxN2VlNjk1NjBhZmZfazE4Qkg2TFZYcFZHaUxGR2NJUXVWVnZURHVhdDJKU1BfVG9rZW46Ym94Y25ycTBNdEdxRUpLNExIczMzdVI5cVVlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>侧边导航栏</strong></p><ul><li><p>使用列表的形式。列表头部跟手机的导航对应。</p></li><li><p>分为三部分：主导航区、快捷入口区、用户自定义区。</p></li></ul><p><strong>内容区</strong></p><ul><li><p>使用列表的形式。列表的内容跟手机的导航对应。</p></li><li><p>内容区可以是分栏结构。</p></li></ul><h4 id="交互规则-26"><a href="#交互规则-26" class="headerlink" title="交互规则"></a>交互规则</h4><h5 id="侧边页签-1"><a href="#侧边页签-1" class="headerlink" title="侧边页签"></a>侧边页签</h5><ul><li><p>点击页签：在内容区显示该页签对应的内容。</p></li><li><p>点击系统返回：内容区界面响应返回操作。</p></li><li><p>横屏切换为竖屏：竖屏显示为手机架构。</p></li><li><p>全屏界面切换为分屏、窗口：分屏或窗口下显示为手机架构。</p></li></ul><h5 id="侧边入口列表-1"><a href="#侧边入口列表-1" class="headerlink" title="侧边入口列表"></a>侧边入口列表</h5><p><strong>侧边导航的显示和隐藏</strong></p><ul><li><p>在侧边导航栏隐藏的时候，界面上向右滑动显示侧边栏。</p></li><li><p>点击“隐藏”图标，隐藏侧边栏。点击“显示”图标，显示侧边导航栏。</p></li><li><p>切换为其他显示模式，例如竖屏、分屏、窗口时，侧边导航栏不显示。</p></li></ul><p><strong>内容最大化</strong></p><ul><li><p>在侧边导航栏显示的情况下，可以为详情页提供最大化操作按钮。方便用户查看内容。</p></li><li><p>在内容处于最大化的情况下，需要再次点击“缩小”按钮，恢复成侧边导航样式。注：在最大化的情况下，不支持通过向右滑动的方式显示侧边栏。</p></li></ul><h4 id="视觉规则-32"><a href="#视觉规则-32" class="headerlink" title="视觉规则"></a>视觉规则</h4><h5 id="侧边导航栏-1"><a href="#侧边导航栏-1" class="headerlink" title="侧边导航栏"></a>侧边导航栏</h5><p>图标+文本组成的侧边页签控件，该控件宽度为 96vp，控件整体在屏幕一半的位置居中显示</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjU4OGIxOTk0MmFmZTI2ZDg5NjFjZmEwMzBhM2IxYjlfRk53Mm90ZlFuZGxMNEl2ZkZiV3JRSUNxWVBlOHhlbEpfVG9rZW46Ym94Y25QRlZyZkdkTDQyNHFPZkpiV2p2ajhnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="侧边入口列表-2"><a href="#侧边入口列表-2" class="headerlink" title="侧边入口列表"></a>侧边入口列表</h5><ul><li><p>屏幕宽度超过 840vp 的时候使用。</p></li><li><p>在应用切换为窗口、分屏的情况下，不使用侧边导航。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTFhMzFiNGRmZjdjMzYxYjZlZTk0N2YxZDgwYTA0ZGNfNXNCbjNOZ1REaXZaa3hsblAySHp4WjZqRERNcml6bFRfVG9rZW46Ym94Y25udVZ1WHJsNm9GYjZNSlZuVjRDUndoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>展开态：</p><p>第一栏宽度固定 280vp，第二栏和第三栏在剩下的可用区域内分别占比 40% 和 60%。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjNkNjZmNTNlOTFlNWVjMWJlOTc0OGNmYTM4ZGY3Y2RfVE9nRVZIQ28yZXpmWms5dHp5NWcxTkdFSm5MeEMwZ3dfVG9rZW46Ym94Y242U0h5dm5YR0lNWGlKQkRHV2hnTEZjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>收起态：</p><p>第二栏和第三栏在屏幕可用区域内分别占比 40% 和 60%。</p><h4 id="动效规则-2"><a href="#动效规则-2" class="headerlink" title="动效规则"></a>动效规则</h4><h5 id="侧边入口列表-3"><a href="#侧边入口列表-3" class="headerlink" title="侧边入口列表"></a>侧边入口列表</h5><ul><li><p>二栏变化到三栏，最左侧导航栏向右运动进场，右侧内容区针对内容大小做适配。</p></li><li><p>三栏变化的二栏，最左侧导航栏向左运动退场，右侧内容区针对内容大小做适配。</p></li></ul><h3 id="控件的走焦"><a href="#控件的走焦" class="headerlink" title="控件的走焦"></a>控件的走焦</h3><h4 id="可交互元素"><a href="#可交互元素" class="headerlink" title="可交互元素"></a>可交互元素</h4><p>如果构成控件的元素能够接收用户输入而改变界面状态（跳转、移动、切换等），则称其为可交互的，也就是说，这些元素将能够获得焦点。</p><p>无法复制加载中的内容</p><h4 id="焦点的默认位置"><a href="#焦点的默认位置" class="headerlink" title="焦点的默认位置"></a>焦点的默认位置</h4><p>焦点的默认位置与界面层级与内容相关，具体规则如下：</p><ol><li>层级优先，最顶层的界面优先。</li><li>核心操作优先，根据应用提供的服务决定默认焦点位置。</li><li>内容优先，遵循从上至下从左至右的方向规则。</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjIxNDJkZTFkZTNjNzE2MmJlYWM2ODM5OGZmNmNmYTNfZVNlNXBHZlprMmVTc09ZdmZEUTVsMEFqdENaelgwMWZfVG9rZW46Ym94Y25iVmdscnVSd1VaeGxaejVPVktiejNiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="跨区域获得焦点提高走焦效率"><a href="#跨区域获得焦点提高走焦效率" class="headerlink" title="跨区域获得焦点提高走焦效率"></a>跨区域获得焦点提高走焦效率</h4><p>在由多种控件组成的可划分明显区域的界面中，可设置跨区域走焦以提升效率。</p><p>无法复制加载中的内容</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWY4ZDc3ZjNjMTY5YWQ5MWQzZDg4OWYwNWJiOWU3MzlfRkRYNW9wRW9uZlZFN0V2Z1RXcGYwcVBtRDlKcWkyT2VfVG9rZW46Ym94Y25iejNhTWxPQkhuaTQ4bTdLZXZYNHVlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="焦点的自动获取与作用域"><a href="#焦点的自动获取与作用域" class="headerlink" title="焦点的自动获取与作用域"></a>焦点的自动获取与作用域</h4><p>在以下场景中焦点将自动获取：</p><ol><li>打开叠加次序更高级的页面时（例如弹出框、气泡提示等）。</li><li>跳转到新的页面时。</li><li>删除当前焦点处的界面元素时。</li></ol><p>备注：应避免刷新界面内容时带来的焦点跳动或丢失的问题。</p><p>无法复制加载中的内容</p><h4 id="Tab与光标键的作用域区别："><a href="#Tab与光标键的作用域区别：" class="headerlink" title="Tab与光标键的作用域区别："></a>Tab与光标键的作用域区别：</h4><ol><li>Tab在屏幕可见区域内的焦点间循环移动。</li><li>光标键通过切换列表、页面等操作使当前不可见部分变为可见。</li></ol><h4 id="获焦与内容切换"><a href="#获焦与内容切换" class="headerlink" title="获焦与内容切换"></a>获焦与内容切换</h4><ol><li>涉及页面内容展示时，如果焦点位置 selected 状态与 focused 状态可以分离展示，则需要激活操作（space/Enter）。</li><li>涉及文本输入时，为了走焦流畅，将只选中文本框体，不会自动进入输入状态。</li></ol><p>备注：规则1可以近似于触摸屏滑动时即切换内容的，切换焦点时也切换内容。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmRlMThiNGJkZjQzZDc5MWJmMWMzN2UxOWY5MmIwNDVfZ1hJdkxQNlFzQ3RWWjdINUtJdGV3OXBhSkhGbGVWNWtfVG9rZW46Ym94Y25DcDBpSFgzcXlaSVhPUXRKekp5VG9oXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQ1YjI4NWNiMWYwMDg2NWNjZWRiODM4MTc2MzI2NjRfYXI0dW5pazJJYlV5MDhsVHphdXNKZFpWYTIxV1E1R3lfVG9rZW46Ym94Y25BME82d2xyUE9pbm8yOGJLWWIyazhFXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTZiMzRlMzE3YTAwNTEzM2IwYzg0YzVkZTAyMGNjNmZfNUhUN0UxUWlnZ0lGNXM5U0MzcEY0eEhCZWE4UE1mVDdfVG9rZW46Ym94Y25yQnNtYnJ5aUJyWDAxb01sS05KcUlkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="帮助引导"><a href="#帮助引导" class="headerlink" title="帮助引导"></a>帮助引导</h3><p>当应用中的某些功能或信息不易理解或功能不易发现时，考虑使用帮助引导。</p><h4 id="类型-21"><a href="#类型-21" class="headerlink" title="类型"></a>类型</h4><p>使用优先级如下：</p><ul><li><p>嵌入型</p></li><li><p>操作引导型</p></li><li><p>全屏引导型</p></li></ul><h4 id="如何使用-35"><a href="#如何使用-35" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>设计帮助引导时，优先基于时间、地理位置和用户操作习惯，视具体场景来设计。出现时机应与当前的用户场景相关。</p></li><li><p>根据三种提示类型对用户的干扰程度，设计帮助引导时，优先考虑嵌入式帮助，其次考虑操作引导，最后考虑全屏引导的形式。</p></li><li><p>某些场景下，为用户提供上下文相关的特性介绍，鼓励用户去使用。例如用户看电子书时，提示用户有护眼模式。若在错误时机为用户提供了与上下文无关的特性，就是对用户的打扰。</p></li><li><p>当用户执行某个操作时，应避免打断用户的帮助提示。提示应帮助用户更好完成任务。</p></li><li><p>提示频率不宜过多，一段时间内只能提醒1次。若用户忽略提示，在后续较长时间段内，不要再次提示。若用户接受提示，表明用户希望继续探索，短时间内可再给出类似提示。</p></li></ul><h4 id="嵌入型"><a href="#嵌入型" class="headerlink" title="嵌入型"></a>嵌入型</h4><p>5种样式：</p><p>无法复制加载中的内容</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDdlMDI2MzZhMjdmMmI5MGE0NTk3ZTAyOGE5ZWM5ZjhfUnZqUnNsQzVaQmVjT2Q4VDdSS0t3VTZxSWRvRFB3OVFfVG9rZW46Ym94Y252U1pSc0RnUUtkS1d3WDA1Mmp5Y0diXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWNkMTg0ZjMwMmM0YTQ5ZDI0YWE3NzQ4ODI0ZDQzYWJfYVJIanZsY3RBeE9tS1NsNTlSYU4wTVlUbkdZNjRQTmRfVG9rZW46Ym94Y254cGZPWkFxUnNrVkVac1ZUNjllcVpkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjQwNzFkN2FjMzJjNzljMTNjNjRlOWYyMGE3MWYyMzFfZkR0cEJsa0dJUFBGS3k0UnFNOEdjR3JJUHdKZ244V1BfVG9rZW46Ym94Y24xdnZGQnBoa0o0OUMwRk1tUW1HMm9oXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="操作引导型"><a href="#操作引导型" class="headerlink" title="操作引导型"></a>操作引导型</h4><p>操作引导是主动呈现给用户的操作提示信息，主要用于重要功能或亮点功能的提示。</p><p>分为 4 类：</p><p>无法复制加载中的内容</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGU3MmIyZjMxMzYxMTFiMjI4YWQ5NzhmOWVmNjBhODRfOFdnZzBIVTk2SWVPbEtDTmVyQ3FRN3hZNEtpQ0ZXTUhfVG9rZW46Ym94Y25GdVo2dXZuQlY0dXhNdnhlSU03YUJoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTQxNWZkMGRkMGU2YjRhMmY0MGM4YTVkNzg2MWY3ZTJfNlRtMHZFako1OTgzdUNYNnprS0diUG1aT3R0dzBOeXVfVG9rZW46Ym94Y250a2xSMHRHc0EwVmkxRE5ZbU52c0xkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="全屏引导型"><a href="#全屏引导型" class="headerlink" title="全屏引导型"></a>全屏引导型</h4><p>首次打开应用时，向用户介绍新特性。</p><p>应用版本升级，再次打开新版本时，向用户介绍新特性。</p><p>两种样式：</p><ul><li><p>单页面全屏引导。</p></li><li><p>多页面全屏引导：默认有导航点，不超过三页。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2ZhMDllYmM4MjUyNDU2Y2QzYjQwMzU5ZjgxY2RhMjJfeWFHYXlEMFFrUEV5Tk9OZ3VIVlVYZ2NlMTlTS2tkcWNfVG9rZW46Ym94Y25wUFlKaW1JN2hBaTlJNUJzMVF1U0hMXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><p>编辑操作允许用户对当前内容进行修改。</p><h4 id="类型-22"><a href="#类型-22" class="headerlink" title="类型"></a>类型</h4><ul><li><p>单项编辑，例如编辑闹钟、新建联系人等。</p></li><li><p>多项编辑，例如编辑天气的城市列表、编辑多个订阅频道等。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTkzMDVjMWQzMDM4YWU2ZDM5NmVmZjI0N2RmNzY5NTVfTjFNQUtBSDN1RFA5VHdQN3hYZ2tqa2NUOGU0S2xPNTlfVG9rZW46Ym94Y25Kc1NsV2JXeXpOdjFnaTZrbUlsQWxkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="单项编辑"><a href="#单项编辑" class="headerlink" title="单项编辑"></a>单项编辑</h4><p>用于对单项的详情进行编辑。</p><h5 id="交互规则-27"><a href="#交互规则-27" class="headerlink" title="交互规则"></a>交互规则</h5><p>标题栏左边取消（叉）和右边操作（勾）。</p><p>无法复制加载中的内容</p><p>点击“叉”弹框询问是否保存，界面用语写作规则：</p><p>文本：是否保存当前修改？</p><p>按钮：不保存/保存</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjI0MDlhZmMwZGUxNzU3YmNhZTY0NDk0ZDFmY2U3ODhfTWZOemtleDFVbVpjTDNabGVXR0NwTVlIWmoweXhhVmVfVG9rZW46Ym94Y25NRjJxMjFYRjlPdGxKUkxjT1FxbFdlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="多项编辑"><a href="#多项编辑" class="headerlink" title="多项编辑"></a>多项编辑</h4><p>用于对多项进行编辑，通常是对多项进行删除或排序操作。</p><h5 id="交互规则-28"><a href="#交互规则-28" class="headerlink" title="交互规则"></a>交互规则</h5><p>多项编辑状态下，删除单项时，所选项从界面直接消失，不弹出提示。点击右上角“勾”后，才是真正删除</p><h3 id="查看更多"><a href="#查看更多" class="headerlink" title="查看更多"></a>查看更多</h3><p>界面空间有限，无法展示完整信息时，可展示主要信息，并提供查看更多入口。</p><h4 id="类型-23"><a href="#类型-23" class="headerlink" title="类型"></a>类型</h4><p>在当前界面内直接展开/收起：</p><ul><li><p>直接展开文本</p></li><li><p>直接展开更多相同类型内容</p></li><li><p>直接展开更多其他内容</p></li></ul><p>跳转新界面显示全部内容：</p><ul><li><p>内容下方新起一行</p></li><li><p>子标题右侧</p></li></ul><h4 id="在当前界面内直接展开"><a href="#在当前界面内直接展开" class="headerlink" title="在当前界面内直接展开"></a>在当前界面内直接展开</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzYzOWI1ZTlhZGIyZjZjMjJmZGEzNTg5OWIyYWU3ZGJfQ1hqSDBkc0VGOHM3ZmNKZ3dnNGg1SkxYSGdCeVZSeFhfVG9rZW46Ym94Y25xS25sMDVlbXpsbjBZd1RCYlRJZ2ljXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODdiNDYxNmZiOTMxYWRmNTE1MGIzNjcwYjg4YmU0YWZfcm1RQ0hNcTBHYVAxZWM2QnpkVGRpUUwyU0FGcFJldVpfVG9rZW46Ym94Y25yOW1ySk96VXZrNExwVUptVlp4elFnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="跳转到新界面显示全部内容"><a href="#跳转到新界面显示全部内容" class="headerlink" title="跳转到新界面显示全部内容"></a>跳转到新界面显示全部内容</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Q1NDU4NjcwYjg2NzIxYTg1ZGU3NjM0MmMyNjhkNDZfWXNmSkZqUFI0cHJybXN6SmE0cE9YVFFVemQ1dEIwaFNfVG9rZW46Ym94Y25oMnZKczBlU3N2ajh1WUI2bmw4TXRjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="第三方品牌露出"><a href="#第三方品牌露出" class="headerlink" title="第三方品牌露出"></a>第三方品牌露出</h3><p>应用中使用了第三方提供的技术或服务，因知识产权或服务提供方要求，在界面中标识第三方品牌。非沉浸式页面按照本文所述进行布局和提示，在页面底部显示相关信息。通常以品牌文字露出或品牌标识露出的方式呈现。沉浸式页面根据实际场景结合内容融合设计，规范不做特殊要求。</p><h4 id="类型-24"><a href="#类型-24" class="headerlink" title="类型"></a>类型</h4><ul><li><p>提供内容类的服务支持</p></li><li><p>提供技术类的服务支持</p></li></ul><h4 id="提供内容类的服务支持"><a href="#提供内容类的服务支持" class="headerlink" title="提供内容类的服务支持"></a>提供内容类的服务支持</h4><p>有两类形式：品牌文字露出和品牌标识露出。</p><h4 id="品牌文字露出"><a href="#品牌文字露出" class="headerlink" title="品牌文字露出"></a>品牌文字露出</h4><ul><li><p>在页面底部以文字形式进行提示。</p></li><li><p>需要时可添加链接，样式不变。</p></li><li><p>格式为：[xxx 服务]由[xxx 公司]提供。[ ]中括号内文字根据实际情况填写，实际不显示中括号。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWU0ZTQyNGMwYTkxMzRiMTk3NDZmYTVhMGYzMmFlZGNfT256TGw3YWVMbjcyOVVKVTJKNjJKVzZEN2NPallnM3VfVG9rZW46Ym94Y25Dbkx1YlRFdHJXV0REMXBDUzVCMm1mXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="品牌标识露出"><a href="#品牌标识露出" class="headerlink" title="品牌标识露出"></a>品牌标识露出</h4><ul><li><p>当品牌较少时，可以在一行放下，则格式为：左侧文本+右侧标识图标</p></li><li><p>当品牌较多时，一行放不下时，则格式为：上方文本+下方标识图标从左到右依次罗列</p></li><li><p>具体文本根据具体内容来显示，例如数据来源。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGMxYWRjYzliNjM0NGVjYmU0N2QyMzA1NDhlZjJhYTJfam02bWxlRHZMNEN3bnVkZ3BXbmRldEJEUHRRNEt6VnZfVG9rZW46Ym94Y240anNQaGt5RmhkcmhpcGlwTlNuYVZnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="提供技术类的服务支持"><a href="#提供技术类的服务支持" class="headerlink" title="提供技术类的服务支持"></a>提供技术类的服务支持</h4><p>有两类形式：品牌文字露出 和 品牌标识露出</p><h5 id="品牌文字露出-1"><a href="#品牌文字露出-1" class="headerlink" title="品牌文字露出"></a>品牌文字露出</h5><p>格式为：[ xxx ]提供技术支持</p><p>[ ]中括号内文字自定义，实际不显示中括号。</p><h5 id="品牌标识露出-1"><a href="#品牌标识露出-1" class="headerlink" title="品牌标识露出"></a>品牌标识露出</h5><p>当品牌较少时，可以在一行放下，则格式为：左侧文本“技术支持”+右侧标识图标</p><p>当品牌较多时，一行放不下时，则格式为：上方文本“技术支持”+下方标识图标从左到右依次罗列</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2Y4NGQyZTZiOTRjY2NjYWZlZWE3NTA1NjZlNTAyYzlfd2dsdHRwQzEzcjF4VUdwRmV3OU5yNXN3VzJNUkdmV0xfVG9rZW46Ym94Y242U2tMdzdYYWh3b3hXQU5CbnZiajVnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzQwOWRiOTg2ZmZhMzI2NDgyN2FhYjRiZDI4ZjkyNThfS1QxVVZKNVlSTTZqSDRGR0NXdTFKRWdYR0lCYTA3bzRfVG9rZW46Ym94Y25UMUlCcExIMXFKSkxVU2tCUEtIUGZkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzE0Y2RiMmY2ZDFlMDRjOTc2YTNiMzY3N2Q2NjEzMGJfdGpXVk4xSTFOS29ZbHhjTzhJNzFNVk9MSHVKamw3QTNfVG9rZW46Ym94Y25hSmEwNFpmUmlob2RSNmk5MXpyREZmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="分栏"><a href="#分栏" class="headerlink" title="分栏"></a>分栏</h3><p>分栏是一种层级关系的左右分窗口布局，旨在为宽屏幕设备提供较好的显示效果，以及帮助用户更高效地处理任务。</p><h4 id="设计原则-2"><a href="#设计原则-2" class="headerlink" title="设计原则"></a>设计原则</h4><ul><li><p>8 栅格以上的设备可支持分栏。</p></li><li><p>特定类型应用适用于分栏，例如办公类应用、效率型应用、IM 社交类应用(邮件、备忘录、文件管理、设置、短信等)。</p></li><li><p>允许用户在设置中关闭分栏，或在应用内临时从分栏切换到全屏。</p></li><li><p>不支持分栏的应用，在宽屏设备上可通过平行视界解决宽屏显示</p></li></ul><h5 id="基于栅格的分栏布局"><a href="#基于栅格的分栏布局" class="headerlink" title="基于栅格的分栏布局"></a>基于栅格的分栏布局</h5><p><strong>8 栅格以上的设备，可分栏；8 栅格以下的设备，不支持分栏。</strong></p><p>8 栅格以上设备包括：手机横屏、折叠屏横/竖屏、平板横/竖屏、电脑、电视等。</p><p>各设备的栅格规则具体可参考：<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/layout-0000001110498552" target="_blank" rel="noopener">栅格系统</a>。</p><p>分栏位置在当前窗口的 40% 或者 50%（业务根据需要选择），左右 2 个区域窗口内的内容根据窗口宽度重新计算内部的栅格数量进行布局。</p><p>有父子结构的应用，例如设置、邮件、短信、联系人、记事本。如果父页面底部有页签，需要保证每个页签都适合分栏，避免同一个应用内部分页签分栏部分页签不分栏的不统一情况。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDIyM2M2YmU0NGRjOWU5ZGU2OWNlZTY0MzY5NmZhMGJfbk9rMUlFSUVhNVFwOWlRSHR3d1BGcjFQYjlON2RYWDlfVG9rZW46Ym94Y25XS2xPaUc3ZDBUcmdHRmlwSW91c1ljXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="交互规则-29"><a href="#交互规则-29" class="headerlink" title="交互规则"></a>交互规则</h5><p><strong>应用内开关：</strong>在应用内可点击“全屏/退出全屏”按钮，切换到全屏/分栏展示。开启应用内全屏/分栏后，下一次启动应用，依然记录上次的状态。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTY5ZWQ3MmQ4MjM3MGRhNjAxYzY4Y2M2ZmIwYTJlZThfcHNmMHFWdWo4RVNxdmRVWWM5cjlaWkM0aDNZUXdVYjRfVG9rZW46Ym94Y241WVh0WTR6UkFpRENyMUpGeFdtVk1mXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>通过应用内开关，切换到全屏/分栏后：</strong></p><p>\1. 进入/退出编辑，跟随上一次状态的全屏/分栏。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTc3MWMzZTkwYjZiMjBhNjQ2MTJiZmVlM2NjMjM1MWNfMjVoVDJwSWpIUmhEcnYzTDJlZUVITm03S1djM1dnTHhfVG9rZW46Ym94Y25kZGR3TWlKSUxMR3NTTXRzbmtVR0tkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>\2. 访问下一层级内容，跟随上一层级的全屏/分栏。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzg4ZGMwYTU5ZTMxMmI3NjMwZjE3ZWE3MzllNWE1OGNfU0drd0JjVENtcDA5WWgzb2NMbkwxNVpWZ2ZzUnZyb0xfVG9rZW46Ym94Y25MZWpUbkViWHIyNVllTTlnNjRDWERiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>\3. 打开新建功能，无论上一层级页面是全屏还是分栏，均全屏显示新建功能。例如新建邮件、新建备忘录等。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmY4YTUyNDQ0NTY5NTk0ZjczNTI0MDkyZTk1NWQ0ZTRfVzdzYVMzU1NocUVlajMwdnBzSlVrd1lXT0lwTFdYTW1fVG9rZW46Ym94Y25rend6Q21vVko2SVZxTDFpRmNqdHJlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="分栏种类"><a href="#分栏种类" class="headerlink" title="分栏种类"></a>分栏种类</h4><p><strong>多层级应用的分栏</strong></p><p>左侧始终是列表结构的首页，右侧内容可切换。例如折叠屏、平板上设置应用的分栏。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Njc3ZjVmNDhkNTE2MDZiNTQyNjRiMjJlMDAzZThhYWFfUDFCcHBFT0lBdUhWVmxTeFRvVDhnWWgyT0VsbkdQNFNfVG9rZW46Ym94Y25jS2FtQzlvQ3BlempoZHc4VnBvM2R3XzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>单层级应用的分栏</strong></p><p>右侧始终是内容详情，左侧可切换到上一层级菜单。例如折叠屏、平板上邮件应用的分栏。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmFkYTRiYTVmYmRiNDZjYmVmOWNhZDAxYTMyNzQ2OWJfNGR6MDAyNEl0cVAydFViaDl1eDFjR01sQ2E1MElMUHpfVG9rZW46Ym94Y25jQ0pIN2ZaSm9aQVRIOVNlYXZOQ2pLXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h3><p>用户可通过“分享”操作，将内容分享给他人。</p><h4 id="类型-25"><a href="#类型-25" class="headerlink" title="类型"></a>类型</h4><ul><li><p>通过系统控件分享：点击后直接弹出系统分享框进行分享。</p></li><li><p>应用自定义渠道分享：点击后直接弹出应用定制的分享框进行分享。</p></li><li><p>预览后分享：点击后先预览分享效果，例如海报、视频等，再选择分享方式。</p></li></ul><h4 id="通过系统控件分享"><a href="#通过系统控件分享" class="headerlink" title="通过系统控件分享"></a>通过系统控件分享</h4><ul><li><p>系统提供分享控件，应用可直接调用系统分享控件进行分享操作。</p></li><li><p>分享控件在屏幕底部显示，使用网格方式陈列各分享渠道。</p></li><li><p>分享控件规范详见<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/share-0000001110661490" target="_blank" rel="noopener">“控件”&gt;“分享”</a>。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjZkOWMxM2UwNmEyNjhhMDRkYjQwN2NjODQ4OGQ5YjhfTlVHd0Vla3hnd2xNWjRVSFZzV3YxV2czZDZmZkFMQXVfVG9rZW46Ym94Y25CWThoczJvRWpPSmtIRXQzUEVRZUVlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="应用自定义渠道分享"><a href="#应用自定义渠道分享" class="headerlink" title="应用自定义渠道分享"></a>应用自定义渠道分享</h4><ul><li><p>系统分享控件的分享渠道无法满足应用需求时，应用自己定义渠道直接分享。</p></li><li><p>先显示业务推荐的分享渠道，最后一个地方显示“更多”，分享渠道以网格形式呈现。点击“更多”显示系统分享控件。</p></li></ul><h4 id="预览后分享"><a href="#预览后分享" class="headerlink" title="预览后分享"></a>预览后分享</h4><p>有些场景，用户分享前需对分享内容进行编辑或预览，例如音乐应用，选择部分歌词后分享歌词卡片；阅读应用，分享自己的书摘想法等。这类场景，可提前预览最终分享的内容。</p><h3 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h3><p>帮助用户了解该应用的更多信息。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjdkZGU3NGMzMGMyZTM3MmVkMWMwYTVjMTU0OWM1MzZfakc4d0V3dVBSeWprNk1XZEpEWGptSldGT0xFMktuVEFfVG9rZW46Ym94Y25PS2cwWktFN3p6MUdRNHB2OENvU1lmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmRkMmEyNGZhYmFmOTBkZDY4YmZhNGI0OWNhNzk2NGRfWndoRjdSaTZONUxGeDdmVGRWRlExTDB1bDJEN2gwdXlfVG9rZW46Ym94Y25IVDZWN1N1U1BGRmJ1ckJLUGJNSE1mXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDQ4NmQ3YTk5N2RjZWVmMTI3OWE4NzI4NGYyNTg3MmJfZzBSY1pTcmROd0I4OUV1M3p1bTd5V0FJblV2dDROU3pfVG9rZW46Ym94Y25ZUmpiakJjdjZzcnhjUkdmMUZwVWJvXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmNmZjM3MWQ1ZTBiNjRjNDk1ODVkMjc3ODBiNDMwOTdfSHl1TlBEZVVsdTFNYXZ2MFJYRU9ORzUxS21EZkhGZEpfVG9rZW46Ym94Y25RZ0EzMHIzWmtHV0RPVVRCOEtWUmhkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="空内容界面"><a href="#空内容界面" class="headerlink" title="空内容界面"></a>空内容界面</h3><p>应用的整个页面或局部区域无内容。</p><h4 id="类型-26"><a href="#类型-26" class="headerlink" title="类型"></a>类型</h4><ul><li><p>整个页面内容为空</p></li><li><p>页面局部内容为空</p></li></ul><h4 id="整个页面内容为空"><a href="#整个页面内容为空" class="headerlink" title="整个页面内容为空"></a>整个页面内容为空</h4><ul><li><p>在空内容的区域显示内容相关图标+文字：“没有XXX”。</p></li><li><p>若需增加额外说明，说明文字在“没有XXX”下方，如果不超过一行，居中显示，如果超过一行，则居左显示。</p></li><li><p>说明文字下方可显示“新建”等推荐用户使用的与当前页面相关的功能，在页面底部使用底部大按钮。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjkwNDY3ZGI0MjdiMjdiMTNmMTY3MmY2YWU0MzFmM2RfUW9BREtxRDc0Q2ZjaFNudGxaMHNLaFZmWU5ManJCUUxfVG9rZW46Ym94Y25CeXN4Nkt5bVBoYnQyTlY3RHZlV1hiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="页面局部内容为空"><a href="#页面局部内容为空" class="headerlink" title="页面局部内容为空"></a>页面局部内容为空</h4><ul><li><p>在空内容的区域显示内容相关图标+文字：“没有XXX”。</p></li><li><p>若需增加额外说明，说明文字在“没有XXX”下方，如果不超过一行，居中显示，如果超过一行，则居左显示。</p></li><li><p>空内容提示文字下方如需增加操作按钮，使用文本按钮。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGZmMTE0YmFiMWZhNjZiZTM4NzU3NDRjY2IyM2IxOTRfZzRKZEZCSXRQUkY5Skk4Q2M2bVhBeXhxeW1BRDlNbllfVG9rZW46Ym94Y25Ocjk1N0pZVlJVR0xBNnp6bHFtR1Q1XzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTY1ODRhODdkM2U1YTc5MGExZDBlNjljNWMwZWE4YzhfYUViZDd3VWRxVHdPcU5ESFJQbmxES25jQmRmWVJ5OXBfVG9rZW46Ym94Y25hUFg3c0p5bmg2Rk0xRHV2ZzNha3RlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWY1OWRkNDNlNDdlMDM5YTVjNGRmNTU2ZWRhNDAyNDFfd0RDQW9KMktDNFJSZ21xNm5FME5ETTd0NExsUXZuVzBfVG9rZW46Ym94Y25OYlJFdTlZSEQwWDNpU3Z4cGlDNlRjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2E4YmU4N2VjMWQ4MTcxZmIzMTgyOWU4YzdkZmQxMDVfUGdGWFB5eUNvWTBqNEdyQXB3MVZqYnAxTkFPbldOdnFfVG9rZW46Ym94Y25ZaEtYa2ZEeENtTmZldjhYS1pXSlhkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="快速定位"><a href="#快速定位" class="headerlink" title="快速定位"></a>快速定位</h3><p>界面内容较多，且用户有查找需求，需提供快速定位的操作方式。</p><p>使用应用有：联系人、信息、邮件、图库、文件管理、云服务等。</p><h4 id="类型-27"><a href="#类型-27" class="headerlink" title="类型"></a>类型</h4><ul><li><p>点击底部页签快速回页面顶部</p></li><li><p>字母索引定位</p></li><li><p>滚动条快速定位</p></li></ul><h4 id="点击底部页签快速回页面顶部"><a href="#点击底部页签快速回页面顶部" class="headerlink" title="点击底部页签快速回页面顶部"></a>点击底部页签快速回页面顶部</h4><ul><li><p>在有底部页签的应用，尤其是有较长信息流的情况下，用户浏览很多内容后，可以通过单击当前页面的底部页签快速回到顶部。</p></li><li><p>详见<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/bottom-tab-0000001110467118" target="_blank" rel="noopener">“控件”&gt;“底部页签”</a>。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODFmMTVjNGRjMWY1OThjNGViODJhZjFhNTZhZTAxNGZfb0U2WVhJQkVPUFF1b2QyTzNtT1Fud3A4WTJYUExIRWNfVG9rZW46Ym94Y245aFRwNU44VU9adFVJbHlWQU1HQU5kXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzlkMTJjYzM1MjhhMmM1MmMyZDMyZDQ2YWNjMDljNTBfSjRSajdNYUVYYUJUWG5TQkNveG1semp2Ujl2UHpmVXFfVG9rZW46Ym94Y25vaTh0dVJITkYzVjE2M1lDUlVPV3NjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="内容加载"><a href="#内容加载" class="headerlink" title="内容加载"></a>内容加载</h3><p>内容加载指获取内容并呈现出来。</p><h4 id="类型-28"><a href="#类型-28" class="headerlink" title="类型"></a>类型</h4><ul><li><p>局部加载</p></li><li><p>上拉加载</p></li><li><p>H5 界面加载</p></li></ul><h4 id="局部加载"><a href="#局部加载" class="headerlink" title="局部加载"></a>局部加载</h4><p>界面内部分内容需要加载，分区域加载和数值加载 。</p><ul><li><p>区域加载：在需要加载区域内加载，不要弹框显示加载。</p></li><li><p>数值加载：数值暂未获取到的，显示“–”，全部数据获取到后，再显示数据。</p></li></ul><h4 id="上拉加载"><a href="#上拉加载" class="headerlink" title="上拉加载"></a>上拉加载</h4><p>在内容已刷新的页面，进行上拉加载更多内容的操作。使用应用有邮件、应用市场等。</p><p>上拉加载：上拉时，屏幕下端区域显示加载动画（非模态）+ “正在加载…”。加载完成：显示加载出的内容。加载失败后的提示：“加载失败，点击重试”</p><h4 id="H5-界面加载"><a href="#H5-界面加载" class="headerlink" title="H5 界面加载"></a>H5 界面加载</h4><ul><li><p>调用网页内容的界面使用。</p></li><li><p>在标题栏底部显示加载进度。使用进度条控件。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MThlN2UyZDkyMDA3ZGRkNDdiMWUzNTZhNjBiZGQ5YWRfVTNUc09xTjBnN2lzd1JYb2Z1Qk1EV29JVEZNUWd1b2dfVG9rZW46Ym94Y25PU3VXUlUyS1lkUG04a2JlSVVyZmZlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="扫一扫和二维码"><a href="#扫一扫和二维码" class="headerlink" title="扫一扫和二维码"></a>扫一扫和二维码</h3><p>扫一扫：通过相机取景来识别相关信息的流程。</p><p>二维码：规定一般场景下二维码的大小和布局。</p><h4 id="扫一扫"><a href="#扫一扫" class="headerlink" title="扫一扫"></a>扫一扫</h4><h5 id="界面元素"><a href="#界面元素" class="headerlink" title="界面元素"></a>界面元素</h5><p>一般情况下，扫一扫页面通常有如下几个组成元素：</p><p><strong>标题区</strong></p><p>\1. 标题栏：右侧最多放 3 个图标，多于 3 个放到更多按钮里面。</p><p><strong>说明区</strong></p><p>\2. 引导文案（必要组成元素）</p><ul><li><p>标题：扫描二维码、扫描银行卡。</p></li><li><p>辅助说明：不做限制，应用可自己根据需要进行描述，例如提示用户扫描的目的、扫描时的一些注意事项等。</p></li></ul><p><strong>扫描区</strong></p><p>\3. 扫描框（必要组成元素）</p><ul><li><p>用于引导用户将扫描对象置于目标区域中。</p></li><li><p>框内有自上而下的扫描动画。</p></li></ul><p><strong>其他功能区</strong></p><p>\4. 开启手电筒功能：不常驻，传感器感光弱时自动出现。</p><p>\5. 按钮区（可选）：提供除了扫码之外的功能，例如手动输入。</p><p>\6. 底部页签（可选）：可切换来执行不同的扫描任务，例如购物、翻译等</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MWNkYzg3YjQwNjAxMTY0ZTc5MmE0ZTcyYmNkMGNjMWJfRk10QUR6OHJUZ1pZNWNoSzRMbUNZSkNpdkVub0laZHZfVG9rZW46Ym94Y24wMFVCcU9ac25hb0RzU05OOG9tRUZlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="扫描框"><a href="#扫描框" class="headerlink" title="扫描框"></a>扫描框</h4><p>常见 2 种样式：</p><ul><li><p>无边框：扫描对象为二维码</p></li><li><p>有边框：扫描对象为银行卡、条形码；边框高度可自定义调整</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGZkNTBhZjE4NTYxZjE2ZWE1YjZkN2I0OTgwZGQwZmVfdDBqRm5rSnEyYnA5YWkzVHIwTTVVSFYwSmZwd3NBOE9fVG9rZW46Ym94Y25OOW9ubkxGbW94ckM5RGo1dUFUMkFlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWZkNTEwMzRkZDgwYjk1YjRhN2UyZjU1NzU5ODk4NjZfTWtxYkhMNjFSVW9adHdDYnVBNW85Y1NVTk1sM0Y4TEFfVG9rZW46Ym94Y24xN2wxRWRPa1JucVJEQ1VMRTBOVFFmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>说明区</strong></p><p><strong>默认模版：</strong>顶部、扫描区、底部比例为 2:3:2。</p><p><strong>自定义模版：</strong>顶部、扫描区、底部比例可根据内容调整为 2:3:3。</p><h4 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h4><p>定义 2 种尺寸。</p><p>大尺寸：通用类。例如全屏、弹出框等。</p><p>小尺寸：特殊布局使用。例如银行卡二维码、乘车二维码等。</p><p>可配置头像。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>用户主动将不需要的内容项从系统删除的操作。删除成功不显示即时反馈提示。</p><h4 id="类型-29"><a href="#类型-29" class="headerlink" title="类型"></a>类型</h4><ul><li><p>列表横向滑动删除，例如邮件、信息。</p></li><li><p>删除单个对象，例如联系人详情。</p></li><li><p>删除多个对象，例如闹钟、天气、图库。</p></li><li><p>删除单个图片，例如信息中编辑信息的时候删除图片。</p></li></ul><h4 id="列表横向滑动删除"><a href="#列表横向滑动删除" class="headerlink" title="列表横向滑动删除"></a>列表横向滑动删除</h4><ul><li><p>效率优先，推荐删除后直接消失，无需弹框二次确认。在应用发生误删除情况时，如果删除后数据丢失且不可找回，给用户造成数据损失，则需要弹框二次确认。</p></li><li><p>在横向滑动菜单出现的时候，对屏幕其他区域的操作将收起横向滑动菜单。例如对列表进行滚动，对另外的项进行横向滑动，点击屏幕上的其他操作项等。</p></li><li><p>在横向滑动菜单出现的时候，点击跳转到其他页面，不收起横向滑动菜单，跳转到其他页面后，横向菜单回收。从其他页面切换回来的时候，横向滑动菜单已是收回状态。例如底部页签切换。</p></li></ul><h4 id="删除单个对象"><a href="#删除单个对象" class="headerlink" title="删除单个对象"></a>删除单个对象</h4><ul><li><p>详情界面，针对整个界面的删除操作，需有提示框进行确认（邮件应用详情界面删除默认不提示，在邮件设置中可以打开提示 ）。</p></li><li><p>查看详情界面，有删除功能，例如邮件详情界面。</p></li><li><p>无查看详情界面时，删除放在编辑界面，例如编辑闹钟界面。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTExZGE2NTc5ZjI2MGQ2MTFiYTY2NjE2OGU5YWVlMmNfVjdCMHNHaUlPdmNoNGxJaXFLUWJFVEVLYWJiT0U4YWFfVG9rZW46Ym94Y24wTXZYSFJrWTZQblljbDlUbkt6UTFlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="删除多个对象"><a href="#删除多个对象" class="headerlink" title="删除多个对象"></a>删除多个对象</h4><p>多选删除操作，需有二次确认框。</p><h4 id="删除单个图片"><a href="#删除单个图片" class="headerlink" title="删除单个图片"></a>删除单个图片</h4><p>在图片的右上角提供删除功能。点击后，直接删除，无需确认。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWQ4MTI0NTEwMjc1NTBkYzQ3NDQxODVkZTJmZTAyYTVfTXhxQUlVNzFNb2dRenNPZTdrRkFQWmR2cUw5bGI1ZmtfVG9rZW46Ym94Y25qTXdGQktFeWc2M0tyOUwzajUxUXZmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="动效规则-3"><a href="#动效规则-3" class="headerlink" title="动效规则"></a>动效规则</h4><h5 id="单个删除"><a href="#单个删除" class="headerlink" title="单个删除"></a>单个删除</h5><p>在列表项被删除时，会将临近的列表项填补进来，此过程中要体现补位动效。</p><p>在列表内容未超出一屏时：</p><ul><li><p>删除项中的任何一项或多项（不包含最后一项），该项下面的未删除项将往上补位。</p></li><li><p>当删除项含最后一项时，最后一项直接消失。</p></li></ul><p>在列表内容超出一屏时：</p><ul><li>默认向上补位，如果下面的项本身就处于屏幕底部，无法向上补位时，就使用向下补位。</li></ul><h5 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h5><p>批量连续删除：被删除项大于等于 2 项，且位置相邻，删除后补位项向上补位。无法向上补位时，就使用向下补位。</p><p>批量间隔删除：被删除项大于等于 2 项，位置有间隔，删除后补位项向上补位。无法向上补位时，就使用向下补位。</p><h4 id="列表横向滑动删除动效"><a href="#列表横向滑动删除动效" class="headerlink" title="列表横向滑动删除动效"></a>列表横向滑动删除动效</h4><p>在列表项被删除时，会将临近的列表项填补进来，此过程中要体现补位动效。</p><p>在列表内容未超出一屏时：</p><ul><li><p>删除项中的任何一项或多项（不包含最后一项），该项下面的未删除项将往上补位。</p></li><li><p>当删除项含最后一项时，最后一项直接消失。</p></li></ul><p>在列表内容超出一屏时：</p><ul><li>默认向上补位，如果下面的项本身就处于屏幕底部，无法向上补位时，就使用向下补位</li></ul><p>横滑删除动效设计描述：</p><ol><li>向上补位：被删除项向上位移一个项的高度，同时淡出，向上补位的项向上移动，补充空白的位置。</li><li>向下补位：被删除项向上位移一个项的高度，同时淡出，向下补位的项向下移动，补充空白的位置。</li></ol><h4 id="界面写作规则-12"><a href="#界面写作规则-12" class="headerlink" title="界面写作规则"></a>界面写作规则</h4><p>删除确认弹框的界面用语写作规则：</p><ul><li><p>选择单项时 : 是否+（动作）+ 此 +（数据项）？</p></li><li><p>选择多项时 : 是否+（动作）+（空格）（数量）（空格）+（单位）+（数据项）？</p></li><li><p>选择全部时 : 是否+（动作）+ 全部 +（数据项）？</p></li></ul><p>例如是否删除此联系人？／是否删除 8 个联系人？/是否删除全部联系人？</p><p>若页面仅一项内容，多选中选择该项，删除确认弹框使用单项删除的提示语。</p><h3 id="上下结构布局"><a href="#上下结构布局" class="headerlink" title="上下结构布局"></a>上下结构布局</h3><p>上下结构布局介绍了常用的页面布局样式。</p><h4 id="类型-30"><a href="#类型-30" class="headerlink" title="类型"></a>类型</h4><ul><li><p>上下文本</p></li><li><p>上图下文</p></li></ul><h4 id="上下文本"><a href="#上下文本" class="headerlink" title="上下文本"></a>上下文本</h4><h5 id="交互规则-30"><a href="#交互规则-30" class="headerlink" title="交互规则"></a>交互规则</h5><p>滑动：下文向上滚动时，整屏滚动，即上方的文本区域是跟随下方文本一起滚动的。</p><h5 id="视觉规则-33"><a href="#视觉规则-33" class="headerlink" title="视觉规则"></a>视觉规则</h5><p>上面区域仅包含文本，上面区域为 21:9 的比例（不含状态栏）。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmNkNjE4ZDlhZjNlMGZiZWYyZjRiNGJhZDliYTlhNDRfOXBIeWlmN2gwRzQ2T29OMGhxMk5ZZzNYVE9OT1NBempfVG9rZW46Ym94Y25jT2FHRFMydHdQTUFhOVFMZWNIRzRnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="上图下文"><a href="#上图下文" class="headerlink" title="上图下文"></a>上图下文</h4><h5 id="交互规则-31"><a href="#交互规则-31" class="headerlink" title="交互规则"></a>交互规则</h5><p>滑动：下文向上滚动时，整屏滚动，即上方的图片区域是跟随文本一起滚动的。</p><h5 id="视觉规则-34"><a href="#视觉规则-34" class="headerlink" title="视觉规则"></a>视觉规则</h5><p>页面区域包含图片区域与文本，比例 3:2 和 1:1 两种。</p><p><strong>3:2</strong></p><p>上面区域包含图片与文本，比例 3:2（不含状态栏）。详细规则参考“<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/illustration-0000001156818445" target="_blank" rel="noopener">插画</a>”</p><p><strong>竖屏</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzM3NGYxYjkxZTU1MmQ1Y2IwZGY0NjAxNzJlNzdhODlfbEoycTFiZXF6NVp5Q2xTaGpraGF2Qmp1Y1VyV0R1MUZfVG9rZW46Ym94Y240cVFPeFNnajNCUFNsYVNZOExqM3FlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>1:1</strong></p><p>上面区域包含插画，比例 1:1（不含状态栏）。</p><p><strong>竖屏</strong></p><p>底部组合样式：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWRjYTZjMzVjYjNlYzk1ZWJlMDM0ZjE1ZTZjMWRiOTZfSWhkZXQ3UDVjUWloZjhTNURsVnVucUdQbDlZVkJwd0tfVG9rZW46Ym94Y25NSzczZHhhaTRJWjlyMm0zUjhPaU1nXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="上图下文弹框"><a href="#上图下文弹框" class="headerlink" title="上图下文弹框"></a>上图下文弹框</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzYwZjJlYzhhNzkzNmQ0NDdjMGNjNjhhMDg0NTRkYWNfWmswSHc1QUZqRUM5QTZuaVBjWmxvUGxGM3EwYWs1UFJfVG9rZW46Ym94Y25oeFBTN2w2OGRxQU5RU0h5MmFrYnliXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="界面用语"><a href="#界面用语" class="headerlink" title="界面用语"></a>界面用语</h5><p>上图下文如果是介绍新功能，底部按钮字符串“立即XX”，例如立即使用、立即体验等。</p><h5 id="文本对齐方式"><a href="#文本对齐方式" class="headerlink" title="文本对齐方式"></a>文本对齐方式</h5><ul><li><p>标题：始终居中对齐。</p></li><li><p>正文（普通）：一行或多行均居中对齐。</p></li><li><p>正文（带序号）：居左对齐。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTdjZDAzMjc0NTRlNjExYjUzYTRiYmEzOTRkMTcyNzJfRUdDRFRDMkJOSGwxYjhQNWtFU2xPZGhQMXc4clhZYWlfVG9rZW46Ym94Y25USHZhWVpEa3ZZUGFTNHRrNjlRVHJnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><p>用户或应用可通过刷新获取最新内容。使用应用：邮件、天气、阅读、文件管理器、视频等。</p><h4 id="类型-31"><a href="#类型-31" class="headerlink" title="类型"></a>类型</h4><ul><li><p>自动刷新</p></li><li><p>下拉刷新</p></li><li><p>点击“刷新”图标或菜单触发</p></li></ul><h4 id="自动刷新"><a href="#自动刷新" class="headerlink" title="自动刷新"></a>自动刷新</h4><ul><li><p>默认进入可刷新界面后自动刷新。</p></li><li><p>根据业务特性需要，需要在一定时间间隔后自动触发内容的刷新。</p></li><li><p>用户在当前界面操作时，应用可在后台获取更新信息，并提示用户更新了几条，但界面内容不刷新。</p></li></ul><h4 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h4><ul><li><p>凡需通过互联网获取最新内容，都可采用下拉刷新。</p></li><li><p>下拉过程中显示加载转圈动画。</p></li><li><p>下拉小于规定距离时，松手后页面直接回弹。</p></li><li><p>下拉超过规定距离时并松手，触发刷新动画，仅显示加载转圈动画，不显示文字。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzE5ZDMyM2JhMDI0YzgxNDYzZTViNTkyNTUwNGRiOGZfeXM5VzRVYnhWekJTZUNHQ3BRRUJZTGRrOTZOa1h6SmpfVG9rZW46Ym94Y25rUHUzdDlFZHZTYmdVcEZRS0ZvMHhmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>默认仅显示加载转圈动画即可</p><p>业务可决定是否显示上次更新时间，字符串格式为：“上次更新时间： XXXX ”，XXXX 按照时间日期显示规范显示。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjgzMmQ0ZTI0ZDgwY2U4N2I3ODNkMTRkY2IzMzg4M2FfSEcxdk5JSnlhRDRzempKa1FHSVdySktvNWVjS0ppSXdfVG9rZW46Ym94Y25OVkhMbkZDQWh3ZUpiQTFRaml3YktoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="刷新过程"><a href="#刷新过程" class="headerlink" title="刷新过程"></a>刷新过程</h4><ul><li><p>不论通过下拉触发刷新还是点击相关图标或菜单触发，刷新过程中，用户可在内容区域上下滚动浏览内容。</p></li><li><p>此时刷新条区域变窄，悬浮在内容区上层，显示加载动画＋“正在刷新…”字符串。</p></li></ul><h4 id="刷新结果"><a href="#刷新结果" class="headerlink" title="刷新结果"></a>刷新结果</h4><ul><li><p>根据业务场景考虑刷新结果的显示。</p></li><li><p>刷新成功，顶部可使用悬浮条提示：“更新了 XX 条XX”，例如“更新了 15 条新闻”。可点击悬浮条快速回到页面顶部。悬浮条显示时长同即时反馈长提示，超过后自动消失。适用场景：新闻资讯类信息流（业务自定义是否使用悬浮条）。</p></li><li><p>刷新成功后，若用户处于浏览内容过程中，则不能中断用户操作，不自动回到页面顶部，不自动刷新页面。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTUxY2E3Y2I4OGNkZjhhMzRjZjBmYmM0NzZjMmU4MDlfcHFRaXI4UGJhSXE1N2tZdkdRSUQ1VVcxZXlrQ2ZFY1RfVG9rZW46Ym94Y25nOHFHcnk1b1FWZ3A2NnY3OU9oYkhmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><ul><li><p>刷新失败，顶部悬浮条提示。</p></li><li><p>如果是网络异常造成的刷新失败，按照<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/exception-0000001110652998" target="_blank" rel="noopener">网络异常提示</a>规范进行提示。</p></li><li><p>如果是其他原因造成刷新失败，直接在顶部悬浮条提示“刷新失败”或具体原因。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2IwYjI3NDcxZGQ0Njg1NjIzYzhhYjBhZWQzYjA5ZmVfUk11Unl3TWtIVGNsb2c0YzBHZU1aNnNMUWVGZU5PcndfVG9rZW46Ym94Y25yWktncjg0UTdBZnNRQmlpdWhhZWFjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>开发指南，详见 <a href="https://developer.harmonyos.com/cn/docs/documentation/doc-references/js-components-container-refresh-0000000000618205" target="_blank" rel="noopener">refresh</a> (JS)。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>通过输入关键词找出与给定关键词相关的内容。</p><h4 id="类型-32"><a href="#类型-32" class="headerlink" title="类型"></a>类型</h4><p>根据搜索反馈方式，分即时搜索和非即时搜索。</p><ul><li><p>即时搜索：根据输入的关键词，进行内容的实时过滤。</p></li><li><p>非即时搜索：输入关键词，不立即显示搜索结果，但可显示联想内容和推荐。</p></li></ul><h4 id="即时搜索"><a href="#即时搜索" class="headerlink" title="即时搜索"></a>即时搜索</h4><p>搜索入口</p><ul><li><p>顶部搜索框入口：当搜索在该页面为常用的行为时使用。</p></li><li><p>标题栏右侧搜索图标入口：当搜索在该页面为不常用的行为时使用。</p></li></ul><p>激活搜索</p><ul><li><p>点击搜索入口后，进入搜索页面，弹出输入法键盘，搜索输入框置顶显示，左侧显示返回。输入框内显示焦点。此时按系统返回键，第一次收回键盘，第二次直接退回搜索前的界面。</p></li><li><p>若不需显示搜索历史，在原页面上蒙层，场景：日历、联系人等。点击蒙层或返回按钮，退出搜索状态。</p></li></ul><h5 id="输入搜索关键词"><a href="#输入搜索关键词" class="headerlink" title="输入搜索关键词"></a>输入搜索关键词</h5><ul><li><p>应用根据关键词，实时匹配本地内容，过滤出带关键词的内容，以列表形式呈现。</p></li><li><p>搜索框固定在顶端显示，不随搜索结果上下滚动。</p></li><li><p>输入文本后，框内右侧显示清除按钮，可点击清除框内搜索词。</p></li><li><p>显示结果时，关键词要高亮。</p></li><li><p>若需显示结果数量，使用子标题提示：找到+数量+单位+具体内容，例如“找到 5 个联系人”。</p></li><li><p>部分应用在内容区显示与搜索文本相关的搜索选项，包括在网上搜索、与搜索文本相似的关键词等。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWE1MTBmZTAyM2RjZjJlYWU5ZGQwOTQ2MWMwMjE0YzFfZ0hKOVhyNDQ2YWhqS3o4QUZ5bDVOTVpxWDlOM1JYRjZfVG9rZW46Ym94Y25paVNkVmY1NE5JRU9STmRtQ1BnVTZlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="非即时搜索"><a href="#非即时搜索" class="headerlink" title="非即时搜索"></a>非即时搜索</h4><h5 id="搜索入口，同即时搜索"><a href="#搜索入口，同即时搜索" class="headerlink" title="搜索入口，同即时搜索"></a>搜索入口，同即时搜索</h5><ul><li><p>顶部搜索框入口：当搜索在该页面为常用的行为时使用。</p></li><li><p>标题栏右侧搜索图标入口：当搜索在该页面为不常用的行为时使用。</p></li></ul><h5 id="激活搜索"><a href="#激活搜索" class="headerlink" title="激活搜索"></a>激活搜索</h5><ul><li><p>点击搜索入口后，进入搜索页面，搜索输入框置顶显示，弹出输入法键盘，左侧显示返回，输入框内显示焦点。此时按系统返回键，第一次收回键盘，第二次直接退回搜索前的界面。</p></li><li><p>内容区向上滑动时，搜索框不隐藏。</p></li><li><p>搜索页面默认显示内容，根据业务需要，显示搜索历史和推荐搜索内容。</p></li></ul><h5 id="输入搜索关键词-1"><a href="#输入搜索关键词-1" class="headerlink" title="输入搜索关键词"></a>输入搜索关键词</h5><ul><li><p>输入搜索内容，不会自动进行完整搜索，用户需手动点击搜索框右侧放大镜图标进行搜索。</p></li><li><p>实时联想的内容可包含本地内容，直达结果的具体内容，以及相关度大的搜索词。</p></li><li><p>输入的关键词能精确命中具体内容的，可提供搜索结果直达，不同类型搜索结果通过图标进行区分。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGY4MjdhMGY2NGIyNjM0NmQyNWYxNjAzOTQ1OTA0NThfcnNLUk82RWZhMktRQmI4cjY3TTY4Sm9xaXd2TVBsRkFfVG9rZW46Ym94Y25MWVp4V1Vzb1BTYjZDb2xJc25lYXpvXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2I1ZTA3NmM3MzBiOGQ1ZmVlMjE0NTMzNmYyNmM3ZGJfeGFXSkJmQVFzUGVhem9EYmt6a0pUM0Z5bG9rZ3ljZnlfVG9rZW46Ym94Y24zSjdBcTBob1JURTFjTTVCc1Zlc1hmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="搜索有结果"><a href="#搜索有结果" class="headerlink" title="搜索有结果"></a>搜索有结果</h4><ul><li><p>搜索结果一般包含：结果反馈、与精确结果相似的结果（例如相关专题）、根据结果进行的其他搜索推荐。</p></li><li><p>对于本地内容，小标题文字格式为“找到+数量+单位+内容”，例如“找到 5 个本地联系人”，搜索结果也可使用子标题按类别显示。</p></li><li><p>对于云服务应用，若搜索结果很多，可通过合理分类，帮助用户更好浏览结果。页面结构：筛选组件和具体的内容呈现。详见“<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/search-0000001110493100#ZH-CN_TOPIC_0000001110493100__section395mcpsimp" target="_blank" rel="noopener">搜索结果筛选</a>”小节。</p></li></ul><p><strong>二级搜索结果页</strong></p><ul><li><p>若业务搜索结果的类型较多，会分类显示搜索结果，每个分类仅显示部分结果，可通过“查看更多” 去显示完整结果。</p></li><li><p>点击“查看更多”后显示的结果页，即为“二级搜索结果页”，该页面支持快捷退出搜索状态，回到主页面。</p></li><li><p>在搜索框的右侧显示“退出”按钮，即可直接返回到主页面。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTE0YWZmYzBmZDdhMTgyZGRlMDVkNGYzYmFjMTU2MGRfWDc4RDlYdVNwM2MzSFRjaXhtMzVCTGVBSVhXNXV4dWVfVG9rZW46Ym94Y25GckRKd3BvMjZ6aW9FNEtGbktUbmFkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="搜索无结果"><a href="#搜索无结果" class="headerlink" title="搜索无结果"></a>搜索无结果</h4><p>提供相应建议。按照空内容界面方式显示图标+“没有匹配的结果”。考虑提供其他搜索推荐。搜索推荐视业务需求而定，逻辑同“激活搜索”时的搜索推荐。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTMzNDBlOTRkYjM4Yzk5ZTc2MzFlNTM2MTk3ZmJmZWNfbXZ5elJJQkRJakxFenJmTUdOSHc1ZUc0ZUNyMFZUUDdfVG9rZW46Ym94Y253Z0lYU2FOZ1RvWmlSanR2SlZjNWpFXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDY1N2VmMDAxNDcxY2M4NzlhZDBlMmVkYjI3NGY0OTFfdDhsTUMxUW1BOTBTbXphZDM0STZ6ZHVERTJFWURzTlFfVG9rZW46Ym94Y25seXU2dkVMc1plUlRFakdTQTI3ZWJiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzBlMDU4YjYwYmMzMWJkYWQ2ZGQ0ZmMwODYzZjNjOTZfSU9uUmtkMXVHUU50d2ZYWFNDRDhBUE1vbFlMNkxpZjZfVG9rZW46Ym94Y25nalJCbTZqaWFGanhOc2dESzduSm9iXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTYyZTRmNWJmYWMxNTMzNDAwY2U3MGVjN2ZkNDc4ZGRfZ3pBNHEyOVRlaERyODdrU2pJYkxEVXBTcEFxck5kcDRfVG9rZW46Ym94Y255WVBBclFlTVNoR2Jua2l0YlBMUEtjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>系统下载操作使用内联设计，即点击下载后界面不跳转，在下载按钮处直接显示下载进度。</p><h4 id="类型-33"><a href="#类型-33" class="headerlink" title="类型"></a>类型</h4><ul><li><p>文本下载按钮，可显示具体下载进度。</p></li><li><p>图标下载按钮。</p></li></ul><p>优先使用按文本下载钮样式来指示下载进度，结合场景进行选择。</p><h4 id="文本下载按钮"><a href="#文本下载按钮" class="headerlink" title="文本下载按钮"></a>文本下载按钮</h4><ul><li><p>下载过程中的状态。</p></li><li><p>“下载前”界面用语：下载/更新。</p></li><li><p>“下载中”界面用语：等待中，或显示进度条（百分比+暂停）；下载中状态，需有取消功能。</p></li><li><p>“暂停中”界面用语：继续。</p></li><li><p>“下载后”界面用语：打开/安装中。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjA0MzBlNmNiMTVhMTQ5MmM0OGY2M2YyZTZkZTEzNGRfczJNMktraWRQZFN5MzNidEVSUjhEa0ZYbmtiMG83YlhfVG9rZW46Ym94Y25nNFVvcXQ2V3VuWWdQQ0ZZUU5VbU1kXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTgwMTBkOTNiMDA1NTk4NjQ4OWVjMTFkMjBiOGJmZDFfc01ZSzNXM1VFZzFSczFQVXFzbDhUYjdtcGdrdzBHQnFfVG9rZW46Ym94Y253UUZySFZzNFhKTzFLaHdEZ3RRcndjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="下载管理"><a href="#下载管理" class="headerlink" title="下载管理"></a>下载管理</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p>可在后台下载的应用，需有下载管理功能，方便用户查看下载进度，进行删除等管理。通常是下载列表。</p><h5 id="如何使用-36"><a href="#如何使用-36" class="headerlink" title="如何使用"></a>如何使用</h5><ul><li><p>通常以列表形式呈现。</p></li><li><p>标题：业务各异，叫法不同。默认情况下“下载管理”。若有业务强相关的场景，例如视频类，一般为“离线缓存”或“离线下载”。不作强制要求。</p></li><li><p>根据下载任务状态，按“已下载”和“正在下载”两组进行管理。正在下载的内容，位于下载任务列表最上方，下载完成，该组消失。</p></li><li><p>下载任务列表界面，支持对单条任务和批量任务进行删除、暂停、继续下载等操作。</p></li><li><p>下载管理界面长按进入多选界面，可选择多条内容进行删除、暂停、继续等操作。</p></li><li><p>已下载的文件，若需按属性分类显示，可通过子页签进行区分。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjUyNzlhYWEwYzZjMTEzZmRmZTg0M2YzMWU4ZDMyODRfTDEwRk9jcjZud3lUTEdGYjBvRFEweEFNbE11VzNrejlfVG9rZW46Ym94Y25NWEN1VlZQa2h6eUpWTVRnZnFPTEhMXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>用户需要在系统中新增一个内容的操作。</p><h4 id="类型-34"><a href="#类型-34" class="headerlink" title="类型"></a>类型</h4><p>根据场景的不同，“新建/添加”的使用形式不同：</p><ul><li><p>界面无内容</p></li><li><p>界面有内容</p></li><li><p>弹框</p></li></ul><h4 id="界面无内容"><a href="#界面无内容" class="headerlink" title="界面无内容"></a>界面无内容</h4><p>当界面内容为空时，“新建/添加”采用底部大按钮的形式。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDVhNzAzNjQwNzVkYTYzYTAwMjI0MjY2MmVjNjcxNWZfT3huOEtwdDQ0SDNCZVFteGVreW9YbXA5S0ZIZjFqVFJfVG9rZW46Ym94Y25kNnVoZGs1cndDQzlSOUJqd0d0QnJoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="界面有内容"><a href="#界面有内容" class="headerlink" title="界面有内容"></a>界面有内容</h4><h5 id="单一内容（例如纯网格-列表等）"><a href="#单一内容（例如纯网格-列表等）" class="headerlink" title="单一内容（例如纯网格/列表等）"></a>单一内容（例如纯网格/列表等）</h5><ul><li>长期使用后内容不超过一页的：“新建/添加”跟随内容放在最后一项之后。</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGMxM2RiNTQ3YjNjM2JmMjgwNTQ4ZmI5NGNkMjA2YTlfQWlkZ3VCeEhLTk13dVJoeUxTQzhmOHdtdVZjYTUycjlfVG9rZW46Ym94Y252YzdEQ0RJTE40UnpaaFIzQ01hN0JoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><ul><li>长期使用后内容超过一页的，“新建/添加”优先放在底部工具栏上，其次考虑放在右上角标题栏上。</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2FiOWNkYjVlZTFlMjlhOTc1MzkyZGRlYzUyODdmZmRfaHRQQ1JEMUVRd1k3RVV6M0tsT0Y3V21nTlZoTXhNbVNfVG9rZW46Ym94Y25rYmxuRHRuSnNPQUNNZmZKcTFDckNkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="组合内容（内容有多种形式的网格-列表等）"><a href="#组合内容（内容有多种形式的网格-列表等）" class="headerlink" title="组合内容（内容有多种形式的网格/列表等）"></a>组合内容（内容有多种形式的网格/列表等）</h4><ul><li>长期使用后内容不超过一页的：“新建/添加”跟随内容放在最后一项之后。</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODZlNWRjZDEyM2YzNzNjZWFiZDFjM2IwNzVmZjg2N2VfeFUxdkVGNDNZZWQyRzZobXcxWWZjNkVKR2MzYmlTUEZfVG9rZW46Ym94Y25oOWtDYVBLSXplQnJqMjh0WHl4VTJkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><ul><li>长期使用后内容超过一页的，“新建/添加”放在子标题右上角。</li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzY1Y2VmNzRhZmEwNzM0ZTRkZTYzOTk0N2Q5MjRmMDFfYU1TbHRIRWhmZGVRc0p0d1FuYzhKSDdkRzdvRkhMSTJfVG9rZW46Ym94Y25heTh3YnFKYUZDVFNxV0w2SGNWR3NEXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="弹框"><a href="#弹框" class="headerlink" title="弹框"></a>弹框</h4><p>“新建/添加”放在列表弹框的最后一行，弹框显示时，要保证“新建/添加”不被内容遮挡。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmUzZjE2NzMyZmYwY2QyMGI5NmRkZTQ1MjcwNTU4NDJfUDhlZkQwa3JSNEZibGRaak0yb1dieGlYaU5EOVRMSElfVG9rZW46Ym94Y25selRhemlUNnRvM01VaUdWUzBZVXNkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="异常提示"><a href="#异常提示" class="headerlink" title="异常提示"></a>异常提示</h3><p>对系统或应用使用过程中出现的错误或风险进行提示。</p><h4 id="类型-35"><a href="#类型-35" class="headerlink" title="类型"></a>类型</h4><ul><li><p>网络异常提示</p></li><li><p>应用错误/异常/状态风险提示</p></li><li><p>公告消息</p></li></ul><h4 id="网络异常提示"><a href="#网络异常提示" class="headerlink" title="网络异常提示"></a>网络异常提示</h4><p>当由于网络异常导致界面内容不能显示或刷新时，需要在界面上给予提示和帮助。同时需要保持对网络内容的侦测，当网络恢复正常时，则及时自动刷新内容。</p><h4 id="类型-36"><a href="#类型-36" class="headerlink" title="类型"></a>类型</h4><ul><li><p>内容区中间位置提示</p></li><li><p>内容区上方插入横幅提示</p></li><li><p>内容区嵌入提示</p></li></ul><h4 id="内容区中间位置提示"><a href="#内容区中间位置提示" class="headerlink" title="内容区中间位置提示"></a>内容区中间位置提示</h4><p>适用于无可显示内容的情况。</p><ul><li><p>无网络：显示“网络未连接”，底部显示设置网络按钮，点击按钮后跳转到设置网络弹出框。</p></li><li><p>网络差：显示“网络连接不稳定，请点击屏幕重试”，底部显示设置网络按钮，点击按钮后跳转到设置网络弹出框。</p></li><li><p>连不上服务器：显示“无法连接服务器，请点击屏幕重试”。</p></li><li><p>有网但获取不到内容：显示“无法获取XX，请点击屏幕重试”，XX是用户需获取的内容，可为“信息”、“图片”、“资料”等。</p></li></ul><p>上述描述不能涵盖到的情况，应用需给出一般用户能理解的错误提示，指导用户解决问题。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWYxZGEwMzE2MjBkMjI2MTJmMjIwZjA0OTU3Yjk2ZmJfVHVZV0tCSkZYTHdmWjJyZGJaNnRQRWk5SzFWMFZTV3dfVG9rZW46Ym94Y25abjRwUEJuazFDc0REdDl1MkhaWHM5XzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="内容区上方插入横幅提示"><a href="#内容区上方插入横幅提示" class="headerlink" title="内容区上方插入横幅提示"></a>内容区上方插入横幅提示</h4><p>适用于有离线内容可显示的情况。</p><ul><li><p>无网络：显示“网络未连接 设置网络”，点击左侧文本，变为正在连接的状态。点击“设置网络”，跳转到设置网络弹出框。若网络硬件未打开，则不需要连接中的状态。</p></li><li><p>网络差：显示“网络连接不稳定，请点击重试 设置网络” ，点击左侧文本，变为正在连接的状态。点击“设置网络”，跳转到设置网络弹出框。</p></li><li><p>连不上服务器：显示“无法连接服务器，请点击重试”。</p></li><li><p>有网但是获取不到内容：显示“无法获取XX，请点击重试” 。XX是用户需获取的内容，可为“信息”、“图片”、“资料”等。</p></li></ul><p>上述描述不能涵盖到的情况，应用需给出小白用户能够理解的错误提示，指导用户解决问题。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDNkZTFhMjNkNGZiZjBiZTUyMGEwZGM1MTU3NWE3MzNfOHhoUTJLVnV5NGlubWJXbVVFTHRBT0dVcEFrN3dFSkxfVG9rZW46Ym94Y24yUktweGUyZWtEYmlFUTk5MUdRcU5iXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="内容区嵌入提示"><a href="#内容区嵌入提示" class="headerlink" title="内容区嵌入提示"></a>内容区嵌入提示</h4><p>沉浸式效果的界面，可以使用内容区嵌入提示，需要根据界面内容布局进行设计。适合天气、负一屏等沉浸式效果，不适合用横幅提示的场景。</p><ul><li><p>无网络：显示“网络未连接，点击设置网络”，点击跳转到设置网络弹出框。</p></li><li><p>网络差：显示“网络连接不稳定，请点击重试”。</p></li><li><p>连不上服务器：显示“无法连接服务器，请点击重试”。</p></li><li><p>有网但是获取不到内容：显示“无法获取XX，请点击重试” ，XX是用户需获取的内容，可为“信息”，“图片”，“资料”等。</p></li></ul><p>上述描述不能涵盖到的情况，应用需给出小白用户能够理解的错误提示，指导用户解决问题。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTRhYjk3ZDQyYTM3ZDBmNjEwNmE3ZmM2N2Q2YTk3YzZfN0NRcGtyZ0RIcldMVlFjOFZLRXVDbG1OZ1BjdG5mMHNfVG9rZW46Ym94Y25FeVE0S3phT1p3QXd6UHFGRWRGdGFmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="设置网络"><a href="#设置网络" class="headerlink" title="设置网络"></a>设置网络</h5><p>网络提示提供了“设置网络”的按钮入口，点击该按钮，需调用有设置应用提供的设置网络公共弹框，直接在当前界面开启。</p><h4 id="应用错误-异常-状态风险提示"><a href="#应用错误-异常-状态风险提示" class="headerlink" title="应用错误/异常/状态风险提示"></a>应用错误/异常/状态风险提示</h4><h5 id="类型-37"><a href="#类型-37" class="headerlink" title="类型"></a>类型</h5><ul><li><p>前台应用提示</p></li><li><p>后台应用提示</p></li></ul><h4 id="前台应用提示"><a href="#前台应用提示" class="headerlink" title="前台应用提示"></a>前台应用提示</h4><ul><li><p>优先：根据具体操作项或内容相结合的方式进行提醒。例如发短信失败。内容区嵌入式风险提示需采用红色文字提醒，不需要用户确认。</p></li><li><p>其次：选用不打断用户当前操作的提示方式，使用横幅通知（针对第三方应用，例如打开支付宝时，提示加入到安全空间）和 即时提示（例如邮件附件太大，点击发送后的提示）。</p></li><li><p>再次：需要用户操作才能继续使用的，使用弹框。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Njk2Yzg1MTg1YzI1ZDlhNTcyMWFmYjJlZmE2ZmVlMzNfT2xHYjJxaG4wT29DYzd0SzdCRlc2ZXZiWjlBbmppbTRfVG9rZW46Ym94Y25yVlJFbXI2dHVOZXJaUTdwdWQzWDBnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="后台操作提示"><a href="#后台操作提示" class="headerlink" title="后台操作提示"></a>后台操作提示</h4><ul><li><p>后台进行的任务，若出现错误、异常或风险，使用横幅通知，然后自动消失到通知栏显示。</p></li><li><p>异常情况，需提供解决问题的入口。</p></li><li><p>所有正在进行的过程类操作的信息，放在通知面板上。</p></li></ul><h4 id="公告消息"><a href="#公告消息" class="headerlink" title="公告消息"></a>公告消息</h4><p>即时的公告消息，希望用户立即关注。通常是一些极其重要的信息，平时不显示。</p><h5 id="如何使用-37"><a href="#如何使用-37" class="headerlink" title="如何使用"></a>如何使用</h5><ul><li><p>涉及金额变动、服务不可用或有重要通知显示。</p></li><li><p>不自动消失，不可点击。</p></li><li><p>服务恢复可用或宣传窗口期失效，提示才可消失。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDYxMmExZWI4NmVkZTExMjJkNjc3ZTA3ZmUyN2Q1NmJfUHJNcDlLbkJxZkpmRVV5eVVxdlRjMHo0NnlpMHRxbzFfVG9rZW46Ym94Y25zR0tEc1pZTldEZUlWNjluQWJiVkFoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h2 id="系统特性"><a href="#系统特性" class="headerlink" title="系统特性"></a>系统特性</h2><h3 id="打开方式"><a href="#打开方式" class="headerlink" title="打开方式"></a>打开方式</h3><p>用于选择文件用什么应用打开。默认情况下，常用的文件都有默认的应用可以打开。对无默认打开方式的文件，使用打开方式来打开。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGE2NTNkZTBmNzM3NTU0OTFiMGFhZjcxNjEwMDg1MzJfenB6d2RCQ3dUbzJYdDh0UDZxZkN2UEt4NTNXVlhwNVpfVG9rZW46Ym94Y25ROW1CejdvY0dXRlNhOUU0TVg4RUViXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="如何使用-38"><a href="#如何使用-38" class="headerlink" title="如何使用"></a>如何使用</h4><p>对于应用内的文件，如有适合的系统默认应用，直接用系统默认应用打开文件。如果没有合适的系统默认应用，使用打开方式选择可使用的应用去打开。</p><h4 id="交互规则-32"><a href="#交互规则-32" class="headerlink" title="交互规则"></a>交互规则</h4><h4 id="初始排序"><a href="#初始排序" class="headerlink" title="初始排序"></a>初始排序</h4><ul><li><p>最前面：系统默认应用。</p></li><li><p>其次：常用打开方式。</p></li><li><p>最后：默认按字母顺序排序，根据使用频率自动调整顺序。</p></li></ul><h4 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h4><p>系统默认应用排在最前面。其他排序方式根据使用频率自动调整顺序。</p><h4 id="打开方式选择"><a href="#打开方式选择" class="headerlink" title="打开方式选择"></a>打开方式选择</h4><p>用户选择打开方式后，点击“仅此一次”进行打开，下次再打开该类文件时，还会询问用何种方式打开。若点击“始终”进行打开，系统将始终用此方式打开该类文件</p><h3 id="多窗口交互"><a href="#多窗口交互" class="headerlink" title="多窗口交互"></a>多窗口交互</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>折叠屏展开态、平板、电脑等大屏幕设备，具有多任务并行和效率型任务处理的先天优势。</p><p>系统提供了悬浮窗、分屏、平行视界三种多窗口交互，为用户在大屏幕设备上的多任务并行、便捷的临时任务处理提供更佳的使用体验。</p><h4 id="三种类型"><a href="#三种类型" class="headerlink" title="三种类型"></a>三种类型</h4><p>无法复制加载中的内容</p><h4 id="多任务并行"><a href="#多任务并行" class="headerlink" title="多任务并行"></a>多任务并行</h4><p>通过多窗口交互可实现多任务并行，包括多应用多任务并行和单应用多任务并行。</p><p><strong>多应用多任务：</strong>用户在使用电子设备时，经常需要同时使用多个应用。可通过分屏、应用悬浮窗实现多应用并行。</p><p><strong>单应用多任务：</strong>相对复杂的平台型应用，存在应用内多个相互独立的持续性进程需要同时进行的情况。</p><p>按照既有操作，强制中断前一个任务，跳转到第二个任务；或维持在第一个任务中，忽视第二个任务的通知。这两种方式都体验不佳，因此，需要一种应用内多任务并行以及各任务间灵活切换的机制来帮助用户实现单应用多任务。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTcyNDZlZTYwMjQ0N2QwZDE1MmZiZWViZGVlZWU4MDVfcjZ5V3FTSjdiSHJhTU5ycERTdEgzYmx5djM1MkZ0Rm5fVG9rZW46Ym94Y25YOW1KYWlTbVpsQTNGcXlxbUdYV3NkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>单应用多任务的交互特点：</p><ol><li>页面两侧类似于系统级的跨应用多窗口，两侧内容没有直接关联，用户只是需要两个部分可以同时运行。</li><li>在当前页面即可触发单应用多任务，避免必须要退到应用的主界面，才能切换到另一个任务的多步操作，也避免了切换过程中的任务中断。</li></ol><p>为了保证单应用多任务给用户带来好的体验，应用需在设计中满足以下基本要求：</p><ol><li>应用内多任务必须是基于用户在具体场景下的需要来构建。</li><li>需要向用户提供易理解、易操作的形式。</li><li>一般由用户来主动触发进入多任务状态，同时用户也应有能力控制主动退出或不进入此状态。仅在用户有明确预期或诉求的情况下可以由应用自动触发进入多任务。</li></ol><p>常见的实现单应用多任务的方式：</p><p>\1. 悬浮窗</p><p>\2. 单应用分屏</p><p>\3. 平行视界后台锁定</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmZjNDAyNDhmZmUxZmU0ZjlkYjhmZTFiMTQxNDI5ZTJfb2FidGlmVEZLcHZmOHR4aG12VHNYV1ZpMDZLUWhndmJfVG9rZW46Ym94Y241NXVQZU1GdEtLcFdaeFZYdkFSbW5iXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="临时任务处理"><a href="#临时任务处理" class="headerlink" title="临时任务处理"></a>临时任务处理</h4><p>通过多窗口交互，可实现便捷的临时任务处理，包括一步窗口&amp;跨窗口拖拽。</p><p>三方应用根据业务需求，列举需要调用一步窗口的场景，对系统提出调用一步窗口的请求，系统提供一步窗口的能力。</p><p>在特定场景下，点击控件/按钮/链接/附件等，直接打开一个任务悬浮窗，即为一步窗口。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTBjMjY4MWZhNDg2ZTYxMTA3NDJmZDJhZGVlNzJkZDhfVWlQTXJiTkdwblNqeFUyaU9yam9KbWpZV3dJTm9EaUJfVG9rZW46Ym94Y25ObmRUQ0ZNRXZ6UTZia3VpYTcyQ1hkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="分享-1"><a href="#分享-1" class="headerlink" title="分享"></a>分享</h3><p>系统级特性，用于分享文本、图片、视频等内容。使用华为分享，可以免流量极速分享到附近设备。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWEyODBkMzYwNjYwNWQ1YjYwYzMzYzMxMTVkZWYxYmZfZU5ERkJhWmxjT0V0dFpmWWlxSlFqc3NaTzAxeHZwQVdfVG9rZW46Ym94Y25HNjVHZEw4TERHM1ZrYnNTSmE5WVlnXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="如何使用-39"><a href="#如何使用-39" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>点击“华为分享”区域显示的头像，可以将内容分享给该头像对应的设备。</p></li><li><p>点击具体分享方式进行分享。</p></li></ul><h4 id="界面构成"><a href="#界面构成" class="headerlink" title="界面构成"></a>界面构成</h4><ol><li>分享对象预览区</li><li>华为分享</li><li>所有分享方式区</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTA1NjU4MWY0OWJlZDE2YTQ5OTdkYzQ0M2I1YTQzZGJfeXNRRDljNXRUQklHTTA1M2kxcVk4dVJMOWdVM0ZGRG9fVG9rZW46Ym94Y256aExIVGRUY0RhRnBaQ0J0MWZuZkFkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWQ5MDJkODk2YjgyMzhjYWJhYjYxNGYyMzNlMDM0NjRfa3BNTmZCa09SQU5POG1VeG45aDVUSWNMaXQ1OG5pWW1fVG9rZW46Ym94Y25OYzZpMFpaUFVPMzhFd28wcDlNSndlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="动效规则-4"><a href="#动效规则-4" class="headerlink" title="动效规则"></a>动效规则</h4><ul><li><p>普通分享动效，调起可滑动面板。</p></li><li><p>图库分享动效，图片以共享元素的方式转场。</p></li></ul><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>通知旨在让用户以合适的方式及时获得有用的新消息，帮助用户高效地处理任务。</p><h4 id="通知使用原则"><a href="#通知使用原则" class="headerlink" title="通知使用原则"></a>通知使用原则</h4><ul><li><p>为用户提供有价值的通知内容信息。</p></li><li><p>不要发送相同内容的通知打扰用户。</p></li><li><p>必要时，为用户提供有效、直观的通知操作按钮。</p></li><li><p>优先采用规范布局，避免自定义复杂的布局，以保证通知体验的一致性。</p></li><li><p>不要将通知作为小工具或广告板使用。</p></li><li><p>不要出于商业目的强制改变通知属性（如采用进行中通知强制置顶显示），避免损害用户使用体验。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MWJkNTJkMjRjY2E5MDk1N2E3NTRjYWZkNjJiMDg5YWZfNHh6VmZJRGZiM2dPdTdKTm1hR1RETmJudjZ1cVpyZE1fVG9rZW46Ym94Y240dXJRampaVFVESGtHTVM2UDZabVhkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="通知详情"><a href="#通知详情" class="headerlink" title="通知详情"></a>通知详情</h4><h5 id="单条通知"><a href="#单条通知" class="headerlink" title="单条通知"></a>单条通知</h5><p>单条通知的基本元素包括标题区、内容区、操作区：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2VmZmEzMjMxYjlhOWRlNjIyMDM4ZWEzY2I2YzZiOGZfdjZzamhCTWt2TVNZdmZLTGgwMDY0aGJ2dUY0VTlmZm5fVG9rZW46Ym94Y25aa25lSnRPYW5tVUUzV3lLdVNqSUFjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>标题区</strong></p><p>\1. 通知图标：表示通知的功能与类型，需应用单独提供。</p><p>\2. 通知名称：应用名称或功能名称。</p><p>\3. 时间：发送通知的时间，系统默认显示。</p><p>\4. 展开箭头：点击标题区，展开被折叠的内容和按钮。若无折叠的内容和按钮，不显示此箭头。</p><p><strong>内容区</strong></p><p>\5. 内容标题：描述简明概要。</p><p>\6. 内容详情：描述具体内容或详情。</p><p><strong>操作区</strong></p><p>\7. 操作按钮：支持功能操作或界面跳转。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2IyYTJjYjUwY2RhNGJhYzcyNTdiZjc4YWE0OTliNzlfd3NJdk5wUW11V2dNZ1FtNXdEakQ2NnREMkNObElPb1ZfVG9rZW46Ym94Y25yaDhDSW4yNWhmU0NSYUQ4YVFpZVllXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>交互规则</strong></p><p>\1. 支持展开的通知，点击标题区展开，点击内容区跳转至应用详情界面。</p><p>\2. 不支持展开的通知，点击整条通知跳转至应用详情界面。</p><p>\3. 没有应用界面的通知，点击不跳转。</p><h5 id="组合通知"><a href="#组合通知" class="headerlink" title="组合通知"></a>组合通知</h5><p>应用如果发送多条通知，需设为一条组合通知。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmJmYzVlOGE0MzAwMzhlZjgxM2IyOGNjNWI1ZmJkNGRfcHN5NkVTbG5JVzNPTFhHQjdoeE03bzdYSEx3Qzl1aUJfVG9rZW46Ym94Y240V1FCaEIwVGFTeE1WaW9tR1Nxc0hjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>展开前</strong></p><p>\1. 通知图标：最新 1 条通知的图标。</p><p>\2. 通知名称：最新 1 条通知的应用名称或特性名称。</p><p>\3. 时间：最新 1 条通知的时间。</p><p>\4. 展开箭头：点击展开所有通知。</p><p>\5. 内容区第一行：第 1 条通知的内容标题和详情。</p><p>\6. 内容区第二行：第 2 条通知的内容标题和详情。</p><p>\7. 数字：表示未显示通知的数量。</p><p><strong>展开后</strong></p><p>\8. 子通知标题：若子通知的图标和名称与最新一条通知的一致，子通知标题仅显示时间；若不一致，则子通知标题显示图标+名称+时间。</p><p>\9. 子标题展开箭头：同单条通知的展开箭头。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjdkMzYwMGJjYTEyYWM4YTgxYzY3NjhjMTZiM2U5MmVfUmt1WWVWWmFZczBaS2VyYWV3Y0RtYXMyMXBQNW80cTRfVG9rZW46Ym94Y25PcTFRQ2djblZQQzIxajIzSzJub0tjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p><strong>交互规则</strong></p><p>\1. 折叠时，点击整条通知展开。</p><p>\2. 展开时，点击标题区收起。</p><p>\3. 子通知交互规则同单条通知。</p><h4 id="通知提示场景"><a href="#通知提示场景" class="headerlink" title="通知提示场景"></a>通知提示场景</h4><p><strong>通知会在不同场景以不同形式提示用户。应用发出一条通知时，可配置通知的提示场景。</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2UyMjIxNmM0OGVmYTE1MjhhNTEzOTIwNTcyYmRjNjhfS2FlMjBTSm5YY0xvM1lZVWZ5RTZoQm5ObkxPZk5USldfVG9rZW46Ym94Y25CcDFhWWY3UkhhUElHQk9kTGJLY0FiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="通知栏"><a href="#通知栏" class="headerlink" title="通知栏"></a>通知栏</h5><ul><li><p>通知默认在通知栏显示，应用无需配置。</p></li><li><p>进行中通知显示在通知栏顶部（按时间排序）。</p></li><li><p>通知按时间由上至下排序。最上方显示最新的通知。</p></li><li><p>通知数量超过一屏后，未显示通知的图标将在底部收纳成一排。</p></li><li><p>通知栏默认展开第一条单条通知；其他通知为折叠状态。</p></li></ul><p><strong>交互规则</strong></p><ul><li><p>向右滑动通知卡片，删除通知。</p></li><li><p>向左滑动通知卡片，显示设置、删除按钮，再次向左滑动删除通知。</p></li><li><p>点击左滑出来的删除按钮，删除单条通知。</p></li><li><p>点击左滑出来的设置按钮，出现设置项弹框。</p></li><li><p>点击设置项弹框上的“关闭通知” ，屏蔽该应用所有通知。</p></li><li><p>点击设置项弹框上的“设为静默通知” ，将该应用所有通知设为静默，仅在通知栏显示。</p></li><li><p>点击设置项弹框上的“延后提醒” ，设置当前通知延后提醒。</p></li><li><p>点击设置项弹框上的“更多设置” ，进入对应应用的通知设置详情界面。</p></li><li><p>点击通知栏底部的悬浮删除按钮，删除所有通知。</p></li><li><p>点击通知栏右下方的“通知管理” ，进入 “设置”中的“通知”页面。</p></li></ul><h5 id="横幅通知"><a href="#横幅通知" class="headerlink" title="横幅通知"></a>横幅通知</h5><ul><li><p>横幅通知为高提示性场景，仅白名单内应用可生效。</p></li><li><p>横幅通知在界面顶部显示 5s 后消失。例外：来电、闹钟横幅通知为长时间停留。</p></li><li><p>同时接收多条横幅通知时，仅显示最新一条通知。</p></li><li><p>非全屏界面显示 3 行通知高度和操作按钮。箭头仅折叠内容详情，超过 1 行将被折叠。</p></li><li><p>全屏界面下，通知显示单行高度。</p></li></ul><p><strong>交互规则</strong></p><ul><li><p>在横幅通知上向左或向右滑动删除通知。</p></li><li><p>上滑忽略横幅通知，在通知栏里仍显示。</p></li><li><p>点击通知内容区进入应用详情界面。</p></li></ul><h5 id="锁屏通知"><a href="#锁屏通知" class="headerlink" title="锁屏通知"></a>锁屏通知</h5><ul><li><p>锁屏上仅显示本次锁屏期间接收的普通通知，进行中通知可在锁屏上常驻。</p></li><li><p>最多显示3条锁屏通知。</p></li><li><p>锁屏通知分为 primary 与 public 属性，public 属性下，打开“隐藏通知内容”开关，通知内容不会被隐藏。</p></li><li><p>应用可配置通知是否显示在锁屏上。</p></li></ul><p><strong>交互规则</strong></p><ul><li><p>双击单条通知内容区，跳转至应用详情界面。</p></li><li><p>有折叠箭头的单条通知，双击标题区，展开被折叠内容与操作按钮。</p></li><li><p>双击组通知，展开被折叠的单条通知。</p></li><li><p>向右滑动删除通知。</p></li><li><p>向左滑动显示设置、删除按钮，再次向左滑动删除通知。</p></li></ul><h5 id="桌面图标角标"><a href="#桌面图标角标" class="headerlink" title="桌面图标角标"></a>桌面图标角标</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWYwMjY5YjU1MWVhZGE3ZWNmMWRiMDI1MGE0NDBhNTdfREtiS1VNTzVRdGZESXdKM1dnd0Y0dVBpNTZ5ZE9lbzBfVG9rZW46Ym94Y25WbktGcFVrWVRQaUVpYUM1TzZiWlNiXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><ul><li><p>桌面图标角标分为圆点角标和数字角标两种。</p></li><li><p>圆点角标对应通知，表示该应用有通知，圆点角标的颜色是根据应用图标颜色进行的智能取色，无需应用定义。</p></li><li><p>数字角标是应用新消息的提示，不是完全对应通知的。</p></li><li><p>系统默认显示数字角标。</p></li></ul><h5 id="通知图标"><a href="#通知图标" class="headerlink" title="通知图标"></a>通知图标</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzRlZDJjNTgzNTVkNTlkYmJhNWM2NzRmMjZiNGZjNzNfdVh0SHVydjJ6RWRiT1YzeEo3QXdhakNkcWtjbVZodnVfVG9rZW46Ym94Y241VTVnTFk3YXZaR3BvT0FPNUh1N1pkXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><ul><li><p>通知以图标形式显示在状态栏、熄屏界面，与通知卡片图标为同一资源。</p></li><li><p>通知图标资源需应用单独提供。</p></li></ul><h4 id="通知特殊属性"><a href="#通知特殊属性" class="headerlink" title="通知特殊属性"></a>通知特殊属性</h4><h5 id="进行中通知"><a href="#进行中通知" class="headerlink" title="进行中通知"></a>进行中通知</h5><ul><li><p>任务进行中的通知，显示在通知栏、锁屏通知顶部。有多条进行中通知时，按时间排序。</p></li><li><p>进行中通知不能被删除，当用户结束此任务后消失。</p></li></ul><h5 id="静默通知"><a href="#静默通知" class="headerlink" title="静默通知"></a>静默通知</h5><ul><li><p>静默通知仅在通知栏显示，且无响铃和振动。</p></li><li><p>在通知栏中，静默通知和非静默通知在位置与样式上无区别。</p></li><li><p>系统、应用和用户任意一方可将通知设定为静默通知。</p></li><li><p>静默通知以应用为单位生效。</p></li></ul><h4 id="文本超长显示规则"><a href="#文本超长显示规则" class="headerlink" title="文本超长显示规则"></a>文本超长显示规则</h4><h5 id="通知名称"><a href="#通知名称" class="headerlink" title="通知名称"></a>通知名称</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTE0YzU5MjI0ZGIwMWFhYzEzODgyMjVmMjdjMTAzMmJfc2ptc1NiYjFuRzNTcDFFQkZCVFEzMWp4cklPcjA3d1ZfVG9rZW46Ym94Y25oTkg0TFZYS2ZHM1V3MHJtbEpxZHZoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>建议完整显示字串。</p><p>不支持换行，超过 1 行“…”截断。</p><h5 id="通知内容标题"><a href="#通知内容标题" class="headerlink" title="通知内容标题"></a>通知内容标题</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjg3ZTE0OTBhOTFiODU0Zjk2NjAzNzRiNDc0YjdhMjFfRlVweGdOdWNQRnBOd2s1UVhzakoxM2ExeXdLeFZSRndfVG9rZW46Ym94Y25zdG8zb1hYVUJEMlV6SGpDdURtd1pmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>建议完整显示字串。</p><p>不支持换行，超过 1 行“…”截断。</p><h5 id="通知内容详情"><a href="#通知内容详情" class="headerlink" title="通知内容详情"></a>通知内容详情</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmEwNjcyYzRiMmIyYWYyOTdhNmQ3OGMxYjczZTAwNTVfNFlZa1MzU015V1hEa1JtZGJ5ZGRHYTZQNHR6QmtMT3ZfVG9rZW46Ym94Y25PZ2IyT2pRdEhIRzVSTlhWRGIwek5mXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><ul><li><p>折叠状态下，超过 1 行“…”截断 。</p></li><li><p>展开状态下，最多可显示 8 行，仍显示不下“…”截断。</p></li><li><p>最大高度为 295vp。</p></li></ul><h5 id="通知按钮"><a href="#通知按钮" class="headerlink" title="通知按钮"></a>通知按钮</h5><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzk5ODBlN2ViZDRkOTRkYWY0ODg2ZDBiYjdiOWRmMmVfM3AydmxRZnlIV2l2QVllVnlTSXdnWUllaldjS2J6NVhfVG9rZW46Ym94Y25jOWYzV2FFSFV3WGhVMWtQMTlGZ1RmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><ul><li><p>先逐级缩小字号到 15fp。</p></li><li><p>仍然超长，换行处理，支持换一行。</p></li><li><p>最后，“…”截断。</p></li></ul><h4 id="通知栅格布局规则"><a href="#通知栅格布局规则" class="headerlink" title="通知栅格布局规则"></a>通知栅格布局规则</h4><p>4 个 columns 时，通知占 4 个 columns</p><p>8 个 columns 时，通知占 6 个 columns</p><p>12 个 columns 时，通知占 8 个 columns</p><p>手机竖屏：通知宽度为 4 个 columns</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODA1NGViZGFjMmFiYmZlNDE5Mzc0YThmYzZhNWE1ZWJfcDF2NjdOaWg0VFRiYWY4NjlFa2w3c0NiZWc2MGtXak9fVG9rZW46Ym94Y25CR1FzQ2JhdUxCbDlpTlRXR3U0NFkyXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>手机横屏：通知宽度为 6 个 columns</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWU3YTcyMjQ4YmQ0NWQyOWFjODZmNjE4NzQyNzQ2NjFfTzBhSUl4cURzNXRCWHpmSUkzNUk1MExvY2hscTZwdlNfVG9rZW46Ym94Y25Ka2hYdGNsRlVmWTkwMFVRZ3Eya29mXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>平板竖屏：通知宽度为 6 个 columns</p><p>平板横屏：通知宽度与竖屏保持一致</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWI1NWZlZWRhNzc4OTczMDZhMjk4MGRmMDk3ZDgyMjhfUlc2ZENFdmF2VU1xUjNBTDRUUFpSbnRuOXlOVXMzQjRfVG9rZW46Ym94Y25Dd0ZMWGR4OEo2UjdxZzRvZ3QyVExlXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><p>折叠屏横/竖屏：通知宽度为 6 个 columns</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGQzZThkZGRmMjZlZWU0NWVjZTliMDNlODU5MTg0MDBfeEtNUFMzWk9aMld6OWdpQW01azc2NmdZaFBodFFnVXNfVG9rZW46Ym94Y25MdXhQdjlRdFMyZGpkTFJ4bFJEZzVmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h3 id="选择文件与路径"><a href="#选择文件与路径" class="headerlink" title="选择文件与路径"></a>选择文件与路径</h3><p>为给用户提供一致的文件操作体验，避免各应用提供各式各样的文件调用操作界面，降低由此带来的用户学习成本，HarmonyOS 提供了系统级的文件操作解决方案，在不同的使用场景中，用户都能够使用熟悉的界面完成打开、查找、保存文件等任务。如无特殊需求，应用应优先考虑调用系统能力，而不是重新实现相同的功能。</p><h4 id="文件选择器"><a href="#文件选择器" class="headerlink" title="文件选择器"></a>文件选择器</h4><h5 id="界面效果"><a href="#界面效果" class="headerlink" title="界面效果"></a>界面效果</h5><p>应用需在其使用场景中打开/插入一个或多个文件时（例如添加邮件附件、发送文件给联系人），可以调用文件选择器来完成文件选取任务。文件选择器提供以下查找文件的方式：</p><ul><li><p>查看并选择最近文件</p></li><li><p>根据类型、位置与来源维度浏览文件</p></li><li><p>在已收藏的列表中选择</p></li><li><p>按条件和关键字搜索文件</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWI5ZTZmYzEwMDljMzE0ZGJmOWUyZWMxNjczYjc0ZDFfQkpkdXpJUXVRMUdQWEVKS2pNaHZDSDhPV21Ca3hheUxfVG9rZW46Ym94Y25yanZ5Y2hRMldqU01sdFpEVVJBQURoXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>文件选择器由应用根据场景调起，用户选择所需文件后，操作流程回到调用应用，并返回用户所选择的文件列表。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjJmNmU2ZWM5MDFkOGZiMzczZjRjZTFlZWQ3OGM5NjhfZm9Zb0NpaWlpeWxUMndTMVlaRGtSNFNvNmxoTk8yZGNfVG9rZW46Ym94Y25kbE1sZ2NsQTBKalNnU0pTekVkUmhjXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h5 id="文件来源"><a href="#文件来源" class="headerlink" title="文件来源"></a>文件来源</h5><p>系统文件选择器除可访问当前设备的本地文件外，还可访问以下位置的文件内容：</p><ul><li><p>华为云盘</p></li><li><p>其他可信分布式设备</p></li><li><p>通过网络邻居连接的设备</p></li></ul><h5 id="可定制能力"><a href="#可定制能力" class="headerlink" title="可定制能力"></a>可定制能力</h5><p>应用在调用文件选择器时可以指定以下参数：</p><ul><li><p>指定文件类型默认支持所有类型，如果传递类型参数，则路径下非指定类型文件将不可见。</p></li><li><p>指定文件数量最大个数默认最大个数为 500，如果传递的参数大于 500，则仍保持 500 为最大个数。</p></li></ul><h5 id="路径选择器"><a href="#路径选择器" class="headerlink" title="路径选择器"></a>路径选择器</h5><h4 id="界面效果-1"><a href="#界面效果-1" class="headerlink" title="界面效果"></a>界面效果</h4><p>应用需在其使用场景中保存一个或多个文件时（例如下载文件、上传至云盘），可以调用路径选择器来完成路径选取任务。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDBmMGY5NDVhMThkMzI1MGZmZDVhYTU2MGM3ODUzZWJfUjdzaklscWRQOWNxTnFwN1JhOU4zS3RRcG0wcFFPV3ZfVG9rZW46Ym94Y25pdXFGZmxJdnVDS2lKTW9SSUxGTVZmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p>应用需要保存文件时，调用路径选择器，用户选择保存位置并指定保存文件名称（可选）后，操作流程回到调用应用，并返回保存结果。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGUxMDhhOTM3Y2E1ODk2ZTU3ZTEzYmViZjZlYTkzNDZfYWhxdlU5OHU1TVFic0kxZkVtbm5Fa2lCdHI0WVBvbTNfVG9rZW46Ym94Y252c2Z5VGxyblA3TjFxQmt4MDRicjNmXzE2MjcxNDcxMjU6MTYyNzE1MDcyNV9WNA" alt="img"></p><h4 id="保存路径"><a href="#保存路径" class="headerlink" title="保存路径"></a>保存路径</h4><p>路径选择器可将文件存入以下位置：</p><ul><li><p>当前设备本地路径</p></li><li><p>SD卡</p></li><li><p>U盘</p></li><li><p>华为云盘</p></li></ul><h2 id="设计自检表"><a href="#设计自检表" class="headerlink" title="设计自检表"></a>设计自检表</h2><p>设计自检表详细列举出了在设计和开发过程中应当注意的设计规则，提交审核前请再次检查各项是否符合规则要求，这将帮助应用减少用户舆情且提升用户体验的一致性。</p><p>自检表的要求范围分为“必选”与“推荐”两类。必选类一般为已总结出的较优解决方案或效果，表示相关设计需要按照此原则统一执行；推荐类指可能受应用品牌风格或业务特殊性影响，可适量做出修改。</p><p>请参考以下表格范围内提出的要求对应用进行检查。</p><p>无法复制加载中的内容</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Harmony </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Harmony </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HarmonyOS设计：设计方案</title>
      <link href="/posts/adaa.html"/>
      <url>/posts/adaa.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式设计"><a href="#分布式设计" class="headerlink" title="分布式设计"></a>分布式设计</h1><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWIxNjRhZDljZTNhNTI4MWU2YWJkZWVlYTk3MDhlMDBfVjJTcTVJMlhpNVQ1YmM3WmNRaWhPTVBSeG5CcmhCd1NfVG9rZW46Ym94Y25QS0lYZ0FxNVpvSU9ZbXc0NUl0RVZmXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>HarmonyOS 是面向未来全场景智慧生活方式的分布式操作系统。对消费者而言，HarmonyOS 将生活场景中的各类终端进行能力整合，形成“One Super Device”，以实现不同终端设备之间的极速连接、多端协同、资源共享，匹配合适的设备、提供流畅的全场景体验。</p><p>分布式设计指南可以帮助应用开发者了解如何充分发挥“One Super Device”的能力，提供独特的跨设备交互体验。</p><h3 id="设计原则-1"><a href="#设计原则-1" class="headerlink" title="设计原则"></a>设计原则</h3><p>要构建优秀的分布式体验，需要遵循如下设计原则：</p><h4 id="体验增值"><a href="#体验增值" class="headerlink" title="体验增值"></a>体验增值</h4><p>简单叠加更多的设备并不能带来更好的体验，反而可能造成体验下降。要谨慎地设计分布式体验，跨设备交互要能提供明显的体验提升，例如更好的感官体验、更好的交互效率等。</p><h4 id="无缝流畅"><a href="#无缝流畅" class="headerlink" title="无缝流畅"></a>无缝流畅</h4><p>从一个设备流转到另一个设备的过程是流畅的，设备与设备的协同是无缝的，就像是在使用一个设备一样，例如用户通过智能推荐可以一步把界面内容流转到其他设备。</p><h4 id="清晰明确"><a href="#清晰明确" class="headerlink" title="清晰明确"></a>清晰明确</h4><p>跨设备交互是新的使用体验，用户可能没有预期，交互的指引要清晰明确，可以帮助用户快速了解和学习跨设备交互的使用，例如提供明确的图标或推荐。</p><h4 id="易于理解"><a href="#易于理解" class="headerlink" title="易于理解"></a>易于理解</h4><p>跨设备交互应该是易于理解和记忆的，方便用户长期持续地使用，即使用户没有用过某个分布式的功能，在根据操作指引使用之后应该能够很容易地理解操作流程，记住操作步骤。</p><h4 id="用户可控"><a href="#用户可控" class="headerlink" title="用户可控"></a>用户可控</h4><p>在跨设备交互时，用户要能够随时切换到其他设备或其他可用的跨设备交互模式，例如用户把视频流转到智慧屏设备后，也可以随时切换到其他可用的设备。</p><h4 id="沉浸无干扰"><a href="#沉浸无干扰" class="headerlink" title="沉浸无干扰"></a>沉浸无干扰</h4><p>更多的设备为沉浸式体验提供了更多可能，考虑根据设备的属性在不同设备上分配信息，最大化提供沉浸无干扰的体验，例如在手机上浏览邮件列表，在智慧屏上查看选中的邮件详情。</p><h2 id="分布式体验架构"><a href="#分布式体验架构" class="headerlink" title="分布式体验架构"></a>分布式体验架构</h2><p>随着全场景多设备生活方式的不断深入，用户拥有的设备越来越多，每个设备都能在适合的场景下提供良好的体验，例如，手表可以提供及时的信息查看能力，电视可以带来沉浸的观影体验。同时，每个设备也有使用场景的局限，例如在电视上输入文本相对手机来说是非常糟糕的体验。当多个设备通过分布式操作系统能够相互感知、进而整合成一个超级终端时，设备与设备之间就可以取长补短、相互帮助，为用户提供更加自然流畅的分布式体验，在 HarmonyOS 中我们把分布式体验统称为分布式流转。</p><p>目前为止，分布式流转包括跨端迁移体验和多端协同体验两种类型。</p><ul><li><p>跨端迁移是指当用户在一个设备上发起操作，并切换到另一个设备上继续操作时，用户能够马上在新的设备上继续当前的操作。</p></li><li><p>多端协同是指多个设备上的软件和硬件能力相互协同，作为一个整体为用户提供比单设备更加高效、沉浸的体验。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjRhNzYxMTU3OTZhMTMzNjBkMzUzOTU4MmM4MTEwZTlfMHpPZXczVGN6WGlwVzZNU3RqbEs0Zm1SOUZsS1h2QnJfVG9rZW46Ym94Y250RlU3dVVqdzFDM0w4alp2RnA4cUNoXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>通过精心开展的跨端迁移和多端协同设计，应用开发者可以打造优秀的分布式流转体验。请阅读相关章节了解对应的体验特点和设计方法</p><h2 id="跨端迁移设计"><a href="#跨端迁移设计" class="headerlink" title="跨端迁移设计"></a>跨端迁移设计</h2><h3 id="跨端迁移场景"><a href="#跨端迁移场景" class="headerlink" title="跨端迁移场景"></a>跨端迁移场景</h3><p>用户使用应用的过程中，当使用情境发生变化时（例如从室内走到户外、从办公室到车上等），之前使用的设备可能已经不适合继续当前的任务，或者周围有更合适的设备，此时，用户会选择使用新的设备来继续当前的任务，这就是跨端迁移。跨端迁移适合文档编辑、视频、游戏等场景。例如，在手机上编辑邮件，回到家里后迁移到平板，在平板上继续编辑邮件。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmJmMzI0NzEwY2U1MTdkYjBmZjFkZGZjYTk4ZWI1YzNfeE9DR0RkRTk4MVBBUmZYQWhYMkZXQXcyTm5wd2NVMXhfVG9rZW46Ym94Y25iM3dPYTV1dTVCY3pCNE1wVDVScW5nXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>跨端迁移适合的场景有：</p><ul><li><p>在外时手机上编辑邮件，到家后迁移到平板上继续编辑。</p></li><li><p>在外时手机玩游戏，到家后迁移到平板上继续玩。</p></li><li><p>在家里智慧屏上看视频，出门时迁移到手机上继续观看。</p></li><li><p>手机视频通话迁移到智慧屏，更沉浸地视频聊天。</p></li></ul><p>一个好的跨端迁移设计会让整个迁移的操作过程自然流畅，不需要用户做额外的操作。</p><p>应用在设计跨端迁移时，必须满足如下体验要求：</p><ul><li><p>为用户提供跨端迁移的明显入口或指示。</p></li><li><p>迁移后，迁移设备需同步呈现原设备上任务的状态，避免迁移造成用户的迷失。</p></li><li><p>迁移后的任务要能够满足用户当前的主要任务诉求，用户能够独立进行使用</p></li></ul><h3 id="跨端迁移交互定义"><a href="#跨端迁移交互定义" class="headerlink" title="跨端迁移交互定义"></a>跨端迁移交互定义</h3><p>当用户进行的任务跨端迁移到其他设备后，迁移设备上的任务可以独立运行，原设备上的任务关闭。例如，在手机上打开了备忘录，把备忘录迁移到平板后，平板可以独立编辑备忘录，而手机上的备忘录自动关闭。</p><h4 id="迁移入口"><a href="#迁移入口" class="headerlink" title="迁移入口"></a>迁移入口</h4><p>迁移入口有两种类型，不同迁移入口对应的操作略有差异：</p><ul><li><p>智能推荐</p></li><li><p>手动迁移</p></li></ul><h4 id="智能推荐"><a href="#智能推荐" class="headerlink" title="智能推荐"></a>智能推荐</h4><p>系统根据用户习惯、场景和可用设备，主动推荐最适合的设备进行迁移。</p><p><strong>原则</strong></p><ul><li><p>不干扰当前操作。</p></li><li><p>方便操作，提升效率。</p></li><li><p>符合用户场景。</p></li></ul><p><strong>推荐气泡</strong></p><p>当检测到用户周围有更合适的可迁移设备时，当前设备上会出现推荐气泡，用户点击推荐气泡可以进行跨端迁移。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODJiMzUwNWE0MDFiOTZiYjBmMTNiNDZjNWY0MzY4YTNfaFVNcWhaeGFTbFBmUWh2T3ppUHRWYWRXOVh2bWk4cGxfVG9rZW46Ym94Y252SVlwNWp5cktaY0hWSnYyQWRtWVJ5XzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>例如当用户编写邮件，到家后为了提供更高效的交互体验，系统会推荐用户将邮件迁移到平板上。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTFhNDQxMzYxNmQ4NTNlYzVhMjg2NGIzMTg3NDU1N2Rfd2pvaWt4QllWQXR1ZlFrWG14WFNJZnVxeE1GaFhOREtfVG9rZW46Ym94Y24zZ1J3TzFLREJMQ1BXYjlSY0VmNkVlXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="手动迁移"><a href="#手动迁移" class="headerlink" title="手动迁移"></a>手动迁移</h4><p>提供应用内迁移的入口，用户手动选择合适的设备进行迁移。</p><p><strong>原则</strong></p><ul><li><p>在不同设备不同场景下有统一的样式。</p></li><li><p>手动迁移按钮触发全量的可用设备列表。</p></li></ul><p><strong>流转图标</strong></p><p>跨端迁移使用流转图标作为应用内手动迁移的入口。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmU5YTUzMWQ3NmM2Zjk5OTYzYTNhNzk0MWNmYTY2MmVfb1ZiNmRjeFFoZ1p6bmNRWGRtNFkyejg0M1Q2akF5MkFfVG9rZW46Ym94Y25OMFNpb0V3bk9yZnJONVR6dVpBWklkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>我们提供了多种图标颜色以适应不同的界面背景，并提供了在界面中如何放置流转图标的建议，详见<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/service-hop-icon-0000001136140831" target="_blank" rel="noopener">服务流转规范</a>。</p><p>点击流转图标后，会拉起系统提供的流转面板进行设备的选择。在流转面板中，开发者需要提供图标、名称及标题。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTUwOWZjM2E2YTJjMzNhN2Y4MDk2ODE0NmNhODVlMDVfTTdmd25mQVpoZE56eDZ5alFWek9ZNHBuUVF5SzJNQmpfVG9rZW46Ym94Y25jMFJFUnR2WWxGWExBN3JzRk00NThiXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h2 id="多端协同设计"><a href="#多端协同设计" class="headerlink" title="多端协同设计"></a>多端协同设计</h2><h3 id="多端协同模式"><a href="#多端协同模式" class="headerlink" title="多端协同模式"></a>多端协同模式</h3><p>不同的设备进行多端协同主要是因为其他设备上有本设备不具备的或比本设备明显更合适的能力，协同后这一项能力得到增强。</p><p>常见的协同能力有：</p><ul><li><p>显示能力</p></li><li><p>摄像能力</p></li><li><p>音频输入能力</p></li><li><p>音频输出能力</p></li><li><p>交互能力</p></li><li><p>传感器能力</p></li></ul><p>我们针对这些常见协同能力总结了常用的协同模式，应用开发者可以根据应用的特点选择合适的模式进行协同体验的设计，或者创造出更适合应用场景的新的协同模式。其他没有列出的能力也可以参考下面列出的协同模式进行思考和设计。</p><h4 id="显示协同"><a href="#显示协同" class="headerlink" title="显示协同"></a>显示协同</h4><p>显示协同是多端协同的常见场景。根据应用界面的构成，显示协同有如下两种常用模式：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTZjN2E3YzI4ZTY5MDQ5ZjNhNjYyNTk5NDkwNmIzZGFfbTBoRWx6ZzR3a1liR2J1VjRtblc2WlNBWFBFNXZnN1VfVG9rZW46Ym94Y250TldHWUhWeENHMldsa0xRdUNSQ0tjXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="显示分离模式"><a href="#显示分离模式" class="headerlink" title="显示分离模式"></a>显示分离模式</h5><p>显示分离模式是指把一个设备上的一个界面或多个界面中的内容分拆到多个设备上同时显示，达到更有效利用显示空间的作用。分拆的内容显示需要根据显示的设备进行响应式布局。</p><p>场景举例：</p><p>邮件应用的列表和详情可以分别显示在手机和智慧屏上，在手机上快速地定位要查看的邮件，在智慧屏上更清晰地查看邮件内容。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODcyNmIyMWQ5NzNkZDE0MGU1NGIyYmNkODM3YzIyMWZfbEp4NnVzOWNrWHVkN0hZUFVFcHdVZDZDUmY5YzJPWTRfVG9rZW46Ym94Y25QdnJJTFhHVHRWMkV5eFpURzZjSnBoXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="显示和功能分离模式"><a href="#显示和功能分离模式" class="headerlink" title="显示和功能分离模式"></a>显示和功能分离模式</h5><p>显示和功能分离模式是指把一个设备上的一个编辑类界面中显示和功能操作的部分分拆到多个设备上同时显示，这样可以有效利用显示空间，提高交互效率。</p><p>场景举例：</p><p>文档编辑应用的文档内容和周边工具菜单可以分别显示在智慧屏和手机上，在手机上快速操作编辑菜单，在智慧屏上更清晰地查看编辑的效果。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2UwYTFjNzEwOGExNGQ4NzM0ZWM0YmZlOTMxZTk5MDZfcWtnNnF5bDFVczdoM3VtOVJNeXR5SXBVbTRGbkhLWmFfVG9rZW46Ym94Y25peWM0c2JNRUxsSDF0VG5UMHJ2N2xmXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="摄像协同"><a href="#摄像协同" class="headerlink" title="摄像协同"></a>摄像协同</h4><p>摄像协同有如下两种常用模式：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTk0ZGEzMjEwMGNlZTFkMTVjNGE3YjZmZWI0OWI1NWVfaGptVGR0UzhJYjhrckU5ZHFRTDZoYlFCT0NjNjhpa3JfVG9rZW46Ym94Y25nbnM0d1RCaHBWSzM5ZXJzZmY3d2RRXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="优选模式"><a href="#优选模式" class="headerlink" title="优选模式"></a>优选模式</h5><p>优选模式是指用另一个设备上的摄像头替代本设备上的摄像头进行摄像。</p><p>一般用在如下场景：</p><ul><li><p>本设备摄像头的拍摄质量不如另一个可用的设备，通过另一个设备的摄像头来获取质量更好的摄像效果。例如智慧屏调用手机的摄像头获取更加清晰细腻的拍照效果。</p></li><li><p>本设备摄像头的位置和角度不适合当前摄像场景，通过另一个设备的摄像头能够克服这些问题并获得满足质量要求的摄像效果。例如手机调用智慧屏的摄像头完成全家福拍照。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWI0MGVlODk1ZDg5MzQ4YmI0ZjIyMjFmZTAxMjkyY2ZfWmpIVDl0Q1IybTlIV0xmSndraHE1Ymx2UzF3cllGYnFfVG9rZW46Ym94Y253UGRIMVlLeEVrdE1SVFJjY1VxSGJjXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="多路摄像模式"><a href="#多路摄像模式" class="headerlink" title="多路摄像模式"></a>多路摄像模式</h5><p>多路摄像模式是指一个设备调用另一个设备上的摄像头和本设备上的摄像头组合在一起使用。当需要提供除本设备外更多的摄像取景画面时，通过调用另一个设备的摄像头来获取多路摄像的效果。</p><p>常用的多路摄像模式展示形式：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzg4NDBlNmIzNjViZGZkNjFjN2M2M2JhOTY1YWM5NTlfUm9yZzBZU0k0eXZsYmJDangzeGRXNzVQRmlVeEZYVUZfVG9rZW46Ym94Y25OaVZRVnAyUEVNZFpWZE1LSWxyNlJmXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>场景举例：</p><ul><li><p>拍视频时，同时使用手机摄像头和智慧屏摄像头，提供两个取景界面的视频录制并组合生成一个视频。</p></li><li><p>直播软件在直播卖货时，同时使用手机摄像头和其他设备的摄像头，手机摄像头拍摄主播，其他设备的摄像头拍摄商品，一般只给观众显示拍摄主播的摄像头取景界面，当需要展示商品时切换到拍摄商品的摄像头取景界面。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDE2OGU0MzRlNWNjNTIwNzU5Mzg0NzdhOTBjMjFlZWRfSmsycWxPR1hOV0hSOU4zY3lPamw5T3ZnalVWaVJHbmNfVG9rZW46Ym94Y25peW1UaEFqTTc0TjBHQjFveDdoYmZiXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGY3Y2IwOGEzYmRlYzgxNzRiNmEzNTU1ODE5OTFhZmJfUzVzZUNOTHBWY3oyRmYxbUZUMXVMaVFGSm5OdkFwTkxfVG9rZW46Ym94Y24xTmhwaFJqb1oxWEVkVkdmT3F1VjFkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="音频输入协同"><a href="#音频输入协同" class="headerlink" title="音频输入协同"></a>音频输入协同</h4><p>音频输入协同有如下两种常用模式：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGEwYzMyOWNlNDhjYzJjYjdmYjcyNzZiNDFmY2ZiZTFfQXhDOFVXRUVwUDRsaGVoVDVITFhkV0I5MVlLNG5LSnVfVG9rZW46Ym94Y25yWklHeWc1cjhJRUZoeERtQWZVM3RkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="收音增强模式"><a href="#收音增强模式" class="headerlink" title="收音增强模式"></a>收音增强模式</h5><p>收音增强模式是把另一个设备的音频输入能力作为补充，提供更清晰的收音效果。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2VhNjJlYTkwYzc3MTUzNTcwMGQ2OGNhNmY3MjYxYTNfYmhyTmVrUTdRWlBrU2pzR2Z1NHZyRGdmSVpVZzdJUFdfVG9rZW46Ym94Y25lQzRJalV5TElpOTVpR1c5QWs5OFVXXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>场景举例：</p><p>上课时坐得比较靠后，听不清老师的讲话，可以把另一个具备音频输入能力的设备放在离老师近的地方，通过收音增强模式获得清晰的收听效果。</p><h5 id="话筒模式"><a href="#话筒模式" class="headerlink" title="话筒模式"></a>话筒模式</h5><p>话筒模式是把另一个设备的音频输入能力作为话筒来使用，当用户需要更好的话筒效果或更多的话筒时使用话筒模式。话筒模式通常需要跟音频输出设备（如音箱）结合使用，把话筒的效果通过音箱播放出来。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDY3MjUxZWExNzgwNzM3OWM4Mzc3MDc4MGQyMTVhMDBfcEVVSTFqUkhIb25wYklYVGgwRWJkM2t2TUlIcGxTZ2pfVG9rZW46Ym94Y25jelcyVnFWd0dsVjF1dWJlTFFkQXhmXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>场景举例：</p><ul><li><p>在比较吵闹的地方，用户把手机作为话筒，将声音通过连接的音箱进行播放，达到类似专业话筒的效果。</p></li><li><p>在K歌的时候，把手机作为话筒接入K歌软件，达到多个人多个话筒合唱K歌的效果。</p></li></ul><h4 id="音频输出协同"><a href="#音频输出协同" class="headerlink" title="音频输出协同"></a>音频输出协同</h4><p>音频输出协同有如下两种常用模式：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTczNjE3OGJjYmRiYTRkMjY4NjYwNGM3Y2E0Y2E5ZjhfTjhhQkx1UHF4TTliSkF3d2NyRGtheDFxb2YwbmJ2enFfVG9rZW46Ym94Y25WVThZVHoxcEVVUzZ3NlNyOHdjSFFmXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="音视频分离模式"><a href="#音视频分离模式" class="headerlink" title="音视频分离模式"></a>音视频分离模式</h5><p>音视频分离模式是指把一个设备上视频播放场景中的音频分拆到其他设备上，可以提升特定场景下的音频使用体验。</p><p>场景举例：</p><p>当手机视频迁移到智慧屏观看时，为了不吵到其他人，把音频切换到耳机进行播放。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDQ5M2YzYTAxZmVjMTIwOGQzNzMzM2MwNjQ3ODc3NmFfQXlJT0ZFZ29JV05PbDRhN0tmMFhESEhGNWd6RlVScGRfVG9rZW46Ym94Y241NDFRRUdJeDJtdUQzMjZTVGtNRXdkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="多路音频播放模式"><a href="#多路音频播放模式" class="headerlink" title="多路音频播放模式"></a>多路音频播放模式</h5><p>多路音频播放模式是指一个设备上的音频输出和另一个设备上的音频输出同时使用，可以提供立体声或同时在不同设备上播放不同音频等使用体验。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmNmNTBlYTRhMGFmYzg0YTZkNGUwNGUxMGI4YTg2NTBfY1RhNmM3OEY1d1cwWGdXYXp5dmJZcFBSSkNYS0RVQXJfVG9rZW46Ym94Y241c1hDVUVJVXBFa0N5WndWOWlpdTVmXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>场景举例：</p><ul><li><p>HarmonyOS 设备连接多个音箱同时播放一首音乐，提供立体声的播放效果。</p></li><li><p>手机一边通过音箱播放音乐，一边通过耳机接听电话。</p></li></ul><h4 id="交互协同"><a href="#交互协同" class="headerlink" title="交互协同"></a>交互协同</h4><p>交互协同有如下两种常用模式：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTM3NzljOWI4ODg2YTdiOWRjZWY4Y2YwYjA3MTYzZDBfTFZhV0laZ2V3U2Y1ckVCNmZNTUpDeGQ2ZXlBdzZOT2FfVG9rZW46Ym94Y25maXlTOHRMM3ZqMHZzWk92Vm5STUFCXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="内容输入协同"><a href="#内容输入协同" class="headerlink" title="内容输入协同"></a>内容输入协同</h5><p>内容输入协同是指利用另一个设备上便捷的内容输入能力帮助本设备进行内容输入，提升内容输入效率。</p><p>场景举例：</p><ul><li><p>在智慧屏上进行搜索时，在手机上帮助智慧屏进行文本输入。</p></li><li><p>通过智慧屏上网课时，在手机上帮助智慧屏进行手写答题或绘画。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzA1ZTg3ZTAwYmJiMDVjNTNjMDc2MzhlMmQwYTY4ZmJfNXo4RWpMYkwzUFZwZEJKYVY2eVNPR2I4aGdMTEhHQnpfVG9rZW46Ym94Y253YzU4NzVod2o4VGxHaWFiNkY5MFlnXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="控制输入协同"><a href="#控制输入协同" class="headerlink" title="控制输入协同"></a>控制输入协同</h5><p>控制输入协同是指利用另一个设备的更方便的交互能力帮助本设备进行操作，提升操作效率。</p><p>场景举例：</p><p>在智慧屏上玩游戏时，利用手机作为游戏遥控器进行游戏操控。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmQwN2M0YjQwODk4N2I2ZGVlYjMwNmU4Mjk1NDliZGVfdEFTNXZCcWVMSmplazhBOGFXZVRkRUNkdDJ1d2Q1ZldfVG9rZW46Ym94Y251NjB3NTlXMVpGeGRPWTdUYXNMT1RYXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="传感器协同"><a href="#传感器协同" class="headerlink" title="传感器协同"></a>传感器协同</h4><p>传感器协同有如下两种常用模式：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDBiNjgyMmFiMTg3OTUzMzJmNjE2ODRlMDMzM2U2NTFfMkhlSjRzS3N0eG9jN3lFOTBHNVNZeXVZeDFQaHdFazRfVG9rZW46Ym94Y244NzBJQnZETlRRbndvdGVBVFNyd0piXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="生理数据检测"><a href="#生理数据检测" class="headerlink" title="生理数据检测"></a>生理数据检测</h5><p>生理数据检测是利用其他有生理数据检测能力的设备（如手表）获取生理数据，一般用于运动、健康类应用。</p><p>场景举例：</p><p>在智慧屏上学习健康类课程时，通过手表获取实时的心率数据，并显示在智慧屏上，帮助用户了解健康状态，给出健康建议。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDU0MjZlNDM4ODc1OTk3YmRjNzYzOWFiMmM2Mzk5NDVfNTBYeHNzdEVqcVI2U2plV2lwUWl2SDUyTU4zNUhmZk5fVG9rZW46Ym94Y25weFFpUk9TOGt1SDFlbEVCRkI3V2dmXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="运动数据检测"><a href="#运动数据检测" class="headerlink" title="运动数据检测"></a>运动数据检测</h5><p>运动数据检测是利用其他有运动数据检测能力的设备（如手表）获取运动数据，一般用于运动、健康类应用。</p><p>场景举例：</p><p>在智慧屏上使用运动类应用时，通过手表获取用户的运动数据，并显示在智慧屏上，帮助用户了解运动状态，给出运动建议。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQ5MTEwMGUyYWE0NjNmMzJmNjNmODAxMTk4NzgyZTZfSlJCR05xY3o2ZG9SSzNIRjZQMjlmUTdxNHQ2SGhIZzdfVG9rZW46Ym94Y255cXpHbkd0S1g3T2FDY0o3SXIxaVpnXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="组合能力协同"><a href="#组合能力协同" class="headerlink" title="组合能力协同"></a>组合能力协同</h4><p>在实际设计中，不是所有的协同都是单纯的某一项能力的协同，例如某些场景下可能同时使用智慧屏的显示能力和摄像能力。这种情况下，可以组合这些能力进行协同，提供更加符合场景的协同体验。</p><p>应用开发者在设计中，应该针对应用所使用到的每一项能力考虑多设备下的协同模式，并把这些用到的协同模式组合在一起检查整体的使用体验。即使每一项独立的能力是最佳的协同效果，多个能力协同组合在一起后可能也会带来糟糕的体验，需要基于场景和设备的其他属性来考虑如何达到更好的整体协同体验</p><h3 id="基于场景和设备属性设计多端协同体验"><a href="#基于场景和设备属性设计多端协同体验" class="headerlink" title="基于场景和设备属性设计多端协同体验"></a>基于场景和设备属性设计多端协同体验</h3><p>通过对特定类型的设备进行分析，了解此类设备的优劣势，总结出此类设备在多端协同中可以提供的能力和需要提供帮助的能力，再基于应用的场景把多个设备的这些优劣势进行匹配，可以设计出优秀的多端协同体验。</p><p>下面针对典型的 HarmonyOS 设备进行分析。</p><h4 id="设备特性分析"><a href="#设备特性分析" class="headerlink" title="设备特性分析"></a>设备特性分析</h4><p><strong>智慧屏</strong></p><p>无法复制加载中的内容</p><p><strong>手表</strong></p><p>无法复制加载中的内容</p><h4 id="设计举例"><a href="#设计举例" class="headerlink" title="设计举例"></a>设计举例</h4><p>场景：用户在家中进行运动课程训练。</p><p>通常情况下用户的操作过程如下：</p><ol><li>在手机上打开运动健康应用。</li><li>选择要进行的运动课程。</li><li>把手机放在前方桌子上跟着应用的视频进行训练。</li></ol><p>当把多设备考虑进来之后，可以按照如下步骤来考虑多端协同设计：</p><ol><li><p><strong>列出周边可能可用的设备</strong>：家中有智慧屏，用户手上带着手表。</p></li><li><p><strong>列出此场景下应用需要的能力</strong>：视频课程播放需要用到设备的显示能力。</p></li><li><p><strong>列出需要的能力有优势的周边设备</strong>：智慧屏的屏幕显示更大。</p></li><li><p><strong>选择合适的协同模式</strong>：适合采用显示协同的“显示和功能分离模式”（视频在智慧屏上播放，手机显示控制界面）</p></li><li><p>考虑可用设备其他的优势是否可以带来增值体验</p><p>：</p><ol><li>智慧屏的摄像能力可以帮助拍摄用户运动的状态，方便用户更好的调整运动姿态。</li><li>手表的生理数据检测能力可以帮助检测心率等生理状态，方便应用提供更精准的训练建议。</li><li>手表的随身特性可以让用户更方便的控制训练视频的播放。</li></ol></li><li><p><strong>整合协同模式，检验整体操作流程</strong>。</p></li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODQyZDUyNGM5OWQzOTgyZTFhNDYxZDU0YTkwNTc4MzBfTjdjWEdqUDZPSTFEMENmQ0QzUzc4UUtuTDgzMW5ScnlfVG9rZW46Ym94Y25OanpoSXkyR0ZnMEJQWWpYaHBlaTBlXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h3 id="多端协同交互定义"><a href="#多端协同交互定义" class="headerlink" title="多端协同交互定义"></a>多端协同交互定义</h3><h4 id="协同入口"><a href="#协同入口" class="headerlink" title="协同入口"></a>协同入口</h4><p>多端协同入口有两种类型，不同入口对应的操作略有差异：</p><ul><li><p>智能推荐</p></li><li><p>手动协同</p></li></ul><h4 id="智能推荐-1"><a href="#智能推荐-1" class="headerlink" title="智能推荐"></a>智能推荐</h4><p>系统根据场景和可用设备，主动推荐最适合的设备进行协同。</p><p><strong>原则</strong></p><ul><li><p>不干扰当前操作。</p></li><li><p>方便操作，提升效率。</p></li><li><p>符合用户场景。</p></li></ul><p><strong>推荐气泡</strong></p><p>当检测到用户周围有更合适的设备时，当前设备上会出现推荐气泡，用户点击推荐气泡可以进行多端协同。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzEyMmE4OTdhNjE4ZjhhZTJmNTM2YWIyM2UwNDgwNjJfMjRoSTRLajZPTkExOUtuZGhudzlyMG5iaDZXYXdPNkVfVG9rZW46Ym94Y25BSHN3dEcyRUQ1ZzI4R1htd1VHSTdkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>例如当用户使用手机玩游戏时，系统监测到周边有智慧屏，为了提供更沉浸的游戏体验，系统会推荐用户将游戏协同到智慧屏上，而手机则作为遥控器进行游戏操控。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTY1NzQyMDUwZTMwNDEwMjk4MWU0NTJiOWM3YTc1OWNfa2dRaFg1dXdXaXNWVEZqa3hiZmxEc2I2UVZra0dOTDVfVG9rZW46Ym94Y25vVzdRUUhsOWwzaGhkTmtrY2ppQkRkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="手动协同"><a href="#手动协同" class="headerlink" title="手动协同"></a>手动协同</h4><p>提供应用内协同的入口，用户手动选择合适的设备进行协同。</p><p><strong>原则</strong></p><ul><li><p>符合场景</p></li><li><p>明确表达含义</p></li></ul><p><strong>流转图标</strong></p><p>一般情况下，多端协同使用流转图标作为手动发起的入口。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjFmZGRkZjkyMWZkYjY4Y2QzZjk5ZGRmNWQwMDMxNGZfTTJhRFhsanN3bXpBbGVJNVJXSjJNTkthWkFOVjJxaWVfVG9rZW46Ym94Y25XeGZOcmxkYm52dHJjano2OW1YZlhmXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>我们提供了多种图标颜色以适应不同的界面背景，并提供了在界面中如何放置流转图标的建议，详见<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/service-hop-icon-0000001136140831" target="_blank" rel="noopener">服务流转规范</a>。</p><p>点击流转图标后，会拉起系统提供的流转面板进行设备的选择。在流转面板中，开发者需要提供图标、名称及标题。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWY2YTM2ODMyYWZhYTI5ZWQ4NGExZTkxNzY5MmI5OGRfUjRmVERSTU14WEs2c3dFN3M2ZFRGRE9wMXI5a3V3a2JfVG9rZW46Ym94Y25INTBucXBTc2V2cFM3TEJZYjNaUHdkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p><strong>业务图标</strong></p><p>当应用跨设备的场景是应用当前功能的必要特性时采用业务图标入口，点击后显示设备选择列表。例如，K歌应用定义了多个手机作为麦克风唱歌的功能，命名为合唱，点击合唱图标可以进入选择其他手机麦克风的界面，添加其他设备的麦克风后可以为用户提供多手机合唱K歌的体验。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGY5OWVhNDBlZDVhYzRiMjNmYWE2YTI4NDBjNDhlMTBfd09SbERvcnpadzAyTXBkeG9OMFRaUEoyalhTUVl4a2RfVG9rZW46Ym94Y25VdGZHUm9menQyTkZjM1lHM2NvakxoXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>在使用业务图标的场景，点击业务图标后，应用需要显示设备选择列表进行设备的选择。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTU2MjhkNjk2ZDlmZWJhZmQ3YTcxZDBiMDFlNDQyOTFfM0VlWUR0aWFKdm1MTEoyazVqd1JTMGZjTTE1M0I5c0RfVG9rZW46Ym94Y25POXdUTEV2bmlMa25WSnVlNU9Oc1FmXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="协同控制"><a href="#协同控制" class="headerlink" title="协同控制"></a>协同控制</h4><h5 id="设备切换"><a href="#设备切换" class="headerlink" title="设备切换"></a>设备切换</h5><p>多端协同中时，流转图标为点亮状态，再次点击图标，打开设备流转面板，可通过流转面板控制协同到其他设备。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWYxYzliN2ZhZTk0OGNhODYzYjZmZTNhOWIxNTc3ZTFfOVBsaEREWnl3bFdmaVQ3VjRtUFVVTkFvN2plT2tMMzRfVG9rZW46Ym94Y251NVJBelBRZ3FaRVhUb2t2RVhaOGhkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="退出协同"><a href="#退出协同" class="headerlink" title="退出协同"></a>退出协同</h5><p>在打开流转面板时，也可以通过点击“结束流转”按钮或者再次点击正在流转的设备以结束迁移，把任务拉回到原设备上。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODI0MzAwNGY4ZTFhNmIyM2QyNjNiYzgzODRmNjc3NWFfMm9CRFFMbjhrZjNzeEtzSFVCY0dEbE5qNTBUaUFsZk1fVG9rZW46Ym94Y25vWXl2VGxNTG1TelNqN3QyMHc0QnBlXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h2 id="设计自检表"><a href="#设计自检表" class="headerlink" title="设计自检表"></a>设计自检表</h2><p>设计自检表详细列举出了在分布式设计和开发过程中应当注意的用户体验要素，提交审核前请再次检查各项是否符合要求，这将帮助应用减少用户舆情且提升用户体验的一致性。</p><p>自检表的要求范围分为“必选”与“推荐”两类。必选类一般为已总结出的较优解决方案或效果，表示相关设计需要按照此原则统一执行；推荐类指可能受应用品牌风格或业务特殊性影响，可适量做出修改。</p><p>请参考以下表格范围内提出的要求对应用进行检查。</p><p>无法复制加载中的内容</p><h1 id="原子化服务设计"><a href="#原子化服务设计" class="headerlink" title="原子化服务设计"></a>原子化服务设计</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在万物互联时代，人均持有设备量不断攀升，设备和场景的多样性，使服务开发变得更加复杂、服务入口更加丰富。在此趋势下，应用提供方和用户迫切需要一种新的服务提供方式，使应用开发更简单、服务的获取和使用更便捷。为此，HarmonyOS 提供了基于原子化服务和应用的便捷服务。</p><p>原子化服务是 HarmonyOS 提供的一种面向未来的服务提供方式，是有独立入口的（用户可通过点击、碰一碰、扫一扫等方式直接触发）、免安装的（无需显式安装，由系统程序框架后台安装后即可使用）、可为用户提供一个或多个便捷服务的用户程序形态。原子化服务基于 HarmonyOS API 开发，支持运行在 1+8+N 设备上，供用户在合适的场景、合适的设备上便捷使用。</p><p>原子化服务具有随处可及、服务免安装直达、分布式流转等特性。日常生活中，用户可以通过扫描 HarmonyOS Connect 标签、“碰一碰”设备来快速启动原子化服务，也可以在设备的服务中心和桌面上轻松找到他。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MWU1MGI1MGZlMTI3NmNmN2Y4ZTRmNWU4Mjk2ZDhiZTFfblhFbkJOdUJaR1M1blRBQmQ3bENhNE8xQmxsZDFlZDJfVG9rZW46Ym94Y25zZUNtTWxyRWlUUW9yWVRxWnBNbFA0XzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>原子化服务具有如下基本要素，必须设计和开发：</p><ul><li><p>基础信息</p></li><li><p>服务卡片</p></li></ul><p>原子化服务支持如下体验特性，可以融入到产品的设计开发中，拓宽分布式能力场景，打造差异化用户体验：</p><ul><li><p>多种入口</p></li><li><p>服务流转</p></li><li><p>服务分享</p></li><li><p>设备控制</p></li></ul><h3 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h3><h4 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h4><p>每个原子化服务有独立的图标、名称、描述、快照。基础信息将根据场景在服务中心、系统设置等界面展示。</p><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/service-basic-0000001092893896" target="_blank" rel="noopener">了解服务基础信息详情</a></p><h4 id="服务卡片"><a href="#服务卡片" class="headerlink" title="服务卡片"></a>服务卡片</h4><p>为了给用户提供便捷、智能的服务体验，每个原子化服务都需要开发至少一个服务卡片，每个应用可选配置服务卡片。卡片作为服务的轻量承载，需要做到易用可见、智能可选和多端可变。</p><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/service-widget-about-0000001144696239" target="_blank" rel="noopener">了解服务卡片详情</a></p><h3 id="体验特性"><a href="#体验特性" class="headerlink" title="体验特性"></a>体验特性</h3><h4 id="多种入口"><a href="#多种入口" class="headerlink" title="多种入口"></a>多种入口</h4><p>在 HarmonyOS Connect标签的支持下，原子化服务可以通过线上和线下发现。用户也可以在设备的服务中心、桌面等界面发现并管理原子化服务。</p><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/overview-0000001152059407" target="_blank" rel="noopener">了解 HarmonyOS Connect标签详情</a></p><h4 id="服务流转"><a href="#服务流转" class="headerlink" title="服务流转"></a>服务流转</h4><p>在 HarmonyOS 中泛指涉及多端的分布式操作。流转能力打破设备界限，多设备联动，使原子化服务可分可合、可流转，实现如邮件跨设备编辑、多设备协同健身、多屏游戏等分布式业务。</p><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/service-hop-overview-0000001089296748" target="_blank" rel="noopener">了解服务流转详情</a></p><h4 id="服务分享"><a href="#服务分享" class="headerlink" title="服务分享"></a>服务分享</h4><p>原子化服务支持通过面对面或网络途径分享给其他用户，如 Huawei Share、畅连分享，结合免安装和流转特性，能让接受分享的用户立即打开并协同使用原子化服务。</p><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/service-share-huaweishare-0000001095058634" target="_blank" rel="noopener">了解服务分享详情</a></p><h4 id="设备控制"><a href="#设备控制" class="headerlink" title="设备控制"></a>设备控制</h4><p>HarmonyOS 尽力为用户打造简单易用、自然流畅的设备控制功能。用户可通过手机便捷地连接和控制 HarmonyOS 设备，用手机“碰一碰” HarmonyOS 设备的 NFC 标签，识别后手机将运行对应的原子化服务。</p><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/principle-0000001053627645" target="_blank" rel="noopener">了解设备控制详情</a></p><h2 id="基础信息-1"><a href="#基础信息-1" class="headerlink" title="基础信息"></a>基础信息</h2><p>每个原子化服务有独立的图标、名称、描述、快照。基础信息应能够准确反映服务提供方的特征及服务的核心体验，并与其他关联的应用和服务保持同步最新。</p><p>原子化服务信息将展示在服务中心、搜索等界面。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjJiNmFhY2YxYzIyNWM0OGFhM2M5NGFmNzVmN2VkYTVfRGY5eHRkQ2g5NWJJZFVJSVJ3VEN5bEhKNnZ0SW1pek9fVG9rZW46Ym94Y242VGJWcE91Z2VBNXVHVkxnVFBmSjJvXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p>原子化服务图标与应用图标有明显区别，它继承了 HarmonyOS 的设计语言体系，内部圆形表示完整独立，外圈装饰线表示可分可合可流转的特点。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTA0OWYxZTgxMDE5MWNlMjQ0YWU1YWI0MWFmZTM2ZjlfQ0Z6MmhCSmo2TVlNNkk1elZsanlxc090c2VJcUg2WXNfVG9rZW46Ym94Y25Wc2hVUHBFQ0VKY2Vqbk9SWjVDdU5iXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>原子化服务图标必须在华为提供的标准图标底板上设计。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDdhM2JlZWM5OGFkMzI5Yjk0MTBmZWQxNGJjODhmZDRfejlhZ3FCbEFPZllWSmp1NVFTTm1aMGZlRHRxR3djdzBfVG9rZW46Ym94Y25iU2doTEJjZUtKQzVKeDV3ZUpva3JkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><ol><li>图标主体内容可沿用应用图标，或根据服务特征专门设计。</li><li>图标主体内容应保持在圆形区域内。</li><li>外圈装饰线可根据主体内容或品牌色填充：单色、双色、渐变色。</li></ol><p>以下是图标绘制样例</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWY0M2Y4ODFjNjE1NjU3NzM1ODc0NjBhNzk3MDRkNjdfbXhpdnNwRENrMXFlY0hrY1pienlDZDlMbmZHQzlneU5fVG9rZW46Ym94Y25IU0N2S0NyZnlCT1dFSUo1NjY5MlhlXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h3 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h3><p>原子化服务名称应精确表示服务内容，不宜过长。名称中应体现品牌或服务提供方以便用户区分，可在名称中的不同位置出现，符合阅读习惯。</p><p>如“华为商城购物车”、“最新信息”、“我的畅连联系人”。</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>原子化服务描述应简要而准确地说明服务的功能，做到用户一眼可知。不允许出现广告运营或为应用引流的暗示信息。</p><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><p>快照为与原子化服务关联的小尺寸服务卡片的截图。截图应为理想的服务状态，让用户一眼可知服务内容。需提供直角图片，由展示快照的应用进行圆角裁切。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTJjYmIwMmY3N2M1NThhYzE5NjMzMWNkYzMzZmU1NDdfWmFScURTZUFnTHliYjAzbldGbnZYbEx6NEhaU3NlTTlfVG9rZW46Ym94Y25Ja25ZaWZzM0w2RWxYbWtFdmpja2NkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><ol><li>快照分辨率必须为 600*600 ，对应小尺寸服务卡片设计</li><li>由展示界面适配圆角</li></ol><h2 id="服务卡片-1"><a href="#服务卡片-1" class="headerlink" title="服务卡片"></a>服务卡片</h2><h3 id="关于卡片"><a href="#关于卡片" class="headerlink" title="关于卡片"></a>关于卡片</h3><h4 id="服务卡片介绍"><a href="#服务卡片介绍" class="headerlink" title="服务卡片介绍"></a>服务卡片介绍</h4><p>将原子化服务/应用的重要信息以卡片的形式展示在桌面，用户可通过快捷手势使用卡片，通过轻量交互行为实现服务直达、减少层级跳转的目的。</p><p>服务卡片的核心理念在于提供用户容易使用且一目了然的信息内容，将智慧化能力融入到服务卡片的体验中供用户选择使用，同时满足在不同终端设备上的展示和自适应。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjg4ZGJiZjY1YTFiMmM1MDAwOWQyMWEyZTk3OWM0ZTJfcG5LSUxLdzhJSEJJemNiQnlVeEl0dWtoeDQ1cTRqdHBfVG9rZW46Ym94Y25saTZtUEphbUo0bWM0N2thcVpIS2xiXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="服务卡片的构成"><a href="#服务卡片的构成" class="headerlink" title="服务卡片的构成"></a>服务卡片的构成</h4><p>服务卡片的显示主要由内容主体、归属的 App 名称构成，在临时态下会出现Pin钮的操作特征，点击按钮用户可快捷将卡片固定在桌面显示。开发者应该借助卡片内容和卡片名称清晰地向用户传递所要提供的服务信息。</p><p>服务卡片在桌面或者服务中心显示的名称为应用名称，不可更改此名称的展示规则。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2JjZDA5OTk1ODI4MDhlZTU3OTIxNTM3NzYwZjY1MjRfYmZqeUh3T3pDVjZzd0NlYzA3TG5IOWs4WVpWVGViclhfVG9rZW46Ym94Y25DYTV0T2NuVHphY1VpOU1zbE9Fa1ZkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="服务卡片尺寸"><a href="#服务卡片尺寸" class="headerlink" title="服务卡片尺寸"></a>服务卡片尺寸</h4><p>服务卡片支持多种卡片尺寸：微、小、中、大。卡片展示的尺寸大小分别对应桌面不同的宫格数量，微卡片对应 1<em>2 宫格，小卡片对应 2</em>2 宫格，中卡片对应 2<em>4 宫格，大卡片对应 4</em>4 宫格。</p><p>无法复制加载中的内容</p><p>同一个应用还支持多种不同类型的服务卡片，不同尺寸与类型可以通过卡片管理界面进行切换和选择。</p><p>上滑应用图标展示的默认卡片的尺寸由开发者指定。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzJiNTQ5ZmUwOTI5ZTg4ZWU5NzViMGVmZDc3OWMxZmVfSXl2dndZbkFRWkRXbjFJbHFYUG5CMENsWXdrcFB6QTBfVG9rZW46Ym94Y25tWUJLSERhbUJ0SlZ1TzJqMXU4cXhjXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h3 id="交互设计"><a href="#交互设计" class="headerlink" title="交互设计"></a>交互设计</h3><h4 id="如何使用卡片"><a href="#如何使用卡片" class="headerlink" title="如何使用卡片"></a>如何使用卡片</h4><p>服务卡片在桌面上有临时和常驻两种状态。临时态卡片以轻量、便捷的方式向用户展示服务内容，即用即走的操作体验能保证不破坏现有桌面使用习惯，实现服务直达的目的，而常驻态又能满足用户对服务内容的持续关注。</p><ul><li><p>临时显示：上滑桌面应用图标快捷展示当前应用的服务卡片，点击卡片以外的区域能收起卡片返回桌面。</p></li><li><p>常驻显示：点击临时态卡片 Pin 的图标可将卡片固定到桌面上常驻显示，用户还可以通过拖动服务卡片到桌面常驻展示。</p></li></ul><h4 id="服务卡片管理"><a href="#服务卡片管理" class="headerlink" title="服务卡片管理"></a>服务卡片管理</h4><p>长按卡片后会显示“更多服务卡片”菜单，点击即可进入更多服务卡片界面。用户通过此界面可选择不同尺寸和服务内容的卡片，也可以长按拖动卡片到桌面上。</p><h4 id="服务卡片基础交互规则"><a href="#服务卡片基础交互规则" class="headerlink" title="服务卡片基础交互规则"></a>服务卡片基础交互规则</h4><p>前后呼应：卡片内支持多热区，跳转到与之对应的内容界面。简单交互：不要在卡片内设计左右、上下滑动的操作。避免冲突：在桌面长按卡片可拖动或管理卡片，因此卡片内不支持长按和拖动操作；由于卡片右上角被 Pin 钮占用，因此请不要再右上角 30*30vp 的区域内放置可操作组件或热区。</p><h4 id="服务卡片热区定义"><a href="#服务卡片热区定义" class="headerlink" title="服务卡片热区定义"></a>服务卡片热区定义</h4><p>开发者需要保证可操作热区与界面内容的交互逻辑一致，否则可能影响用户对服务卡片可操作内容的判断。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJmOThmZTIwMmJiZTg1MTRmMTZlN2UxM2E3M2ZlMWJfVFNEVndLSlBtQ3ZvUWVrcnZlWU9tOVI1TklWd29SSTlfVG9rZW46Ym94Y25EaDlna3lseW9tRXQ4aFU0MmVWWmdiXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="卡片跳转规则"><a href="#卡片跳转规则" class="headerlink" title="卡片跳转规则"></a>卡片跳转规则</h4><p>服务卡片点击可进行界面跳转，跳转至对应原子化服务或应用内界面；当用户进入到原子化服务或应用界面时，返回到桌面，再此对卡片进行点击时，仍然会到对应原子化服务或应用界面，而不是上次停留的界面；从服务界面返回到桌面时，服务界面应该先回到当前卡片的位置，而不是应用图标的位置，遵循从哪来到哪去的基本原则；不要在卡片内通过点击或其他操作后出现弹窗、半模态等其他操作界面，卡片是拉起服务的主要入口，避免不一致的交互行为；</p><h3 id="内容设计"><a href="#内容设计" class="headerlink" title="内容设计"></a>内容设计</h3><h4 id="体验原则"><a href="#体验原则" class="headerlink" title="体验原则"></a>体验原则</h4><ul><li><p><strong>突出卡片的服务内容，而非全是跳转入口</strong>克制的使用按钮这类操作控件，若一个卡片仅有一组信息内容，则点击卡片进入服务界面即可。使用按钮会给用户一种暗示，并吸引用户去点击。另外，卡片仍然是以展示服务信息为主，过多的使用按钮和操作块会使卡片看起来更像是一个快捷指令面板。</p></li><li><p><strong>明确划分有限的操作空间</strong>卡片的使用空间非常有限，请合理的排布文本、图片和按钮之间的关系。用户不会对一张卡片浏览太久，因此展示过于密集的信息可能会影响阅读体验，但可以使用较大尺寸的卡片来展示必要信息。如果在卡片内使用了按钮控件，请考虑用户操作热区以及误操作的可能性。此外，请不要在卡片内使用滑动、拖拽和长按等交互手势，避免与系统交互产生冲突。</p></li><li><p><strong>展示必要的信息和图片</strong>在小尺寸的卡片内，展示一到两个信息点即可，即使用户切换到更大尺寸的卡片，也不要提供过于分散的入口操作。所有信息都请务必关联到应用的业务能力，不要提供不相关的运营内容、广告或流量入口。设计一个整洁的卡片界面，不要为了吸引眼球而使用刺眼的颜色。</p></li><li><p><strong>轻量交互原则</strong>简化用户可感知的行为，在卡片内请勿定义复杂的交互和使用场景，通过点击直达服务界面即可。切勿在卡片内执行流程型工作，例如通过点击按钮出现二级弹窗后再执行下一步操作，或在卡片内使用长按或多指操作。</p></li></ul><h4 id="卡片选择与编辑"><a href="#卡片选择与编辑" class="headerlink" title="卡片选择与编辑"></a>卡片选择与编辑</h4><p>每个应用可以配置多个服务卡片，开发者可根据业务需要来设计不同的卡片。同时，每个卡片也支持多种尺寸选择，可根据展示信息的多少来匹配适合的尺寸，小尺寸卡片为必开发选项。此外服务卡片支持多实例选择，例如：用户手动添加了当地天气的服务卡片，可以通过对单个服务卡片的重复添加来实现多个实例。卡片编辑可以通过配置文件来完成，详情可查看开发指导中对<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-service-widget-provider-optional-0000001104085286" target="_blank" rel="noopener">卡片编辑</a>部分的描述。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2ZjOGEzYmJlNDM2MmJjMjhkZDE2YTExOTUzNzgwNGNfdXBIR3NsUHNDRlR2bWNDMk00V0gyeWJSMWxVZmRyak5fVG9rZW46Ym94Y25Ua0NiS1p3dkVNTVZDT2d3TWtCdDRmXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="内容设计-1"><a href="#内容设计-1" class="headerlink" title="内容设计"></a>内容设计</h4><p>开发者可以定义每一张服务卡片的功能，通常来说，卡片尺寸越小对应展示的功能和信息就越少，所能使用的控件也会受限制。请根据核心诉求进行卡片设计，聚焦在关键信息的展示上。</p><h5 id="卡片内容定义"><a href="#卡片内容定义" class="headerlink" title="卡片内容定义"></a>卡片内容定义</h5><p>在设计服务卡片时，用于展示的设计元素有明确分类，开发者可以使用以下元素来组织一张新卡片。</p><p>不同尺寸的卡片都有使用元素的上限，不要在卡片中放入过多纬度的信息，内容过于复杂会使用户的关注度不够聚焦。</p><p>如下列表所示，在微卡片尺寸下，无论是相同还是不同的元素，使用的数量都请不要超过 2 种。</p><p>无法复制加载中的内容</p><p>如下图示例，卡片应当清晰的展示内容、布局以及业务逻辑，确保不同设计元素之间互不干扰。开发者可以尝试不同布局类型，熟练使用设计技巧对卡片进行布局，以此来满足用户对卡片的个性化需求。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDg2OTc0NmQ1ODNhZjExMDQyY2EzN2VjM2I1YzY3YzhfcmwwaXZNd2xwOXhBNEhndUlQQ0tiWWZVMEpuRWJjcEFfVG9rZW46Ym94Y25Sc2hxMFJZVURkSkd2VUV0dlZ3Yk5MXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGRmMmI5ZWM3NWIyNjMyM2ZkN2U2ZWNmMmFlNmY2MWNfMzRuRHl6dnJVWTFoeDZFUGFjd3dkRVhPcFQ0Q0xBNGVfVG9rZW46Ym94Y25aSG94a1dBNzRlcDVoTlJGWnVFejdiXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="微卡片展示例"><a href="#微卡片展示例" class="headerlink" title="微卡片展示例"></a>微卡片展示例</h4><p>内容由最多 2 种元素构成</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzJmNTQyYTY5Yjg3NzVlMTkxNzBhNDk0MTJjNDAzZDFfeFBkNkxXTElhQmFtT3IyaTNWSXFSeUlqcG9xQ2FNdk9fVG9rZW46Ym94Y25HYzAwdjFkVXNiMzhMMnVZc21nRXRlXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="小卡片展示例"><a href="#小卡片展示例" class="headerlink" title="小卡片展示例"></a>小卡片展示例</h4><p>内容由最多 3 种元素构成</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWIxODI2MDUzNzYxZDhmMTNiZjE4ZDE5OWY3ZDBmMzRfTXFSaWhtalBGSUd5cUZPN1MxZWtMZVdIV3M1a20xd0JfVG9rZW46Ym94Y25tTW1VbFFFRUM0N3NKQVp2dXM2cHg3XzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="中卡片展示例"><a href="#中卡片展示例" class="headerlink" title="中卡片展示例"></a>中卡片展示例</h4><p>内容由 3 种元素构成</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTM2ZjljOGI1YjJjZjhiNGM3MWM5NDI0ZGM1OTA5Yjhfd2N3UWtPd29OVGc3NTduQVFWYm10dnVvM0NZczdqNGlfVG9rZW46Ym94Y25lakthNzR2SG1RQkwzNTJwYkxjZEVjXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="大卡片展示例"><a href="#大卡片展示例" class="headerlink" title="大卡片展示例"></a>大卡片展示例</h4><p>内容由 4 种元素构成</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWVlN2Y0YmQwNGYwNWUwZTk5N2NiNWM0NzJhZmRiNThfakpkUnNFR3NxTmhkWUl2dEozRGtvRGxRV0dtR3ZhNEVfVG9rZW46Ym94Y25od2RSeXlJSzhicXRUTlFNSVZSdjZnXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="合理融入品牌特征"><a href="#合理融入品牌特征" class="headerlink" title="合理融入品牌特征"></a>合理融入品牌特征</h4><p>适当的将应用品牌色或特征图形融入到卡片中，从而让卡片内容更加丰富。在服务卡片设计过程中，为了方便凸显应用的品牌形象，可以选择在卡片左上角露出应用图标。通用图标的尺寸为 20*20vp 的圆形图标，或可以选择使用其他的异形图标作为点缀。因为在卡片系统会默认展示应用名称，因此不需要再重复展示，若需要添加其他文本信息，请使用 14fp 的文本大小。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzNjNzkyY2VlMzM1OTU5YjdlOGEzNDU1YWI1ODIyNmNfMDBQdXZpcmEwSFk4a3hqeFV4N29oMlBPTEpKVVBXSzdfVG9rZW46Ym94Y25jNGI0MmJUNFY0QWl3a2dnc2I2SHllXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="定义卡片的刷新机制"><a href="#定义卡片的刷新机制" class="headerlink" title="定义卡片的刷新机制"></a>定义卡片的刷新机制</h4><p>服务卡片提供自动刷新机制，开发者可以定义卡片自动刷新时间和频率，让用户时刻享受最新的服务内容，有规律的内容变更也更符合用户的心里预期。但频繁的内容刷新并不能带来显著的流量增益，甚至会引起用户对信息真实性的质疑以及使用体验。因此，开发者可以根据业务属性对时间的依赖性进行配置，例如消费类卡片，根据就餐时间刷新卡片内容。让卡片的内容刷新更贴近用户使用的自然规律。</p><p>卡片刷新时间的频率以 30 分钟为基础，开发者可根据业务性质向上叠加时间长度。例如，影音娱乐类的卡片没有在后台运行时，用户可以每隔 2 小时获取到最新的数据信息。</p><p>HarmonyOS 生态面向七大类业务对应用进行归类，按照七大类维度我们定义了不同的刷新时间机制：</p><ul><li><p>家庭生活相关由于用户关注度较高，且跟个人信息相关，平台规定默认刷新时间在 30 分钟以上</p></li><li><p>出行与办公类应用属于低运营属性，通常情况下由用户主动触发功能，因此规定默认刷新时间在 1 小时以上</p></li><li><p>娱乐休闲类大多有固定更新时间，用户单次消耗时间长但频率较低，因此规定刷新时间为 2 小时以上</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGQ2MDk1ZjgxMzcxODliOTNkZDRmYzVhODU1ZTEyZTVfUjR6cUp3TlRORlFZOEJuUHZDb3cwU2JyVXc0Y0pWSlVfVG9rZW46Ym94Y25wVHk1a2RaVTdLOVBqSGQwRHgwNHplXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h3 id="视觉风格"><a href="#视觉风格" class="headerlink" title="视觉风格"></a>视觉风格</h3><h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>服务卡片以展示信息内容为主，传递“弱交互、强服务”的设计理念，为用户提供一步准确直达的使用场景和体验。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWYyNzdkNmVhYTUzNjdmZTdhZWRkNzA4NTIwYWM3MzBfR3VyelJwVUNLVjFoMHQyS3BXV3ZZVklsMGlwT3h5eEhfVG9rZW46Ym94Y25iZTM5dVVUTzhjUDJseUJHU0c3b3NjXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="尺寸与基础参数"><a href="#尺寸与基础参数" class="headerlink" title="尺寸与基础参数"></a>尺寸与基础参数</h5><p>服务卡片按照桌面宫格布局，以手机 4x6 宫格为基础分为 4 种尺寸。在修改手机桌面宫格布局后，微卡片和小卡片仍然按照桌面布局显示，中卡片和大卡片按照宫格最大宽度拉伸。因此在设计时需要考虑到卡片内容的尺寸适配。</p><p>服务卡片使用 HamronyOS 通用界面单位进行开发，在 Java UI 中可以使用虚拟像素（virtual pixels, vp）进行开发，详细规格可参考<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/basic-0000001055539104" target="_blank" rel="noopener">通用设计规范</a>的介绍。在 Js UI 中由于可以设置 Auto Design 属性，像素（Pixel）与虚拟像素（virtual pixels, vp）具有同等概念，可以不做区分。</p><p><strong>尺寸分类</strong></p><p>无法复制加载中的内容</p><p>服务卡片内请保留四周各 12vp 的安全间距，服务卡片内容尽可能保证在安全范围内，在圆角剪裁时避免对内容造成影响。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmY2MGY2YzE2YTkzY2EzYmRmY2JkMjQ1NDM4NGIxMjZfQnZqRXJIZXVIeWJiMjB6emFIWmZpU3FvUk9IUmlIemVfVG9rZW46Ym94Y25jRVh4NURlYW11OTBzazFvV3VyNG1kXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="卡片圆角"><a href="#卡片圆角" class="headerlink" title="卡片圆角"></a>卡片圆角</h5><p>在交付服务卡片时请保证背景是直角矩形，服务卡片的宿主会提供对应的圆角剪裁，保证在不同设备上服务卡片圆角效果一致。</p><p>设计师在进行设计时如果需要保证最终最终效果，可以在设计工具里使用 16vp 圆角预览效果，交付时确保直角即可。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2ExYzUxZDMyZTI2NzM5MzFhYzEzMWYzNWRmMjFjNDhfU1ViNEN2MUJwMFhjeEhoTmVjSlRnbjdUaklzeHNXS1VfVG9rZW46Ym94Y25qbEdDb25BbFBBNHJKbHBCTzJNam1iXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>无法复制加载中的内容</p><h5 id="提供预览效果"><a href="#提供预览效果" class="headerlink" title="提供预览效果"></a>提供预览效果</h5><p>为了满足用户的合理预期，请考虑在网络连接不畅的情况下提供一个预览样式，昂用户了解卡片即将展示的内容。可以提供占位文字或几何图形来代替未能显示的内容，保证占位图或符号与展示卡片在视觉风格上效果统一。</p><h4 id="色彩"><a href="#色彩" class="headerlink" title="色彩"></a>色彩</h4><h5 id="卡片默认背景色"><a href="#卡片默认背景色" class="headerlink" title="卡片默认背景色"></a>卡片默认背景色</h5><ul><li><p>服务卡片的背景色尽可能保持干净整洁，不使用过度激烈的颜色，避免引起用户的视觉疲劳。</p></li><li><p>如果需要体现品牌色特征，请控制在合理范围内，保证用户阅读性和心理感受。</p></li><li><p>系统在浅色模式下默认使用白色，当用户修改系统主题为深色模式时，对应的卡片需要适配深色模式的色彩，卡片默认背景色建议使用系统推荐的#2E3033.</p></li><li><p>除此之外为了提升卡片整体的设计感，也可使用透明度的毛玻璃效果作为卡片背景，如使用此效果需要调用系统的模糊能力。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDJmN2IyODg1NzM4NjY1Y2U1MDk1ZTEwN2M5NDRhMzlfVGZJZDQ2YjBIdEpINk5qUUZJc3RRU3p5M21RZDY2eGhfVG9rZW46Ym94Y253Mjh3N0NqejFNbExSZzdwbGswazA1XzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="默认文本色"><a href="#默认文本色" class="headerlink" title="默认文本色"></a>默认文本色</h5><p>服务卡片内的多彩色参照 HarmonyOS 的色彩标准，可用于高亮文本和图标予以提示作用，突出卡片核心信息。</p><p>多彩色的饱和度较高，请不要过度使用，例如将多彩色直接用于整张卡片的背景或整段文字。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJlNWFlODAxN2ZmNzkyYjdiMWZmNDYyODhmZTEzOTFfQk1MdzNHc1JIRmZUWGNuV0d5MHN1Y1ZwRWFDbTBuamtfVG9rZW46Ym94Y25hQ3BkZHpyeEswRXZvOHFzTHNpQUtnXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="卡片多彩色"><a href="#卡片多彩色" class="headerlink" title="卡片多彩色"></a>卡片多彩色</h5><p>服务卡片内的多彩色参照 HarmonyOS 的色彩标准，可用于高亮文本和图标予以提示作用，突出卡片核心信息。多彩色的饱和度较高，请不要过度使用，例如将多彩色直接用于整张卡片的背景或整段文字。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTRhZTIzM2YwNTdmYmFiOGJjZWRlMjBhOGYzZDk1MDNfTFA5YzFwbWV6OGliemhkaFN2ZHNVZnNMOUV0Z20xRkRfVG9rZW46Ym94Y25vUEdCYldDMDNDelRIR3BJT1hmTjhiXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTI3M2RlZDY4ZTdlNjBhZGZkYzdmNzk5ZGU4ZTkwYzlfMmd0c0NiNjZua0pBcEQ4aUVzRkxGQjRXNXY3NmZYUkxfVG9rZW46Ym94Y243VTVwQmR2UHlxbjRta29qM05oTENjXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="深色模式"><a href="#深色模式" class="headerlink" title="深色模式"></a>深色模式</h5><p>卡片背景若不实用模糊效果，在浅色模式下默认使用背景色#FFFFFF，深色模式下默认使用#2E3033。</p><p><strong>场景1</strong></p><p>局部元素使用透明度为 0% 的 png 资源，保证深色模式下不会渗出底色。</p><p>文本对应系统色板，使用分层参数匹配色彩值。</p><p>图片本身不处理深色模式，不用搭配多套资源。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDkxZDZiOGUyYTNhMThkZTFkMTgzYjgyYzYyNDQzODdfVnlzaW9IZkdNQmtLSlR1eHR6V281aDZxdnJxQlR6a0RfVG9rZW46Ym94Y24wd3dUM2luRFZjNFlsUXdDODduMDJkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p><strong>场景2</strong></p><p>多彩色的使用对应系统参数。若使用品牌色调，请按照业务自身的VI色彩处理深色模式。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZThkZjkzN2Q0M2RjZjZlZGM3ODM1ZDQxZmM0NjcyOTBfNTZiQTlTeFR5M0wyaXF6VDhtQzU0SWxsbWRPdUh5TnJfVG9rZW46Ym94Y25SNzVjUjVob2dXWHFqUWpWZFdqa1JiXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="卡片模糊"><a href="#卡片模糊" class="headerlink" title="卡片模糊"></a>卡片模糊</h5><p>卡片模糊效果能够提升整体的设计质量，使卡片更好的与用户设备融为一体。使用卡片模糊时具体参数请与系统保持一致，为用户创造感官一致的体验。具体实现方式可参考开发者文档：<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ability-service-widget-provider-optional-0000001104085286" target="_blank" rel="noopener">卡片模糊调用方式</a>。</p><p><strong>设备支持模糊场景时</strong></p><p>卡片背景若使用模糊效果也请适配深色模式，具体实现请调用系统的模糊能力，按照系统定义的卡片背景不透明度参数进行设计。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDk0NmVlNzU4Mjk3YTY3ZGVlMTdkNDdmZjQyMTRiZDdfTEpHdVpTZ25rOFM5bUgySGFjeUJ5d0pWQ3c5TktlVjdfVG9rZW46Ym94Y25iS3FCOVBlcHVoY0J0TTRaYUlJa1JkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p><strong>设备不支持模糊场景时</strong></p><p>当卡片识别到设备或场景不支持模糊效果时，卡片背景色更改为无透明度的颜色参数。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTdkMzhjOGZjYzE0YTFmY2JiNjdhYTlmNmI1ZTFmNjBfM3Zld2JVZDV3cGZadklEVDhXZzZhWllVRFJhZGtYMWhfVG9rZW46Ym94Y25hVnd3aU1IcHRoYjBEM3plSGRjaU5oXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p>服务卡片定义了多种文本尺寸，这足以保证内容信息在界面中可以被明确区分且易于识别。</p><p>请参考<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/service-widget-visualdesign-color-0000001144457805#ZH-CN_TOPIC_0000001144457805__section492mcpsimp" target="_blank" rel="noopener">默认文本色</a>章节对于文本颜色的定义，将文本区域用于展示有必要的内容信息。此外，合理运用不同字重在卡片内的关系，帮助用户在阅读相对复杂的信息卡片时能够及时做出筛选。</p><p>字体使用最小 10fp，主要用在数据刻度或提示性文字，不能作为主要信息展示。</p><p>无法复制加载中的内容</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJkOTIwNzk0NjA0ZjMwMGQ1NTkzNDEyNzdhY2Q5NzhfY2t4Njd3MmM3MFZvbmpqaFRhWnMxcUxtVkx2akRIbjZfVG9rZW46Ym94Y253bEQ2VHFvTG5kSUx3VDdpaHdPcWtjXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h3 id="折叠屏、平板设备服务卡片适配"><a href="#折叠屏、平板设备服务卡片适配" class="headerlink" title="折叠屏、平板设备服务卡片适配"></a>折叠屏、平板设备服务卡片适配</h3><h4 id="多设备卡片适配原则"><a href="#多设备卡片适配原则" class="headerlink" title="多设备卡片适配原则"></a>多设备卡片适配原则</h4><p><strong>为不同尺寸的卡片提供不同的功能</strong></p><p>在卡片开发过程中请考虑适配不同尺寸的设备，特别是在折叠屏和平板设备上，设备屏幕尺寸的变化直接影响了卡片内容的展示。请发挥想象力设计具有自适应能力的卡片，避免在卡片内容不做任何处理的情况下直接适配成较大尺寸，原则上卡片尺寸越大呈现的信息要越丰富，可交互的范围也越大。</p><p><strong>使用百分比方式配合标注</strong></p><p>由于设备尺寸的不确定性会导致卡片的尺寸发生变化，设计师在交付卡片布局的过程中，可以使用百分比进行标注。例如标准尺寸的卡片宽度为 150vp，按钮距离卡片边缘间距为 24vp 时，当卡片宽度扩展时仍然使用相同的间距可能效果并不美观，我们可以换算出卡片的间距在标准尺寸下占整体比例的 16%，这样当卡片尺寸扩展到 200vp 时，卡片边距也就变成了 32vp，以此类推，能够保证一定程度下的适配效果。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjM2NDQwMjc1YmRlMzQwZjYwYjUxZWM2YTAwNzQzMTRfSDlENWZ0aG9xQjhCWmQ4NGxKaXJXczVhQWt0WlhqQWJfVG9rZW46Ym94Y25FU1N1bU01Q2d5QzV2NTZ4R0RUSUZjXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="卡片对应宫格比例对照表"><a href="#卡片对应宫格比例对照表" class="headerlink" title="卡片对应宫格比例对照表"></a>卡片对应宫格比例对照表</h4><p>服务卡片参照桌面宫格布局为基准参照物，通过换算对应宫格来实现在不同设备的桌面适配。为了减少卡片尺寸的变化规律，当手机从 4<em>6 布局切换至 5</em>6 布局时，需保证中卡片和大卡片的最大宽度不变化。在平板的桌面 2<em>N 和 4</em>N 对应的桌面宫格对应更换为 2<em>3 和 3</em>3。</p><p>*N为最大横向宫格数</p><p>无法复制加载中的内容</p><h4 id="多端适配尺寸"><a href="#多端适配尺寸" class="headerlink" title="多端适配尺寸"></a>多端适配尺寸</h4><p>服务卡片需要适配除手机以外的折叠屏及平板等设备，可以在此处下载对应 <a href="https://communityfile-drcn.op.hicloud.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20210610175623.01604541679494071675743978690159:50520610025653:2800:7DF5E64DC40F03A6172C4BD718B43625DFFFA43EE1539FF9576D66B8E8417E94.zip?needInitFileName=true" target="_blank" rel="noopener">Library</a> 文件，文件内包含对应的桌面宫格和详细尺寸描述。</p><p>标准设计尺寸如下（单位：vp）：</p><p>无法复制加载中的内容</p><p>因设备差异可能导致的尺寸变形如下（单位：vp）：</p><p>无法复制加载中的内容</p><h4 id="通用布局模板"><a href="#通用布局模板" class="headerlink" title="通用布局模板"></a>通用布局模板</h4><p>在IDE工具中针对手机、折叠屏和平板的业务场景给出若干<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ide_service_widget-0000001078566997" target="_blank" rel="noopener">通用模板布局</a>，开发者可以参考设计。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTkxNjljZDBmNDA2MDgxYTRmNGI0NmRkZWRjN2Y4ZGRfT2FGaWJJVG0zZDh1ZG9NYXd0M3Z3VnJQN0tUcVVTUGZfVG9rZW46Ym94Y24xMkVEeEl0VGk0MHdTNjFMd3NGVXhjXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h3 id="其他设备卡片规范"><a href="#其他设备卡片规范" class="headerlink" title="其他设备卡片规范"></a>其他设备卡片规范</h3><h4 id="智慧屏"><a href="#智慧屏" class="headerlink" title="智慧屏"></a>智慧屏</h4><h5 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h5><ul><li><p>智慧屏操作系统主要通过遥控器进行交互，因此在卡片设计上要避免交互行为的冲突，以整张卡片为焦点内容进行操作。</p></li><li><p>在卡片内不要进行热区划分，也不要对卡片进行过多功能的定义，智慧屏服务卡片仅作为信息数据外露的展示和服务界面的入口。</p></li><li><p>遥控器“上下左右”键：切换不同的富信息卡片。</p></li><li><p>遥控器 “OK” 键：点击后进入对应的服务卡片内容。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2JlMTNjM2I2NmIzYjNhZjcxZDExNTIwNWYwZTJmOGNfelhDbmJ4QXpaanJWc0l2VGIwdmNjZTFLUVpETUVPU0dfVG9rZW46Ym94Y25oT2xEZ21WbWFKeDFoR3BYN1BnYjRnXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="基础参数定义"><a href="#基础参数定义" class="headerlink" title="基础参数定义"></a>基础参数定义</h5><p><strong>尺寸分类</strong></p><p>无法复制加载中的内容</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2EzZDhhNjEzMDI0YjZlMTgyMWY1YzRkYTNlZjI1Y2JfUDlrTlpsTENJMXZ0T0cwcEhNZTFPeXhTdTIxRTFJRjRfVG9rZW46Ym94Y25oUTJGcVp2QWR2VDlhREdVZDQ0NmliXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="卡片构成及注意事项"><a href="#卡片构成及注意事项" class="headerlink" title="卡片构成及注意事项"></a>卡片构成及注意事项</h5><p>智慧屏的卡片主要由文本信息和内容区组成，内容区主要展示卡片数据，文本信息则为辅助展示。卡片内主要展示图文信息为主，由于交互特殊性，不要再卡片内设计按钮、可滑动列表、开关等操作指令。具体的视觉参照智慧屏的通用设计规范，斟酌对文字尺寸和颜色的使用，并保留固定的安全间距。注意事项不要使用带有透明度的背景色，会使卡片再获焦状态下看起来非常怪异。由于卡片宿主会展示对应的来源应用名称，因此不要在卡片内重复出现应用图标和应用名称。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJlOGMxOWMzMzM5Y2RjYzBiYWZmZmVjMTFhZWZkNjVfRG5yOGg2NkQ3eHc2M0hLN05hMEpIZ0ZHNlJmMVFMcDlfVG9rZW46Ym94Y25kVTNBN0xoU3JTazdDa3p2bmF5OWRiXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="字体-1"><a href="#字体-1" class="headerlink" title="字体"></a>字体</h5><p>智慧屏作为远场交互设备，通用字体与手机版本基本保持一致，使用系统默认字体。</p><p>但在最小字体的使用上略有区别，智慧屏服务卡片的最小文本为 12fp，避免在远场文本的易阅读性。</p><p>无法复制加载中的内容</p><h5 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h5><p>在 IDE 工具中针对智慧屏的业务场景给出了若干<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ide_service_widget-0000001078566997" target="_blank" rel="noopener">通用模板布局</a>，设计师可参考设计。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzdjMThhNzRmODJmNDMwMzFjOGVhOTg1MzI1MTk5ZDVfWGh1YUpCeHljSlhqRjJRZ0xYbXY1b09Va25xTndPSkdfVG9rZW46Ym94Y25qbWwzYnpoRjZBbUFVTDAzVElUR3BkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="穿戴卡片规范"><a href="#穿戴卡片规范" class="headerlink" title="穿戴卡片规范"></a>穿戴卡片规范</h4><h5 id="基本定义-1"><a href="#基本定义-1" class="headerlink" title="基本定义"></a>基本定义</h5><ul><li><p>穿戴设备的服务卡片与 Launcher 保持平级架构，通过左右滑动表盘来切换不同的服务内容。</p></li><li><p>向右滑倒最后一张卡片时，用户可点击按钮进入全部服务卡片界面，选择自己心仪的服务内容。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTU1NmNkNGYyMDliODM3NGE5NDM1MDIxN2UzZmE4MjBfdXVLbWN3OWJsTzFDMjFyVjBYUlhsYVFlSFNTQmQ3cHlfVG9rZW46Ym94Y25IeUhqNm5xdHdVOGs5ZTMxSXI2aHZjXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="交互规则"><a href="#交互规则" class="headerlink" title="交互规则"></a>交互规则</h5><p>服务卡片不支持上下滑动切换更多，因此在设计时因可能控制信息内容在一屏。服务内容需要明确引导用户，每一级非空界面需要通过标题明确告知用户当前所处的应用或层级。卡片内支持多热区操作，考虑设备使用场景，不要在表盘内设计复杂的功能布局，基础规则可参照穿戴设计规范。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjBjMmQ4NDhjMDUyNjJjZDM2Njk0NDRmYjNjODIxNGVfdTdwbDNvbDR0eTE2TkZPc0JFZXBwSmlEUWFuTmxVNWtfVG9rZW46Ym94Y25rZ2pzSlZTOHFGUTFlbmx4dmJXOVhmXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="基础参数定义-1"><a href="#基础参数定义-1" class="headerlink" title="基础参数定义"></a>基础参数定义</h5><p>穿戴设备由于硬件屏幕的限制，呈现界面为圆形，因此在开发服务卡片时应当考虑这一特殊因素，将主要信息内容集中在圆形尺寸内，防止卡片内容被裁剪。</p><p><strong>尺寸分类</strong></p><p>无法复制加载中的内容</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWYxYjMwOTM1MGY0MGI0NjQxYjkyMWFjNThmZTc1YmFfT3ZlRk8xOEdCRXVmUXBLVEVEcklWSkkxV3g4V3B1eG5fVG9rZW46Ym94Y25RWDNwQ0RQQ2ZKdTdEcW8zTFBaNE1oXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODE4NTQ1Zjc2NGFiYWY2ZjEyZGYzYzg3M2E1MzE0ZDhfVzJjVWdnNmVUalR1QU9XQU1VNE1LdUlrZlpYclJTcEhfVG9rZW46Ym94Y25sRnpMRWU4aU04dk5meWJsOUNaYkRmXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="字体-2"><a href="#字体-2" class="headerlink" title="字体"></a>字体</h5><p>通用文本请使用系统默认字体。</p><p>根据不同的场景使用相应的字号，重要信息文本优先使用18fp以上的字号，确保信息的易读性</p><p>无法复制加载中的内容</p><h5 id="通用模板-1"><a href="#通用模板-1" class="headerlink" title="通用模板"></a>通用模板</h5><p>在IDE工具中针对穿戴的业务场景给出了若干<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/ide_service_widget-0000001078566997" target="_blank" rel="noopener">通用模板布局</a>，开发者可参考设计。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTNiYWFiMmUyMjZhYzcwNjhlZWQyYTk5OTRhZTFjZThfSWswdG9jZk9kclBWc0xvYjJ3SmZTTnRDSmE5czhlQktfVG9rZW46Ym94Y25PQklBdHhCbnFhUFkxYUFYTVpzWFRkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h3 id="设计自检表-1"><a href="#设计自检表-1" class="headerlink" title="设计自检表"></a>设计自检表</h3><p>设计自检表详细列举出了在全场景设备设计和开发过程中应当注意的设计规则，提交审核前请再次检查各项是否符合规则要求，这将帮助服务减少用户舆情且提升用户体验的一致性。 自检表的要求范围分为“必选”与“推荐”两类。必选类一般为已总结出的较优解决方案或效果，表示相关设计需要按照此原则统一执行；推荐类指可能受服务品牌风格或业务特殊性影响，可适量做出修改。 请参考以下表格范围内提出的要求对服务进行检查。</p><p>无法复制加载中的内容</p><h2 id="服务流转-1"><a href="#服务流转-1" class="headerlink" title="服务流转"></a>服务流转</h2><h3 id="流转概述"><a href="#流转概述" class="headerlink" title="流转概述"></a>流转概述</h3><p>服务流转是 HarmonyOS 的分布式操作方式。流转能力打破设备界限，多设备联动，使原子化服务可分可合、可流转，实现如邮件跨设备编辑、多设备协同健身、多屏游戏等分布式业务。</p><p>开发者通过嵌入流转图标，可以便捷地将服务流转到不同 HarmonyOS 设备，包括但不限于智慧屏、平板、手表、音箱等设备，也可灵活地切换和管理流转任务。流转实现多设备的协同联动，为开发者提供更广的使用场景和更新的产品视角，强化产品优势，实现体验升级，打造 HarmonyOS 超级终端服务体验。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmZjMjRjMmJhZTA0NmQ2OGNlZTEwNzNiMmM4NGQxMzVfMTY1UmNOUktqM1pXZmlmdWtMQUZnMTVOVnBoZTlqMGlfVG9rZW46Ym94Y25GbDhJY3BoT3p5VXE5eUF0TlRXVko4XzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>开发者可以将流转功能融入到产品的设计中，打造有竞争力的分布式场景。例如：</p><ol><li>当用户在玩游戏时，手机作为手柄与智慧屏配合玩游戏。</li><li>当用户使用教育类课程服务时，智慧屏可以播放老师的授课视频，用户可以在平板上进行答题和老师互动。</li><li>当用户在直播购物时，智慧屏上可以播放主播的商品讲解，同时用户可以在手机上同步查看商品详情并进行下单。</li><li>当用户在会议室进行项目汇报时，通过智慧屏展示文档的同时，可以利用手机进行文档翻页和批注。</li></ol><h4 id="通用流程"><a href="#通用流程" class="headerlink" title="通用流程"></a>通用流程</h4><p>流转的流程包括流转触发、流转连接和流转结束三个阶段。在每个阶段用户都会接触到不同的控件以推动流程的进行。</p><p><strong>流转到我的设备</strong></p><p>HarmonyOS 致力于打造无缝的超级终端体验。服务在已授权设备之间流转，无需鉴权，一键直达。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjU2MTcyMWRjZTQ2MjZjMjkyOWRlOWQ5Nzg1ODRiY2JfQ0VSUnNwY3JtN2xDekJpQmN6UEJTZ3E2SkIzUENQYlNfVG9rZW46Ym94Y25WM2g5VWl0WWk4b1pUbTJlQ2lCOWJnXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p><strong>流转到更多设备</strong></p><p>为提供更广泛的使用场景和更便利的使用体验，HarmonyOS 也同样支持将服务流转到其他未授权设备上。流转到其他设备需要对端设备确认后方可流转。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWEwNzAwYmM1ODczNTAxNGVlNjAxN2VlNzY1YjFjMmFfSHpTSjhXd0E3S2FIcG5iZXFVeTdXcWNJQ2xiMmVCNkpfVG9rZW46Ym94Y242UDNhN2JxNERrVElQT2YwdWhFTjJ2XzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h3 id="流转流程"><a href="#流转流程" class="headerlink" title="流转流程"></a>流转流程</h3><h4 id="流转触发"><a href="#流转触发" class="headerlink" title="流转触发"></a>流转触发</h4><p>根据触发方式的不同可分为系统推荐流转和用户手动流转。</p><h5 id="系统推荐流转"><a href="#系统推荐流转" class="headerlink" title="系统推荐流转"></a>系统推荐流转</h5><p>当用户使用原子化服务时，所处环境中存在更优的可信设备，系统则自动为用户推荐设备，用户可确认是否启动流转，使服务智能无缝地流转到对应设备上运行。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2U3ZTM5MzllYWY0OWEzNzViZTU3NWYwZTNhYjUzY2ZfRWJzOURpTXBJbDcwTlZ5cE1UclVyNmp5Z0NHYzA1TDZfVG9rZW46Ym94Y25LRDQ2a0M2WFRvb2gxWXA4ZFNwdU5iXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>例如当用户使用手机进行导航时，同时系统监测到用户正在佩戴智能表，为了提供更便捷的导航体验，系统会推荐用户将导航任务流转到智能表上进行。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmYxMWVmNGE4ZmIxMjJmZGM0YTBhM2IzNjJmZDMwODRfMnRGSVVmNkZGaFJWbmc3bkZJd0RFaTVGYzFtWG9KNk5fVG9rZW46Ym94Y25uSElWMGVwWU5WeGw2eU1LaHVlVXBlXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="用户手动流转"><a href="#用户手动流转" class="headerlink" title="用户手动流转"></a>用户手动流转</h5><p>开发者也可在原子化服务中内嵌<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/service-hop-icon-0000001136140831" target="_blank" rel="noopener">规范的流转图标</a>，使用户可以手动选择合适的设备进行流转。用户点击图标后，会调起系统提供的流转面板。面板中会展示出原子化服务的信息及可流转的设备，引导用户进行后续的连接操作。</p><h4 id="流转连接"><a href="#流转连接" class="headerlink" title="流转连接"></a>流转连接</h4><h5 id="流转到我的设备"><a href="#流转到我的设备" class="headerlink" title="流转到我的设备"></a>流转到我的设备</h5><p>HarmonyOS 致力于打造无缝流畅的流转体验。用户可以通过推荐气泡或者流转图标发起在我的设备（指已授权的 HarmonyOS 设备）间的服务流转。</p><h6 id="推荐气泡发起"><a href="#推荐气泡发起" class="headerlink" title="推荐气泡发起"></a>推荐气泡发起</h6><p>当检测到用户周围有更优的可流转设备（指已授权的 HarmonyOS 设备），屏幕上即会出现推荐气泡，用户点击推荐气泡完成服务的一键流转。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmFkMTVmYjFjNWIyNzM4MjUzNDRhMGYyMTQ0OTc2MjhfQXh3UHhQVFVrVmF6emx3MWhNQkJ3cHlSaVAyOXNLU1RfVG9rZW46Ym94Y25SY056VDYxcmdzdkl1QW9wNlRVemJkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h6 id="流转图标发起"><a href="#流转图标发起" class="headerlink" title="流转图标发起"></a>流转图标发起</h6><p>用户也可自行点击服务内的流转图标，调起流转面板选择要流转的设备进行流转。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjE3YTAwNzBkYTIxNWQ4M2QxNWVjNzE3NWJhNGY2NzJfOGt2MnhxcEUwYUFWb09MWklKMDFKVkMyUDZoVEkzazdfVG9rZW46Ym94Y25ONFM4UW1rUUU3S1lObUdvcVVqNGhlXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="流转到更多设备"><a href="#流转到更多设备" class="headerlink" title="流转到更多设备"></a>流转到更多设备</h5><p>当用户需要将服务流转到其他未授权设备时，可以通过点击流转图标调出系统提供的流转面板来实现。用户选择要流转的非授权设备，对方设备上首先会显示一张介绍卡片来告知被流转的服务信息。当对方同意后，对方设备屏幕上会显示出多功能码，通过扫描以完成设备认证和服务流转。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDRlNTgyZDYwMDllNmUwNjMxZTYzYzc1MGQwNjY3MjhfT01tZ0UwZHVMRG9QYUdHTTBjSWVpZmlubm9UWXlxclBfVG9rZW46Ym94Y251NjlHMDlPbm1LUGFVRjFoQnRBTG1mXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="流转结束"><a href="#流转结束" class="headerlink" title="流转结束"></a>流转结束</h4><p>对于协同类的服务场景，在流转连接完成后，还需要支持服务后续的管理。开发者需要在服务页中内嵌正在流转状态的流转图标，使用户享受顺畅的全流程体验。</p><p>当用户需要结束流转任务时，除了直接关闭服务的方式外，也可以通过再次调出流转面板来完成。用户点击图标调出流转面板，点击“结束流转”按钮或者再次点击正在流转的设备以结束流转任务。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODk4ZWVjNmMwYjU1N2IzYWUyMzY0ZWYwNmU0YWY3ZjFfYzNjVlNPaXZ1a1lTZUlvdDNrMDNWa0draUJNOW9tNnZfVG9rZW46Ym94Y25HV2x6c0FnakM5RzZscGZ1OGtpZkFGXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h3 id="服务流转图标"><a href="#服务流转图标" class="headerlink" title="服务流转图标"></a>服务流转图标</h3><p>为了保证在不同服务内流转体验的一致性，请使用 HarmonyOS 的流转图标。请不要创造流转图标样式，也不要绘制模仿流转图标。</p><p><a href="https://developer.harmonyos.com/cn/docs/design/des-resources/general-0000001157315901" target="_blank" rel="noopener">下载流转图标</a></p><h4 id="图标颜色"><a href="#图标颜色" class="headerlink" title="图标颜色"></a>图标颜色</h4><p>我们为您提供了多种图标颜色以适应不同的界面背景。</p><p>无法复制加载中的内容</p><h4 id="尺寸大小"><a href="#尺寸大小" class="headerlink" title="尺寸大小"></a>尺寸大小</h4><p>流转图标为矩形图标，尺寸上请保持与其他业务图标等大，并与其保持安全距离。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTI0ZTlhM2E3OWMxMDM4NGY5YTliMmRmNTYyZTM2YWJfbFJoZEU1c0poa29qVTduZHdtSEt0RkhkZTlkUENTVm5fVG9rZW46Ym94Y25EaVQxMDlCUW1oUE8wdmdiRHpPdWZkXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="交互状态"><a href="#交互状态" class="headerlink" title="交互状态"></a>交互状态</h4><p>服务未转时使用默认状态图标，服务正在流转时使用静态或动态蓝色高亮图标。点击流转图标后，会拉起流转面板进行<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/service-hop-process-trigger-0000001137622057" target="_blank" rel="noopener">服务发起和结束</a>。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzBjZDkyZDBiOTE3M2VhYjU4MGQyMGY5NjRiNGNjM2Nfd3IxeDhncUM3WllFWXZReXAya25WWHg2bVFwcGFaSEFfVG9rZW46Ym94Y25VUnM3UHVKeVZOaTRNQm92dzZLNjliXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="图标位置"><a href="#图标位置" class="headerlink" title="图标位置"></a>图标位置</h4><p>根据业务特性及体验继承综合考量，您可将流转图标置于一级界面或二级界面的特定位置中。</p><h5 id="一级界面"><a href="#一级界面" class="headerlink" title="一级界面"></a>一级界面</h5><p>一级界面中可将流转图标置于界面右上角或者底部工具栏。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTg4MzdhZGNkZDlhNGU4NzUzZDk1MGY4OTQ5NjRiOGRfRTNJRTY2Y1d5TUV5TTNuUjRoc3Bzb0ZpSHRoZ1FwVmRfVG9rZW46Ym94Y25ZQVA0QlpPbkJJNlhUUG5XTUxvNXRQXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>请参考一级界面示范样式，不要将图标放在一级界面内非右上角及底部工具栏位置。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTAyMTgwZjNmNjdiNWUzZGNhMjIzMDc2MDY4MmFlM2VfQTNkeTNhYUZCSXg2NkRuc1VZcnQ3VXZsOGtHeXBlUm5fVG9rZW46Ym94Y240OTYyT3V5UFFpbG5BbGVzUzBRSTZnXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h5 id="二级界面"><a href="#二级界面" class="headerlink" title="二级界面"></a>二级界面</h5><p>二级界面中可将流转图标置于由“更多”或“分享”入口拉起的菜单弹出框或者底部弹框。当“更多”及“分享”入口同时存在时，优先选择“分享”入口。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDNlMDk4Yjk2Y2ZhNTM2MWZhMGEwOWM3OGY0MzkxZTdfN1FZbGN4SFZMY2lZdUtKenBuS0tCTU1CWTN5a3lFODlfVG9rZW46Ym94Y25kRVhaVDQ0R1I2SVAxNWY0bVVrUW1jXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p>请参考二级界面示范样式，不要将图标置于三级界面以上及不相关入口内。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjhhOGRjYmJhMTMyMmRkNTBjYTQwNTc1M2E3YTAyYTJfSm0xbkhuWUFTTXc4djNDOHI1T1JHQUY3N0xMV1JmWDNfVG9rZW46Ym94Y25Ka01LWDZIcHBsQVJRNVlHT3J0cHdnXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h4 id="长视频类服务"><a href="#长视频类服务" class="headerlink" title="长视频类服务"></a>长视频类服务</h4><p>针对于已有跨设备业务的长视频类服务，为保证界面精简与认知一致，可以考虑将流转图标与原有业务图标进行融合。例如长视频服务具有投屏业务图标，点击图标后在选择设备的界面中可嵌入流转图标。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzg1ODJjMDhkOTU4ZjAzOWJmYTMwNDliYWE2MGRiZDRfNHVLczZ6QTllTHNqSzZNSlBhVE5HYnhkdWxQSlBPb21fVG9rZW46Ym94Y25ESERJUTNPNk9UYUQ4RE05UXZXN0dnXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjA2ZmI3NWNiMDc2ZjBkNWViNWQ0ZTQxNTI2ODk5OTNfSWlic0puUWRIbTdrZGF3OUF2MGRsSGV6U01pVTlUUlhfVG9rZW46Ym94Y25hbjd4azdJTVdmWDRkTjZWWmdqamZiXzE2MjcxNDcwMTQ6MTYyNzE1MDYxNF9WNA" alt="img"></p><h3 id="设计自检表-2"><a href="#设计自检表-2" class="headerlink" title="设计自检表"></a>设计自检表</h3><p>设计自检表详细列举出了在全场景设备设计和开发过程中应当注意的设计规则，提交审核前请再次检查各项是否符合规则要求，这将帮助服务减少用户舆情且提升用户体验的一致性。 自检表的要求范围分为“必选”与“推荐”两类。必选类一般为已总结出的较优解决方案或效果，表示相关设计需要按照此原则统一执行；推荐类指可能受服务品牌风格或业务特殊性影响，可适量做出修改。 请参考以下表格范围内提出的要求对服务进行检查。</p><p>无法复制加载中的内容</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Harmony </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Harmony </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HarmonyOS设计：设计基础</title>
      <link href="/posts/dd26.html"/>
      <url>/posts/dd26.html</url>
      
        <content type="html"><![CDATA[<h1 id="通用设计基础"><a href="#通用设计基础" class="headerlink" title="通用设计基础"></a>通用设计基础</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HarmonyOS 是一款面向全场景智慧生活方式的分布式操作系统。在传统的单设备系统能力的基础上，HarmonyOS 提出了基于同一套系统能力、适配多种终端形态的分布式理念，能够支持手机、平板、PC、智慧屏、智能穿戴、智能音箱、车机、耳机、AR/VR眼镜等多种终端设备。</p><p>对消费者而言，HarmonyOS 能够将生活场景中的各类终端进行能力整合，形成“One Super Device”，实现不同终端设备之间的极速连接、能力互助、资源共享，匹配合适的设备、提供流畅的全场景体验。</p><p>当为多种不同的设备开发应用时，需要从如下三个方面来考虑UX设计：</p><p><strong>差异性</strong></p><p>充分了解所要支持的设备，包括屏幕尺寸、交互方式、使用场景、用户人群等，对设备的特性进行针对性的设计。具体设计方法详见设备设计指南，如<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/principle-0000001052167857" target="_blank" rel="noopener">智慧屏设计指南</a>、<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/design-principles-0000001052899763" target="_blank" rel="noopener">智能穿戴设计指南</a>。</p><p><strong>一致性</strong></p><p>除了要考虑每个设备的特性外，还需要考虑不同设备的共性，并使用通用性设计方法提供既符合设备差异性，又具有跨设备一致性的设计，从而减少用户学习的难度，降低应用开发的成本。具体内容详见本设计指南的后续章节。</p><p><strong>协同性</strong></p><p>当考虑多个设备之间的相互协同时，需要了解设备与设备之间多种可能的协同模式，最大程度地展现 HarmonyOS 上独特的多设备无缝流转体验。具体设计方法详见<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/principles-0000001054445996" target="_blank" rel="noopener">分布式设计指南</a>。</p><p>在为 HarmonyOS 的多种设备进行通用性设计和开发时，可以从如下方面进行考虑：</p><ul><li><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/design-philosophy-0000001108049898" target="_blank" rel="noopener">设计理念</a>：了解 HarmonyOS 设计系统的核心理念，确保在多设备上的一致体验。</p></li><li><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/human-factors-0000001154595111" target="_blank" rel="noopener">人因研究</a>：了解人因研究如何为UX设计提供系统性的科学指导。</p></li><li><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/app-navigation-0000001054723026" target="_blank" rel="noopener">应用架构</a>：了解常用的应用架构，并在应用设计中进行实践。</p></li><li><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/hci-overview-0000001054726474" target="_blank" rel="noopener">人机交互</a>：了解多种不同的人机交互方式，以及每种交互方式设计中的注意事项。</p></li><li><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/basic-0000001055539104" target="_blank" rel="noopener">视觉风格</a>：了解基础概念、色彩、字体、图标、插画、布局等关键视觉设计的概念和规则。</p></li><li><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/overview-0000001158153643" target="_blank" rel="noopener">动效</a>：了解时长、曲线、帧率等动效基础要素，以及特征、转场、手势动效的设计方法和微动效、插画动效的设计指导。</p></li><li><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/overview-0000001111593834" target="_blank" rel="noopener">声音</a>：了解声音的设计属性以及音色、音响、频段、动态响应等关键声音元素在差异设备间的设计方法</p></li><li><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/components-0000001157881613" target="_blank" rel="noopener">多态控件</a>：了解不同设备下多态控件的特点，以及控件的不同显示状态，确保应用正确使用控件。</p></li><li><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/ui-language-0000001053966009" target="_blank" rel="noopener">界面用语</a>：了解如何确保用语风格统一、清晰明了、流畅自然，给用户带来良好的阅读体验。</p></li><li><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/overview-0000001053574132" target="_blank" rel="noopener">全球化</a>：了解如何提供通用方案满足不同国家的常规需求，以及如何提供个性化方案满足某些国家的特殊需求。</p></li><li><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/accessibilitysummarize-0000001154076955" target="_blank" rel="noopener">无障碍</a>：了解如何让视障用户正常使用智能设备，获得良好的信息无障碍体验，包括色彩、对比度和屏幕朗读器等。</p></li><li><p><a href="https://developer.harmonyos.com/cn/docs/design/des-guides/introduction-0000001077467612" target="_blank" rel="noopener">隐私设计</a>：了解如何保护用户的隐私，并让用户自主管控自己的信息，做到清晰可知，方便可控。</p></li></ul><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><p>在万物互联的时代，我们每天都会接触到很多不同形态的设备，每种设备在特定的场景下能够为我们解决一些特定的问题，表面看起来我们能够做到的事情更多了，但每种设备在使用时都是孤立的，提供的服务也都局限于特定的设备，我们的生活并没有变得更好更便捷，反而变得非常复杂。HarmonyOS 的诞生旨在解决这些问题，在纷繁复杂的世界中回归本源，建立平衡，连接万物。</p><p>混沌初开，一生二、二生三、三生万物，我们希望通过 HarmonyOS 为用户打造一个和谐的数字世界——One Harmonious Universe。</p><h3 id="One"><a href="#One" class="headerlink" title="One"></a>One</h3><p>万物归一，回归本源。我们强调以人为本的设计，通过严谨的实验探究体验背后的人因，并将其结论融入到我们的设计当中。</p><p>HarmonyOS 系统的表现应该符合人的本质需求。结合充分的人因研究，为保障全场景多设备的舒适体验，在整个系统中，各种大小的文字都清晰易读，图标精确而清晰、色彩舒适而协调、动效流畅而生动。同时，界面元素层次清晰，能巧妙地突出界面的重要内容，并能传达元素可交互的感觉。另外，系统的表现应该是直觉的，用户在使用过程中无需思考。因此系统的操作需要符合人的本能，并且使用智能化的技术能力主动适应用户的习惯。</p><h3 id="Harmonious"><a href="#Harmonious" class="headerlink" title="Harmonious"></a>Harmonious</h3><p>一生为二，平衡共生。万物皆有两面，虚与实、阴与阳、正与反… 二者有所不同却可以很好地融合，达至平衡。</p><p>在 HarmonyOS 中，我们希望给用户带来和谐的视觉体验。我们在物理世界中找到在数字世界中的映射，通过光影、材质等设计转化到界面设计中，给用户带来高品质的视觉享受。同时，物理世界中的体验记忆转化到虚拟世界中，熟悉的印象有助于帮助用户快速理解界面元素并完成相应的操作。</p><h3 id="Universe"><a href="#Universe" class="headerlink" title="Universe"></a>Universe</h3><p>三生万物，演化自如。HarmonyOS 是面向多设备体验的操作系统，因此，给用户提供舒适便捷的多设备操作体验是 HarmonyOS 区别于其他操作系统的核心要点。</p><p>一方面，界面设计/组件设计需要拥有良好的自适应能力，可快速进行不同尺寸屏幕的开发。</p><p>另一方面，我们希望多设备的体验能在一致性与差异性中取得良好的平衡。</p><p>● 一致性：界面中的元素设计以及交互方式尽量保持一致，以便减少用户的学习成本。</p><p>● 差异性：不同类型的设备在设屏幕尺寸、交互方式、使用场景、用户人群等方面都会存在一定的差异性，为了给用户提供合适的操作体验，我们需要针对不同类型的设备进行差异化的设计。</p><p>同时，HarmonyOS 作为面向全球用户的操作系统，为了让更多的用户享受便利的科技与愉悦的体验，我们将在数字健康、全球化、无障碍等方面进行积极的探索与思考。</p><h2 id="人因研究"><a href="#人因研究" class="headerlink" title="人因研究"></a>人因研究</h2><p>人因学是研究人与系统其它要素之间交互的学科，也是一门应用相关理论、原则、数据和方法进行研究应用，以实现人的健康和整个系统效能最优化的学科。（国际人因工效学学会，International Ergonomics Association，IEA 2009）</p><p>在 HarmonyOS 中，我们通过大量的人因研究为UX设计提供了系统性的科学指导。</p><p><strong>常用关键词：</strong></p><ul><li><p>Human Factors，Ergonomics，Engineering Psychology</p></li><li><p>人因学、人类工效学、工程心理学</p></li></ul><h3 id="人因学的研究领域"><a href="#人因学的研究领域" class="headerlink" title="人因学的研究领域"></a>人因学的研究领域</h3><p>主要有以下三个研究领域：</p><p><strong>物理人因学（Physical Ergonomics）</strong></p><p>考察与人体物理运动相关的人体解剖学、人体测量学、生理学、生物力学等特征。主要运用于操作姿势、材料搬运、重复性动作、操作性损伤、工作空间设计、安全和健康等领域。</p><p><strong>认知人因学（Cognitive Ergonomics）</strong></p><p>考察人与系统中其他因素交互中的心理加工，例如感知觉、记忆、学习、推理等特征。主要运用于认知负荷、决策、经验形成、人机交互、人的可靠性、工作压力和技能培训等领域。</p><p><strong>组织人因学（Organization Ergonomics）</strong></p><p>考察社会技术系统的优化问题，包括组织结构、政策规定和管理流程。主要运用于沟通交流、人员管理、工作设计、工作团队、社区工效、团队协作、虚拟团队工作等领域。</p><h3 id="人因学的发展趋势"><a href="#人因学的发展趋势" class="headerlink" title="人因学的发展趋势"></a>人因学的发展趋势</h3><p>人因学起源于19世纪末期，人类从最初的实践经验中总结规律，学习如何适应机器，逐步发展到现阶段，运用先进成熟的技术科学地度量人-机-环境中的问题，达到人与机器相互适应的和谐发展局面。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWUzYjA5ZWYzNDRlMWZhY2M5NmQ1YjdiMzYzYzRmMTJfRVJ0VmpnczUxSjFmQUUxSkxralRROVZCeDZrQkhIQ0pfVG9rZW46Ym94Y25rQTZ4TXRqOGdieE91aWZaZW5iQU1pXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>注：图片素材引用自Flaticon.com</p><h3 id="UX人因研究框架"><a href="#UX人因研究框架" class="headerlink" title="UX人因研究框架"></a>UX人因研究框架</h3><p>人因研究通常会从使用者、设备、使用环境三要素对设计问题进行剖析，并开展相应的人因实验，促使设计更新迭代，达到相应的用户体验目标。</p><ul><li><p>使用者：考虑使用者的基本人口统计特征（年龄、职业等），使用不同设备时的姿态与视角，使用设备时对认知资源的占用情况等。</p></li><li><p>设备：考虑设备尺寸，设备显示能力（分辨率、显示色域等），交互方式（触摸、语音等），交互时长等。</p></li><li><p>环境：考虑设备所处的物理环境（环境光、环境音、使用距离等），社会环境（私人或公共设备）等。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmMyMjM4MDg5Yzk0MDljZjhkYjBhOGU4YWQxM2QxNTJfY0hNS1F1RTBtU3J0cjBqZnpRdzF0N09IRnFKclo3c0FfVG9rZW46Ym94Y24ydGN5M0tNVzI4aGE3aXFNaDR1OE9lXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h3 id="UX人因研究已有成果"><a href="#UX人因研究已有成果" class="headerlink" title="UX人因研究已有成果"></a>UX人因研究已有成果</h3><p>已有的UX人因研究主要是从基础UX和HarmonyOS UX两个领域开展的，下文将选取典型案例进行阐述。</p><p><strong>基础UX人因研究</strong></p><p>已有研究主要从GUI体验、流畅体验、交互体验、多感官体验等领域开展。以GUI体验为例，主要是为了在多设备上实现清晰易读、舒适可读、简洁美观的体验目标。</p><p><strong>HarmonyOS UX人因研究</strong></p><p>已有研究主要从全场景UX人因和多设备UX人因等领域开展，其中多设备UX人因研究覆盖设备：手机、折叠屏、平板、PC、智慧屏、智能穿戴、耳机、VR&amp;AR等。</p><p>后文将以“GUI体验研究”为例，阐述人因研究的研究方法与部分研究成果。</p><p><strong>研究方法</strong></p><ul><li><p>在GUI领域的研究中，首先需要考虑不同设备上，用户的使用距离和视野范围，如下图所示。</p></li><li><p>进一步，开展人因实验，通过主观体验、行为绩效、生理数据的综合分析，得到相关结果。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjk0ZDIyMTdhNjk3Y2E1ZDZhOTE0OWZmODc3NGI1YTdfWUZhNndxMndpRzlCczNTbGY2S1hxek84NzJoZ1J2YkZfVG9rZW46Ym94Y25PcnF3eHRCUkM5b1Rwc2ZBVTdKVkNiXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p><strong>研究成果示例</strong></p><p>示例1：为了满足不同环境光中，页面视觉设计的易读舒适性，通过人因实验进行对比度水平建模，得到下图中展示的结果，并应用于“深色模式”的设计。更多针对色彩的设计，详见<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/color-0000001111857246" target="_blank" rel="noopener">色彩</a>。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTQ5MjkyYmFiODNmNWI5ZWQ3ZTQ0MjY2Mzk3YWFlMjdfSDhSRHdaVWNhdGFGRnhCamp1TjlTa3Q3QXBuRjRiNjFfVG9rZW46Ym94Y25rR01SQ240TzA2UGFia1NjY2h3bmRnXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>示例2：为了保证智慧屏在一般室内光/暗光环境中，页面上的文字都能清晰易读，通过人因实验给出如下字号设计建议。针对多设备字号的设计，详见<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/font-0000001157868583" target="_blank" rel="noopener">字体</a>。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjcxZDk3MTI5ZGFkNmFkNjM3NjcyMjIwOWZiNDc2YjRfNVdEbnI5UGFGQTdGNW1TU21YOVNIU1labExQTDJoQ3NfVG9rZW46Ym94Y25TV0l2M3hzRlRDaW5PSjNad3I3eFhjXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h2 id="应用中的导航结构"><a href="#应用中的导航结构" class="headerlink" title="应用中的导航结构"></a>应用中的导航结构</h2><p>应用中的导航用于引导用户在应用的各个页面进行浏览。好的导航让用户知道身处何处，去往何方，以及来自哪里。</p><h3 id="导航的原则"><a href="#导航的原则" class="headerlink" title="导航的原则"></a>导航的原则</h3><p>导航需要遵循以下原则：</p><ul><li><p>一致。导航操作的结果应该与用户的期望保持一致。相同或类似的场景使用用户熟悉的界面布局和控件，确保一致的导航行为，让用户无论在什么页面，都知道如何导航。例如二级界面使用左上角的返回按钮来返回界面的上一个层级。</p></li><li><p>清晰。导航应该提供清晰的路径。用户使用的时候，逻辑关系简单且容易理解，能够知道当前处在界面的什么位置，操作后将会跳转到什么位置，不会迷失方向。例如使用底部页签，让用户在平级页面之间进行切换。</p></li></ul><p>导航要避免以下设计：</p><ul><li><p>层级过深：导航层级建议在三层以内。对于太深的层次，会带来操作效率的问题。如果确实需要深层级设计，建议使用面包屑设计或增加一键回到首页的功能。</p></li><li><p>导航复杂：在侧边导航中，使用底部页签，会让操作变得复杂，建议仅使用侧边导航。</p></li></ul><h3 id="导航的分类"><a href="#导航的分类" class="headerlink" title="导航的分类"></a>导航的分类</h3><p>常用的应用导航有：</p><ul><li><p>平级导航</p></li><li><p>层级导航</p></li><li><p>混合导航</p></li></ul><h4 id="平级导航"><a href="#平级导航" class="headerlink" title="平级导航"></a>平级导航</h4><p>平级导航结构中，页面均处在同一层级。</p><p>使用场景：用于展示同等地位或同等层级的界面。例如以TAB方式组成的页面。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmM2NmRkNGY5YTNjYTdiYTE1NGRjNjc4ODFmYmY1YzhfMkg0aGZ0TmFCd0FVNGdoZGJvdVdybDd2VEo1Qm5uMzBfVG9rZW46Ym94Y25OZXZ3ak1Vd3cwUHpFTHA3V2ZXTGRlXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h4 id="层级导航"><a href="#层级导航" class="headerlink" title="层级导航"></a>层级导航</h4><p>层级导航结构由父页面和子页面组成。父页面可以有一个或多个子页面。每个子页面都有一个父页面。</p><p>层级导航适用于多层级的复杂结构。层级结构深的内容，用户访问的路径变长，效率降低，可以通过适当的层级穿透设计（如快捷方式）解决此问题。</p><p>使用场景：页面存在上下级关系的应用。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTE5YjU0ZTQwOGE3ZWE0M2JmOTAzZTRlNmFkZTg3NGJfN2R6SEk4MXNNNnpHZGVVUmhJWWhRc09KVWVGSkZkdFVfVG9rZW46Ym94Y25VRFBLWE00bDRhNVhpdXNjazlVNnZiXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h4 id="混合导航"><a href="#混合导航" class="headerlink" title="混合导航"></a>混合导航</h4><p>在应用中，对同等地位或同等层级的页面使用平级导航结构，对具有复杂关系的页面使用层级导航结构。</p><p>使用场景：应用由几个同等级的模块组成，每个模块又有上下层级关系页面。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDY3N2FjNjVlOWNjMDdiMmY2NjZkY2ExZTIzNDQ1NDlfdThSY0owVXBaUzZZWVdsRFE5alQ2ejlrVDROeEU0NkpfVG9rZW46Ym94Y255V3NVRUJvV2dUVEZuQmlST1BHUUJjXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h2 id="常用应用界面框架"><a href="#常用应用界面框架" class="headerlink" title="常用应用界面框架"></a>常用应用界面框架</h2><p>常用应用界面框架有：</p><ul><li><p>启动页</p></li><li><p>详情页</p></li><li><p>列表视图</p></li><li><p>网格视图</p></li></ul><h3 id="启动页"><a href="#启动页" class="headerlink" title="启动页"></a>启动页</h3><p>针对内容型应用，应用首页内容的获取需要花费一定的时间，此时可以使用启动页缓解页面加载内容的等待感。启动页可以展示应用的品牌形象或者广告。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODY3MDc2NjJlN2MwMDI3M2RjN2FmODM4Y2IzOTE4YTRfSmNEVjFJR3BRTU50TE5BZ3VHbUpXY05PTXA4OXlIQTNfVG9rZW46Ym94Y250TGtwRk9rUXFVWTNPT0g4S1Fza1RkXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><ul><li><p>仅针对内容型应用使用启动页。内容型应用在启动时，需要花一定的时间获取内容，因此需要使用启动页，减少用户的等待感。没有网络加载内容的应用，不需要使用启动页。</p></li><li><p>避免让用户等待过长时间。用户总是希望第一时间看到应用内容，因此在页面加载完成后，需要及时呈现内容。</p></li><li><p>从后台加载应用时，不应该显示启动页。当应用被切换到后台后，再从后台加载回来时，不应该再次显示启动页。应用需要保留应用的状态，以便从后台恢复，方便用户继续浏览。</p></li></ul><h3 id="详情页"><a href="#详情页" class="headerlink" title="详情页"></a>详情页</h3><p>详情页用于展示应用的详细描述和操作。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGUwYTVhYjg4MGJlM2JkMTMxZTA1OGU4Njk3M2I3MzZfWHVPSGRwd2dmMm5mdlkzY092RWFVa1BRUkJTUHBBUWJfVG9rZW46Ym94Y25TbWdPeUpJdktmTlB6dnFMQ1NtekJiXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h3 id="列表视图"><a href="#列表视图" class="headerlink" title="列表视图"></a>列表视图</h3><p>列表视图通常用于文字和数据内容的展示。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NTJjMzg2ZGE1NTlhYTZhNjU5NGEzYTcxMDM4NTJjZWRfMExiVlBha0thenFhWnFIUjNXcUEzOEJrZW9ySkx4R09fVG9rZW46Ym94Y25iQXJrR0RsSUVEWmxKb2RCTU16cEJGXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><ul><li><p>列表应该按照一定的逻辑排序，便于用户浏览和操作。例如：按字母顺序排序、按时间排序。</p></li><li><p>列表应该是同类项的集合，应该对外呈现一致的布局样式。常见的是单行列表、双行列表和三行列表。</p></li><li><p>列表显示的内容要主次分明，用户一眼就能关注到重要的信息和操作。</p></li></ul><h3 id="网格视图"><a href="#网格视图" class="headerlink" title="网格视图"></a>网格视图</h3><p>网格视图通常用于图片和视频内容的展示。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzgzYzA0NzRlYzIxMTQ4ZmY3OGZmMGI2NzdmZDA4NGNfeFR0NElxeVlZdFJuRW43VkVyMmpPSld6bUdBWUxTdjVfVG9rZW46Ym94Y24wUmxmOTltWkk2eHJ2bXlEWkxrNG5lXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><ul><li><p>网格视图显示同等重要的项目，具有统一的布局。</p></li><li><p>网格视图以图像为主组织内容。例如图库中用网格视图展示图片。</p></li><li><p>网格视图可以辅以文字和操作。例如应用市场中使用网格展示应用程序图标、简单描述和下载按钮。</p></li><li><p>网格视图应该考虑响应式布局。在横竖屏切换时，网格视图应该能够调整网格的数量以适应页面的宽度变化。</p></li></ul><h2 id="人机交互"><a href="#人机交互" class="headerlink" title="人机交互"></a>人机交互</h2><p>在全场景的数字体验中，越来越多类型的智能终端设备分布在用户的日常生活中，可交互的用户界面广泛存在于智能手机、平板、PC、智能穿戴、电视、车机、虚拟现实（VR）和增强现实（AR）等设备上。应用可能在多种设备上运行或在单一设备上被用户通过多种输入方式操控，这需要其用户界面能够自动识别和支持不同的输入方式，以便用户以习惯的、舒适的方法与其进行交互。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWVlZmFiMDM4ZDRhY2NlMzkwMTg4NDI3YTk2NTY0MTZfQjVRQmZ2eEsyd0tTZEc2T3BaRGNKV0ZPNFd2bFFUSUJfVG9rZW46Ym94Y25va09QWkdKQml0NWlGZDU4djFlcXBlXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>在全场景的人机交互方面，HarmonyOS 的核心思想是“根据用户的状态，提供符合当前状态的交互方式，保证用户交互体验的一致性”。例如，当应用运行在触屏设备上时，用户可以通过手指长按打开上下文菜单；当应用运行在 PC 上时，用户则可以通过单击鼠标右键打开该菜单。</p><p>典型的输入方式包括但不限于触屏上手指/手写笔等直接交互、鼠标/触摸板/键盘/表冠/遥控器/车机摇杆/旋钮/手柄/隔空手势等间接交互、以及语音交互。</p><h3 id="基于触控的交互"><a href="#基于触控的交互" class="headerlink" title="基于触控的交互"></a>基于触控的交互</h3><p>很多设备都拥有支持多点触控的屏幕，允许用户使用手指和/或手写笔进行交互。它们与屏幕的接触状态、数量以及运动行为被识别成触控手势和操作，可以支持多种交互功能和体验（例如点击、滑动、缩放、旋转）。在多数情况下，应将触控交互作为用户首要的交互方式。以下内容描述了 HarmonyOS 所支持的核心手势。</p><h4 id="基础手势"><a href="#基础手势" class="headerlink" title="基础手势"></a>基础手势</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzBkOThhYWYyZTljNjhkYTJiMDVmMzAwYWM1YzlmNmNfMjhwWk5kNlo4WkVDdks4Ylh6V2t4QWNTNkpqSk5zVHlfVG9rZW46Ym94Y25TdEIwUzAxWVZLUXRJZFBEN0hjbnBjXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h4 id="敲击"><a href="#敲击" class="headerlink" title="敲击"></a>敲击</h4><p>适用于支持指关节手势的机型。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjAzYjgyNzAyNWRkYmNjYjgzODFiY2VmOTllYThlNGJfM2JLUHJuNWJrNHJsMzFZYkZxZkZrczhZbUJIQUZOMVNfVG9rZW46Ym94Y25NYVJpSFJUTnNkdXhKSXl3c295Y2lQXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h3 id="基于光标的交互"><a href="#基于光标的交互" class="headerlink" title="基于光标的交互"></a>基于光标的交互</h3><p>当用户使用指向设备（鼠标、触摸板、AR/VR手柄、隔空手势等）与应用程序进行间接交互时，光标指向的对象和光标本身应提供适当的视觉反馈以表达对象的可交互性和到达的准确性。同时，应考虑利用光标支持精细化操作和悬浮状态的特性（相比手指触摸），以提升应用生产力、简化交互任务和增强信息展示。</p><p>本节规范主要适用于使用鼠标和触摸板来操作平面光标的场景，但基本的设计原则可推广至AR/VR手柄和隔空手势等空间交互场景。</p><h4 id="光标形态"><a href="#光标形态" class="headerlink" title="光标形态"></a>光标形态</h4><p>光标形态的设计遵循以下三个原则：</p><p><strong>功能表达</strong></p><p>当光标悬浮在特定界面对象或区域上时，可使用系统定义的标准的光标样式集合来表达其交互状态。</p><p>应用也可根据其自身具体场景自定义光标的形态。</p><p><strong>简单性</strong></p><p>为保证全局交互体验的一致性，应优先使用系统已定义的光标样式集合。如无必要，请勿增加新的光标样式。</p><p>对于自定义的光标样式，应尽可能简洁直观地表达在当前界面状态下用户可进行的操作和所需精度，不应在视觉上过分吸引用户的注意力。</p><p><strong>自动隐藏和显现</strong></p><p>对于以触摸交互为主的终端设备，如果光标在一段时间内没有移动或用户使用了触摸交互，则自动隐藏光标保证界面的干净整洁。</p><h4 id="悬浮对象的形态"><a href="#悬浮对象的形态" class="headerlink" title="悬浮对象的形态"></a>悬浮对象的形态</h4><p>当光标进入并悬浮在界面元素上时，界面元素可通过适当的视觉和行为反馈来使其对用户聚焦和提高指向的准确率。</p><p><strong>界面元素需要响应光标悬停的动作，以清晰表达该元素的可交互性</strong></p><p>在光标范式下，用户是通过将光标移动到界面元素上，然后执行对应的操作。这种情况下，需要界面元素在光标悬停的时候就反馈出其是否可交互，避免用户点击后才发现该元素不可交互而产生挫败感。</p><p>在表达界面元素的可交互性时，应考虑以下设计原则：</p><ol><li>显著性：在悬浮态下，与普通状态和其周围的界面元素相比，拥有清晰的功能可见性。</li><li>微妙性：视觉上不应过于强调或与普通状态具有较大差别，避免干扰用户注意力。</li><li>一致性：同类型控件的可交互性表达（视觉和动效上）应具有一致性。从平板/PC向电视、AR/VR使用场景扩展时，不同设备间控件的悬浮态也应具备一定程度的表达一致性。</li></ol><p><strong>在悬浮态下，界面元素要表达其可交互的热区</strong></p><p>图形界面中可能存在很多界面元素其视觉可见部分和实际可（触控）交互的热区相差很大。在此类场景下，光标悬停时准确表达可交互的热区有利于用户感知元素有效的触发区域，并进而提高交互的效率。</p><p><strong>界面元素的悬浮态效果类型</strong></p><p>HarmonyOS 具有2种默认的界面元素的悬浮态效果：浮起和背板高亮。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjkzMDE3YWIxYzllZWE1MTgxMWI0NTAyZWIyOGQ2ZDhfU3pXUWJwdUR6WVlmcXNDZ29tNXczanJkSGNFNlk4ZlZfVG9rZW46Ym94Y24zdnR0Q1Y1c2ZONmt2SkdoMTlLUzNkXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><ol><li><strong>浮起</strong>：当光标进入对象时，对象放大；离开时，对象尺寸恢复。尺寸变化过程中辅以过渡动画使体验流畅。浮起的效果一般适用于可见部分和实际热区大小接近、有背景填充、且在布局上与其它元素不相邻的控件，典型的控件类型包括强调按钮、导航点、勾选等。</li><li><strong>背板高亮</strong>：当光标进入对象时，对象底部叠加颜色色块。整体上，背板高亮的效果根据控件类型可分为两类：</li></ol><ul><li><p>对于视觉可见部分和实际可交互热区范围相差很大的控件，浅色的圆角矩形叠加于内容底层以高效表达其热区。此类控件通常无背景填充，典型的类型包括文本按钮、工具栏、Tab栏等。</p></li><li><p>对于有明显边界的容器类控件，比如列表、卡片、菜单等，当光标进入控件时，仅改变控件背板颜色以表达其可交互性。</p></li></ul><h4 id="展示附加信息"><a href="#展示附加信息" class="headerlink" title="展示附加信息"></a>展示附加信息</h4><p>当光标移动到界面元素上时，在以下场景中，可考虑通过显示附加信息来提升光标体验。</p><ol><li><strong>受限内容预览：</strong>例如在邮件、日历、备忘录等应用中，当光标悬停在内容列表/网格上时，可以通过悬浮窗显示更多的内容详情，方便用户进行快速预览和选择。</li><li><strong>精确位置显示：</strong>例如在截图、设计、办公应用中，当光标悬停在某些对象上时展示位置、尺寸等数值，便于用户进行精细控制。</li><li><strong>控件功能提示：</strong>如果一个界面元素其功能的自我解释性较差，则可通过文本提示进行告知。</li></ol><p>应谨慎使用悬停展示附加信息的功能。在使用时，展示的附加信息必须是必要的或能明显提升用户体验的。在使用展示附加信息的方案之前，应优先考虑界面的清晰性、简洁性和表达性，以便用户无论是使用光标输入方式还是在直接用手指触摸交互，都可以很容易且舒适地使用应用。</p><h4 id="精细化操作"><a href="#精细化操作" class="headerlink" title="精细化操作"></a>精细化操作</h4><p>光标交互区别于手指触摸交互的一个重要方面是光标支持精细化操作，设计师可考虑如何利用这一特性配合特定的光标形态来简化交互任务和提升生产力。</p><h4 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h4><p>应优化光标移动的显控比以提升其指向的速度和准确性。用户在使用光标指向目标时，可分为弹道加速和减速修正两个阶段。以鼠标为例，在弹道加速阶段，当焦点离目标较远时，用户快速移动鼠标以缩短光标与目标之间的距离，此时速度的重要性优于精度控制；在减速修正阶段，当光标离目标较近时，用户降低鼠标的移动速度，更为仔细的瞄准目标，此时精度控制重要性优于速度。</p><h3 id="基于焦点的交互"><a href="#基于焦点的交互" class="headerlink" title="基于焦点的交互"></a>基于焦点的交互</h3><p>当用户使用键盘、电视遥控器、车机摇杆/旋钮等非指向性输入方式与应用程序进行间接交互时，基于焦点的导航和交互是重要的输入手段。</p><p>本节描述了基于焦点交互的通用设计规范，针对各输入方式的细化的焦点交互方法请参考各输入方式的具体章节。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWVjYTZmYzVkNzU0YzA2N2NmMTJiOTVjNGQzNjZiNGRfeUJsdkJoV2ROQ0oyUEVYbkd4c3pOak1KVWJid1NYMU9fVG9rZW46Ym94Y25VUkdsSEZwUjl4eldXR3loWUhHd3FnXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><p><strong>内置支持</strong></p><p>控件原生支持走焦操作，设计师和开发者可以针对具体的应用场景对是否获焦、焦点顺序进行调整。</p><p><strong>提供初始</strong></p><p>初始焦点的位置需明确、突出，让用户有效地识别该位置，以便顺利开始走焦操作。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjkzOWQxNjM2NWE3MWQ4YTQzMzNhZmMzNjVjYWE4ZjlfM1pES2p2c25EZ1hUTnMyOGxnbFhnaFJWQU5lZmtZZlFfVG9rZW46Ym94Y25jczRLRzNNajlTelJ3WjFLeWhad25kXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>焦点的默认位置与界面层级与内容相关，确认默认焦点的规则如下：</p><ol><li>层级优先，最顶层的界面优先。</li><li>核心操作优先，根据应用提供的服务决定默认操作。</li><li>内容优先，遵循从上至下从左至右的方向规则。</li><li>不要在未加载完毕的区域显示默认焦点。</li></ol><p><strong>可遍历</strong></p><p>为完成所有交互任务，焦点需要能够遍历所有可获得焦点的界面元素，以保证功能的完整性。</p><p><strong>按区域获得焦点提高走焦效率</strong></p><p>在由多种控件组成的可划分明显区域的界面中，可精简 Tab stop 的数量以提升走焦效率。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjBiNTNkM2JkZTJkMmNiYTlkMzRlZDdkNWUxMDcxYzBfeHk1WnFHSUtpcXF3YmVpTjk4dE1oa3FDSEtTNmR4VmdfVG9rZW46Ym94Y251OHljenNKaWNrUVkyZHF0TzBTbVFoXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>Tab stop 与普通焦点的异同（以键盘操作为例）：</p><ul><li><p>Tab stop：可以用 Tab 键获得焦点的控制元素，一般情况下，一个区域的首项为该区域的 Tab stop。</p></li><li><p>普通焦点：不在 Tab 走焦序列之中，但在区域内可以通过方向键移动获得焦点。</p></li></ul><p>另一个典型的需要考虑区域获焦的场景是在车机上通过旋钮和摇杆/方向键的配合使用来快速移动焦点。例如使用摇杆/方向键来切换页面、层级和区块，使用旋钮切换每个可点击的元素。</p><p>应根据输入方式的支持情况决定是否开启按区域走焦，如无Tab键或其等价键支持，则不能开启区域间快速移动操作，此时，只能在单个焦点间遍历（Tab stop 数量与可获得焦点元素数量相同）。</p><h4 id="走焦顺序"><a href="#走焦顺序" class="headerlink" title="走焦顺序"></a>走焦顺序</h4><p>依据用户界面的形态和输入方式的不同，走焦场景可基本分为三类：绝对顺序走焦、相对方向走焦、和插入符走焦。</p><p><strong>绝对顺序走焦</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTRmZmU2MGU2MzRkNjRmNGI5NmRkZjljYzhhNWMxNjNfWXI5aXRyYk5xa3VNZmJYQlNwMW1LVTJLc1dwV0ZEdHFfVG9rZW46Ym94Y25ubE9yc3dkbGtXQmlocHBpbkhCQ0VjXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>存在一个确定的走焦顺序，所有可获焦元素都会按照在屏幕上显示的顺序或指定的顺序进入走焦顺序中。例如：当使用键盘时，Tab键选择下一个焦点，Shift+Tab键选择上一个焦点。</p><p>在设计应用时，可按照功能分区、视觉呈现等规则重新组织焦点顺序。</p><p>基本规则：</p><ul><li><p>用户只能按照给定的焦点顺序移动焦点。</p></li><li><p>提供两种操作次序：正序和反序（例如键盘上的Tab和Shift+Tab，车机旋钮的右旋和左旋）。</p></li><li><p>一般来说，焦点列表首尾相连。</p></li></ul><p><strong>相对方向走焦</strong></p><p>按照可获焦元素的分布方向关系进行走焦，存在多种不同路径的走焦顺序。</p><p>用户输入方向信息，系统通过某种算法计算出在相应的视觉方向上应获得焦点的元素，并使其获焦。典型场景为使用遥控器上的方向键与电视交互。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTc5NTM5ZDEyNzg3OTEzYWQzYzJlZDkwNTE1NGRjZDRfTzhpZE1tSFBTN0oxdkxmRUZmcTkxb2hZWDc3VmY1R0dfVG9rZW46Ym94Y25aWlFnTUN2UlhmUHRtMjJSNFhQemlnXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>共用底层导航机制：</p><ol><li>无论输入方式是键盘、遥控器，或触摸板、摇杆等其他方向操作模拟设备，基本操作逻辑都保持一致。</li><li>不同的导航策略将影响用户在按下方向键时下一个焦点的选择。</li></ol><p>基于方向和距离优先的判断方法：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWQzYjkzN2QwMTRiZDk3Y2E3YzAwYjAxNDI2NzRiYmZfV1IyQ0pjNmpmdVQ1R0xBQXAyWVRQT2ptbUxpbjhUVjdfVG9rZW46Ym94Y25yeUlDdHI0Y05jSG9Ha0xtSkFKdkhlXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><ol><li>收到用户按键输入</li><li>将当前焦点边缘向该方向扩展</li><li>第一个可投射至该扩展区域的即是目标焦点位置</li><li>此时如果有多个候选焦点，选投影距离最短的那个</li><li>如果仍有多个候选焦点，按照从上到下/从左到右的规则进行筛选</li></ol><p><strong>在绝对顺序走焦中嵌入相对方向走焦区域</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2M2OTY1MGY4YTYyYjMyODIzNzAwZDczYmIxYzM5ZGJfVVIyT0kxMEZ4ZldwaVo1UEdYaE5MNWhvanUzV2x3Y3BfVG9rZW46Ym94Y25UMGpBbU1heXpkRTV3VFptdk5EVENnXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>此类导航设计主要有两个目的：</p><ol><li>提升操作效率。绝对顺序走焦可遍历所有可交互控件，在元素较多的情况下效率不高。</li><li>使走焦顺序更具有逻辑性。按照功能组织分区，将逻辑顺序与视觉分区进行匹配，用户更容易学习。</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Q4YmIyM2EzOTc0ZTcxOTFmODcxMWQ3ZjFkODQwMTNfYjlvT0JncVNKcGNWbVoyVzlLZ24xd0hmS2l6elJ1clhfVG9rZW46Ym94Y25STFFHd2xyaU84UnNOWVd5aGg5ZWRlXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>优化策略1：</p><p>在相对方向区域内支持方向键导航，如上图所示，使用右键将焦点从B移至C，使用左键将C移至B；方向键只能在当前层级内使用，不能用于跳出区域，如：焦点位于C时，按右键无响应。</p><p>优化策略2：</p><p>为每个区域指定一个默认Tab次序，使用Tab键能快速在区域间跳转，如：将A的TabIndex设置为1,B的TabIndex设置为2,D的TabIndex设置为3，则按Tab键的走焦顺序为A-&gt;B-&gt;D，可以不再遍历所有焦点，而在每个区域内可以使用方向键进行遍历，提供了一个效率更高的融合走焦方式。</p><p><strong>插入符走焦</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDViOGM3NTc3MmQxOTJkNTMwM2NmZmZjOTQ4Zjc5MjRfT2Zya2ppQWlEOTUzekU0YzNCcHBReUVwVk1ibkZWS3pfVG9rZW46Ym94Y24wc3pLdTVKREdQTjZTNXk1SFhzb1ZlXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>针对文本处理的操作，以插入符为操作指引，通过方向键移动、选择，常见于文本处理类、表格应用或控件之中，通常用来配合支持一些常见的文本操作类快捷键。</p><p><strong>其它注意事项</strong></p><p>对于支持触控交互或光标交互的系统，焦点仅在系统检测到用户正在使用特定的输入方式进行走焦操作时显示，避免视觉上的干扰。</p><p>在走焦操作状态下，如果检测到用户将输入方式切换为触控交互或光标交互，界面上的焦点视觉元素应自动隐藏。</p><h3 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h3><p>鼠标是一种典型的基于光标的、具备像素级精度的指向型输入方式，最为适用于对用户交互具有较高精度要求的生产力应用和高密度UI的场景。</p><p>一般地，鼠标由左键、右键和滚轮键组成，这些按键的交互应遵循业界标准的规范功能和用户的既有使用习惯。鼠标也可以通过和不同的键盘按键进行结合，提供额外的快捷操作体验。系统级一致的鼠标交互包括：</p><p>无法复制加载中的内容</p><h4 id="鼠标与触摸交互的关系"><a href="#鼠标与触摸交互的关系" class="headerlink" title="鼠标与触摸交互的关系"></a>鼠标与触摸交互的关系</h4><p>在很多场景下，应用程序需要同时支持触屏交互和鼠标交互。</p><p>手指触摸交互通过对界面对象执行的物理世界真实的手势（例如滑动、旋转等）来模拟直接在屏幕上操作这些UI对象的能力。而鼠标受限于其间接交互的性质和仅有一个指针响应位置的特点，在一些交互任务上并不适合将手指触摸和鼠标按下操作完全对等。</p><ol><li>在一般的选择或启动对象上，鼠标左键点击可以直接等同于触屏上手指点击。</li><li>在其它场景下，应优化应用以适配鼠标的交互习惯以提高生产力和用户体验的一致性。例如，上下文菜单应通过右键单击来快速触发，而非模拟触屏上手指长按的左键长按；</li></ol><p>拖拽对象时，允许鼠标左键按下即可拖拽，而无需长按才能触发拖拽状态；</p><p>尽量通过滚轮来控制页面的滑动和切换，而非左键按下后沿一定方向移动鼠标（这对用户来说是一个效率低下且难以控制的行为）。</p><p>关于更加详细的具体场景下触摸交互和鼠标交互的对应和转换关系，请参考<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/unified_hci_framework-0000001054246492" target="_blank" rel="noopener">交互事件归一</a>。</p><p>关于光标和界面对象的悬浮态表现，请参考<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/hci-cursor-based-0000001053407781#ZH-CN_TOPIC_0000001053407781" target="_blank" rel="noopener">基于光标的交互</a>。</p><h3 id="触控板"><a href="#触控板" class="headerlink" title="触控板"></a>触控板</h3><p>触控板同时具备多指触控手势输入（触屏）和精细化指向型输入（鼠标）的特性，使得触控板既适合用于基于触摸交互优化的用户界面，也适合用于对指点精度有较高要求的生产力应用。</p><p>在为你的应用设计或适配触控板交互时，触控板交互应满足用户手眼分离状态下（眼睛看着屏幕，手在触控板上盲操作）的使用习惯，应遵循以下原则：</p><ol><li>触控板应该能起到取代鼠标的作用。</li><li>应用在触屏上的手势操作功能可通过在触摸板上相应的手势来实现。</li></ol><p>无法复制加载中的内容</p><p>关于更加详细的具体场景下触摸交互和触控板交互的对应和转换关系，请参考<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/unified_hci_framework-0000001054246492" target="_blank" rel="noopener">交互事件归一</a>。</p><p>关于光标和界面对象的悬浮态表现，请参考<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/hci-cursor-based-0000001053407781#ZH-CN_TOPIC_0000001053407781" target="_blank" rel="noopener">基于光标的交互</a>。</p><h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><p>键盘是一种重要的生产力输入方式，优秀的键盘使用体验应允许用户快速准确地进行文本输入、双手无需离开键盘即可在系统和应用内进行导航、访问所有的功能、以及支持无障碍体验。</p><h4 id="走焦导航"><a href="#走焦导航" class="headerlink" title="走焦导航"></a>走焦导航</h4><p>焦点导航和交互方式、焦点划分和走焦顺序等设计原则请参考<a href="https://developer.harmonyos.com/cn/docs/design/des-guides/hci-focus-based-0000001053927764#ZH-CN_TOPIC_0000001053927764" target="_blank" rel="noopener">基于焦点的交互</a>。</p><h4 id="基础和标准快捷键"><a href="#基础和标准快捷键" class="headerlink" title="基础和标准快捷键"></a>基础和标准快捷键</h4><p>应结合应用场景提供必要的快捷键支持（例如：按键导航相关、剪切/复制/粘贴等），基础设计原则为：</p><ol><li>以传统PC为兼容对象，根据设备情况和应用场景进行裁剪。传统PC有最庞大的用户基础，用户习惯难以改变。但同时应移除过于复杂、频率较低、或缺乏设备使用场景的快捷键组合。</li><li>新增快捷键支持。针对华为特有应用或功能（例如：分屏、多终端等）增加直接入口。</li><li>以融合PC为目标为触屏手势操作添加快捷键支持，提高生产力（例如：打开通知栏、控制中心、显示/隐藏Dock等）。</li></ol><p>无法复制加载中的内容</p><h4 id="自定义快捷键"><a href="#自定义快捷键" class="headerlink" title="自定义快捷键"></a>自定义快捷键</h4><p>在一些场景下，用户可能更习惯于通过键盘来访问系统和应用功能，例如在生产力软件中通过键盘快捷键来提高使用效率，部分残障人士也更偏好使用键盘来进行交互。因此，请确保应用中核心功能支持仅通过键盘操作即可访问。</p><ol><li><strong>对菜单中的功能提供键盘快捷键访问支持：</strong>键盘快捷键经常和应用内菜单中的功能关联出现，应允许用户通过键盘快捷键访问这些功能。例如图库应用中照片列表支持通过快捷键进行全选、删除、复制、分享等操作。</li><li><strong>对应用中其它核心功能提供键盘快捷键访问支持：</strong>应用中某些常用的功能没有对应的菜单项，也需要相应的快捷键支持，这类功能往往和控件上的直接操作对应。例如在聊天页面中，应将Enter键与发送按钮的单击操作相关联，允许用户在文本框输入消息内容后可以通过按Enter键来直接发送内容。</li><li><strong>与系统标准快捷键相兼容：</strong>在所有应用中，对于标准功能，快捷键的设计应与系统标准快捷键的定义一致。另一方面，在应用内尽量避免对标准快捷键的功能进行重新定义，否则将对用户的使用造成混淆。</li></ol><h3 id="手写笔"><a href="#手写笔" class="headerlink" title="手写笔"></a>手写笔</h3><p>在触屏上，手写笔是手指精细化操作的延伸，是一种像素级精度的指点设备。手写笔提供了一种直接的、自然的方式来进行数字内容书写、绘图和标注。目前手写笔分有无物理按键两种笔型，支持系统级一致的交互：</p><h4 id="有物理按键"><a href="#有物理按键" class="headerlink" title="有物理按键"></a>有物理按键</h4><p>无法复制加载中的内容</p><h4 id="无物理按键"><a href="#无物理按键" class="headerlink" title="无物理按键"></a>无物理按键</h4><p>无法复制加载中的内容</p><h4 id="手绘套件开放"><a href="#手绘套件开放" class="headerlink" title="手绘套件开放"></a>手绘套件开放</h4><p>Pencil Engine：将手写效果能力以插件化方式集成，为应用开发者创造更多的手写应用场景。支持多种笔刷（圆珠笔、钢笔、铅笔、马克笔）选择、多色调色版；能设置笔刷颜色、粗细、撤销、恢复、擦除、套索等笔迹编辑能力。应用利用多笔刷可满足用户日常所有的笔记和绘图、涂鸦等需求，能达到较好的文字书写体验。</p><h3 id="隔空手势"><a href="#隔空手势" class="headerlink" title="隔空手势"></a>隔空手势</h3><p>隔空手势（非接触手势）是一种人与设备交互的新方式，用户可以在无需手持或接触设备的情况下与设备进行便捷的交互。随着技术的发展，隔空手势在手机、平板、车机、电视、音箱、AR/VR等设备上都有一定的应用。通常情况下，快捷手势通常是符合用户直觉、文化习惯或者容易操作的动作。</p><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p><strong>巧用隐喻建立联系</strong></p><p>利用手势本身的含义，将于功能与有相近含义的手势建立联系，进行隐喻，从而让用户更容易接受与记忆。</p><p><strong>基于原有交互习惯进行延伸</strong></p><p>基于用户已有的交互习惯进行延伸，能降低用户的进入难度，用户在使用新的交互方式时自然而然会产生亲切感；将会减少用户的学习、记忆成本。</p><p><strong>尊重各国文化，避免手势禁忌</strong></p><p>应避免不同地域的手势禁忌问题，手势功能应与人们理解的更一致，从而让用户更容易接受。</p><p><strong>设计疲劳度低的手势</strong></p><p>避免太长时间、太精细的操作；另外在长时间交互时，长时间的悬停，会使疲劳度增高，手势疲劳度从小到大依次是：手掌&lt;小臂&lt;大臂。</p><h4 id="常用隔空手势"><a href="#常用隔空手势" class="headerlink" title="常用隔空手势"></a>常用隔空手势</h4><p>快捷手势对应的功能一般也为用户常用的高频功能，在 HarmonyOS 中主要有以下几种：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2EzOTY1Mjc5NjBkN2QxNmYxMDMzOGFlMTg0NTE2MzNfanJMSzRmVHhpUUIzczJMMVJjMWlNUjh0b2RkWGFCT3BfVG9rZW46Ym94Y25uSkNVVEVSWWwySFdwSWRPZzlkUmxoXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmQzYzFhMTgwN2Q1NGU1YmIxMzcyNmZjNDk5M2E1MDFfTGxpeTE4U05MdU9SbGxCbzRkdGYwOW1jbVNob0VhTmJfVG9rZW46Ym94Y25iZDY4UjFSWkV2c0VYNVFxemFZVVRnXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h3 id="交互事件归一"><a href="#交互事件归一" class="headerlink" title="交互事件归一"></a>交互事件归一</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDRhMzZjMTIzMTZkNTRkNmVhYmZjOGFmNDE3NmJmMTJfd2Q2ekROd3l4eWdCMEx2OHpDQkRWR29KV3Fpckx3MEFfVG9rZW46Ym94Y25VbExrRUFrbm1BNG9rcWlxbjR3Z21mXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>本章节描述了在多种交互任务或场景下，应用在触屏上和其它常用的输入方式（例如鼠标、触摸板、键盘）上分别对应的正确的交互规则。设计师和开发者应保证在当前输入方式下应用能够以正确的、符合用户习惯的交互规则进行响应。</p><h4 id="打开-切换对象"><a href="#打开-切换对象" class="headerlink" title="打开/切换对象"></a>打开/切换对象</h4><p><strong>应用场景</strong></p><p>用户通过点击某个元素触发功能、访问新页面、或改变自身状态。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDc2ZjUxMGM5ZDJlZjA5ZmY3ZmE4NDQ0NzgwMTliNzJfblJsSXlrNEFOaHNUMXFkd3d6MWZIWkF2bENFR2s3N0NfVG9rZW46Ym94Y250UG5uTjh6T0ZzZTZ2TkdWZHhaZjNjXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>一般地，触屏手指的按下/抬起行为对应于光标的按下/抬起行为。</p><p>在一些特殊场景，可能会存在使用鼠标/触摸板双击打开对象的交互方案，例如电脑模式下打开桌面应用或文件。此类情况需由应用单独特殊处理，且同一功能不能同时支持单击和双击两种交互方式。</p><h4 id="显示菜单"><a href="#显示菜单" class="headerlink" title="显示菜单"></a>显示菜单</h4><p><strong>应用场景</strong></p><p>某个元素上显示弹出菜单或快捷方式菜单。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2M2NmQwMjk2YmFhZDk5MTIxOTc5MmMyNjcwMDY5MmVfWEtpUjZOYkw5aVZwUEZSNUlTTUxvYXZJY0lma0hRRmZfVG9rZW46Ym94Y25LVmgyR1YwWnJheU91ZDgwSHJURFZFXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>无法复制加载中的内容</p><p>这里的菜单指的是广义的菜单，即用于展示用户可执行的操作的临时性弹出窗口。</p><p>凡是在触屏上通过长按显示的菜单，都需要支持鼠标右键单击和触摸板双指单击的触发方式。</p><h4 id="选择对象"><a href="#选择对象" class="headerlink" title="选择对象"></a>选择对象</h4><p><strong>应用场景</strong></p><p>用户在触屏上通过长按操作进入多选，一般用于列表或宫格界面。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGM0NDIyMDA4ZmRhZjBmODA3ZGQ4ODUwYzlkZmYzMDVfR0ZnTXdHRnMwQ09uNGszV0w4VjVHUkUzZzRrQ0ZaMExfVG9rZW46Ym94Y25zZjVtUTVoWTNZY2VwT0QwZmRKMzBnXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>无法复制加载中的内容</p><p>使用鼠标和触摸板选中某个项目时可以同时显示上下文菜单（可选）。</p><h4 id="滑动对象"><a href="#滑动对象" class="headerlink" title="滑动对象"></a>滑动对象</h4><p><strong>场景1：连续滚动列表和页面</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWFlY2RlMTAzYmVmNzc3NGMyZTUwNTU3ZDRlZGQzZWJfdjF1QmtoQVluNGFDWDZqYVF3RGJEbk51cXlicjFpY2dfVG9rZW46Ym94Y244YjdOT1R3OWx2S0tORkJ5QnFoTk1iXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>无法复制加载中的内容</p><p><strong>场景2：横向/竖向切换页面/对象</strong></p><p>每次操作仅滚动一项。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGJmN2U1OGYzNTRmOTdmZTQwZThhY2I2ZGU2MzZiNjVfakFsS3pqQmRnVVlyNTJYTW5lQUFVYVVERUptSHloNDVfVG9rZW46Ym94Y25UTkJEWGlZWDRqMmhyaWIzNndOMkU0XzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>无法复制加载中的内容</p><p><strong>场景3：调节滑动条</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmM1NDdmY2M3ZWRhNzRiNmY1ZGQ0Yjc1NjZkYjhkZTZfelN1OWd1UVVtQk5JT2gwQUVmVXA0b2hlTzRJdGJDTVpfVG9rZW46Ym94Y255Tms2b1hmTUlScmhOSTdFR0RwaG5nXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>无法复制加载中的内容</p><p><strong>场景4：调节滑动选择器</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjU3NTIzYWEwN2RmYmVlNTY5ZWMwM2Y3Yzg5YTA2NjJfcW5udWpiN2VmcTJpYXdyT3A3cGFObXhPbGVqc1pHczFfVG9rZW46Ym94Y25oWjB1S093WHNCNUhzWVJpUlk4NlJoXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>无法复制加载中的内容</p><p>当滑动条/picker嵌套在可滑动页面和列表中时，两者都可用鼠标和触摸板进行滑动，在使用光标指向型设备时应保证两者的兼容性。</p><p>这种情况下：</p><ul><li><p>每次光标位置移动后，根据光标的位置决定响应的控件。</p></li><li><p>如果进行滑动操作前，指针位于滑动条/picker 上，则滑动条/picker 进行调节，列表不滚动。</p></li><li><p>如果进行滑动操作前，光标位于列表上，则列表进行滑动，而滑动条/picker 不响应，即使在列表滑动过程中光标进入 滑动条/picker 的有效范围内。</p></li><li><p>在某次滑动后，如果光标位置在屏幕上发生变化，则重新进行判断。</p></li></ul><p><strong>场景5：自定义滑动</strong></p><p>其它更多自定义触摸滑动行为，比如在视频播放界面调节音量/亮度、滑动返回等。在操作不冲突的前提下，鼠标和触摸板应也应支持相应的交互。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjdiYmI3NWRhMjc3OWQ4ZGQyYzBiOTgyYzVmYTUwNGRfUkl4enFqSldrRjdSb25yNjFjRmtWUE9GU1FLSjZlMGtfVG9rZW46Ym94Y25JajA4R3EwTUxkMVlIUk1XZnJXQ0VoXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>无法复制加载中的内容</p><p>应优化鼠标滚轮滚动次数/双指在触摸板上的滑动距离和对象行为之间的关系，以使用户能够轻松、快速、准确地控制对象</p><h4 id="刷新页面"><a href="#刷新页面" class="headerlink" title="刷新页面"></a>刷新页面</h4><p><strong>应用场景</strong></p><p>用户在触屏上通过手指滑动对列表/页面进行下拉刷新。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2I3YWIxNmVlYzViYzRjNWViMzAzYzNjMWI4MTk2MDlfUVJVUEp4Z3dzcGNlT0t6STczeTZxQUt2cGhCOHFjcm5fVG9rZW46Ym94Y25idlFoOElIVG9YdE5IRFl5VG0yNE5kXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>无法复制加载中的内容</p><h4 id="缩放对象"><a href="#缩放对象" class="headerlink" title="缩放对象"></a>缩放对象</h4><p><strong>应用场景</strong></p><p>查看图片时调整图片大小。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODFlZmEzNDAxNjBkNzQ5ZTZiYmQwODNkZTlmNzg3ZDhfTDV3bHBRMGs2MGFiSDN6RGFGZGFTZDRCemFvaU9HeFBfVG9rZW46Ym94Y25hNmNpWEF0R0lQTG93N2VkWkNmazlmXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>无法复制加载中的内容</p><h4 id="旋转对象"><a href="#旋转对象" class="headerlink" title="旋转对象"></a>旋转对象</h4><p><strong>应用场景</strong></p><p>编辑图片时旋转图片。</p><p>无法复制加载中的内容</p><p>有些场景中触屏上双指可以同时进行缩放和旋转操作（如图片/地图浏览），触摸板应同步支持。</p><h4 id="拖拽对象"><a href="#拖拽对象" class="headerlink" title="拖拽对象"></a>拖拽对象</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YThmYWYxN2QxOWI1MzQyOGNiMzA5NWE2ZDdiYjczZTlfckpPUmxFbk9IeXlFdXhnSk9oNjR5WTFqMUIwN0lFa2pfVG9rZW46Ym94Y25OTER5bDJvNG9ZaFZWQnQzbGxMOERkXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>无法复制加载中的内容</p><h2 id="视觉风格"><a href="#视觉风格" class="headerlink" title="视觉风格"></a>视觉风格</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="虚拟像素单位：vp"><a href="#虚拟像素单位：vp" class="headerlink" title="虚拟像素单位：vp"></a>虚拟像素单位：vp</h4><p>虚拟像素(virtual pixel)是一台设备针对应用而言所具有的虚拟尺寸（区别于屏幕硬件本身的像素单位）。它提供了一种灵活的方式来适应不同屏幕密度的显示效果。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjM1NGJmODI1NDc3YzE4NzJlMDg5OGQ3NThhOWI5ZjdfcmZKMW1xaGpsQlNsUEhCY3FuSWJVQk5ETzUwdDUxZldfVG9rZW46Ym94Y25yOXJHOGExUU1ZMk9CN1hTZ2RwWVpiXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>使用虚拟像素，使元素在不同密度的设备上具有一致的视觉体量。</p><h4 id="字体像素单位：fp"><a href="#字体像素单位：fp" class="headerlink" title="字体像素单位：fp"></a>字体像素单位：fp</h4><p>字体像素(font pixel) 大小默认情况下与 vp 相同，即默认情况下 1 fp = 1vp。如果用户在设置中选择了更大的字体，字体的实际显示大小就会在 vp 的基础上乘以 scale 系数，即 1 fp = 1 vp * scale</p><h3 id="色彩"><a href="#色彩" class="headerlink" title="色彩"></a>色彩</h3><p>HarmonyOS 色彩系统的目标是为所有人群而设计，我们关心每个用户的体验，站在不同人群的角度思考问题，做到感同身受的体验设计。色彩本身没有好与坏、对与错。产品设计里的色彩，取决于如何正确合理地使用它们，就像我们绘画时调色盒里的颜色一样，能否绘出优秀的作品，取决于作画者如何正确地运用色彩。</p><h4 id="品牌色"><a href="#品牌色" class="headerlink" title="品牌色"></a>品牌色</h4><p>色彩能够赋予应用界面足够的生动性，并给用户提供视觉感官上的连续性。同时，合理地运用色彩可以传达关键的状态信息，给予用户即时的状态反馈以及数据可视化呈现。</p><p>HarmonyOS 采用蓝色作为系统的主色调。根据人因研究，对蓝色的接受度无论是在男性还是女性群体中，比例都是最高的。而在世界地域维度，蓝色也是最受欢迎的颜色。更重要的是，对于大多数色觉障碍人士，蓝色依然可以被辨识，这满足了 HarmonyOS 为障碍人群而设计的要求。</p><h4 id="宇宙蓝"><a href="#宇宙蓝" class="headerlink" title="宇宙蓝"></a>宇宙蓝</h4><p>我们选择更为深邃广阔的宇宙蓝，无边无垠的蓝深邃如宇宙，为系统带来宇宙初开的纯净与宁静。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmRmZTUzMmQzNmM3ZDYwM2U0NzEzZDI4MjljY2U4ZThfRVV5VG9HY0VvT1pBTm03Q0RMeHNBRWZnWjlaUVVtWmNfVG9rZW46Ym94Y25VZ3pEVWNSR0RnZEtETFVyM2hXTXJkXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p><strong>色值及使用场景</strong></p><p>在色彩设计上，既保持统一的色彩语言，又根据多端不同的使用场景做了调整，带来定制化用户体验。</p><h4 id="雪域灰"><a href="#雪域灰" class="headerlink" title="雪域灰"></a>雪域灰</h4><p>自然里面，没有绝对的黑也没有绝对的白，以带有淡蓝色相的雪域灰作为卡片界面的背景颜色来烘托界面的纯净感。</p><p>宇宙蓝与雪域灰，苍穹与大地，两者相配合，使得整个界面更加干净、和谐。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTM1MzYyOGQ5MGQyNjI4NDAyOWVlM2RjYjhmYjlmOWVfS2Jsa2JKRzRmc0c2YTB2dTVqbExVdnc2UGpkcllZckVfVG9rZW46Ym94Y25WRkxKbFl5amJxUWttOEFEcm9VekNlXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>雪域灰可用于卡片界面的底色来衬托卡片层级感，或者可用于深色主题下的前景颜色，使深色场景的前景与背景对比度不会过高，减轻视觉刺激。</p><h4 id="主题风格"><a href="#主题风格" class="headerlink" title="主题风格"></a>主题风格</h4><p>HarmonyOS 设计了浅色主题、深色主题、半透明主题三种不同的主题样式，设备和应用可以选择合适的主题风格来呈现界面。例如：</p><ul><li><p>手机建议主要以浅色主题为主，其他主题为辅。当用户有需要的时候，也可开启深色模式将浅色主题的应用界面切换为深色主题样式。</p></li><li><p>智慧屏的使用场景较为固定，多为室内观看，所以大屏主题风格选择了深色主题为主。</p></li><li><p>智能穿戴设备采用深色主题为主，可以为穿戴设备降低电量消耗。</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=M2FiOTJhYjI1MmY5ZmZhZWMxOWQxZmZlOWM4ZTNlMmZfazFubW5QNERPd2Vxb2x1SW9COFpqb3AxOVp5UFFOaUxfVG9rZW46Ym94Y25pcjZBZ2NiQXVQdmpTTUg0Mk5ER0xiXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="全新-HarmonyOS-字体"><a href="#全新-HarmonyOS-字体" class="headerlink" title="全新 HarmonyOS 字体"></a>全新 HarmonyOS 字体</h4><p>通过研究用户在不同场景下对多终端设备的阅读反馈，综合考量不同设备的尺寸、使用场景等因素，同时也考虑用户使用设备时因视距、视角的差异带来的字体大小和字重的不同诉求，我们为 HarmonyOS 设计了全新系统默认的字体——HarmonyOS Sans。</p><p>下载 <a href="https://communityfile-drcn.op.hicloud.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20210608111628.62420999153403221248286695242932:50520607053655:2800:27F307A9789BAC4269AD95AC3BB2C8F68B4857BA697D207904B1937733A2C648.zip?needInitFileName=true" target="_blank" rel="noopener">HarmonyOS Sans</a></p><h4 id="全新字体笔画设计"><a href="#全新字体笔画设计" class="headerlink" title="全新字体笔画设计"></a>全新字体笔画设计</h4><p>在保障字体体验的功能性前提下，我们在人文和现代中找到新的平衡。在短笔画时保持横平竖直，简约无装饰，撇捺弯钩长笔画中融入书法的笔势美学，带来全新的视觉感受。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmVlNzA2NmNlYjc2MmM2OTZhYzJjYzAwNjhiZjJkMjJfdDdHOTJNekJvemt3eGVuakpPb1F3Uzl4QVV2YlBqOWtfVG9rZW46Ym94Y25ZaHhzbXBMdlhOUjd3ZkpHNWVRVjhlXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h4 id="优化字体灰度，提升阅读体验"><a href="#优化字体灰度，提升阅读体验" class="headerlink" title="优化字体灰度，提升阅读体验"></a>优化字体灰度，提升阅读体验</h4><p>在不同设备的应用场景下，字体的灰度会影响在弱光环境、小字号、远距离下的识别性。因此我们优化字体的灰度，让新字体在不同场景下具有更好的识别性和阅读体验。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWQzYzBiY2FlNDYwZjIzMjVkZWI4M2M5NDZkMDZmNzdfY0RWaU02NEE5QjZ4ekh1OEt6dk9GU01iaUswQVNQNXpfVG9rZW46Ym94Y243ZXoxVkNrcXFxSERaZFRzdjFrclFiXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h4 id="统一多语言字形风格"><a href="#统一多语言字形风格" class="headerlink" title="统一多语言字形风格"></a>统一多语言字形风格</h4><p>我们重新设计了中文、拉丁文、希利尔文、希腊文、阿拉伯文的字形样式，支持100+语言，让多语言下阅读体验更加一致。</p><h4 id="HarmonyOS-字体特性"><a href="#HarmonyOS-字体特性" class="headerlink" title="HarmonyOS 字体特性"></a>HarmonyOS 字体特性</h4><h5 id="动态字重粗细调节"><a href="#动态字重粗细调节" class="headerlink" title="动态字重粗细调节"></a>动态字重粗细调节</h5><p>HarmonyOS Sans支持可变特性，让用户选择他们喜欢的字体粗细来进行文本的显示。</p><h4 id="支持更多字重能力"><a href="#支持更多字重能力" class="headerlink" title="支持更多字重能力"></a>支持更多字重能力</h4><p>HarmonyOS Sans增加了Thin、Light、Bold、Black的字重能力，开发者可以选择需要的字重来构建界面的信息层级。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NzdhYzcxYWI1MTkxMjAxZDExODFiMjdjOWZlYTVlMzBfakNBaVZuOUdYU1oyamJlME5nQXhDQnhWNGVicUk0WElfVG9rZW46Ym94Y24wb0tnMllkcGE1U2lRRnZud2ZIc2pmXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h4 id="等宽与变宽数字字体"><a href="#等宽与变宽数字字体" class="headerlink" title="等宽与变宽数字字体"></a>等宽与变宽数字字体</h4><p>HarmonyOS Sans支持变宽和等宽两种样式。文本混排中使用系统默认的变宽数字，在阅读文本段落中能让阅读体验更加连贯。而等宽时钟数字在需要强调数值以及数据需要经常变化的表格和时钟数字的场景中使用时，可以保持数字字宽的对齐，同时更具图形化的呈现可以在界面中脱颖而出。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjI3ODIzMDQ1NjE2NzFiMmM0OGQ1Y2JhNzcwZTlmMjZfbzBqbzJ3eTRFN3lCRnRjTG8yak1sQUVVZHNsdXFkNmxfVG9rZW46Ym94Y25uTDcxN1hxNHhjTW5tMjRVOXFXRFl1XzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h4 id="支持时钟字体特性"><a href="#支持时钟字体特性" class="headerlink" title="支持时钟字体特性"></a>支持时钟字体特性</h4><p>HarmonyOS Sans支持时钟字体特性，冒号格式会根据时间格式自动调整位置。</p><h4 id="字体排版"><a href="#字体排版" class="headerlink" title="字体排版"></a>字体排版</h4><h5 id="多设备字号层级"><a href="#多设备字号层级" class="headerlink" title="多设备字号层级"></a>多设备字号层级</h5><p>选择合适的字号有助于定义内容的信息层级，以及达到内容的可读性。通过研究全场景设备的显示环境、用户使用时环境的差异，我们为不同设备形态定义了一套构建信息层级的字号系统。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzRjMDM1MDZiZjkwNjFjZTNmOGM3YzYzM2FjYmJiYmNfT3IxSXYwcUt1bTl0NjNBenYxUEtxem1hdWxRSDJmMWJfVG9rZW46Ym94Y25GbEVuMG5jTUl5ZUV4YW9LRjB5dTlmXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h4 id="文本对齐规则"><a href="#文本对齐规则" class="headerlink" title="文本对齐规则"></a>文本对齐规则</h4><p>不同的文本对齐方式可以引导用户的视觉流向。在段落文本中文本超长换行默认使用左对齐的方式，因为人的浏览视线都是从左往右移，因此大段需要阅读的文案，采用左对齐的方式排版有利于用户快速定位，保证良好的阅读体验。相对于更常见的左对齐，居中对齐可以更容易获得用户的注意力，因此在标题上、空页面的描述文本以及在插画的引导页上使用居中对齐可以更有效地抓住用户眼球。</p><h3 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h3><p>图标是操作系统与用户界面关键的视觉元素之一。图标应当具备直接识别关键信息或语义的特质，帮助用户轻松辨别图标所代表的含义。为了保证用户在不同的设备中视觉体验的一致性，在图标的设计上应当保持应用图标的元素一致，再根据不同的设备匹配对应的图标背板以适应于各种场景。除此之外，图标在颜色的使用上应当遵循 HarmonyOS 的色彩规则，满足用户阅读的舒适度以及整体界面的和谐程度。对于面状图标与线状图标的使用也应当遵循系统的设计规则，两种样式使用同一种图形结构，降低用户阅读时再次识别的成本。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTkxMjVkNDQ4YmFhY2NiMmJjNDFmYzFiZDNhZGQ5NTZfcWV3SWROVTZvRmhuNVp2Vml0TmF2VmZPWXBjcW02UlRfVG9rZW46Ym94Y25ZVlIwSkw2OVIxOEhmSmVUSXljZVpmXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h4 id="设计原则-1"><a href="#设计原则-1" class="headerlink" title="设计原则"></a>设计原则</h4><p>HarmonyOS系统图标追求精致简约、独特考究的设计原则，主要运用几何型塑造图形，精简线条的结构，精准把握比例关系。在造型和隐喻上增加年轻化的设计语言，使整体风格更加年轻时尚。避免尖锐直角的使用，在情感表达上给用户传递出亲近、友好的视觉体验。</p><h4 id="图形特征"><a href="#图形特征" class="headerlink" title="图形特征"></a>图形特征</h4><ol><li>描边粗细：1.5vp</li><li>终点样式：圆头</li><li>外圆角：4vp，内圆角：2.5vp</li><li>断口宽度：1vp</li></ol><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQzY2UyNzM2N2JlZjNlODQ5YzA0MzY4M2I2OGEwZDFfdUs1QkNvZnNTNTAwZ09LUEFWRU9nR3NZUVZIakQwTXpfVG9rZW46Ym94Y24zODRMU29UVDB6Zk1WaVM3dE9OYXNkXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p><strong>命名逻辑顺序样例： ic_模块_功能_位置_颜色_状态_数字</strong></p><p>ic_模块_功能，为必选项；位置_颜色_状态_数字，可根据实际情况选填。</p><p>注： 资源名要求全部为小写字母，长字段可以尽量用缩写，命名中不能有空格，不同字段之间以“_”分隔。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTBiYmVkYTM1MTM3ZDhmM2QzN2MyYWI4ZmEzMmRlYWJfRlU0TlhrWDdFVWEySkZQR0VVcEQ4b3ROVmlWaVZ4dzJfVG9rZW46Ym94Y254TWhDd3BuV1hHdEpWcVhhZ0xDM3lnXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h3 id="插画"><a href="#插画" class="headerlink" title="插画"></a>插画</h3><p>比起文字，插画可以用来表达更丰富的信息，通过视觉图像满足用户情感诉求的同时，更起到增强视觉冲击力和趣味性的作用。</p><p>HarmonyOS插画是友好的、令人愉悦的，容易被理解的。包含场景型和功能型两种类型。主要使用在以下场景：帮助引导页、启动页和欢迎页。</p><h4 id="场景型插画"><a href="#场景型插画" class="headerlink" title="场景型插画"></a>场景型插画</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWNlZjZhZTU2MGE3NjhiM2QxZDUyMTQzZWY4NzU5MTdfNnF1TTRhc25XUVVvOFJiUGhhcHROSEVRU2VkdGpTZnhfVG9rZW46Ym94Y25Qek5ScGZqd2RlUEZnRHNsN0hOeXZlXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NWMyMWE2MWVjYWNlNjIxOGRlOTljYzFkODZjNmM0NGRfcHhPeW1nQUhQWGlMYmpZazNLcTVMZmtsNmdCMVNrdVVfVG9rZW46Ym94Y25hdUtXSXpZMVlremhmZVhIQ1o1V3VjXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>深色主题</p><h4 id="功能型插画"><a href="#功能型插画" class="headerlink" title="功能型插画"></a>功能型插画</h4><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzlhYzQ0NjVjNTlmNzIxODRjNDFlNjFlYjM5NmY4ZThfZXdqR25XdGR1cTR2Z2ZGZFF0T0lUcnpYWllybTE1Tk1fVG9rZW46Ym94Y240b0JTRkVydVRrdnpTZWk0RUpMZVhkXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>浅色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODlmNzcxNTVlYmI0MGUyNGY5MDhkZDBhYmM0YTUxYTFfR0V1Q0syeTE1Z0I2dnV3NGx1Z1RhODlvNHJqNVhkQTFfVG9rZW46Ym94Y24xZkhHc3oxQnNxUlJIT2xuYlc1enFnXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>深色主题</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjg1M2ExYTg3OWU5ZWU3M2I1NDFjNTdlNDZjZjllMGNfWlZaTXZTUjlHWmZRWDdnQUlpU3dXY3JpQlBremwxbmlfVG9rZW46Ym94Y25TcWd5OEsxQWVZN0Z4TXltanpzV2tlXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>在浅色主题和深色主题上都能良好显示</p><p><strong>手和机模的组合使用</strong></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDQ5NzdiMjQzMDI0Y2NkNjU3ODYzMjBhNTU2ZTRlZjlfbkVSMjNNamRVbjVDbm5qa09EUmtwbXVsWEZMektjOW5fVG9rZW46Ym94Y25GZnV1MjExYWxjTWtTWWJ0WXRGZDFiXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p><strong>动态交互手势</strong></p><ul><li><p>动态插画可单独使用</p></li><li><p>静态插画可搭配箭头、手共同使用</p></li></ul><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>布局不是静态固定的，当显示环境发生变化时，如横竖屏切换、调节字体大小、应用分屏时，我们需要及时调整内容的布局方式以适应变化。了解布局的基础概念后，通过自适应布局和响应式布局就可以让你的内容更好地适配显示环境的变化。</p><h4 id="布局基础"><a href="#布局基础" class="headerlink" title="布局基础"></a>布局基础</h4><h5 id="8vp网格系统"><a href="#8vp网格系统" class="headerlink" title="8vp网格系统"></a>8vp网格系统</h5><p>基于 8vp 为网格的基本单位可以对界面上元素的大小、位置、对齐方式进行更好的规划，构建更有层次感、秩序感，以及多设备上一致的布局效果。一些更小的控件（例如图标）大小也可以对齐 4vp 的网格大小。</p><h4 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h4><p>栅格系统是一个多设备下通用的辅助定位系统，有 Margin，Gutter，Column 三个属性构成。其中 Column 是根据设备的水平宽度自动匹配的（规则见栅格断点系统）。通过栅格系统进行布局，可以达到多设备下布局的一致性。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTE2ODg2NTkyM2Q4Mzk0NmMyNDk4NDU1NWExN2JiNmZfVVFVZnhZdmdUOTk5bUIweENSWjlaM3lSOEI0VDZCa05fVG9rZW46Ym94Y25uOTkwalZldTVabTJoRFhFQ3Z5ZWVlXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h5 id="栅格断点系统"><a href="#栅格断点系统" class="headerlink" title="栅格断点系统"></a>栅格断点系统</h5><p>根据设备的水平宽度，栅格系统定义了对应 Column 的数量关系。不同的设备根据自身屏幕水平宽度 在不同的断点范围，系统将自动匹配不同数量的栅格。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YjBlOTg0ZjIwOGI0MTg3MGU2ZGNhNzk1ODczN2QzNDJfRXcyanNUVnczb05oaFdxY2tWMGtlSDg5c2thS01nR29fVG9rZW46Ym94Y25lWnR1MzlpR2lBUGloVzVGV1RBQlRmXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h4 id="自适应布局"><a href="#自适应布局" class="headerlink" title="自适应布局"></a>自适应布局</h4><p>自适应布局是通过设定元素与外部容器的相对关系达到的。当外部容器大小、位置等发生变化时，元素即可以根据相对关系自动变化以适应外部环境的变化。</p><h5 id="自适应拉伸"><a href="#自适应拉伸" class="headerlink" title="自适应拉伸"></a>自适应拉伸</h5><p>文本的显示宽度不是固定值，而是通过相对参照物的方式来确定其显示宽度。当参照物的宽度发生变化时，文本的显示宽度随之发生自适应拉伸。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjQxNjMwOWVlZGJkNGFhNDQxNTUwODYxODcxMDIzOTVfNFE1dkVCekhNMk9kUDV5R2xWc3piTGxmTUVpSHJpd0xfVG9rZW46Ym94Y25GcDh4dWNDS0pOelhtUmd0eThpb1dmXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h5 id="自适应缩放"><a href="#自适应缩放" class="headerlink" title="自适应缩放"></a>自适应缩放</h5><p>组件的显示大小是固比例，通过相对参照物的方式来确定其宽或高。当参照物的大小发生变化时，元素的大小随之发生自适应缩放。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDljNzI0YzMwMGUwOWNiY2Q3OTI1MTA1ZjBhNWNhMDRfb3hjNFR4bzhqb1Q1cnNtYm1kRmMwNVkxd0FxbkZGTHJfVG9rZW46Ym94Y25ReTQzUnBrekZqcGp6bkhOZ091Q2piXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h5 id="自适应延伸"><a href="#自适应延伸" class="headerlink" title="自适应延伸"></a>自适应延伸</h5><p>组件的数量不是固定的，而是通过相对参照物的方式来确定其显示数量。当参照物的宽度发生变化时，组件随之发生自适应延伸显示更多数量。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGRkYzVlNTkxM2RkMmVmZjdhYzg0ZDc4NDJjOWNkZmZfV2VyNmNZMTVKdXUwYm5XaFhVTFUzcHBDaERiajV0U1lfVG9rZW46Ym94Y25qSFhaSm8xUzh2dmVEWUUwMWVzNThDXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h4 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h4><p>当基本的自适应布局无法满足多终端上屏幕的体验要求时，我们需要针对不同终端的屏幕特点进行响应式的布局。常见的响应式布局样式有：分栏布局、重复布局、挪移布局和缩进布局。</p><h5 id="分栏布局"><a href="#分栏布局" class="headerlink" title="分栏布局"></a>分栏布局</h5><p>利用屏幕的宽度优势，将有上下级层级的界面同时左右显示。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjYyNjJkMjYyOTM2OWUyY2VkMjMwNjUxZjI4MDExZTJfN1BxelBOUnhOVGZWWW11NlpCb1pjejZvOEYyNnhmRlBfVG9rZW46Ym94Y25aeDVtQnVIb0ltM0JJTXNxVldxTDNmXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>当栅格为8column或12column时可以响应分栏布局。</p><h5 id="重复布局"><a href="#重复布局" class="headerlink" title="重复布局"></a>重复布局</h5><p>利用屏幕的宽度优势，将相同属性的组件横向并列排布。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OWU4OTNmZDU5YjhlYWU4Yzg1ZTUxNzU0NjZiYjZjYmJfS3RHczJXcWthbjQwNm1pMWpZWG1xZkdta2I1NFdBM3BfVG9rZW46Ym94Y25ISUNxaUYwdkR4Y05BUFhUdWtKSndjXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>当栅格为8column或12column时可以响应重复布局</p><h5 id="挪移布局"><a href="#挪移布局" class="headerlink" title="挪移布局"></a>挪移布局</h5><p>利用屏幕的宽度优势，将原先的上下布局切换成左右布局。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzZjMTY3ZjUwNmU1YmQ4Zjc1N2M1YjZmYjQyZjUxMzRfYklTVGd5ZE9ESHo5TXIyNWVSbVAzaEtqQ2JDZWUzdUNfVG9rZW46Ym94Y25OeTZHVTk5NXd1V0RFMHBQVVdHZHFnXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h5 id="缩进布局"><a href="#缩进布局" class="headerlink" title="缩进布局"></a>缩进布局</h5><p>为了在宽屏上内容显示有更好的效果，在不同宽度的设备上进行不同缩进效果。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDA5MmY0ZDRiOWZkNDc3YmY4NTBkYzY4ZDExYjY5M2FfeXQ5MkMzVDBrWTQ0bWsxUVlWdURlYVowQ2gzVjV4WXNfVG9rZW46Ym94Y25VNkZLdG4ybk0yWnphQnJkS0JqTGhjXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h2 id="动效"><a href="#动效" class="headerlink" title="动效"></a>动效</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>HarmonyOS 动效引力体系，围绕回归本源设计理念，打造自然、流畅、品质一体的操作体验。</p><p>“引力”是自然中普遍存在的一种力，作用于万物并在其中表现出丰富多样的形态。我们将其提炼转化并运用于操作系统的动效设计中。在特征动效中呈现出天体运动“力”的即视感；转场动效表现出物体在运动过程中“力”的秩序感；手势动效打造出元素运动互相影响“力”的控制感。</p><h3 id="设计原则-2"><a href="#设计原则-2" class="headerlink" title="设计原则"></a>设计原则</h3><p>在设计动效过程中，要清楚地理解动效在系统中承载的作用，动效能体现页面的流畅过渡、对象的明确提示、元素的层级关系、产品的品牌印象等。动效要始终围绕操作符合用户心理预期，物体运动符合真实世界，元素表现形态凸显产品的品牌与调性。</p><p><strong>自然流畅</strong></p><p>流畅性是人对加工信息难易程度的一种主观体验，它指手势触控、视觉感知、心理预期三者合一的综合体验。帧率稳定、响应及时、跟手操作是动效流畅体验的基础要求。</p><p><strong>简洁高效</strong></p><p>界面元素运动尽可能少且简洁，减少路径及不必要的元素，快速的完成用户的任务，体现性能的快。物体运动到动效设计上，界面元素越多用户所消耗的时间就越长，容易造成慢的体验。</p><p><strong>快速响应</strong></p><p>高效响应并减少过长的位移和时间。如长距离保持在350ms内，短距离保持在250ms内，较短的动画保持在150ms内完成动作，整体体现动画快速呈现。</p><p><strong>运动一致</strong></p><p>在动作编排时应遵循运动路径方式一致，避免不一致的运动来分散用户视觉焦点，运用适当的编排手法，引导用户聚焦操作任务。</p><p><strong>凸显品牌</strong></p><p>通过动效设计为产品增加亮点，它可以为产品带来惊喜的体验及凸显品牌的气质，使它赋予生命力，让产品脱颖而出。通过系统级的元素特效设计，将某一种特效属性贯穿到适合的界面中，营造品牌的氛围感，例如拖尾、融球、发光、磁吸等效果。</p><h3 id="动效属性"><a href="#动效属性" class="headerlink" title="动效属性"></a>动效属性</h3><p>任何类型的动效都包含三大基本的动效属性：时长、曲线、帧率。这些基本属性形成了动效不可缺少的基本要素。通过组合这些基本的动效属性，可以塑造产品动效的不同风格特点，例如稳重、活泼、轻盈、舒缓等。</p><h4 id="时长"><a href="#时长" class="headerlink" title="时长"></a>时长</h4><p>时间是产生动效的基本要素，不同类型的元素、场景适用不同的时长，过短或太长都会让用户不适。以下因素详细说明了时长应如何设计以适应不同类型的动效。</p><p><strong>单位</strong></p><p>动效设计的时长单位一般使用毫秒（ms）表示，1秒=1000毫秒。在帧率（FPS）60帧的环境下，1帧=16.67毫秒。</p><p><strong>复杂程度</strong></p><p>复杂的动画比简单的动画需要更多的时间来表达，基于图形的特点来进行动画设计。</p><p><strong>区域范围</strong></p><p>动效运动在一定的范围内进行，小范围内比全屏幕运动所用的时间相对更短。</p><h3 id="曲线"><a href="#曲线" class="headerlink" title="曲线"></a>曲线</h3><p>曲线与时长相互配合产⽣运动的韵律感。调整曲线能使物体实现加速和减速，⽽不是以恒定的速率运动。在自然定律下，物体不会突然开始或停止移动，它们需要一定的时间来加速和减速。</p><p>没有缓和曲线的过渡看起来僵硬和机械</p><h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><p>贝塞尔曲线(Bézier curve)是一种数学曲线，在动效设计中广泛使用。从曲线形态的类型上可以分为这几类：标准曲线、减速曲线、加速曲线。</p><p><strong>标准曲线</strong></p><p>最常用的曲线类型，开始和结束处静止，速度峰值在中段，加速阶段相对于减速阶段用时更少。</p><p>使用原则：运动前后始终在用户视线范围内的物体，符合物体启动和停止的真实规律。</p><p>应用场景：图片缩放，Tab切换，Switch开关等。</p><p><strong>减速曲线</strong></p><p>开始处物体运动速度最快，初始即达到峰值速度，渐渐变缓，在结束处完全静止。</p><p>使用原则：适用从视线中新出现的物体，结束时通过相对较长的缓冲让人眼适应运动变化。</p><p>应用场景： 弹框出现等。</p><p><strong>加速曲线</strong></p><p>从静止启动，逐渐加速，在达到峰值速度时结束（出场）。</p><p>使用原则：适用原本在视线中的物体，需要消失或出场，逐渐加速符合退场行为特征。</p><p>应用场景：窗口出场、卡片删除等。</p><h4 id="弹性曲线"><a href="#弹性曲线" class="headerlink" title="弹性曲线"></a>弹性曲线</h4><p>弹性曲线(Spring curve)是一种物理曲线，它可以将速度值作为参数输入到曲线公式里，因此同一组参数在不同速度下可以产生差异化的曲线表现；同时弹性曲线通过刚性和阻尼等物理属性参数，产生自然的弹簧效果。</p><p>使用原则：适用于进行跟手运动的对象，或是需要表现弹簧特性的对象。</p><p>应用场景：列表上下滚动、桌面左右翻页、手势上滑退出应用等。</p><p><strong>临界阻尼</strong></p><p>当阻尼使对象刚好能不产生振动，又以最短时间到达稳定平衡状态的情况。</p><h3 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h3><p>每秒钟显示的帧数即帧率（FPS）。由于人眼的特殊生理结构，所看画面帧率一般高于每秒约10~12帧，就会认为是连贯的，该现象为视觉暂留。但连贯不代表感知流畅，运动较快的动画需要更高的帧率来保障流畅度。</p><p>相同时间和位移距离情况下，不同帧率效果对比（90FPS和120FPS受浏览器播放器的限制，可能无法看出差异）</p><p><strong>交互类动效帧率</strong></p><p>移动设备的屏幕一般使用60赫兹刷新率，动画帧率与其保持一致能让动效呈现最好状态。与观看类动画不同，交互型动效需要更严苛的帧率稳定性，否则易造成体验上的卡顿感受。</p><p><strong>纯动画帧率</strong></p><p>纯动画（如操作引导动画）的帧率要求没有交互类动效那么严苛，早期迪士尼的手绘动画基本帧率是24FPS，也能满足观看流畅的程度。高帧率的动画则拥有更细腻的视觉体验，特别是针对快速类的动作，细腻度尤为明显。有些动画创作会选择8FPS，这更多的是动画风格上的需要。</p><h3 id="风格"><a href="#风格" class="headerlink" title="风格"></a>风格</h3><p>通过调整时长、曲线的参数，在转场、特征等动效设计上的差异来表达品牌的动效设计语言。例如较多地使用弹性动画会让产品的动效风格显得更加灵动和活泼。</p><h3 id="特征动效"><a href="#特征动效" class="headerlink" title="特征动效"></a>特征动效</h3><p>特征动效比其他动效类型有更强烈的动画视觉风格，能让用户感受到鲜明的个性，以及动画本身所传递的魅力，在传递产品设计理念中起着关键的作用。</p><h4 id="引力特征动效"><a href="#引力特征动效" class="headerlink" title="引力特征动效"></a>引力特征动效</h4><p>打造 “天体拟物感知”。</p><h4 id="实例场景"><a href="#实例场景" class="headerlink" title="实例场景"></a>实例场景</h4><p>将抽象特征结合视觉进行实例化，在产品相应场景上使用，增强引力特征动效感知。</p><h4 id="开场动画"><a href="#开场动画" class="headerlink" title="开场动画"></a>开场动画</h4><h3 id="转场动效"><a href="#转场动效" class="headerlink" title="转场动效"></a>转场动效</h3><p>衔接页面与页面间或元素与元素间的过渡动画称之为转场动效，帮助用户理解界面以及元素之间的逻辑关系，例如应用打开动效、日程切换动效等。在 HarmonyOS 的转场动效设计上，我们推出了一镜到底的高级转场设计手法，在提升视觉流畅性的同时也增强了动效的品质感。</p><h4 id="层级关系"><a href="#层级关系" class="headerlink" title="层级关系"></a>层级关系</h4><p>层级关系由系统架构和应用架构定义，它确定了转场动效的交互目的。不同的转场设计会传递不同的交互层级隐喻，不合理的动效编排会让用户误解，从而导致用户主观感受下降，流畅体验感较差。在设计转场动效时，首先要理解应用之间和页面元素之间的架构关系，再运用合适的设计手法完成动效设计表达。</p><h4 id="同层级"><a href="#同层级" class="headerlink" title="同层级"></a>同层级</h4><p>转场后的页面或元素与当前的在同一层级上。</p><p>应用场景：编辑操作、页签切换、横竖屏转场等</p><h4 id="上下层级"><a href="#上下层级" class="headerlink" title="上下层级"></a>上下层级</h4><p>转场后的页面或元素与当前的存在上下层级关系。</p><p>应用场景：上下级页面切换、解锁操作、搜索转场等</p><h3 id="跨层级"><a href="#跨层级" class="headerlink" title="跨层级"></a>跨层级</h3><p>适用于应用之间的跳转。</p><p>应用场景：从一个应用跳转到其他应用操作</p><h4 id="运动编排"><a href="#运动编排" class="headerlink" title="运动编排"></a>运动编排</h4><p>在界面变化过程中，将各个部分元素进行分类，协调相互之间的运动方式，使整个过程自然流畅，并合理引导用户的注意力。</p><h5 id="场景解构"><a href="#场景解构" class="headerlink" title="场景解构"></a>场景解构</h5><p>转场是由交互行为引起的界面变化，分析界面元素在过程中的意义，定义其在转场中所在的类型，并将它们进行分类，元素所属的类别会影响它们使用怎样的转场方式，同时也将决定用什么类型的曲线和时长。</p><ul><li><p><strong>进场元素</strong>：转场中新出现的元素，一般是结果界面上的构成元素。</p></li><li><p><strong>出场元素</strong>：转场中消失的元素，一般是上一界面中的构成元素。</p></li><li><p><strong>持续元素</strong>：转场中持续存在的元素，可以是元素在布局上的变化，也可以是某种连续性的动画效果，整个过程无中断。</p></li><li><p><strong>静止元素</strong>：转场中无任何变化的元素。</p></li></ul><h4 id="一镜到底"><a href="#一镜到底" class="headerlink" title="一镜到底"></a>一镜到底</h4><p>一镜到底是通过共享元素、容器和动势来进行转场过渡的一种编排方式，有助于提升用户操作任务的效率，增强视觉的流畅感，是转场设计中重点推荐的技法。</p><ul><li><p>共享元素</p></li><li><p>共享容器</p></li><li><p>共享动势</p></li></ul><p><strong>共享元素</strong></p><p>共享元素一般是转场前后持续存在的界面元素，即上文提到的持续元素，是在转场发生后希望用户关注到的焦点元素，它增强了转场的连续感。</p><p><strong>共享容器</strong></p><p>当一组元素在过渡时包含明确的边界，可使用容器来让转换过程有连续感。容器通过大小、高度、圆角等属性进行补间过渡转换，容器内的元素可通过淡入淡出或共享元素的手法进行过渡。</p><p><strong>共享动势</strong></p><p>无中间属性，无法通过补间变化来实现柔和过渡，需要提取出可用的共享转换属性，来实现前后的平滑过渡。常用的共享运动属性有位移、缩放、旋转等。</p><h4 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h4><p>淡入淡出是通过透明度变化来实现过渡转场，适用于无中间属性的组件或元素之间进行过渡变化，可参考以下手法：</p><p><strong>单向淡入淡出</strong></p><p>在前后层叠的场景中，只有前景元素进行淡入或淡出动作，下方元素无变化。</p><p><strong>交叉淡入淡出</strong></p><p>存在出场元素与进场元素的场景下，根据元素图形特点进行淡入淡出效果处理。一般进出场元素样式一致或近似，可考虑使用同时进行透明度变化的方式；视觉样式上不同类型的进出场元素，为避免交叠状态带来视觉上的混乱，可适当错开出场元素淡出和进场元素淡入的时机。</p><h3 id="多设备编排设计"><a href="#多设备编排设计" class="headerlink" title="多设备编排设计"></a>多设备编排设计</h3><p>原则：符合人因，避免动效引起的不适感。</p><p>同一类型的动效下，编排方式不一样。例如手机和智慧屏上的差异，手机上使用图标到界面共享容器的方式；智慧屏上采用共享动势的方式来避免过大的位移路径给用户带来不适感</p><h3 id="手势动效"><a href="#手势动效" class="headerlink" title="手势动效"></a>手势动效</h3><p>手势动效是指手在终端屏幕或触摸板等输入设备上进行跟手操作的动效，大致分为点击、滑动、拖拽等手势，典型的实例场景有手势导航上滑、捏合照片等操作。我们主张无阻塞感的动效设计，结合运用 HarmonyOS 动效物理引擎，将自然属性运用到界面的操作中，比如摩擦力、弹性、碰撞影响等。</p><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>手势动效的设计是为了用户在使用交互手势时，交互对象与用户手势建立流畅的操作反馈感，通过弹性曲线等物理模型，还原真实可行的手势操作体验。聚焦在手势操作的常用几个类型：</p><ul><li><p>点击</p></li><li><p>滑动</p></li><li><p>翻动</p></li><li><p>夹捏</p></li><li><p>拖拽</p></li></ul><h4 id="点击"><a href="#点击" class="headerlink" title="点击"></a>点击</h4><p>点击手势通常包含两个行为：按下（touch down）和抬起（touch up）。按下接触过程平均时长100~130ms中，这期间对象无反馈，为提升响应速度，点击手势动效设计在按下那一刻即响应动效反馈，这一可先行的触控响应机制强化了界面元素的视觉反馈，为用户理解界面状态提供了更多的线索信息。</p><h4 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h4><p>滑动手势是指手抬起时带有方向和速度的动作。以列表样式场景为例，主要分为跟手阶段、离手瞬间、离手后阶段这三大部分，跟手阶段着重对象的跟手响应性；离手瞬间需要对象继承手速进行离手后的动画反馈，保证对象动效反馈的结果与手势动作的连贯性是滑动手势动效设计的关键。</p><h4 id="翻动"><a href="#翻动" class="headerlink" title="翻动"></a>翻动</h4><p>翻动通过抛滑和拖拽手势进行操作，由翻页这类场景承载。翻页是基于设定区域进行对象内容的翻动切换，离手后对象不会处于任一坐标位置上，有明显的限位属性，页在这里等同于设定区域。翻页有成功与否，未成功会停留在当前内容上；成功则显示下一页/几页的内容。为了提示性，翻页也有过界拖拽的场景</p><h4 id="捏合"><a href="#捏合" class="headerlink" title="捏合"></a>捏合</h4><p>捏合手势是指双/多指合拢或分开的动作，是自然手势的重要体现，分为跟手阶段、离手瞬间、离手后阶段这三大部分，跟手阶段着重对象的跟手响应性，对象需要基于手势动作进行缩放、旋转、移动等反馈；离手瞬间需要对象继承手速进行离手后的动画反馈</p><h4 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h4><p>拖拽手势是指手指按下同时进行移动的动作，动效设计了对象通过拖拽行为进行状态转换的整个过程，这其中包括跟手阶段显控比设计；离手后对象运动曲线以及属性变化设计。</p><ul><li><p>标题联动</p></li><li><p>左右横滑联动</p></li><li><p>下拉返回</p></li></ul><h5 id="标题联动"><a href="#标题联动" class="headerlink" title="标题联动"></a>标题联动</h5><p>对象主内容区与标题区的联动设计，在主内容区到达顶部边界时继续进行拖拽操作，除了主内容区因过界显控比设计产生的阻尼感，上方的标题区与其产生不同阻尼感的联动设计，让过界拖拽体验更灵动并富有层次感。</p><h5 id="卡片左右滑"><a href="#卡片左右滑" class="headerlink" title="卡片左右滑"></a>卡片左右滑</h5><p>卡片横向滑动可扩展更多功能，显控比设计让横向拖拽手势在一定距离后产生阻尼感，提示并引导用户进行后续操作。</p><h5 id="下拉返回"><a href="#下拉返回" class="headerlink" title="下拉返回"></a>下拉返回</h5><p>下拉过程中加入递进的显控比设计，渐强的阻尼感让对象的拖拽手感更富有质感。离手后对象继承手速并按设定进行动画反馈。</p><h3 id="微动效"><a href="#微动效" class="headerlink" title="微动效"></a>微动效</h3><p>图标微动效一般指系统的小图标动效，主要增强用户操作趣味性，强化操作提示，在适当的场景增加夸张的动态设计，有助于提升产品的趣味性与品质感，如面板开关图标微动效、底部栏图标动效。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>微动效设计一般用于图标和小组件上，主要增强用户操作趣味性，强化操作提示。</p><h4 id="合理设计"><a href="#合理设计" class="headerlink" title="合理设计"></a>合理设计</h4><p>基于图形视觉特点来进行动画脚本的设计，尽量不增加多余的动画细节从而过多的分散操作注意力和影响交互效率。</p><h4 id="动画时长"><a href="#动画时长" class="headerlink" title="动画时长"></a>动画时长</h4><p>简单或复杂的动画一方面是设计风格的选择，另一方面也基于图形特点的动画设计。复杂的动画比简单的需要更多时间来表现，以下是建议值：</p><ul><li><p>简单动画：50~100ms</p></li><li><p>一般动画：150~300ms</p></li><li><p>复杂动画：350~1000ms</p></li></ul><h3 id="插画动效"><a href="#插画动效" class="headerlink" title="插画动效"></a>插画动效</h3><p>具有特定的时尚插画视觉风格的动效场景，一般出现在功能的引导页，以引导教学为主，增加插画浏览体验的理解和愉悦感。可以运用多样的设计与开发方式，以权衡当前的内存与性能表现。</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><p>通过动画的方式丰富视觉元素所要表达的信息，并串联前后画面，便于用户理解，也使画面表现更富有生命力。</p><ul><li><p>引导解读功能信息</p></li><li><p>生动表现插画内容</p></li><li><p>传递品牌风格调性</p></li></ul><h4 id="设计原则-3"><a href="#设计原则-3" class="headerlink" title="设计原则"></a>设计原则</h4><ul><li><p><strong>匹配静态视觉风格</strong>：图形、配色、肌理等视觉手法形成插画风格，动画在设计时需要考虑适合的相关类型，以免产生不和谐的突兀感。</p></li><li><p><strong>符合基本运动规律</strong>：插画中会有各类元素和物件，需要考虑元素本身的特质来制作动画，保证动画效果自然且令人信服。</p></li><li><p><strong>满足动画流畅帧率</strong>：观看插画动效的帧率通常不低于30FPS，有快速运动元素的可能需要更高的帧率来满足帧间距符合人眼舒适性体验。</p></li><li><p><strong>关注头尾衔接循环</strong>：部分动画需要用户操作才会切换，这之前动画通过循环播放来避免停滞发生。</p></li></ul><h4 id="功能引导类"><a href="#功能引导类" class="headerlink" title="功能引导类"></a>功能引导类</h4><p>这类插画动效是为了清晰地向用户介绍功能如何使用，一般由操作动画和界面动画两大部分组成，简单明了的动画设计是这类动画的基本要求。</p><h4 id="场景介绍类"><a href="#场景介绍类" class="headerlink" title="场景介绍类"></a>场景介绍类</h4><p>通过动画让画面更加生动，更好地传递视觉语言，易于用户理解同时增加观看的愉悦感。</p><h2 id="声音"><a href="#声音" class="headerlink" title="声音"></a>声音</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>声音设计以提升用户听觉体验及优化信息传达方式为主要目的，在人机交互中提供反馈信息，并增强用户的感官与情感体验。</p><h4 id="设计原则-4"><a href="#设计原则-4" class="headerlink" title="设计原则"></a>设计原则</h4><ul><li><p><strong>自然流畅的</strong>：好的声音表现应该可以给用户提供足够的舒适与安全感受，符合客观使用场景及主观心里预期，在频繁播放和功能切换时没有突兀的响度变化和非必要的“噪音”存在。</p></li><li><p><strong>通用的</strong>：声音的功能性应足够直观且易于理解，层次上足够清晰并具备设计上的可延展性，即在保有个性化功能特质作用的同时满足多场景需求，调性统一。</p></li><li><p><strong>品质的</strong>：声音设计的听觉体验应符合具体产品定位及声学美学特征，各频段间的平衡处理方式和采样大小选择需针对终端硬件播放媒介做合理取舍， 最优化混音方式。</p></li></ul><h4 id="多设备场景"><a href="#多设备场景" class="headerlink" title="多设备场景"></a>多设备场景</h4><p>人因研究实验表明，生活场景噪音对终端硬件声音存在一定的掩蔽效应，即随着响度的升高而增大，且人耳对不同频率段敏感度不同，着重提升硬件音频1K-3KHz的频段响应有助于提高声音的主观辨识度。</p><ul><li><p><strong>移动及穿戴设备</strong>：手机、智能手表及平板等终端设备受自身音腔大小限制，低频单元反馈明显受限，且硬件性能差别导致设备间存在明显的频段响应差异，因此针对性的声音校准是必要的调试过程。</p></li><li><p><strong>汽车及家居智能设备</strong>：汽车座舱和大型智能家居如智能电视等设备具有较平直的全频段反馈曲线，相较于移动穿戴设备有更丰富的低频动态响应，一般可支持多声道环绕系统，对音频设计缩混规格有一定要求。</p></li></ul><h4 id="类型及规范"><a href="#类型及规范" class="headerlink" title="类型及规范"></a>类型及规范</h4><p>以手机为核心的终端产品一般会有四种声音类型：提示类、交互类以及铃声和闹铃。每一种类型的声音都可以以不同的方式对信息和品牌标识进行传达，在听觉维度赋予其个性美感。</p><h4 id="提示类音效"><a href="#提示类音效" class="headerlink" title="提示类音效"></a>提示类音效</h4><ul><li><p>长度：＜3秒（00:00 ：03:00），（建议原则）。</p></li><li><p>提示音 ：根据系统功能性触发（必要原则）。</p></li><li><p>作用特征：提示音通常用于表示系统级信息、动作及事件，可以增强产品的美学和情感表现，赋予品牌个性。</p></li></ul><p>范例：</p><ul><li><p>通知提示：用于系统级通知及事件提醒，声音短促适合频繁播放。</p></li><li><p>成功提示：用于表现事件的达成，如下载成功、任务完成等，常用和谐的上行的音阶化织体表现。</p></li><li><p>失败提示：用于预警的信息传达，如电量不足，传输失败等，保证声音舒适度的同时使用不和谐的音阶符合心里预期。</p></li></ul><h4 id="交互类音效"><a href="#交互类音效" class="headerlink" title="交互类音效"></a>交互类音效</h4><ul><li><p>长度：＜1秒（00:00 ：01:00），（建议原则）。</p></li><li><p>交互音 ：根据用户交互动作触发（必要原则）。</p></li><li><p>作用特征：交互音通常作为操作动作和状态的即时反馈，可以辅助提升产品的视觉传达效果和使用体验。</p></li></ul><p>范例：</p><ul><li><p>触屏音：常以声音合成方式对用户点击、划动等操作动作进行补充，如按键输入、音量调节等。</p></li><li><p>拍照音：常以真实物理或拟物化声音对用户拍摄场景进行补充，如快门、参数调节等。</p></li></ul><h4 id="铃声"><a href="#铃声" class="headerlink" title="铃声"></a>铃声</h4><ul><li><p>长度：20秒左右（00:00 ：20:00），（建议原则）。</p></li><li><p>铃声：在来电时可循环播放的铃声 （必要原则）。</p></li><li><p>作用特征：铃声的声音表现通常含有较明显的产品和品牌调性，常规设计中以器乐化、旋律简洁化为主。</p></li></ul><h4 id="闹铃"><a href="#闹铃" class="headerlink" title="闹铃"></a>闹铃</h4><ul><li><p>长度：40秒左右（00:00 ：40:00），可结合设计风格类型进行调整（建议原则）。</p></li><li><p>闹铃 ：在闹铃时可循环播放的铃声 （必要原则）。</p></li><li><p>作用特征：闹铃的声音表现需要兼顾提醒功能和听觉舒适度两个层面，具有一定的音乐性，对比铃声的声音表现更加的柔和。</p></li></ul><h3 id="设计属性"><a href="#设计属性" class="headerlink" title="设计属性"></a>设计属性</h3><h4 id="音乐化"><a href="#音乐化" class="headerlink" title="音乐化"></a>音乐化</h4><p>音乐主要用于在UI设计环节中增添情绪，由明确的乐音成分做功能性用途，也可与图像或动作匹配。</p><p>音乐在UI中的主要用途：</p><ul><li><p><strong>引起情感共鸣</strong>：音乐上的期待感是激活奖励系统的关键因素，通过不同的节奏强度和对高低频段的差异处理等方式可以与听者建立有效的情感链接。</p></li><li><p><strong>表现产品调性</strong>：音乐的风格、展现形式以及特征元素通常与产品的整体定位相吻合，便于传达品牌信息。</p></li><li><p><strong>叙事性功能</strong>：通常上扬的音阶具有“成功”、“达成”等积极性暗示，下降的音阶具有“紧急”、“关闭”等终止性暗示。</p></li></ul><h4 id="音效化"><a href="#音效化" class="headerlink" title="音效化"></a>音效化</h4><p>音效可以增强视觉化信息的表现能力，也可建立独立的用户交互反馈方式。</p><p>音效在UI中的主要用途：</p><ul><li><p><strong>将交互场景与特定声音关联</strong>：声音具有可被记忆的属性，将场景与声音进行搭配链接有利于降低用户记忆成本并优化操作体验。</p></li><li><p><strong>表达情感及个性</strong>：在UI设计中对音效差异性有着鲜明的诉求，这种抽象的声音表现通常由拟音或合成等方式作为原始材料。</p></li><li><p><strong>增强感官反馈</strong>：音效可对用户的听觉反馈层面进行补充，有利于产品使用体验的多感官效果提升。</p></li></ul><h4 id="噪音（避免）"><a href="#噪音（避免）" class="headerlink" title="噪音（避免）"></a>噪音（避免）</h4><p>在UI设计场景中的“噪音”通常指一类容易引起用户烦躁或干扰性的声音。</p><p>常见的引起方式：</p><ul><li><p><strong>电流噪音</strong>：电流声是电子元器件的不规则运动导致的被放大的电信号，在设计中主要是由不当的拾音过程导致。</p></li><li><p><strong>响度问题</strong>：输出音频的响度应根据功能需求保持在合适区间，过高或过低会造成“削波”或频段细节缺失，影响最终声音品质。</p></li><li><p><strong>格式问题</strong>：最终音频输出的格式和大小与声音精度和频率问题息息相关，平衡容量大小和避免失真两方面通常需要兼顾考量以最大化产品性能</p></li></ul><h3 id="声音优化"><a href="#声音优化" class="headerlink" title="声音优化"></a>声音优化</h3><h4 id="效果调试"><a href="#效果调试" class="headerlink" title="效果调试"></a>效果调试</h4><p><strong>均衡</strong>（频段均衡）</p><p>声音的简单塑形可通过均衡“EQ”实现，其对材料上的处理方式更接近合成器中的滤波器模块，主要目的是通过频段的衰减改变音色。</p><p><strong>混响</strong>（空间感）</p><p>混响是由空间内的直达声以及大量的反射声产生，且受到空间材质的影响不易被察觉，大部分的混响效果处理都是使用特定的算法来模拟声音传播的方式，对声音本身可以增加其空间感，改变其个性，同时可以填充时间或者解决掩蔽效应。</p><p><strong>延迟</strong>（时间反馈）</p><p>延迟效果在设计中主要起到点缀性作用，有反馈延迟和多段延迟两类，区别方式在于使用一个还是多个延迟单元，最基础的两个参数即延迟时间和反馈强度，二者分别决定每一次延迟声音时间上的间隔和声音总的延迟次数。</p><p><strong>压缩</strong>（动态范围）</p><p>压缩效果主要的作用是改变响度的强弱从而减少或压缩音频信号的动态范围，除了声音塑形外针对单个声音材料最重要的是限制器的参数，可以一定程度上的平衡前期拾音过程中每个音频的响度。</p><h4 id="音频格式及输出"><a href="#音频格式及输出" class="headerlink" title="音频格式及输出"></a>音频格式及输出</h4><p><strong>最优化音频输出</strong></p><p>音频文件的最终播放效果会依据不同的硬件产品和软件功能限制而产生变化，需要遵循以最小质量降低的原则进行文件大小的缩减，两者之间通常要进行一定的取舍。</p><p>常见优化声音文件大小的方式是降低采样深度和精度，也可以在文件的起始和结尾处删减掉多余的空白部分减少文件大小，在进行有损压缩的同时需要从主观听觉及客观数值两方面对声音表现进行衡量，避免出现音色变化。</p><p><strong>格式建议</strong></p><p>音频的最终输出格式取决于播放的硬件产品以及系统级别的限制，应优先选择系统及硬件所兼容的最佳音频格式，声音细节可以充分表现，避免压缩格式中低到高的无效转换</p><h3 id="其他要素"><a href="#其他要素" class="headerlink" title="其他要素"></a>其他要素</h3><p><strong>音乐感受</strong></p><ul><li><p>声音利于记忆不过于繁杂</p></li><li><p>运用传统调性音乐体系</p></li><li><p>符合广义各年龄层审美通用化</p></li></ul><p><strong>声音质量</strong></p><ul><li><p>使用高保真文件或实时录音采样是保证声音高质量输出的前提条件。</p></li><li><p>通过各类合成技术的调试进行声音设计时需要充分考虑设备音响性能。</p></li></ul><p><strong>频段</strong></p><ul><li><p>人耳能感知到的频率范围大致在20-20KHz，但随着年龄的增长通常会逐渐衰减，在老年人群体中尤其明显。</p></li><li><p>声音由振动产生，也就意味着频率越高声音越高昂尖锐，相对的频率越低声音越低沉压抑。</p></li><li><p>在声音调试中，最重要的是要依需求保证各频段的相对平衡，即高频不过分刺耳，低频不过分浑浊。</p></li></ul><p><strong>技术制约</strong></p><ul><li><p>手机具有比较小的扬声器来播放铃声和音频，所以在手机等移动设备创作声音或铃声时需要关注设备的频率范围。</p></li><li><p>在移动设备上比较突出的频率从在500hz左右到16khz左右，比较平坦的频响曲线从250hz - 4khz左右，对于复音数较多的乐器需要慎用，对于人声需要进行齿音等处理再进行效果对比听辨</p></li></ul><h2 id="多态控件"><a href="#多态控件" class="headerlink" title="多态控件"></a>多态控件</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>为了支持1+8+N设备，应用需要能够在不同的设备上运行，控件作为应用的基础组成部分，需要支持不同的设备，且在视觉、交互、动效等表现形式上针对设备进行必要的调整，达到最佳体验。因此，同一控件在不同的设备上会呈现出不同的形态，称为多态控件。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWUzMmU5MzVlY2UyM2ViZjQ4NmY1YzJiNWIzYTAwMzRfeWdONG5TRENvMkFNZEFvdjFxM1ptUVpPeGVKUDdtWkJfVG9rZW46Ym94Y25Lc1lrVTU2VHdvTWN6RHhpMUFicFdiXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><p>按钮在不同设备上的不同呈现</p><p>多态控件应该具备以下特点：</p><ul><li><p>覆盖手机、折叠屏、平板，兼顾智慧屏、车机、智能穿戴等终端。</p></li><li><p>场景一致性。在对应的使用场景下，其交互、视觉、动效要保持一致，在设计上属性参数保持一致或差异化。</p></li><li><p>针对设备做优化。多态控件在不同的设备上的呈现应该是该设备下的最佳效果，因此在保证一致性的同时，还需要针对设备的特点进行优化。</p></li></ul><h3 id="控件的状态"><a href="#控件的状态" class="headerlink" title="控件的状态"></a>控件的状态</h3><ul><li><p>控件的状态是一种视觉呈现，用于展示控件当前处于何种交互阶段。不同控件的相同状态应该保持一致的视觉风格，且应该清晰可见。</p></li><li><p>应用可能部署在不同设备上供用户使用，有些设备会支持多种输入方式。例如平板可以连接蓝牙键盘和鼠标来做文字编辑工作，此时控件需要同时满足键盘和鼠标交互，需要支持获焦态和悬停态，如果控件没有支持这两种状态，在使用键盘走焦时或鼠标悬停时，控件就无法呈现出相应的状态，给予用户正确的视觉引导。</p></li></ul><p>常见的状态类型：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2FmM2FiM2I0YzRjZTBjOWIxYTYyMmUwMzIyZDM2OTlfNktOSkFYZm5YWVBkMXpzV0JneVZBMVR0NXN6dElFMmZfVG9rZW46Ym94Y243eE1zdFFCRHphZkxjU3AyRkx4bmVoXzE2MjcxNDY4NjU6MTYyNzE1MDQ2NV9WNA" alt="img"></p><h3 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h3><p>控件在不同的设备下，对外表述一致，内部有不同的实现，不同的设备下有符合该设备特征的实现。</p><p>下表展示了控件与开发语言的对应关系。</p><p><strong>操作类</strong></p><p>无法复制加载中的内容</p><p><strong>导航类</strong></p><p>无法复制加载中的内容</p><p><strong>展示类</strong></p><p>无法复制加载中的内容</p><p><strong>容器类</strong></p><p>无法复制加载中的内容</p><h2 id="界面用语"><a href="#界面用语" class="headerlink" title="界面用语"></a>界面用语</h2><p>以下原则旨在为界面用语提供统一约定与要求， 以确保用语风格统一、清晰明了、流畅自然，给用户带来良好的阅读体验。</p><h3 id="一致"><a href="#一致" class="headerlink" title="一致"></a>一致</h3><p><strong>同一对象，指称一致</strong></p><p>无法复制加载中的内容</p><p>同一对象，不能有的用“E-mail 地址”，有的用“电子邮件”。</p><p><strong>同一状态，描述一致</strong></p><p>无法复制加载中的内容</p><p>都是在连接 WLAN 状态下，不能有的用“仅 WLAN 下”，有的用“仅连接 WLAN 时”。</p><p><strong>同一行为，提示一致</strong></p><p>无法复制加载中的内容</p><p>都是正在进行某行为，不能有的提醒“请稍候”，有的不提醒。</p><h3 id="简洁"><a href="#简洁" class="headerlink" title="简洁"></a>简洁</h3><p><strong>用词简短</strong></p><p>无法复制加载中的内容</p><p>存在多种表达方式时，选取最简短的词语。</p><h3 id="条理"><a href="#条理" class="headerlink" title="条理"></a>条理</h3><p><strong>上下呼应</strong></p><p>无法复制加载中的内容</p><p>标题用“为何搜索不到热点”，是询问问题出现的原因，在此场景下，下文描述就应给出原因。若让用户检查是否设置了隐藏 SSID，这不是描述原因，而是给出问题解决方法，上下不呼应。</p><p><strong>主次分明</strong></p><p>无法复制加载中的内容</p><p>“静音”为主要信息，应在前；“月亮图标”为次要信息，应在后。</p><h3 id="亲和"><a href="#亲和" class="headerlink" title="亲和"></a>亲和</h3><p><strong>化“难”为易</strong></p><p>无法复制加载中的内容</p><p>复杂的信息给出说明，降低理解难度。</p><p><strong>“礼”字当先</strong></p><p>无法复制加载中的内容</p><p>少用强制类词语。</p><p><strong>正向表达</strong></p><p>无法复制加载中的内容</p><p>多从正向描述。</p><h3 id="灵动"><a href="#灵动" class="headerlink" title="灵动"></a>灵动</h3><p><strong>用词多变</strong></p><p>无法复制加载中的内容</p><p>避免出现两个“以”，显得单调。</p><p><strong>远离平淡</strong></p><p>无法复制加载中的内容</p><p>广告宣传类用语，表达要有品位与个性。</p><h3 id="契合"><a href="#契合" class="headerlink" title="契合"></a>契合</h3><p><strong>身份契合</strong></p><p>无法复制加载中的内容</p><p>对孩子用“您”不合适。</p><p><strong>产品契合</strong></p><p>表达要与所描述的设备特性相契合，不可将A设备特性的描述，机械地用到与之有差异的B设备。若某个功能适用范围无法区分到具体设备，则用“设备”进行广覆盖。不可在智能穿戴设备界面上出现智慧屏特性的描述，反之，亦不可在智慧屏界面上出现智能穿戴设备特性的描述</p><h2 id="设计自检表"><a href="#设计自检表" class="headerlink" title="设计自检表"></a>设计自检表</h2><p>设计自检表详细列举出了在全场景设备设计和开发过程中应当注意的设计规则，提交审核前请再次检查各项是否符合规则要求，这将帮助应用减少用户舆情且提升用户体验的一致性。</p><p>自检表的要求范围分为“必选”与“推荐”两类。必选类一般为已总结出的较优解决方案或效果，表示相关设计需要按照此原则统一执行；推荐类指可能受应用品牌风格或业务特殊性影响，可适量做出修改。</p><p>请参考以下表格范围内提出的要求对应用进行检查。</p><p>无法复制加载中的内容</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Harmony </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Harmony </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker详解</title>
      <link href="/posts/c58.html"/>
      <url>/posts/c58.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p><strong>Docker</strong> 最初是 <code>dotCloud</code> 公司创始人 <a href="https://github.com/shykes" target="_blank" rel="noopener">Solomon Hykes</a> 在法国期间发起的一个公司内部项目，它是基于 <code>dotCloud</code> 公司多年云服务技术的一次革新，并于 <a href="https://en.wikipedia.org/wiki/Docker_" target="_blank" rel="noopener">2013 年 3 月以 Apache 2.0 授权协议开源</a>，主要项目代码在 <a href="https://github.com/moby/moby" target="_blank" rel="noopener">GitHub</a> 上进行维护。<code>Docker</code> 项目后来还加入了 Linux 基金会，并成立推动 <a href="https://opencontainers.org/" target="_blank" rel="noopener">开放容器联盟（OCI）</a>。</p><p><strong>Docker</strong> 自开源后受到广泛的关注和讨论，至今其 <a href="https://github.com/moby/moby" target="_blank" rel="noopener">GitHub 项目</a> 已经超过 5 万 7 千个星标和一万多个 <code>fork</code>。甚至由于 <code>Docker</code> 项目的火爆，在 <code>2013</code> 年底，<a href="https://www.docker.com/blog/dotcloud-is-becoming-docker-inc/" target="_blank" rel="noopener">dotCloud 公司决定改名为 Docker</a>。<code>Docker</code> 最初是在 <code>Ubuntu 12.04</code> 上开发实现的；<code>Red Hat</code> 则从 <code>RHEL 6.5</code> 开始对 <code>Docker</code> 进行支持；<code>Google</code> 也在其 <code>PaaS</code> 产品中广泛应用 <code>Docker</code>。</p><p><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <a href="https://golang.google.cn/" target="_blank" rel="noopener">Go 语言</a> 进行开发实现，基于 <code>Linux</code> 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroup</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>，以及 <a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/" target="_blank" rel="noopener">OverlayFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC</a>，从 <code>0.7</code> 版本以后开始去除 <code>LXC</code>，转而使用自行开发的 <a href="https://github.com/docker/libcontainer" target="_blank" rel="noopener">libcontainer</a>，从 <code>1.11</code> 版本开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runC</a> 和 <a href="https://github.com/containerd/containerd" target="_blank" rel="noopener">containerd</a>。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NmVlY2NkMmMzYTMxYzk4MWU0YmI1NTMyMGIxN2QwN2VfTkZnQU9IdWVFNVBRTFZKOXdJczZkb2czTnJYY293dWFfVG9rZW46Ym94Y25CbGNLcklzcHZxb0lpWTNuMmJhcFljXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>Docker 架构</p><blockquote><p><code>runc</code> 是一个 Linux 命令行工具，用于根据 <a href="https://github.com/opencontainers/runtime-spec" target="_blank" rel="noopener">OCI容器运行时规范</a> 创建和运行容器。</p></blockquote><blockquote><p><code>containerd</code> 是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。</p></blockquote><p><strong>Docker</strong> 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 <code>Docker</code> 技术比虚拟机技术更为轻便、快捷。</p><p>下面的图片比较了 <strong>Docker</strong> 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzk0OWVmOTNjNTFmMWQxNzlhNjZmMWZiNjYyOWQ5MmVfOUlBM1dQd3J5amp2NGZkSk96eko4WExYOEhZb0RtRkdfVG9rZW46Ym94Y25UbnBpZVhmcnh2WW1pQ0QzWjBKeVZmXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MGM2OGM2Yzg0NTg3ZTVlMzJiMWYzZDYzOWZhNzRkNjRfWjJKcFFvSmtYYXNIT253OVRaRGh6VGVJN3N4M25XSTJfVG9rZW46Ym94Y250WjVLZ1FYVzhHRVRVRUpMVU1nWnNmXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><h2 id="为什么要用-Docker"><a href="#为什么要用-Docker" class="headerlink" title="为什么要用 Docker"></a>为什么要用 Docker</h2><p>作为一种新兴的虚拟化方式，<code>Docker</code> 跟传统的虚拟化方式相比具有众多的优势。</p><p><strong>更高效的利用系统资源</strong></p><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，<code>Docker</code> 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><p><strong>更快速的启动时间</strong></p><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><p><strong>一致的运行环境</strong></p><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 <code>Docker</code> 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p><p><strong>持续交付和部署</strong></p><p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps" target="_blank" rel="noopener">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p><p>使用 <code>Docker</code> 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 <a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile" target="_blank" rel="noopener">Dockerfile</a> 来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="noopener">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery" target="_blank" rel="noopener">持续部署(Continuous Delivery/Deployment)</a> 系统进行自动部署。</p><p>而且使用 <code>Dockerfile</code> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><p><strong>更轻松的迁移</strong></p><p>由于 <code>Docker</code> 确保了执行环境的一致性，使得应用的迁移更加容易。<code>Docker</code> 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p><p><strong>更轻松的维护和扩展</strong></p><p><code>Docker</code> 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，<code>Docker</code> 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&amp;image_filter=official" target="_blank" rel="noopener">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><p><strong>对比传统虚拟机总结</strong></p><p>无法复制加载中的内容</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>我们都知道，操作系统分为 <strong>内核</strong> 和 <strong>用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 <strong>Docker 镜像</strong>（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p><p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 <code>ISO</code> 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 <strong>容器存储层</strong>。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://yeasy.gitbook.io/docker_practice/repository/registry" target="_blank" rel="noopener">Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><p>以 <a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:16.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p><p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p><h3 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的 <a href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official" target="_blank" rel="noopener">官方镜像</a>。除此以外，还有 Red Hat 的 <a href="https://quay.io/repository/" target="_blank" rel="noopener">Quay.io</a>；Google 的 <a href="https://cloud.google.com/container-registry/" target="_blank" rel="noopener">Google Container Registry</a>，<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 的镜像使用的就是这个服务；代码托管平台 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 推出的 <a href="https://docs.github.com/cn/packages/guides/about-github-container-registry" target="_blank" rel="noopener">ghcr.io</a>。</p><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为 <strong>加速器</strong>。常见的有 <a href="https://www.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu" target="_blank" rel="noopener">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 安装 Docker 一节中有详细的配置方法。</p><p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://www.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu" target="_blank" rel="noopener">阿里云镜像库</a> 等。</p><h3 id="私有-Docker-Registry"><a href="#私有-Docker-Registry" class="headerlink" title="私有 Docker Registry"></a>私有 Docker Registry</h3><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。在 <a href="https://yeasy.gitbook.io/docker_practice/repository/registry" target="_blank" rel="noopener">私有仓库</a> 一节中，会有进一步的搭建私有 Registry 服务的讲解。</p><p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">Docker Registry API</a> 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">Harbor</a> 和 <a href="https://yeasy.gitbook.io/docker_practice/repository/nexus3_registry" target="_blank" rel="noopener">Sonatype Nexus</a>。</p><h1 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h1><h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h2><blockquote><p>警告：切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker.</p></blockquote><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h4><p>Docker 支持以下版本的 <a href="https://ubuntu.com/server" target="_blank" rel="noopener">Ubuntu</a> 操作系统：</p><ul><li><p>Ubuntu Groovy 20.10</p></li><li><p>Ubuntu Focal 20.04 (LTS)</p></li><li><p>Ubuntu Bionic 18.04 (LTS)</p></li><li><p>Ubuntu Xenial 16.04 (LTS)</p></li></ul><p>Docker 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本。</p><h4 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h4><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p><pre><code>$ sudo apt-get remove docker \               docker-engine \               docker.io</code></pre><h3 id="使用-APT-安装"><a href="#使用-APT-安装" class="headerlink" title="使用 APT 安装"></a>使用 APT 安装</h3><p>由于 <code>apt</code> 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p><pre><code>$ sudo apt-get update$ sudo apt-get install \    apt-transport-https \    ca-certificates \    curl \    gnupg \    lsb-release</code></pre><p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。</p><p>为了确认所下载软件包的合法性，需要添加软件源的 <code>GPG</code> 密钥。</p><pre><code>$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg# 官方源# $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</code></pre><p>然后，我们需要向 <code>sources.list</code> 中添加 Docker 软件源</p><pre><code>$ echo \  "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \  $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null# 官方源# $ echo \#   "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \#   $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</code></pre><blockquote><p>以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test。</p></blockquote><h4 id="安装-Docker-1"><a href="#安装-Docker-1" class="headerlink" title="安装 Docker"></a>安装 Docker</h4><p>更新 apt 软件包缓存，并安装 <code>docker-ce</code>：</p><pre><code>$ sudo apt-get update$ sudo apt-get install docker-ce docker-ce-cli containerd.io</code></pre><h3 id="使用脚本自动安装"><a href="#使用脚本自动安装" class="headerlink" title="使用脚本自动安装"></a>使用脚本自动安装</h3><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：</p><blockquote><p>若你想安装测试版的 Docker, 请从 test.docker.com 获取脚本</p></blockquote><pre><code># $ curl -fsSL test.docker.com -o get-docker.sh$ curl -fsSL get.docker.com -o get-docker.sh$ sudo sh get-docker.sh --mirror Aliyun# $ sudo sh get-docker.sh --mirror AzureChinaCloud</code></pre><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p><h3 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h3><pre><code>$ sudo systemctl enable docker$ sudo systemctl start docker</code></pre><h3 id="建立-docker-用户组"><a href="#建立-docker-用户组" class="headerlink" title="建立 docker 用户组"></a>建立 docker 用户组</h3><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="noopener">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><pre><code>$ sudo groupadd docker</code></pre><p>将当前用户加入 <code>docker</code> 组：</p><pre><code>$ sudo usermod -aG docker $USER</code></pre><p>退出当前终端并重新登录，进行如下测试。</p><h3 id="测试-Docker-是否安装正确"><a href="#测试-Docker-是否安装正确" class="headerlink" title="测试 Docker 是否安装正确"></a>测试 Docker 是否安装正确</h3><pre><code>$ docker run --rm hello-worldUnable to find image 'hello-world:latest' locallylatest: Pulling from library/hello-worldb8dfde127a29: Pull completeDigest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24Status: Downloaded newer image for hello-world:latestHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.    (amd64) 3. The Docker daemon created a new container from that image which runs the    executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it    to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/</code></pre><p>若能正常输出以上信息，则说明安装成功。</p><h3 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h3><h2 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h2><h3 id="系统要求-1"><a href="#系统要求-1" class="headerlink" title="系统要求"></a>系统要求</h3><p><a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">Docker Desktop for Mac</a> 要求系统最低为 macOS Mojave 10.14。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="使用-Homebrew-安装"><a href="#使用-Homebrew-安装" class="headerlink" title="使用 Homebrew 安装"></a>使用 Homebrew 安装</h4><p><a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 的 <a href="https://github.com/Homebrew/homebrew-cask" target="_blank" rel="noopener">Cask</a> 已经支持 Docker Desktop for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装：</p><pre><code>$ brew install --cask docker</code></pre><h4 id="手动下载安装"><a href="#手动下载安装" class="headerlink" title="手动下载安装"></a>手动下载安装</h4><p>如果需要手动下载，请点击以下 <a href="https://desktop.docker.com/mac/stable/amd64/Docker.dmg" target="_blank" rel="noopener">链接</a> 下载 Docker Desktop for Mac。</p><blockquote><p>如果你的电脑搭载的是 M1 芯片（<code>arm64</code> 架构），请点击以下 <a href="https://desktop.docker.com/mac/stable/arm64/Docker.dmg" target="_blank" rel="noopener">链接</a> 下载 Docker Desktop for Mac。你可以在 <a href="https://docs.docker.com/docker-for-mac/apple-silicon/" target="_blank" rel="noopener">官方文档</a> 查阅已知的问题。</p></blockquote><p>如同 macOS 其它软件一样，安装也非常简单，双击下载的 <code>.dmg</code> 文件，然后将那只叫 <a href="https://www.docker.com/blog/call-me-moby-dock/" target="_blank" rel="noopener">Moby</a> 的鲸鱼图标拖拽到 <code>Application</code> 文件夹即可（其间需要输入用户密码）。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2RmZjhlYTEzMWQzODA2NTA3MTg3Nzk3ZGFhZTdjZDBfbHkzNVlsMGNKeGZQMTA1MVRVRnZ1Y3VyT0lHSWlLMFBfVG9rZW46Ym94Y245NldUZGtIckY0ZW11Q2pqbjI3TG9lXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>从应用中找到 Docker 图标并点击运行。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTU3YWViN2ZhZjZhOGFmNjlmY2QxYzAyMWMxMjc4ZDdfQ0Z3cXFIeDBPVG9UNElJODRmNTdOQWpHSWYzVGlyamZfVG9rZW46Ym94Y25lRnlvaDBaYXJwS0EzYkJRUUhlY2JlXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>运行之后，会在右上角菜单栏看到多了一个鲸鱼图标，这个图标表明了 Docker 的运行状态。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzFjZGI5OTY0OTI2MTI3ZTgyNGY3YzQyN2M0NTVkOGFfQ3I4VVJpb1BtMElYYXgwR1BsaHNtbm52VnV3SWJWMUhfVG9rZW46Ym94Y24yR0Q5aW8xYmltVzJlVk1pNXBCdXJaXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>每次点击鲸鱼图标会弹出操作菜单。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MDc2NDhlMjNiYjQzNmVmMjNlNTA3MzRlZDgyOTk0OGZfZzh2UjU1VnQ5dnh5ZTc5UnNNalJLSzFldkJCYlFENWRfVG9rZW46Ym94Y251YmsycmxuS2xncE14STdPU1ZTWDViXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>之后，你可以在终端通过命令检查安装后的 Docker 版本。</p><pre><code>$ docker --versionDocker version 20.10.0, build 7287ab3</code></pre><p>如果 <code>docker version</code>、<code>docker info</code> 都正常的话，可以尝试运行一个 <a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener">Nginx 服务器</a>：</p><pre><code>$ docker run -d -p 80:80 --name webserver nginx</code></pre><p>服务运行后，可以访问 <a href="http://localhost/" target="_blank" rel="noopener">http://localhost</a>，如果看到了 “Welcome to nginx!”，就说明 Docker Desktop for Mac 安装成功了。</p><p>要停止 Nginx 服务器并删除执行下面的命令：</p><pre><code>$ docker stop webserver$ docker rm webserver</code></pre><p>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker 国内镜像加速。</p><h2 id="Windows-10"><a href="#Windows-10" class="headerlink" title="Windows 10"></a>Windows 10</h2><h3 id="系统要求-2"><a href="#系统要求-2" class="headerlink" title="系统要求"></a>系统要求</h3><p><a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">Docker Desktop for Windows</a> 支持 64 位版本的 Windows 10 Pro，且必须开启 Hyper-V（若版本为 v1903 及以上则无需开启 Hyper-V），或者 64 位版本的 Windows 10 Home v1903 及以上版本。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p><strong>手动下载安装</strong></p><p>点击以下 [链接](<a href="https://desktop.docker.com/win/stable/amd64/Docker" target="_blank" rel="noopener">https://desktop.docker.com/win/stable/amd64/Docker</a> Desktop Installer.exe) 下载 Docker Desktop for Windows。</p><p>下载好之后双击 <code>Docker Desktop Installer.exe</code> 开始安装。</p><p><strong>使用</strong> <strong><a href="https://docs.microsoft.com/zh-cn/windows/package-manager/" target="_blank" rel="noopener">winget</a></strong> <strong>安装</strong></p><pre><code>$ winget install Docker.DockerDesktop</code></pre><h3 id="在-WSL2-运行-Docker"><a href="#在-WSL2-运行-Docker" class="headerlink" title="在 WSL2 运行 Docker"></a>在 WSL2 运行 Docker</h3><p>若你的 Windows 版本为 Windows 10 专业版或家庭版 v1903 及以上版本可以使用 WSL2 运行 Docker，具体请查看 <a href="https://docs.docker.com/docker-for-windows/wsl/" target="_blank" rel="noopener">Docker Desktop WSL 2 backend</a>。</p><h3 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h3><p>在 Windows 搜索栏输入 <strong>Docker</strong> 点击 <strong>Docker Desktop</strong> 开始运行。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmMwZTQyZWM3Yzg5ZjcyODNmYzM1YzExNjdhNThhZDhfa1VuQW1EZ05DN2JvQ0xqcUgwajJOeGZkdEV0bzR1ZjJfVG9rZW46Ym94Y25EbUN4alhyUlpoUjhoQ3VqNVJDeHluXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>Docker 启动之后会在 Windows 任务栏出现鲸鱼图标。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Njk2MjZmZDdhMGQ3MWRhNjhlZjFmYmU3NzhiYTQ3NzhfWDZCMXgxazVqTm44anBxa1BNbEh3bEtITFVyS1Vtb1FfVG9rZW46Ym94Y25XbUdYNUJOTFdsb0tlb3lTVmJRNlJWXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>等待片刻，当鲸鱼图标静止时，说明 Docker 启动成功，之后你可以打开 PowerShell 使用 Docker。</p><blockquote><p>推荐使用 <a href="https://docs.microsoft.com/zh-cn/windows/terminal/get-started" target="_blank" rel="noopener">Windows Terminal</a> 在终端使用 Docker。</p></blockquote><h3 id="镜像加速-1"><a href="#镜像加速-1" class="headerlink" title="镜像加速"></a>镜像加速</h3><p>如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker <a href="https://yeasy.gitbook.io/docker_practice/install/mirror" target="_blank" rel="noopener">国内镜像加速</a>。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">官方文档</a></p></li><li><p><a href="https://devblogs.microsoft.com/commandline/wsl-2-support-is-coming-to-windows-10-versions-1903-and-1909/" target="_blank" rel="noopener">WSL 2 Support is coming to Windows 10 Versions 1903 and 1909</a></p></li></ul><h2 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h2><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速器服务，例如：</p><ul><li><p><a href="https://www.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu" target="_blank" rel="noopener">阿里云加速器(点击管理控制台 -&gt; 登录账号(淘宝账号) -&gt; 右侧镜像工具 -&gt; 镜像加速器 -&gt; 复制加速器地址)</a></p></li><li><p><a href="https://www.163yun.com/help/documents/56918246390157312" target="_blank" rel="noopener">网易云加速器 </a><code>https://hub-mirror.c.163.com</code></p></li><li><p><a href="https://cloud.baidu.com/doc/CCE/s/Yjxppt74z#使用dockerhub加速器" target="_blank" rel="noopener">百度云加速器 </a><code>https://mirror.baidubce.com</code></p></li></ul><p><strong>由于镜像服务可能出现宕机，建议同时配置多个镜像。各个镜像站测试结果请到</strong> <strong><a href="https://github.com/docker-practice/docker-registry-cn-mirror-test/actions" target="_blank" rel="noopener">docker-practice/docker-registry-cn-mirror-test</a></strong> <strong>查看。</strong></p><blockquote><p>国内各大云服务商（腾讯云、阿里云、百度云）均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务，具体请参考本页最后一小节。</p></blockquote><p>本节我们以 <a href="https://www.163yun.com/" target="_blank" rel="noopener">网易云</a> 镜像服务 <code>https://hub-mirror.c.163.com</code> 为例进行介绍。</p><h3 id="Ubuntu-16-04-、Debian-8-、CentOS-7"><a href="#Ubuntu-16-04-、Debian-8-、CentOS-7" class="headerlink" title="Ubuntu 16.04+、Debian 8+、CentOS 7+"></a>Ubuntu 16.04+、Debian 8+、CentOS 7+</h3><p>目前主流 Linux 发行版均已使用 <a href="https://systemd.io/" target="_blank" rel="noopener">systemd</a> 进行服务管理，这里介绍如何在使用 systemd 的 Linux 发行版中配置镜像加速器。</p><p>请首先执行以下命令，查看是否在 <code>docker.service</code> 文件中配置过镜像地址。</p><pre><code>$ systemctl cat docker | grep '\-\-registry\-mirror'</code></pre><p>如果该命令有输出，那么请执行 <code>$ systemctl cat docker</code> 查看 <code>ExecStart=</code> 出现的位置，修改对应的文件内容去掉 <code>--registry-mirror</code> 参数及其值，并按接下来的步骤进行配置。</p><p>如果以上命令没有任何输出，那么就可以在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）：</p><pre><code>{  "registry-mirrors": [    "https://hub-mirror.c.163.com",    "https://mirror.baidubce.com"  ]}</code></pre><blockquote><p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p></blockquote><p>之后重新启动服务。</p><pre><code>$ sudo systemctl daemon-reload$ sudo systemctl restart docker</code></pre><h3 id="Windows-10-1"><a href="#Windows-10-1" class="headerlink" title="Windows 10"></a>Windows 10</h3><p>对于使用 <code>Windows 10</code> 的用户，在任务栏托盘 Docker 图标内右键菜单选择 <code>Settings</code>，打开配置窗口后在左侧导航菜单选择 <code>Docker Engine</code>，在右侧像下边一样编辑 json 文件，之后点击 <code>Apply &amp; Restart</code> 保存后 Docker 就会重启并应用配置的镜像地址了。</p><pre><code>{  "registry-mirrors": [    "https://hub-mirror.c.163.com",    "https://mirror.baidubce.com"  ]}</code></pre><h3 id="macOS-1"><a href="#macOS-1" class="headerlink" title="macOS"></a>macOS</h3><p>对于使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 -&gt; <code>Perferences</code>，在左侧导航菜单选择 <code>Docker Engine</code>，在右侧像下边一样编辑 json 文件。修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像地址了。</p><pre><code>{  "registry-mirrors": [    "https://hub-mirror.c.163.com",    "https://mirror.baidubce.com"  ]}</code></pre><h3 id="检查加速器是否生效"><a href="#检查加速器是否生效" class="headerlink" title="检查加速器是否生效"></a>检查加速器是否生效</h3><p>执行 <code>$ docker info</code>，如果从结果中看到了如下内容，说明配置成功。</p><p>Registry Mirrors:</p><p> <a href="https://hub-mirror.c.163.com/" target="_blank" rel="noopener">https://hub-mirror.c.163.com/</a></p><h3 id="k8s-gcr-io-镜像"><a href="#k8s-gcr-io-镜像" class="headerlink" title="k8s.gcr.io 镜像"></a><code>k8s.gcr.io</code> 镜像</h3><p>可以登录 <a href="https://www.aliyun.com/product/acr?source=5176.11533457&amp;userCode=8lx5zmtu&amp;type=copy" target="_blank" rel="noopener">阿里云 容器镜像服务</a> <strong>镜像中心</strong> -&gt; <strong>镜像搜索</strong> 查找。</p><p>例如 <code>k8s.gcr.io/coredns:1.6.7</code> 镜像可以用 <code>registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.6.7</code> 代替。</p><p>一般情况下有如下对应关系：</p><pre><code># $ docker pull k8s.gcr.io/xxx$ docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/xxx</code></pre><h3 id="不再提供服务的镜像"><a href="#不再提供服务的镜像" class="headerlink" title="不再提供服务的镜像"></a>不再提供服务的镜像</h3><p>某些镜像不再提供服务，添加无用的镜像加速器，会拖慢镜像拉取速度，你可以从镜像配置列表中删除它们。</p><ul><li><p><a href="https://dockerhub.azk8s.cn/" target="_blank" rel="noopener">https://dockerhub.azk8s.cn</a> <strong>已转为私有</strong></p></li><li><p><a href="https://reg-mirror.qiniu.com/" target="_blank" rel="noopener">https://reg-mirror.qiniu.com</a></p></li><li><p><a href="https://registry.docker-cn.com/" target="_blank" rel="noopener">https://registry.docker-cn.com</a></p></li></ul><p>建议 <strong>watch（页面右上角）</strong> <a href="https://github.com/docker-practice/docker-registry-cn-mirror-test" target="_blank" rel="noopener">镜像测试</a> 这个 GitHub 仓库，我们会在此更新各个镜像地址的状态。</p><h3 id="云服务商"><a href="#云服务商" class="headerlink" title="云服务商"></a>云服务商</h3><p>某些云服务商提供了 <strong>仅供内部</strong> 访问的镜像服务，当您的 Docker 运行在云平台时可以选择它们。</p><ul><li><p><a href="https://github.com/Azure/container-service-for-azure-china/blob/master/aks/README.md#22-container-registry-proxy" target="_blank" rel="noopener">Azure 中国镜像 </a><code>https://dockerhub.azk8s.cn</code></p></li><li><p><a href="https://cloud.tencent.com/act/cps/redirect?redirect=10058&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61" target="_blank" rel="noopener">腾讯云 </a><code>https://mirror.ccs.tencentyun.com</code></p></li></ul><h2 id="开启实验特性"><a href="#开启实验特性" class="headerlink" title="开启实验特性"></a>开启实验特性</h2><p>一些 docker 命令或功能仅当 <strong>实验特性</strong> 开启时才能使用，请按照以下方法进行设置。</p><h3 id="Docker-CLI-的实验特性"><a href="#Docker-CLI-的实验特性" class="headerlink" title="Docker CLI 的实验特性"></a>Docker CLI 的实验特性</h3><p>从 <code>v20.10</code> 版本开始，Docker CLI 所有实验特性的命令均默认开启，无需再进行配置或设置系统环境变量。</p><h3 id="开启-dockerd-的实验特性"><a href="#开启-dockerd-的实验特性" class="headerlink" title="开启 dockerd 的实验特性"></a>开启 dockerd 的实验特性</h3><p>编辑 <code>/etc/docker/daemon.json</code>，新增如下条目</p><pre><code>{  "experimental": true}</code></pre><h1 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h1><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>之前提到过，<a href="https://hub.docker.com/search?q=&amp;type=image" target="_blank" rel="noopener">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><pre><code>$ docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</code></pre><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p><ul><li><p>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub(<code>docker.io</code>)。</p></li><li><p>仓库名：如之前所说，这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</p></li></ul><p>比如：</p><pre><code>$ docker pull ubuntu:18.0418.04: Pulling from library/ubuntu92dc2a97ff99: Pull completebe13a9d27eb8: Pull completec8299583700a: Pull completeDigest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26Status: Downloaded newer image for ubuntu:18.04docker.io/library/ubuntu:18.04</code></pre><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （<code>docker.io</code>）获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。<code>docker pull</code> 命令的输出结果最后一行给出了镜像的完整名称，即： <code>docker.io/library/ubuntu:18.04</code>。</p><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p><p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 <code>sha256</code> 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p><h3 id="运行-2"><a href="#运行-2" class="headerlink" title="运行"></a>运行</h3><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p><pre><code>$ docker run -it --rm ubuntu:18.04 bashroot@e7009c6ce357:/# cat /etc/os-releaseNAME="Ubuntu"VERSION="18.04.1 LTS (Bionic Beaver)"ID=ubuntuID_LIKE=debianPRETTY_NAME="Ubuntu 18.04.1 LTS"VERSION_ID="18.04"HOME_URL="https://www.ubuntu.com/"SUPPORT_URL="https://help.ubuntu.com/"BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"VERSION_CODENAME=bionicUBUNTU_CODENAME=bionic</code></pre><p><code>docker run</code> 就是运行容器的命令，具体格式我们会在 <a href="https://yeasy.gitbook.io/docker_practice/container" target="_blank" rel="noopener">容器</a> 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。</p><ul><li><p><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</p></li><li><p><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</p></li><li><p><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</p></li><li><p><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</p></li></ul><p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 <code>cat /etc/os-release</code>，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 <code>Ubuntu 18.04.1 LTS</code> 系统。</p><p>最后我们通过 <code>exit</code> 退出了这个容器。</p><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><pre><code>$ docker image lsREPOSITORY           TAG                 IMAGE ID            CREATED             SIZEredis                latest              5f515359c7f8        5 days ago          183 MBnginx                latest              05a60462f8ba        5 days ago          181 MBmongo                3.2                 fe9198c04d62        5 days ago          342 MB&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MBubuntu               18.04               329ed837d508        3 days ago          63.3MBubuntu               bionic              329ed837d508        3 days ago          63.3MB</code></pre><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h3 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h3><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:18.04</code> 镜像大小，在这里是 <code>63.3MB</code>，但是在 <a href="https://hub.docker.com/layers/ubuntu/library/ubuntu/bionic/images/sha256-32776cc92b5810ce72e77aca1d949de1f348e1d281d3f00ebcc22a3adcdc9f42?context=explore" target="_blank" rel="noopener">Docker Hub</a> 显示的却是 <code>25.47 MB</code>。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p><p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p><p>你可以通过 <code>docker system df</code> 命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><pre><code>$ docker system dfTYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLEImages              24                  0                   1.992GB             1.992GB (100%)Containers          1                   0                   62.82MB             62.82MB (100%)Local Volumes       9                   0                   652.2MB             652.2MB (100%)Build Cache                                                 0B                  0B</code></pre><h3 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h3><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。：</p><pre><code>&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</code></pre><p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p><pre><code>$ docker image ls -f dangling=trueREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE&lt;none&gt;              &lt;none&gt;              00285df0df87        5 days ago          342 MB</code></pre><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><pre><code>$ docker image prune</code></pre><h3 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h3><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p><pre><code>$ docker image ls -a</code></pre><p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p><h3 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h3><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p><p>根据仓库名列出镜像</p><pre><code>$ docker image ls ubuntuREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               329ed837d508        3 days ago          63.3MBubuntu              bionic              329ed837d508        3 days ago          63.3MB</code></pre><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><pre><code>$ docker image ls ubuntu:18.04REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               329ed837d508        3 days ago          63.3MB</code></pre><p>除此以外，<code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code>。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>mongo:3.2</code> 之后建立的镜像，可以用下面的命令：</p><pre><code>$ docker image ls -f since=mongo:3.2REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEredis               latest              5f515359c7f8        5 days ago          183 MBnginx               latest              05a60462f8ba        5 days ago          181 MB</code></pre><p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可。</p><p>此外，如果镜像构建时，定义了 <code>LABEL</code>，还可以通过 <code>LABEL</code> 来过滤。</p><pre><code>$ docker image ls -f label=com.example.version=0.1...</code></pre><h3 id="以特定格式显示"><a href="#以特定格式显示" class="headerlink" title="以特定格式显示"></a>以特定格式显示</h3><p>默认情况下，<code>docker image ls</code> 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 <code>docker image ls</code> 把所有的虚悬镜像的 ID 列出来，然后才可以交给 <code>docker image rm</code> 命令作为参数来删除指定的这些镜像，这个时候就用到了 <code>-q</code> 参数。</p><pre><code>$ docker image ls -q5f515359c7f805a60462f8bafe9198c04d6200285df0df87329ed837d508329ed837d508</code></pre><p><code>--filter</code> 配合 <code>-q</code> 产生出指定范围的 ID 列表，然后送给另一个 <code>docker</code> 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。</p><p>另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 <a href="https://gohugo.io/templates/introduction/" target="_blank" rel="noopener">Go 的模板语法</a>。</p><p>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p><pre><code>$ docker image ls --format "{{.ID}}: {{.Repository}}"5f515359c7f8: redis05a60462f8ba: nginxfe9198c04d62: mongo00285df0df87: &lt;none&gt;329ed837d508: ubuntu329ed837d508: ubuntu</code></pre><p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p><pre><code>$ docker image ls --format "table {{.ID}}\t{{.Repository}}\t{{.Tag}}"IMAGE ID            REPOSITORY          TAG5f515359c7f8        redis               latest05a60462f8ba        nginx               latestfe9198c04d62        mongo               3.200285df0df87        &lt;none&gt;              &lt;none&gt;329ed837d508        ubuntu              18.04329ed837d508        ubuntu              bionic</code></pre><h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><pre><code>$ docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</code></pre><h3 id="用-ID、镜像名、摘要删除镜像"><a href="#用-ID、镜像名、摘要删除镜像" class="headerlink" title="用 ID、镜像名、摘要删除镜像"></a>用 ID、镜像名、摘要删除镜像</h3><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有这么一些镜像：</p><pre><code>$ docker image lsREPOSITORY                  TAG                 IMAGE ID            CREATED             SIZEcentos                      latest              0584b3d2cf6d        3 weeks ago         196.5 MBredis                       alpine              501ad78535f0        3 weeks ago         21.03 MBdocker                      latest              cf693ec9b5c7        3 weeks ago         105.1 MBnginx                       latest              e43d811ce2f4        5 weeks ago         181.5 MB</code></pre><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><pre><code>$ docker image rm 501Untagged: redis:alpineUntagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86dDeleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899bDeleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2faDeleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</code></pre><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名&gt;:&lt;标签&gt;</code>，来删除镜像。</p><pre><code>$ docker image rm centosUntagged: centos:latestUntagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366cDeleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8aDeleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</code></pre><p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p><pre><code>$ docker image ls --digestsREPOSITORY                  TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZEnode                        slim                sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228   6e0c4c8e3913        3 weeks ago         214 MB$ docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</code></pre><h3 id="Untagged-和-Deleted"><a href="#Untagged-和-Deleted" class="headerlink" title="Untagged 和 Deleted"></a>Untagged 和 Deleted</h3><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p><p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因。</p><p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p><h3 id="用-docker-image-ls-命令来配合"><a href="#用-docker-image-ls-命令来配合" class="headerlink" title="用 docker image ls 命令来配合"></a>用 docker image ls 命令来配合</h3><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><pre><code>$ docker image rm $(docker image ls -q redis)</code></pre><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p><pre><code>$ docker image rm $(docker image ls -q -f before=mongo:3.2)</code></pre><p>充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。</p><h2 id="利用-commit-理解镜像构成"><a href="#利用-commit-理解镜像构成" class="headerlink" title="利用 commit 理解镜像构成"></a>利用 commit 理解镜像构成</h2><blockquote><p>注意：如果您是初学者，您可以暂时跳过后面的内容，直接学习 容器 一节。</p></blockquote><p>注意： <code>docker commit</code> 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 <code>docker commit</code> 定制镜像，定制镜像应该使用 <code>Dockerfile</code> 来完成。如果你想要定制镜像请查看下一小节。</p><p>镜像是容器的基础，每次执行 <code>docker run</code> 的时候都会指定哪个镜像作为容器运行的基础。在之前的例子中，我们所使用的都是来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，我们就需要定制这些镜像。接下来的几节就将讲解如何定制镜像。</p><p>回顾一下之前我们学到的知识，镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p><p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p><pre><code>$ docker run --name webserver -d -p 80:80 nginx</code></pre><p>这条命令会用 <code>nginx</code> 镜像启动一个容器，命名为 <code>webserver</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 <code>nginx</code> 服务器。</p><p>如果是在本机运行的 Docker，那么可以直接访问：<code>http://localhost</code> ，如果是在虚拟机、云服务器上安装的 Docker，则需要将 <code>localhost</code> 换为虚拟机地址或者实际云服务器地址。</p><p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmFjZDdhYWQxYmFjYmFjMDgzYTdmYTBiY2ZkY2JjMzhfRm9ONjNKQmF0OUl1THVENFBaeDY0SVpKMmxaMERFR2dfVG9rZW46Ym94Y25aT0h1VkN1MktvUXIxRjdpWjlHaXVjXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 <code>docker exec</code> 命令进入容器，修改其内容。</p><pre><code>$ docker exec -it webserver bashroot@3729b97e8226:/# echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.htmlroot@3729b97e8226:/# exitexit</code></pre><p>我们以交互式终端方式进入 <code>webserver</code> 容器，并执行了 <code>bash</code> 命令，也就是获得一个可操作的 Shell。</p><p>然后，我们用 <code>&lt;h1&gt;Hello, Docker!&lt;/h1&gt;</code> 覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p><p>现在我们再刷新浏览器的话，会发现内容被改变了。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MzJmNmNjZWRjMmZiODgyMmI4NzcwYmIzMzMwZmI0NDJfT1BrRUZCUDBFM1hkYTh3QnQyV3NHWWVsSjBEa2pzanBfVG9rZW46Ym94Y25QcnRWZ2ZZMGFJNFRKUkRaajBkeWhnXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p><pre><code>$ docker diff webserverC /rootA /root/.bash_historyC /runC /usrC /usr/shareC /usr/share/nginxC /usr/share/nginx/htmlC /usr/share/nginx/html/index.htmlC /varC /var/cacheC /var/cache/nginxA /var/cache/nginx/client_tempA /var/cache/nginx/fastcgi_tempA /var/cache/nginx/proxy_tempA /var/cache/nginx/scgi_tempA /var/cache/nginx/uwsgi_temp</code></pre><p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。</p><p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p><code>docker commit</code> 的语法格式为：</p><p>docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</p><p>我们可以用下面的命令将容器保存为镜像：</p><pre><code>$ docker commit \    --author "Tao Wang &lt;twang2218@gmail.com&gt;" \    --message "修改了默认网页" \    webserver \    nginx:v2sha256:07e33465974800ce65751acc279adc6ed2dc5ed4e0838f8b86f0c87aa1795214</code></pre><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这点和 <code>git</code> 版本控制相似，不过这里这些信息可以省略留空。</p><p>我们可以在 <code>docker image ls</code> 中看到这个新定制的镜像：</p><pre><code>$ docker image ls nginxREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEnginx               v2                  07e334659748        9 seconds ago       181.5 MBnginx               1.11                05a60462f8ba        12 days ago         181.5 MBnginx               latest              e43d811ce2f4        4 weeks ago         181.5 MB</code></pre><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p><pre><code>$ docker history nginx:v2IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT07e334659748        54 seconds ago      nginx -g daemon off;                            95 B                修改了默认网页e43d811ce2f4        4 weeks ago         /bin/sh -c #(nop)  CMD ["nginx" "-g" "daemon    0 B&lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop)  EXPOSE 443/tcp 80/tcp        0 B&lt;missing&gt;           4 weeks ago         /bin/sh -c ln -sf /dev/stdout /var/log/nginx/   22 B&lt;missing&gt;           4 weeks ago         /bin/sh -c apt-key adv --keyserver hkp://pgp.   58.46 MB&lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop)  ENV NGINX_VERSION=1.11.5-1   0 B&lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop)  MAINTAINER NGINX Docker Ma   0 B&lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop)  CMD ["/bin/bash"]            0 B&lt;missing&gt;           4 weeks ago         /bin/sh -c #(nop) ADD file:23aa4f893e3288698c   123 MB</code></pre><p>新的镜像定制好后，我们可以来运行这个镜像。</p><pre><code>docker run --name web2 -d -p 81:80 nginx:v2</code></pre><p>这里我们命名为新的服务为 <code>web2</code>，并且映射到 <code>81</code> 端口。访问 <code>http://localhost:81</code> 看到结果，其内容应该和之前修改后的 <code>webserver</code> 一样。</p><p>至此，我们第一次完成了定制镜像，使用的是 <code>docker commit</code> 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p><h3 id="慎用-docker-commit"><a href="#慎用-docker-commit" class="headerlink" title="慎用 docker commit"></a>慎用 <code>docker commit</code></h3><p>使用 <code>docker commit</code> 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p><p>首先，如果仔细观察之前的 <code>docker diff webserver</code> 的结果，你会发现除了真正想要修改的 <code>/usr/share/nginx/html/index.html</code> 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，将会导致镜像极为臃肿。</p><p>此外，使用 <code>docker commit</code> 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为 <strong>黑箱镜像</strong>，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体的操作。这种黑箱镜像的维护工作是非常痛苦的。</p><p>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 <code>docker commit</code> 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p><h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><p>从刚才的 <code>docker commit</code> 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><pre><code>$ mkdir mynginx$ cd mynginx$ touch Dockerfile</code></pre><p>其内容为：</p><pre><code>FROM nginxRUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</code></pre><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><p>在 <a href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official" target="_blank" rel="noopener">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <code>nginx</code>、<code>redis</code>、<code>mongo</code>、<code>mysql</code>、<code>httpd</code>、<code>php</code>、<code>tomcat</code> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <code>node</code>、<code>openjdk</code>、<code>python</code>、<code>ruby</code>、<code>golang</code> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <code>ubuntu</code>、<code>debian</code>、<code>centos</code>、<code>fedora</code>、<code>alpine</code> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><pre><code>FROM scratch...</code></pre><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.google.cn/" target="_blank" rel="noopener">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li></ul><pre><code>RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</code></pre><ul><li><em>exec</em> 格式：<code>RUN ["可执行文件", "参数1", "参数2"]</code>，这更像是函数调用中的格式。</li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p><pre><code>FROM debian:stretchRUN apt-get updateRUN apt-get install -y gcc libc6-dev make wgetRUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz"RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install</code></pre><p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p><p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p><p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p><pre><code>FROM debian:stretchRUN set -x; buildDeps='gcc libc6-dev make wget' \    &amp;&amp; apt-get update \    &amp;&amp; apt-get install -y $buildDeps \    &amp;&amp; wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \    &amp;&amp; mkdir -p /usr/src/redis \    &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \    &amp;&amp; make -C /usr/src/redis \    &amp;&amp; make -C /usr/src/redis install \    &amp;&amp; rm -rf /var/lib/apt/lists/* \    &amp;&amp; rm redis.tar.gz \    &amp;&amp; rm -r /usr/src/redis \    &amp;&amp; apt-get purge -y --auto-remove $buildDeps</code></pre><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><pre><code>$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048 kBStep 1 : FROM nginx ---&gt; e43d811ce2f4Step 2 : RUN echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html ---&gt; Running in 9cdc27646c7b ---&gt; 44aa4490ce2cRemoving intermediate container 9cdc27646c7bSuccessfully built 44aa4490ce2c</code></pre><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><pre><code>docker build [选项] &lt;上下文路径/URL/-&gt;</code></pre><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><h3 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h3><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><pre><code>COPY ./package.json /app/</code></pre><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><pre><code>$ docker build -t nginx:v3 .Sending build context to Docker daemon 2.048 kB...</code></pre><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><h3 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="其它 docker build 的用法"></a>其它 <code>docker build</code> 的用法</h3><h4 id="直接用-Git-repo-进行构建"><a href="#直接用-Git-repo-进行构建" class="headerlink" title="直接用 Git repo 进行构建"></a>直接用 Git repo 进行构建</h4><p>或许你已经注意到了，<code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p><pre><code># $env:DOCKER_BUILDKIT=0# export DOCKER_BUILDKIT=0$ docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-worldStep 1/3 : FROM scratch ---&gt;Step 2/3 : COPY hello / ---&gt; ac779757d46eStep 3/3 : CMD ["/hello"] ---&gt; Running in d2a513a760edRemoving intermediate container d2a513a760ed ---&gt; 038ad4142d2bSuccessfully built 038ad4142d2b</code></pre><p>这行命令指定了构建所需的 Git repo，并且指定分支为 <code>master</code>，构建目录为 <code>/amd64/hello-world/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p><h4 id="用给定的-tar-压缩包构建"><a href="#用给定的-tar-压缩包构建" class="headerlink" title="用给定的 tar 压缩包构建"></a>用给定的 tar 压缩包构建</h4><pre><code>$ docker build http://server/context.tar.gz</code></pre><p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p><h4 id="从标准输入中读取-Dockerfile-进行构建"><a href="#从标准输入中读取-Dockerfile-进行构建" class="headerlink" title="从标准输入中读取 Dockerfile 进行构建"></a>从标准输入中读取 Dockerfile 进行构建</h4><pre><code>docker build - &lt; Dockerfile</code></pre><p>或</p><pre><code>cat Dockerfile | docker build -</code></pre><p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p><h4 id="从标准输入中读取上下文压缩包进行构建"><a href="#从标准输入中读取上下文压缩包进行构建" class="headerlink" title="从标准输入中读取上下文压缩包进行构建"></a>从标准输入中读取上下文压缩包进行构建</h4><pre><code>$ docker build - &lt; context.tar.gz</code></pre><p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p><h2 id="Dockerfile-指令详解"><a href="#Dockerfile-指令详解" class="headerlink" title="Dockerfile 指令详解"></a>Dockerfile 指令详解</h2><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p><ul><li><p><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></p></li><li><p><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;源路径1&gt;",... "&lt;目标路径&gt;"]</code></p></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p><pre><code>COPY package.json /usr/src/app/</code></pre><p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <code>filepath.Match</code> 规则，如：</p><pre><code>COPY hom* /mydir/COPY hom?.txt /mydir/</code></pre><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p><pre><code>COPY --chown=55:mygroup files* /mydir/COPY --chown=bin files* /mydir/COPY --chown=1 files* /mydir/COPY --chown=10:11 files* /mydir/</code></pre><p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p><h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p><p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p><p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p><pre><code>FROM scratchADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /...</code></pre><p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p><p>在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p><p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p><p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p><p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p><pre><code>ADD --chown=55:mygroup files* /mydir/ADD --chown=bin files* /mydir/ADD --chown=1 files* /mydir/ADD --chown=10:11 files* /mydir/</code></pre><h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><p><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></p></li><li><p><code>exec</code> 格式：<code>CMD ["可执行文件", "参数1", "参数2"...]</code></p></li><li><p>参数列表格式：<code>CMD ["参数1", "参数2"...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</p></li></ul><p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>"</code>，而不要使用单引号。</p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p><pre><code>CMD echo $HOME</code></pre><p>在实际执行中，会将其变更为：</p><pre><code>CMD [ "sh", "-c", "echo $HOME" ]</code></pre><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p><p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p><p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p><p>一些初学者将 <code>CMD</code> 写为：</p><pre><code>CMD service nginx start</code></pre><p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p><p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p><p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ "sh", "-c", "service nginx start"]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p><p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p><pre><code>CMD ["nginx", "-g", "daemon off;"]</code></pre><h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p><p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p><pre><code>&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</code></pre><p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</code> 有什么好处么？让我们来看几个场景。</p><h4 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h4><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p><pre><code>FROM ubuntu:18.04RUN apt-get update \    &amp;&amp; apt-get install -y curl \    &amp;&amp; rm -rf /var/lib/apt/lists/*CMD [ "curl", "-s", "http://myip.ipip.net" ]</code></pre><p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p><pre><code>$ docker run myip</code></pre><p>当前 IP：61.148.226.66 来自：北京市 联通</p><p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p><pre><code>$ docker run myip -idocker: Error response from daemon: invalid header field value "oci runtime error: container_linux.go:247: starting container process caused \"exec: \\\"-i\\\": executable file not found in $PATH\"\n".</code></pre><p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://myip.ipip.net</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p><pre><code>$ docker run myip curl -s http://myip.ipip.net -i</code></pre><p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p><pre><code>FROM ubuntu:18.04RUN apt-get update \    &amp;&amp; apt-get install -y curl \    &amp;&amp; rm -rf /var/lib/apt/lists/*ENTRYPOINT [ "curl", "-s", "http://myip.ipip.net" ]</code></pre><p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p><pre><code>$ docker run myip</code></pre><p>当前 IP：61.148.226.66 来自：北京市 联通</p><pre><code>$ docker run myip -iHTTP/1.1 200 OKServer: nginx/1.8.0Date: Tue, 22 Nov 2016 05:12:40 GMTContent-Type: text/html; charset=UTF-8Vary: Accept-EncodingX-Powered-By: PHP/5.6.24-1~dotdeb+7.1X-Cache: MISS from cache-2X-Cache-Lookup: MISS from cache-2:80X-Cache: MISS from proxy-2_6Transfer-Encoding: chunkedVia: 1.1 cache-2:80, 1.1 proxy-2_6:8006Connection: keep-alive</code></pre><p>当前 IP：61.148.226.66 来自：北京市 联通</p><p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p><h4 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h4><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p><p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p><p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p><p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p><pre><code>FROM alpine:3.4...RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis...ENTRYPOINT ["docker-entrypoint.sh"]EXPOSE 6379CMD [ "redis-server" ]</code></pre><p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p><pre><code>#!/bin/sh...# allow the container to be started with `--user`if [ "$1" = 'redis-server' -a "$(id -u)" = '0' ]; then    find . \! -user redis -exec chown redis '{}' +    exec gosu redis "$0" "$@"fiexec "$@"</code></pre><p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p><pre><code>$ docker run -it redis iduid=0(root) gid=0(root) groups=0(root)</code></pre><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p><ul><li><p><code>ENV &lt;key&gt; &lt;value&gt;</code></p></li><li><p><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></p></li></ul><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><pre><code>ENV VERSION=1.0 DEBUG=on \    NAME="Happy Feet"</code></pre><p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p><p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p><pre><code>ENV NODE_VERSION 7.2.0RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz" \  &amp;&amp; curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc" \  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \  &amp;&amp; grep " node-v$NODE_VERSION-linux-x64.tar.xz\$" SHASUMS256.txt | sha256sum -c - \  &amp;&amp; tar -xJf "node-v$NODE_VERSION-linux-x64.tar.xz" -C /usr/local --strip-components=1 \  &amp;&amp; rm "node-v$NODE_VERSION-linux-x64.tar.xz" SHASUMS256.txt.asc SHASUMS256.txt \  &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</code></pre><p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p><p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code>。</p><p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p><h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p><p>灵活的使用 <code>ARG</code> 指令，能够在不修改 Dockerfile 的情况下，构建出不同的镜像。</p><p>ARG 指令有生效范围，如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。</p><pre><code>ARG DOCKER_USERNAME=libraryFROM ${DOCKER_USERNAME}/alpineRUN set -x ; echo ${DOCKER_USERNAME}</code></pre><p>使用上述 Dockerfile 会发现无法输出 <code>${DOCKER_USERNAME}</code> 变量的值，要想正常输出，你必须在 <code>FROM</code> 之后再次指定 <code>ARG</code></p><pre><code># 只在 FROM 中生效ARG DOCKER_USERNAME=libraryFROM ${DOCKER_USERNAME}/alpine# 要想在 FROM 之后使用，必须再次指定ARG DOCKER_USERNAME=libraryRUN set -x ; echo ${DOCKER_USERNAME}</code></pre><p>对于多阶段构建，尤其要注意这个问题</p><pre><code># 这个变量在每个 FROM 中都生效ARG DOCKER_USERNAME=libraryFROM ${DOCKER_USERNAME}/alpineRUN set -x ; echo 1FROM ${DOCKER_USERNAME}/alpineRUN set -x ; echo 2</code></pre><p>对于上述 Dockerfile 两个 <code>FROM</code> 指令都可以使用 <code>${DOCKER_USERNAME}</code>，对于在各个阶段中使用的变量都必须在每个阶段分别指定：</p><pre><code>ARG DOCKER_USERNAME=libraryFROM ${DOCKER_USERNAME}/alpine# 在FROM 之后使用变量，必须在每个阶段分别指定ARG DOCKER_USERNAME=libraryRUN set -x ; echo ${DOCKER_USERNAME}FROM ${DOCKER_USERNAME}/alpine# 在FROM 之后使用变量，必须在每个阶段分别指定ARG DOCKER_USERNAME=libraryRUN set -x ; echo ${DOCKER_USERNAME}</code></pre><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p><ul><li><p><code>VOLUME ["&lt;路径1&gt;", "&lt;路径2&gt;"...]</code></p></li><li><p><code>VOLUME &lt;路径&gt;</code></p></li></ul><p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><pre><code>VOLUME /data</code></pre><p>这里的 <code>/data</code> 目录就会在容器运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：</p><pre><code>$ docker run -d -v mydata:/data xxxx</code></pre><p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p><h3 id="EXPOSE-暴露端口"><a href="#EXPOSE-暴露端口" class="headerlink" title="EXPOSE 暴露端口"></a>EXPOSE 暴露端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p><p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p><p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><pre><code>RUN cd /appRUN echo "hello" &gt; world.txt</code></pre><p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p><p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p><pre><code>WORKDIR /appRUN echo "hello" &gt; world.txt</code></pre><p>如果你的 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p><pre><code>WORKDIR /aWORKDIR bWORKDIR cRUN pwd</code></pre><p><code>RUN pwd</code> 的工作目录为 <code>/a/b/c</code>。</p><h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p><p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p><p>注意，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p><pre><code>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redisUSER redisRUN [ "redis-server" ]</code></pre><p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <code>gosu</code>。</p><pre><code># 建立 redis 用户，并使用 gosu 换另一个用户执行命令RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis# 下载 gosuRUN wget -O /usr/local/bin/gosu "https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64" \    &amp;&amp; chmod +x /usr/local/bin/gosu \    &amp;&amp; gosu nobody true# 设置 CMD，并以另外的用户执行CMD [ "exec", "gosu", "redis", "redis-server" ]</code></pre><h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h3><p>格式：</p><ul><li><p><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</p></li><li><p><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</p></li></ul><p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p><p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p><p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p><p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p><p><code>HEALTHCHECK</code> 支持下列选项：</p><ul><li><p><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</p></li><li><p><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</p></li><li><p><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</p></li></ul><p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p><p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p><p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p><pre><code>FROM nginxRUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*HEALTHCHECK --interval=5s --timeout=3s \  CMD curl -fs http://localhost/ || exit 1</code></pre><p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p><p>使用 <code>docker build</code> 来构建这个镜像：</p><pre><code>$ docker build -t myweb:v1 .</code></pre><p>构建好了后，我们启动一个容器：</p><pre><code>$ docker run -d --name web -p 80:80 myweb:v1</code></pre><p>当运行该镜像后，可以通过 <code>docker container ls</code> 看到最初的状态为 <code>(health: starting)</code>：</p><pre><code>$ docker container lsCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES03e28eb00bd0        myweb:v1            "nginx -g 'daemon off"   3 seconds ago       Up 2 seconds (health: starting)   80/tcp, 443/tcp     web</code></pre><p>在等待几秒钟后，再次 <code>docker container ls</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p><pre><code>$ docker container lsCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS               NAMES03e28eb00bd0        myweb:v1            "nginx -g 'daemon off"   18 seconds ago      Up 16 seconds (healthy)   80/tcp, 443/tcp     web</code></pre><p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code>。</p><p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p><pre><code>$ docker inspect --format '{{json .State.Health}}' web | python -m json.tool{    "FailingStreak": 0,    "Log": [        {            "End": "2016-11-25T14:35:37.940957051Z",            "ExitCode": 0,            "Output": "&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n",            "Start": "2016-11-25T14:35:37.780192565Z"        }    ],    "Status": "healthy"</code></pre><h3 id="ONBUILD-为他人作嫁衣裳"><a href="#ONBUILD-为他人作嫁衣裳" class="headerlink" title="ONBUILD 为他人作嫁衣裳"></a>ONBUILD 为他人作嫁衣裳</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p><p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p><p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p><p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p><pre><code>FROM node:slimRUN mkdir /appWORKDIR /appCOPY ./package.json /appRUN [ "npm", "install" ]COPY . /app/CMD [ "npm", "start" ]</code></pre><p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p><p>如果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。</p><p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p><pre><code>FROM node:slimRUN mkdir /appWORKDIR /appCMD [ "npm", "start" ]</code></pre><p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p><pre><code>FROM my-nodeCOPY ./package.json /appRUN [ "npm", "install" ]COPY . /app/</code></pre><p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新。</p><p>那么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p><p><code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p><pre><code>FROM node:slimRUN mkdir /appWORKDIR /appONBUILD COPY ./package.json /appONBUILD RUN [ "npm", "install" ]ONBUILD COPY . /app/CMD [ "npm", "start" ]</code></pre><p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p><pre><code>FROM my-node</code></pre><p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p><h3 id="LABEL-为镜像添加元数据"><a href="#LABEL-为镜像添加元数据" class="headerlink" title="LABEL 为镜像添加元数据"></a>LABEL 为镜像添加元数据</h3><p><code>LABEL</code> 指令用来给镜像以键值对的形式添加一些元数据（metadata）。</p><pre><code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></pre><p>我们还可以用一些标签来申明镜像的作者、文档地址等：</p><pre><code>LABEL org.opencontainers.image.authors="yeasy"LABEL org.opencontainers.image.documentation="https://yeasy.gitbooks.io"</code></pre><p>具体可以参考 <a href="https://github.com/opencontainers/image-spec/blob/master/annotations.md" target="_blank" rel="noopener">https://github.com/opencontainers/image-spec/blob/master/annotations.md</a></p><h3 id="SHELL-指令"><a href="#SHELL-指令" class="headerlink" title="SHELL 指令"></a>SHELL 指令</h3><p>格式：<code>SHELL ["executable", "parameters"]</code></p><pre><code>SHELL` 指令可以指定 `RUN` `ENTRYPOINT` `CMD` 指令的 shell，Linux 中默认为 `["/bin/sh", "-c"]SHELL ["/bin/sh", "-c"]RUN lll ; lsSHELL ["/bin/sh", "-cex"]RUN lll ; ls</code></pre><p>两个 <code>RUN</code> 运行同一命令，第二个 <code>RUN</code> 运行的命令会打印出每条命令并当遇到错误时退出。</p><p>当 <code>ENTRYPOINT</code> <code>CMD</code> 以 shell 格式指定时，<code>SHELL</code> 指令所指定的 shell 也会成为这两个指令的 shell</p><pre><code>SHELL ["/bin/sh", "-cex"]# /bin/sh -cex "nginx"ENTRYPOINT nginxSHELL ["/bin/sh", "-cex"]# /bin/sh -cex "nginx"CMD nginx</code></pre><h2 id="Dockerfile-多阶段构建"><a href="#Dockerfile-多阶段构建" class="headerlink" title="Dockerfile 多阶段构建"></a>Dockerfile 多阶段构建</h2><h3 id="之前的做法"><a href="#之前的做法" class="headerlink" title="之前的做法"></a>之前的做法</h3><p>在 Docker 17.05 版本之前，我们构建 Docker 镜像时，通常会采用两种方式：</p><h3 id="全部放入一个-Dockerfile"><a href="#全部放入一个-Dockerfile" class="headerlink" title="全部放入一个 Dockerfile"></a>全部放入一个 Dockerfile</h3><p>一种方式是将所有的构建过程编包含在一个 <code>Dockerfile</code> 中，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题：</p><ul><li><p>镜像层次多，镜像体积较大，部署时间变长</p></li><li><p>源代码存在泄露的风险</p></li></ul><p>例如，编写 <code>app.go</code> 文件，该程序输出 <code>Hello World!</code></p><pre><code>package mainimport "fmt"func main(){    fmt.Printf("Hello World!");}</code></pre><p>编写 <code>Dockerfile.one</code> 文件</p><pre><code>FROM golang:alpineRUN apk --no-cache add git ca-certificatesWORKDIR /go/src/github.com/go/helloworld/COPY app.go .RUN go get -d -v github.com/go-sql-driver/mysql \  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \  &amp;&amp; cp /go/src/github.com/go/helloworld/app /rootWORKDIR /root/CMD ["./app"]</code></pre><p>构建镜像</p><pre><code>$ docker build -t go/helloworld:1 -f Dockerfile.one .</code></pre><h4 id="分散到多个-Dockerfile"><a href="#分散到多个-Dockerfile" class="headerlink" title="分散到多个 Dockerfile"></a>分散到多个 Dockerfile</h4><p>另一种方式，就是我们事先在一个 <code>Dockerfile</code> 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 <code>Dockerfile</code> 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。</p><p>例如，编写 <code>Dockerfile.build</code> 文件</p><pre><code>FROM golang:alpineRUN apk --no-cache add gitWORKDIR /go/src/github.com/go/helloworldCOPY app.go .RUN go get -d -v github.com/go-sql-driver/mysql \  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</code></pre><p>编写 <code>Dockerfile.copy</code> 文件</p><pre><code>FROM alpine:latestRUN apk --no-cache add ca-certificatesWORKDIR /root/COPY app .CMD ["./app"]</code></pre><p>新建 <code>build.sh</code></p><pre><code>#!/bin/shecho Building go/helloworld:builddocker build -t go/helloworld:build . -f Dockerfile.builddocker create --name extract go/helloworld:builddocker cp extract:/go/src/github.com/go/helloworld/app ./appdocker rm -f extractecho Building go/helloworld:2docker build --no-cache -t go/helloworld:2 . -f Dockerfile.copyrm ./app</code></pre><p>现在运行脚本即可构建镜像</p><pre><code>$ chmod +x build.sh$ ./build.sh</code></pre><p>对比两种方式生成的镜像大小</p><pre><code>$ docker image lsREPOSITORY      TAG    IMAGE ID        CREATED         SIZEgo/helloworld   2      f7cf3465432c    22 seconds ago  6.47MBgo/helloworld   1      f55d3e16affc    2 minutes ago   295MB</code></pre><h3 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h3><p>为解决以上问题，Docker v17.05 开始支持多阶段构建 (<code>multistage builds</code>)。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 <code>Dockerfile</code>：</p><p>例如，编写 <code>Dockerfile</code> 文件</p><pre><code>FROM golang:alpine as builderRUN apk --no-cache add gitWORKDIR /go/src/github.com/go/helloworld/RUN go get -d -v github.com/go-sql-driver/mysqlCOPY app.go .RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .FROM alpine:latest as prodRUN apk --no-cache add ca-certificatesWORKDIR /root/COPY --from=0 /go/src/github.com/go/helloworld/app .CMD ["./app"]</code></pre><p>构建镜像</p><pre><code>$ docker build -t go/helloworld:3 .</code></pre><p>对比三个镜像大小</p><pre><code>$ docker image lsREPOSITORY        TAG   IMAGE ID         CREATED            SIZEgo/helloworld     3     d6911ed9c846     7 seconds ago      6.47MBgo/helloworld     2     f7cf3465432c     22 seconds ago     6.47MBgo/helloworld     1     f55d3e16affc     2 minutes ago      295MB</code></pre><p>很明显使用多阶段构建的镜像体积小，同时也完美解决了上边提到的问题。</p><h4 id="只构建某一阶段的镜像"><a href="#只构建某一阶段的镜像" class="headerlink" title="只构建某一阶段的镜像"></a>只构建某一阶段的镜像</h4><p>我们可以使用 <code>as</code> 来为某一阶段命名，例如</p><pre><code>FROM golang:alpine as builder</code></pre><p>例如当我们只想构建 <code>builder</code> 阶段的镜像时，增加 <code>--target=builder</code> 参数即可</p><pre><code>$ docker build --target builder -t username/imagename:tag .</code></pre><h4 id="构建时从其他镜像复制文件"><a href="#构建时从其他镜像复制文件" class="headerlink" title="构建时从其他镜像复制文件"></a>构建时从其他镜像复制文件</h4><p>上面例子中我们使用 <code>COPY --from=0 /go/src/github.com/go/helloworld/app .</code> 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件。</p><pre><code>$ COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</code></pre><h2 id="实战多阶段构建-Laravel-镜像"><a href="#实战多阶段构建-Laravel-镜像" class="headerlink" title="实战多阶段构建 Laravel 镜像"></a>实战多阶段构建 Laravel 镜像</h2><blockquote><p>本节适用于 PHP 开发者阅读。<code>Laravel</code> 基于 8.x 版本，各个版本的文件结构可能会有差异，请根据实际自行修改。</p></blockquote><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>新建一个 <code>Laravel</code> 项目或在已有的 <code>Laravel</code> 项目根目录下新建 <code>Dockerfile</code> <code>.dockerignore</code> <code>laravel.conf</code> 文件。</p><p>在 <code>.dockerignore</code> 文件中写入以下内容。</p><pre><code>.idea/.git/vendor/node_modules/public/js/public/css/public/mix-manifest.jsonyarn-error.logbootstrap/cache/*storage/# 自行添加其他需要排除的文件，例如 .env.* 文件</code></pre><p>在 <code>laravel.conf</code> 文件中写入 nginx 配置。</p><pre><code>server {  listen 80 default_server;  root /app/laravel/public;  index index.php index.html;  location / {      try_files $uri $uri/ /index.php?$query_string;  }  location ~ .*\.php(\/.*)*$ {    fastcgi_pass   laravel:9000;    include        fastcgi.conf;    # fastcgi_connect_timeout 300;    # fastcgi_send_timeout 300;    # fastcgi_read_timeout 300;  }}</code></pre><h3 id="前端构建"><a href="#前端构建" class="headerlink" title="前端构建"></a>前端构建</h3><p>第一阶段进行前端构建。</p><pre><code>FROM node:alpine as frontendCOPY package.json /app/RUN set -x ; cd /app \      &amp;&amp; npm install --registry=https://registry.npm.taobao.orgCOPY webpack.mix.js webpack.config.js tailwind.config.js /app/COPY resources/ /app/resources/RUN set -x ; cd /app \      &amp;&amp; touch artisan \      &amp;&amp; mkdir -p public \      &amp;&amp; npm run production</code></pre><h3 id="安装-Composer-依赖"><a href="#安装-Composer-依赖" class="headerlink" title="安装 Composer 依赖"></a>安装 Composer 依赖</h3><p>第二阶段安装 Composer 依赖。</p><pre><code>FROM composer as composerCOPY database/ /app/database/COPY composer.json composer.lock /app/RUN set -x ; cd /app \      &amp;&amp; composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ \      &amp;&amp; composer install \           --ignore-platform-reqs \           --no-interaction \           --no-plugins \           --no-scripts \           --prefer-dist</code></pre><h3 id="整合以上阶段所生成的文件"><a href="#整合以上阶段所生成的文件" class="headerlink" title="整合以上阶段所生成的文件"></a>整合以上阶段所生成的文件</h3><p>第三阶段对以上阶段生成的文件进行整合。</p><pre><code>FROM php:7.4-fpm-alpine as laravelARG LARAVEL_PATH=/app/laravelCOPY --from=composer /app/vendor/ ${LARAVEL_PATH}/vendor/COPY . ${LARAVEL_PATH}COPY --from=frontend /app/public/js/ ${LARAVEL_PATH}/public/js/COPY --from=frontend /app/public/css/ ${LARAVEL_PATH}/public/css/COPY --from=frontend /app/public/mix-manifest.json ${LARAVEL_PATH}/public/mix-manifest.jsonRUN set -x ; cd ${LARAVEL_PATH} \      &amp;&amp; mkdir -p storage \      &amp;&amp; mkdir -p storage/framework/cache \      &amp;&amp; mkdir -p storage/framework/sessions \      &amp;&amp; mkdir -p storage/framework/testing \      &amp;&amp; mkdir -p storage/framework/views \      &amp;&amp; mkdir -p storage/logs \      &amp;&amp; chmod -R 777 storage \      &amp;&amp; php artisan package:discover</code></pre><h3 id="最后一个阶段构建-NGINX-镜像"><a href="#最后一个阶段构建-NGINX-镜像" class="headerlink" title="最后一个阶段构建 NGINX 镜像"></a>最后一个阶段构建 NGINX 镜像</h3><pre><code>FROM nginx:alpine as nginxARG LARAVEL_PATH=/app/laravelCOPY laravel.conf /etc/nginx/conf.d/COPY --from=laravel ${LARAVEL_PATH}/public ${LARAVEL_PATH}/public</code></pre><h3 id="构建-Laravel-及-Nginx-镜像"><a href="#构建-Laravel-及-Nginx-镜像" class="headerlink" title="构建 Laravel 及 Nginx 镜像"></a>构建 Laravel 及 Nginx 镜像</h3><p>使用 <code>docker build</code> 命令构建镜像。</p><pre><code>$ docker build -t my/laravel --target=laravel .$ docker build -t my/nginx --target=nginx .</code></pre><h3 id="启动容器并测试"><a href="#启动容器并测试" class="headerlink" title="启动容器并测试"></a>启动容器并测试</h3><p>新建 Docker 网络</p><pre><code>$ docker network create laravel</code></pre><p>启动 laravel 容器， <code>--name=laravel</code> 参数设定的名字必须与 <code>nginx</code> 配置文件中的 <code>fastcgi_pass laravel:9000;</code> 一致</p><pre><code>$ docker run -dit --rm --name=laravel --network=laravel my/laravel</code></pre><p>启动 nginx 容器</p><pre><code>$ docker run -dit --rm --network=laravel -p 8080:80 my/nginx</code></pre><p>浏览器访问 <code>127.0.0.1:8080</code> 可以看到 Laravel 项目首页。</p><blockquote><p>也许 Laravel 项目依赖其他外部服务，例如 redis、MySQL，请自行启动这些服务之后再进行测试，本小节不再赘述。</p></blockquote><h3 id="生产环境优化"><a href="#生产环境优化" class="headerlink" title="生产环境优化"></a>生产环境优化</h3><p>本小节内容为了方便测试，将配置文件直接放到了镜像中，实际在使用时 <strong>建议</strong> 将配置文件作为 <code>config</code> 或 <code>secret</code> 挂载到容器中，请读者自行学习 <code>Swarm mode</code> 或 <code>Kubernetes</code> 的相关内容。</p><p>由于篇幅所限本小节只是简单列出，更多内容可以参考 <a href="https://github.com/khs1994-docker/laravel-demo" target="_blank" rel="noopener">https://github.com/khs1994-docker/laravel-demo</a> 项目。</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>完整的 <code>Dockerfile</code> 文件如下。</p><pre><code>FROM node:alpine as frontendCOPY package.json /app/RUN set -x ; cd /app \      &amp;&amp; npm install --registry=https://registry.npm.taobao.orgCOPY webpack.mix.js webpack.config.js tailwind.config.js /app/COPY resources/ /app/resources/RUN set -x ; cd /app \      &amp;&amp; touch artisan \      &amp;&amp; mkdir -p public \      &amp;&amp; npm run productionFROM composer as composerCOPY database/ /app/database/COPY composer.json /app/RUN set -x ; cd /app \      &amp;&amp; composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ \      &amp;&amp; composer install \           --ignore-platform-reqs \           --no-interaction \           --no-plugins \           --no-scripts \           --prefer-distFROM php:7.4-fpm-alpine as laravelARG LARAVEL_PATH=/app/laravelCOPY --from=composer /app/vendor/ ${LARAVEL_PATH}/vendor/COPY . ${LARAVEL_PATH}COPY --from=frontend /app/public/js/ ${LARAVEL_PATH}/public/js/COPY --from=frontend /app/public/css/ ${LARAVEL_PATH}/public/css/COPY --from=frontend /app/public/mix-manifest.json ${LARAVEL_PATH}/public/mix-manifest.jsonRUN set -x ; cd ${LARAVEL_PATH} \      &amp;&amp; mkdir -p storage \      &amp;&amp; mkdir -p storage/framework/cache \      &amp;&amp; mkdir -p storage/framework/sessions \      &amp;&amp; mkdir -p storage/framework/testing \      &amp;&amp; mkdir -p storage/framework/views \      &amp;&amp; mkdir -p storage/logs \      &amp;&amp; chmod -R 777 storage \      &amp;&amp; php artisan package:discoverFROM nginx:alpine as nginxARG LARAVEL_PATH=/app/laravelCOPY laravel.conf /etc/nginx/conf.d/COPY --from=laravel ${LARAVEL_PATH}/public ${LARAVEL_PATH}/public</code></pre><h2 id="构建多种系统架构支持的-Docker-镜像"><a href="#构建多种系统架构支持的-Docker-镜像" class="headerlink" title="构建多种系统架构支持的 Docker 镜像"></a>构建多种系统架构支持的 Docker 镜像</h2><p>我们知道使用镜像创建一个容器，该镜像必须与 Docker 宿主机系统架构一致，例如 <code>Linux x86_64</code> 架构的系统中只能使用 <code>Linux x86_64</code> 的镜像创建容器。</p><blockquote><p>Windows、macOS 除外，其使用了 <a href="https://docs.docker.com/docker-for-mac/multi-arch/" target="_blank" rel="noopener">binfmt_misc</a> 提供了多种架构支持，在 Windows、macOS 系统上 (x86_64) 可以运行 arm 等其他架构的镜像。</p></blockquote><p>例如我们在 <code>Linux x86_64</code> 中构建一个 <code>username/test</code> 镜像。</p><pre><code>FROM alpineCMD echo 1</code></pre><p>构建镜像后推送到 Docker Hub，之后我们尝试在树莓派 <code>Linux arm64v8</code> 中使用这个镜像。</p><pre><code>$ docker run -it --rm username/test</code></pre><p>可以发现这个镜像根本获取不到。</p><p>要解决这个问题，通常采用的做法是通过镜像名区分不同系统架构的镜像，例如在 <code>Linux x86_64</code> 和 <code>Linux arm64v8</code> 分别构建 <code>username/test</code> 和 <code>username/arm64v8-test</code> 镜像。运行时使用对应架构的镜像即可。</p><p>这样做显得很繁琐，那么有没有一种方法让 Docker 引擎根据系统架构自动拉取对应的镜像呢？</p><p>我们发现在 <code>Linux x86_64</code> 和 <code>Linux arm64v8</code> 架构的计算机中分别使用 <code>golang:alpine</code> 镜像运行容器 <code>$ docker run golang:alpine go version</code> 时，容器能够正常的运行。</p><p>这是什么原因呢？</p><p>原因就是 <code>golang:alpine</code> 官方镜像有一个 <code>manifest</code><a href="https://docs.docker.com/registry/spec/manifest-v2-2/" target="_blank" rel="noopener"> 列表 (</a><code>manifest list</code><a href="https://docs.docker.com/registry/spec/manifest-v2-2/" target="_blank" rel="noopener">)</a>。</p><p>当用户获取一个镜像时，Docker 引擎会首先查找该镜像是否有 <code>manifest</code> 列表，如果有的话 Docker 引擎会按照 Docker 运行环境（系统及架构）查找出对应镜像（例如 <code>golang:alpine</code>）。如果没有的话会直接获取镜像（例如上例中我们构建的 <code>username/test</code>）。</p><p>我们可以使用 <code>$ docker manifest inspect golang:alpine</code> 查看这个 <code>manifest</code> 列表的结构。</p><pre><code>$ docker manifest inspect golang:alpine{   "schemaVersion": 2,   "mediaType": "application/vnd.docker.distribution.manifest.list.v2+json",   "manifests": [      {         "mediaType": "application/vnd.docker.distribution.manifest.v2+json",         "size": 1365,         "digest": "sha256:5e28ac423243b187f464d635bcfe1e909f4a31c6c8bce51d0db0a1062bec9e16",         "platform": {            "architecture": "amd64",            "os": "linux"         }      },      {         "mediaType": "application/vnd.docker.distribution.manifest.v2+json",         "size": 1365,         "digest": "sha256:2945c46e26c9787da884b4065d1de64cf93a3b81ead1b949843dda1fcd458bae",         "platform": {            "architecture": "arm",            "os": "linux",            "variant": "v7"         }      },      {         "mediaType": "application/vnd.docker.distribution.manifest.v2+json",         "size": 1365,         "digest": "sha256:87fff60114fd3402d0c1a7ddf1eea1ded658f171749b57dc782fd33ee2d47b2d",         "platform": {            "architecture": "arm64",            "os": "linux",            "variant": "v8"         }      },      {         "mediaType": "application/vnd.docker.distribution.manifest.v2+json",         "size": 1365,         "digest": "sha256:607b43f1d91144f82a9433764e85eb3ccf83f73569552a49bc9788c31b4338de",         "platform": {            "architecture": "386",            "os": "linux"         }      },      {         "mediaType": "application/vnd.docker.distribution.manifest.v2+json",         "size": 1365,         "digest": "sha256:25ead0e21ed5e246ce31e274b98c09aaf548606788ef28eaf375dc8525064314",         "platform": {            "architecture": "ppc64le",            "os": "linux"         }      },      {         "mediaType": "application/vnd.docker.distribution.manifest.v2+json",         "size": 1365,         "digest": "sha256:69f5907fa93ea591175b2c688673775378ed861eeb687776669a48692bb9754d",         "platform": {            "architecture": "s390x",            "os": "linux"         }      }   ]}</code></pre><p>可以看出 <code>manifest</code> 列表中包含了不同系统架构所对应的镜像 <code>digest</code> 值，这样 Docker 就可以在不同的架构中使用相同的 <code>manifest</code> (例如 <code>golang:alpine</code>) 获取对应的镜像。</p><p>下面介绍如何使用 <code>$ docker manifest</code> 命令创建并推送 <code>manifest</code> 列表到 Docker Hub。</p><h3 id="构建镜像-1"><a href="#构建镜像-1" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>首先在 <code>Linux x86_64</code> 构建 <code>username/x8664-test</code> 镜像。并在 <code>Linux arm64v8</code> 中构建 <code>username/arm64v8-test</code> 镜像，构建好之后推送到 Docker Hub。</p><h3 id="创建-manifest-列表"><a href="#创建-manifest-列表" class="headerlink" title="创建 manifest 列表"></a>创建 <code>manifest</code> 列表</h3><pre><code># $ docker manifest create MANIFEST_LIST MANIFEST [MANIFEST...]$ docker manifest create username/test \      username/x8664-test \      username/arm64v8-test</code></pre><p>当要修改一个 <code>manifest</code> 列表时，可以加入 <code>-a</code> 或 <code>--amend</code> 参数。</p><h3 id="设置-manifest-列表"><a href="#设置-manifest-列表" class="headerlink" title="设置 manifest 列表"></a>设置 <code>manifest</code> 列表</h3><pre><code># $ docker manifest annotate [OPTIONS] MANIFEST_LIST MANIFEST$ docker manifest annotate username/test \      username/x8664-test \      --os linux --arch x86_64$ docker manifest annotate username/test \      username/arm64v8-test \      --os linux --arch arm64 --variant v8</code></pre><p>这样就配置好了 <code>manifest</code> 列表。</p><h3 id="查看-manifest-列表"><a href="#查看-manifest-列表" class="headerlink" title="查看 manifest 列表"></a>查看 <code>manifest</code> 列表</h3><pre><code>$ docker manifest inspect username/test</code></pre><h3 id="推送-manifest-列表"><a href="#推送-manifest-列表" class="headerlink" title="推送 manifest 列表"></a>推送 <code>manifest</code> 列表</h3><p>最后我们可以将其推送到 Docker Hub。</p><pre><code>$ docker manifest push username/test</code></pre><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我们在 <code>Linux x86_64</code> <code>Linux arm64v8</code> 中分别执行 <code>$ docker run -it --rm username/test</code> 命令，发现可以正确的执行。</p><h2 id="其它制作镜像的方式"><a href="#其它制作镜像的方式" class="headerlink" title="其它制作镜像的方式"></a>其它制作镜像的方式</h2><p>除了标准的使用 <code>Dockerfile</code> 生成镜像的方法外，由于各种特殊需求和历史原因，还提供了一些其它方法用以生成镜像。</p><h3 id="从-rootfs-压缩包导入"><a href="#从-rootfs-压缩包导入" class="headerlink" title="从 rootfs 压缩包导入"></a>从 rootfs 压缩包导入</h3><p>格式：<code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></p><p>压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。压缩包将会在镜像 <code>/</code> 目录展开，并直接作为镜像第一层提交。</p><p>比如我们想要创建一个 <a href="https://openvz.org/" target="_blank" rel="noopener">OpenVZ</a> 的 Ubuntu 16.04 <a href="https://wiki.openvz.org/Download/template/precreated" target="_blank" rel="noopener">模板</a>的镜像：</p><pre><code>$ docker import \    http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz \    openvz/ubuntu:16.04Downloading from http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gzsha256:412b8fc3e3f786dca0197834a698932b9c51b69bd8cf49e100c35d38c9879213</code></pre><p>这条命令自动下载了 <code>ubuntu-16.04-x86_64.tar.gz</code> 文件，并且作为根文件系统展开导入，并保存为镜像 <code>openvz/ubuntu:16.04</code>。</p><p>导入成功后，我们可以用 <code>docker image ls</code> 看到这个导入的镜像：</p><pre><code>$ docker image ls openvz/ubuntuREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEopenvz/ubuntu       16.04               412b8fc3e3f7        55 seconds ago      505MB</code></pre><p>如果我们查看其历史的话，会看到描述中有导入的文件链接：</p><pre><code>$ docker history openvz/ubuntu:16.04IMAGE               CREATED              CREATED BY          SIZE                COMMENTf477a6e18e98        About a minute ago                       214.9 MB            Imported from http://download.openvz.org/template/precreated/ubuntu-16.04-x86_64.tar.gz</code></pre><h3 id="Docker-镜像的导入和导出-docker-save-和-docker-load"><a href="#Docker-镜像的导入和导出-docker-save-和-docker-load" class="headerlink" title="Docker 镜像的导入和导出 docker save 和 docker load"></a>Docker 镜像的导入和导出 <code>docker save</code> 和 <code>docker load</code></h3><p>Docker 还提供了 <code>docker save</code> 和 <code>docker load</code> 命令，用以将镜像保存为一个文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。</p><h4 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h4><p>使用 <code>docker save</code> 命令可以将镜像保存为归档文件。</p><p>比如我们希望保存这个 <code>alpine</code> 镜像。</p><pre><code>$ docker image ls alpineREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEalpine              latest              baa5d63471ea        5 weeks ago         4.803 MB</code></pre><p>保存镜像的命令为：</p><pre><code>$ docker save alpine -o filename$ file filenamefilename: POSIX tar archive</code></pre><p>这里的 filename 可以为任意名称甚至任意后缀名，但文件的本质都是归档文件</p><p><strong>注意：如果同名则会覆盖（没有警告）</strong></p><p>若使用 <code>gzip</code> 压缩：</p><pre><code>$ docker save alpine | gzip &gt; alpine-latest.tar.gz</code></pre><p>然后我们将 <code>alpine-latest.tar.gz</code> 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像：</p><pre><code>$ docker load -i alpine-latest.tar.gzLoaded image: alpine:latest</code></pre><p>如果我们结合这两个命令以及 <code>ssh</code> 甚至 <code>pv</code> 的话，利用 Linux 强大的管道，我们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能：</p><pre><code>docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; 'cat | docker load'</code></pre><h1 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><h3 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h3><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><pre><code>$ docker run ubuntu:18.04 /bin/echo 'Hello world'Hello world</code></pre><p>这跟在本地直接执行 <code>/bin/echo 'hello world'</code> 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><pre><code>$ docker run -t -i ubuntu:18.04 /bin/bashroot@af8bae53bdd3:/#</code></pre><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p><pre><code>root@af8bae53bdd3:/# pwd/root@af8bae53bdd3:/# lsbin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</code></pre><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li><p>检查本地是否存在指定的镜像，不存在就从 <a href="https://yeasy.gitbook.io/docker_practice/repository" target="_blank" rel="noopener">registry</a> 下载</p></li><li><p>利用镜像创建并启动一个容器</p></li><li><p>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</p></li><li><p>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</p></li><li><p>从地址池配置一个 ip 地址给容器</p></li><li><p>执行用户指定的应用程序</p></li><li><p>执行完毕后容器被终止</p></li></ul><h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><pre><code>root@ba267838cc1b:/# ps  PID TTY          TIME CMD    1 ?        00:00:00 bash   11 ?        00:00:00 ps</code></pre><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><h2 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h2><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><pre><code>$ docker run ubuntu:18.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"hello worldhello worldhello worldhello world</code></pre><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p>如果使用了 <code>-d</code> 参数运行容器。</p><pre><code>$ docker run -d ubuntu:18.04 /bin/sh -c "while true; do echo hello world; sleep 1; done"77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</code></pre><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p><p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><pre><code>$ docker container lsCONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES77b2dc01fe0f  ubuntu:18.04  /bin/sh -c 'while tr  2 minutes ago  Up 1 minute        agitated_wright</code></pre><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p><pre><code>$ docker container logs [container ID or NAMES]hello worldhello worldhello world. . .</code></pre><h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h2><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p><pre><code>$ docker container ls -aCONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMESba267838cc1b        ubuntu:18.04             "/bin/bash"            30 minutes ago      Exited (0) About a minute ago                       trusting_newton</code></pre><p>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</p><p>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p><h3 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h3><p>下面示例如何使用 <code>docker attach</code> 命令。</p><pre><code>$ docker run -dit ubuntu243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES243c32535da7        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           nostalgic_hypatia$ docker attach 243croot@243c32535da7:/#</code></pre><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p><h3 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h3><h4 id="i-t-参数"><a href="#i-t-参数" class="headerlink" title="-i -t 参数"></a><code>-i</code> <code>-t</code> 参数</h4><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><pre><code>$ docker run -dit ubuntu69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES69d137adef7a        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           zealous_swirles$ docker exec -i 69d1 bashlsbinbootdev...$ docker exec -it 69d1 bashroot@69d137adef7a:/#</code></pre><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p><p>更多参数说明请使用 <code>docker exec --help</code> 查看。</p><h2 id="导出和导入"><a href="#导出和导入" class="headerlink" title="导出和导入"></a>导出和导入</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><pre><code>$ docker container ls -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES7691a814370e        ubuntu:18.04        "/bin/bash"         36 hours ago        Exited (0) 21 hours ago                       test$ docker export 7691a814370e &gt; ubuntu.tar</code></pre><p>这样将导出容器快照到本地文件。</p><h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><pre><code>$ cat ubuntu.tar | docker import - test/ubuntu:v1.0$ docker image lsREPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZEtest/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</code></pre><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><pre><code>$ docker import http://example.com/exampleimage.tgz example/imagerepo</code></pre><p><em>注：用户既可以使用</em> <code>*docker load*</code> <em>来导入镜像存储文件到本地镜像库，也可以使用</em> <code>*docker import*</code> <em>来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</em></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><pre><code>$ docker container rm trusting_newtontrusting_newton</code></pre><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h3 id="清理所有处于终止状态的容器"><a href="#清理所有处于终止状态的容器" class="headerlink" title="清理所有处于终止状态的容器"></a>清理所有处于终止状态的容器</h3><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><pre><code>$ docker container prune</code></pre><h1 id="访问仓库"><a href="#访问仓库" class="headerlink" title="访问仓库"></a>访问仓库</h1><p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p><p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>docker.io/ubuntu</code> 来说，<code>docker.io</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p><p>大部分时候，并不需要严格区分这两者的概念</p><h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，其中已经包括了数量超过 <a href="https://hub.docker.com/search/?type=image" target="_blank" rel="noopener">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>你可以在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p><p>你可以通过 <code>docker logout</code> 退出登录。</p><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>你可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p><p>例如以 <code>centos</code> 为关键词进行搜索：</p><pre><code>$ docker search centosNAME                               DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDcentos                             The official build of CentOS.                   6449      [OK]ansible/centos7-ansible            Ansible on Centos7                              132                  [OK]consol/centos-xfce-vnc             Centos container with "headless" VNC session…   126                  [OK]jdeathe/centos-ssh                 OpenSSH / Supervisor / EPEL/IUS/SCL Repos - …   117                  [OK]centos/systemd                     systemd enabled base container.                 96                   [OK]</code></pre><p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（<code>OFFICIAL</code>）、是否自动构建 （<code>AUTOMATED</code>）。</p><p>根据是否是官方提供，可将镜像分为两类。</p><p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p><p>还有一种类型，比如 <code>ansible/centos7-ansible</code> 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 ansible 用户。</p><p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p><p>下载官方 <code>centos</code> 镜像到本地。</p><pre><code>$ docker pull centosUsing default tag: latestlatest: Pulling from library/centos7a0437f04f83: Pull completeDigest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1Status: Downloaded newer image for centos:latestdocker.io/library/centos:latest</code></pre><h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p><p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p><pre><code>$ docker tag ubuntu:18.04 username/ubuntu:18.04$ docker image lsREPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZEubuntu                                                   18.04                  275d79972a86        6 days ago          94.6MBusername/ubuntu                                          18.04                  275d79972a86        6 days ago          94.6MB$ docker push username/ubuntu:18.04$ docker search usernameNAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDusername/ubuntu</code></pre><h3 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h3><blockquote><p>2021 年 6 月 18 日之后，该项功能仅限<a href="https://www.docker.com/blog/changes-to-docker-hub-autobuilds/" target="_blank" rel="noopener">付费用户</a>使用。</p></blockquote><p>自动构建（<code>Automated Builds</code>）功能对于需要经常升级镜像内程序来说，十分方便。</p><p>有时候，用户构建了镜像，安装了某个软件，当软件发布新版本则需要手动更新镜像。</p><p>而自动构建允许用户通过 Docker Hub 指定跟踪一个目标网站（支持 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a> 或 <a href="https://bitbucket.org/" target="_blank" rel="noopener">BitBucket</a>）上的项目，一旦项目发生新的提交 （<code>commit</code>）或者创建了新的标签（<code>tag</code>），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p><p>要配置自动构建，包括如下的步骤：</p><ul><li><p>登录 Docker Hub；</p></li><li><p>在 Docker Hub 点击右上角头像，在账号设置（<code>Account Settings</code>）中关联（<code>Linked Accounts</code>）目标网站；</p></li><li><p>在 Docker Hub 中新建或选择已有的仓库，在 <code>Builds</code> 选项卡中选择 <code>Configure Automated Builds</code>；</p></li><li><p>选取一个目标网站中的项目（需要含 <code>Dockerfile</code>）和分支；</p></li><li><p>指定 <code>Dockerfile</code> 的位置，并保存。</p></li></ul><p>之后，可以在 Docker Hub 的仓库页面的 <code>Timeline</code> 选项卡中查看每次构建的状态。</p><h2 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h2><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p><p>本节介绍如何使用本地仓库。</p><p><code>docker-registry</code> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <code>docker-registry</code> v2.x 版本。</p><h3 id="安装运行-docker-registry"><a href="#安装运行-docker-registry" class="headerlink" title="安装运行 docker-registry"></a>安装运行 docker-registry</h3><h4 id="容器运行"><a href="#容器运行" class="headerlink" title="容器运行"></a>容器运行</h4><p>你可以使用官方 <code>registry</code> 镜像来运行。</p><pre><code>$ docker run -d -p 5000:5000 --restart=always --name registry registry</code></pre><p>这将使用官方的 <code>registry</code> 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。你可以通过 <code>-v</code> 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 <code>/opt/data/registry</code> 目录。</p><pre><code>$ docker run -d \    -p 5000:5000 \    -v /opt/data/registry:/var/lib/registry \    registry</code></pre><h3 id="在私有仓库上传、搜索、下载镜像"><a href="#在私有仓库上传、搜索、下载镜像" class="headerlink" title="在私有仓库上传、搜索、下载镜像"></a>在私有仓库上传、搜索、下载镜像</h3><p>创建好私有仓库之后，就可以使用 <code>docker tag</code> 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 <code>127.0.0.1:5000</code>。</p><p>先在本机查看已有的镜像。</p><pre><code>$ docker image lsREPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZEubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</code></pre><p>使用 <code>docker tag</code> 将 <code>ubuntu:latest</code> 这个镜像标记为 <code>127.0.0.1:5000/ubuntu:latest</code>。</p><p>格式为 <code>docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</code>。</p><pre><code>$ docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest$ docker image lsREPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZEubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB</code></pre><p>使用 <code>docker push</code> 上传标记的镜像。</p><pre><code>$ docker push 127.0.0.1:5000/ubuntu:latestThe push refers to repository [127.0.0.1:5000/ubuntu]373a30c24545: Pusheda9148f5200b0: Pushedcdd3de0940ab: Pushedfc56279bbb33: Pushedb38367233d37: Pushed2aebd096e0e2: Pushedlatest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568</code></pre><p>用 <code>curl</code> 查看仓库中的镜像。</p><pre><code>$ curl 127.0.0.1:5000/v2/_catalog{"repositories":["ubuntu"]}</code></pre><p>这里可以看到 <code>{"repositories":["ubuntu"]}</code>，表明镜像已经被成功上传了。</p><p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p><pre><code>$ docker image rm 127.0.0.1:5000/ubuntu:latest$ docker pull 127.0.0.1:5000/ubuntu:latestPulling repository 127.0.0.1:5000/ubuntu:latestba5877dc9bec: Download complete511136ea3c5a: Download complete9bad880da3d2: Download complete25f11f5fb0cb: Download completeebc34468f71d: Download complete2318d26665ef: Download complete$ docker image lsREPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB</code></pre><h3 id="配置非-https-仓库地址"><a href="#配置非-https-仓库地址" class="headerlink" title="配置非 https 仓库地址"></a>配置非 https 仓库地址</h3><p>如果你不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p><p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 <code>HTTPS</code> 访问的私有仓库。</p><h4 id="Ubuntu-16-04-Debian-8-centos-7"><a href="#Ubuntu-16-04-Debian-8-centos-7" class="headerlink" title="Ubuntu 16.04+, Debian 8+, centos 7"></a>Ubuntu 16.04+, Debian 8+, centos 7</h4><p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p><pre><code>{  "registry-mirror": [    "https://hub-mirror.c.163.com",    "https://mirror.baidubce.com"  ],  "insecure-registries": [    "192.168.199.100:5000"  ]}</code></pre><blockquote><p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>对于 Docker Desktop for Windows 、 Docker Desktop for Mac 在设置中的 <code>Docker Engine</code> 中进行编辑 ，增加和上边一样的字符串即可。</p><h2 id="私有仓库高级配置"><a href="#私有仓库高级配置" class="headerlink" title="私有仓库高级配置"></a>私有仓库高级配置</h2><p>上一节我们搭建了一个具有基础功能的私有仓库，本小节我们来使用 <code>Docker Compose</code> 搭建一个拥有权限认证、TLS 的私有仓库。</p><p>新建一个文件夹，以下步骤均在该文件夹中进行。</p><h3 id="准备站点证书"><a href="#准备站点证书" class="headerlink" title="准备站点证书"></a>准备站点证书</h3><p>如果你拥有一个域名，国内各大云服务商均提供免费的站点证书。你也可以使用 <code>openssl</code> 自行签发证书。</p><p>这里假设我们将要搭建的私有仓库地址为 <code>docker.domain.com</code>，下面我们介绍使用 <code>openssl</code> 自行签发 <code>docker.domain.com</code> 的站点 SSL 证书。</p><p>第一步创建 <code>CA</code> 私钥。</p><pre><code>$ openssl genrsa -out "root-ca.key" 4096</code></pre><p>第二步利用私钥创建 <code>CA</code> 根证书请求文件。</p><pre><code>$ openssl req \          -new -key "root-ca.key" \          -out "root-ca.csr" -sha256 \          -subj '/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=Your Company Name Docker Registry CA'</code></pre><blockquote><p>以上命令中 <code>-subj</code> 参数里的 <code>/C</code> 表示国家，如 <code>CN</code>；<code>/ST</code> 表示省；<code>/L</code> 表示城市或者地区；<code>/O</code> 表示组织名；<code>/CN</code> 通用名称。</p></blockquote><p>第三步配置 <code>CA</code> 根证书，新建 <code>root-ca.cnf</code>。</p><pre><code>[root_ca]basicConstraints = critical,CA:TRUE,pathlen:1keyUsage = critical, nonRepudiation, cRLSign, keyCertSignsubjectKeyIdentifier=hash</code></pre><p>第四步签发根证书。</p><pre><code>$ openssl x509 -req  -days 3650  -in "root-ca.csr" \               -signkey "root-ca.key" -sha256 -out "root-ca.crt" \               -extfile "root-ca.cnf" -extensions \               root_ca</code></pre><p>第五步生成站点 <code>SSL</code> 私钥。</p><pre><code>$ openssl genrsa -out "docker.domain.com.key" 4096</code></pre><p>第六步使用私钥生成证书请求文件。</p><pre><code>$ openssl req -new -key "docker.domain.com.key" -out "site.csr" -sha256 \          -subj '/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=docker.domain.com'</code></pre><p>第七步配置证书，新建 <code>site.cnf</code> 文件。</p><pre><code>[server]authorityKeyIdentifier=keyid,issuerbasicConstraints = critical,CA:FALSEextendedKeyUsage=serverAuthkeyUsage = critical, digitalSignature, keyEnciphermentsubjectAltName = DNS:docker.domain.com, IP:127.0.0.1subjectKeyIdentifier=hash</code></pre><p>第八步签署站点 <code>SSL</code> 证书。</p><pre><code>$ openssl x509 -req -days 750 -in "site.csr" -sha256 \    -CA "root-ca.crt" -CAkey "root-ca.key"  -CAcreateserial \    -out "docker.domain.com.crt" -extfile "site.cnf" -extensions server</code></pre><p>这样已经拥有了 <code>docker.domain.com</code> 的网站 SSL 私钥 <code>docker.domain.com.key</code> 和 SSL 证书 <code>docker.domain.com.crt</code> 及 CA 根证书 <code>root-ca.crt</code>。</p><p>新建 <code>ssl</code> 文件夹并将 <code>docker.domain.com.key</code> <code>docker.domain.com.crt</code> <code>root-ca.crt</code> 这三个文件移入，删除其他文件。</p><h3 id="配置私有仓库"><a href="#配置私有仓库" class="headerlink" title="配置私有仓库"></a>配置私有仓库</h3><p>私有仓库默认的配置文件位于 <code>/etc/docker/registry/config.yml</code>，我们先在本地编辑 <code>config.yml</code>，之后挂载到容器中。</p><pre><code>version: 0.1log:  accesslog:    disabled: true  level: debug  formatter: text  fields:    service: registry    environment: stagingstorage:  delete:    enabled: true  cache:    blobdescriptor: inmemory  filesystem:    rootdirectory: /var/lib/registryauth:  htpasswd:    realm: basic-realm    path: /etc/docker/registry/auth/nginx.htpasswdhttp:  addr: :443  host: https://docker.domain.com  headers:    X-Content-Type-Options: [nosniff]  http2:    disabled: false  tls:    certificate: /etc/docker/registry/ssl/docker.domain.com.crt    key: /etc/docker/registry/ssl/docker.domain.com.keyhealth:  storagedriver:    enabled: true    interval: 10sthreshold: 3</code></pre><h3 id="生成-http-认证文件"><a href="#生成-http-认证文件" class="headerlink" title="生成 http 认证文件"></a>生成 http 认证文件</h3><pre><code>$ mkdir auth$ docker run --rm \    --entrypoint htpasswd \    httpd:alpine \    -Bbn username password &gt; auth/nginx.htpasswd</code></pre><blockquote><p>将上面的 <code>username</code> <code>password</code> 替换为你自己的用户名和密码。</p></blockquote><h3 id="编辑-docker-compose-yml"><a href="#编辑-docker-compose-yml" class="headerlink" title="编辑 docker-compose.yml"></a>编辑 <code>docker-compose.yml</code></h3><pre><code>version: '3'services:  registry:    image: registry    ports:      - "443:443"    volumes:      - ./:/etc/docker/registry      - registry-data:/var/lib/registryvolumes:  registry-data:</code></pre><h3 id="修改-hosts"><a href="#修改-hosts" class="headerlink" title="修改 hosts"></a>修改 hosts</h3><p>编辑 <code>/etc/hosts</code></p><pre><code>127.0.0.1 docker.domain.com</code></pre><h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><pre><code>$ docker-compose up -d</code></pre><p>这样我们就搭建好了一个具有权限认证、TLS 的私有仓库，接下来我们测试其功能是否正常。</p><h3 id="测试私有仓库功能"><a href="#测试私有仓库功能" class="headerlink" title="测试私有仓库功能"></a>测试私有仓库功能</h3><p>由于自行签发的 CA 根证书不被系统信任，所以我们需要将 CA 根证书 <code>ssl/root-ca.crt</code> 移入 <code>/etc/docker/certs.d/docker.domain.com</code> 文件夹中。</p><pre><code>$ sudo mkdir -p /etc/docker/certs.d/docker.domain.com$ sudo cp ssl/root-ca.crt /etc/docker/certs.d/docker.domain.com/ca.crt</code></pre><p>登录到私有仓库。</p><pre><code>$ docker login docker.domain.com</code></pre><p>尝试推送、拉取镜像。</p><pre><code>$ docker pull ubuntu:18.04$ docker tag ubuntu:18.04 docker.domain.com/username/ubuntu:18.04$ docker push docker.domain.com/username/ubuntu:18.04$ docker image rm docker.domain.com/username/ubuntu:18.04$ docker pull docker.domain.com/username/ubuntu:18.04</code></pre><p>如果我们退出登录，尝试推送镜像。</p><pre><code>$ docker logout docker.domain.com$ docker push docker.domain.com/username/ubuntu:18.04no basic auth credentials</code></pre><p>发现会提示没有登录，不能将镜像推送到私有仓库中。</p><h2 id="Nexus-3"><a href="#Nexus-3" class="headerlink" title="Nexus 3"></a>Nexus 3</h2><p>使用 Docker 官方的 Registry 创建的仓库面临一些维护问题。比如某些镜像删除以后空间默认是不会回收的，需要一些命令去回收空间然后重启 Registry。在企业中把内部的一些工具包放入 <code>Nexus</code> 中是比较常见的做法，最新版本 <code>Nexus3.x</code> 全面支持 Docker 的私有镜像。所以使用 <code>Nexus3.x</code> 一个软件来管理 <code>Docker</code> , <code>Maven</code> , <code>Yum</code> , <code>PyPI</code> 等是一个明智的选择。</p><h3 id="启动-Nexus-容器"><a href="#启动-Nexus-容器" class="headerlink" title="启动 Nexus 容器"></a>启动 Nexus 容器</h3><pre><code>$ docker run -d --name nexus3 --restart=always \    -p 8081:8081 \    --mount src=nexus-data,target=/nexus-data \    sonatype/nexus3</code></pre><p>首次运行需等待 3-5 分钟，你可以使用 <code>docker logs nexus3 -f</code> 查看日志：</p><pre><code>$ docker logs nexus3 -f2021-03-11 15:31:21,990+0000 INFO  [jetty-main-1] *SYSTEM org.sonatype.nexus.bootstrap.jetty.JettyServer --------------------------------------------------Started Sonatype Nexus OSS 3.30.0-01-------------------------------------------------</code></pre><p>如果你看到以上内容，说明 <code>Nexus</code> 已经启动成功，你可以使用浏览器打开 <code>http://YourIP:8081</code> 访问 <code>Nexus</code> 了。</p><p>首次运行请通过以下命令获取初始密码：</p><pre><code>$ docker exec nexus3 cat /nexus-data/admin.password9266139e-41a2-4abb-92ec-e4142a3532cb</code></pre><p>首次启动 Nexus 的默认帐号是 <code>admin</code> ，密码则是上边命令获取到的，点击右上角登录，首次登录需更改初始密码。</p><p>登录之后可以点击页面上方的齿轮按钮按照下面的方法进行设置。</p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>创建一个私有仓库的方法： <code>Repository-&gt;Repositories</code> 点击右边菜单 <code>Create repository</code> 选择 <code>docker (hosted)</code></p><ul><li><p><strong>Name</strong>: 仓库的名称</p></li><li><p><strong>HTTP</strong>: 仓库单独的访问端口（例如：<strong>5001</strong>）</p></li><li><p><strong>Hosted -&gt; Deployment pollcy</strong>: 请选择 <strong>Allow redeploy</strong> 否则无法上传 Docker 镜像。</p></li></ul><p>其它的仓库创建方法请各位自己摸索，还可以创建一个 <code>docker (proxy)</code> 类型的仓库链接到 DockerHub 上。再创建一个 <code>docker (group)</code> 类型的仓库把刚才的 <code>hosted</code> 与 <code>proxy</code> 添加在一起。主机在访问的时候默认下载私有仓库中的镜像，如果没有将链接到 DockerHub 中下载并缓存到 Nexus 中。</p><h3 id="添加访问权限"><a href="#添加访问权限" class="headerlink" title="添加访问权限"></a>添加访问权限</h3><p>菜单 <code>Security-&gt;Realms</code> 把 Docker Bearer Token Realm 移到右边的框中保存。</p><p>添加用户规则：菜单 <code>Security-&gt;Roles</code>-&gt;<code>Create role</code> 在 <code>Privlleges</code> 选项搜索 docker 把相应的规则移动到右边的框中然后保存。</p><p>添加用户：菜单 <code>Security-&gt;Users</code>-&gt;<code>Create local user</code> 在 <code>Roles</code> 选项中选中刚才创建的规则移动到右边的窗口保存。</p><h3 id="NGINX-加密代理"><a href="#NGINX-加密代理" class="headerlink" title="NGINX 加密代理"></a>NGINX 加密代理</h3><p>证书的生成请参见 <code>私有仓库高级配置</code> 里面证书生成一节。</p><p>NGINX 示例配置如下</p><pre><code>upstream register{    server "YourHostName OR IP":5001; #端口为上面添加私有镜像仓库时设置的 HTTP 选项的端口号    check interval=3000 rise=2 fall=10 timeout=1000 type=http;    check_http_send "HEAD / HTTP/1.0\r\n\r\n";    check_http_expect_alive http_4xx;}server {    server_name YourDomainName;#如果没有 DNS 服务器做解析，请删除此选项使用本机 IP 地址访问    listen       443 ssl;    ssl_certificate key/example.crt;    ssl_certificate_key key/example.key;    ssl_session_timeout  5m;    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers  HIGH:!aNULL:!MD5;    ssl_prefer_server_ciphers   on;    large_client_header_buffers 4 32k;    client_max_body_size 300m;    client_body_buffer_size 512k;    proxy_connect_timeout 600;    proxy_read_timeout   600;    proxy_send_timeout   600;    proxy_buffer_size    128k;    proxy_buffers       4 64k;    proxy_busy_buffers_size 128k;    proxy_temp_file_write_size 512k;    location / {        proxy_set_header Host $host;        proxy_set_header X-Forwarded-Proto $scheme;        proxy_set_header X-Forwarded-Port $server_port;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection $connection_upgrade;        proxy_redirect off;        proxy_set_header X-Real-IP $remote_addr;        proxy_pass http://register;        proxy_read_timeout 900s;    }    error_page   500 502 503 504  /50x.html;}</code></pre><h3 id="Docker-主机访问镜像仓库"><a href="#Docker-主机访问镜像仓库" class="headerlink" title="Docker 主机访问镜像仓库"></a>Docker 主机访问镜像仓库</h3><p>如果不启用 SSL 加密可以通过 前面章节 的方法添加非 https 仓库地址到 Docker 的配置文件中然后重启 Docker。</p><p>使用 SSL 加密以后程序需要访问就不能采用修改配置的方式了。具体方法如下：</p><pre><code>$ openssl s_client -showcerts -connect YourDomainName OR HostIP:443 &lt;/dev/null 2&gt;/dev/null|openssl x509 -outform PEM &gt;ca.crt$ cat ca.crt | sudo tee -a /etc/ssl/certs/ca-certificates.crt$ systemctl restart docker</code></pre><p>使用 <code>docker login YourDomainName OR HostIP</code> 进行测试，用户名密码填写上面 Nexus 中设置的。</p><h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OTdhYzY5ZDhlMzBjZmNmOTI3YzFmNTI2Y2Q3MjBlYzRfNlhKeldHaU40UHB6c2thUTlFUDBZVXJKNmk4TzVIeWRfVG9rZW46Ym94Y24wczNGMVU3Ym9vVzNGYXFDWndiZHVkXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>在容器中管理数据主要有两种方式：</p><ul><li><p>数据卷（Volumes）</p></li><li><p>挂载主机目录 (Bind mounts)</p></li></ul><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li><p><code>数据卷</code> 可以在容器之间共享和重用</p></li><li><p>对 <code>数据卷</code> 的修改会立马生效</p></li><li><p>对 <code>数据卷</code> 的更新，不会影响镜像</p></li><li><p><code>数据卷</code> 默认会一直存在，即使容器被删除</p></li></ul><blockquote><p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p></blockquote><h3 id="创建一个数据卷"><a href="#创建一个数据卷" class="headerlink" title="创建一个数据卷"></a>创建一个数据卷</h3><pre><code>$ docker volume create my-vol</code></pre><p>查看所有的 <code>数据卷</code></p><pre><code>$ docker volume lsDRIVER              VOLUME NAMElocal               my-vol</code></pre><p>在主机里使用以下命令可以查看指定 <code>数据卷</code> 的信息</p><pre><code>$ docker volume inspect my-vol[    {        "Driver": "local",        "Labels": {},        "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",        "Name": "my-vol",        "Options": {},        "Scope": "local"    }]</code></pre><h3 id="启动一个挂载数据卷的容器"><a href="#启动一个挂载数据卷的容器" class="headerlink" title="启动一个挂载数据卷的容器"></a>启动一个挂载数据卷的容器</h3><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p><pre><code>$ docker run -d -P \    --name web \    # -v my-vol:/usr/share/nginx/html \    --mount source=my-vol,target=/usr/share/nginx/html \    nginx:alpine</code></pre><h3 id="查看数据卷的具体信息"><a href="#查看数据卷的具体信息" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><pre><code>$ docker inspect web</code></pre><p><code>数据卷</code> 信息在 “Mounts” Key 下面</p><pre><code>"Mounts": [    {        "Type": "volume",        "Name": "my-vol",        "Source": "/var/lib/docker/volumes/my-vol/_data",        "Destination": "/usr/share/nginx/html",        "Driver": "local",        "Mode": "",        "RW": true,        "Propagation": ""    }],</code></pre><h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><pre><code>$ docker volume rm my-vol</code></pre><p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><pre><code>$ docker volume prune</code></pre><h2 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h2><h3 id="挂载一个主机目录作为数据卷"><a href="#挂载一个主机目录作为数据卷" class="headerlink" title="挂载一个主机目录作为数据卷"></a>挂载一个主机目录作为数据卷</h3><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><pre><code>$ docker run -d -P \    --name web \    # -v /src/webapp:/usr/share/nginx/html \    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \    nginx:alpine</code></pre><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/usr/share/nginx/html</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p><pre><code>$ docker run -d -P \    --name web \    # -v /src/webapp:/usr/share/nginx/html:ro \    --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \    nginx:alpine</code></pre><p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/usr/share/nginx/html</code> 目录新建文件，会显示如下错误</p><pre><code>/usr/share/nginx/html # touch new.txttouch: new.txt: Read-only file system</code></pre><h3 id="查看数据卷的具体信息-1"><a href="#查看数据卷的具体信息-1" class="headerlink" title="查看数据卷的具体信息"></a>查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><pre><code>$ docker inspect web</code></pre><p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p><pre><code>"Mounts": [    {        "Type": "bind",        "Source": "/src/webapp",        "Destination": "/usr/share/nginx/html",        "Mode": "",        "RW": true,        "Propagation": "rprivate"    }],</code></pre><h3 id="挂载一个本地主机文件作为数据卷"><a href="#挂载一个本地主机文件作为数据卷" class="headerlink" title="挂载一个本地主机文件作为数据卷"></a>挂载一个本地主机文件作为数据卷</h3><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p><pre><code>$ docker run --rm -it \   # -v $HOME/.bash_history:/root/.bash_history \   --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \   ubuntu:18.04 \   bashroot@2affd44b4667:/# history1  ls2  diskutil list</code></pre><p>这样就可以记录在容器输入过的命令了。</p><h1 id="使用网络"><a href="#使用网络" class="headerlink" title="使用网络"></a>使用网络</h1><h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。</p><p>使用 <code>docker container ls</code> 可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</p><pre><code>$ docker run -d -P nginx:alpine$ docker container ls -lCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMESfae320d08268        nginx:alpine        "/docker-entrypoint.…"   24 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty</code></pre><p>同样的，可以通过 <code>docker logs</code> 命令来查看访问记录。</p><pre><code>$ docker logs fa172.17.0.1 - - [25/Aug/2020:08:34:04 +0000] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0" "-"</code></pre><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行</p><pre><code>$ docker run -d -p 80:80 nginx:alpine</code></pre><p>此时默认会绑定本地所有接口上的所有地址。</p><h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p><pre><code>$ docker run -d -p 127.0.0.1:80:80 nginx:alpine</code></pre><h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h3><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p><pre><code>$ docker run -d -p 127.0.0.1::80 nginx:alpine</code></pre><p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p><pre><code>$ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine</code></pre><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p><pre><code>$ docker port fa 800.0.0.0:32768</code></pre><p>注意：</p><ul><li><p>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</p></li><li><p><code>-p</code> 标记可以多次使用来绑定多个端口</p></li></ul><p>例如</p><pre><code>$ docker run -d \    -p 80:80 \    -p 443:443 \    nginx:alpine</code></pre><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>如果你之前有 <code>Docker</code> 使用经验，你可能已经习惯了使用 <code>--link</code> 参数来使容器互联。</p><p>随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。</p><h3 id="新建网络"><a href="#新建网络" class="headerlink" title="新建网络"></a>新建网络</h3><p>下面先创建一个新的 Docker 网络。</p><pre><code>$ docker network create -d bridge my-net</code></pre><p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 Swarm mode，在本小节中你可以忽略它。</p><h3 id="连接容器"><a href="#连接容器" class="headerlink" title="连接容器"></a>连接容器</h3><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p><pre><code>$ docker run -it --rm --name busybox1 --network my-net busybox sh</code></pre><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p><pre><code>$ docker run -it --rm --name busybox2 --network my-net busybox sh</code></pre><p>再打开一个新的终端查看容器信息</p><pre><code>$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMESb47060aca56b        busybox             "sh"                11 minutes ago      Up 11 minutes                           busybox28720575823ec        busybox             "sh"                16 minutes ago      Up 16 minutes                           busybox1</code></pre><p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><p>在 <code>busybox1</code> 容器输入以下命令</p><pre><code>/ # ping busybox2PING busybox2 (172.19.0.3): 56 data bytes64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms</code></pre><p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p><p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p><pre><code>/ # ping busybox1PING busybox1 (172.19.0.2): 56 data bytes64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms</code></pre><p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>如果你有多个容器之间需要互相连接，推荐使用 Docker Compose。</p><h2 id="配置-DNS"><a href="#配置-DNS" class="headerlink" title="配置 DNS"></a>配置 DNS</h2><p>如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</p><p>在容器中使用 <code>mount</code> 命令可以看到挂载信息：</p><pre><code>$ mount/dev/disk/by-uuid/1fec...ebdf on /etc/hostname type ext4 .../dev/disk/by-uuid/1fec...ebdf on /etc/hosts type ext4 ...tmpfs on /etc/resolv.conf type tmpfs ...</code></pre><p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 <code>/etc/resolv.conf</code> 文件立刻得到更新。</p><p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。</p><pre><code>{  "dns" : [    "114.114.114.114",    "8.8.8.8"  ]}</code></pre><p>这样每次启动的容器 DNS 自动配置为 <code>114.114.114.114</code> 和 <code>8.8.8.8</code>。使用以下命令来证明其已经生效。</p><pre><code>$ docker run -it --rm ubuntu:18.04  cat etc/resolv.confnameserver 114.114.114.114nameserver 8.8.8.8</code></pre><p>如果用户想要手动指定容器的配置，可以在使用 <code>docker run</code> 命令启动容器时加入如下参数：</p><p><code>-h HOSTNAME</code> 或者 <code>--hostname=HOSTNAME</code> 设定容器的主机名，它会被写到容器内的 <code>/etc/hostname</code> 和 <code>/etc/hosts</code>。但它在容器外部看不到，既不会在 <code>docker container ls</code> 中显示，也不会在其他的容器的 <code>/etc/hosts</code> 看到。</p><p><code>--dns=IP_ADDRESS</code> 添加 DNS 服务器到容器的 <code>/etc/resolv.conf</code> 中，让容器用这个服务器来解析所有不在 <code>/etc/hosts</code> 中的主机名。</p><p><code>--dns-search=DOMAIN</code> 设定容器的搜索域，当设定搜索域为 <code>.example.com</code> 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 <code>host.example.com</code>。</p><blockquote><p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 <code>/etc/resolv.conf</code> 来配置容器。</p></blockquote><h1 id="高级网络配置"><a href="#高级网络配置" class="headerlink" title="高级网络配置"></a>高级网络配置</h1><p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p><p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a href="https://tools.ietf.org/html/rfc1918" target="_blank" rel="noopener">RFC1918</a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p><p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQ1NzRhODc3NjAyMzI0NjM3ZDQ2YjcxODZhYmJiNDFfZUZUc0lhZnFMQzlZZW9WY3hSZlByamtLMzBPSFh0SFdfVG9rZW46Ym94Y244VGkxNDhubTRlSm5ERG15OVFkNUJlXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>接下来的部分将介绍在一些场景中，Docker 所有的网络定制配置。以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认的网络配置。</p><h2 id="快速配置指南"><a href="#快速配置指南" class="headerlink" title="快速配置指南"></a>快速配置指南</h2><p>下面是一个跟 Docker 网络相关的命令列表。</p><p>其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。</p><ul><li><p><code>-b BRIDGE</code> 或 <code>--bridge=BRIDGE</code> 指定容器挂载的网桥</p></li><li><p><code>--bip=CIDR</code> 定制 docker0 的掩码</p></li><li><p><code>-H SOCKET...</code> 或 <code>--host=SOCKET...</code> Docker 服务端接收命令的通道</p></li><li><p><code>--icc=true|false</code> 是否支持容器之间进行通信</p></li><li><p><code>--ip-forward=true|false</code> 请看下文容器之间的通信</p></li><li><p><code>--iptables=true|false</code> 是否允许 Docker 添加 iptables 规则</p></li><li><p><code>--mtu=BYTES</code> 容器网络中的 MTU</p></li></ul><p>下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker 服务启动的时候指定则会成为默认值，后面执行 <code>docker run</code> 时可以覆盖设置的默认值。</p><ul><li><p><code>--dns=IP_ADDRESS...</code> 使用指定的DNS服务器</p></li><li><p><code>--dns-search=DOMAIN...</code> 指定DNS搜索域</p></li></ul><p>最后这些选项只有在 <code>docker run</code> 执行时使用，因为它是针对容器的特性内容。</p><ul><li><p><code>-h HOSTNAME</code> 或 <code>--hostname=HOSTNAME</code> 配置容器主机名</p></li><li><p><code>--link=CONTAINER_NAME:ALIAS</code> 添加到另一个容器的连接</p></li><li><p><code>--net=bridge|none|container:NAME_or_ID|host</code> 配置容器的桥接模式</p></li><li><p><code>-p SPEC</code> 或 <code>--publish=SPEC</code> 映射容器端口到宿主主机</p></li><li><p><code>-P or --publish-all=true|false</code> 映射容器所有端口到宿主主机</p></li></ul><h2 id="容器访问控制"><a href="#容器访问控制" class="headerlink" title="容器访问控制"></a>容器访问控制</h2><p>容器的访问控制，主要通过 Linux 上的 <code>iptables</code> 防火墙来进行管理和实现。<code>iptables</code> 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。</p><h3 id="容器访问外部网络"><a href="#容器访问外部网络" class="headerlink" title="容器访问外部网络"></a>容器访问外部网络</h3><p>容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p><pre><code>$sysctl net.ipv4.ip_forwardnet.ipv4.ip_forward = 1</code></pre><p>如果为 0，说明没有开启转发，则需要手动打开。</p><pre><code>$sysctl -w net.ipv4.ip_forward=1</code></pre><p>如果在启动 Docker 服务的时候设定 <code>--ip-forward=true</code>, Docker 就会自动设定系统的 <code>ip_forward</code> 参数为 1。</p><h3 id="容器之间访问"><a href="#容器之间访问" class="headerlink" title="容器之间访问"></a>容器之间访问</h3><p>容器之间相互访问，需要两方面的支持。</p><ul><li><p>容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 <code>docker0</code> 网桥上。</p></li><li><p>本地系统的防火墙软件 – <code>iptables</code> 是否允许通过。</p></li></ul><h3 id="访问所有端口"><a href="#访问所有端口" class="headerlink" title="访问所有端口"></a>访问所有端口</h3><p>当启动 Docker 服务（即 dockerd）的时候，默认会添加一条转发策略到本地主机 iptables 的 FORWARD 链上。策略为通过（<code>ACCEPT</code>）还是禁止（<code>DROP</code>）取决于配置<code>--icc=true</code>（缺省值）还是 <code>--icc=false</code>。当然，如果手动指定 <code>--iptables=false</code> 则不会添加 <code>iptables</code> 规则。</p><p>可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 <code>/etc/docker/daemon.json</code> 文件中配置 <code>{"icc": false}</code> 来禁止它。</p><h3 id="访问指定端口"><a href="#访问指定端口" class="headerlink" title="访问指定端口"></a>访问指定端口</h3><p>在通过 <code>-icc=false</code> 关闭网络访问后，还可以通过 <code>--link=CONTAINER_NAME:ALIAS</code> 选项来访问容器的开放端口。</p><p>例如，在启动 Docker 服务时，可以同时使用 <code>icc=false --iptables=true</code> 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 <code>iptables</code> 规则。</p><p>此时，系统中的 <code>iptables</code> 规则可能是类似</p><pre><code>$ sudo iptables -nL...Chain FORWARD (policy ACCEPT)target     prot opt source               destinationDROP       all  --  0.0.0.0/0            0.0.0.0/0...</code></pre><p>之后，启动容器（<code>docker run</code>）时使用 <code>--link=CONTAINER_NAME:ALIAS</code> 选项。Docker 会在 <code>iptable</code> 中为 两个容器分别添加一条 <code>ACCEPT</code> 规则，允许相互访问开放的端口（取决于 <code>Dockerfile</code> 中的 <code>EXPOSE</code> 指令）。</p><p>当添加了 <code>--link=CONTAINER_NAME:ALIAS</code> 选项后，添加了 <code>iptables</code> 规则。</p><pre><code>$ sudo iptables -nL...Chain FORWARD (policy ACCEPT)target     prot opt source               destinationACCEPT     tcp  --  172.17.0.2           172.17.0.3           tcp spt:80ACCEPT     tcp  --  172.17.0.3           172.17.0.2           tcp dpt:80DROP       all  --  0.0.0.0/0            0.0.0.0/0</code></pre><p>注意：<code>--link=CONTAINER_NAME:ALIAS</code> 中的 <code>CONTAINER_NAME</code> 目前必须是 Docker 分配的名字，或使用 <code>--name</code> 参数指定的名字。主机名则不会被识别。</p><h2 id="端口映射实现"><a href="#端口映射实现" class="headerlink" title="端口映射实现"></a>端口映射实现</h2><p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p><h3 id="容器访问外部实现"><a href="#容器访问外部实现" class="headerlink" title="容器访问外部实现"></a>容器访问外部实现</h3><p>容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 <code>iptables</code> 的源地址伪装操作实现的。</p><p>查看主机的 NAT 规则。</p><pre><code>$ sudo iptables -t nat -nL...Chain POSTROUTING (policy ACCEPT)target     prot opt source               destinationMASQUERADE  all  --  172.17.0.0/16       !172.17.0.0/16...</code></pre><p>其中，上述规则将所有源地址在 <code>172.17.0.0/16</code> 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。</p><h3 id="外部访问容器实现"><a href="#外部访问容器实现" class="headerlink" title="外部访问容器实现"></a>外部访问容器实现</h3><p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。</p><p>不管用那种办法，其实也是在本地的 <code>iptable</code> 的 nat 表中添加相应的规则。</p><p>使用 <code>-P</code> 时：</p><pre><code>$ iptables -t nat -nL...Chain DOCKER (2 references)target     prot opt source               destinationDNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:49153 to:172.17.0.2:80</code></pre><p>使用 <code>-p 80:80</code> 时：</p><pre><code>$ iptables -t nat -nLChain DOCKER (2 references)target     prot opt source               destinationDNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80 to:172.17.0.2:80</code></pre><p>注意：</p><ul><li><p>这里的规则映射了 <code>0.0.0.0</code>，意味着将接受主机来自所有接口的流量。用户可以通过 <code>-p IP:host_port:container_port</code> 或 <code>-p IP::port</code> 来指定允许访问容器的主机上的 IP、接口等，以制定更严格的规则。</p></li><li><p>如果希望永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容。</p></li></ul><pre><code>{  "ip": "0.0.0.0"}</code></pre><h2 id="配置-docker0-网桥"><a href="#配置-docker0-网桥" class="headerlink" title="配置 docker0 网桥"></a>配置 docker0 网桥</h2><p>Docker 服务默认会创建一个 <code>docker0</code> 网桥（其上有一个 <code>docker0</code> 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p><p>Docker 默认指定了 <code>docker0</code> 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。</p><ul><li><p><code>--bip=CIDR</code> IP 地址加掩码格式，例如 192.168.1.5/24</p></li><li><p><code>--mtu=BYTES</code> 覆盖默认的 Docker mtu 配置</p></li></ul><p>也可以在配置文件中配置 DOCKER_OPTS，然后重启服务。</p><p>由于目前 Docker 网桥是 Linux 网桥，用户可以使用 <code>brctl show</code> 来查看网桥和端口连接信息。</p><pre><code>$ sudo brctl showbridge name     bridge id               STP enabled     interfacesdocker0         8000.3a1d7362b4ee       no              veth65f9                                             vethdda6</code></pre><p>注：<code>brctl</code> 命令在 Debian、Ubuntu 中可以使用 <code>sudo apt-get install bridge-utils</code> 来安装。</p><p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 <code>docker0</code> 接口的 IP 作为所有容器的默认网关。</p><pre><code>$ sudo docker run -i -t --rm base /bin/bash$ ip addr show eth024: eth0: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000    link/ether 32:6f:e0:35:57:91 brd ff:ff:ff:ff:ff:ff    inet 172.17.0.3/16 scope global eth0       valid_lft forever preferred_lft forever    inet6 fe80::306f:e0ff:fe35:5791/64 scope link       valid_lft forever preferred_lft forever$ ip routedefault via 172.17.42.1 dev eth0172.17.0.0/16 dev eth0  proto kernel  scope link  src 172.17.0.3</code></pre><h2 id="自定义网桥"><a href="#自定义网桥" class="headerlink" title="自定义网桥"></a>自定义网桥</h2><p>除了默认的 <code>docker0</code> 网桥，用户也可以指定网桥来连接各个容器。</p><p>在启动 Docker 服务的时候，使用 <code>-b BRIDGE</code>或<code>--bridge=BRIDGE</code> 来指定使用的网桥。</p><p>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p><pre><code>$ sudo systemctl stop docker$ sudo ip link set dev docker0 down$ sudo brctl delbr docker0</code></pre><p>然后创建一个网桥 <code>bridge0</code>。</p><pre><code>$ sudo brctl addbr bridge0$ sudo ip addr add 192.168.5.1/24 dev bridge0$ sudo ip link set dev bridge0 up</code></pre><p>查看确认网桥创建并启动。</p><pre><code>$ ip addr show bridge04: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state UP group default    link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff    inet 192.168.5.1/24 scope global bridge0       valid_lft forever preferred_lft forever</code></pre><p>在 Docker 配置文件 <code>/etc/docker/daemon.json</code> 中添加如下内容，即可将 Docker 默认桥接到创建的网桥上。</p><pre><code>{  "bridge": "bridge0",}</code></pre><p>启动 Docker 服务。</p><p>新建一个容器，可以看到它已经桥接到了 <code>bridge0</code> 上。</p><p>可以继续用 <code>brctl show</code> 命令查看桥接的信息。另外，在容器中可以使用 <code>ip addr</code> 和 <code>ip route</code> 命令来查看 IP 地址配置和路由信息。</p><h2 id="工具和示例"><a href="#工具和示例" class="headerlink" title="工具和示例"></a>工具和示例</h2><p>在介绍自定义网络拓扑之前，你可能会对一些外部工具和例子感兴趣：</p><h3 id="pipework"><a href="#pipework" class="headerlink" title="pipework"></a>pipework</h3><p>Jérôme Petazzoni 编写了一个叫 <a href="https://github.com/jpetazzo/pipework" target="_blank" rel="noopener">pipework</a> 的 shell 脚本，可以帮助用户在比较复杂的场景中完成容器的连接。</p><h3 id="playground"><a href="#playground" class="headerlink" title="playground"></a>playground</h3><p>Brandon Rhodes 创建了一个提供完整的 Docker 容器网络拓扑管理的 <a href="https://github.com/brandon-rhodes/fopnp/tree/m/playground" target="_blank" rel="noopener">Python库</a>，包括路由、NAT 防火墙；以及一些提供 <code>HTTP</code> <code>SMTP</code> <code>POP</code> <code>IMAP</code> <code>Telnet</code> <code>SSH</code> <code>FTP</code> 的服务器。</p><h2 id="编辑网络配置文件"><a href="#编辑网络配置文件" class="headerlink" title="编辑网络配置文件"></a>编辑网络配置文件</h2><p>Docker 1.2.0 开始支持在运行中的容器里编辑 <code>/etc/hosts</code>, <code>/etc/hostname</code> 和 <code>/etc/resolv.conf</code> 文件。</p><p>但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来，也不会被 <code>docker commit</code> 提交。</p><h2 id="实例：创建一个点到点连接"><a href="#实例：创建一个点到点连接" class="headerlink" title="实例：创建一个点到点连接"></a>实例：创建一个点到点连接</h2><p>默认情况下，Docker 会将所有容器连接到由 <code>docker0</code> 提供的虚拟子网中。</p><p>用户有时候需要两个容器之间可以直连通信，而不用通过主机网桥进行桥接。</p><p>解决办法很简单：创建一对 <code>peer</code> 接口，分别放到两个容器中，配置成点到点链路类型即可。</p><p>首先启动 2 个容器：</p><pre><code>$ docker run -i -t --rm --net=none base /bin/bashroot@1f1f4c1f931a:/#$ docker run -i -t --rm --net=none base /bin/bashroot@12e343489d2f:/#</code></pre><p>找到进程号，然后创建网络命名空间的跟踪文件。</p><pre><code>$ docker inspect -f '{{.State.Pid}}' 1f1f4c1f931a2989$ docker inspect -f '{{.State.Pid}}' 12e343489d2f3004$ sudo mkdir -p /var/run/netns$ sudo ln -s /proc/2989/ns/net /var/run/netns/2989$ sudo ln -s /proc/3004/ns/net /var/run/netns/3004</code></pre><p>创建一对 <code>peer</code> 接口，然后配置路由</p><pre><code>$ sudo ip link add A type veth peer name B$ sudo ip link set A netns 2989$ sudo ip netns exec 2989 ip addr add 10.1.1.1/32 dev A$ sudo ip netns exec 2989 ip link set A up$ sudo ip netns exec 2989 ip route add 10.1.1.2/32 dev A$ sudo ip link set B netns 3004$ sudo ip netns exec 3004 ip addr add 10.1.1.2/32 dev B$ sudo ip netns exec 3004 ip link set B up$ sudo ip netns exec 3004 ip route add 10.1.1.1/32 dev B</code></pre><p>现在这 2 个容器就可以相互 ping 通，并成功建立连接。点到点链路不需要子网和子网掩码。</p><p>此外，也可以不指定 <code>--net=none</code> 来创建点到点链路。这样容器还可以通过原先的网络来通信。</p><p>利用类似的办法，可以创建一个只跟主机通信的容器。但是一般情况下，更推荐使用 <code>--icc=false</code> 来关闭容器之间的通信。</p><h1 id="Docker-Buildx"><a href="#Docker-Buildx" class="headerlink" title="Docker Buildx"></a>Docker Buildx</h1><p>Docker Buildx 是一个 docker CLI 插件，其扩展了 docker 命令，支持 <a href="https://yeasy.gitbook.io/docker_practice/buildx/buildkit" target="_blank" rel="noopener">Moby BuildKit</a> 提供的功能。提供了与 docker build 相同的用户体验，并增加了许多新功能。</p><h1 id="Docker-Compose-1"><a href="#Docker-Compose-1" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p><code>Docker Compose</code> 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。</p><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p><p>其代码目前在 <a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a> 上开源。</p><p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p><p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p><p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p><p><code>Compose</code> 中有两个重要的概念：</p><ul><li><p>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</p></li><li><p>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</p></li></ul><p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p><p>目前 Docker 官方用 GO 语言 <a href="https://github.com/docker/compose-cli" target="_blank" rel="noopener">重写</a> 了 Docker Compose，并将其作为了 docker cli 的子命令，称为 <code>Compose V2</code>。你可以参照官方文档安装，然后将熟悉的 <code>docker-compose</code> 命令替换为 <code>docker compose</code>，即可使用 Docker Compose。</p><p><strong>官方文档</strong></p><ul><li><a href="https://docs.docker.com/compose/cli-command/" target="_blank" rel="noopener">Compose V2 beta</a></li></ul><h2 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h2><p><code>Compose</code> 支持 Linux、macOS、Windows 10 三大平台。</p><p><code>Compose</code> 可以通过 Python 的包管理工具 <code>pip</code> 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。</p><p><code>Docker Desktop for Mac/Windows</code> 自带 <code>docker-compose</code> 二进制文件，安装 Docker 之后可以直接使用。</p><pre><code>$ docker-compose --versiondocker-compose version 1.27.4, build 40524192</code></pre><p>Linux 系统请使用以下介绍的方法安装。</p><h3 id="二进制包"><a href="#二进制包" class="headerlink" title="二进制包"></a>二进制包</h3><p>在 Linux 上的也安装十分简单，从 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。</p><p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p><pre><code>$ sudo curl -L https://github.com/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose# 国内用户可以使用以下方式加快下载$ sudo curl -L https://download.fastgit.org/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose$ sudo chmod +x /usr/local/bin/docker-compose</code></pre><h3 id="PIP-安装"><a href="#PIP-安装" class="headerlink" title="PIP 安装"></a>PIP 安装</h3><p><em>注：</em> <code>x86_64</code> 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 <code>ARM</code> (例如，树莓派)，再使用 <code>pip</code> 安装。</p><p>这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。</p><p>执行安装命令：</p><pre><code>$ sudo pip install -U docker-compose</code></pre><p>可以看到类似如下输出，说明安装成功。</p><pre><code>Collecting docker-compose  Downloading docker-compose-1.27.4.tar.gz (149kB): 149kB downloaded...Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress</code></pre><h3 id="bash-补全命令"><a href="#bash-补全命令" class="headerlink" title="bash 补全命令"></a>bash 补全命令</h3><pre><code>$ curl -L https://raw.githubusercontent.com/docker/compose/1.27.4/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</code></pre><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>如果是二进制包方式安装的，删除二进制文件即可。</p><pre><code>$ sudo rm /usr/local/bin/docker-compose</code></pre><p>如果是通过 <code>pip</code> 安装的，则执行如下命令即可删除。</p><pre><code>$ sudo pip uninstall docker-compose</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p>首先介绍几个术语。</p><ul><li><p>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</p></li><li><p>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。</p></li></ul><p>可见，一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p><p>下面我们用 <code>Python</code> 来建立一个能够记录页面访问次数的 web 网站。</p><h3 id="web-应用"><a href="#web-应用" class="headerlink" title="web 应用"></a>web 应用</h3><p>新建文件夹，在该目录中编写 <code>app.py</code> 文件</p><pre><code>from flask import Flaskfrom redis import Redisapp = Flask(__name__)redis = Redis(host='redis', port=6379)@app.route('/')def hello():    count = redis.incr('hits')    return 'Hello World! 该页面已被访问 {} 次。\n'.format(count)if __name__ == "__main__":    app.run(host="0.0.0.0", debug=True)</code></pre><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><p>编写 <code>Dockerfile</code> 文件，内容为</p><pre><code>FROM python:3.6-alpineADD . /codeWORKDIR /codeRUN pip install redis flaskCMD ["python", "app.py"]</code></pre><h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><p>编写 <code>docker-compose.yml</code> 文件，这个是 Compose 使用的主模板文件。</p><pre><code>version: '3'services:  web:    build: .    ports:     - "5000:5000"  redis:    image: "redis:alpine"</code></pre><h4 id="运行-compose-项目"><a href="#运行-compose-项目" class="headerlink" title="运行 compose 项目"></a>运行 compose 项目</h4><pre><code>$ docker-compose up</code></pre><p>此时访问本地 <code>5000</code> 端口，每次刷新页面，计数就会加 1。</p><h2 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h2><h3 id="命令对象与格式"><a href="#命令对象与格式" class="headerlink" title="命令对象与格式"></a>命令对象与格式</h3><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p><p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p><p><code>docker-compose</code> 命令的基本的使用格式是</p><pre><code>docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</code></pre><h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><ul><li><p><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</p></li><li><p><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</p></li><li><p><code>--verbose</code> 输出更多调试信息。</p></li><li><p><code>-v, --version</code> 打印版本并退出。</p></li></ul><h3 id="命令使用说明"><a href="#命令使用说明" class="headerlink" title="命令使用说明"></a>命令使用说明</h3><h4 id="build"><a href="#build" class="headerlink" title="build"></a><code>build</code></h4><p>格式为 <code>docker-compose build [options] [SERVICE...]</code>。</p><p>构建（重新构建）项目中的服务容器。</p><p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p><p>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</p><p>选项包括：</p><ul><li><p><code>--force-rm</code> 删除构建过程中的临时容器。</p></li><li><p><code>--no-cache</code> 构建镜像过程中不使用 cache（这将加长构建过程）。</p></li><li><p><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</p></li></ul><h4 id="config"><a href="#config" class="headerlink" title="config"></a><code>config</code></h4><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p><h4 id="down"><a href="#down" class="headerlink" title="down"></a><code>down</code></h4><p>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a><code>exec</code></h4><p>进入指定的容器。</p><h4 id="help"><a href="#help" class="headerlink" title="help"></a><code>help</code></h4><p>获得一个命令的帮助。</p><h4 id="images"><a href="#images" class="headerlink" title="images"></a><code>images</code></h4><p>列出 Compose 文件中包含的镜像。</p><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a><code>kill</code></h4><p>格式为 <code>docker-compose kill [options] [SERVICE...]</code>。</p><p>通过发送 <code>SIGKILL</code> 信号来强制停止服务容器。</p><p>支持通过 <code>-s</code> 参数来指定发送的信号，例如通过如下指令发送 <code>SIGINT</code> 信号。</p><pre><code>$ docker-compose kill -s SIGINT</code></pre><h4 id="logs"><a href="#logs" class="headerlink" title="logs"></a><code>logs</code></h4><p>格式为 <code>docker-compose logs [options] [SERVICE...]</code>。</p><p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 <code>--no-color</code> 来关闭颜色。</p><p>该命令在调试问题的时候十分有用。</p><h4 id="pause"><a href="#pause" class="headerlink" title="pause"></a><code>pause</code></h4><p>格式为 <code>docker-compose pause [SERVICE...]</code>。</p><p>暂停一个服务容器。</p><h4 id="port"><a href="#port" class="headerlink" title="port"></a><code>port</code></h4><p>格式为 <code>docker-compose port [options] SERVICE PRIVATE_PORT</code>。</p><p>打印某个容器端口所映射的公共端口。</p><p>选项：</p><ul><li><p><code>--protocol=proto</code> 指定端口协议，tcp（默认值）或者 udp。</p></li><li><p><code>--index=index</code> 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</p></li></ul><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a><code>ps</code></h4><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p><p>列出项目中目前的所有容器。</p><p>选项：</p><ul><li><code>-q</code> 只打印容器的 ID 信息。</li></ul><h4 id="pull"><a href="#pull" class="headerlink" title="pull"></a><code>pull</code></h4><p>格式为 <code>docker-compose pull [options] [SERVICE...]</code>。</p><p>拉取服务依赖的镜像。</p><p>选项：</p><ul><li><code>--ignore-pull-failures</code> 忽略拉取镜像过程中的错误。</li></ul><h4 id="push"><a href="#push" class="headerlink" title="push"></a><code>push</code></h4><p>推送服务依赖的镜像到 Docker 镜像仓库。</p><h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a><code>restart</code></h4><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p><p>重启项目中的服务。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li></ul><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h4><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p><p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p><p>选项：</p><ul><li><p><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</p></li><li><p><code>-v</code> 删除容器所挂载的数据卷。</p></li></ul><h4 id="run"><a href="#run" class="headerlink" title="run"></a><code>run</code></h4><p>格式为 <code>docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]</code>。</p><p>在指定服务上执行一个命令。</p><p>例如：</p><pre><code>$ docker-compose run ubuntu ping docker.com</code></pre><p>将会启动一个 ubuntu 服务容器，并执行 <code>ping docker.com</code> 命令。</p><p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p><p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p><p>两个不同点：</p><ul><li><p>给定命令将会覆盖原有的自动运行命令；</p></li><li><p>不会自动创建端口，以避免冲突。</p></li></ul><p>如果不希望自动启动关联的容器，可以使用 <code>--no-deps</code> 选项，例如</p><pre><code>$ docker-compose run --no-deps web python manage.py shell</code></pre><p>将不会启动 web 容器所关联的其它容器。</p><p>选项：</p><ul><li><p><code>-d</code> 后台运行容器。</p></li><li><p><code>--name NAME</code> 为容器指定一个名字。</p></li><li><p><code>--entrypoint CMD</code> 覆盖默认的容器启动指令。</p></li><li><p><code>-e KEY=VAL</code> 设置环境变量值，可多次使用选项来设置多个环境变量。</p></li><li><p><code>-u, --user=""</code> 指定运行容器的用户名或者 uid。</p></li><li><p><code>--no-deps</code> 不自动启动关联的服务容器。</p></li><li><p><code>--rm</code> 运行命令后自动删除容器，<code>d</code> 模式下将忽略。</p></li><li><p><code>-p, --publish=[]</code> 映射容器端口到本地主机。</p></li><li><p><code>--service-ports</code> 配置服务端口并映射到本地主机。</p></li><li><p><code>-T</code> 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</p></li></ul><h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a><code>scale</code></h4><p>格式为 <code>docker-compose scale [options] [SERVICE=NUM...]</code>。</p><p>设置指定服务运行的容器个数。</p><p>通过 <code>service=num</code> 的参数来设置数量。例如：</p><pre><code>$ docker-compose scale web=3 db=2</code></pre><p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p><p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h4 id="start"><a href="#start" class="headerlink" title="start"></a><code>start</code></h4><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p><p>启动已经存在的服务容器。</p><h4 id="stop"><a href="#stop" class="headerlink" title="stop"></a><code>stop</code></h4><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p><p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p><p>选项：</p><ul><li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li></ul><h4 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h4><p>查看各个服务容器内运行的进程。</p><h4 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a><code>unpause</code></h4><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p><p>恢复处于暂停状态中的服务。</p><h4 id="up"><a href="#up" class="headerlink" title="up"></a><code>up</code></h4><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p><p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p><p>链接的服务都将会被自动启动，除非已经处于运行状态。</p><p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p><p>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p><p>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</p><p>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p><p>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 <code>docker-compose up --no-recreate</code>。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 <code>docker-compose up --no-deps -d &lt;SERVICE_NAME&gt;</code> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p><p>选项：</p><ul><li><p><code>-d</code> 在后台运行服务容器。</p></li><li><p><code>--no-color</code> 不使用颜色来区分不同的服务的控制台输出。</p></li><li><p><code>--no-deps</code> 不启动服务所链接的容器。</p></li><li><p><code>--force-recreate</code> 强制重新创建容器，不能与 <code>--no-recreate</code> 同时使用。</p></li><li><p><code>--no-recreate</code> 如果容器已经存在了，则不重新创建，不能与 <code>--force-recreate</code> 同时使用。</p></li><li><p><code>--no-build</code> 不自动构建缺失的服务镜像。</p></li><li><p><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</p></li></ul><h4 id="version"><a href="#version" class="headerlink" title="version"></a><code>version</code></h4><p>格式为 <code>docker-compose version</code>。</p><p>打印版本信息。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://docs.docker.com/compose/reference/overview/" target="_blank" rel="noopener">官方文档</a></li></ul><h3 id="Compose-模板文件"><a href="#Compose-模板文件" class="headerlink" title="Compose 模板文件"></a><a href="https://yeasy.gitbook.io/docker_practice/compose/compose_file" target="_blank" rel="noopener">Compose 模板文件</a></h3><h2 id="实战-Django"><a href="#实战-Django" class="headerlink" title="实战 Django"></a>实战 Django</h2><blockquote><p>本小节内容适合 <code>Python</code> 开发人员阅读。</p></blockquote><p>我们现在将使用 <code>Docker Compose</code> 配置并运行一个 <code>Django/PostgreSQL</code> 应用。</p><p>在一切工作开始前，需要先编辑好三个必要的文件。</p><p>第一步，因为应用将要运行在一个满足所有环境依赖的 Docker 容器里面，那么我们可以通过编辑 <code>Dockerfile</code> 文件来指定 Docker 容器要安装内容。内容如下：</p><pre><code>FROM python:3ENV PYTHONUNBUFFERED 1RUN mkdir /codeWORKDIR /codeCOPY requirements.txt /code/RUN pip install -r requirements.txtCOPY . /code/</code></pre><p>以上内容指定应用将使用安装了 Python 以及必要依赖包的镜像。更多关于如何编写 <code>Dockerfile</code> 文件的信息可以查看 <a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile" target="_blank" rel="noopener"> Dockerfile 使用</a>。</p><p>第二步，在 <code>requirements.txt</code> 文件里面写明需要安装的具体依赖包名。</p><pre><code>Django&gt;=2.0,&lt;3.0psycopg2&gt;=2.7,&lt;3.0</code></pre><p>第三步，<code>docker-compose.yml</code> 文件将把所有的东西关联起来。它描述了应用的构成（一个 web 服务和一个数据库）、使用的 Docker 镜像、镜像之间的连接、挂载到容器的卷，以及服务开放的端口。</p><pre><code>version: "3"services:  db:    image: postgres    environment:      POSTGRES_PASSWORD: 'postgres'  web:    build: .    command: python manage.py runserver 0.0.0.0:8000    volumes:      - .:/code    ports:      - "8000:8000"</code></pre><p>现在我们就可以使用 <code>docker-compose run</code> 命令启动一个 <code>Django</code> 应用了。</p><pre><code>$ docker-compose run web django-admin startproject django_example .</code></pre><p>由于 web 服务所使用的镜像并不存在，所以 Compose 会首先使用 <code>Dockerfile</code> 为 web 服务构建一个镜像，接着使用这个镜像在容器里运行 <code>django-admin startproject django_example</code> 指令。</p><p>这将在当前目录生成一个 <code>Django</code> 应用。</p><pre><code>$ lsDockerfile       docker-compose.yml          django_example       manage.py       requirements.txt</code></pre><p>如果你的系统是 Linux,记得更改文件权限。</p><pre><code>$ sudo chown -R $USER:$USER .</code></pre><p>首先，我们要为应用设置好数据库的连接信息。用以下内容替换 <code>django_example/settings.py</code> 文件中 <code>DATABASES = ...</code> 定义的节点内容。</p><pre><code>DATABASES = {    'default': {        'ENGINE': 'django.db.backends.postgresql',        'NAME': 'postgres',        'USER': 'postgres',        'HOST': 'db',        'PORT': 5432,        'PASSWORD': 'postgres',    }}</code></pre><p>这些信息是在 <a href="https://hub.docker.com/_/postgres/" target="_blank" rel="noopener">postgres</a> 镜像固定设置好的。然后，运行 <code>docker-compose up</code> ：</p><pre><code>$ docker-compose updjango_db_1 is up-to-dateCreating django_web_1 ...Creating django_web_1 ... doneAttaching to django_db_1, django_web_1db_1   | The files belonging to this database system will be owned by user "postgres".db_1   | This user must also own the server process.db_1   |db_1   | The database cluster will be initialized with locale "en_US.utf8".db_1   | The default database encoding has accordingly been set to "UTF8".db_1   | The default text search configuration will be set to "english".web_1  | Performing system checks...web_1  |web_1  | System check identified no issues (0 silenced).web_1  |web_1  | November 23, 2017 - 06:21:19web_1  | Django version 1.11.7, using settings 'django_example.settings'web_1  | Starting development server at http://0.0.0.0:8000/web_1  | Quit the server with CONTROL-C.</code></pre><p>这个 <code>Django</code> 应用已经开始在你的 Docker 守护进程里监听着 <code>8000</code> 端口了。打开 <code>127.0.0.1:8000</code> 即可看到 <code>Django</code> 欢迎页面。</p><p>你还可以在 Docker 上运行其它的管理命令，例如对于同步数据库结构这种事，在运行完 <code>docker-compose up</code> 后，在另外一个终端进入文件夹运行以下命令即可：</p><pre><code>$ docker-compose run web python manage.py syncdb</code></pre><h2 id="实战-WordPress"><a href="#实战-WordPress" class="headerlink" title="实战 WordPress"></a>实战 WordPress</h2><blockquote><p>本小节内容适合 <code>PHP</code> 开发人员阅读。</p></blockquote><p><code>Compose</code> 可以很便捷的让 <code>Wordpress</code> 运行在一个独立的环境中。</p><h3 id="创建空文件夹"><a href="#创建空文件夹" class="headerlink" title="创建空文件夹"></a>创建空文件夹</h3><p>假设新建一个名为 <code>wordpress</code> 的文件夹，然后进入这个文件夹。</p><h3 id="创建-docker-compose-yml-文件"><a href="#创建-docker-compose-yml-文件" class="headerlink" title="创建 docker-compose.yml 文件"></a>创建 <code>docker-compose.yml</code> 文件</h3><p><code>docker-compose.yml</code> 文件将开启一个 <code>wordpress</code> 服务和一个独立的 <code>MySQL</code> 实例：</p><pre><code>version: "3"services:   db:     image: mysql:8.0     command:      - --default_authentication_plugin=mysql_native_password      - --character-set-server=utf8mb4      - --collation-server=utf8mb4_unicode_ci          volumes:       - db_data:/var/lib/mysql     restart: always     environment:       MYSQL_ROOT_PASSWORD: somewordpress       MYSQL_DATABASE: wordpress       MYSQL_USER: wordpress       MYSQL_PASSWORD: wordpress   wordpress:     depends_on:       - db     image: wordpress:latest     ports:       - "8000:80"     restart: always     environment:       WORDPRESS_DB_HOST: db:3306       WORDPRESS_DB_USER: wordpress       WORDPRESS_DB_PASSWORD: wordpressvolumes:  db_data:</code></pre><h3 id="构建并运行项目"><a href="#构建并运行项目" class="headerlink" title="构建并运行项目"></a>构建并运行项目</h3><p>运行 <code>docker-compose up -d</code> Compose 就会拉取镜像再创建我们所需要的镜像，然后启动 <code>wordpress</code> 和数据库容器。 接着浏览器访问 <code>127.0.0.1:8000</code> 端口就能看到 <code>WordPress</code> 安装界面了。</p><h2 id="实战-LNMP"><a href="#实战-LNMP" class="headerlink" title="实战 LNMP"></a>实战 LNMP</h2><p>本项目的维护者 <a href="https://github.com/khs1994" target="_blank" rel="noopener">khs1994</a> 的开源项目 <a href="https://github.com/khs1994-docker/lnmp" target="_blank" rel="noopener">khs1994-docker/lnmp</a> 使用 Docker Compose 搭建了一套 LNMP 环境，各位开发者可以参考该项目在 Docker 或 Kubernetes 中运行 LNMP。</p><h1 id="Swarm-mode"><a href="#Swarm-mode" class="headerlink" title="Swarm mode"></a>Swarm mode</h1><p>Docker 1.12 <a href="https://docs.docker.com/engine/swarm/" target="_blank" rel="noopener">Swarm mode</a> 已经内嵌入 Docker 引擎，成为了 docker 子命令 <code>docker swarm</code>。请注意与旧的 <code>Docker Swarm</code> 区分开来。</p><p><code>Swarm mode</code> 内置 kv 存储功能，提供了众多的新特性，比如：具有容错能力的去中心化设计、内置服务发现、负载均衡、路由网格、动态伸缩、滚动更新、安全传输等。使得 Docker 原生的 <code>Swarm</code> 集群具备与 Mesos、Kubernetes 竞争的实力。</p><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>Swarm</code> 是使用 <code>SwarmKit</code> 构建的 Docker 引擎内置（原生）的集群管理和编排工具。</p><p>使用 <code>Swarm</code> 集群之前需要了解以下几个概念。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>运行 Docker 的主机可以主动初始化一个 <code>Swarm</code> 集群或者加入一个已存在的 <code>Swarm</code> 集群，这样这个运行 Docker 的主机就成为一个 <code>Swarm</code> 集群的节点 (<code>node</code>) 。</p><p>节点分为管理 (<code>manager</code>) 节点和工作 (<code>worker</code>) 节点。</p><p>管理节点用于 <code>Swarm</code> 集群的管理，<code>docker swarm</code> 命令基本只能在管理节点执行（节点退出集群命令 <code>docker swarm leave</code> 可以在工作节点执行）。一个 <code>Swarm</code> 集群可以有多个管理节点，但只有一个管理节点可以成为 <code>leader</code>，<code>leader</code> 通过 <code>raft</code> 协议实现。</p><p>工作节点是任务执行节点，管理节点将服务 (<code>service</code>) 下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点。</p><p>来自 Docker 官网的这张图片形象的展示了集群中管理节点与工作节点的关系。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGNlMDE0YjZiY2VkYTQ3ZWVjOTkwOGZmYTQ2MTcwZGJfVGpHaW5kNDNhNlBsVUZqd2RSOElGVnRmdGk0M0NyTkxfVG9rZW46Ym94Y244MUQxbkZyOHluR0s0WGRyZ0JkTXZnXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><h3 id="服务和任务"><a href="#服务和任务" class="headerlink" title="服务和任务"></a>服务和任务</h3><p>任务 （<code>Task</code>）是 <code>Swarm</code> 中的最小的调度单位，目前来说就是一个单一的容器。</p><p>服务 （<code>Services</code>） 是指一组任务的集合，服务定义了任务的属性。服务有两种模式：</p><ul><li><p><code>replicated services</code> 按照一定规则在各个工作节点上运行指定个数的任务。</p></li><li><p><code>global services</code> 每个工作节点上运行一个任务</p></li></ul><p>两种模式通过 <code>docker service create</code> 的 <code>--mode</code> 参数指定。</p><p>来自 Docker 官网的这张图片形象的展示了容器、任务、服务的关系。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGU4OWJhNTVkYjM3ZWZhZWZlZjIwYmJjOThmOTEwODFfbDRtWkVZdHVkMzVnT0RrNUFnbmZHbzJKdjNSYlNseFZfVG9rZW46Ym94Y25aQWtQbkJDRDgzOTFyMGFSUW1LUnNlXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><h2 id="创建-Swarm-集群"><a href="#创建-Swarm-集群" class="headerlink" title="创建 Swarm 集群"></a>创建 Swarm 集群</h2><p>阅读 基本概念 一节我们知道 <code>Swarm</code> 集群由 <strong>管理节点</strong> 和 <strong>工作节点</strong> 组成。本节我们来创建一个包含一个管理节点和两个工作节点的最小 <code>Swarm</code> 集群。</p><h3 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h3><p><code>Docker Machine</code> 可以在数秒内创建一个虚拟的 Docker 主机，下面我们使用它来创建三个 Docker 主机，并加入到集群中。</p><p>我们首先创建一个 Docker 主机作为管理节点。</p><pre><code>$ docker-machine create -d virtualbox manager</code></pre><p>我们使用 <code>docker swarm init</code> 在管理节点初始化一个 <code>Swarm</code> 集群。</p><pre><code>$ docker-machine ssh managerdocker@manager:~$ docker swarm init --advertise-addr 192.168.99.100Swarm initialized: current node (dxn1zf6l61qsb1josjja83ngz) is now a manager.To add a worker to this swarm, run the following command:    docker swarm join \    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \    192.168.99.100:2377To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.</code></pre><p>如果你的 Docker 主机有多个网卡，拥有多个 IP，必须使用 <code>--advertise-addr</code> 指定 IP。</p><blockquote><p>执行 <code>docker swarm init</code> 命令的节点自动成为管理节点。</p></blockquote><h3 id="增加工作节点"><a href="#增加工作节点" class="headerlink" title="增加工作节点"></a>增加工作节点</h3><p>上一步我们初始化了一个 <code>Swarm</code> 集群，拥有了一个管理节点，下面我们继续创建两个 Docker 主机作为工作节点，并加入到集群中。</p><pre><code>$ docker-machine create -d virtualbox worker1$ docker-machine ssh worker1docker@worker1:~$ docker swarm join \    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \    192.168.99.100:2377This node joined a swarm as a worker.$ docker-machine create -d virtualbox worker2$ docker-machine ssh worker2docker@worker1:~$ docker swarm join \    --token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \    192.168.99.100:2377This node joined a swarm as a worker.</code></pre><blockquote><p>注意：一些细心的读者可能通过 <code>docker-machine create --help</code> 查看到 <code>--swarm*</code> 等一系列参数。该参数是用于旧的 <code>Docker Swarm</code>，与本章所讲的 <code>Swarm mode</code> 没有关系。</p></blockquote><h3 id="查看集群"><a href="#查看集群" class="headerlink" title="查看集群"></a>查看集群</h3><p>经过上边的两步，我们已经拥有了一个最小的 <code>Swarm</code> 集群，包含一个管理节点和两个工作节点。</p><p>在管理节点使用 <code>docker node ls</code> 查看集群。</p><pre><code>$ docker node lsID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS03g1y59jwfg7cf99w4lt0f662    worker2   Ready   Active9j68exjopxe7wfl6yuxml7a7j    worker1   Ready   Activedxn1zf6l61qsb1josjja83ngz *  manager   Ready   Active        Leader</code></pre><h2 id="部署服务"><a href="#部署服务" class="headerlink" title="部署服务"></a>部署服务</h2><p>我们使用 <code>docker service</code> 命令来管理 <code>Swarm</code> 集群中的服务，该命令只能在管理节点运行。</p><h3 id="新建服务"><a href="#新建服务" class="headerlink" title="新建服务"></a>新建服务</h3><p>现在我们在上一节创建的 <code>Swarm</code> 集群中运行一个名为 <code>nginx</code> 服务。</p><pre><code>$ docker service create --replicas 3 -p 80:80 --name nginx nginx:1.13.7-alpine</code></pre><p>现在我们使用浏览器，输入任意节点 IP ，即可看到 nginx 默认页面。</p><h3 id="查看服务"><a href="#查看服务" class="headerlink" title="查看服务"></a>查看服务</h3><p>使用 <code>docker service ls</code> 来查看当前 <code>Swarm</code> 集群运行的服务。</p><pre><code>$ docker service lsID                  NAME                MODE                REPLICAS            IMAGE                 PORTSkc57xffvhul5        nginx               replicated          3/3                 nginx:1.13.7-alpine   *:80-&gt;80/tcp</code></pre><p>使用 <code>docker service ps</code> 来查看某个服务的详情。</p><pre><code>$ docker service ps nginxID                  NAME                IMAGE                 NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTSpjfzd39buzlt        nginx.1             nginx:1.13.7-alpine   swarm2              Running             Running about a minute agohy9eeivdxlaa        nginx.2             nginx:1.13.7-alpine   swarm1              Running             Running about a minute ago36wmpiv7gmfo        nginx.3             nginx:1.13.7-alpine   swarm3              Running             Running about a minute ago</code></pre><p>使用 <code>docker service logs</code> 来查看某个服务的日志。</p><pre><code>$ docker service logs nginxnginx.3.36wmpiv7gmfo@swarm3    | 10.255.0.4 - - [25/Nov/2017:02:10:30 +0000] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0" "-"nginx.3.36wmpiv7gmfo@swarm3    | 10.255.0.4 - - [25/Nov/2017:02:10:30 +0000] "GET /favicon.ico HTTP/1.1" 404 169 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0" "-"nginx.3.36wmpiv7gmfo@swarm3    | 2017/11/25 02:10:30 [error] 5#5: *1 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 10.255.0.4, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "192.168.99.102"nginx.1.pjfzd39buzlt@swarm2    | 10.255.0.2 - - [25/Nov/2017:02:10:26 +0000] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0" "-"nginx.1.pjfzd39buzlt@swarm2    | 10.255.0.2 - - [25/Nov/2017:02:10:27 +0000] "GET /favicon.ico HTTP/1.1" 404 169 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0" "-"nginx.1.pjfzd39buzlt@swarm2    | 2017/11/25 02:10:27 [error] 5#5: *1 open() "/usr/share/nginx/html/favicon.ico" failed (2: No such file or directory), client: 10.255.0.2, server: localhost, request: "GET /favicon.ico HTTP/1.1", host: "192.168.99.101"</code></pre><h3 id="服务伸缩"><a href="#服务伸缩" class="headerlink" title="服务伸缩"></a>服务伸缩</h3><p>我们可以使用 <code>docker service scale</code> 对一个服务运行的容器数量进行伸缩。</p><p>当业务处于高峰期时，我们需要扩展服务运行的容器数量。</p><pre><code>$ docker service scale nginx=5</code></pre><p>当业务平稳时，我们需要减少服务运行的容器数量。</p><pre><code>$ docker service scale nginx=2</code></pre><h3 id="删除服务"><a href="#删除服务" class="headerlink" title="删除服务"></a>删除服务</h3><p>使用 <code>docker service rm</code> 来从 <code>Swarm</code> 集群移除某个服务。</p><pre><code>$ docker service rm nginx</code></pre><h2 id="使用-compose-文件"><a href="#使用-compose-文件" class="headerlink" title="使用 compose 文件"></a>使用 compose 文件</h2><p>正如之前使用 <code>docker-compose.yml</code> 来一次配置、启动多个容器，在 <code>Swarm</code> 集群中也可以使用 <code>compose</code> 文件 （<code>docker-compose.yml</code>） 来配置、启动多个服务。</p><p>上一节中，我们使用 <code>docker service create</code> 一次只能部署一个服务，使用 <code>docker-compose.yml</code> 我们可以一次启动多个关联的服务。</p><p>我们以在 <code>Swarm</code> 集群中部署 <code>WordPress</code> 为例进行说明。</p><pre><code>version: "3"services:  wordpress:    image: wordpress    ports:      - 80:80    networks:      - overlay    environment:      WORDPRESS_DB_HOST: db:3306      WORDPRESS_DB_USER: wordpress      WORDPRESS_DB_PASSWORD: wordpress    deploy:      mode: replicated      replicas: 3  db:    image: mysql    networks:       - overlay    volumes:      - db-data:/var/lib/mysql    environment:      MYSQL_ROOT_PASSWORD: somewordpress      MYSQL_DATABASE: wordpress      MYSQL_USER: wordpress      MYSQL_PASSWORD: wordpress    deploy:      placement:        constraints: [node.role == manager]  visualizer:    image: dockersamples/visualizer:stable    ports:      - "8080:8080"    stop_grace_period: 1m30s    volumes:      - "/var/run/docker.sock:/var/run/docker.sock"    deploy:      placement:        constraints: [node.role == manager]volumes:  db-data:networks:  overlay:</code></pre><p>在 <code>Swarm</code> 集群管理节点新建该文件，其中的 <code>visualizer</code> 服务提供一个可视化页面，我们可以从浏览器中很直观的查看集群中各个服务的运行节点。</p><p>在 <code>Swarm</code> 集群中使用 <code>docker-compose.yml</code> 我们用 <code>docker stack</code> 命令，下面我们对该命令进行详细讲解。</p><h3 id="部署服务-1"><a href="#部署服务-1" class="headerlink" title="部署服务"></a>部署服务</h3><p>部署服务使用 <code>docker stack deploy</code>，其中 <code>-c</code> 参数指定 compose 文件名。</p><pre><code>$ docker stack deploy -c docker-compose.yml wordpress</code></pre><p>现在我们打开浏览器输入 <code>任一节点IP:8080</code> 即可看到各节点运行状态。如下图所示：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NjdlMjU5Zjg3NjcxYTM2MDgxM2Y5YmJhNTJkNzJhMTJfYjk3aDlVYlJBaTJhTkFwVVNTVFMyb1V5QnpweVh1YllfVG9rZW46Ym94Y24waWpvRHB2b3ZGVGR4alpRTEp1OXBmXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>在浏览器新的标签页输入 <code>任一节点IP</code> 即可看到 <code>WordPress</code> 安装界面，安装完成之后，输入 <code>任一节点IP</code> 即可看到 <code>WordPress</code> 页面。</p><h3 id="查看服务-1"><a href="#查看服务-1" class="headerlink" title="查看服务"></a>查看服务</h3><pre><code>$ docker stack lsNAME                SERVICESwordpress           3</code></pre><h3 id="移除服务"><a href="#移除服务" class="headerlink" title="移除服务"></a>移除服务</h3><p>要移除服务，使用 <code>docker stack down</code></p><pre><code>$ docker stack down wordpressRemoving service wordpress_dbRemoving service wordpress_visualizerRemoving service wordpress_wordpressRemoving network wordpress_overlayRemoving network wordpress_default</code></pre><p>该命令不会移除服务所使用的 <code>数据卷</code>，如果你想移除数据卷请使用 <code>docker volume rm</code></p><p><a href="https://yeasy.gitbook.io/docker_practice/swarm_mode" target="_blank" rel="noopener"> </a></p><h2 id="管理密钥"><a href="#管理密钥" class="headerlink" title="管理密钥"></a>管理密钥</h2><p>在动态的、大规模的分布式集群上，管理和分发 <code>密码</code>、<code>证书</code> 等敏感信息是极其重要的工作。传统的密钥分发方式（如密钥放入镜像中，设置环境变量，volume 动态挂载等）都存在着潜在的巨大的安全风险。</p><p>Docker 目前已经提供了 <code>secrets</code> 管理功能，用户可以在 Swarm 集群中安全地管理密码、密钥证书等敏感数据，并允许在多个 Docker 容器实例之间共享访问指定的敏感数据。</p><blockquote><p>注意： <code>secret</code> 也可以在 <code>Docker Compose</code> 中使用。</p></blockquote><p>我们可以用 <code>docker secret</code> 命令来管理敏感信息。接下来我们在上面章节中创建好的 Swarm 集群中介绍该命令的使用。</p><p>这里我们以在 Swarm 集群中部署 <code>mysql</code> 和 <code>wordpress</code> 服务为例。</p><h3 id="创建-secret"><a href="#创建-secret" class="headerlink" title="创建 secret"></a>创建 secret</h3><p>我们使用 <code>docker secret create</code> 命令以管道符的形式创建 <code>secret</code></p><pre><code>$ openssl rand -base64 20 | docker secret create mysql_password -$ openssl rand -base64 20 | docker secret create mysql_root_password -</code></pre><h3 id="查看-secret"><a href="#查看-secret" class="headerlink" title="查看 secret"></a>查看 secret</h3><p>使用 <code>docker secret ls</code> 命令来查看 <code>secret</code></p><pre><code>$ docker secret lsID                          NAME                  CREATED             UPDATEDl1vinzevzhj4goakjap5ya409   mysql_password        41 seconds ago      41 seconds agoyvsczlx9votfw3l0nz5rlidig   mysql_root_password   12 seconds ago      12 seconds ago</code></pre><h3 id="创建-MySQL-服务"><a href="#创建-MySQL-服务" class="headerlink" title="创建 MySQL 服务"></a>创建 MySQL 服务</h3><p>创建服务相关命令已经在前边章节进行了介绍，这里直接列出命令。</p><pre><code>$ docker network create -d overlay mysql_private$ docker service create \     --name mysql \     --replicas 1 \     --network mysql_private \     --mount type=volume,source=mydata,destination=/var/lib/mysql \     --secret source=mysql_root_password,target=mysql_root_password \     --secret source=mysql_password,target=mysql_password \     -e MYSQL_ROOT_PASSWORD_FILE="/run/secrets/mysql_root_password" \     -e MYSQL_PASSWORD_FILE="/run/secrets/mysql_password" \     -e MYSQL_USER="wordpress" \     -e MYSQL_DATABASE="wordpress" \     mysql:latest</code></pre><p>如果你没有在 <code>target</code> 中显式的指定路径时，<code>secret</code> 默认通过 <code>tmpfs</code> 文件系统挂载到容器的 <code>/run/secrets</code> 目录中。</p><pre><code>$ docker service create \     --name wordpress \     --replicas 1 \     --network mysql_private \     --publish target=30000,port=80 \     --mount type=volume,source=wpdata,destination=/var/www/html \     --secret source=mysql_password,target=wp_db_password,mode=0400 \     -e WORDPRESS_DB_USER="wordpress" \     -e WORDPRESS_DB_PASSWORD_FILE="/run/secrets/wp_db_password" \     -e WORDPRESS_DB_HOST="mysql:3306" \     -e WORDPRESS_DB_NAME="wordpress" \     wordpress:latest</code></pre><p>查看服务</p><pre><code>$ docker service lsID            NAME   MODE        REPLICAS  IMAGEwvnh0siktqr3  mysql      replicated  1/1       mysql:latestnzt5xzae4n62  wordpress  replicated  1/1       wordpress:latest</code></pre><p>现在浏览器访问 <code>IP:30000</code>，即可开始 <code>WordPress</code> 的安装与使用。</p><p>通过以上方法，我们没有像以前通过设置环境变量来设置 MySQL 密码， 而是采用 <code>docker secret</code> 来设置密码，防范了密码泄露的风险。</p><h2 id="管理配置信息"><a href="#管理配置信息" class="headerlink" title="管理配置信息"></a>管理配置信息</h2><p>在动态的、大规模的分布式集群上，管理和分发配置文件也是很重要的工作。传统的配置文件分发方式（如配置文件放入镜像中，设置环境变量，volume 动态挂载等）都降低了镜像的通用性。</p><p>在 Docker 17.06 以上版本中，Docker 新增了 <code>docker config</code> 子命令来管理集群中的配置信息，以后你无需将配置文件放入镜像或挂载到容器中就可实现对服务的配置。</p><blockquote><p>注意：<code>config</code> 仅能在 Swarm 集群中使用。</p></blockquote><p>这里我们以在 Swarm 集群中部署 <code>redis</code> 服务为例。</p><h3 id="创建-config"><a href="#创建-config" class="headerlink" title="创建 config"></a>创建 config</h3><p>新建 <code>redis.conf</code> 文件</p><pre><code>port 6380</code></pre><p>此项配置 Redis 监听 <code>6380</code> 端口</p><p>我们使用 <code>docker config create</code> 命令创建 <code>config</code></p><pre><code>$ docker config create redis.conf redis.conf</code></pre><h3 id="查看-config"><a href="#查看-config" class="headerlink" title="查看 config"></a>查看 config</h3><p>使用 <code>docker config ls</code> 命令来查看 <code>config</code></p><pre><code>$ docker config lsID                          NAME                CREATED             UPDATEDyod8fx8iiqtoo84jgwadp86yk   redis.conf          4 seconds ago       4 seconds ago</code></pre><h3 id="创建-redis-服务"><a href="#创建-redis-服务" class="headerlink" title="创建 redis 服务"></a>创建 redis 服务</h3><pre><code>$ docker service create \     --name redis \     # --config source=redis.conf,target=/etc/redis.conf \     --config redis.conf \     -p 6379:6380 \     redis:latest \     redis-server /redis.conf</code></pre><p>如果你没有在 <code>target</code> 中显式的指定路径时，默认的 <code>redis.conf</code> 以 <code>tmpfs</code> 文件系统挂载到容器的 <code>/config.conf</code>。</p><p>经过测试，redis 可以正常使用。</p><p>以前我们通过监听主机目录来配置 Redis，就需要在集群的每个节点放置该文件，如果采用 <code>docker config</code> 来管理服务的配置信息，我们只需在集群中的管理节点创建 <code>config</code>，当部署服务时，集群会自动的将配置文件分发到运行服务的各个节点中，大大降低了配置信息的管理和分发难度。</p><h2 id="滚动升级"><a href="#滚动升级" class="headerlink" title="滚动升级"></a>滚动升级</h2><p>在 <a href="https://starcross.feishu.cn/docs/doccn4K8zDqPJzkbMyuWAKDDdyh#BpQXbd" target="_blank" rel="noopener">部署服务</a> 一节中我们使用 <code>nginx:1.13.7-alpine</code> 镜像部署了一个名为 <code>nginx</code> 的服务。</p><p>现在我们想要将 <code>NGINX</code> 版本升级到 <code>1.13.12</code>，那么在 Swarm mode 中如何升级服务呢？</p><p>你可能会想到，先停止原来的服务，再使用新镜像部署一个服务，不就完成服务的 “升级” 了吗。</p><p>这样做的弊端很明显，如果新部署的服务出现问题，原来的服务删除之后，很难恢复，那么在 Swarm mode 中到底该如何对服务进行滚动升级呢？</p><p>答案就是使用 <code>docker service update</code> 命令。</p><pre><code>$ docker service update \    --image nginx:1.13.12-alpine \    nginx</code></pre><p>以上命令使用 <code>--image</code> 选项更新了服务的镜像。当然我们也可以使用 <code>docker service update</code> 更新任意的配置。</p><p><code>--secret-add</code> 选项可以增加一个密钥</p><p><code>--secret-rm</code> 选项可以删除一个密钥</p><p>更多选项可以通过 <code>docker service update -h</code> 命令查看。</p><h3 id="服务回退"><a href="#服务回退" class="headerlink" title="服务回退"></a>服务回退</h3><p>现在假设我们发现 <code>nginx</code> 服务的镜像升级到 <code>nginx:1.13.12-alpine</code> 出现了一些问题，我们可以使用命令一键回退。</p><pre><code>$ docker service rollback nginx</code></pre><p>现在使用 <code>docker service ps</code> 命令查看 <code>nginx</code> 服务详情。</p><pre><code>$ docker service ps nginxID                  NAME                IMAGE                  NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTSrt677gop9d4x        nginx.1             nginx:1.13.7-alpine   VM-20-83-debian     Running             Running about a minute agod9pw13v59d00         \_ nginx.1         nginx:1.13.12-alpine  VM-20-83-debian     Shutdown            Shutdown 2 minutes agoi7ynkbg6ybq5         \_ nginx.1         nginx:1.13.7-alpine   VM-20-83-debian     Shutdown            Shutdown 2 minutes ago</code></pre><p>结果的输出详细记录了服务的部署、滚动升级、回退的过程。</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>评估 Docker 的安全性时，主要考虑三个方面:</p><ul><li><p>由内核的命名空间和控制组机制提供的容器内在安全</p></li><li><p>Docker 程序（特别是服务端）本身的抗攻击性</p></li><li><p>内核安全性的加强机制对容器安全性的影响</p></li></ul><h2 id="内核命名空间"><a href="#内核命名空间" class="headerlink" title="内核命名空间"></a>内核命名空间</h2><p>Docker 容器和 LXC 容器很相似，所提供的安全特性也差不多。当用 <code>docker run</code> 启动一个容器时，在后台 Docker 为容器创建了一个独立的命名空间和控制组集合。</p><p>命名空间提供了最基础也是最直接的隔离，在容器中运行的进程不会被运行在主机上的进程和其它容器发现和作用。</p><p>每个容器都有自己独有的网络栈，意味着它们不能访问其他容器的 sockets 或接口。不过，如果主机系统上做了相应的设置，容器可以像跟主机交互一样的和其他容器交互。当指定公共端口或使用 links 来连接 2 个容器时，容器就可以相互通信了（可以根据配置来限制通信的策略）。</p><p>从网络架构的角度来看，所有的容器通过本地主机的网桥接口相互通信，就像物理机器通过物理交换机通信一样。</p><p>那么，内核中实现命名空间和私有网络的代码是否足够成熟？</p><p>内核命名空间从 2.6.15 版本（2008 年 7 月发布）之后被引入，数年间，这些机制的可靠性在诸多大型生产系统中被实践验证。</p><p>实际上，命名空间的想法和设计提出的时间要更早，最初是为了在内核中引入一种机制来实现 <a href="https://en.wikipedia.org/wiki/OpenVZ" target="_blank" rel="noopener">OpenVZ</a> 的特性。 而 OpenVZ 项目早在 2005 年就发布了，其设计和实现都已经十分成熟。</p><h2 id="控制组"><a href="#控制组" class="headerlink" title="控制组"></a>控制组</h2><p>控制组是 Linux 容器机制的另外一个关键组件，负责实现资源的审计和限制。</p><p>它提供了很多有用的特性；以及确保各个容器可以公平地分享主机的内存、CPU、磁盘 IO 等资源；当然，更重要的是，控制组确保了当容器内的资源使用产生压力时不会连累主机系统。</p><p>尽管控制组不负责隔离容器之间相互访问、处理数据和进程，它在防止拒绝服务（DDOS）攻击方面是必不可少的。尤其是在多用户的平台（比如公有或私有的 PaaS）上，控制组十分重要。例如，当某些应用程序表现异常的时候，可以保证一致地正常运行和性能。</p><p>控制组机制始于 2006 年，内核从 2.6.24 版本开始被引入。</p><h2 id="服务端防护"><a href="#服务端防护" class="headerlink" title="服务端防护"></a>服务端防护</h2><p>运行一个容器或应用程序的核心是通过 Docker 服务端。Docker 服务的运行目前需要 root 权限，因此其安全性十分关键。</p><p>首先，确保只有可信的用户才可以访问 Docker 服务。Docker 允许用户在主机和容器间共享文件夹，同时不需要限制容器的访问权限，这就容易让容器突破资源限制。例如，恶意用户启动容器的时候将主机的根目录<code>/</code>映射到容器的 <code>/host</code> 目录中，那么容器理论上就可以对主机的文件系统进行任意修改了。这听起来很疯狂？但是事实上几乎所有虚拟化系统都允许类似的资源共享，而没法禁止用户共享主机根文件系统到虚拟机系统。</p><p>这将会造成很严重的安全后果。因此，当提供容器创建服务时（例如通过一个 web 服务器），要更加注意进行参数的安全检查，防止恶意的用户用特定参数来创建一些破坏性的容器。</p><p>为了加强对服务端的保护，Docker 的 REST API（客户端用来跟服务端通信）在 0.5.2 之后使用本地的 Unix 套接字机制替代了原先绑定在 127.0.0.1 上的 TCP 套接字，因为后者容易遭受跨站脚本攻击。现在用户使用 Unix 权限检查来加强套接字的访问安全。</p><p>用户仍可以利用 HTTP 提供 REST API 访问。建议使用安全机制，确保只有可信的网络或 VPN，或证书保护机制（例如受保护的 stunnel 和 ssl 认证）下的访问可以进行。此外，还可以使用 <a href="https://docs.docker.com/engine/security/https/" target="_blank" rel="noopener"> HTTPS 和证书</a> 来加强保护。</p><p>最近改进的 Linux 命名空间机制将可以实现使用非 root 用户来运行全功能的容器。这将从根本上解决了容器和主机之间共享文件系统而引起的安全问题。</p><p>终极目标是改进 2 个重要的安全特性：</p><ul><li><p>将容器的 root 用户 <a href="https://docs.docker.com/engine/security/userns-remap/" target="_blank" rel="noopener">映射到本地主机上的非 root 用户</a>，减轻容器和主机之间因权限提升而引起的安全问题；</p></li><li><p>允许 Docker 服务端在 <a href="https://docs.docker.com/engine/security/rootless/" target="_blank" rel="noopener">非 root 权限(rootless 模式)</a> 下运行，利用安全可靠的子进程来代理执行需要特权权限的操作。这些子进程将只允许在限定范围内进行操作，例如仅仅负责虚拟网络设定或文件系统管理、配置操作等。</p></li></ul><p>最后，建议采用专用的服务器来运行 Docker 和相关的管理服务（例如管理服务比如 ssh 监控和进程监控、管理工具 nrpe、collectd 等）。其它的业务服务都放到容器中去运行。</p><h2 id="内核能力机制"><a href="#内核能力机制" class="headerlink" title="内核能力机制"></a>内核能力机制</h2><p><a href="https://man7.org/linux/man-pages/man7/capabilities.7.html" target="_blank" rel="noopener">能力机制（Capability）</a> 是 Linux 内核一个强大的特性，可以提供细粒度的权限访问控制。 Linux 内核自 2.2 版本起就支持能力机制，它将权限划分为更加细粒度的操作能力，既可以作用在进程上，也可以作用在文件上。</p><p>例如，一个 Web 服务进程只需要绑定一个低于 1024 的端口的权限，并不需要 root 权限。那么它只需要被授权 <code>net_bind_service</code> 能力即可。此外，还有很多其他的类似能力来避免进程获取 root 权限。</p><p>默认情况下，Docker 启动的容器被严格限制只允许使用内核的一部分能力。</p><p>使用能力机制对加强 Docker 容器的安全有很多好处。通常，在服务器上会运行一堆需要特权权限的进程，包括有 ssh、cron、syslogd、硬件管理工具模块（例如负载模块）、网络配置工具等等。容器跟这些进程是不同的，因为几乎所有的特权进程都由容器以外的支持系统来进行管理。</p><ul><li><p>ssh 访问被主机上ssh服务来管理；</p></li><li><p>cron 通常应该作为用户进程执行，权限交给使用它服务的应用来处理；</p></li><li><p>日志系统可由 Docker 或第三方服务管理；</p></li><li><p>硬件管理无关紧要，容器中也就无需执行 udevd 以及类似服务；</p></li><li><p>网络管理也都在主机上设置，除非特殊需求，容器不需要对网络进行配置。</p></li></ul><p>从上面的例子可以看出，大部分情况下，容器并不需要“真正的” root 权限，容器只需要少数的能力即可。为了加强安全，容器可以禁用一些没必要的权限。</p><ul><li><p>完全禁止任何 mount 操作；</p></li><li><p>禁止直接访问本地主机的套接字；</p></li><li><p>禁止访问一些文件系统的操作，比如创建新的设备、修改文件属性等；</p></li><li><p>禁止模块加载。</p></li></ul><p>这样，就算攻击者在容器中取得了 root 权限，也不能获得本地主机的较高权限，能进行的破坏也有限。</p><p>默认情况下，Docker采用 <a href="https://github.com/moby/moby/blob/master/oci/caps/defaults.go" target="_blank" rel="noopener">白名单</a> 机制，禁用必需功能之外的其它权限。 当然，用户也可以根据自身需求来为 Docker 容器启用额外的权限。</p><h2 id="其它安全特性"><a href="#其它安全特性" class="headerlink" title="其它安全特性"></a>其它安全特性</h2><p>除了能力机制之外，还可以利用一些现有的安全机制来增强使用 Docker 的安全性，例如 TOMOYO, AppArmor, Seccomp, SELinux, GRSEC 等。</p><p>Docker 当前默认只启用了能力机制。用户可以采用多种方案来加强 Docker 主机的安全，例如：</p><ul><li><p>在内核中启用 GRSEC 和 PAX，这将增加很多编译和运行时的安全检查；通过地址随机化避免恶意探测等。并且，启用该特性不需要 Docker 进行任何配置。</p></li><li><p>使用一些有增强安全特性的容器模板，比如带 AppArmor 的模板和 Redhat 带 SELinux 策略的模板。这些模板提供了额外的安全特性。</p></li><li><p>用户可以自定义访问控制机制来定制安全策略。</p></li></ul><p>跟其它添加到 Docker 容器的第三方工具一样（比如网络拓扑和文件系统共享），有很多类似的机制，在不改变 Docker 内核情况下就可以加固现有的容器。</p><p><a href="https://yeasy.gitbook.io/docker_practice/security/daemon_sec" target="_blank" rel="noopener"> </a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来看，Docker 容器还是十分安全的，特别是在容器内不使用 root 权限来运行进程的话。</p><p>另外，用户可以使用现有工具，比如 <a href="https://docs.docker.com/engine/security/apparmor/" target="_blank" rel="noopener">Apparmor</a>, <a href="https://docs.docker.com/engine/security/seccomp/" target="_blank" rel="noopener">Seccomp</a>, SELinux, GRSEC 来增强安全性；甚至自己在内核中实现更复杂的安全机制。</p><p><a href="https://yeasy.gitbook.io/docker_practice/security/control_group" target="_blank" rel="noopener"> </a></p><h1 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h1><p>Docker 底层的核心技术包括 Linux 上的命名空间（Namespaces）、控制组（Control groups）、Union 文件系统（Union file systems）和容器格式（Container format）。</p><p>我们知道，传统的虚拟机通过在宿主主机中运行 hypervisor 来模拟一整套完整的硬件环境提供给虚拟机的操作系统。虚拟机系统看到的环境是可限制的，也是彼此隔离的。 这种直接的做法实现了对资源最完整的封装，但很多时候往往意味着系统资源的浪费。 例如，以宿主机和虚拟机系统都为 Linux 系统为例，虚拟机中运行的应用其实可以利用宿主机系统中的运行环境。</p><p>我们知道，在操作系统中，包括内核、文件系统、网络、PID、UID、IPC、内存、硬盘、CPU 等等，所有的资源都是应用进程直接共享的。 要想实现虚拟化，除了要实现对内存、CPU、网络IO、硬盘IO、存储空间等的限制外，还要实现文件系统、网络、PID、UID、IPC等等的相互隔离。 前者相对容易实现一些，后者则需要宿主机系统的深入支持。</p><p>随着 Linux 系统对于命名空间功能的完善实现，程序员已经可以实现上面的所有需求，让某些进程在彼此隔离的命名空间中运行。大家虽然都共用一个内核和某些运行时环境（例如一些系统命令和系统库），但是彼此却看不到，都以为系统中只有自己的存在。这种机制就是容器（Container），利用命名空间来做权限的隔离控制，利用 cgroups 来做资源分配。</p><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>Docker 采用了 <code>C/S</code> 架构，包括客户端和服务端。Docker 守护进程 （<code>Daemon</code>）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）。</p><p>客户端和服务端既可以运行在一个机器上，也可通过 <code>socket</code> 或者 <code>RESTful API</code> 来进行通信。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MmFkOGNmNDdkMTk1YzA0MjQ1MmVjY2MwNDg3YmU1MmZfSXBYem95S1ZyVkQwMGxVVGhpTEJWRFpjd1Q3SDVUaEtfVG9rZW46Ym94Y25xNGRQRnd1M0pHMzJIUDk1dEp2MFJjXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>Docker 守护进程一般在宿主主机后台运行，等待接收来自客户端的消息。</p><p>Docker 客户端则为用户提供一系列可执行命令，用户用这些命令实现跟 Docker 守护进程交互。</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>命名空间是 Linux 内核一个强大的特性。每个容器都有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响。</p><h3 id="pid-命名空间"><a href="#pid-命名空间" class="headerlink" title="pid 命名空间"></a>pid 命名空间</h3><p>不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。所有的 LXC 进程在 Docker 中的父进程为 Docker 进程，每个 LXC 进程具有不同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。</p><h3 id="net-命名空间"><a href="#net-命名空间" class="headerlink" title="net 命名空间"></a>net 命名空间</h3><p>有了 pid 命名空间，每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备，IP 地址，路由表，/proc/net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。</p><h3 id="ipc-命名空间"><a href="#ipc-命名空间" class="headerlink" title="ipc 命名空间"></a>ipc 命名空间</h3><p>容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess communication - IPC)， 包括信号量、消息队列和共享内存等。然而同 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 id。</p><h3 id="mnt-命名空间"><a href="#mnt-命名空间" class="headerlink" title="mnt 命名空间"></a>mnt 命名空间</h3><p>类似 chroot，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个命名空间中的容器在 /proc/mounts 的信息只包含所在命名空间的 mount point。</p><h3 id="uts-命名空间"><a href="#uts-命名空间" class="headerlink" title="uts 命名空间"></a>uts 命名空间</h3><p>UTS(“UNIX Time-sharing System”) 命名空间允许每个容器拥有独立的 hostname 和 domain name， 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。</p><h3 id="user-命名空间"><a href="#user-命名空间" class="headerlink" title="user 命名空间"></a>user 命名空间</h3><p>每个容器可以有不同的用户和组 id， 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。</p><p>注：更多关于 Linux 上命名空间的信息，请阅读 <a href="https://blog.scottlowe.org/2013/09/04/introducing-linux-network-namespaces/" target="_blank" rel="noopener">这篇文章</a>。</p><h2 id="控制组-1"><a href="#控制组-1" class="headerlink" title="控制组"></a>控制组</h2><p>控制组（<a href="https://en.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroups</a>）是 Linux 内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。</p><p>控制组技术最早是由 Google 的程序员在 2006 年提出，Linux 内核自 2.6.24 开始支持。</p><p>控制组可以提供对容器的内存、CPU、磁盘 IO 等资源的限制和审计管理。</p><h2 id="联合文件系统"><a href="#联合文件系统" class="headerlink" title="联合文件系统"></a>联合文件系统</h2><p>联合文件系统（<a href="https://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="noopener">UnionFS</a>）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p><p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><p>另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。</p><p>Docker 中使用的 AUFS（Advanced Multi-Layered Unification Filesystem）就是一种联合文件系统。 <code>AUFS</code> 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 <code>AUFS</code> 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。</p><p>Docker 目前支持的联合文件系统包括 <code>OverlayFS</code>, <code>AUFS</code>, <code>Btrfs</code>, <code>VFS</code>, <code>ZFS</code> 和 <code>Device Mapper</code>。</p><p>各 Linux 发行版 Docker 推荐使用的存储驱动如下表。</p><p>无法复制加载中的内容</p><p>在可能的情况下，<a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/" target="_blank" rel="noopener">推荐</a> 使用 <code>overlay2</code> 存储驱动，<code>overlay2</code> 是目前 Docker 默认的存储驱动，以前则是 <code>aufs</code>。你可以通过配置来使用以上提到的其他类型的存储驱动。</p><h2 id="容器格式"><a href="#容器格式" class="headerlink" title="容器格式"></a>容器格式</h2><p>最初，Docker 采用了 <code>LXC</code> 中的容器格式。从 0.7 版本以后开始去除 LXC，转而使用自行开发的 <a href="https://github.com/docker/libcontainer" target="_blank" rel="noopener">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runC</a> 和 <a href="https://github.com/containerd/containerd" target="_blank" rel="noopener">containerd</a>。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>Docker 的网络实现其实就是利用了 Linux 上的网络命名空间和虚拟网络设备（特别是 veth pair）。建议先熟悉了解这两部分的基本概念再阅读本章。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>首先，要实现网络通信，机器需要至少一个网络接口（物理接口或虚拟接口）来收发数据包；此外，如果不同子网之间要进行通信，需要路由机制。</p><p>Docker 中的网络接口默认都是虚拟的接口。虚拟接口的优势之一是转发效率较高。 Linux 通过在内核中进行数据复制来实现虚拟接口之间的数据转发，发送接口的发送缓存中的数据包被直接复制到接收接口的接收缓存中。对于本地系统和容器内系统看来就像是一个正常的以太网卡，只是它不需要真正同外部网络设备通信，速度要快很多。</p><p>Docker 容器网络就利用了这项技术。它在本地主机和容器内分别创建一个虚拟接口，并让它们彼此连通（这样的一对接口叫做 <code>veth pair</code>）。</p><h3 id="创建网络参数"><a href="#创建网络参数" class="headerlink" title="创建网络参数"></a>创建网络参数</h3><p>Docker 创建一个容器的时候，会执行如下操作：</p><ul><li><p>创建一对虚拟接口，分别放到本地主机和新容器中；</p></li><li><p>本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 veth65f9；</p></li><li><p>容器一端放到新容器中，并修改名字作为 eth0，这个接口只在容器的命名空间可见；</p></li><li><p>从网桥可用地址段中获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 veth65f9。</p></li></ul><p>完成这些之后，容器就可以使用 eth0 虚拟网卡来连接其他容器和其他网络。</p><p>可以在 <code>docker run</code> 的时候通过 <code>--net</code> 参数来指定容器的网络配置，有4个可选值：</p><ul><li><p><code>--net=bridge</code> 这个是默认值，连接到默认的网桥。</p></li><li><p><code>--net=host</code> 告诉 Docker 不要将容器网络放到隔离的命名空间中，即不要容器化容器内的网络。此时容器使用本地主机的网络，它拥有完全的本地主机接口访问权限。容器进程可以跟主机其它 root 进程一样可以打开低范围的端口，可以访问本地网络服务比如 D-bus，还可以让容器做一些影响整个主机系统的事情，比如重启主机。因此使用这个选项的时候要非常小心。如果进一步的使用 <code>--privileged=true</code>，容器会被允许直接配置主机的网络堆栈。</p></li><li><p><code>--net=container:NAME_or_ID</code> 让 Docker 将新建容器的进程放到一个已存在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但会和已存在的容器共享 IP 地址和端口等网络资源，两者进程可以直接通过 <code>lo</code> 环回接口通信。</p></li><li><p><code>--net=none</code> 让 Docker 将新容器放到隔离的网络栈中，但是不进行网络配置。之后，用户可以自己进行配置。</p></li></ul><h3 id="网络配置细节"><a href="#网络配置细节" class="headerlink" title="网络配置细节"></a>网络配置细节</h3><p>用户使用 <code>--net=none</code> 后，可以自行配置网络，让容器达到跟平常一样具有访问网络的权限。通过这个过程，可以了解 Docker 配置网络的细节。</p><p>首先，启动一个 <code>/bin/bash</code> 容器，指定 <code>--net=none</code> 参数。</p><pre><code>$ docker run -i -t --rm --net=none base /bin/bashroot@63f36fc01b5f:/#</code></pre><p>在本地主机查找容器的进程 id，并为它创建网络命名空间。</p><pre><code>$ docker inspect -f '{{.State.Pid}}' 63f36fc01b5f2778$ pid=2778$ sudo mkdir -p /var/run/netns$ sudo ln -s /proc/$pid/ns/net /var/run/netns/$pid</code></pre><p>检查桥接网卡的 IP 和子网掩码信息。</p><pre><code>$ ip addr show docker021: docker0: ...inet 172.17.42.1/16 scope global docker0...</code></pre><p>创建一对 “veth pair” 接口 A 和 B，绑定 A 到网桥 <code>docker0</code>，并启用它</p><pre><code>$ sudo ip link add A type veth peer name B$ sudo brctl addif docker0 A$ sudo ip link set A up</code></pre><p>将B放到容器的网络命名空间，命名为 eth0，启动它并配置一个可用 IP（桥接网段）和默认网关。</p><pre><code>$ sudo ip link set B netns $pid$ sudo ip netns exec $pid ip link set dev B name eth0$ sudo ip netns exec $pid ip link set eth0 up$ sudo ip netns exec $pid ip addr add 172.17.42.99/16 dev eth0$ sudo ip netns exec $pid ip route add default via 172.17.42.1</code></pre><p>以上，就是 Docker 配置网络的具体过程。</p><p>当容器结束后，Docker 会清空容器，容器内的 eth0 会随网络命名空间一起被清除，A 接口也被自动从 <code>docker0</code> 卸载。</p><p>此外，用户可以使用 <code>ip netns exec</code> 命令来在指定网络命名空间中进行配置，从而配置容器内的网络。</p><h1 id="Etcd-项目"><a href="#Etcd-项目" class="headerlink" title="Etcd 项目"></a>Etcd 项目</h1><p><code>etcd</code> 是 <code>CoreOS</code> 团队发起的一个管理配置信息和服务发现（<code>Service Discovery</code>）的项目，在这一章里面，我们将基于 <code>etcd 3.x</code> 版本介绍该项目的目标，安装和使用，以及实现的技术。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ODdjOTZjMjJjMmM0YTdmMDljZWI1OWJjMWJlNzRiODRfREdWNTlRN2hFVWg5czdaWDlCaVQyeGZDRlpaOTR4NlpfVG9rZW46Ym94Y25MYzQyVmxiMTJ3ZGRWQzQ2Vk84Z1VjXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p><code>etcd</code> 是 <code>CoreOS</code> 团队于 2013 年 6 月发起的开源项目，它的目标是构建一个高可用的分布式键值（<code>key-value</code>）数据库，基于 <code>Go</code> 语言实现。我们知道，在分布式系统中，各种服务的配置信息的管理分享，服务的发现是一个很基本同时也是很重要的问题。<code>CoreOS</code> 项目就希望基于 <code>etcd</code> 来解决这一问题。</p><p><code>etcd</code> 目前在 <a href="https://github.com/etcd-io/etcd" target="_blank" rel="noopener">github.com/etcd-io/etcd</a> 进行维护。</p><p>受到 <a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">Apache ZooKeeper</a> 项目和 <a href="https://github.com/ha/doozerd" target="_blank" rel="noopener">doozer</a> 项目的启发，<code>etcd</code> 在设计的时候重点考虑了下面四个要素：</p><ul><li><p>简单：具有定义良好、面向用户的 <code>API</code> (<a href="https://github.com/grpc/grpc" target="_blank" rel="noopener">gRPC</a>)</p></li><li><p>安全：支持 <code>HTTPS</code> 方式的访问</p></li><li><p>快速：支持并发 <code>10 k/s</code> 的写操作</p></li><li><p>可靠：支持分布式结构，基于 <code>Raft</code> 的一致性算法</p></li></ul><p><em>Apache ZooKeeper 是一套知名的分布式系统中进行同步和一致性管理的工具。</em></p><p><em>doozer 是一个一致性分布式数据库。</em></p><p><em><a href="https://raft.github.io/" target="_blank" rel="noopener">Raft</a></em> <em>是一套通过选举主节点来实现分布式系统一致性的算法，相比于大名鼎鼎的 Paxos 算法，它的过程更容易被人理解，由 Stanford 大学的 Diego Ongaro 和 John Ousterhout 提出。更多细节可以参考</em> <em><a href="http://raftconsensus.github.io/" target="_blank" rel="noopener">raftconsensus.github.io</a>**。</em></p><p>一般情况下，用户使用 <code>etcd</code> 可以在多个节点上启动多个实例，并添加它们为一个集群。同一个集群中的 <code>etcd</code> 实例将会保持彼此信息的一致性。</p><h1 id="Fedora-CoreOS"><a href="#Fedora-CoreOS" class="headerlink" title="Fedora CoreOS"></a>Fedora CoreOS</h1><p><code>CoreOS</code> 是一个专门为安全和大规模运行容器化工作负载而构建的新 Fedora 版本，它继承了 Fedora Atomic Host 和 CoreOS Container Linux 的优势。</p><p><code>CoreOS</code> 的安装文件和运行依赖非常小，它提供了精简的 Linux 系统。它使用 Linux 容器在更高的抽象层来管理你的服务，而不是通过常规的包管理工具 <code>yum</code> 或 <code>apt</code> 来安装包。</p><p>同时，<code>CoreOS</code> 几乎可以运行在任何平台：<code>VirtualBox</code> <code>Amazon EC2</code> <code>QEMU/KVM</code> <code>VMware</code> <code>Bare Metal</code> 和 <code>OpenStack</code> 等 。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://getfedora.org/coreos/" target="_blank" rel="noopener">Fedora CoreOS</a> 是一个自动更新的，最小的，整体的，以容器为中心的操作系统，不仅适用于集群，而且可独立运行，并针对运行 Kubernetes 进行了优化。它旨在结合 CoreOS Container Linux 和 Fedora Atomic Host 的优点，将 Container Linux 中的 <a href="https://github.com/coreos/ignition" target="_blank" rel="noopener">Ignition</a> 与 <a href="https://github.com/coreos/rpm-ostree" target="_blank" rel="noopener">rpm-ostree</a> 和 Project Atomic 中的 SELinux 强化等技术相集成。其目标是提供最佳的容器主机，以安全，大规模地运行容器化的工作负载。</p><h3 id="FCOS-特性"><a href="#FCOS-特性" class="headerlink" title="FCOS 特性"></a>FCOS 特性</h3><h4 id="一个最小化操作系统"><a href="#一个最小化操作系统" class="headerlink" title="一个最小化操作系统"></a>一个最小化操作系统</h4><p>FCOS 被设计成一个基于容器的最小化的现代操作系统。它比现有的 Linux 安装平均节省 40% 的 RAM（大约 114M ）并允许从 PXE 或 iPXE 非常快速的启动。</p><h4 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h4><p>Ignition 是一种配置实用程序，可读取配置文件（JSON 格式）并根据该配置配置 FCOS 系统。可配置的组件包括存储，文件系统，systemd 和用户。</p><p>Ignition 在系统首次启动期间（在 initramfs 中）仅运行一次。由于 Ignition 在启动过程中的早期运行，因此它可以在用户空间开始启动之前重新对磁盘分区，格式化文件系统，创建用户并写入文件。当 systemd 启动时，systemd 服务已被写入磁盘，从而加快了启动时间。</p><h4 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h4><p>FCOS 使用 rpm-ostree 系统进行事务性升级。无需像 yum 升级那样升级单个软件包，而是 rpm-ostree 将 OS 升级作为一个原子单元进行。新的 OS 部署在升级期间进行，并在下次重新引导时生效。如果升级出现问题，则一次回滚和重新启动会使系统返回到先前的状态。确保了系统升级对群集容量的影响降到最小。</p><h4 id="容器工具"><a href="#容器工具" class="headerlink" title="容器工具"></a>容器工具</h4><p>对于诸如构建，复制和其他管理容器的任务，FCOS 用一组容器工具代替了 <strong>Docker CLI</strong>。<strong>podman CLI</strong> 工具支持许多容器运行时功能，例如运行，启动，停止，列出和删除容器和镜像。<strong>skopeo CLI</strong> 工具可以复制，认证和签名镜像。您还可以使用 <strong>crictl CLI</strong> 工具来处理 CRI-O 容器引擎中的容器和镜像。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><p><a href="https://docs.fedoraproject.org/en-US/fedora-coreos/" target="_blank" rel="noopener">官方文档</a></p></li><li><p><a href="https://docs.openshift.com/container-platform/4.3/architecture/architecture-rhcos.html" target="_blank" rel="noopener">openshift 官方文档</a></p></li></ul><h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><h3 id="下载-ISO"><a href="#下载-ISO" class="headerlink" title="下载 ISO"></a>下载 ISO</h3><p>在 <a href="https://getfedora.org/coreos/download/" target="_blank" rel="noopener">下载页面</a> <code>Bare Metal &amp; Virtualized</code> 标签页下载 ISO。</p><h3 id="编写-FCC"><a href="#编写-FCC" class="headerlink" title="编写 FCC"></a>编写 FCC</h3><p>FCC 是 Fedora CoreOS Configuration （Fedora CoreOS 配置）的简称。</p><pre><code># example.fccvariant: fcosversion: 1.0.0passwd:  users:    - name: core      ssh_authorized_keys:        - ssh-rsa AAAA...</code></pre><p>将 <code>ssh-rsa AAAA...</code> 替换为自己的 SSH 公钥（位于 <code>~/.ssh/id_rsa.pub</code>）。</p><h3 id="转换-FCC-为-Ignition"><a href="#转换-FCC-为-Ignition" class="headerlink" title="转换 FCC 为 Ignition"></a>转换 FCC 为 Ignition</h3><pre><code>$ docker run -i --rm quay.io/coreos/fcct:v0.5.0 --pretty --strict &lt; example.fcc &gt; example.ign</code></pre><h3 id="挂载-ISO-启动虚拟机并安装"><a href="#挂载-ISO-启动虚拟机并安装" class="headerlink" title="挂载 ISO 启动虚拟机并安装"></a>挂载 ISO 启动虚拟机并安装</h3><blockquote><p>虚拟机需要分配 3GB 以上内存，否则会无法启动。</p></blockquote><p>在虚拟机终端执行以下命令安装：</p><pre><code>$ sudo coreos-installer install /dev/sda --ignition-file example.ign</code></pre><p>安装之后重新启动即可使用。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><pre><code>$ ssh core@虚拟机IP$ docker --version</code></pre><h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://docs.fedoraproject.org/en-US/fedora-coreos/bare-metal/" target="_blank" rel="noopener">官方文档</a></li></ul><h1 id="Kubernetes-开源容器编排引擎"><a href="#Kubernetes-开源容器编排引擎" class="headerlink" title="Kubernetes - 开源容器编排引擎"></a>Kubernetes - 开源容器编排引擎</h1><p><code>Kubernetes</code> 是 Google 团队发起并维护的基于 Docker 的开源容器集群管理系统，它不仅支持常见的云平台，而且支持内部数据中心。</p><p>建于 Docker 之上的 <code>Kubernetes</code> 可以构建一个容器的调度服务，其目的是让用户透过 <code>Kubernetes</code> 集群来进行云端容器集群的管理，而无需用户进行复杂的设置工作。系统会自动选取合适的工作节点来执行具体的容器集群调度处理工作。其核心概念是 <code>Container Pod</code>。一个 <code>Pod</code> 由一组工作于同一物理工作节点的容器构成。这些组容器拥有相同的网络命名空间、IP以及存储配额，也可以根据实际情况对每一个 <code>Pod</code> 进行端口映射。此外，<code>Kubernetes</code> 工作节点会由主系统进行管理，节点包含了能够运行 Docker 容器所用到的服务。</p><p>本章将分为 5 节介绍 <code>Kubernetes</code>，包括</p><ul><li><p>项目简介</p></li><li><p>快速入门</p></li><li><p>基本概念</p></li><li><p>实践例子</p></li><li><p>架构分析等高级话题</p></li></ul><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Q4ZmM1Zjg5YzkxODhiMmRkNWMyMTU5ZTBhMTNiYTFfcEJZUTdCT2x6b2hPZFY5RkE5UGhkY0Q4SjFPY0hUOGVfVG9rZW46Ym94Y25OWWV0ZnZ5UjZIY1VuV3Jrd1RoUHhiXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>Kubernetes 是 Google 团队发起的开源项目，它的目标是管理跨多个主机的容器，提供基本的部署，维护以及应用伸缩，主要实现语言为 Go 语言。Kubernetes 是：</p><ul><li><p>易学：轻量级，简单，容易理解</p></li><li><p>便携：支持公有云，私有云，混合云，以及多种云平台</p></li><li><p>可拓展：模块化，可插拔，支持钩子，可任意组合</p></li><li><p>自修复：自动重调度，自动重启，自动复制</p></li></ul><p>Kubernetes 构建于 Google 数十年经验，一大半来源于 Google 生产环境规模的经验。结合了社区最佳的想法和实践。</p><p>在分布式系统中，部署，调度，伸缩一直是最为重要的也最为基础的功能。Kubernetes 就是希望解决这一序列问题的。</p><p>Kubernetes 目前在<a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">GitHub</a>进行维护。</p><p><strong>Kubernetes 能够运行在任何地方！</strong></p><p>虽然 Kubernetes 最初是为 GCE 定制的，但是在后续版本中陆续增加了其他云平台的支持，以及本地数据中心的支持。</p><ul><li><a href="https://yeasy.gitbook.io/docker_practice/kubernetes/concepts" target="_blank" rel="noopener">基本概念</a></li><li><a href="https://yeasy.gitbook.io/docker_practice/kubernetes/design" target="_blank" rel="noopener">架构设计</a></li></ul><h1 id="部署-Kubernetes"><a href="#部署-Kubernetes" class="headerlink" title="部署 Kubernetes"></a>部署 Kubernetes</h1><p>目前，Kubernetes 支持在多种环境下使用，包括本地主机（Ubuntu、Debian、CentOS、Fedora 等）、云服务（<a href="https://cloud.tencent.com/act/cps/redirect?redirect=10058&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61" target="_blank" rel="noopener">腾讯云</a>、<a href="https://www.aliyun.com/product/kubernetes?source=5176.11533457&amp;userCode=8lx5zmtu&amp;type=copy" target="_blank" rel="noopener">阿里云</a>、<a href="https://cloud.baidu.com/product/cce.html" target="_blank" rel="noopener">百度云</a> 等）。</p><p>你可以使用以下几种方式部署 Kubernetes：</p><ul><li><p>kubeadm</p></li><li><p>docker-desktop</p></li><li><p>k3s</p></li></ul><h2 id="使用-kubeadm-部署-kubernetes"><a href="#使用-kubeadm-部署-kubernetes" class="headerlink" title="使用 kubeadm 部署 kubernetes"></a>使用 kubeadm 部署 kubernetes</h2><p><code>kubeadm</code> 提供了 <code>kubeadm init</code> 以及 <code>kubeadm join</code> 这两个命令作为快速创建 <code>kubernetes</code> 集群的最佳实践。</p><h3 id="安装-Docker-2"><a href="#安装-Docker-2" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><h3 id="安装-kubelet-kubeadm-kubectl"><a href="#安装-kubelet-kubeadm-kubectl" class="headerlink" title="安装 kubelet kubeadm kubectl"></a>安装 <strong>kubelet</strong> <strong>kubeadm</strong> <strong>kubectl</strong></h3><h4 id="Ubuntu-Debian"><a href="#Ubuntu-Debian" class="headerlink" title="Ubuntu/Debian"></a>Ubuntu/Debian</h4><pre><code>$ apt-get update &amp;&amp; apt-get install -y apt-transport-https$ curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -$ cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.listdeb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial mainEOF$ apt-get update$ apt-get install -y kubelet kubeadm kubectl</code></pre><h4 id="CentOS-Fedora"><a href="#CentOS-Fedora" class="headerlink" title="CentOS/Fedora"></a>CentOS/Fedora</h4><pre><code>$ cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF$ sudo yum install -y kubelet kubeadm kubectl</code></pre><h3 id="修改内核的运行参数"><a href="#修改内核的运行参数" class="headerlink" title="修改内核的运行参数"></a>修改内核的运行参数</h3><pre><code>$ cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.confnet.bridge.bridge-nf-call-iptables  = 1net.ipv4.ip_forward                 = 1net.bridge.bridge-nf-call-ip6tables = 1EOF# 应用配置$ sysctl --system</code></pre><h3 id="配置-kubelet"><a href="#配置-kubelet" class="headerlink" title="配置 kubelet"></a>配置 kubelet</h3><h4 id="修改-kubelet-service"><a href="#修改-kubelet-service" class="headerlink" title="修改 kubelet.service"></a>修改 <code>kubelet.service</code></h4><p><code>/etc/systemd/system/kubelet.service.d/10-proxy-ipvs.conf</code> 写入以下内容</p><pre><code># 启用 ipvs 相关内核模块[Service]ExecStartPre=-/sbin/modprobe ip_vsExecStartPre=-/sbin/modprobe ip_vs_rrExecStartPre=-/sbin/modprobe ip_vs_wrrExecStartPre=-/sbin/modprobe ip_vs_sh</code></pre><p>执行以下命令应用配置。</p><pre><code>$ sudo systemctl daemon-reload</code></pre><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><pre><code>$ sudo kubeadm init --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers \      --pod-network-cidr 10.244.0.0/16 \      --v 5 \      --ignore-preflight-errors=all</code></pre><ul><li><code>--pod-network-cidr 10.244.0.0/16</code> 参数与后续 CNI 插件有关，这里以 <code>flannel</code> 为例，若后续部署其他类型的网络插件请更改此参数。</li></ul><blockquote><p>执行可能出现错误，例如缺少依赖包，根据提示安装即可。</p></blockquote><p>执行成功会输出</p><pre><code>...[addons] Applied essential addon: CoreDNSI1116 12:35:13.270407   86677 request.go:538] Throttling request took 181.409184ms, request: POST:https://192.168.199.100:6443/api/v1/namespaces/kube-system/serviceaccountsI1116 12:35:13.470292   86677 request.go:538] Throttling request took 186.088112ms, request: POST:https://192.168.199.100:6443/api/v1/namespaces/kube-system/configmaps[addons] Applied essential addon: kube-proxyYour Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user:  mkdir -p $HOME/.kube  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config  sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run "kubectl apply -f [podnetwork].yaml" with one of the options listed at:  https://kubernetes.io/docs/concepts/cluster-administration/addons/Then you can join any number of worker nodes by running the following on each as root:kubeadm join 192.168.199.100:6443 --token cz81zt.orsy9gm9v649e5lf \    --discovery-token-ca-cert-hash sha256:5edb316fd0d8ea2792cba15cdf1c899a366f147aa03cba52d4e5c5884ad836fe</code></pre><h4 id="node-工作节点"><a href="#node-工作节点" class="headerlink" title="node 工作节点"></a>node 工作节点</h4><p>在 <strong>另一主机</strong> 重复 <strong>部署</strong> 小节以前的步骤，安装配置好 kubelet。根据提示，加入到集群。</p><pre><code>$ kubeadm join 192.168.199.100:6443 --token cz81zt.orsy9gm9v649e5lf \    --discovery-token-ca-cert-hash sha256:5edb316fd0d8ea2792cba15cdf1c899a366f147aa03cba52d4e5c5884ad836fe</code></pre><h4 id="查看服务-2"><a href="#查看服务-2" class="headerlink" title="查看服务"></a>查看服务</h4><p>所有服务启动后，查看本地实际运行的 Docker 容器。这些服务大概分为三类：主节点服务、工作节点服务和其它服务。</p><h4 id="主节点服务"><a href="#主节点服务" class="headerlink" title="主节点服务"></a>主节点服务</h4><ul><li><p><code>apiserver</code> 是整个系统的对外接口，提供 RESTful 方式供客户端和其它组件调用；</p></li><li><p><code>scheduler</code> 负责对资源进行调度，分配某个 pod 到某个节点上；</p></li><li><p><code>controller-manager</code> 负责管理控制器，包括 endpoint-controller（刷新服务和 pod 的关联信息）和 replication-controller（维护某个 pod 的复制为配置的数值）。</p></li></ul><h4 id="工作节点服务"><a href="#工作节点服务" class="headerlink" title="工作节点服务"></a>工作节点服务</h4><ul><li><code>proxy</code> 为 pod 上的服务提供访问的代理。</li></ul><h4 id="其它服务"><a href="#其它服务" class="headerlink" title="其它服务"></a>其它服务</h4><ul><li>Etcd 是所有状态的存储数据库；</li></ul><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><p>将 <code>/etc/kubernetes/admin.conf</code> 复制到 <code>~/.kube/config</code></p><p>执行 <code>$ kubectl get all -A</code> 查看启动的服务。</p><p>由于未部署 CNI 插件，CoreDNS 未正常启动。如何使用 Kubernetes，请参考后续章节。</p><h3 id="部署-CNI"><a href="#部署-CNI" class="headerlink" title="部署 CNI"></a>部署 CNI</h3><p>这里以 <code>flannel</code> 为例进行介绍。</p><h4 id="flannel"><a href="#flannel" class="headerlink" title="flannel"></a>flannel</h4><p>检查 podCIDR 设置</p><pre><code>$ kubectl get node -o yaml | grep CIDR# 输出    podCIDR: 10.244.0.0/16    podCIDRs:$ kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.11.0/Documentation/kube-flannel.yml</code></pre><h4 id="master-节点默认不能运行-pod"><a href="#master-节点默认不能运行-pod" class="headerlink" title="master 节点默认不能运行 pod"></a>master 节点默认不能运行 pod</h4><p>如果用 <code>kubeadm</code> 部署一个单节点集群，默认情况下无法使用，请执行以下命令解除限制</p><pre><code>$ kubectl taint nodes --all node-role.kubernetes.io/master-# 恢复默认值# $ kubectl taint nodes NODE_NAME node-role.kubernetes.io/master=true:NoSchedule</code></pre><h3 id="参考文档-1"><a href="#参考文档-1" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">官方文档</a></li></ul><h2 id="在-Docker-Desktop-使用"><a href="#在-Docker-Desktop-使用" class="headerlink" title="在 Docker Desktop 使用"></a>在 Docker Desktop 使用</h2><p>使用 Docker Desktop 可以很方便的启用 Kubernetes，由于国内获取不到 <code>k8s.gcr.io</code> 镜像，我们必须首先解决这一问题。</p><h3 id="获取-k8s-gcr-io-镜像"><a href="#获取-k8s-gcr-io-镜像" class="headerlink" title="获取 k8s.gcr.io 镜像"></a>获取 <code>k8s.gcr.io</code> 镜像</h3><p>由于国内拉取不到 <code>k8s.gcr.io</code> 镜像，我们可以使用开源项目 <a href="https://github.com/AliyunContainerService/k8s-for-docker-desktop" target="_blank" rel="noopener">AliyunContainerService/k8s-for-docker-desktop</a> 来获取所需的镜像。</p><h3 id="启用-Kubernetes"><a href="#启用-Kubernetes" class="headerlink" title="启用 Kubernetes"></a>启用 Kubernetes</h3><p>在 Docker Desktop 设置页面，点击 <code>Kubernetes</code>，选择 <code>Enable Kubernetes</code>，稍等片刻，看到左下方 <code>Kubernetes</code> 变为 <code>running</code>，Kubernetes 启动成功。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTA1N2MwYWQ2OTY3ZmZkNDAyNWQ1YzI2ZTQ5ZGIwNjVfMUtqaUE4TVRTUUVhTm5McTdUYkdFdzFzcEN4d2JTT3dfVG9rZW46Ym94Y25PdklSNmFhdUdrb294OGFqU1pLVFpnXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><pre><code>$ kubectl version</code></pre><p>如果正常输出信息，则证明 Kubernetes 成功启动。</p><h2 id="部署-Dashboard"><a href="#部署-Dashboard" class="headerlink" title="部署 Dashboard"></a>部署 Dashboard</h2><p><a href="https://github.com/kubernetes/dashboard" target="_blank" rel="noopener">Kubernetes Dashboard</a> 是基于网页的 Kubernetes 用户界面。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=OGFjODFkNTEzMTNmMDBiNWFmZTFmYTE5NWRkODIxMGVfV255N2RHSWFWNEthQ2lNb2QyY2JlbGJQVFBwbDAwdXJfVG9rZW46Ym94Y25uTlAwUUJ6RkhWcFpiOTBUMW9OUHNiXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><h3 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h3><p>执行以下命令即可部署 Dashboard：</p><pre><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml</code></pre><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>通过命令行代理访问，执行以下命令：</p><pre><code>$ kubectl proxy</code></pre><p>到 <a href="http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/" target="_blank" rel="noopener">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</a> 即可访问。</p><h3 id="登录-1"><a href="#登录-1" class="headerlink" title="登录"></a>登录</h3><p>目前，Dashboard 仅支持使用 Bearer 令牌登录。下面教大家如何创建该令牌：</p><pre><code>$ kubectl create sa dashboard-admin -n kube-system$ kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin$ ADMIN_SECRET=$(kubectl get secrets -n kube-system | grep dashboard-admin | awk '{print $1}')$ DASHBOARD_LOGIN_TOKEN=$(kubectl describe secret -n kube-system ${ADMIN_SECRET} | grep -E '^token' | awk '{print $2}')echo ${DASHBOARD_LOGIN_TOKEN}</code></pre><p>将结果粘贴到登录页面，即可登录。</p><h3 id="参考文档-2"><a href="#参考文档-2" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://kubernetes.io/zh/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="noopener">官方文档</a></li></ul><h1 id="Kubernetes-命令行-kubectl"><a href="#Kubernetes-命令行-kubectl" class="headerlink" title="Kubernetes 命令行 kubectl"></a>Kubernetes 命令行 kubectl</h1><p><a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">kubectl</a> 是 Kubernetes 自带的客户端，可以用它来直接操作 Kubernetes。</p><p>使用格式有两种：</p><pre><code>kubectl [flags]kubectl [command]</code></pre><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>显示一个或多个资源</p><h2 id="describe"><a href="#describe" class="headerlink" title="describe"></a>describe</h2><p>显示资源详情</p><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>从文件或标准输入创建资源</p><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>从文件或标准输入更新资源</p><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>通过文件名、标准输入、资源名或者 label selector 删除资源</p><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>输出 pod 中一个容器的日志</p><h2 id="rolling-update"><a href="#rolling-update" class="headerlink" title="rolling-update"></a>rolling-update</h2><p>对指定的 replication controller 执行滚动升级</p><h2 id="exec-1"><a href="#exec-1" class="headerlink" title="exec"></a>exec</h2><p>在容器内部执行命令</p><h2 id="port-forward"><a href="#port-forward" class="headerlink" title="port-forward"></a>port-forward</h2><p>将本地端口转发到Pod</p><h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><p>为 Kubernetes API server 启动代理服务器</p><h2 id="run-1"><a href="#run-1" class="headerlink" title="run"></a>run</h2><p>在集群中使用指定镜像启动容器</p><h2 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h2><p>将 replication controller service 或 pod 暴露为新的 kubernetes service</p><h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><p>更新资源的 label</p><h2 id="config-1"><a href="#config-1" class="headerlink" title="config"></a>config</h2><p>修改 kubernetes 配置文件</p><h2 id="cluster-info"><a href="#cluster-info" class="headerlink" title="cluster-info"></a>cluster-info</h2><p>显示集群信息</p><h2 id="api-versions"><a href="#api-versions" class="headerlink" title="api-versions"></a>api-versions</h2><p>以 “组/版本” 的格式输出服务端支持的 API 版本</p><h2 id="version-1"><a href="#version-1" class="headerlink" title="version"></a>version</h2><p>输出服务端和客户端的版本信息</p><h2 id="help-1"><a href="#help-1" class="headerlink" title="help"></a>help</h2><p>显示各个命令的帮助信息</p><h1 id="容器与云计算"><a href="#容器与云计算" class="headerlink" title="容器与云计算"></a>容器与云计算</h1><p>Docker 目前已经得到了众多公有云平台的支持，并成为除虚拟机之外的核心云业务。</p><p>除了 AWS、Google、Azure 等，国内的各大公有云厂商，基本上都同时支持了虚拟机服务和基于 Kubernetes 的容器云业务。有的还推出了其他服务，例如 <a href="https://cloud.tencent.com/act/cps/redirect?redirect=11588&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61" target="_blank" rel="noopener">容器镜像服务</a> 让用户在云上享有安全高效的镜像托管、分发等服务。</p><p>目前与容器相关的云计算主要分为两种类型。</p><p>一种是传统的 IaaS 服务商提供对容器相关的服务，包括镜像下载、容器托管等。</p><p>另一种是直接基于容器技术对外提供容器云服务，所谓 Container as a Service（CaaS）。</p><h2 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h2><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTY4YWEyOTY4NWUxOGIwZmEwOGIwMTQ1ZGI3OWJiN2NfNTVxWXZQbWJzb09jT205SmlhWjE0b0lWRWhwT2RDZ21fVG9rZW46Ym94Y25Ua1A2NXdFc2F4WTZVcWVLUUpQYU5nXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>腾讯云</p><p><a href="https://cloud.tencent.com/act/cps/redirect?redirect=1040&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61&amp;from=console" target="_blank" rel="noopener">腾讯云</a> 在架构方面经过多年积累，并且有着多年对海量互联网服务的经验。不管是社交、游戏还是其他领域，都有多年的成熟产品来提供产品服务。腾讯在云端完成重要部署，为开发者及企业提供云服务、云数据、云运营等整体一站式服务方案。</p><p>具体包括 <a href="https://cloud.tencent.com/act/cps/redirect?redirect=1001&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61&amp;from=console" target="_blank" rel="noopener">云服务器</a>、<a href="https://cloud.tencent.com/act/cps/redirect?redirect=1020&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61&amp;from=console" target="_blank" rel="noopener">云存储</a>、<a href="https://cloud.tencent.com/act/cps/redirect?redirect=1003&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61&amp;from=console" target="_blank" rel="noopener">云数据库</a>、<a href="https://cloud.tencent.com/act/cps/redirect?redirect=1019&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61&amp;from=console" target="_blank" rel="noopener">视频与CDN</a> 和 <a href="https://dnspod.cloud.tencent.com/" target="_blank" rel="noopener">域名注册</a> 等基础云服务；腾讯云分析（MTA）、腾讯云推送（信鸽）等腾讯整体大数据能力；以及 QQ互联、QQ 空间、微云、微社区等云端链接社交体系。这些正是腾讯云可以提供给这个行业的差异化优势，造就了可支持各种互联网使用场景的高品质的腾讯云技术平台。</p><p><a href="https://cloud.tencent.com/act/cps/redirect?redirect=10058&amp;cps_key=3a5255852d5db99dcd5da4c72f05df61" target="_blank" rel="noopener">腾讯云容器服务 TKE</a> 是高度可扩展的高性能容器管理服务，用户可以在托管的云服务器实例集群上轻松运行应用程序。使用该服务，将无需安装、运维、扩展用户的集群管理基础设施，只需进行简单的 API 调用，便可启动和停止 Docker 应用程序，查询集群的完整状态，以及使用各种云服务。用户可以根据用户的资源需求和可用性要求在用户的集群中安排容器的置放，满足业务或应用程序的特定要求。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjRjOGY1MmQ0NmZmNDY3ZDA2NThhMzUyNzU4NjFkYzNfNTNnQlVnTmdGOTlWWjhVelVaYU5kU1hFdlhtdVF2bDFfVG9rZW46Ym94Y240YjcwdzZlM3BwakttU1hpa3B6dW45XzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzk1YTZlMDNiMjFlYjY5ZjViMDZlNWM0MmQwYjRhMDJfZGZkR0R0TG9vQkJMZjBEQ1RKU3FsRThia0N6ZWZsYUNfVG9rZW46Ym94Y25UR3duTGdEOUVFOFFySjhucnlFVEZkXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>阿里云</p><p><a href="https://www.aliyun.com/?source=5176.11533457&amp;userCode=8lx5zmtu&amp;type=copy" target="_blank" rel="noopener">阿里云</a> 创立于 2009 年，是中国较早的云计算平台。阿里云致力于提供安全、可靠的计算和数据处理能力。</p><p><a href="https://www.aliyun.com/?source=5176.11533457&amp;userCode=8lx5zmtu&amp;type=copy" target="_blank" rel="noopener">阿里云</a> 的客户群体中，活跃着微博、虎牙、魅族、优酷等一大批明星互联网公司。在天猫双 11 全球狂欢节等极富挑战的应用场景中，阿里云保持着良好的运行纪录。</p><p><a href="https://www.aliyun.com/product/kubernetes?source=5176.11533457&amp;userCode=8lx5zmtu&amp;type=copy" target="_blank" rel="noopener">阿里云容器服务 Kubernetes 版 ACK</a> 提供了高性能、可伸缩的容器应用管理服务，支持在一组云服务器上通过 Docker 容器来进行应用生命周期管理。容器服务极大简化了用户对容器管理集群的搭建工作，无缝整合了阿里云虚拟化、存储、网络和安全能力。容器服务提供了多种应用发布方式和流水线般的持续交付能力，原生支持微服务架构，助力用户无缝上云和跨云管理。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjMxOTkwZDk3NmEyNTRhNzhmM2RlZmQwODQ5NzIyYzFfcjRRaHFuaVBSeWxWa3gxTmFMU1NjRml1Ylk0czhGb3JfVG9rZW46Ym94Y25pTGVzMVdTQkQybmIzV2E2VzRsMjVjXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><h2 id="亚马逊云"><a href="#亚马逊云" class="headerlink" title="亚马逊云"></a>亚马逊云</h2><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQxODBhZDIzYWYzOGJkN2YxMGI5YmI2NzlhMjdiYzFfdHl5b2xyVW5YWTdNRmNCWlFPMEp0SUN6SERnc1pLbDNfVG9rZW46Ym94Y25kT3pwQnZvZm9Jejc5NHJMb09BNHFiXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p><a href="https://www.amazonaws.cn/" target="_blank" rel="noopener">AWS</a>，即 Amazon Web Services，是亚马逊（Amazon）公司的 IaaS 和 PaaS 平台服务。AWS 提供了一整套基础设施和应用程序服务，使用户几乎能够在云中运行一切应用程序：从企业应用程序和大数据项目，到社交游戏和移动应用程序。AWS 面向用户提供包括弹性计算、存储、数据库、应用程序在内的一整套云计算服务，能够帮助企业降低 IT 投入成本和维护成本。</p><p>自 2006 年初起，亚马逊 AWS 开始在云中为各种规模的公司提供技术服务平台。利用亚马逊 AWS，软件开发人员可以轻松购买计算、存储、数据库和其他基于 Internet 的服务来支持其应用程序。开发人员能够灵活选择任何开发平台或编程环境，以便于其尝试解决问题。由于开发人员只需按使用量付费，无需前期资本支出，亚马逊 AWS 是向最终用户交付计算资源、保存的数据和其他应用程序的一种经济划算的方式。</p><p>2015 年 AWS 正式发布了 EC2 容器服务(ECS)。ECS 的目的是让 Docker 容器变的更加简单，它提供了一个集群和编排的层，用来控制主机上的容器部署，以及部署之后的集群内的容器的生命周期管理。ECS 是诸如 Docker Swarm、Kubernetes、Mesos 等工具的替代，它们工作在同一个层，除了作为一个服务来提供。这些工具和 ECS 不同的地方在于，前者需要用户自己来部署和管理，而 ECS 是“作为服务”来提供的。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MjA3YjVjNDlkYzRjMWFmZmYyMDY2ZTQ3ZTNiNTNhZTBfSGJ6QjZzQkRYSHFmZXJsT3VBVjZ5a29lMXdaT1FvWUlfVG9rZW46Ym94Y25KNVRzRXBCenp4c09jTkhCV3RCaWFkXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本章介绍了公有云服务对 Docker 的积极支持，以及新出现的容器云平台。</p><p>事实上，Docker 技术的出现自身就极大推动了云计算行业的发展。</p><p>通过整合公有云的虚拟机和 Docker 方式，可能获得更多的好处，包括</p><ul><li><p>更快速的持续交付和部署能力；</p></li><li><p>利用内核级虚拟化，对公有云中服务器资源进行更加高效地利用；</p></li><li><p>利用公有云和 Docker 的特性更加方便的迁移和扩展应用。</p></li></ul><p>同时，容器将作为与虚拟机类似的业务直接提供给用户使用，极大的丰富了应用开发和部署的场景。</p><h1 id="实战案例-操作系统"><a href="#实战案例-操作系统" class="headerlink" title="实战案例 - 操作系统"></a>实战案例 - 操作系统</h1><p>目前常用的 Linux 发行版主要包括 <code>Debian/Ubuntu</code> 系列和 <code>CentOS/Fedora</code> 系列。</p><p>前者以自带软件包版本较新而出名；后者则宣称运行更稳定一些。选择哪个操作系统取决于读者的具体需求。</p><p>使用 Docker，读者只需要一个命令就能快速获取一个 Linux 发行版镜像，这是以往包括各种虚拟化技术都难以实现的。这些镜像一般都很精简，但是可以支持完整 Linux 系统的大部分功能。</p><p>本章将介绍如何使用 Docker 安装和使用 <code>Busybox</code>、<code>Alphine</code>、<code>Debian/Ubuntu</code>、<code>CentOS/Fedora</code> 等操作系统。</p><h2 id="Busybox"><a href="#Busybox" class="headerlink" title="Busybox"></a>Busybox</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWE0MTE4ZWIxYzI0ZTc2MDdlZTY5ZDU3NGRkN2U4ZTVfM0lHOWFubFFrTFlDQnhuTVhDVVBaTFFIY2taNG5zZ1JfVG9rZW46Ym94Y24xQmQySzRmeURMMEt5NUpROTNZTVpVXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>Busybox - Linux 瑞士军刀</p><p><code>BusyBox</code> 是一个集成了一百多个最常用 Linux 命令和工具（如 <code>cat</code>、<code>echo</code>、<code>grep</code>、<code>mount</code>、<code>telnet</code> 等）的精简工具箱，它只需要几 MB 的大小，很方便进行各种快速验证，被誉为“Linux 系统的瑞士军刀”。</p><p><code>BusyBox</code> 可运行于多款 <code>POSIX</code> 环境的操作系统中，如 <code>Linux</code>（包括 <code>Android</code>）、<code>Hurd</code>、<code>FreeBSD</code> 等。</p><h3 id="获取官方镜像"><a href="#获取官方镜像" class="headerlink" title="获取官方镜像"></a>获取官方镜像</h3><p>在 <code>Docker Hub</code> 中搜索 <code>busybox</code> 相关的镜像。</p><pre><code>$ docker search busyboxNAME                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDbusybox                         Busybox base image.                             755       [OK]progrium/busybox                                                                63                   [OK]radial/busyboxplus              Full-chain, Internet enabled, busybox made...   11                   [OK]odise/busybox-python                                                            3                    [OK]multiarch/busybox               multiarch ports of ubuntu-debootstrap           2                    [OK]azukiapp/busybox                This image is meant to be used as the base...   2                    [OK]...</code></pre><p>读者可以看到最受欢迎的镜像同时带有 <code>OFFICIAL</code> 标记，说明它是官方镜像。用户使用 <code>docker pull</code> 指令下载 <code>busybox:latest</code> 镜像：</p><pre><code>$ docker pull busybox:latestlatest: Pulling from library/busybox5c4213be9af9: Pull completeDigest: sha256:c6b45a95f932202dbb27c31333c4789f45184a744060f6e569cc9d2bf1b9ad6fStatus: Downloaded newer image for busybox:latestdocker.io/library/busybox:latest</code></pre><p>下载后，可以看到 <code>busybox</code> 镜像只有 <strong>2.433 MB</strong>：</p><pre><code>$ docker image lsREPOSITORY                   TAG                 IMAGE ID            CREATED             VIRTUAL SIZEbusybox                   latest              e72ac664f4f0        6 weeks ago         2.433 MB</code></pre><h3 id="运行-busybox"><a href="#运行-busybox" class="headerlink" title="运行 busybox"></a>运行 busybox</h3><p>启动一个 <code>busybox</code> 容器，并在容器中执行 <code>grep</code> 命令。</p><pre><code>$ docker run -it busybox/ # grepBusyBox v1.22.1 (2014-05-22 23:22:11 UTC) multi-call binary.Usage: grep [-HhnlLoqvsriwFE] [-m N] [-A/B/C N] PATTERN/-e PATTERN.../-f FILE [FILE]...Search for PATTERN in FILEs (or stdin)        -H      Add 'filename:' prefix        -h      Do not add 'filename:' prefix        -n      Add 'line_no:' prefix        -l      Show only names of files that match        -L      Show only names of files that don't match        -c      Show only count of matching lines        -o      Show only the matching part of line        -q      Quiet. Return 0 if PATTERN is found, 1 otherwise        -v      Select non-matching lines        -s      Suppress open and read errors        -r      Recurse        -i      Ignore case        -w      Match whole words only        -x      Match whole lines only        -F      PATTERN is a literal (not regexp)        -E      PATTERN is an extended regexp        -m N    Match up to N times per file        -A N    Print N lines of trailing context        -B N    Print N lines of leading context        -C N    Same as '-A N -B N'        -e PTRN Pattern to match        -f FILE Read pattern from file</code></pre><p>查看容器内的挂载信息。</p><pre><code>/ # mountoverlay on / type overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/BOTCI5RF24AMC4A2UWF4N6ZWFP:/var/lib/docker/overlay2/l/TWVP5T5DMKJGXZOROR7CAPWGFP,upperdir=/var/lib/docker/overlay2/801ef0bf6cce35288dbb8fe00a4f9cc47760444693bfdf339ed0bdcf926e12a3/diff,workdir=/var/lib/docker/overlay2/801ef0bf6cce35288dbb8fe00a4f9cc47760444693bfdf339ed0bdcf926e12a3/work)proc on /proc type proc (rw,nosuid,nodev,noexec,relatime)tmpfs on /dev type tmpfs (rw,nosuid,size=65536k,mode=755)devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=666)sysfs on /sys type sysfs (ro,nosuid,nodev,noexec,relatime)tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,relatime,mode=755)cgroup on /sys/fs/cgroup/systemd type cgroup (ro,nosuid,nodev,noexec,relatime,xattr,release_agent=/lib/systemd/systemd-cgroups-agent,name=systemd)cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (ro,nosuid,nodev,noexec,relatime,net_cls,net_prio)cgroup on /sys/fs/cgroup/freezer type cgroup (ro,nosuid,nodev,noexec,relatime,freezer)cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (ro,nosuid,nodev,noexec,relatime,cpu,cpuacct)cgroup on /sys/fs/cgroup/cpuset type cgroup (ro,nosuid,nodev,noexec,relatime,cpuset)cgroup on /sys/fs/cgroup/blkio type cgroup (ro,nosuid,nodev,noexec,relatime,blkio)cgroup on /sys/fs/cgroup/perf_event type cgroup (ro,nosuid,nodev,noexec,relatime,perf_event)cgroup on /sys/fs/cgroup/memory type cgroup (ro,nosuid,nodev,noexec,relatime,memory)cgroup on /sys/fs/cgroup/devices type cgroup (ro,nosuid,nodev,noexec,relatime,devices)cgroup on /sys/fs/cgroup/pids type cgroup (ro,nosuid,nodev,noexec,relatime,pids)mqueue on /dev/mqueue type mqueue (rw,nosuid,nodev,noexec,relatime)shm on /dev/shm type tmpfs (rw,nosuid,nodev,noexec,relatime,size=65536k)/dev/vda1 on /etc/resolv.conf type ext3 (rw,noatime,data=ordered)/dev/vda1 on /etc/hostname type ext3 (rw,noatime,data=ordered)/dev/vda1 on /etc/hosts type ext3 (rw,noatime,data=ordered)devpts on /dev/console type devpts (rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=666)proc on /proc/bus type proc (ro,relatime)proc on /proc/fs type proc (ro,relatime)proc on /proc/irq type proc (ro,relatime)proc on /proc/sys type proc (ro,relatime)proc on /proc/sysrq-trigger type proc (ro,relatime)tmpfs on /proc/acpi type tmpfs (ro,relatime)tmpfs on /proc/kcore type tmpfs (rw,nosuid,size=65536k,mode=755)tmpfs on /proc/keys type tmpfs (rw,nosuid,size=65536k,mode=755)tmpfs on /proc/timer_list type tmpfs (rw,nosuid,size=65536k,mode=755)tmpfs on /proc/sched_debug type tmpfs (rw,nosuid,size=65536k,mode=755)tmpfs on /sys/firmware type tmpfs (ro,relatime)</code></pre><p><code>busybox</code> 镜像虽然小巧，但包括了大量常见的 <code>Linux</code> 命令，读者可以用它快速熟悉 <code>Linux</code> 命令。</p><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li><p><code>Busybox</code> 官网：<a href="https://busybox.net/" target="_blank" rel="noopener">https://busybox.net/</a></p></li><li><p><code>Busybox</code> 官方仓库：<a href="https://git.busybox.net/busybox/" target="_blank" rel="noopener">https://git.busybox.net/busybox/</a></p></li><li><p><code>Busybox</code> 官方镜像：<a href="https://hub.docker.com/_/busybox/" target="_blank" rel="noopener">https://hub.docker.com/_/busybox/</a></p></li><li><p><code>Busybox</code> 官方仓库：<a href="https://github.com/docker-library/busybox" target="_blank" rel="noopener">https://github.com/docker-library/busybox</a></p></li></ul><h2 id="Alpine"><a href="#Alpine" class="headerlink" title="Alpine"></a>Alpine</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Alpine Linux 操作系统</p><p><code>Alpine</code> 操作系统是一个面向安全的轻型 <code>Linux</code> 发行版。它不同于通常 <code>Linux</code> 发行版，<code>Alpine</code> 采用了 <code>musl libc</code> 和 <code>busybox</code> 以减小系统的体积和运行时资源消耗，但功能上比 <code>busybox</code> 又完善的多，因此得到开源社区越来越多的青睐。在保持瘦身的同时，<code>Alpine</code> 还提供了自己的包管理工具 <code>apk</code>，可以通过 <code>https://pkgs.alpinelinux.org/packages</code> 网站上查询包信息，也可以直接通过 <code>apk</code> 命令直接查询和安装各种软件。</p><p><code>Alpine</code> 由非商业组织维护的，支持广泛场景的 <code>Linux</code>发行版，它特别为资深/重度<code>Linux</code>用户而优化，关注安全，性能和资源效能。<code>Alpine</code> 镜像可以适用于更多常用场景，并且是一个优秀的可以适用于生产的基础系统/环境。</p><p><code>Alpine</code> Docker 镜像也继承了 <code>Alpine Linux</code> 发行版的这些优势。相比于其他 <code>Docker</code> 镜像，它的容量非常小，仅仅只有 <strong>5 MB</strong> 左右（对比 <code>Ubuntu</code> 系列镜像接近 <code>200 MB</code>），且拥有非常友好的包管理机制。官方镜像来自 <code>docker-alpine</code> 项目。</p><p>目前 Docker 官方已开始推荐使用 <code>Alpine</code> 替代之前的 <code>Ubuntu</code> 做为基础镜像环境。这样会带来多个好处。包括镜像下载速度加快，镜像安全性提高，主机之间的切换更方便，占用更少磁盘空间等。</p><p>下表是官方镜像的大小比较：</p><pre><code>REPOSITORY          TAG           IMAGE ID          VIRTUAL SIZEalpine              latest        4e38e38c8ce0      4.799 MBdebian              latest        4d6ce913b130      84.98 MBubuntu              latest        b39b81afc8ca      188.3 MBcentos              latest        8efe422e6104      210 MB</code></pre><h3 id="获取并使用官方镜像"><a href="#获取并使用官方镜像" class="headerlink" title="获取并使用官方镜像"></a>获取并使用官方镜像</h3><p>由于镜像很小，下载时间往往很短，读者可以直接使用 <code>docker run</code> 指令直接运行一个 <code>Alpine</code> 容器，并指定运行的 Linux 指令，例如：</p><pre><code>$ docker run alpine echo '123'123</code></pre><h3 id="迁移至-Alpine-基础镜像"><a href="#迁移至-Alpine-基础镜像" class="headerlink" title="迁移至 Alpine 基础镜像"></a>迁移至 <code>Alpine</code> 基础镜像</h3><p>目前，大部分 Docker 官方镜像都已经支持 <code>Alpine</code> 作为基础镜像，可以很容易进行迁移。</p><p>例如：</p><ul><li><p><code>ubuntu/debian</code> -&gt; <code>alpine</code></p></li><li><p><code>python:3</code> -&gt; <code>python:3-alpine</code></p></li><li><p><code>ruby:2.6</code> -&gt; <code>ruby:2.6-alpine</code></p></li></ul><p>另外，如果使用 <code>Alpine</code> 镜像替换 <code>Ubuntu</code> 基础镜像，安装软件包时需要用 <code>apk</code> 包管理器替换 <code>apt</code> 工具，如</p><pre><code>$ apk add --no-cache &lt;package&gt;</code></pre><p><code>Alpine</code> 中软件安装包的名字可能会与其他发行版有所不同，可以在 <code>https://pkgs.alpinelinux.org/packages</code> 网站搜索并确定安装包名称。如果需要的安装包不在主索引内，但是在测试或社区索引中。那么可以按照以下方法使用这些安装包。</p><pre><code>$ echo "http://dl-cdn.alpinelinux.org/alpine/edge/testing" &gt;&gt; /etc/apk/repositories$ apk --update add --no-cache &lt;package&gt;</code></pre><p>由于在国内访问 <code>apk</code> 仓库较缓慢，建议在使用 <code>apk</code> 之前先替换仓库地址为国内镜像。</p><pre><code>RUN sed -i "s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g" /etc/apk/repositories \      &amp;&amp; apk add --no-cache &lt;package&gt;</code></pre><h3 id="相关资源-1"><a href="#相关资源-1" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li><p><code>Alpine</code> 官网：<a href="https://www.alpinelinux.org/" target="_blank" rel="noopener">https://www.alpinelinux.org/</a></p></li><li><p><code>Alpine</code> 官方仓库：<a href="https://github.com/alpinelinux" target="_blank" rel="noopener">https://github.com/alpinelinux</a></p></li><li><p><code>Alpine</code> 官方镜像：<a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener">https://hub.docker.com/_/alpine/</a></p></li><li><p><code>Alpine</code> 官方镜像仓库：<a href="https://github.com/gliderlabs/docker-alpine" target="_blank" rel="noopener">https://github.com/gliderlabs/docker-alpine</a></p></li></ul><h2 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian Ubuntu"></a>Debian Ubuntu</h2><p><code>Debian</code> 和 <code>Ubuntu</code> 都是目前较为流行的 <strong>Debian 系</strong> 的服务器操作系统，十分适合研发场景。<code>Docker Hub</code> 上提供了官方镜像，国内各大容器云服务也基本都提供了相应的支持。</p><h3 id="Debian-系统简介"><a href="#Debian-系统简介" class="headerlink" title="Debian 系统简介"></a>Debian 系统简介</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDI2MGEyMmIzZjViYmM0MmQwNTBiYTZjNzQ4MWEyNjlfTTNGZXpjdUNhbFA4ampmeldpMDdScGFQcG5TNTVyV2tfVG9rZW46Ym94Y25QVG8xbDg3RFJPcklyek1Gbmp3SGVlXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p><code>Debian</code> 是由 <code>GPL</code> 和其他自由软件许可协议授权的自由软件组成的操作系统，由 <strong>Debian 计划（Debian Project）</strong> 组织维护。<strong>Debian 计划</strong> 是一个独立的、分散的组织，由 <code>3000</code> 人志愿者组成，接受世界多个非盈利组织的资金支持，<code>Software in the Public Interest</code> 提供支持并持有商标作为保护机构。<code>Debian</code> 以其坚守 <code>Unix</code> 和自由软件的精神，以及其给予用户的众多选择而闻名。现时 <code>Debian</code> 包括了超过 <code>25,000</code> 个软件包并支持 <code>12</code> 个计算机系统结构。</p><p><code>Debian</code> 作为一个大的系统组织框架，其下有多种不同操作系统核心的分支计划，主要为采用 <code>Linux</code> 核心的 <code>Debian GNU/Linux</code> 系统，其他还有采用 <code>GNU Hurd</code> 核心的 <code>Debian GNU/Hurd</code> 系统、采用 <code>FreeBSD</code> 核心的 <code>Debian GNU/kFreeBSD</code> 系统，以及采用 <code>NetBSD</code> 核心的 <code>Debian GNU/NetBSD</code> 系统。甚至还有利用 <code>Debian</code> 的系统架构和工具，采用 <code>OpenSolaris</code> 核心构建而成的 <code>Nexenta OS</code> 系统。在这些 <code>Debian</code> 系统中，以采用 <code>Linux</code> 核心的 <code>Debian GNU/Linux</code> 最为著名。</p><p>众多的 <code>Linux</code> 发行版，例如 <code>Ubuntu</code>、<code>Knoppix</code> 和 <code>Linspire</code> 及 <code>Xandros</code> 等，都基于 <code>Debian GNU/Linux</code>。</p><h3 id="使用-Debian-官方镜像"><a href="#使用-Debian-官方镜像" class="headerlink" title="使用 Debian 官方镜像"></a>使用 Debian 官方镜像</h3><p>读者可以使用 <code>docker search</code> 查找 <code>Debian</code> 镜像：</p><pre><code>$ docker search debianNAME         DESCRIPTION    STARS     OFFICIAL   AUTOMATEDdebian       Debian is...   1565      [OK]neurodebian  NeuroDebian...   26      [OK]armbuild/debian port of debian 8                 [OK]...</code></pre><p>官方提供了大家熟知的 <code>debian</code> 镜像以及面向科研领域的 <code>neurodebian</code> 镜像。</p><p>可以使用 <code>docker run</code> 直接运行 <code>Debian</code> 镜像。</p><pre><code>$ docker run -it debian bashroot@668e178d8d69:/# cat /etc/issueDebian GNU/Linux 8</code></pre><p><code>Debian</code> 镜像很适合作为基础镜像，构建自定义镜像。</p><h3 id="Ubuntu-系统简介"><a href="#Ubuntu-系统简介" class="headerlink" title="Ubuntu 系统简介"></a>Ubuntu 系统简介</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmU5N2JiOTQ4Y2MwYjYyMzU4MjVmNzU2MWFlOGEzZTZfUmtIUWJjTUQ4OE5MTEZjeFhENFJFbWVJUE50TlpYRzdfVG9rZW46Ym94Y25oYWdyWHN6VGpTdUpyaGY0R2Jma1lnXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p><code>Ubuntu</code> 是一个以桌面应用为主的 <code>GNU/Linux</code> 操作系统，其名称来自非洲南部祖鲁语或豪萨语的“ubuntu”一词（官方译名“友帮拓”，另有“吾帮托”、“乌班图”、“有奔头”或“乌斑兔”等译名）。<code>Ubuntu</code> 意思是“人性”以及“我的存在是因为大家的存在”，是非洲传统的一种价值观，类似华人社会的“仁爱”思想。 <code>Ubuntu</code> 基于 <code>Debian</code> 发行版和 <code>GNOME/Unity</code> 桌面环境，与 <code>Debian</code> 的不同在于它每 6 个月会发布一个新版本，每 2 年推出一个长期支持 <strong>（Long Term Support，LTS）</strong> 版本，一般支持 3 年时间。</p><h3 id="使用-Ubuntu-官方镜像"><a href="#使用-Ubuntu-官方镜像" class="headerlink" title="使用 Ubuntu 官方镜像"></a>使用 Ubuntu 官方镜像</h3><p><code>Ubuntu</code> 相关的镜像有很多，这里使用 <code>--filter=stars=10</code> 参数，只搜索那些被收藏 <code>10</code> 次以上的镜像。</p><pre><code>$ docker search --filter=stars=10 ubuntuNAME                                                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDubuntu                                                    Ubuntu is a Debian-based Linux operating sys…   10539               [OK]dorowu/ubuntu-desktop-lxde-vnc                            Docker image to provide HTML5 VNC interface …   395                                     [OK]rastasheep/ubuntu-sshd                                    Dockerized SSH service, built on top of offi…   243                                     [OK]consol/ubuntu-xfce-vnc                                    Ubuntu container with "headless" VNC session…   210                                     [OK]ubuntu-upstart                                            Upstart is an event-based replacement for th…   105                 [OK]ansible/ubuntu14.04-ansible                               Ubuntu 14.04 LTS with ansible                   98                                      [OK]neurodebian                                               NeuroDebian provides neuroscience research s…   64                  [OK]1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5      ubuntu-16-nginx-php-phpmyadmin-mysql-5          50                                      [OK]ubuntu-debootstrap                                        debootstrap --variant=minbase --components=m…   42                  [OK]nuagebec/ubuntu                                           Simple always updated Ubuntu docker images w…   24                                      [OK]i386/ubuntu                                               Ubuntu is a Debian-based Linux operating sys…   191and1internet/ubuntu-16-apache-php-5.6                    ubuntu-16-apache-php-5.6                        14                                      [OK]1and1internet/ubuntu-16-apache-php-7.0                    ubuntu-16-apache-php-7.0                        13                                      [OK]eclipse/ubuntu_jdk8                                       Ubuntu, JDK8, Maven 3, git, curl, nmap, mc, …   12                                      [OK]1and1internet/ubuntu-16-nginx-php-phpmyadmin-mariadb-10   ubuntu-16-nginx-php-phpmyadmin-mariadb-10       11                                      [OK]</code></pre><p>根据搜索出来的结果，读者可以自行选择下载镜像并使用。</p><p>下面以 <code>ubuntu:18.04</code> 为例，演示如何使用该镜像安装一些常用软件。</p><p>首先使用 <code>-ti</code> 参数启动容器，登录 <code>bash</code>，查看 <code>ubuntu</code> 的发行版本号。</p><pre><code>$ docker run -ti ubuntu:18.04 /bin/bashroot@7d93de07bf76:/# cat /etc/os-releaseNAME="Ubuntu"VERSION="18.04.1 LTS (Bionic Beaver)"ID=ubuntuID_LIKE=debianPRETTY_NAME="Ubuntu 18.04.1 LTS"VERSION_ID="18.04"HOME_URL="https://www.ubuntu.com/"SUPPORT_URL="https://help.ubuntu.com/"BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"VERSION_CODENAME=bionicUBUNTU_CODENAME=bionic</code></pre><p>当试图直接使用 <code>apt-get</code> 安装一个软件的时候，会提示 <code>E: Unable to locate package</code>。</p><pre><code>root@7d93de07bf76:/# apt-get install curlReading package lists... DoneBuilding dependency treeReading state information... DoneE: Unable to locate package curl</code></pre><p>这并非系统不支持 <code>apt-get</code> 命令。Docker 镜像在制作时为了精简清除了 <code>apt</code> 仓库信息，因此需要先执行 <code>apt-get update</code> 命令来更新仓库信息。更新信息后即可成功通过 <code>apt-get</code> 命令来安装软件。</p><pre><code>root@7d93de07bf76:/# apt-get updateGet:1 http://archive.ubuntu.com/ubuntu bionic InRelease [242 kB]Get:2 http://security.ubuntu.com/ubuntu bionic-security InRelease [88.7 kB]Get:3 http://security.ubuntu.com/ubuntu bionic-security/multiverse amd64 Packages [7348 B]Get:4 http://security.ubuntu.com/ubuntu bionic-security/universe amd64 Packages [823 kB]Get:5 http://archive.ubuntu.com/ubuntu bionic-updates InRelease [88.7 kB]Get:6 http://archive.ubuntu.com/ubuntu bionic-backports InRelease [74.6 kB]Get:7 http://archive.ubuntu.com/ubuntu bionic/universe amd64 Packages [11.3 MB]Get:8 http://security.ubuntu.com/ubuntu bionic-security/restricted amd64 Packages [31.0 kB]Get:9 http://security.ubuntu.com/ubuntu bionic-security/main amd64 Packages [835 kB]Get:10 http://archive.ubuntu.com/ubuntu bionic/restricted amd64 Packages [13.5 kB]Get:11 http://archive.ubuntu.com/ubuntu bionic/main amd64 Packages [1344 kB]Get:12 http://archive.ubuntu.com/ubuntu bionic/multiverse amd64 Packages [186 kB]Get:13 http://archive.ubuntu.com/ubuntu bionic-updates/main amd64 Packages [1127 kB]Get:14 http://archive.ubuntu.com/ubuntu bionic-updates/universe amd64 Packages [1350 kB]Get:15 http://archive.ubuntu.com/ubuntu bionic-updates/multiverse amd64 Packages [11.4 kB]Get:16 http://archive.ubuntu.com/ubuntu bionic-updates/restricted amd64 Packages [44.7 kB]Get:17 http://archive.ubuntu.com/ubuntu bionic-backports/main amd64 Packages [2496 B]Get:18 http://archive.ubuntu.com/ubuntu bionic-backports/universe amd64 Packages [4252 B]Fetched 17.6 MB in 1min 25s (207 kB/s)Reading package lists... Done</code></pre><p>首先，安装 <code>curl</code> 工具。</p><pre><code>root@7d93de07bf76:/# apt-get install curlReading package lists... DoneBuilding dependency treeReading state information... DoneThe following additional packages will be installed:  ca-certificates krb5-locales libasn1-8-heimdal libcurl4 libgssapi-krb5-2 libgssapi3-heimdal libhcrypto4-heimdal libheimbase1-heimdal libheimntlm0-heimdal libhx509-5-heimdal  libk5crypto3 libkeyutils1 libkrb5-26-heimdal libkrb5-3 libkrb5support0 libldap-2.4-2 libldap-common libnghttp2-14 libpsl5 libroken18-heimdal librtmp1 libsasl2-2 libsasl2-modules libsasl2-modules-db libsqlite3-0 libssl1.1 libwind0-heimdal openssl publicsuffix...root@7d93de07bf76:/# curlcurl: try 'curl --help' or 'curl --manual' for more information</code></pre><p>接下来，再安装 <code>apache</code> 服务。</p><pre><code>root@7d93de07bf76:/# apt-get install -y apache2Reading package lists... DoneBuilding dependency treeReading state information... DoneThe following additional packages will be installed:  apache2-bin apache2-data apache2-utils file libapr1 libaprutil1 libaprutil1-dbd-sqlite3 libaprutil1-ldap libexpat1 libgdbm-compat4 libgdbm5 libicu60 liblua5.2-0 libmagic-mgc libmagic1 libperl5.26 libxml2 mime-support netbase perl perl-modules-5.26 ssl-cert xz-utils...</code></pre><p>启动这个 <code>apache</code> 服务，然后使用 <code>curl</code> 来测试本地访问。</p><pre><code>root@7d93de07bf76:/# service apache2 start * Starting web server apache2                                                                                                                               AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this message *root@7d93de07bf76:/# curl 127.0.0.1&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;  &lt;!--    Modified from the Debian original for Ubuntu    Last updated: 2016-11-16    See: https://launchpad.net/bugs/1288690  --&gt;  &lt;head&gt;    &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;    &lt;title&gt;Apache2 Ubuntu Default Page: It works&lt;/title&gt;    &lt;style type="text/css" media="screen"&gt;...</code></pre><p>配合使用 <code>-p</code> 参数对外映射服务端口，可以允许容器外来访问该服务。</p><h3 id="相关资源-2"><a href="#相关资源-2" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li><p><code>Debian</code> 官网：<a href="https://www.debian.org/" target="_blank" rel="noopener">https://www.debian.org/</a></p></li><li><p><code>Neuro Debian</code> 官网：<a href="http://neuro.debian.net/" target="_blank" rel="noopener">http://neuro.debian.net/</a></p></li><li><p><code>Debian</code> 官方仓库：<a href="https://github.com/Debian" target="_blank" rel="noopener">https://github.com/Debian</a></p></li><li><p><code>Debian</code> 官方镜像：<a href="https://hub.docker.com/_/debian/" target="_blank" rel="noopener">https://hub.docker.com/_/debian/</a></p></li><li><p><code>Debian</code> 官方镜像仓库：<a href="https://github.com/tianon/docker-brew-debian/" target="_blank" rel="noopener">https://github.com/tianon/docker-brew-debian/</a></p></li><li><p><code>Ubuntu</code> 官网：<a href="https://ubuntu.com/" target="_blank" rel="noopener">https://ubuntu.com</a></p></li><li><p><code>Ubuntu</code> 官方仓库：<a href="https://github.com/ubuntu" target="_blank" rel="noopener">https://github.com/ubuntu</a></p></li><li><p><code>Ubuntu</code> 官方镜像：<a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="noopener">https://hub.docker.com/_/ubuntu/</a></p></li><li><p><code>Ubuntu</code> 官方镜像仓库：<a href="https://github.com/tianon/docker-brew-ubuntu-core" target="_blank" rel="noopener">https://github.com/tianon/docker-brew-ubuntu-core</a></p></li></ul><h2 id="CentOS-Fedora-1"><a href="#CentOS-Fedora-1" class="headerlink" title="CentOS Fedora"></a>CentOS Fedora</h2><h3 id="CentOS-系统简介"><a href="#CentOS-系统简介" class="headerlink" title="CentOS 系统简介"></a>CentOS 系统简介</h3><p><code>CentOS</code> 和 <code>Fedora</code> 都是基于 <code>Redhat</code> 的常见 Linux 分支。<code>CentOS</code> 是目前企业级服务器的常用操作系统；<code>Fedora</code> 则主要面向个人桌面用户。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YWJjNWM3ZTFkOTgxZDlhMmIwYTI3MGE4NTRiNDg0NGFfUmJ2NVBMdlJ3R2s4T25XM0k2Q000WFNBZjZoQ28xQUlfVG9rZW46Ym94Y25qMHlzVUxxM1RDZTlKd2F4TGQwTWlkXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>CentOS（Community Enterprise Operating System，中文意思是：社区企业操作系统），它是基于 <code>Red Hat Enterprise Linux</code> 源代码编译而成。由于 <code>CentOS</code> 与 <code>Redhat Linux</code> 源于相同的代码基础，所以很多成本敏感且需要高稳定性的公司就使用 <code>CentOS</code> 来替代商业版 <code>Red Hat Enterprise Linux</code>。<code>CentOS</code> 自身不包含闭源软件。</p><h3 id="使用-CentOS-官方镜像"><a href="#使用-CentOS-官方镜像" class="headerlink" title="使用 CentOS 官方镜像"></a>使用 CentOS 官方镜像</h3><p>首先使用 <code>docker search</code> 命令来搜索标星至少为 <code>25</code> 的 <code>CentOS</code> 相关镜像。</p><pre><code>$ docker search -f stars=25 centosNAME      DESCRIPTION      STARS     OFFICIAL   AUTOMATEDcentos    The official...  2543      [OK]jdeathe/centos-ssh         27                   [OK]</code></pre><p>使用 <code>docker run</code> 直接运行最新的 <code>CentOS</code> 镜像，并登录 <code>bash</code>。</p><pre><code>$ docker run -it centos bashUnable to find image 'centos:latest' locallylatest: Pulling from library/centos3d8673bd162a: Pull completeDigest: sha256:a66ffcb73930584413de83311ca11a4cb4938c9b2521d331026dad970c19adf4Status: Downloaded newer image for centos:latest[root@43eb3b194d48 /]# cat /etc/redhat-releaseCentOS Linux release 7.2.1511 (Core)</code></pre><h3 id="Fedora-系统简介"><a href="#Fedora-系统简介" class="headerlink" title="Fedora 系统简介"></a>Fedora 系统简介</h3><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjBiNjdmY2VlMGNjOGE2MTA4NzQwNWNiMTY0ZTEwNWFfQ3Q2SGxCOHczTk84aG1BYnBCN3gxUFdwcUQ3ejQwZjlfVG9rZW46Ym94Y25XTW12SWZSUFNVdFAyTmxDMjhCd1ZIXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p><code>Fedora</code> 由 <code>Fedora Project</code> 社区开发，红帽公司赞助的 <code>Linux</code> 发行版。它的目标是创建一套新颖、多功能并且自由和开源的操作系统。<code>Fedora</code> 的功能对于用户而言，它是一套功能完备的，可以更新的免费操作系统，而对赞助商 <code>Red Hat</code> 而言，它是许多新技术的测试平台。被认为可用的技术最终会加入到 <code>Red Hat Enterprise Linux</code> 中。</p><h3 id="使用-Fedora-官方镜像"><a href="#使用-Fedora-官方镜像" class="headerlink" title="使用 Fedora 官方镜像"></a>使用 Fedora 官方镜像</h3><p>首先使用 <code>docker search</code> 命令来搜索标星至少为 <code>2</code> 的 <code>Fedora</code> 相关镜像，结果如下。</p><pre><code>$ docker search -f stars=2 fedoraNAME                     DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDfedora                   Official Docker builds of Fedora                433       [OK]dockingbay/fedora-rust   Trusted build of Rust programming language...   3                    [OK]gluster/gluster-fedora   Official GlusterFS image [ Fedora 21 + Glu...   3                    [OK]startx/fedora            Simple container used for all startx based...   2                    [OK]使用 docker run 命令直接运行 Fedora 官方镜像，并登录 bash。$ docker run -it fedora bashUnable to find image 'fedora:latest' locallylatest: Pulling from library/fedora2bf01635e2a0: Pull completeDigest: sha256:64a02df6aac27d1200c2572fe4b9949f1970d05f74d367ce4af994ba5dc3669eStatus: Downloaded newer image for fedora:latest[root@196ca341419b /]# cat /etc/redhat-releaseFedora release 24 (Twenty Four)</code></pre><h3 id="相关资源-3"><a href="#相关资源-3" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li><p><code>Fedora</code> 官网：<a href="https://getfedora.org/" target="_blank" rel="noopener">https://getfedora.org/</a></p></li><li><p><code>Fedora</code> 官方仓库：<a href="https://github.com/fedora-infra" target="_blank" rel="noopener">https://github.com/fedora-infra</a></p></li><li><p><code>Fedora</code> 官方镜像：<a href="https://hub.docker.com/_/fedora/" target="_blank" rel="noopener">https://hub.docker.com/_/fedora/</a></p></li><li><p><code>Fedora</code> 官方镜像仓库：<a href="https://github.com/fedora-cloud/docker-brew-fedora" target="_blank" rel="noopener">https://github.com/fedora-cloud/docker-brew-fedora</a></p></li><li><p><code>CentOS</code> 官网：<a href="https://www.centos.org/" target="_blank" rel="noopener">https://www.centos.org</a></p></li><li><p><code>CentOS</code> 官方仓库：<a href="https://github.com/CentOS" target="_blank" rel="noopener">https://github.com/CentOS</a></p></li><li><p><code>CentOS</code> 官方镜像：<a href="https://hub.docker.com/_/centos/" target="_blank" rel="noopener">https://hub.docker.com/_/centos/</a></p></li><li><p><code>CentOS</code> 官方镜像仓库：<a href="https://github.com/CentOS/CentOS-Dockerfiles" target="_blank" rel="noopener">https://github.com/CentOS/CentOS-Dockerfiles</a></p></li></ul><h1 id="实战案例-CI-CD"><a href="#实战案例-CI-CD" class="headerlink" title="实战案例 - CI/CD"></a>实战案例 - CI/CD</h1><p><strong>持续集成(Continuous integration)</strong> 是一种软件开发实践，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。</p><p><strong>持续部署(continuous deployment)</strong> 是通过自动化的构建、测试和部署循环来快速交付高质量的产品。</p><p>与 <code>Jenkins</code> 不同的是，基于 Docker 的 CI/CD 每一步都运行在 Docker 容器中，所以理论上支持所有的编程语言。</p><h2 id="GitHub-Actions"><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h2><p>GitHub <a href="https://github.com/features/actions" target="_blank" rel="noopener">Actions</a> 是 GitHub 推出的一款 CI/CD 工具。</p><p>我们可以在每个 <code>job</code> 的 <code>step</code> 中使用 Docker 执行构建步骤。</p><pre><code>on: pushname: CIjobs:  my-job:    name: Build    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@master        with:          fetch-depth: 2      - name: run docker container        uses: docker://golang:alpine        with:          args: go version</code></pre><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://docs.github.com/en/actions" target="_blank" rel="noopener">Actions Docs</a></li></ul><h2 id="Drone"><a href="#Drone" class="headerlink" title="Drone"></a>Drone</h2><p>基于 <code>Docker</code> 的 <code>CI/CD</code> 工具 <code>Drone</code> 所有编译、测试的流程都在 <code>Docker</code> 容器中进行。</p><p>开发者只需在项目中包含 <code>.drone.yml</code> 文件，将代码推送到 git 仓库，<code>Drone</code> 就能够自动化的进行编译、测试、发布。</p><p>本小节以 <code>GitHub</code> + <code>Drone</code> 来演示 <code>Drone</code> 的工作流程。当然在实际开发过程中，你的代码也许不在 GitHub 托管，那么你可以尝试使用 <code>Gogs</code> + <code>Drone</code> 来进行 <code>CI/CD</code>。</p><h3 id="Drone-关联项目"><a href="#Drone-关联项目" class="headerlink" title="Drone 关联项目"></a>Drone 关联项目</h3><p>在 Github 新建一个名为 <code>drone-demo</code> 的仓库。</p><p>打开我们已经 <a href="https://yeasy.gitbook.io/docker_practice/ci/drone/install" target="_blank" rel="noopener">部署好的 Drone 网站</a> 或者 <a href="https://cloud.drone.io/" target="_blank" rel="noopener">Drone Cloud</a>，使用 GitHub 账号登录，在界面中关联刚刚新建的 <code>drone-demo</code> 仓库。</p><h3 id="编写项目源代码"><a href="#编写项目源代码" class="headerlink" title="编写项目源代码"></a>编写项目源代码</h3><p>初始化一个 git 仓库</p><pre><code>$ mkdir drone-demo$ cd drone-demo$ git init$ git remote add origin git@github.com:username/drone-demo.git</code></pre><p>这里以一个简单的 <code>Go</code> 程序为例，该程序输出 <code>Hello World!</code></p><p>编写 <code>app.go</code> 文件</p><pre><code>package mainimport "fmt"func main(){    fmt.Printf("Hello World!\n");}</code></pre><p>编写 <code>.drone.yml</code> 文件</p><pre><code>kind: pipelinetype: dockername: buildsteps:- name: build  image: golang:alpine  pull: if-not-exists # always never  environment:    KEY: VALUE  commands:    - echo $KEY    - pwd    - ls    - CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .    - ./apptrigger:  branch:  - master</code></pre><p>现在目录结构如下</p><pre><code>├── .drone.yml└── app.go</code></pre><h3 id="推送项目源代码到-GitHub"><a href="#推送项目源代码到-GitHub" class="headerlink" title="推送项目源代码到 GitHub"></a>推送项目源代码到 GitHub</h3><pre><code>$ git add .$ git commit -m "test drone ci"$ git push origin master</code></pre><h3 id="查看项目构建过程及结果"><a href="#查看项目构建过程及结果" class="headerlink" title="查看项目构建过程及结果"></a>查看项目构建过程及结果</h3><p>打开我们部署好的 <code>Drone</code> 网站或者 Drone Cloud，即可看到构建结果。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=NDlhNzJmYjkxZmRkMzE5NWRmMTZmN2IzOWZmODQ4OGNfRnMxZUVoUUVQaUlRM2lqMmpta3g2eFlCVmNCREhUaVlfVG9rZW46Ym94Y245SVpOUW1hTkd0YTNUQkVzVmhHa3FoXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>当然我们也可以把构建结果上传到 GitHub，Docker Registry，云服务商提供的对象存储，或者生产环境中。</p><p>本书 GitBook 也使用 Drone 进行 CI/CD，具体配置信息请查看本书根目录 <code>.drone.yml</code> 文件。</p><h3 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><p><a href="https://github.com/drone/drone" target="_blank" rel="noopener">Drone Github</a></p></li><li><p><a href="https://docs.drone.io/" target="_blank" rel="noopener">Drone 文档</a></p></li><li><p><a href="https://github.com/docker-practice/drone-demo" target="_blank" rel="noopener">Drone 示例</a></p></li></ul><h2 id="部署-Drone"><a href="#部署-Drone" class="headerlink" title="部署 Drone"></a>部署 Drone</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul><li><p>拥有公网 IP、域名 (如果你不满足要求，可以尝试在本地使用 Gogs + Drone)</p></li><li><p>域名 SSL 证书 (目前国内有很多云服务商提供免费证书)</p></li><li><p>熟悉 <code>Docker</code> 以及 <code>Docker Compose</code></p></li><li><p>熟悉 <code>Git</code> 基本命令</p></li><li><p>对 <code>CI/CD</code> 有一定了解</p></li></ul><h3 id="新建-GitHub-应用"><a href="#新建-GitHub-应用" class="headerlink" title="新建 GitHub 应用"></a>新建 GitHub 应用</h3><p>登录 GitHub，在 <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a> 新建一个应用。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzZjZjMzMzdlNzQ4OWFkYWUzZGJiOWEwN2JiMDBhNjJfMk10UjdyYjg3WGxac1A4elRxOTJwVmFpOWZNSEVXN0NfVG9rZW46Ym94Y25STUpDQlRWcXFUV3UwcnppbHNLUTNkXzE2MjcxNDYwMzM6MTYyNzE0OTYzM19WNA" alt="img"></p><p>接下来查看这个应用的详情，记录 <code>Client ID</code> 和 <code>Client Secret</code>，之后配置 Drone 会用到。</p><h3 id="配置-Drone"><a href="#配置-Drone" class="headerlink" title="配置 Drone"></a>配置 Drone</h3><p>我们通过使用 <code>Docker Compose</code> 来启动 <code>Drone</code>，编写 <code>docker-compose.yml</code> 文件。</p><pre><code>version: '3'services:  drone-server:    image: drone/drone:1    ports:      - 443:443      - 80:80    volumes:      - drone-data:/data:rw      - ./ssl:/etc/certs    restart: always    environment:      - DRONE_AGENTS_ENABLED=true      - DRONE_SERVER_HOST=${DRONE_SERVER_HOST:-https://drone.yeasy.com}      - DRONE_SERVER_PROTO=${DRONE_SERVER_PROTO:-https}      - DRONE_RPC_SECRET=${DRONE_RPC_SECRET:-secret}      - DRONE_GITHUB_SERVER=https://github.com      - DRONE_GITHUB_CLIENT_ID=${DRONE_GITHUB_CLIENT_ID}      - DRONE_GITHUB_CLIENT_SECRET=${DRONE_GITHUB_CLIENT_SECRET}  drone-agent:    image: drone/drone-runner-docker:1    restart: always    depends_on:      - drone-server    volumes:      - /var/run/docker.sock:/var/run/docker.sock:rw    environment:      - DRONE_RPC_PROTO=http      - DRONE_RPC_HOST=drone-server      - DRONE_RPC_SECRET=${DRONE_RPC_SECRET:-secret}      - DRONE_RUNNER_NAME=${HOSTNAME:-demo}      - DRONE_RUNNER_CAPACITY=2    dns: 114.114.114.114volumes:  drone-data:</code></pre><p>新建 <code>.env</code> 文件，输入变量及其值</p><pre><code># 必填 服务器地址，例如 drone.domain.comDRONE_SERVER_HOST=DRONE_SERVER_PROTO=httpsDRONE_RPC_SECRET=secretHOSTNAME=demo# 必填 在 GitHub 应用页面查看DRONE_GITHUB_CLIENT_ID=# 必填 在 GitHub 应用页面查看DRONE_GITHUB_CLIENT_SECRET=</code></pre><h3 id="启动-Drone"><a href="#启动-Drone" class="headerlink" title="启动 Drone"></a>启动 Drone</h3><pre><code>$ docker-compose up -d</code></pre><h1 id="在-IDE-中使用-Docker"><a href="#在-IDE-中使用-Docker" class="headerlink" title="在 IDE 中使用 Docker"></a>在 IDE 中使用 Docker</h1><p>使用 IDE 进行开发，往往要求本地安装好工具链。一些 IDE 支持 Docker 容器中的工具链，这样充分利用了 Docker 的优点，而无需在本地安装。</p><h2 id="将-Docker-容器作为远程开发环境"><a href="#将-Docker-容器作为远程开发环境" class="headerlink" title="将 Docker 容器作为远程开发环境"></a>将 Docker 容器作为远程开发环境</h2><p>无需本地安装开发工具，直接将 Docker 容器作为开发环境，具体参考 <a href="https://code.visualstudio.com/docs/remote/containers" target="_blank" rel="noopener">官方文档</a>。</p><h1 id="podman-下一代-Linux-容器工具"><a href="#podman-下一代-Linux-容器工具" class="headerlink" title="podman - 下一代 Linux 容器工具"></a>podman - 下一代 Linux 容器工具</h1><p><code>podman</code> 是一个无守护程序与 docker 命令兼容的下一代 Linux 容器工具。</p><h2 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h2><pre><code>$ sudo yum -y install podman</code></pre><h2 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h2><p><code>podman</code> 与 docker 命令完全兼容，只需将 <code>docker</code> 替换为 <code>podman</code> 即可，例如运行一个容器：</p><pre><code># $ docker run -d -p 80:80 nginx:alpine$ podman run -d -p 80:80 nginx:alpine</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developers.redhat.com/blog/2019/02/21/podman-and-buildah-for-docker-users/" target="_blank" rel="noopener">https://developers.redhat.com/blog/2019/02/21/podman-and-buildah-for-docker-users/</a></li></ul><p><a href="https://yeasy.gitbook.io/docker_practice/ide" target="_blank" rel="noopener"> </a></p><h1 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h1><p>以下项目不被官方支持或内容陈旧，将在下一版本中删除。</p><ul><li><p>Docker Machine</p></li><li><p>Mesos</p></li><li><p>Docker Swarm</p></li></ul><h1 id="附录-1"><a href="#附录-1" class="headerlink" title="附录"></a><a href="https://yeasy.gitbook.io/docker_practice/appendix" target="_blank" rel="noopener">附录</a></h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Container </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v2ray详解</title>
      <link href="/posts/381d.html"/>
      <url>/posts/381d.html</url>
      
        <content type="html"><![CDATA[<p><strong>配置脚本：</strong></p><p><a href="https://github.com/hijkpw/scripts" target="_blank" rel="noopener">https://github.com/hijkpw/scripts</a></p><h1 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h1><h2 id="单服务器模式"><a href="#单服务器模式" class="headerlink" title="单服务器模式"></a>单服务器模式</h2><p>和其它的网络代理工具一样，你需要在一台配置了 V2Ray 的服务器，然后在自己的设备上安装 V2Ray 客户端，然后即可流畅地访问互联网。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=YzQ5YjdmOTAwYzBlNTFkOWVhYmM1YzM0OGM1ZDU3N2FfTWFaZHF3NVFqcHdNSFpYRlZwb2p2YzE0Q3k3ZUtydUJfVG9rZW46Ym94Y25Fa1hqSHVqZHpoZ1hTMGpiQnNNaWRkXzE2MjcxNDY2NjA6MTYyNzE1MDI2MF9WNA" alt="img"></p><p>一个 V2Ray 服务器可同时支持多台设备，使用不同的代理协议访问。同时，经过合理的配置，V2Ray 可以识别并区分需要代理和不需要代理的流量，直连的流量不需要绕路。</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>如果你不想在每一台设备上都配置路由，你也可以设置一台中转服务器，用于接收客户端发来的所有流量，然后在服务器中进行转发判断。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWE2OWZlNzdmODA2ZGZlNjc0YTA2MDU1ZTU0YWYxY2VfYTY2WlJ5VlJDd3FNS25FWE8zNUFmNjFPVTRVMEdNT09fVG9rZW46Ym94Y25udWUxZGRTWVVpTHJlV3ZIR3VtU0VmXzE2MjcxNDY2NjA6MTYyNzE1MDI2MF9WNA" alt="img"></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>在配置 V2Ray 之前，不妨先来看一下 V2Ray 的工作原理，以下是单个 V2Ray 进程的内部结构示意图。多个 V2Ray 之间互相独立，互不影响。</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=MTBmOThjODhhZmY5N2E3OWRjNDMwZTZiZjE5M2QyZGVfazZzWVdqVGVJcXl1MzJuV1dxaXA5SW0zdEx1TFV2akdfVG9rZW46Ym94Y25Rc2JzOGFUNE5BYmVuN1Nta1FMYjBlXzE2MjcxNDY2NjA6MTYyNzE1MDI2MF9WNA" alt="img"></p><ul><li><p>需要配置至少一个入站协议（Inbound）和一个出站协议（Outbound）才可以正常工作。</p><ul><li>入站协议负责与客户端（如浏览器）通信：<ul><li>入站协议通常可以配置用户认证，如 ID 和密码等；</li></ul></li></ul></li><li><p>入站协议收到数据之后，会交给分发器（Dispatcher）进行分发；</p></li><li><p>出站协议负责将数据发给服务器，如另一台主机上的 V2Ray。</p></li><li><p>当有多个出站协议时，可以配置路由（Routing）来指定某一类流量由某一个出站协议发出。</p><ul><li>路由会在必要时查询 DNS 以获取更多信息来进行判断。</li></ul></li></ul><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><h2 id="平台支持"><a href="#平台支持" class="headerlink" title="平台支持"></a>平台支持</h2><p>V2Ray 在以下平台中可用：</p><ul><li><p>Windows 7 及之后版本（x86 / amd64）；</p></li><li><p>Mac OS X 10.10 Yosemite 及之后版本（amd64）；</p></li><li><p>Linux 2.6.23 及之后版本（x86 / amd64 / arm / arm64 / mips64 / mips）；</p><ul><li>包括但不限于 Debian 7 / 8、Ubuntu 12.04 / 14.04 及后续版本、CentOS 6 / 7、Arch Linux；</li></ul></li><li><p>FreeBSD (x86 / amd64)；</p></li><li><p>OpenBSD (x86 / amd64)；</p></li><li><p>Dragonfly BSD (amd64)；</p></li></ul><h2 id="下载-V2Ray"><a href="#下载-V2Ray" class="headerlink" title="下载 V2Ray"></a>下载 V2Ray</h2><p>预编译的压缩包可以在如下几个站点找到：</p><ol><li>Github Release: <a href="https://github.com/v2ray/v2ray-core/releases" target="_blank" rel="noopener">github.com/v2ray/v2ray-core</a></li><li>Github 分流: <a href="https://github.com/v2ray/dist/" target="_blank" rel="noopener">github.com/v2ray/dist</a></li><li>Homebrew: <a href="https://github.com/v2ray/homebrew-v2ray" target="_blank" rel="noopener">github.com/v2ray/homebrew-v2ray</a></li><li>Arch Linux: <a href="https://www.archlinux.org/packages/community/x86_64/v2ray/" target="_blank" rel="noopener">packages/community/x86_64/v2ray/</a></li><li>Snapcraft: <a href="https://snapcraft.io/v2ray-core" target="_blank" rel="noopener">snapcraft.io/v2ray-core</a></li></ol><p>压缩包均为 zip 格式，找到对应平台的压缩包，下载解压即可使用。</p><h2 id="验证安装包"><a href="#验证安装包" class="headerlink" title="验证安装包"></a>验证安装包</h2><p>V2Ray 提供两种验证方式：</p><ol><li>安装包 zip 文件的 SHA1 / SHA256 摘要，在每个安装包对应的<code>.dgst</code>文件中可以找到。</li><li>可运行程序（v2ray 或 v2ray.exe）的 gpg 签名，文件位于安装包中的 v2ray.sig 或 v2ray.exe.sig。签名公钥可以<a href="https://raw.githubusercontent.com/v2ray/v2ray-core/master/release/verify/official_release.asc" target="_blank" rel="noopener">在代码库中</a>找到。</li></ol><h2 id="Windows-和-Mac-OS-安装方式"><a href="#Windows-和-Mac-OS-安装方式" class="headerlink" title="Windows 和 Mac OS 安装方式"></a>Windows 和 Mac OS 安装方式</h2><p>通过上述方式下载的压缩包，解压之后可看到 v2ray 或 v2ray.exe。直接运行即可。</p><h2 id="Linux-发行版仓库"><a href="#Linux-发行版仓库" class="headerlink" title="Linux 发行版仓库"></a>Linux 发行版仓库</h2><p>部分发行版可能已收录 V2Ray 到其官方维护和支持的软件仓库/软件源中。出于兼容性、适配性考虑，您可以考虑选用由您发行版开发团队维护的软件包或下文的安装脚本亦或基于已发布的二进制文件或源代码安装。</p><h2 id="Linux-安装脚本"><a href="#Linux-安装脚本" class="headerlink" title="Linux 安装脚本"></a>Linux 安装脚本</h2><p>V2Ray 提供了一个在 Linux 中的自动化安装脚本。这个脚本会自动检测有没有安装过 V2Ray，如果没有，则进行完整的安装和配置；如果之前安装过 V2Ray，则只更新 V2Ray 二进制程序而不更新配置。</p><p>以下指令假设已在 su 环境下，如果不是，请先运行 sudo su。</p><p>运行下面的指令下载并安装 V2Ray。当 yum 或 apt-get 可用的情况下，此脚本会自动安装 unzip 和 daemon。这两个组件是安装 V2Ray 的必要组件。如果你使用的系统不支持 yum 或 apt-get，请自行安装 unzip 和 daemon</p><pre><code>bash &lt;(curl -L -s https://install.direct/go.sh)</code></pre><p>此脚本会自动安装以下文件：</p><ul><li><p><code>/usr/bin/v2ray/v2ray</code>：V2Ray 程序；</p></li><li><p><code>/usr/bin/v2ray/v2ctl</code>：V2Ray 工具；</p></li><li><p><code>/etc/v2ray/config.json</code>：配置文件；</p></li><li><p><code>/usr/bin/v2ray/geoip.dat</code>：IP 数据文件</p></li><li><p><code>/usr/bin/v2ray/geosite.dat</code>：域名数据文件</p></li></ul><p>此脚本会配置自动运行脚本。自动运行脚本会在系统重启之后，自动运行 V2Ray。目前自动运行脚本只支持带有 Systemd 的系统，以及 Debian / Ubuntu 全系列。</p><p>运行脚本位于系统的以下位置：</p><ul><li><p><code>/etc/systemd/system/v2ray.service</code>: Systemd</p></li><li><p><code>/etc/init.d/v2ray</code>: SysV</p></li></ul><p>脚本运行完成后，你需要：</p><ol><li>编辑 /etc/v2ray/config.json 文件来配置你需要的代理方式；</li><li>运行 <strong>service v2ray start</strong> 来启动 V2Ray 进程；</li><li>之后可以使用 <strong>service v2ray start|stop|status|reload|restart|force-reload</strong> 控制 V2Ray 的运行。</li></ol><h3 id="go-sh-参数"><a href="#go-sh-参数" class="headerlink" title="go.sh 参数"></a>go.sh 参数</h3><p>go.sh 支持如下参数，可在手动安装时根据实际情况调整：</p><ul><li><p><code>-p</code> 或 <code>--proxy</code>: 使用代理服务器来下载 V2Ray 的文件，格式与 curl 接受的参数一致，比如 <code>"socks5://127.0.0.1:1080"</code> 或 <code>"http://127.0.0.1:3128"</code>。</p></li><li><p><code>-f</code> 或 <code>--force</code>: 强制安装。在默认情况下，如果当前系统中已有最新版本的 V2Ray，go.sh 会在检测之后就退出。如果需要强制重装一遍，则需要指定该参数。</p></li><li><p><code>--version</code>: 指定需要安装的版本，比如 <code>"v1.13"</code>。默认值为最新版本。</p></li><li><p><code>--local</code>: 使用一个本地文件进行安装。如果你已经下载了某个版本的 V2Ray，则可通过这个参数指定一个文件路径来进行安装。</p></li></ul><p>示例：</p><ul><li><p>使用地址为 127.0.0.1:1080 的 SOCKS 代理下载并安装最新版本：<code>./go.sh -p socks5://127.0.0.1:1080</code></p></li><li><p>安装本地的 v1.13 版本：<code>./go.sh --version v1.13 --local /path/to/v2ray.zip</code></p></li></ul><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>V2Ray 提供了两个预编译的 Docker image：</p><ul><li><p><a href="https://hub.docker.com/r/v2ray/official/" target="_blank" rel="noopener">v2ray/official</a>: 包含最新发布的版本，每周跟随新版本更新；</p></li><li><p><a href="https://hub.docker.com/r/v2ray/dev/" target="_blank" rel="noopener">v2ray/dev</a>: 包含由最新的代码编译而成的程序文件，随代码库更新；</p></li></ul><p>两个 image 的文件结构相同：</p><ul><li><p>/etc/v2ray/config.json: 配置文件</p></li><li><p>/usr/bin/v2ray/v2ray: V2Ray 主程序</p></li><li><p>/usr/bin/v2ray/v2ctl: V2Ray 辅助工具</p></li><li><p>/usr/bin/v2ray/geoip.dat: IP 数据文件</p></li><li><p>/usr/bin/v2ray/geosite.dat: 域名数据文件</p></li></ul><h1 id="新手上路"><a href="#新手上路" class="headerlink" title="新手上路"></a>新手上路</h1><p>在下载并安装了 V2Ray 之后，你需要对它进行一下配置。这里介绍一下简单的配置方式，只是为了演示。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>在你的 PC （或手机）中，你需要运行 V2Ray 并使用下面的配置：</p><pre><code>{  "inbounds": [{    "port": 1080,  // SOCKS 代理端口，在浏览器中需配置代理并指向这个端口    "listen": "127.0.0.1",    "protocol": "socks",    "settings": {      "udp": true    }  }],  "outbounds": [{    "protocol": "vmess",    "settings": {      "vnext": [{        "address": "server", // 服务器地址，请修改为你自己的服务器 ip 或域名        "port": 10086,  // 服务器端口        "users": [{ "id": "b831381d-6324-4d53-ad4f-8cda48b30811" }]      }]    }  },{    "protocol": "freedom",    "tag": "direct",    "settings": {}  }],  "routing": {    "domainStrategy": "IPOnDemand",    "rules": [{      "type": "field",      "ip": ["geoip:private"],      "outboundTag": "direct"    }]  }}</code></pre><p>上述配置唯一要改的地方就是你的服务器 IP，配置中已注明。上述配置会把除了局域网（比如访问路由器）之外的所有流量转发到你的服务器。</p><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>然后你需要一台防火墙外的服务器，来运行服务器端的 V2Ray。配置如下：</p><pre><code>{  "inbounds": [{    "port": 10086, // 服务器监听端口，必须和上面的一样    "protocol": "vmess",    "settings": {      "clients": [{ "id": "b831381d-6324-4d53-ad4f-8cda48b30811" }]    }  }],  "outbounds": [{    "protocol": "freedom",    "settings": {}  }]}</code></pre><p>服务器的配置中需要确保 <code>id</code> 和端口与客户端一致，就可以正常连接了。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><ul><li><p>在 Windows 和 macOS 中，配置文件通常是 V2Ray 同目录下的 <code>config.json</code> 文件。直接运行 <code>v2ray</code> 或 <code>v2ray.exe</code> 即可。</p></li><li><p>在 Linux 中，配置文件通常位于 <code>/etc/v2ray/config.json</code> 文件。运行 <code>v2ray --config=/etc/v2ray/config.json</code>，或使用 systemd 等工具把 V2Ray 作为服务在后台运行。</p></li></ul><h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><h2 id="V2Ray"><a href="#V2Ray" class="headerlink" title="V2Ray"></a>V2Ray</h2><p>V2Ray 的程序文件的命令行参数如下：</p><pre><code>v2ray [-version] [-test] [-config=config.json] [-format=json]</code></pre><blockquote><pre><code>-version</code></pre></blockquote><p>只输出当前版本然后退出，不运行 V2Ray 主程序。</p><blockquote><pre><code>-test</code></pre></blockquote><p>测试配置文件有效性，如果有问题则输出错误信息，不运行 V2Ray 主程序。</p><blockquote><pre><code>-config</code></pre></blockquote><p>配置文件路径，可选的形式如下:</p><ul><li><p>本地路径，可以是一个绝对路径，或者相对路径。</p></li><li><p><code>"stdin:"</code>: 表示将从标准输入读取配置文件内容，调用者必须在输入完毕后关闭标准输入流。</p></li><li><p>以<code>http://</code>或<code>https://</code>(均为小写)开头: V2Ray 将尝试从这个远程地址加载配置文件。</p></li></ul><blockquote><pre><code>-format</code></pre></blockquote><p>配置文件格式，可选的值有：</p><ul><li><p><code>json</code>: JSON 格式；</p></li><li><p><code>pb</code> 或 <code>protobuf</code>: Protobuf 格式；</p></li></ul><p>当<code>-config</code>没有指定时，V2Ray 将先后尝试从以下路径加载<code>config.json</code>:</p><ul><li><p>工作目录（Working Directory）</p></li><li><p><a href="https://www.v2ray.com/chapter_02/env.html" target="_blank" rel="noopener">环境变量</a>中<code>v2ray.location.asset</code>所指定的路径</p></li></ul><h2 id="V2Ctl"><a href="#V2Ctl" class="headerlink" title="V2Ctl"></a>V2Ctl</h2><p>V2Ctl 是一个集合，它有若干个子命令组成。全局的命令行形式如下：</p><pre><code>v2ctl &lt;command&gt; &lt;options&gt;</code></pre><blockquote><pre><code>command</code></pre></blockquote><p>子命令，有以下选项:</p><ul><li><p><code>api</code>: 调用 V2Ray 进程的远程控制指令。</p></li><li><p><code>config</code>: 从标准输入读取 JSON 格式的配置，然后从标准输出打印 Protobuf 格式的配置。</p></li><li><p><code>cert</code>: 生成 TLS 证书。</p></li><li><p><code>fetch</code>: 抓取远程文件。</p></li><li><p><code>tlsping</code>: (V2Ray 4.17+) 尝试进行 TLS 握手。</p></li><li><p><code>verify</code>: 验证文件是否由 Project V 官方签名。</p></li><li><p><code>uuid</code>: 输出一个随机的 UUID。</p></li></ul><h3 id="V2Ctl-Api"><a href="#V2Ctl-Api" class="headerlink" title="V2Ctl Api"></a>V2Ctl Api</h3><pre><code>v2ctl api [--server=127.0.0.1:8080] &lt;Service.Method&gt; &lt;Request&gt;</code></pre><p>调用 V2Ray 进程的远程控制指令。示例：</p><pre><code>v2ctl api --server=127.0.0.1:8080 LoggerService.RestartLogger ''</code></pre><h3 id="V2Ctl-Config"><a href="#V2Ctl-Config" class="headerlink" title="V2Ctl Config"></a>V2Ctl Config</h3><pre><code>v2ctl config</code></pre><p>此命令没有参数。它从标准输入读取 JSON 格式的配置，然后从标准输出打印 Protobuf 格式的配置。</p><h3 id="V2Ctl-Cert"><a href="#V2Ctl-Cert" class="headerlink" title="V2Ctl Cert"></a>V2Ctl Cert</h3><pre><code>v2ctl cert [--ca] [--domain=v2ray.com] [--expire=240h] [--name="V2Ray Inc"] [--org="V2Ray Inc] [--json] [--file=v2ray]</code></pre><p>生成一个 TLS 证书。</p><blockquote><pre><code>--ca</code></pre></blockquote><p>如果指定此选项，将会生成一个 CA 证书。</p><blockquote><pre><code>--domain</code></pre></blockquote><p>证书的 Alternative Name 项。该参数可以多次使用，来指定多个域名。比如<code>--domain=v2ray.com --domain=v2ray.cool</code>。</p><blockquote><pre><code>--expire</code></pre></blockquote><p>证书有效期。格式为 Golang 的<a href="https://golang.org/pkg/time/#ParseDuration" target="_blank" rel="noopener">时间长度</a>。</p><blockquote><pre><code>--name</code></pre></blockquote><p>证书的 Command Name 项。</p><blockquote><pre><code>--org</code></pre></blockquote><p>证书的 Orgnization 项。</p><blockquote><pre><code>--json</code></pre></blockquote><p>将生成的证书以 V2Ray 支持的 JSON 格式输出到标准输出。默认开启。</p><blockquote><pre><code>--file</code></pre></blockquote><p>将证书以 PEM 格式输出到文件。当指定 <code>--file=a</code> 时，将生成 <code>a_cert.pem</code> 和 <code>a_key.pem</code> 两个文件。</p><h3 id="V2Ctl-Fetch"><a href="#V2Ctl-Fetch" class="headerlink" title="V2Ctl Fetch"></a>V2Ctl Fetch</h3><pre><code>v2ctl fetch &lt;url&gt;</code></pre><p>抓取指定的 URL 的内容并输出，只支持 HTTP 和 HTTPS。</p><h3 id="V2Ctl-TlsPing"><a href="#V2Ctl-TlsPing" class="headerlink" title="V2Ctl TlsPing"></a>V2Ctl TlsPing</h3><pre><code>v2ctl tlsping &lt;domain&gt; --ip=[ip]</code></pre><p>向指定的域名发起 TLS 握手。</p><blockquote><p>domain</p></blockquote><p>目标域名</p><blockquote><p>–ip</p></blockquote><p>此域名的 IP 地址。如果未指定此参数，V2Ctl 将使用系统的 DNS 进行域名解析。</p><h3 id="V2Ctl-Verify"><a href="#V2Ctl-Verify" class="headerlink" title="V2Ctl Verify"></a>V2Ctl Verify</h3><pre><code>v2ctl verify [--sig=/path/to/sigfile] &lt;filepath&gt;</code></pre><p>此命令用于验证一个文件是否由 Project V 官方签名。</p><blockquote><pre><code>--sig</code></pre></blockquote><p>签名文件路径，默认值为待验证文件加入’.sig’后缀。</p><blockquote><pre><code>filepath</code></pre></blockquote><p>待验证文件路径。</p><h3 id="V2Ctl-UUID"><a href="#V2Ctl-UUID" class="headerlink" title="V2Ctl UUID"></a>V2Ctl UUID</h3><pre><code>v2ctl uuid</code></pre><p>此命令没有参数。每次运行都会输出一个新的 UUID。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="一般问题"><a href="#一般问题" class="headerlink" title="一般问题"></a>一般问题</h2><h3 id="制作-V2Ray-的目的是什么？"><a href="#制作-V2Ray-的目的是什么？" class="headerlink" title="制作 V2Ray 的目的是什么？"></a>制作 V2Ray 的目的是什么？</h3><p>对于已公开的合法信息，人民有自由获取的权利。同时，人民也有言论自由的权利。</p><h3 id="是否反对管制？"><a href="#是否反对管制？" class="headerlink" title="是否反对管制？"></a>是否反对管制？</h3><p>不反对管制。事实上任何事物都需要管制，以减少大众的生活成本，比如奶粉。但监管需要有法可依、有据可循。民众都认可的监管方式也是合理的，可接受的。</p><h3 id="Project-V-由谁主导开发？"><a href="#Project-V-由谁主导开发？" class="headerlink" title="Project V 由谁主导开发？"></a>Project V 由谁主导开发？</h3><p>我们是一群爱好自由的人们。由于政策压力，我们倾向于保持匿名，尽可能地不透露任何身份信息。</p><h2 id="V2Ray-使用相关"><a href="#V2Ray-使用相关" class="headerlink" title="V2Ray 使用相关"></a>V2Ray 使用相关</h2><h3 id="V2Ray-如何升级"><a href="#V2Ray-如何升级" class="headerlink" title="V2Ray 如何升级"></a>V2Ray 如何升级</h3><ul><li><p>重新下载安装包，或者</p></li><li><p>如果你使用安装脚本进行安装，重新运行安装脚本即可</p></li></ul><h3 id="V2Ray-闪退"><a href="#V2Ray-闪退" class="headerlink" title="V2Ray 闪退"></a>V2Ray 闪退</h3><ul><li><p>如果你使用 Linux 并开启了 systemd，可以使用 <code>journalctl -u v2ray</code> 查看 V2Ray 退出时的日志；</p></li><li><p>一般情况可以手动运行 <code>v2ray -config=&lt;config-file&gt; -test</code> 来查看错误信息；</p></li></ul><h3 id="兼容性保证"><a href="#兼容性保证" class="headerlink" title="兼容性保证"></a>兼容性保证</h3><ul><li><p>配置文件向后兼容至少一个大版本，即 V2Ray 4.x 可以正常加载 3.x 的配置文件。</p></li><li><p>所有基于 Protobuf 的通信协议，如 Api，向后兼容至少一个大版本。</p></li><li><p>所有基于二进制的通信协议，如 Shadowsocks 和 VMess。当服务器版本不低于客户端版本时，保持永久兼容；当客户端版本超过服务器版本时，保持至少 12 个小版本的兼容性。</p></li></ul><h2 id="V2Ray-错误信息"><a href="#V2Ray-错误信息" class="headerlink" title="V2Ray 错误信息"></a>V2Ray 错误信息</h2><h3 id="VMess-Invalid-User"><a href="#VMess-Invalid-User" class="headerlink" title="VMess: Invalid User"></a>VMess: Invalid User</h3><p>可能的原因：</p><ol><li>客户端和服务器端的用户 ID 不匹配；</li><li>客户端和服务器端的用户 alterId 不匹配；</li><li>客户端与服务器的时间不匹配，误差不能超过90秒钟；</li></ol><h3 id="Shadowsocks-Unknown-address-type"><a href="#Shadowsocks-Unknown-address-type" class="headerlink" title="Shadowsocks: Unknown address type"></a>Shadowsocks: Unknown address type</h3><p>可能的原因：</p><ol><li>Shadowsocks 协议的加密方式或是密码不匹配；</li></ol><h3 id="Socks-Unknown-Socks-version-67"><a href="#Socks-Unknown-Socks-version-67" class="headerlink" title="Socks: Unknown Socks version: 67"></a>Socks: Unknown Socks version: 67</h3><p>可能的原因：</p><ul><li>你开启的是 Socks 代理，但在浏览器中配置了 HTTP 代理</li></ul><p>解决方案：</p><ul><li>在 V2Ray 中配置一个 HTTP 入站代理，然后把浏览器的设置指向这个代理</li></ul><h2 id="其它软件错误"><a href="#其它软件错误" class="headerlink" title="其它软件错误"></a>其它软件错误</h2><h3 id="访问-Google-时，浏览器中显示证书无效"><a href="#访问-Google-时，浏览器中显示证书无效" class="headerlink" title="访问 Google 时，浏览器中显示证书无效"></a>访问 Google 时，浏览器中显示证书无效</h3><p>错误信息：攻击者可能会试图从 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 窃取您的信息（例如：密码、通讯内容或信用卡信息）。了解详情 NET::ERR_CERT_COMMON_NAME_INVALID</p><p>原因：你的 DNS 缓存可能已被污染。</p><p>解决方案：</p><ul><li><p>需要在使用代理的情况下，清空缓存并重新抓取 DNS 数据</p></li><li><p>在 V2Ray 中可使用<code>sniffing</code>功能克服一部分 DNS 污染。</p></li></ul><h2 id="项目授权"><a href="#项目授权" class="headerlink" title="项目授权"></a>项目授权</h2><p>Project V 使用以下方式进行授权</p><h3 id="V2Ray-1"><a href="#V2Ray-1" class="headerlink" title="V2Ray"></a>V2Ray</h3><p>源代码以官方发布的安装包，使用 MIT 协议授权。包括以下代码仓库中的源代码及安装包：</p><ul><li><p><a href="https://www.github.com/v2ray/v2ray-core/" target="_blank" rel="noopener">v2ray/v2ray-core</a></p></li><li><p><a href="https://www.github.com/v2ray/ext" target="_blank" rel="noopener">v2ray/ext</a></p></li></ul><h3 id="官方网站"><a href="#官方网站" class="headerlink" title="官方网站"></a>官方网站</h3><p>官方网站（<a href="https://www.v2ray.com/" target="_blank" rel="noopener">v2ray.com</a>）以<a href="https://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="noopener">知识共享署名 4.0 国际许可协议</a>协议授权。</p><ul><li><p>包括网站中所有可见的文字内容和图片。</p></li><li><p>包括 <a href="https://www.v2ray.com/resources/v2ray_1024.png" target="_blank" rel="noopener">Project V 图标文件</a>。</p></li><li><p>包括生成网站所使用到的源代码，即<a href="https://www.github.com/v2ray/manual" target="_blank" rel="noopener">v2ray/manual</a>。</p></li></ul><h3 id="软件截图和其它文件"><a href="#软件截图和其它文件" class="headerlink" title="软件截图和其它文件"></a>软件截图和其它文件</h3><p>第三方所创作的内容，其版权归其创作者所有。Project V 放弃对这些内容的所有权。</p><ul><li><p>包括 Project V 使用过程中的截图。</p></li><li><p>包括运行 Project V 所需的配置文件。</p></li><li><p>包括 Project V 运行时产生的日志文件。</p></li></ul><h3 id="其它内容"><a href="#其它内容" class="headerlink" title="其它内容"></a>其它内容</h3><p>未在上述提及的内容，其版权视具体情况而定。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>V2Ray 本身使用基于 <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">Protobuf</a> 的配置。由于 Protobuf 的文本格式不方便阅读，V2Ray 同时也支持 JSON 格式的配置。在运行之前，V2Ray 会自动将 JSON 转换为对应的 Protobuf。换言之，V2Ray 将来也可能会支持其它格式的配置。</p><p>以下介绍一下基于 JSON 格式的配置。</p><p>JSON，全称 <a href="https://en.wikipedia.org/wiki/JSON" target="_blank" rel="noopener">JavaScript Object Notation</a>，简而言之是 Javascript 中的对象（Object）。一个 JSON 文件包含一个完整的对象，以大括号“{”开头，大括号“}”结束。</p><p>一个 JSON 对象包含一系列的键值对（Key-Value Pair），一个键是一个字符串（String），而值有多种类型，常见的有字符串（String）、数字（Number）、布尔（Bool）、数组（Array）和对象（Object）。下面是一个简单的 JSON 对象示例：</p><pre><code>{  "stringValue": "This is a string.",  "numberValue": 42,  "boolValue": true,  "arrayValue": ["this", "is", "a", "string", "array"],  "objectValue": {    "another": "object"  }}</code></pre><p>V2Ray 的 JSON 格式支持注释，可使用“//”或者“/* */”来进行注释。在不支持注释的编辑器中可能被显示为“错误”，但实际上是可以正常使用的。</p><h2 id="JSON-数据类型"><a href="#JSON-数据类型" class="headerlink" title="JSON 数据类型"></a>JSON 数据类型</h2><p>这里介绍一下常用的数据类型，在之后其它的配置中会用到。</p><blockquote><p><code>boolean</code>: true | false</p></blockquote><p>布尔值，只有<code>true</code>和<code>false</code>两种取值，不带引号。</p><blockquote><pre><code>number</code></pre></blockquote><p>数字，在 V2Ray 的使用中通常为非负整数，即<code>0</code>、<code>53</code>…… 数字在 JSON 格式中不带引号。</p><blockquote><pre><code>string</code></pre></blockquote><p>字符串，由引号包含的一串字符，如无特殊说明，字符的内容不限。</p><blockquote><p><code>array</code>: []</p></blockquote><p>数组，由方括号包含的一组元素，如字符串数组表示为<code>[string]</code>。</p><blockquote><p><code>object</code>: {}</p></blockquote><p>对象，一组键值对。样例见本文上方的示例。</p><p>通常一个键值对的后面需要有一个逗号”,”，但如果这个键值对后面紧跟一个大括号”｝”的话，则一定不能有逗号。</p><h2 id="V2Ray-常用数据类型"><a href="#V2Ray-常用数据类型" class="headerlink" title="V2Ray 常用数据类型"></a>V2Ray 常用数据类型</h2><blockquote><p><code>map</code>: object {string:string}</p></blockquote><p>一组键值对，其类型在括号内指出。每一个键和值的类型对应相同。</p><blockquote><p><code>address</code>: string</p></blockquote><p>字符串，表示一个 IP 地址或域名，形如：<code>"8.8.8.8"</code> 或 <code>"www.v2ray.com"</code></p><blockquote><p><code>address_port</code>: string</p></blockquote><p>字符串，表示一个地址和端口，常见的形式如：<code>"8.8.8.8:53"</code>，或者 <code>"www.v2ray.com:80"</code>。在一部分配置中，地址部分可以省略，如<code>":443"</code>。</p><h1 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h1><p>V2Ray 的配置文件形式如下，客户端和服务器通用一种形式，只是实际的配置不一样。</p><pre><code>{  "log": {},  "api": {},  "dns": {},  "stats": {},  "routing": {},  "policy": {},  "reverse": {},  "inbounds": [],  "outbounds": [],  "transport": {}}</code></pre><blockquote><p><code>log</code>: <a href="https://www.v2ray.com/chapter_02/01_overview.html#logobject" target="_blank" rel="noopener">LogObject</a></p></blockquote><p>日志配置，表示 V2Ray 如何输出日志。</p><blockquote><p><code>api</code>: <a href="https://www.v2ray.com/chapter_02/api.html" target="_blank" rel="noopener">ApiObject</a></p></blockquote><p>内置的远程控置 API。</p><blockquote><p><code>dns</code>: <a href="https://www.v2ray.com/chapter_02/04_dns.html" target="_blank" rel="noopener">DnsObject</a></p></blockquote><p>内置的 DNS 服务器，若此项不存在，则默认使用本机的 DNS 设置。</p><blockquote><p><code>routing</code>: <a href="https://www.v2ray.com/chapter_02/03_routing.html" target="_blank" rel="noopener">RoutingObject</a></p></blockquote><p><a href="https://www.v2ray.com/chapter_02/03_routing.html" target="_blank" rel="noopener">路由配置</a></p><blockquote><p><code>policy</code>: <a href="https://www.v2ray.com/chapter_02/policy.html" target="_blank" rel="noopener">PolicyObject</a></p></blockquote><p>本地策略可进行一些权限相关的配置</p><blockquote><p><code>inbounds</code>: [<a href="https://www.v2ray.com/chapter_02/01_overview.html#inboundobject" target="_blank" rel="noopener">InboundObject</a>]</p></blockquote><p>一个数组，每个元素是一个入站连接配置。</p><blockquote><p><code>outbounds</code>: [<a href="https://www.v2ray.com/chapter_02/01_overview.html#outboundobject" target="_blank" rel="noopener">OutboundObject</a>]</p></blockquote><p>一个数组，每个元素是一个出站连接配置。列表中的第一个元素作为主出站协议。当路由匹配不存在或没有匹配成功时，流量由主出站协议发出。</p><blockquote><p><code>transport</code>: <a href="https://www.v2ray.com/chapter_02/05_transport.html" target="_blank" rel="noopener">TransportObject</a></p></blockquote><p>用于配置 V2Ray 如何与其它服务器建立和使用网络连接。详见底层传输配置</p><blockquote><p><code>stats</code>: <a href="https://www.v2ray.com/chapter_02/stats.html" target="_blank" rel="noopener">StatsObject</a></p></blockquote><p>当此项存在时，开启统计信息。</p><blockquote><p><code>reverse</code>: <a href="https://www.v2ray.com/chapter_02/reverse.html" target="_blank" rel="noopener">ReverseObject</a></p></blockquote><p>反向代理配置。</p><h2 id="LogObject"><a href="#LogObject" class="headerlink" title="LogObject"></a>LogObject</h2><pre><code>{  "access": "文件地址",  "error": "文件地址",  "loglevel": "warning"}</code></pre><blockquote><p><code>access</code>: string</p></blockquote><p>访问日志的文件地址，其值是一个合法的文件地址，如<code>"/tmp/v2ray/_access.log"</code>（Linux）或者<code>"C:\\Temp\\v2ray\\_access.log"</code>（Windows）。当此项不指定或为空值时，表示将日志输出至 stdout。V2Ray 4.20 加入了特殊值<code>none</code>，即关闭access log。</p><blockquote><p><code>error</code>: string</p></blockquote><p>错误日志的文件地址，其值是一个合法的文件地址，如<code>"/tmp/v2ray/_error.log"</code>（Linux）或者<code>"C:\\Temp\\v2ray\\_error.log"</code>（Windows）。当此项不指定或为空值时，表示将日志输出至 stdout。V2Ray 4.20 加入了特殊值<code>none</code>，即关闭error log（跟<code>loglevel: "none"</code>等价）。</p><blockquote><p><code>loglevel</code>: “debug” | “info” | “warning” | “error” | “none”</p></blockquote><p>错误日志的级别。默认值为<code>"warning"</code>。</p><ul><li><p><code>"debug"</code>: 只有开发人员能看懂的信息。同时包含所有<code>"info"</code>内容。</p></li><li><p><code>"info"</code>: V2Ray 在运行时的状态，不影响正常使用。同时包含所有<code>"warning"</code>内容。</p></li><li><p><code>"warning"</code>: V2Ray 遇到了一些问题，通常是外部问题，不影响 V2Ray 的正常运行，但有可能影响用户的体验。同时包含所有<code>"error"</code>内容。</p></li><li><p><code>"error"</code>: V2Ray 遇到了无法正常运行的问题，需要立即解决。</p></li><li><p><code>"none"</code>: 不记录任何内容。</p></li></ul><h2 id="InboundObject"><a href="#InboundObject" class="headerlink" title="InboundObject"></a>InboundObject</h2><p>入站连接用于接收从客户端（浏览器或上一级代理服务器）发来的数据，可用的协议请见<a href="https://www.v2ray.com/chapter_02/02_protocols.html" target="_blank" rel="noopener">协议列表</a>。</p><pre><code>{  "port": 1080,  "listen": "127.0.0.1",  "protocol": "协议名称",  "settings": {},  "streamSettings": {},  "tag": "标识",  "sniffing": {    "enabled": false,    "destOverride": ["http", "tls"]  },  "allocate": {    "strategy": "always",    "refresh": 5,    "concurrency": 3  }}</code></pre><blockquote><p><code>port</code>: number | “env:variable” | string</p></blockquote><p>端口。接受的格式如下:</p><ul><li><p>整型数值: 实际的端口号。</p></li><li><p>环境变量: 以<code>"env:"</code>开头，后面是一个环境变量的名称，如<code>"env:PORT"</code>。V2Ray 会以字符串形式解析这个环境变量。</p></li><li><p>字符串: 可以是一个数值类型的字符串，如<code>"1234"</code>；或者一个数值范围，如<code>"5-10"</code>表示端口 5 到端口 10 这 6 个端口。</p></li></ul><p>当只有一个端口时，V2Ray 会在此端口监听入站连接。当指定了一个端口范围时，取决于<code>allocate</code>设置。</p><blockquote><p><code>listen</code>: address</p></blockquote><p>监听地址，只允许 IP 地址，默认值为<code>"0.0.0.0"</code>，表示接收所有网卡上的连接。除此之外，必须指定一个现有网卡的地址。</p><blockquote><p><code>protocol</code>: string</p></blockquote><p>连接协议名称，可选的值见<a href="https://www.v2ray.com/chapter_02/02_protocols.html" target="_blank" rel="noopener">协议列表</a>。</p><blockquote><p><code>settings</code>: InboundConfigurationObject</p></blockquote><p>具体的配置内容，视协议不同而不同。详见每个协议中的<code>InboundConfigurationObject</code>。</p><blockquote><p><code>streamSettings</code>: <a href="https://www.v2ray.com/chapter_02/05_transport.html#perproxy" target="_blank" rel="noopener">StreamSettingsObject</a>。</p></blockquote><p><a href="https://www.v2ray.com/chapter_02/05_transport.html#perproxy" target="_blank" rel="noopener">底层传输配置</a></p><blockquote><p><code>tag</code>: string</p></blockquote><p>此入站连接的标识，用于在其它的配置中定位此连接。当其不为空时，其值必须在所有<code>tag</code>中唯一。</p><blockquote><p><code>sniffing</code>: <a href="https://www.v2ray.com/chapter_02/01_overview.html#sniffingobject" target="_blank" rel="noopener">SniffingObject</a></p></blockquote><p>尝试探测流量的类型</p><blockquote><p><code>allocate</code>: <a href="https://www.v2ray.com/chapter_02/01_overview.html#allocateobject" target="_blank" rel="noopener">AllocateObject</a></p></blockquote><p>端口分配设置</p><h3 id="SniffingObject"><a href="#SniffingObject" class="headerlink" title="SniffingObject"></a>SniffingObject</h3><pre><code>{  "enabled": false,  "destOverride": ["http", "tls"]}</code></pre><blockquote><p><code>enabled</code>: true | false</p></blockquote><p>是否开启流量探测。</p><blockquote><p><code>destOverride</code>: [“http” | “tls”]</p></blockquote><p>当流量为指定类型时，按其中包括的目标地址重置当前连接的目标。</p><h3 id="AllocateObject"><a href="#AllocateObject" class="headerlink" title="AllocateObject"></a>AllocateObject</h3><pre><code>{  "strategy": "always",  "refresh": 5,  "concurrency": 3}</code></pre><blockquote><p><code>strategy</code>: “always” | “random”</p></blockquote><p>端口分配策略。<code>"always"</code>表示总是分配所有已指定的端口，<code>port</code>中指定了多少个端口，V2Ray 就会监听这些端口。<code>"random"</code>表示随机开放端口，每隔<code>refresh</code>分钟在<code>port</code>范围中随机选取<code>concurrency</code>个端口来监听。</p><blockquote><p><code>refresh</code>: number</p></blockquote><p>随机端口刷新间隔，单位为分钟。最小值为<code>2</code>，建议值为<code>5</code>。这个属性仅当<code>strategy = random</code>时有效。</p><blockquote><p><code>concurrency</code>: number</p></blockquote><p>随机端口数量。最小值为<code>1</code>，最大值为<code>port</code>范围的三分之一。建议值为<code>3</code>。</p><h2 id="OutboundObject"><a href="#OutboundObject" class="headerlink" title="OutboundObject"></a>OutboundObject</h2><p>出站连接用于向远程网站或下一级代理服务器发送数据，可用的协议请见<a href="https://www.v2ray.com/chapter_02/02_protocols.html" target="_blank" rel="noopener">协议列表</a>。</p><pre><code>{  "sendThrough": "0.0.0.0",  "protocol": "协议名称",  "settings": {},  "tag": "标识",  "streamSettings": {},  "proxySettings": {    "tag": "another-outbound-tag"  },  "mux": {}}</code></pre><blockquote><p><code>sendThrough</code>: address</p></blockquote><p>用于发送数据的 IP 地址，当主机有多个 IP 地址时有效，默认值为<code>"0.0.0.0"</code>。</p><blockquote><p><code>protocol</code>: string</p></blockquote><p>连接协议名称，可选的值见<a href="https://www.v2ray.com/chapter_02/02_protocols.html" target="_blank" rel="noopener">协议列表</a>。</p><blockquote><p><code>settings</code>: OutboundConfigurationObject</p></blockquote><p>具体的配置内容，视协议不同而不同。详见每个协议中的<code>OutboundConfigurationObject</code>。</p><blockquote><p><code>tag</code>: string</p></blockquote><p>此出站连接的标识，用于在其它的配置中定位此连接。当其值不为空时，必须在所有 tag 中唯一。</p><blockquote><p><code>streamSettings</code>: <a href="https://www.v2ray.com/chapter_02/05_transport.html#perproxy" target="_blank" rel="noopener">StreamSettingsObject</a>。</p></blockquote><p><a href="https://www.v2ray.com/chapter_02/05_transport.html#perproxy" target="_blank" rel="noopener">底层传输配置</a></p><blockquote><p><code>proxySettings</code>: <a href="https://www.v2ray.com/chapter_02/01_overview.html#proxysettingsobject" target="_blank" rel="noopener">ProxySettingsObject</a></p></blockquote><p>出站代理配置。当出站代理生效时，此出站协议的<code>streamSettings</code>将不起作用。</p><blockquote><p><code>mux</code>: <a href="https://www.v2ray.com/chapter_02/mux.html" target="_blank" rel="noopener">MuxObject</a></p></blockquote><p><a href="https://www.v2ray.com/chapter_02/mux.html" target="_blank" rel="noopener">Mux 配置</a>。</p><h3 id="ProxySettingsObject"><a href="#ProxySettingsObject" class="headerlink" title="ProxySettingsObject"></a>ProxySettingsObject</h3><pre><code>{  "tag": "another-outbound-tag"}</code></pre><blockquote><p><code>tag</code>: string</p></blockquote><p>当指定另一个出站协议的标识时，此出站协议发出的数据，将被转发至所指定的出站协议发出。</p><h1 id="V2Ray-协议列表"><a href="#V2Ray-协议列表" class="headerlink" title="V2Ray 协议列表"></a>V2Ray 协议列表</h1><p>V2Ray 支持以下协议：</p><ul><li><p><a href="https://www.v2ray.com/chapter_02/protocols/blackhole.html" target="_blank" rel="noopener">Blackhole</a></p></li><li><p><a href="https://www.v2ray.com/chapter_02/protocols/dokodemo.html" target="_blank" rel="noopener">Dokodemo-door</a></p></li><li><p><a href="https://www.v2ray.com/chapter_02/protocols/freedom.html" target="_blank" rel="noopener">Freedom</a></p></li><li><p><a href="https://www.v2ray.com/chapter_02/protocols/http.html" target="_blank" rel="noopener">HTTP</a></p></li><li><p><a href="https://www.v2ray.com/chapter_02/protocols/mtproto.html" target="_blank" rel="noopener">MTProto</a></p></li><li><p><a href="https://www.v2ray.com/chapter_02/protocols/shadowsocks.html" target="_blank" rel="noopener">Shadowsocks</a></p></li><li><p><a href="https://www.v2ray.com/chapter_02/protocols/socks.html" target="_blank" rel="noopener">Socks</a></p></li><li><p><a href="https://www.v2ray.com/chapter_02/protocols/vmess.html" target="_blank" rel="noopener">VMess</a></p></li></ul><h1 id="Blackhole"><a href="#Blackhole" class="headerlink" title="Blackhole"></a>Blackhole</h1><ul><li><p>名称: <code>blackhole</code></p></li><li><p>类型: 出站协议</p></li></ul><p>Blackhole（黑洞）是一个出站数据协议，它会阻碍所有数据的出站，配合<a href="https://www.v2ray.com/chapter_02/03_routing.html" target="_blank" rel="noopener">路由（Routing）</a>一起使用，可以达到禁止访问某些网站的效果。</p><h2 id="OutboundConfigurationObject"><a href="#OutboundConfigurationObject" class="headerlink" title="OutboundConfigurationObject"></a>OutboundConfigurationObject</h2><pre><code>{  "response": {    "type": "none"  }}</code></pre><blockquote><p><code>response</code>: <a href="https://www.v2ray.com/chapter_02/protocols/blackhole.html#responseobject" target="_blank" rel="noopener">ResponseObject</a></p></blockquote><p>配置黑洞的响应数据。Blackhole 会在收到待转发数据之后，发送指定的响应数据，然后关闭连接。待转发的数据将被丢弃。如不指定此项，Blackhole 将直接关闭连接。</p><h3 id="ResponseObject"><a href="#ResponseObject" class="headerlink" title="ResponseObject"></a>ResponseObject</h3><pre><code>{  "type": "none"}</code></pre><blockquote><p><code>type</code>: “http” | “none”</p></blockquote><p>当<code>type</code>为<code>"none"</code>（默认值）时，Blackhole将直接关闭连接。当<code>type</code>为<code>"http"</code>时，Blackhole会发回一个简单的 HTTP 403 数据包，然后关闭连接。</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><ul><li><p>名称: <code>dns</code></p></li><li><p>类型: 出站协议</p></li></ul><p>DNS 是一个出站协议，主要用于拦截和转发 DNS 查询。此出站协议只能接收 DNS 流量（包含基于 UDP 和 TCP 协议的查询），其它类型的流量会导致错误。</p><p>在处理 DNS 查询时，此出站协议会将 IP 查询（即 A 和 AAAA）转发给内置的 <a href="https://www.v2ray.com/chapter_02/04_dns.html" target="_blank" rel="noopener">DNS 服务器</a>。其它类型的查询流量将被转发至它们原本的目标地址。</p><h2 id="OutboundConfigurationObject-1"><a href="#OutboundConfigurationObject-1" class="headerlink" title="OutboundConfigurationObject"></a>OutboundConfigurationObject</h2><pre><code>{    "network": "tcp",    "address": "1.1.1.1",    "port": 53}</code></pre><blockquote><p><code>network</code>: “tcp” | “udp”</p></blockquote><p>(V2Ray 4.16+) 修改 DNS 流量的传输层协议，可选的值有<code>"tcp"</code>和<code>"udp"</code>。当不指定时，保持来源的传输方式不变。</p><blockquote><p><code>address</code>: address</p></blockquote><p>(V2Ray 4.16+) 修改 DNS 服务器地址。当不指定时，保持来源中指定的地址不变。</p><blockquote><p><code>port</code>: number</p></blockquote><p>(V2Ray 4.16+) 修改 DNS 服务器端口。当不指定时，保持来源中指定的端口不变。</p><h1 id="Dokodemo-door"><a href="#Dokodemo-door" class="headerlink" title="Dokodemo-door"></a>Dokodemo-door</h1><ul><li><p>名称: <code>dokodemo-door</code></p></li><li><p>类型: 入站协议</p></li></ul><p>Dokodemo door（任意门）是一个入站数据协议，它可以监听一个本地端口，并把所有进入此端口的数据发送至指定服务器的一个端口，从而达到端口映射的效果。</p><h2 id="InboundConfigurationObject"><a href="#InboundConfigurationObject" class="headerlink" title="InboundConfigurationObject"></a>InboundConfigurationObject</h2><pre><code>{  "address": "8.8.8.8",  "port": 53,  "network": "tcp",  "timeout": 0,  "followRedirect": false,  "userLevel": 0}</code></pre><blockquote><p><code>address</code>: address</p></blockquote><p>将流量转发到此地址。可以是一个 IP 地址，形如<code>"1.2.3.4"</code>，或者一个域名，形如<code>"v2ray.com"</code>。字符串类型。</p><p>当 <code>followRedirect</code>（见下文）为 <code>true</code> 时，<code>address</code> 可为空。</p><blockquote><p><code>port</code>: number</p></blockquote><p>将流量转发到目标地址的指定端口，范围[1, 65535]，数值类型。必填参数。</p><blockquote><p><code>network</code>: “tcp” | “udp” | “tcp,udp”</p></blockquote><p>可接收的网络协议类型。比如当指定为<code>"tcp"</code>时，任意门仅会接收 TCP 流量。默认值为<code>"tcp"</code>。</p><blockquote><p><code>timeout</code>: number</p></blockquote><p>入站数据的时间限制（秒），默认值为 300。</p><p>V2Ray 3.1 后等价于对应用户等级的 <code>connIdle</code> 策略</p><blockquote><p><code>followRedirect</code>: true | false</p></blockquote><p>当值为<code>true</code>时，dokodemo-door 会识别出由 iptables 转发而来的数据，并转发到相应的目标地址。详见<a href="https://www.v2ray.com/chapter_02/05_transport.html" target="_blank" rel="noopener">传输配置</a>中的<code>tproxy</code>设置。</p><blockquote><p><code>userLevel</code>: number</p></blockquote><p>用户等级，所有连接都会使用这个用户等级。</p><h2 id="透明代理配置样例"><a href="#透明代理配置样例" class="headerlink" title="透明代理配置样例"></a>透明代理配置样例</h2><p>V2Ray 中增加一个 dokodemo-door 的入站协议：</p><pre><code>{  "network": "tcp,udp",  "timeout": 30,  "followRedirect": true}</code></pre><p>配置 iptables：</p><pre><code># Create new chainiptables -t nat -N V2RAYiptables -t mangle -N V2RAYiptables -t mangle -N V2RAY_MARK# Ignore your V2Ray server's addresses# It's very IMPORTANT, just be careful.iptables -t nat -A V2RAY -d 123.123.123.123 -j RETURN# Ignore LANs and any other addresses you'd like to bypass the proxy# See Wikipedia and RFC5735 for full list of reserved networks.iptables -t nat -A V2RAY -d 0.0.0.0/8 -j RETURNiptables -t nat -A V2RAY -d 10.0.0.0/8 -j RETURNiptables -t nat -A V2RAY -d 127.0.0.0/8 -j RETURNiptables -t nat -A V2RAY -d 169.254.0.0/16 -j RETURNiptables -t nat -A V2RAY -d 172.16.0.0/12 -j RETURNiptables -t nat -A V2RAY -d 192.168.0.0/16 -j RETURNiptables -t nat -A V2RAY -d 224.0.0.0/4 -j RETURNiptables -t nat -A V2RAY -d 240.0.0.0/4 -j RETURN# Anything else should be redirected to Dokodemo-door's local portiptables -t nat -A V2RAY -p tcp -j REDIRECT --to-ports 12345# Add any UDP rulesip route add local default dev lo table 100ip rule add fwmark 1 lookup 100iptables -t mangle -A V2RAY -p udp --dport 53 -j TPROXY --on-port 12345 --tproxy-mark 0x01/0x01iptables -t mangle -A V2RAY_MARK -p udp --dport 53 -j MARK --set-mark 1# Apply the rulesiptables -t nat -A OUTPUT -p tcp -j V2RAYiptables -t mangle -A PREROUTING -j V2RAYiptables -t mangle -A OUTPUT -j V2RAY_MARK</code></pre><h1 id="Freedom"><a href="#Freedom" class="headerlink" title="Freedom"></a>Freedom</h1><ul><li><p>名称：<code>freedom</code></p></li><li><p>类型：出站协议</p></li></ul><p>Freedom 是一个出站协议，可以用来向任意网络发送（正常的） TCP 或 UDP 数据。</p><h2 id="OutboundConfigurationObject-2"><a href="#OutboundConfigurationObject-2" class="headerlink" title="OutboundConfigurationObject"></a>OutboundConfigurationObject</h2><pre><code>{  "domainStrategy": "AsIs",  "redirect": "127.0.0.1:3366",  "userLevel": 0}</code></pre><blockquote><p><code>domainStrategy</code>: “AsIs” | “UseIP” | “UseIPv4” | “UseIPv6”</p></blockquote><p>在目标地址为域名时，Freedom 可以直接向此域名发出连接（<code>"AsIs"</code>），或者将域名解析为 IP 之后再建立连接（<code>"UseIP"</code>、<code>"UseIPv4"</code>、<code>"UseIPv6"</code>）。解析 IP 的步骤会使用 V2Ray <a href="https://www.v2ray.com/chapter_02/04_dns.html" target="_blank" rel="noopener">内建的 DNS</a>。默认值为<code>"AsIs"</code>。</p><p>(V2Ray 4.6+) 当使用<code>"UseIP"</code>模式，并且<a href="https://www.v2ray.com/chapter_02/01_overview.html#outboundobject" target="_blank" rel="noopener">出站连接配置</a>中指定了<code>sendThrough</code>时，Freedom 会根据<code>sendThrough</code>的值自动判断所需的IP类型，IPv4 或 IPv6。</p><p>(V2Ray 4.7+) 当使用<code>"UseIPv4"</code>或<code>"UseIPv6"</code>模式时，Freedom 会只使用对应的 IPv4 或 IPv6 地址。当<code>sendThrough</code>指定了不匹配的本地地址时，将导致连接失败。</p><blockquote><p><code>redirect</code>: address_port</p></blockquote><p>Freedom 会强制将所有数据发送到指定地址（而不是入站协议指定的地址）。其值为一个字符串，样例：<code>"127.0.0.1:80"</code>, <code>":1234"</code>。当地址不指定时，如<code>":443"</code>，Freedom 不会修改原先的目标地址。当端口为<code>0</code>时，如<code>"v2ray.com:0"</code>，Freedom 不会修改原先的端口。</p><blockquote><p><code>userLevel</code>: number</p></blockquote><p>用户等级，所有连接都使用这一等级。</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><ul><li><p>名称：<code>http</code></p></li><li><p>类型：入站 / 出站</p></li></ul><p>HTTP 的配置分为两部分，<code>InboundConfigurationObject</code>和<code>OutboundConfigurationObject</code>，分别对应入站和出站协议配置中的<code>settings</code>项。</p><h2 id="InboundConfigurationObject-1"><a href="#InboundConfigurationObject-1" class="headerlink" title="InboundConfigurationObject"></a>InboundConfigurationObject</h2><pre><code>{  "timeout": 0,  "accounts": [    {      "user": "my-username",      "pass": "my-password"    }  ],  "allowTransparent": false,  "userLevel": 0}</code></pre><p>应该注意，虽然<code>http inbound</code>可以提供公共服务，但http协议没有对传输加密，不适宜经公网中传输，更容易成为被人用作攻击的肉鸡。<code>http inbound</code>更有意义的用法是在局域网或本机环境下监听，为其他程序提供本地服务。</p><blockquote><p><code>timeout</code>: number</p></blockquote><p>从客户端读取数据的超时设置（秒），0 表示不限时。默认值为 300。 V2Ray 3.1 后等价于对应用户等级的 <code>connIdle</code> 策略。</p><blockquote><p><code>accounts</code>: [<a href="https://www.v2ray.com/chapter_02/protocols/http.html#accountobject" target="_blank" rel="noopener">AccountObject</a>]</p></blockquote><p>一个数组，数组中每个元素为一个用户帐号。默认值为空。</p><p>当 <code>accounts</code> 非空时，HTTP 代理将对入站连接进行 Basic Authentication 验证。</p><blockquote><p><code>allowTransparent</code>: true | false</p></blockquote><p>当为<code>true</code>时，会转发所有 HTTP 请求，而非只是代理请求。若配置不当，开启此选项会导致死循环。</p><blockquote><p><code>userLevel</code>: number</p></blockquote><p>用户等级，所有连接使用这一等级。</p><h3 id="AccountObject"><a href="#AccountObject" class="headerlink" title="AccountObject"></a>AccountObject</h3><pre><code>{  "user": "my-username",  "pass": "my-password"}</code></pre><blockquote><p><code>user</code>: string</p></blockquote><p>用户名，字符串类型。必填。</p><blockquote><p><code>pass</code>: string</p></blockquote><p>密码，字符串类型。必填。</p><p>在 Linux 中使用以下环境变量即可在当前 session 使用全局 HTTP 代理（很多软件都支持这一设置，也有不支持的）。</p><ul><li><p><code>export http_proxy=http://127.0.0.1:8080/</code> (地址须改成你配置的 HTTP 入站代理地址)</p></li><li><p><code>export https_proxy=$http_proxy</code></p></li></ul><h2 id="OutboundConfigurationObject-3"><a href="#OutboundConfigurationObject-3" class="headerlink" title="OutboundConfigurationObject"></a>OutboundConfigurationObject</h2><pre><code>{  "servers": [    {      "address": "192.168.108.1",      "port": 3128,      "users": [        {          "user": "my-username",          "pass": "my-password"        }      ]    }  ]}</code></pre><p>(V2ray 4.21.0+)</p><p>应该注意，虽然<code>http outbound</code>可以作为对外访问的配置，但<code>http proxy</code>协议没有对传输加密，不适宜经公网中传输，且因不支持udp传输将会导致core功能受限（Routing过程的的DNS查询不可用）。<code>http outbound</code>更有意义的用法是在特殊情况下，只能使用<code>http proxy</code>对外访问内部网络中，作为为其他协议连接代理服务器的前置代理使用（见<code>OutboundObject</code>的<code>ProxySettingsObject</code>）。另因<code>http proxy</code>只能代理tcp协议，udp系的协议均不能通过。</p><p>(V2ray 4.21.1+)</p><p>4.20.0版本中引入了http outbound作为其他协议的前置代理用法中，缺乏了对tls配置的支持。4.21.1的补丁版本中对<code>streamSettings</code>中的<code>security</code>和<code>tlsSettings</code>保留生效。目前前置代理的用法中，vmess/tcp、vmess/tcp-tls和shadowsocks等三种协议方式可使用，其他传输协议的前置代理用法需后续版本开发支持。</p><blockquote><p><code>servers</code>: 数组</p></blockquote><p>HTTP代理服务器配置，若配置多个，循环使用 (RoundRobin)。</p><blockquote><p><code>address</code>: string</p></blockquote><p>HTTP代理服务器地址，必填。</p><blockquote><p><code>port</code>: int</p></blockquote><p>HTTP代理服务器端口，必填。</p><blockquote><p><code>user</code>: [<a href="https://www.v2ray.com/chapter_02/protocols/http.html#accountobject" target="_blank" rel="noopener">AccountObject</a>]</p></blockquote><p>一个数组，数组中每个元素为一个用户帐号。默认值为空。</p><h1 id="MTProto"><a href="#MTProto" class="headerlink" title="MTProto"></a>MTProto</h1><ul><li><p>名称: <code>mtproto</code></p></li><li><p>类型: 入站 / 出站</p></li></ul><p>MTProto 是一个 Telegram 专用的代理协议。在 V2Ray 中可使用一组入站出站代理来完成 Telegram 数据的代理任务。</p><p>目前只支持转发到 Telegram 的 IPv4 地址。</p><h2 id="InboundConfigurationObject-2"><a href="#InboundConfigurationObject-2" class="headerlink" title="InboundConfigurationObject"></a>InboundConfigurationObject</h2><pre><code>{  "users": [{    "email": "love@v2ray.com",    "level": 0,    "secret": "b0cbcef5a486d9636472ac27f8e11a9d"  }]}</code></pre><blockquote><p><code>users</code>: [<a href="https://www.v2ray.com/chapter_02/protocols/mtproto.html#userobject" target="_blank" rel="noopener">UserObject</a>]</p></blockquote><p>一个数组，其中每一个元素表示一个用户。目前只有第一个用户会生效。</p><h3 id="UserObject"><a href="#UserObject" class="headerlink" title="UserObject"></a>UserObject</h3><pre><code>{  "email": "love@v2ray.com",  "level": 0,  "secret": "b0cbcef5a486d9636472ac27f8e11a9d"}</code></pre><blockquote><p><code>email</code>: string</p></blockquote><p>用户邮箱，用于统计流量等辅助功能</p><blockquote><p><code>level</code>: number</p></blockquote><p>用户等级。</p><blockquote><p><code>secret</code>: string</p></blockquote><p>用户密钥。必须为 32 个字符，仅可包含<code>0</code>到<code>9</code>和<code>a</code>到<code>f</code>之间的字符。</p><p>使用此命令生成 MTProto 代理所需要的用户密钥：<code>openssl rand -hex 16</code></p><h2 id="OutboundConfigurationObject-4"><a href="#OutboundConfigurationObject-4" class="headerlink" title="OutboundConfigurationObject"></a>OutboundConfigurationObject</h2><pre><code>{}</code></pre><h2 id="样例配置"><a href="#样例配置" class="headerlink" title="样例配置"></a>样例配置</h2><p>MTProto 仅可用于 Telegram 数据。你可能需要一个路由来绑定对应的入站出站代理。以下是一个不完整的示例：</p><p>入站代理：</p><pre><code>{  "tag": "tg-in",  "port": 443,  "protocol": "mtproto",  "settings": {    "users": [{"secret": "b0cbcef5a486d9636472ac27f8e11a9d"}]  }}</code></pre><p>出站代理：</p><pre><code>{  "tag": "tg-out",  "protocol": "mtproto",  "settings": {}}</code></pre><p>路由：</p><pre><code>{  "type": "field",  "inboundTag": ["tg-in"],  "outboundTag": "tg-out"}</code></pre><p>然后使用 Telegram 连接这台机器的 443 端口即可。</p><h1 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h1><ul><li><p>名称：<code>shadowsocks</code></p></li><li><p>类型：入站 / 出站</p></li></ul><p><a href="https://zh.wikipedia.org/wiki/Shadowsocks" target="_blank" rel="noopener">Shadowsocks</a> 协议，包含入站和出站两部分，兼容大部分其它版本的实现。</p><p>与官方版本的兼容性：</p><ul><li><p>支持 TCP 和 UDP 数据包转发，其中 UDP 可选择性关闭；</p></li><li><p>支持 </p><p>OTA</p><p>；</p><ul><li>客户端可选开启或关闭；</li></ul></li><li><p>服务器端可强制开启、关闭或自适应；</p></li><li><p>加密方式（其中 </p><p>AEAD</p><p> 加密方式在 V2Ray 3.0 中加入）：</p><ul><li>aes-256-cfb</li></ul></li><li><p>aes-128-cfb</p></li><li><p>chacha20</p></li><li><p>chacha20-ietf</p></li><li><p>aes-256-gcm</p></li><li><p>aes-128-gcm</p></li><li><p>chacha20-poly1305 或称 chacha20-ietf-poly1305</p></li><li><p>插件：</p><ul><li>通过 Standalone 模式支持 obfs</li></ul></li></ul><p>Shadowsocks 的配置分为两部分，<code>InboundConfigurationObject</code>和<code>OutboundConfigurationObject</code>，分别对应入站和出站协议配置中的<code>settings</code>项。</p><h2 id="InboundConfigurationObject-3"><a href="#InboundConfigurationObject-3" class="headerlink" title="InboundConfigurationObject"></a>InboundConfigurationObject</h2><pre><code>{  "email": "love@v2ray.com",  "method": "aes-128-cfb",  "password": "密码",  "level": 0,  "ota": true,  "network": "tcp"}</code></pre><blockquote><p><code>email</code>: string</p></blockquote><p>邮件地址，可选，用于标识用户</p><blockquote><p><code>method</code>: string</p></blockquote><p>必填。可选的值见<a href="https://www.v2ray.com/chapter_02/protocols/shadowsocks.html#encryption-list" target="_blank" rel="noopener">加密方式列表</a></p><blockquote><p><code>password</code>: string</p></blockquote><p>必填，任意字符串。Shadowsocks 协议不限制密码长度，但短密码会更可能被破解，建议使用 16 字符或更长的密码。</p><blockquote><p><code>level</code>: number</p></blockquote><p>用户等级，默认值为 <code>0</code>。详见<a href="https://www.v2ray.com/chapter_02/policy.html" target="_blank" rel="noopener">本地策略</a>。</p><blockquote><p><code>ota</code>: true | false</p></blockquote><p>是否强制 OTA，如果不指定此项，则自动判断。强制开启 OTA 后，V2Ray 会拒绝未启用 OTA 的连接。反之亦然。</p><p>当使用 AEAD 时，<code>ota</code> 设置无效</p><blockquote><p><code>network</code>: “tcp” | “udp” | “tcp,udp”</p></blockquote><p>可接收的网络连接类型，默认值为<code>"tcp"</code>。</p><h2 id="OutboundConfigurationObject-5"><a href="#OutboundConfigurationObject-5" class="headerlink" title="OutboundConfigurationObject"></a>OutboundConfigurationObject</h2><pre><code>{  "servers": [    {      "email": "love@v2ray.com",      "address": "127.0.0.1",      "port": 1234,      "method": "加密方式",      "password": "密码",      "ota": false,      "level": 0    }  ]}</code></pre><blockquote><p><code>servers</code>: [<a href="https://www.v2ray.com/chapter_02/protocols/shadowsocks.html#serverobject" target="_blank" rel="noopener">ServerObject</a>]</p></blockquote><p>一个数组，其中每一项是一个 <a href="https://www.v2ray.com/chapter_02/protocols/shadowsocks.html#serverobject" target="_blank" rel="noopener">ServerObject</a>。</p><h3 id="ServerObject"><a href="#ServerObject" class="headerlink" title="ServerObject"></a>ServerObject</h3><pre><code>{  "email": "love@v2ray.com",  "address": "127.0.0.1",  "port": 1234,  "method": "加密方式",  "password": "密码",  "ota": false,  "level": 0}</code></pre><blockquote><p><code>email</code>: string</p></blockquote><p>邮件地址，可选，用于标识用户</p><blockquote><p><code>address</code>: address</p></blockquote><p>Shadowsocks 服务器地址，支持 IPv4、IPv6 和域名。必填。</p><blockquote><p><code>port</code>: number</p></blockquote><p>Shadowsocks 服务器端口。必填。</p><blockquote><p><code>method</code>: string</p></blockquote><p>必填。可选的值见<a href="https://www.v2ray.com/chapter_02/protocols/shadowsocks.html#encryption-list" target="_blank" rel="noopener">加密方式列表</a></p><blockquote><p><code>password</code>: string</p></blockquote><p>必填。任意字符串。Shadowsocks 协议不限制密码长度，但短密码会更可能被破解，建议使用 16 字符或更长的密码。</p><blockquote><p><code>ota</code>: true | false</p></blockquote><p>是否开启 Shadowsocks 的一次验证（One time auth），默认值为<code>false</code>。</p><p>当使用 AEAD 时，<code>ota</code> 设置无效。</p><blockquote><p><code>level</code>: number</p></blockquote><p>用户等级</p><h2 id="加密方式列表"><a href="#加密方式列表" class="headerlink" title="加密方式列表"></a>加密方式列表</h2><ul><li><p><code>"aes-256-cfb"</code></p></li><li><p><code>"aes-128-cfb"</code></p></li><li><p><code>"chacha20"</code></p></li><li><p><code>"chacha20-ietf"</code></p></li><li><p><code>"aes-256-gcm"</code></p></li><li><p><code>"aes-128-gcm"</code></p></li><li><p><code>"chacha20-poly1305"</code> 或 <code>"chacha20-ietf-poly1305"</code></p></li></ul><h1 id="Socks"><a href="#Socks" class="headerlink" title="Socks"></a>Socks</h1><ul><li><p>名称：<code>socks</code></p></li><li><p>类型：入站 / 出站</p></li></ul><p>标准 Socks 协议实现，兼容 <a href="http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol" target="_blank" rel="noopener">Socks 4</a>、Socks 4a 和 <a href="http://ftp.icm.edu.pl/packages/socks/socks4/SOCKS4.protocol" target="_blank" rel="noopener">Socks 5</a>。</p><p>Socks 的配置分为两部分，<code>InboundConfigurationObject</code>和<code>OutboundConfigurationObject</code>，分别对应入站和出站协议配置中的<code>settings</code>项。</p><h2 id="OutboundConfigurationObject-6"><a href="#OutboundConfigurationObject-6" class="headerlink" title="OutboundConfigurationObject"></a>OutboundConfigurationObject</h2><pre><code>{  "servers": [{    "address": "127.0.0.1",    "port": 1234,    "users": [      {        "user": "test user",        "pass": "test pass",        "level": 0      }    ]  }]}</code></pre><p>应该注意，虽然socks outbound可以作为对外访问的配置，但socks协议没有对传输加密，不适宜经公网中传输。socks outbound 更有意义的用法是在特殊情况下，只能使用socks proxy对外访问内部网络中，作为为其他协议连接代理服务器的前置代理使用（见<code>OutboundObject</code>的<code>ProxySettingsObject</code>）。</p><blockquote><p><code>servers</code>: [ <a href="https://www.v2ray.com/chapter_02/protocols/socks.html#serverobject" target="_blank" rel="noopener">ServerObject</a> ]</p></blockquote><p>Socks 服务器列表，其中每一项是一个服务器配置。</p><h3 id="ServerObject-1"><a href="#ServerObject-1" class="headerlink" title="ServerObject"></a>ServerObject</h3><pre><code>{  "address": "127.0.0.1",  "port": 1234,  "users": [    {      "user": "test user",      "pass": "test pass",      "level": 0    }  ]}</code></pre><blockquote><p><code>address</code>: address</p></blockquote><p>服务器地址。</p><p>仅支持连接到 Socks 5 服务器。</p><blockquote><p><code>port</code>: number</p></blockquote><p>服务器端口</p><blockquote><p><code>users</code>: [ <a href="https://www.v2ray.com/chapter_02/protocols/socks.html#userobject" target="_blank" rel="noopener">UserObject</a> ]</p></blockquote><p>用户列表，其中每一项一个用户配置。当列表不为空时，Socks 客户端会使用此用户信息进行认证；如未指定，则不进行认证。</p><h3 id="UserObject-1"><a href="#UserObject-1" class="headerlink" title="UserObject"></a>UserObject</h3><pre><code>{  "user": "test user",  "pass": "test pass",  "level": 0}</code></pre><blockquote><p><code>user</code>: string</p></blockquote><p>用户名</p><blockquote><p><code>pass</code>: string</p></blockquote><p>密码</p><blockquote><p><code>level</code>: number</p></blockquote><p>用户等级</p><h2 id="InboundConfigurationObject-4"><a href="#InboundConfigurationObject-4" class="headerlink" title="InboundConfigurationObject"></a>InboundConfigurationObject</h2><p>应该注意，虽然socks inbound可以公共服务端口，但socks协议没有对传输加密，不适宜经公网中传输。socks inbound更有意义的用法是在局域网或本机环境下，为其他程序提供本地服务。</p><pre><code>{  "auth": "noauth",  "accounts": [    {      "user": "my-username",      "pass": "my-password"    }  ],  "udp": false,  "ip": "127.0.0.1",  "userLevel": 0}</code></pre><blockquote><p><code>auth</code>: “noauth” | “password”</p></blockquote><p>Socks 协议的认证方式，支持<code>"noauth"</code>匿名方式和<code>"password"</code>用户密码方式。默认值为<code>"noauth"</code>。</p><blockquote><p><code>accounts</code>: [ <a href="https://www.v2ray.com/chapter_02/protocols/socks.html#accountobject" target="_blank" rel="noopener">AccountObject</a> ]</p></blockquote><p>一个数组，数组中每个元素为一个用户帐号。默认值为空。此选项仅当 <code>auth</code> 为 <code>password</code> 时有效。</p><blockquote><p><code>udp</code>: true | false</p></blockquote><p>是否开启 UDP 协议的支持。默认值为 <code>false</code>。</p><blockquote><p><code>ip</code>: address</p></blockquote><p>当开启 UDP 时，V2Ray 需要知道本机的 IP 地址。默认值为<code>"127.0.0.1"</code>。</p><blockquote><p><code>userLevel</code>: number</p></blockquote><p>用户等级，所有连接使用这一等级。</p><h3 id="AccountObject-1"><a href="#AccountObject-1" class="headerlink" title="AccountObject"></a>AccountObject</h3><pre><code>{  "user": "my-username",  "pass": "my-password"}</code></pre><blockquote><p><code>user</code>: string</p></blockquote><p>用户名</p><blockquote><p><code>pass</code>: string</p></blockquote><p>密码</p><h1 id="VMess"><a href="#VMess" class="headerlink" title="VMess"></a>VMess</h1><ul><li><p>名称：<code>vmess</code></p></li><li><p>类型：入站 / 出站</p></li></ul><p><a href="https://www.v2ray.com/developer/protocols/vmess.html" target="_blank" rel="noopener">VMess</a> 是一个加密传输协议，它分为入站和出站两部分，通常作为 V2Ray 客户端和服务器之间的桥梁。</p><p>VMess 依赖于系统时间，请确保使用 V2Ray 的系统 UTC 时间误差在 90 秒之内，时区无关。在 Linux 系统中可以安装<code>ntp</code>服务来自动同步系统时间。</p><p>VMess 的配置分为两部分，<code>InboundConfigurationObject</code>和<code>OutboundConfigurationObject</code>，分别对应入站和出站协议配置中的<code>settings</code>项。</p><h2 id="OutboundConfigurationObject-7"><a href="#OutboundConfigurationObject-7" class="headerlink" title="OutboundConfigurationObject"></a>OutboundConfigurationObject</h2><pre><code>{  "vnext": [    {      "address": "127.0.0.1",      "port": 37192,      "users": [        {          "id": "27848739-7e62-4138-9fd3-098a63964b6b",          "alterId": 4,          "security": "auto",          "level": 0        }      ]    }  ]}</code></pre><blockquote><p><code>vnext</code>：[ <a href="https://www.v2ray.com/chapter_02/protocols/vmess.html#serverobject" target="_blank" rel="noopener">ServerObject</a> ]</p></blockquote><p>一个数组，包含一系列的服务器配置</p><h3 id="ServerObject-2"><a href="#ServerObject-2" class="headerlink" title="ServerObject"></a>ServerObject</h3><pre><code>{  "address": "127.0.0.1",  "port": 37192,  "users": []}</code></pre><blockquote><p><code>address</code>: address</p></blockquote><p>服务器地址，支持 IP 地址或者域名。</p><blockquote><p><code>port</code>: number</p></blockquote><p>服务器端口号。</p><blockquote><p><code>users</code>: [ <a href="https://www.v2ray.com/chapter_02/protocols/vmess.html#userobject" target="_blank" rel="noopener">UserObject</a> ]</p></blockquote><p>一组服务器认可的用户</p><h3 id="UserObject-2"><a href="#UserObject-2" class="headerlink" title="UserObject"></a>UserObject</h3><pre><code>{  "id": "27848739-7e62-4138-9fd3-098a63964b6b",  "alterId": 4,  "security": "auto",  "level": 0}</code></pre><blockquote><p><code>id</code>：string</p></blockquote><p>VMess 用户的主 ID。必须是一个合法的 UUID。</p><blockquote><p><code>alterId</code>：number</p></blockquote><p>为了进一步防止被探测，一个用户可以在主 ID 的基础上，再额外生成多个 ID。这里只需要指定额外的 ID 的数量，推荐值为 4。不指定的话，默认值是 <code>0</code>。最大值 <code>65535</code>。这个值不能超过服务器端所指定的值。</p><blockquote><p><code>level</code>: number</p></blockquote><p>用户等级</p><blockquote><p><code>security</code>: “aes-128-gcm” | “chacha20-poly1305” | “auto” | “none”</p></blockquote><p>加密方式，客户端将使用配置的加密方式发送数据，服务器端自动识别，无需配置。</p><ul><li><p><code>"aes-128-gcm"</code>：推荐在 PC 上使用</p></li><li><p><code>"chacha20-poly1305"</code>：推荐在手机端使用</p></li><li><p><code>"auto"</code>：默认值，自动选择（运行框架为 AMD64、ARM64 或 s390x 时为aes-128-gcm加密方式，其他情况则为 Chacha20-Poly1305 加密方式）</p></li><li><p><code>"none"</code>：不加密</p></li></ul><p>推荐使用<code>"auto"</code>加密方式，这样可以永久保证安全性和兼容性。</p><h2 id="InboundConfigurationObject-5"><a href="#InboundConfigurationObject-5" class="headerlink" title="InboundConfigurationObject"></a>InboundConfigurationObject</h2><pre><code>{  "clients": [    {      "id": "27848739-7e62-4138-9fd3-098a63964b6b",      "level": 0,      "alterId": 4,      "email": "love@v2ray.com"    }  ],  "default": {    "level": 0,    "alterId": 4  },  "detour": {    "to": "tag_to_detour"  },  "disableInsecureEncryption": false}</code></pre><blockquote><p><code>clients</code>: [ <a href="https://www.v2ray.com/chapter_02/protocols/vmess.html#clientobject" target="_blank" rel="noopener">ClientObject</a> ]</p></blockquote><p>一组服务器认可的用户。clients 可以为空。当此配置用作动态端口时，V2Ray 会自动创建用户。</p><blockquote><p><code>detour</code>: <a href="https://www.v2ray.com/chapter_02/protocols/vmess.html#detourobject" target="_blank" rel="noopener">DetourObject</a></p></blockquote><p>指示对应的出站协议使用另一个服务器。</p><blockquote><p><code>default</code>: <a href="https://www.v2ray.com/chapter_02/protocols/vmess.html#defaultobject" target="_blank" rel="noopener">DefaultObject</a></p></blockquote><p>可选，clients 的默认配置。仅在配合<code>detour</code>时有效。</p><blockquote><p><code>disableInsecureEncryption</code>: true | false</p></blockquote><p>是否禁止客户端使用不安全的加密方式，当客户端指定下列加密方式时，服务器会主动断开连接。默认值为<code>false</code>。</p><ul><li><p><code>"none"</code></p></li><li><p><code>"aes-128-cfb"</code></p></li></ul><h3 id="ClientObject"><a href="#ClientObject" class="headerlink" title="ClientObject"></a>ClientObject</h3><pre><code>{  "id": "27848739-7e62-4138-9fd3-098a63964b6b",  "level": 0,  "alterId": 4,  "email": "love@v2ray.com"}</code></pre><blockquote><p><code>id</code>: string</p></blockquote><p>VMess 的用户 ID。必须是一个合法的 UUID。</p><blockquote><p><code>level</code>: number</p></blockquote><p>用户等级，详见<a href="https://www.v2ray.com/chapter_02/policy.html" target="_blank" rel="noopener">本地策略</a></p><blockquote><p><code>alterId</code>: number</p></blockquote><p>与上文出站协议中的含义相同。</p><blockquote><p><code>email</code>: string</p></blockquote><p>用户邮箱地址，用于区分不同用户的流量。</p><p><code>alterId</code> 取值的大小和流量特征没有必然联系。对于日常使用，<code>16</code> 以内的值已经够用了。</p><h3 id="DetourObject"><a href="#DetourObject" class="headerlink" title="DetourObject"></a>DetourObject</h3><pre><code>{  "to": "tag_to_detour"}</code></pre><blockquote><p><code>to</code>: string</p></blockquote><p>一个入站协议的<code>tag</code>，详见<a href="https://www.v2ray.com/chapter_02/02_protocols.html" target="_blank" rel="noopener">配置文件</a>。指定的入站协议必须是一个 VMess</p><h3 id="DefaultObject"><a href="#DefaultObject" class="headerlink" title="DefaultObject"></a>DefaultObject</h3><pre><code>{  "level": 0,  "alterId": 4}</code></pre><blockquote><p><code>level</code>: number</p></blockquote><p>用户等级，意义同上。默认值为<code>0</code>。</p><blockquote><p><code>alterId</code>: number</p></blockquote><p>和<code>ClientObject</code>中的<code>alterId</code>相同，默认值为<code>64</code>。推荐值<code>4</code>。</p><h1 id="本地策略"><a href="#本地策略" class="headerlink" title="本地策略"></a>本地策略</h1><p>本地策略可以配置一些用户相关的权限，比如连接超时设置。V2Ray 处理的每一个连接，都对应到一个用户，按照这个用户的等级（level）应用不同的策略。本地策略可按照等级的不同而变化。</p><h2 id="PolicyObject"><a href="#PolicyObject" class="headerlink" title="PolicyObject"></a>PolicyObject</h2><p><code>PolicyObject</code>对应配置文件中的<code>policy</code>项。</p><pre><code>{  "levels": {    "0": {      "handshake": 4,      "connIdle": 300,      "uplinkOnly": 2,      "downlinkOnly": 5,      "statsUserUplink": false,      "statsUserDownlink": false,      "bufferSize": 10240    }  },  "system": {    "statsInboundUplink": false,    "statsInboundDownlink": false  }}</code></pre><blockquote><p><code>level</code>: map{string: <a href="https://www.v2ray.com/chapter_02/policy.html#levelpolicyobject" target="_blank" rel="noopener">LevelPolicyObject</a>}</p></blockquote><p>一组键值对，每个键是一个字符串形式的数字（JSON 的要求），比如 <code>"0"</code>、<code>"1"</code> 等，双引号不能省略，这个数字对应用户等级。每一个值是一个 <a href="https://www.v2ray.com/chapter_02/policy.html#levelpolicyobject" target="_blank" rel="noopener">LevelPolicyObject</a>.</p><p>每个入站出站代理现在都可以设置用户等级，V2Ray 会根据实际的用户等级应用不同的本地策略。</p><blockquote><p><code>system</code>: <a href="https://www.v2ray.com/chapter_02/policy.html#systempolicyobject" target="_blank" rel="noopener">SystemPolicyObject</a></p></blockquote><p>V2Ray 系统的策略</p><h3 id="LevelPolicyObject"><a href="#LevelPolicyObject" class="headerlink" title="LevelPolicyObject"></a>LevelPolicyObject</h3><pre><code>{  "handshake": 4,  "connIdle": 300,  "uplinkOnly": 2,  "downlinkOnly": 5,  "statsUserUplink": false,  "statsUserDownlink": false,  "bufferSize": 10240}</code></pre><blockquote><p><code>handshake</code>: number</p></blockquote><p>连接建立时的握手时间限制。单位为秒。默认值为<code>4</code>。在入站代理处理一个新连接时，在握手阶段（比如 VMess 读取头部数据，判断目标服务器地址），如果使用的时间超过这个时间，则中断该连接。</p><blockquote><p><code>connIdle</code>: number</p></blockquote><p>连接空闲的时间限制。单位为秒。默认值为<code>300</code>。在入站出站代理处理一个连接时，如果在 <code>connIdle</code> 时间内，没有任何数据被传输（包括上行和下行数据），则中断该连接。</p><blockquote><p><code>uplinkOnly</code>: number</p></blockquote><p>当连接下行线路关闭后的时间限制。单位为秒。默认值为<code>2</code>。当服务器（如远端网站）关闭下行连接时，出站代理会在等待 <code>uplinkOnly</code> 时间后中断连接。</p><blockquote><p><code>downlinkOnly</code>: number</p></blockquote><p>当连接上行线路关闭后的时间限制。单位为秒。默认值为<code>5</code>。当客户端（如浏览器）关闭上行连接时，入站代理会在等待 <code>downlinkOnly</code> 时间后中断连接。</p><p>在 HTTP 浏览的场景中，可以将<code>uplinkOnly</code>和<code>downlinkOnly</code>设为<code>0</code>，以提高连接关闭的效率。</p><blockquote><p><code>statsUserUplink</code>: true | false</p></blockquote><p>当值为<code>true</code>时，开启当前等级的所有用户的上行流量统计。</p><blockquote><p><code>statsUserDownlink</code>: true | false</p></blockquote><p>当值为<code>true</code>时，开启当前等级的所有用户的下行流量统计。</p><blockquote><p><code>bufferSize</code>: number</p></blockquote><p>每个连接的内部缓存大小。单位为 kB。当值为<code>0</code>时，内部缓存被禁用。</p><p>默认值 (V2Ray 4.4+):</p><ul><li><p>在 ARM、MIPS、MIPSLE 平台上，默认值为<code>0</code>。</p></li><li><p>在 ARM64、MIPS64、MIPS64LE 平台上，默认值为<code>4</code>。</p></li><li><p>在其它平台上，默认值为<code>512</code>。</p></li></ul><p>默认值 (V2Ray 4.3-):</p><ul><li><p>在 ARM、MIPS、MIPSLE、ARM64、MIPS64、MIPS64LE 平台上，默认值为<code>16</code>。</p></li><li><p>在其它平台上，默认值为<code>2048</code>。</p></li></ul><p><code>bufferSize</code> 选项会覆盖<a href="https://www.v2ray.com/chapter_02/env.html#buffer-size" target="_blank" rel="noopener">环境变量</a>中<code>v2ray.ray.buffer.size</code>的设定。</p><h3 id="SystemPolicyObject"><a href="#SystemPolicyObject" class="headerlink" title="SystemPolicyObject"></a>SystemPolicyObject</h3><pre><code>{  "statsInboundUplink": false,  "statsInboundDownlink": false}</code></pre><blockquote><p><code>statsInboundUplink</code>: true | false</p></blockquote><p>当值为<code>true</code>时，开启所有入站代理的上行流量统计。</p><blockquote><p><code>statsInboundDownlink</code>: true | false</p></blockquote><p>当值为<code>true</code>时，开启所有入站代理的下行流量统计。</p><h1 id="路由功能"><a href="#路由功能" class="headerlink" title="路由功能"></a>路由功能</h1><p>V2Ray 内建了一个简单的路由功能，可以将入站数据按需求由不同的出站连接发出，以达到按需代理的目的。这一功能的常见用法是分流国内外流量，V2Ray 可以通过内部机制判断不同地区的流量，然后将它们发送到不同的出站代理。</p><h2 id="RoutingObject"><a href="#RoutingObject" class="headerlink" title="RoutingObject"></a>RoutingObject</h2><p><code>RoutingObject</code> 对应主配置文件中的<code>routing</code>项。</p><pre><code>{  "domainStrategy": "AsIs",  "rules": [],  "balancers": []}</code></pre><blockquote><p><code>domainStrategy</code>: “AsIs” | “IPIfNonMatch” | “IPOnDemand”</p></blockquote><p>域名解析策略，根据不同的设置使用不同的策略。</p><ul><li><p><code>"AsIs"</code>: 只使用域名进行路由选择。默认值。</p></li><li><pre><code>"IPIfNonMatch"</code></pre><p>: 当域名没有匹配任何规则时，将域名解析成 IP（A 记录或 AAAA 记录）再次进行匹配；</p><ul><li>当一个域名有多个 A 记录时，会尝试匹配所有的 A 记录，直到其中一个与某个规则匹配为止；</li></ul></li><li><p>解析后的 IP 仅在路由选择时起作用，转发的数据包中依然使用原始域名；</p></li><li><p><code>"IPOnDemand"</code>: 当匹配时碰到任何基于 IP 的规则，将域名立即解析为 IP 进行匹配；</p></li></ul><blockquote><p><code>rules</code>: [<a href="https://www.v2ray.com/chapter_02/03_routing.html#ruleobject" target="_blank" rel="noopener">RuleObject</a>]</p></blockquote><p>对应一个数组，数组中每个元素是一个规则。对于每一个连接，路由将根据这些规则依次进行判断，当一个规则生效时，即将这个连接转发至它所指定的<code>outboundTag</code>(或<code>balancerTag</code>，V2Ray 4.4+)。当没有匹配到任何规则时，流量默认由主出站协议发出。</p><blockquote><p><code>balancers</code>: [ <a href="https://www.v2ray.com/chapter_02/03_routing.html#balancerobject" target="_blank" rel="noopener">BalancerObject</a> ]</p></blockquote><p>(V2Ray 4.4+)一个数组，数组中每个元素是一个负载均衡器的配置。当一个规则指向一个负载均衡器时，V2Ray 会通过此负载均衡器选出一个出站协议，然后由它转发流量。</p><h3 id="RuleObject"><a href="#RuleObject" class="headerlink" title="RuleObject"></a>RuleObject</h3><pre><code>{  "type": "field",  "domain": [    "baidu.com",    "qq.com",    "geosite:cn"  ],  "ip": [    "0.0.0.0/8",    "10.0.0.0/8",    "fc00::/7",    "fe80::/10",    "geoip:cn"  ],  "port": "53,443,1000-2000",  "network": "tcp",  "source": [    "10.0.0.1"  ],  "user": [    "love@v2ray.com"  ],  "inboundTag": [    "tag-vmess"  ],  "protocol":["http", "tls", "bittorrent"],  "attrs": "attrs[':method'] == 'GET'",  "outboundTag": "direct",  "balancerTag": "balancer"}</code></pre><p>当多个属性同时指定时，这些属性需要同时满足，才可以使当前规则生效。如果多个规则分别使用了<code>domain</code>或者<code>ip</code>，需要对应添加多条规则。</p><blockquote><p><code>type</code>: “field”</p></blockquote><p>目前只支持<code>"field"</code>这一个选项。</p><blockquote><p><code>domain</code>: [string]</p></blockquote><p>一个数组，数组每一项是一个域名的匹配。有以下几种形式：</p><ul><li><p>纯字符串: 当此字符串匹配目标域名中任意部分，该规则生效。比如”sina.com”可以匹配”sina.com”、”sina.com.cn”和”<a href="http://www.sina.com&quot;，但不匹配&quot;sina.cn&quot;。" target="_blank" rel="noopener">www.sina.com"，但不匹配"sina.cn"。</a></p></li><li><p>正则表达式: 由<code>"regexp:"</code>开始，余下部分是一个正则表达式。当此正则表达式匹配目标域名时，该规则生效。例如”regexp:\.goo.*\.com$”匹配”<a href="http://www.google.com&quot;、&quot;fonts.googleapis.com&quot;，但不匹配&quot;google.com&quot;。" target="_blank" rel="noopener">www.google.com"、"fonts.googleapis.com"，但不匹配"google.com"。</a></p></li><li><p>子域名 (推荐): 由<code>"domain:"</code>开始，余下部分是一个域名。当此域名是目标域名或其子域名时，该规则生效。例如”domain:v2ray.com”匹配”<a href="http://www.v2ray.com&quot;、&quot;v2ray.com&quot;，但不匹配&quot;xv2ray.com&quot;。" target="_blank" rel="noopener">www.v2ray.com"、"v2ray.com"，但不匹配"xv2ray.com"。</a></p></li><li><p>完整匹配: 由<code>"full:"</code>开始，余下部分是一个域名。当此域名完整匹配目标域名时，该规则生效。例如”full:v2ray.com”匹配”v2ray.com”但不匹配”<a href="http://www.v2ray.com&quot;。" target="_blank" rel="noopener">www.v2ray.com"。</a></p></li><li><p>预定义域名列表：由<code>"geosite:"</code>开头，余下部分是一个名称，如<code>geosite:google</code>或者<code>geosite:cn</code>。名称及域名列表参考<a href="https://www.v2ray.com/chapter_02/03_routing.html#dlc" target="_blank" rel="noopener">预定义域名列表</a>。</p></li><li><p>从文件中加载域名: 形如<code>"ext:file:tag"</code>，必须以<code>ext:</code>（小写）开头，后面跟文件名和标签，文件存放在<a href="https://www.v2ray.com/chapter_02/env.html#asset-location" target="_blank" rel="noopener">资源目录</a>中，文件格式与<code>geosite.dat</code>相同，标签必须在文件中存在。</p></li></ul><blockquote><p><code>ip</code>: [string]</p></blockquote><p>一个数组，数组内每一个元素代表一个 IP 范围。当某一元素匹配目标 IP 时，此规则生效。有以下几种形式：</p><ul><li><p>IP: 形如<code>"127.0.0.1"</code>。</p></li><li><p><a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing" target="_blank" rel="noopener">CIDR</a>: 形如<code>"10.0.0.0/8"</code>.</p></li><li><p>GeoIP: 形如</p><pre><code>"geoip:cn"</code></pre><p>，必须以</p><pre><code>geoip:</code></pre><p>（小写）开头，后面跟双字符国家代码，支持几乎所有可以上网的国家。</p><ul><li>特殊值：<code>"geoip:private"</code> (V2Ray 3.5+)，包含所有私有地址，如<code>127.0.0.1</code>。</li></ul></li><li><p>从文件中加载 IP: 形如<code>"ext:file:tag"</code>，必须以<code>ext:</code>（小写）开头，后面跟文件名和标签，文件存放在<a href="https://www.v2ray.com/chapter_02/env.html#asset-location" target="_blank" rel="noopener">资源目录</a>中，文件格式与<code>geoip.dat</code>相同标签必须在文件中存在。</p></li></ul><pre><code>"ext:geoip.dat:cn"`等价于`"geoip:cn"</code></pre><blockquote><p><code>port</code>：number | string</p></blockquote><p>端口范围，有三种形式：</p><ul><li><p><code>"a-b"</code>: a 和 b 均为正整数，且小于 65536。这个范围是一个前后闭合区间，当目标端口落在此范围内时，此规则生效。</p></li><li><p><code>a</code>: a 为正整数，且小于 65536。当目标端口为 a 时，此规则生效。</p></li><li><p>(V2Ray 4.18+) 以上两种形式的混合，以逗号”,”分隔。形如：<code>"53,443,1000-2000"</code>。</p></li></ul><blockquote><p><code>network</code>: “tcp” | “udp” | “tcp,udp”</p></blockquote><p>可选的值有”tcp”、”udp”或”tcp,udp”，当连接方式是指定的方式时，此规则生效。</p><blockquote><p><code>source</code>: [string]</p></blockquote><p>一个数组，数组内每一个元素是一个 IP 或 CIDR。当某一元素匹配来源 IP 时，此规则生效。</p><blockquote><p><code>user</code>: [string]</p></blockquote><p>一个数组，数组内每一个元素是一个邮箱地址。当某一元素匹配来源用户时，此规则生效。当前 Shadowsocks 和 VMess 支持此规则。</p><blockquote><p><code>inboundTag</code>: [string]</p></blockquote><p>一个数组，数组内每一个元素是一个标识。当某一元素匹配入站协议的标识时，此规则生效。</p><blockquote><p><code>protocol</code>: [ “http” | “tls” | “bittorrent” ]</p></blockquote><p>一个数组，数组内每一个元素表示一种协议。当某一个协议匹配当前连接的流量时，此规则生效。必须开启入站代理中的<code>sniffing</code>选项。</p><blockquote><p><code>attrs</code>: string</p></blockquote><p>(V2Ray 4.18+) 一段脚本，用于检测流量的属性值。当此脚本返回真值时，此规则生效。</p><p>脚本语言为 <a href="https://github.com/bazelbuild/starlark" target="_blank" rel="noopener">Starlark</a>，它的语法是 Python 的子集。脚本接受一个全局变量<code>attrs</code>，其中包含了流量相关的属性。</p><p>目前只有 http 入站代理会设置这一属性。</p><p>示例：</p><ul><li><p>检测 HTTP GET: <code>"attrs[':method'] == 'GET'"</code></p></li><li><p>检测 HTTP Path: <code>"attrs[':path'].startswith('/test')"</code></p></li><li><p>检测 Content Type: <code>"attrs['accept'].index('text/html') &gt;= 0"</code></p></li></ul><blockquote><p><code>outboundTag</code>: string</p></blockquote><p>对应一个<a href="https://www.v2ray.com/chapter_02/02_protocols.html" target="_blank" rel="noopener">额外出站连接配置</a>的标识。</p><blockquote><p><code>balancerTag</code>: string</p></blockquote><p>对应一个负载均衡器的标识。<code>balancerTag</code>和<code>outboundTag</code>须二选一。当同时指定时，<code>outboundTag</code>生效。</p><h3 id="BalancerObject"><a href="#BalancerObject" class="headerlink" title="BalancerObject"></a>BalancerObject</h3><p>负载均衡器配置。当一个负载均衡器生效时，它会从指定的出站协议中，按配置选出一个最合适的出站协议，进行流量转发。</p><pre><code>{  "tag": "balancer",  "selector": []}</code></pre><blockquote><p><code>tag</code>: string</p></blockquote><p>此负载均衡器的标识，用于匹配<code>RuleObject</code>中的<code>balancerTag</code>。</p><blockquote><p><code>selector</code>: [ string ]</p></blockquote><p>一个字符串数组，其中每一个字符串将用于和出站协议标识的前缀匹配。在以下几个出站协议标识中：<code>[ "a", "ab", "c", "ba" ]</code>，<code>"selector": ["a"]</code>将匹配到<code>[ "a", "ab" ]</code>。</p><p>如果匹配到多个出站协议，负载均衡器目前会从中随机选出一个作为最终的出站协议。</p><h2 id="预定义域名列表"><a href="#预定义域名列表" class="headerlink" title="预定义域名列表"></a>预定义域名列表</h2><p>此列表由 <a href="https://github.com/v2ray/domain-list-community" target="_blank" rel="noopener">domain-list-community</a> 项目维护，预置于每一个 V2Ray 的安装包中，文件名为<code>geosite.dat</code>。</p><p>这个文件包含了一些常见的域名，可用于路由和 DNS 筛选。常用的域名有：</p><ul><li><p><code>category-ads</code>: 包含了常见的广告域名。</p></li><li><p><code>category-ads-all</code>: 包含了常见的广告域名，以及广告提供商的域名。</p></li><li><p><code>cn</code>: 相当于 <code>geolocation-cn</code> 和 <code>tld-cn</code> 的合集。</p></li><li><p><code>google</code>: 包含了 Google 旗下的所有域名。</p></li><li><p><code>facebook</code>: 包含了 Facebook 旗下的所有域名。</p></li><li><p><code>geolocation-cn</code>: 包含了常见的国内站点的域名。</p></li><li><p><code>geolocation-!cn</code>: 包含了常见的非国内站点的域名。</p></li><li><p><code>speedtest</code>: 包含了所有 Speedtest 所用的域名。</p></li><li><p><code>tld-cn</code>: 包含了所有 .cn 和 .中国 结尾的域名。</p></li></ul><h1 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h1><p>V2Ray 内置了一个 DNS 服务器，其有两大主要用途：根据域名的解析IP匹配路由规则，以及像传统的DNS功能，解析目标地址进行连接。</p><p>由此 DNS 服务器所发出的 DNS 查询请求，会自动根据路由配置进行转发，无需额外配置。</p><p>由于 DNS 协议的复杂性，V2Ray 只支持最基本的 IP 查询（A 和 AAAA 记录）。推荐使用本机 DNS 配合一个额外的 DNS 服务器来做 DNS 查询，如 <a href="https://coredns.io/" target="_blank" rel="noopener">CoreDNS</a>，以使用完整的 DNS 功能。</p><p>注意：在<code>freedom</code>协议的<code>outbound</code>中，<code>domainStrategy</code>默认值为<code>AsIs</code>，不会使用本DNS服务器进行目的地址解析，如果需要使用应配置为<code>UseIP</code>。</p><h2 id="DNS-处理流程"><a href="#DNS-处理流程" class="headerlink" title="DNS 处理流程"></a>DNS 处理流程</h2><p>当某个 DNS 服务器指定的域名列表匹配了当前要查询的域名，V2Ray 会优先使用这个 DNS 服务器进行查询，否则按从上往下的顺序进行查询，同时只返回匹配 expectIPs 的 IP 列表。</p><p>DNS服务器的处理流程示意图如下：</p><p><img src="/images/loading.gif" data-original="https://starcross.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2QzODhkY2Y5M2UwMDczY2E1NDkzMjkyYmJjNzRiNDNfVHZ4eEdaOTRwUWg2S0lBVUJ4MmhKMWs1STZaYTJQQXFfVG9rZW46Ym94Y25Ld2NRT0tIcncyTXlkOGlkVEpUWHViXzE2MjcxNDY2NjA6MTYyNzE1MDI2MF9WNA" alt="img"></p><h2 id="DnsObject"><a href="#DnsObject" class="headerlink" title="DnsObject"></a>DnsObject</h2><p><code>DnsObject</code>对应配置文件中的<code>dns</code>项。</p><pre><code>{  "hosts": {    "baidu.com": "127.0.0.1"  },  "servers": [    {      "address": "1.2.3.4",      "port": 5353,      "domains": [        "domain:v2ray.com"      ],      "expectIPs": [        "geoip:cn"      ],    },    "8.8.8.8",    "8.8.4.4",    "localhost"  ],  "clientIp": "1.2.3.4",  "tag": "dns_inbound"}</code></pre><blockquote><p><code>hosts</code>: map{string: address}</p></blockquote><p>静态 IP 列表，其值为一系列的”域名”:”地址”。其中地址可以是 IP 或者域名。在解析域名时，如果域名匹配这个列表中的某一项，当该项的地址为 IP 时，则解析结果为该项的 IP，而不会使用下述的 servers 进行解析；当该项的地址为域名时，会使用此域名进行 IP 解析，而不使用原始域名。</p><p>域名的格式有以下几种形式：</p><ul><li><p>纯字符串: 当此域名完整匹配目标域名时，该规则生效。例如”v2ray.com”匹配”v2ray.com”但不匹配”<a href="http://www.v2ray.com&quot;。" target="_blank" rel="noopener">www.v2ray.com"。</a></p></li><li><p>正则表达式: 由<code>"regexp:"</code>开始，余下部分是一个正则表达式。当此正则表达式匹配目标域名时，该规则生效。例如”regexp:\.goo.*\.com$”匹配”<a href="http://www.google.com&quot;、&quot;fonts.googleapis.com&quot;，但不匹配&quot;google.com&quot;。" target="_blank" rel="noopener">www.google.com"、"fonts.googleapis.com"，但不匹配"google.com"。</a></p></li><li><p>子域名 (推荐): 由<code>"domain:"</code>开始，余下部分是一个域名。当此域名是目标域名或其子域名时，该规则生效。例如”domain:v2ray.com”匹配”<a href="http://www.v2ray.com&quot;、&quot;v2ray.com&quot;，但不匹配&quot;xv2ray.com&quot;。" target="_blank" rel="noopener">www.v2ray.com"、"v2ray.com"，但不匹配"xv2ray.com"。</a></p></li><li><p>子串: 由<code>"keyword:"</code>开始，余下部分是一个字符串。当此字符串匹配目标域名中任意部分，该规则生效。比如”keyword:sina.com”可以匹配”sina.com”、”sina.com.cn”和”<a href="http://www.sina.com&quot;，但不匹配&quot;sina.cn&quot;。" target="_blank" rel="noopener">www.sina.com"，但不匹配"sina.cn"。</a></p></li><li><p>预定义域名列表：由<code>"geosite:"</code>开头，余下部分是一个名称，如<code>geosite:google</code>或者<code>geosite:cn</code>。名称及域名列表参考<a href="https://www.v2ray.com/chapter_02/03_routing.html#dlc" target="_blank" rel="noopener">预定义域名列表</a>。</p></li></ul><blockquote><p><code>servers</code>: [string | <a href="https://www.v2ray.com/chapter_02/04_dns.html#serverobject" target="_blank" rel="noopener">ServerObject</a> ]</p></blockquote><p>一个 DNS 服务器列表，支持的类型有两种：DNS地址（字符串形式）和<a href="https://www.v2ray.com/chapter_02/04_dns.html#serverobject" target="_blank" rel="noopener">ServerObject</a> 。</p><p>当它的值是一个 DNS IP 地址时，如<code>"8.8.8.8"</code>，V2Ray 会使用此地址的 53 端口进行 DNS 查询。</p><p>当值为<code>"localhost"</code>时，表示使用本机预设的 DNS 配置。</p><p>当值是<code>"https://host:port/dns-query"</code>的形式，如<code>"https://dns.google/dns-query"</code>，V2Ray 会使用<code>DNS over HTTPS</code> (RFC8484, 简称DOH) 进行查询。有些服务商拥有IP别名的证书，可以直接写IP形式，比如<code>https://1.1.1.1/dns-query</code>。也可使用非标准端口和路径，如<code>"https://a.b.c.d:8443/my-dns-query"</code> (4.22.0+)</p><p>当值是<code>"https+local://host:port/dns-query"</code>的形式，如<code>"https+local://dns.google/dns-query"</code>，V2Ray 会使用 <code>DOH本地模式</code> 进行查询，即DOH请求不会经过Routing/Outbound等组件，直接对外请求，以降低耗时。一般适合在服务端使用。也可使用非标端口和路径。(4.22.0+)</p><p>当使用 <code>localhost</code> 时，本机的 DNS 请求不受 V2Ray 控制，需要额外的配置才可以使 DNS 请求由 V2Ray 转发。</p><p>不同规则初始化得到的DNS客户端会在V2Ray启动日志中以<code>info</code>级别体现，比如<code>local DOH</code> <code>remote DOH</code> <code>udp</code>等模式。（4.22.0+）</p><blockquote><p><code>clientIp</code>: string</p></blockquote><p>当前系统的 IP 地址，用于 DNS 查询时，通知服务器客户端的所在位置。不能是私有地址。</p><blockquote><p><code>tag</code>: string</p></blockquote><p>(V2Ray 4.13+) 由此 DNS 发出的查询流量，除<code>localhost</code> 和 <code>DOHL_</code> 模式外，都会带有此标识，可在路由使用<code>inboundTag</code>进行匹配。</p><h3 id="ServerObject-3"><a href="#ServerObject-3" class="headerlink" title="ServerObject"></a>ServerObject</h3><pre><code>{  "address": "1.2.3.4",  "port": 5353,  "domains": [    "domain:v2ray.com"  ],  "expectIPs": [    "geoip:cn"  ]}</code></pre><blockquote><p><code>address</code>: address</p></blockquote><p>DNS 服务器地址，如<code>"8.8.8.8"</code>。对于普通DNS IP地址只支持 UDP 协议的 DNS 服务器，若地址是以”<a href="https://xn--" "https+local-8c18a="" "开头的url形式，则使用doh模式，规则同字符串模式的doh配置。"="">https://“或”https+local://“开头的URL形式，则使用DOH模式，规则同字符串模式的DOH配置。</a></p><blockquote><p><code>port</code>: number</p></blockquote><p>DNS 服务器端口，如<code>53</code>。此项缺省时默认为<code>53</code>。当使用DOH模式该项无效，非标端口应在URL中指定。</p><blockquote><p><code>domains</code>: [string]</p></blockquote><p>一个域名列表，此列表包含的域名，将优先使用此服务器进行查询。域名格式和<a href="https://www.v2ray.com/chapter_02/03_routing.html#ruleobject" target="_blank" rel="noopener">路由配置</a>中相同。</p><blockquote><p><code>expectIPs</code>:[string]</p></blockquote><p>(V2Ray 4.22.0+) 一个 IP 范围列表，格式和<a href="https://www.v2ray.com/chapter_02/03_routing.html#ruleobject" target="_blank" rel="noopener">路由配置</a>中相同。</p><p>当配置此项时，V2Ray DNS 会对返回的 IP 的进行校验，只返回包含 expectIPs 列表中的地址。</p><p>如果未配置此项，会原样返回 IP 地址。</p><h1 id="Mux-多路复用"><a href="#Mux-多路复用" class="headerlink" title="Mux 多路复用"></a>Mux 多路复用</h1><p>Mux 功能是在一条 TCP 连接上分发多个 TCP 连接的数据。实现细节详见<a href="https://www.v2ray.com/developer/protocols/muxcool.html" target="_blank" rel="noopener">Mux.Cool</a>。Mux 是为了减少 TCP 的握手延迟而设计，而非提高连接的吞吐量。使用 Mux 看视频、下载或者测速通常都有反效果。Mux 只需要在客户端启用，服务器端自动适配。</p><h2 id="MuxObject"><a href="#MuxObject" class="headerlink" title="MuxObject"></a>MuxObject</h2><p><code>MuxObject</code>对应<code>OutboundObject</code>中的<code>mux</code>项。</p><pre><code>{  "enabled": false,  "concurrency": 8}</code></pre><blockquote><p><code>enabled</code>: true | false</p></blockquote><p>是否启用 Mux 转发请求</p><blockquote><p><code>concurrency</code>: number</p></blockquote><p>最大并发连接数。最小值<code>1</code>，最大值<code>1024</code>，缺省默认值<code>8</code>。</p><p>特殊值<code>-1</code>，不加载mux模块。(4.22.0+)</p><p>这个数值表示了一个 TCP 连接上最多承载的 Mux 连接数量。当客户端发出了 8 个 TCP 请求，而<code>concurrency=8</code>时，V2Ray 只会发出一条实际的 TCP 连接，客户端的 8 个请求全部由这个 TCP 连接传输。</p><h1 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h1><p>V2Ray 中可以开放一些 API 以便远程调用。这些 API 都基于 <a href="https://grpc.io/" target="_blank" rel="noopener">gRPC</a>。</p><p>当远程控制开启时，V2Ray 会自建一个出站代理，以<code>tag</code>配置的值为标识。用户必须手动将所有的 gRPC 入站连接通过<a href="https://www.v2ray.com/chapter_02/03_routing.html" target="_blank" rel="noopener">路由</a>指向这一出站代理。</p><h2 id="ApiObject"><a href="#ApiObject" class="headerlink" title="ApiObject"></a>ApiObject</h2><p><code>ApiObject</code>对应配置文件中的<code>api</code>项。</p><pre><code>{  "tag": "api",  "services": [    "HandlerService",    "LoggerService",    "StatsService"  ]}</code></pre><blockquote><p><code>tag</code>: string</p></blockquote><p>出站代理标识</p><blockquote><p><code>services</code>: [string]</p></blockquote><p>开启的 API 列表，可选的值见<a href="https://www.v2ray.com/chapter_02/api.html#api-list" target="_blank" rel="noopener">API 列表</a>。</p><h2 id="支持的-API-列表"><a href="#支持的-API-列表" class="headerlink" title="支持的 API 列表"></a>支持的 API 列表</h2><h3 id="HandlerService"><a href="#HandlerService" class="headerlink" title="HandlerService"></a>HandlerService</h3><p>一些对于入站出站代理进行修改的 API，可用的功能如下：</p><ul><li><p>添加一个新的入站代理；</p></li><li><p>添加一个新的出站代理；</p></li><li><p>删除一个现有的入站代理；</p></li><li><p>删除一个现有的出站代理；</p></li><li><p>在一个入站代理中添加一个用户（仅支持 VMess）；</p></li><li><p>在一个入站代理中删除一个用户（仅支持 VMess）；</p></li></ul><h3 id="LoggerService"><a href="#LoggerService" class="headerlink" title="LoggerService"></a>LoggerService</h3><p>支持对内置 Logger 的重启，可配合 logrotate 进行一些对日志文件的操作。</p><h3 id="StatsService"><a href="#StatsService" class="headerlink" title="StatsService"></a>StatsService</h3><p>内置的数据统计服务，详见<a href="https://www.v2ray.com/chapter_02/stats.html" target="_blank" rel="noopener">统计信息</a>。</p><h1 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h1><p>V2Ray 提供了一些关于其运行状况的统计信息。</p><h2 id="StatsObject"><a href="#StatsObject" class="headerlink" title="StatsObject"></a>StatsObject</h2><p><code>StatsObject</code> 对应配置文件中的<code>stats</code>项。</p><pre><code>{}</code></pre><p>目前统计信息没有任何参数，只要<code>StatsObject</code>项存在，内部的统计即会开启。同时你还需要在 <a href="https://www.v2ray.com/chapter_02/policy.html" target="_blank" rel="noopener">Policy</a> 中开启对应的项，才可以统计对应的数据。</p><p>目前已有的统计信息如下：</p><h2 id="用户数据"><a href="#用户数据" class="headerlink" title="用户数据"></a>用户数据</h2><blockquote><pre><code>user&gt;&gt;&gt;[email]&gt;&gt;&gt;traffic&gt;&gt;&gt;uplink</code></pre></blockquote><p>特定用户的上行流量，单位字节。</p><blockquote><pre><code>user&gt;&gt;&gt;[email]&gt;&gt;&gt;traffic&gt;&gt;&gt;downlink</code></pre></blockquote><p>特定用户的下行流量，单位字节。</p><p>如果对应用户没有指定 Email，则不会开启统计。</p><h2 id="全局数据"><a href="#全局数据" class="headerlink" title="全局数据"></a>全局数据</h2><blockquote><pre><code>inbound&gt;&gt;&gt;[tag]&gt;&gt;&gt;traffic&gt;&gt;&gt;uplink</code></pre></blockquote><p>特定入站代理的上行流量，单位字节。</p><blockquote><pre><code>inbound&gt;&gt;&gt;[tag]&gt;&gt;&gt;traffic&gt;&gt;&gt;downlink</code></pre></blockquote><p>特定入站代理的下行流量，单位字节。</p><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>反向代理是一个 V2Ray 的附加功能，可以把服务器端的流量向客户端转发，即逆向流量转发。</p><p>反向代理功能在 V2Ray 4.0+ 可用。目前处于测试阶段，可能会有一些问题。</p><p>反向代理的大致工作原理如下:</p><ul><li><p>假设在主机 A 中有一个网页服务器，这台主机没有公网 IP，无法在公网上直接访问。另有一台主机 B，它可以由公网访问。现在我们需要把 B 作为入口，把流量从 B 转发到 A。</p></li><li><p>在主机 A 中配置一个 V2Ray，称为<code>bridge</code>，在 B 中也配置一个 V2Ray，称为<code>portal</code>。</p></li><li><p><code>bridge</code>会向<code>portal</code>主动建立连接，此连接的目标地址可以自行设定。<code>portal</code>会收到两种连接，一是由<code>bridge</code>发来的连接，二是公网用户发来的连接。<code>portal</code>会自动将两类连接合并。于是<code>bridge</code>就可以收到公网流量了。</p></li><li><p><code>bridge</code>在收到公网流量之后，会将其原封不动地发给主机 A 中的网页服务器。当然，这一步需要路由的协作。</p></li><li><p><code>bridge</code>会根据流量的大小进行动态的负载均衡。</p></li></ul><p>反向代理默认已开启 <a href="https://www.v2ray.com/chapter_02/mux.html" target="_blank" rel="noopener">Mux</a>，请不要在其用到的出站代理上再次开启 Mux。</p><h2 id="ReverseObject"><a href="#ReverseObject" class="headerlink" title="ReverseObject"></a>ReverseObject</h2><p><code>ReverseObject</code>对应配置文件中的<code>reverse</code>项。</p><pre><code>{  "bridges": [{    "tag": "bridge",    "domain": "test.v2ray.com"  }],  "portals": [{    "tag": "portal",    "domain": "test.v2ray.com"  }]}</code></pre><blockquote><p><code>bridges</code>: [<a href="https://www.v2ray.com/chapter_02/bridgeobject" target="_blank" rel="noopener">BridgeObject</a>]</p></blockquote><p>一个数组，每一项表示一个<code>bridge</code>。每个<code>bridge</code>的配置是一个 <a href="https://www.v2ray.com/chapter_02/bridgeobject" target="_blank" rel="noopener">BridgeObject</a>。</p><blockquote><p><code>portals</code>: [<a href="https://www.v2ray.com/chapter_02/portalobject" target="_blank" rel="noopener">PortalObject</a>]</p></blockquote><p>一个数组，每一项表示一个<code>portal</code>。每个<code>portal</code>的配置是一个 <a href="https://www.v2ray.com/chapter_02/bridgeobject" target="_blank" rel="noopener">PortalObject</a>。</p><h3 id="BridgeObject"><a href="#BridgeObject" class="headerlink" title="BridgeObject"></a>BridgeObject</h3><pre><code>{  "tag": "bridge",  "domain": "test.v2ray.com"}</code></pre><blockquote><p><code>tag</code>: string</p></blockquote><p>一个标识，所有由<code>bridge</code>发出的连接，都会带有这个标识。可以在<a href="https://www.v2ray.com/chapter_02/03_routing.html" target="_blank" rel="noopener">路由</a>中使用<code>inboundTag</code>进行识别。</p><blockquote><p><code>domain</code>: string</p></blockquote><p>一个域名。<code>bridge</code>向<code>portal</code>建立的连接，都会使用这个域名进行发送。这个域名只作为<code>bridge</code>和<code>portal</code>的通信用途，不必真实存在。</p><h3 id="PortalObject"><a href="#PortalObject" class="headerlink" title="PortalObject"></a>PortalObject</h3><blockquote><p><code>tag</code>: string</p></blockquote><p><code>portal</code>的标识。在<a href="https://www.v2ray.com/chapter_02/03_routing.html" target="_blank" rel="noopener">路由</a>中使用<code>outboundTag</code>将流量转发到这个<code>portal</code>。</p><blockquote><p><code>domain</code>: string</p></blockquote><p>一个域名。当<code>portal</code>接收到流量时，如果流量的目标域名是此域名，则<code>portal</code>认为当前连接上<code>bridge</code>发来的通信连接。而其它流量则会被当成需要转发的流量。<code>portal</code>所做的工作就是把这两类连接进行识别并拼接。</p><p>和其它配置一样，一个 V2Ray 既可以作为<code>bridge</code>，也可以作为<code>portal</code>，也可以同时两者，以适用于不同的场景需要。</p><h2 id="完整配置"><a href="#完整配置" class="headerlink" title="完整配置"></a>完整配置</h2><p><code>bridge</code>通常需要两个出站代理，一个用于连接<code>portal</code>，另一个用于发送实际的流量。也就是说，你需要用路由区分两种流量。</p><p>反向代理配置:</p><pre><code>{  "bridges": [{    "tag": "bridge",    "domain": "test.v2ray.com"  }]}</code></pre><p>出站代理:</p><pre><code>{  "tag": "out",  "protocol": "freedom",  "settings": {    "redirect": "127.0.0.1:80" // 将所有流量转发到网页服务器  }},{  "protocol": "vmess",  "settings": {    "vnext": [{      "address": "portal的IP地址",      "port": 1024,      "users": [{"id": "27848739-7e62-4138-9fd3-098a63964b6b"}]    }]  },  "tag": "interconn"}</code></pre><p>路由配置:</p><pre><code>"routing": {  "rules": [{    "type": "field",    "inboundTag": ["bridge"],    "domain": ["full:test.v2ray.com"],    "outboundTag": "interconn"  },{    "type": "field",    "inboundTag": ["bridge"],    "outboundTag": "out"  }]}</code></pre><p><code>portal</code>通常需要两个入站代理，一个用于接收<code>bridge</code>的连接，另一个用于接收实际的流量。同时你也需要用路由区分两种流量。</p><p>反向代理配置:</p><pre><code>{  "portals": [{    "tag": "portal",    "domain": "test.v2ray.com"  // 必须和 bridge 的配置一样  }]}</code></pre><p>入站代理:</p><pre><code>{  "tag": "external",  "port": 80,  // 开放 80 端口，用于接收外部的 HTTP 访问  "protocol": "dokodemo-door",  "settings": {    "address": "127.0.0.1",    "port": 80,    "network": "tcp"  }},{  "port": 1024, // 用于接收 bridge 的连接  "tag": "interconn",  "protocol": "vmess",  "settings": {    "clients": [{"id": "27848739-7e62-4138-9fd3-098a63964b6b"}]  }}</code></pre><p>路由配置:</p><pre><code>"routing": {  "rules": [{    "type": "field",    "inboundTag": ["external"],    "outboundTag": "portal"  },{    "type": "field",    "inboundTag": ["interconn"],    "outboundTag": "portal"  }]}</code></pre><p>在运行过程中，建议先启用<code>bridge</code>，再启用<code>portal</code>。</p><h1 id="底层传输配置"><a href="#底层传输配置" class="headerlink" title="底层传输配置"></a>底层传输配置</h1><p>底层传输方式（transport）是当前 V2Ray 节点和其它节点对接的方式。底层传输方式提供了稳定的数据传输通道。通常来说，一个网络连接的两端需要有对称的传输方式。比如一端用了 WebSocket，那么另一个端也必须使用 WebSocket，否则无法建立连接。</p><p>底层传输（transport）配置分为两部分，一是全局设置(<a href="https://www.v2ray.com/chapter_02/05_transport.html#transportobject" target="_blank" rel="noopener">TransportObject</a>)，二是分协议配置(<a href="https://www.v2ray.com/chapter_02/05_transport.html#streamsettingsobject" target="_blank" rel="noopener">StreamSettingsObject</a>)。分协议配置可以指定每个单独的入站出站协议用怎样的方式传输。通常来说客户端和服务器对应的出站入站协议需要使用同样的传输方式。当分协议传输配置指定了一种传输方式，但没有填写其设置时，此传输方式会使用全局配置中的设置。</p><h2 id="TransportObject"><a href="#TransportObject" class="headerlink" title="TransportObject"></a>TransportObject</h2><p><code>TransportObject</code>对应配置文件的<code>transport</code>项。</p><pre><code>{  "tcpSettings": {},  "kcpSettings": {},  "wsSettings": {},  "httpSettings": {},  "dsSettings": {},  "quicSettings": {}}</code></pre><blockquote><p><code>tcpSettings</code>: TcpObject</p></blockquote><p>针对 <a href="https://www.v2ray.com/chapter_02/transport/tcp.html" target="_blank" rel="noopener">TCP 连接的配置</a>。</p><blockquote><p><code>kcpSettings</code>: KcpObject</p></blockquote><p>针对 <a href="https://www.v2ray.com/chapter_02/transport/mkcp.html" target="_blank" rel="noopener">mKCP 连接的配置</a>。</p><blockquote><p><code>wsSettings</code>: WebSocketObject</p></blockquote><p>针对 <a href="https://www.v2ray.com/chapter_02/transport/websocket.html" target="_blank" rel="noopener">WebSocket 连接的配置</a>。</p><blockquote><p><code>httpSettings</code>: HttpObject</p></blockquote><p>针对 <a href="https://www.v2ray.com/chapter_02/transport/h2.html" target="_blank" rel="noopener">HTTP/2 连接的配置</a>。</p><blockquote><p><code>dsSettings</code>: DomainSocketObject</p></blockquote><p>针于<a href="https://www.v2ray.com/chapter_02/transport/domainsocket.html" target="_blank" rel="noopener">Domain Socket 连接的配置</a>。</p><blockquote><p><code>quicSettings</code>: QUICObject</p></blockquote><p>(V2Ray 4.7+) 针于<a href="https://www.v2ray.com/chapter_02/transport/quic.html" target="_blank" rel="noopener">QUIC 连接的配置</a>。</p><h2 id="StreamSettingsObject"><a href="#StreamSettingsObject" class="headerlink" title="StreamSettingsObject"></a>StreamSettingsObject</h2><p><code>TransportObject</code>对应出站入站协议中的<code>streamSettings</code>项。每一个入站、出站连接都可以分别配置不同的传输配置，都可以设置<code>streamSettings</code>来进行一些传输的配置。</p><pre><code>{  "network": "tcp",  "security": "none",  "tlsSettings": {},  "tcpSettings": {},  "kcpSettings": {},  "wsSettings": {},  "httpSettings": {},  "dsSettings": {},  "quicSettings": {},  "sockopt": {    "mark": 0,    "tcpFastOpen": false,    "tproxy": "off"  }}</code></pre><blockquote><p><code>network</code>: “tcp” | “kcp” | “ws” | “http” | “domainsocket” | “quic”</p></blockquote><p>数据流所使用的网络类型，默认值为 <code>"tcp"</code></p><blockquote><p><code>security</code>: “none” | “tls”</p></blockquote><p>是否启入传输层加密，支持的选项有 <code>"none"</code> 表示不加密（默认值），<code>"tls"</code> 表示使用 <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" target="_blank" rel="noopener">TLS</a>。</p><blockquote><p><code>tlsSettings</code>: <a href="https://www.v2ray.com/chapter_02/05_transport.html#tlsobject" target="_blank" rel="noopener">TLSObject</a></p></blockquote><p>TLS 配置。TLS 由 Golang 提供，支持 TLS 1.2，不支持 DTLS。</p><blockquote><p><code>tcpSettings</code>: <a href="https://www.v2ray.com/chapter_02/transport/tcp.html" target="_blank" rel="noopener">TcpObject</a></p></blockquote><p>当前连接的 TCP 配置，仅当此连接使用 TCP 时有效。配置内容与上面的全局配置相同。</p><blockquote><p><code>kcpSettings</code>: KcpObject</p></blockquote><p>当前连接的 mKCP 配置，仅当此连接使用 mKCP 时有效。配置内容与上面的全局配置相同。</p><blockquote><p><code>wsSettings</code>: WebSocketObject</p></blockquote><p>当前连接的 WebSocket 配置，仅当此连接使用 WebSocket 时有效。配置内容与上面的全局配置相同。</p><blockquote><p><code>httpSettings</code>: HttpObject</p></blockquote><p>当前连接的 HTTP/2 配置，仅当此连接使用 HTTP/2 时有效。配置内容与上面的全局配置相同。</p><blockquote><p><code>dsSettings</code>: DomainSocketObject</p></blockquote><p>当前连接的 Domain socket 配置，仅当此连接使用 Domain socket 时有效。配置内容与上面的全局配置相同。</p><blockquote><p><code>quicSettings</code>: QUICObject</p></blockquote><p>(V2Ray 4.7+) 当前连接的 QUIC 配置，仅当此连接使用 QUIC 时有效。配置内容与上面的全局配置相同。</p><blockquote><p><code>sockopt</code>: SockoptObject</p></blockquote><p>连接选项</p><h3 id="TLSObject"><a href="#TLSObject" class="headerlink" title="TLSObject"></a>TLSObject</h3><pre><code>{  "serverName": "v2ray.com",  "allowInsecure": false,  "alpn": ["http/1.1"],  "certificates": [],  "disableSystemRoot": false}</code></pre><blockquote><p><code>serverName</code>: string</p></blockquote><p>指定服务器端证书的域名，在连接由 IP 建立时有用。当目标连接由域名指定时，比如在 Socks 入站时接收到了域名，或者由 Sniffing 功能探测出了域名，这个域名会自动用于<code>serverName</code>，无须手动配置。</p><blockquote><p><code>alpn</code>: [ string ]</p></blockquote><p>一个字符串数组，指定了 TLS 握手时指定的 ALPN 数值。默认值为<code>["http/1.1"]</code>。</p><blockquote><p><code>allowInsecure</code>: true | false</p></blockquote><p>是否允许不安全连接（用于客户端）。当值为<code>true</code>时，V2Ray 不会检查远端主机所提供的 TLS 证书的有效性。</p><blockquote><p><code>allowInsecureCiphers</code>: true | false</p></blockquote><p>是否允许不安全的加密方式。默认情况下 TLS 只使用 TLS 1.3 推荐的加密算法套件，开启这一选项会增加一些与 TLS 1.2 兼容的加密套件。</p><blockquote><p><code>disableSystemRoot</code>: true | false</p></blockquote><p>(V2Ray 4.18+) 是否禁用操作系统自带的 CA 证书。默认值为<code>false</code>。当值为<code>true</code>时，V2Ray 只会使用<code>certificates</code>中指定的证书进行 TLS 握手。</p><blockquote><p><code>certificates</code>: [ <a href="https://www.v2ray.com/chapter_02/05_transport.html#certificateobject" target="_blank" rel="noopener">CertificateObject</a> ]</p></blockquote><p>证书列表，其中每一项表示一个证书</p><h3 id="CertificateObject"><a href="#CertificateObject" class="headerlink" title="CertificateObject"></a>CertificateObject</h3><pre><code>{  "usage": "encipherment",  "certificateFile": "/path/to/certificate.crt",  "keyFile": "/path/to/key.key",  "certificate": [    "-----BEGIN CERTIFICATE-----",    "MIICwDCCAaigAwIBAgIRAO16JMdESAuHidFYJAR/7kAwDQYJKoZIhvcNAQELBQAw",    "ADAeFw0xODA0MTAxMzU1MTdaFw0xODA0MTAxNTU1MTdaMAAwggEiMA0GCSqGSIb3",    "DQEBAQUAA4IBDwAwggEKAoIBAQCs2PX0fFSCjOemmdm9UbOvcLctF94Ox4BpSfJ+",    "3lJHwZbvnOFuo56WhQJWrclKoImp/c9veL1J4Bbtam3sW3APkZVEK9UxRQ57HQuw",    "OzhV0FD20/0YELou85TwnkTw5l9GVCXT02NG+pGlYsFrxesUHpojdl8tIcn113M5",    "pypgDPVmPeeORRf7nseMC6GhvXYM4txJPyenohwegl8DZ6OE5FkSVR5wFQtAhbON",    "OAkIVVmw002K2J6pitPuJGOka9PxcCVWhko/W+JCGapcC7O74palwBUuXE1iH+Jp",    "noPjGp4qE2ognW3WH/sgQ+rvo20eXb9Um1steaYY8xlxgBsXAgMBAAGjNTAzMA4G",    "A1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDATAMBgNVHRMBAf8EAjAA",    "MA0GCSqGSIb3DQEBCwUAA4IBAQBUd9sGKYemzwPnxtw/vzkV8Q32NILEMlPVqeJU",    "7UxVgIODBV6A1b3tOUoktuhmgSSaQxjhYbFAVTD+LUglMUCxNbj56luBRlLLQWo+",    "9BUhC/ow393tLmqKcB59qNcwbZER6XT5POYwcaKM75QVqhCJVHJNb1zSEE7Co7iO",    "6wIan3lFyjBfYlBEz5vyRWQNIwKfdh5cK1yAu13xGENwmtlSTHiwbjBLXfk+0A/8",    "r/2s+sCYUkGZHhj8xY7bJ1zg0FRalP5LrqY+r6BckT1QPDIQKYy615j1LpOtwZe/",    "d4q7MD/dkzRDsch7t2cIjM/PYeMuzh87admSyL6hdtK0Nm/Q",    "-----END CERTIFICATE-----"  ],  "key": [    "-----BEGIN RSA PRIVATE KEY-----",    "MIIEowIBAAKCAQEArNj19HxUgoznppnZvVGzr3C3LRfeDseAaUnyft5SR8GW75zh",    "bqOeloUCVq3JSqCJqf3Pb3i9SeAW7Wpt7FtwD5GVRCvVMUUOex0LsDs4VdBQ9tP9",    "GBC6LvOU8J5E8OZfRlQl09NjRvqRpWLBa8XrFB6aI3ZfLSHJ9ddzOacqYAz1Zj3n",    "jkUX+57HjAuhob12DOLcST8np6IcHoJfA2ejhORZElUecBULQIWzjTgJCFVZsNNN",    "itieqYrT7iRjpGvT8XAlVoZKP1viQhmqXAuzu+KWpcAVLlxNYh/iaZ6D4xqeKhNq",    "IJ1t1h/7IEPq76NtHl2/VJtbLXmmGPMZcYAbFwIDAQABAoIBAFCgG4phfGIxK9Uw",    "qrp+o9xQLYGhQnmOYb27OpwnRCYojSlT+mvLcqwvevnHsr9WxyA+PkZ3AYS2PLue",    "C4xW0pzQgdn8wENtPOX8lHkuBocw1rNsCwDwvIguIuliSjI8o3CAy+xVDFgNhWap",    "/CMzfQYziB7GlnrM6hH838iiy0dlv4I/HKk+3/YlSYQEvnFokTf7HxbDDmznkJTM",    "aPKZ5qbnV+4AcQfcLYJ8QE0ViJ8dVZ7RLwIf7+SG0b0bqloti4+oQXqGtiESUwEW",    "/Wzi7oyCbFJoPsFWp1P5+wD7jAGpAd9lPIwPahdr1wl6VwIx9W0XYjoZn71AEaw4",    "bK4xUXECgYEA3g2o9WqyrhYSax3pGEdvV2qN0VQhw7Xe+jyy98CELOO2DNbB9QNJ",    "8cSSU/PjkxQlgbOJc8DEprdMldN5xI/srlsbQWCj72wXxXnVnh991bI2clwt7oYi",    "pcGZwzCrJyFL+QaZmYzLxkxYl1tCiiuqLm+EkjxCWKTX/kKEFb6rtnMCgYEAx0WR",    "L8Uue3lXxhXRdBS5QRTBNklkSxtU+2yyXRpvFa7Qam+GghJs5RKfJ9lTvjfM/PxG",    "3vhuBliWQOKQbm1ZGLbgGBM505EOP7DikUmH/kzKxIeRo4l64mioKdDwK/4CZtS7",    "az0Lq3eS6bq11qL4mEdE6Gn/Y+sqB83GHZYju80CgYABFm4KbbBcW+1RKv9WSBtK",    "gVIagV/89moWLa/uuLmtApyEqZSfn5mAHqdc0+f8c2/Pl9KHh50u99zfKv8AsHfH",    "TtjuVAvZg10GcZdTQ/I41ruficYL0gpfZ3haVWWxNl+J47di4iapXPxeGWtVA+u8",    "eH1cvgDRMFWCgE7nUFzE8wKBgGndUomfZtdgGrp4ouLZk6W4ogD2MpsYNSixkXyW",    "64cIbV7uSvZVVZbJMtaXxb6bpIKOgBQ6xTEH5SMpenPAEgJoPVts816rhHdfwK5Q",    "8zetklegckYAZtFbqmM0xjOI6bu5rqwFLWr1xo33jF0wDYPQ8RHMJkruB1FIB8V2",    "GxvNAoGBAM4g2z8NTPMqX+8IBGkGgqmcYuRQxd3cs7LOSEjF9hPy1it2ZFe/yUKq",    "ePa2E8osffK5LBkFzhyQb0WrGC9ijM9E6rv10gyuNjlwXdFJcdqVamxwPUBtxRJR",    "cYTY2HRkJXDdtT0Bkc3josE6UUDvwMpO0CfAETQPto1tjNEDhQhT",    "-----END RSA PRIVATE KEY-----"  ]}</code></pre><blockquote><p><code>usage</code>: “encipherment” | “verify” | “issue”</p></blockquote><p>证书用途，默认值为<code>"encipherment"</code></p><ul><li><p><code>"encipherment"</code>: 证书用于 TLS 认证和加密。</p></li><li><p><code>"verify"</code>: 证书用于验证远端 TLS 的证书。当使用此项时，当前证书必须为 CA 证书。</p></li><li><p><code>"issue"</code>: 证书用于签发其它证书。当使用此项时，当前证书必须为 CA 证书。</p></li></ul><p>在 Windows 平台上可以将自签名的 CA 证书安装到系统中，即可验证远端 TLS 的证书。</p><p>当有新的客户端请求时，假设所指定的<code>serverName</code>为<code>"v2ray.com"</code>，V2Ray 会先从证书列表中寻找可用于<code>"v2ray.com"</code>的证书，如果没有找到，则使用任一<code>usage</code>为<code>"issue"</code>的证书签发一个适用于<code>"v2ray.com"</code>的证书，有效期为一小时。并将新的证书加入证书列表，以供后续使用。</p><blockquote><p><code>certificateFile</code>: string</p></blockquote><p>证书文件路径，如使用 OpenSSL 生成，后缀名为 .crt。</p><p>使用<code>v2ctl cert -ca</code>可以生成自签名的 CA 证书。</p><blockquote><p><code>certificate</code>: [ string ]</p></blockquote><p>一个字符串数组，表示证书内容，格式如样例所示。<code>certificate</code>和<code>certificateFile</code>二者选一。</p><blockquote><p><code>keyFile</code>: string</p></blockquote><p>密钥文件路径，如使用 OpenSSL 生成，后缀名为 .key。目前暂不支持需要密码的 key 文件。</p><blockquote><p><code>key</code>: [ string ]</p></blockquote><p>一个字符串数组，表示密钥内容，格式如样例如示。<code>key</code>和<code>keyFile</code>二者选一。</p><p>当<code>certificateFile</code>和<code>certificate</code>同时指定时，V2Ray 优先使用<code>certificateFile</code>。<code>keyFile</code>和<code>key</code>也一样。</p><p>当<code>usage</code>为<code>"verify"</code>时，<code>keyFile</code>和<code>key</code>可均为空。</p><h3 id="SockoptObject"><a href="#SockoptObject" class="headerlink" title="SockoptObject"></a>SockoptObject</h3><pre><code>{  "mark": 0,  "tcpFastOpen": false,  "tproxy": "off"}</code></pre><blockquote><p><code>mark</code>: number</p></blockquote><p>一个整数。当其值非零时，在出站连接上标记 SO_MARK。</p><ul><li><p>仅适用于 Linux 系统。</p></li><li><p>需要 CAP_NET_ADMIN 权限。</p></li></ul><blockquote><p><code>tcpFastOpen</code>: true | false</p></blockquote><p>是否启用 <a href="https://zh.wikipedia.org/wiki/TCP快速打开" target="_blank" rel="noopener">TCP Fast Open</a>。当其值为<code>true</code>时，强制开启TFO；当其它为<code>false</code>时，强制关闭TFO；当此项不存在时，使用系统默认设置。可用于入站出站连接。</p><ul><li><p>仅在以下版本（或更新版本）的操作系统中可用:</p><ul><li>Windows 10 (1604)</li></ul></li><li><p>Mac OS 10.11 / iOS 9</p></li><li><p>Linux 3.16: 系统已默认开启，无需要配置。</p></li></ul><blockquote><p><code>tproxy</code>: “redirect” | “tproxy” | “off”</p></blockquote><p>是否开启透明代理 (仅适用于 Linux)。</p><ul><li><p><code>"redirect"</code>: 使用 Redirect 模式的透明代理。仅支持 TCP/IPv4 和 UDP 连接。</p></li><li><p><code>"tproxy"</code>: 使用 TProxy 模式的透明代理。支持 TCP 和 UDP 连接。</p></li><li><p><code>"off"</code>: 关闭透明代理。</p></li></ul><p>透明代理需要 Root 或 CAP_NET_ADMIN 权限。</p><p>当 <a href="https://www.v2ray.com/chapter_02/protocols/dokodemo.html" target="_blank" rel="noopener">Dokodemo-door</a> 中指定了<code>followRedirect</code>，且<code>sockopt.tproxy</code>为空时，<code>sockopt.tproxy</code>的值会被设为<code>"redirect"</code>。</p><h1 id="TCP-传输方式"><a href="#TCP-传输方式" class="headerlink" title="TCP 传输方式"></a>TCP 传输方式</h1><h2 id="TcpObject"><a href="#TcpObject" class="headerlink" title="TcpObject"></a>TcpObject</h2><pre><code>{  "header": {    "type": "none"  }}</code></pre><blockquote><p><code>header</code>: NoneHeaderObject | HttpHeaderobject</p></blockquote><p>数据包头部伪装设置，默认值为<code>NoneHeaderObject</code>。</p><h3 id="NoneHeaderObject"><a href="#NoneHeaderObject" class="headerlink" title="NoneHeaderObject"></a>NoneHeaderObject</h3><p>不进行伪装</p><pre><code>{  "type": "none"}</code></pre><blockquote><p><code>type</code>: “none”</p></blockquote><p>指定不进行伪装</p><h3 id="HttpHeaderObject"><a href="#HttpHeaderObject" class="headerlink" title="HttpHeaderObject"></a>HttpHeaderObject</h3><p>HTTP 伪装配置必须在对应的入站出站连接上同时配置，且内容必须一致。</p><pre><code>{  "type": "http",  "request": {},  "response": {}}</code></pre><blockquote><p><code>type</code>: “http”</p></blockquote><p>指定进行 HTTP 伪装</p><blockquote><p><code>request</code>: <a href="https://www.v2ray.com/chapter_02/transport/tcp.html#httprequestobject" target="_blank" rel="noopener">HTTPRequestObject</a></p></blockquote><p>HTTP 请求</p><blockquote><p><code>response</code>: <a href="https://www.v2ray.com/chapter_02/transport/tcp.html#httpresponseobject" target="_blank" rel="noopener">HTTPResponseObject</a></p></blockquote><p>HTTP 响应</p><h3 id="HTTPRequestObject"><a href="#HTTPRequestObject" class="headerlink" title="HTTPRequestObject"></a>HTTPRequestObject</h3><pre><code>{  "version": "1.1",  "method": "GET",  "path": ["/"],  "headers": {    "Host": ["www.baidu.com", "www.bing.com"],    "User-Agent": [      "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36",      "Mozilla/5.0 (iPhone; CPU iPhone OS 10_0_2 like Mac OS X) AppleWebKit/601.1 (KHTML, like Gecko) CriOS/53.0.2785.109 Mobile/14A456 Safari/601.1.46"    ],    "Accept-Encoding": ["gzip, deflate"],    "Connection": ["keep-alive"],    "Pragma": "no-cache"  }}</code></pre><blockquote><p><code>version</code>: string</p></blockquote><p>HTTP 版本，默认值为<code>"1.1"</code>。</p><blockquote><p><code>method</code>: string</p></blockquote><p>HTTP 方法，默认值为<code>"GET"</code>。</p><blockquote><p><code>path</code>: [ string ]</p></blockquote><p>路径，一个字符串数组。默认值为<code>["/"]</code>。当有多个值时，每次请求随机选择一个值。</p><blockquote><p><code>headers</code>: map{ string, [ string ]}</p></blockquote><p>HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是一个数组。每次请求会附上所有的键，并随机选择一个对应的值。默认值见上方示例。</p><h3 id="HTTPResponseObject"><a href="#HTTPResponseObject" class="headerlink" title="HTTPResponseObject"></a>HTTPResponseObject</h3><pre><code>{  "version": "1.1",  "status": "200",  "reason": "OK",  "headers": {    "Content-Type": ["application/octet-stream", "video/mpeg"],    "Transfer-Encoding": ["chunked"],    "Connection": ["keep-alive"],    "Pragma": "no-cache"  }}</code></pre><blockquote><p><code>version</code>: string</p></blockquote><p>HTTP 版本，默认值为<code>"1.1"</code>。</p><blockquote><p><code>status</code>: string</p></blockquote><p>HTTP 状态，默认值为<code>"200"</code>。</p><blockquote><p><code>reason</code>: string</p></blockquote><p>HTTP 状态说明，默认值为<code>"OK"</code>。</p><blockquote><p><code>headers</code>: map{string, [ string ]}</p></blockquote><p>HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是一个数组。每次请求会附上所有的键，并随机选择一个对应的值。默认值见上方示例。</p><h1 id="mKCP-传输方式"><a href="#mKCP-传输方式" class="headerlink" title="mKCP 传输方式"></a>mKCP 传输方式</h1><p>mKCP 使用 UDP 来模拟 TCP 连接，请确定主机上的防火墙配置正确。mKCP 牺牲带宽来降低延迟。传输同样的内容，mKCP 一般比 TCP 消耗更多的流量。</p><h2 id="KcpObject"><a href="#KcpObject" class="headerlink" title="KcpObject"></a>KcpObject</h2><pre><code>{  "mtu": 1350,  "tti": 20,  "uplinkCapacity": 5,  "downlinkCapacity": 20,  "congestion": false,  "readBufferSize": 1,  "writeBufferSize": 1,  "header": {    "type": "none"  }}</code></pre><blockquote><p><code>mtu</code>: number</p></blockquote><p>最大传输单元（maximum transmission unit），请选择一个介于 <code>576</code> - <code>1460</code> 之间的值。默认值为 <code>1350</code>。</p><blockquote><p><code>tti</code>: number</p></blockquote><p>传输时间间隔（transmission time interval），单位毫秒（ms），mKCP 将以这个时间频率发送数据。请选译一个介于 <code>10</code> - <code>100</code> 之间的值。默认值为 <code>50</code>。</p><blockquote><p><code>uplinkCapacity</code>: number</p></blockquote><p>上行链路容量，即主机发出数据所用的最大带宽，单位 MB/s，默认值 <code>5</code>。注意是 Byte 而非 bit。可以设置为 <code>0</code>，表示一个非常小的带宽。</p><blockquote><p><code>downlinkCapacity</code>: number</p></blockquote><p>下行链路容量，即主机接收数据所用的最大带宽，单位 MB/s，默认值 <code>20</code>。注意是 Byte 而非 bit。可以设置为 <code>0</code>，表示一个非常小的带宽。</p><p><code>uplinkCapacity</code> 和 <code>downlinkCapacity</code> 决定了 mKCP 的传输速度。以客户端发送数据为例，客户端的 <code>uplinkCapacity</code> 指定了发送数据的速度，而服务器端的 <code>downlinkCapacity</code> 指定了接收数据的速度。两者的值以较小的一个为准。推荐把 <code>downlinkCapacity</code> 设置为一个较大的值，比如 100，而 <code>uplinkCapacity</code> 设为实际的网络速度。当速度不够时，可以逐渐增加 <code>uplinkCapacity</code> 的值，直到带宽的两倍左右。</p><blockquote><p><code>congestion</code>: true | false</p></blockquote><p>是否启用拥塞控制，默认值为 <code>false</code>。开启拥塞控制之后，V2Ray 会自动监测网络质量，当丢包严重时，会自动降低吞吐量；当网络畅通时，也会适当增加吞吐量。</p><blockquote><p><code>readBufferSize</code>: number</p></blockquote><p>单个连接的读取缓冲区大小，单位是 MB。默认值为 <code>2</code>。</p><blockquote><p><code>writeBufferSize</code>: number</p></blockquote><p>单个连接的写入缓冲区大小，单位是 MB。默认值为 <code>2</code>。</p><p><code>readBufferSize</code> 和 <code>writeBufferSize</code> 指定了单个连接所使用的内存大小。在需要高速传输时，指定较大的 <code>readBufferSize</code> 和 <code>writeBufferSize</code> 会在一定程度上提高速度，但也会使用更多的内存。在网速不超过 20MB/s 时，默认值 1MB 可以满足需求；超过之后，可以适当增加 <code>readBufferSize</code> 和 <code>writeBufferSize</code> 的值，然后手动平衡速度和内存的关系。</p><blockquote><p><code>header</code>: <a href="https://www.v2ray.com/chapter_02/transport/mkcp.html#headerobject" target="_blank" rel="noopener">HeaderObject</a></p></blockquote><p>数据包头部伪装设置</p><h3 id="HeaderObject"><a href="#HeaderObject" class="headerlink" title="HeaderObject"></a>HeaderObject</h3><pre><code>{  "type": "none"}</code></pre><blockquote><p><code>type</code>: string</p></blockquote><p>伪装类型，可选的值有：</p><ul><li><p><code>"none"</code>: 默认值，不进行伪装，发送的数据是没有特征的数据包。</p></li><li><p><code>"srtp"</code>: 伪装成 SRTP 数据包，会被识别为视频通话数据（如 FaceTime）。</p></li><li><p><code>"utp"</code>: 伪装成 uTP 数据包，会被识别为 BT 下载数据。</p></li><li><p><code>"wechat-video"</code>: 伪装成微信视频通话的数据包。</p></li><li><p><code>"dtls"</code>: 伪装成 DTLS 1.2 数据包。</p></li><li><p><code>"wireguard"</code>: 伪装成 WireGuard 数据包。(并不是真正的 WireGuard 协议)</p></li></ul><h2 id="对-KCP-协议的改进"><a href="#对-KCP-协议的改进" class="headerlink" title="对 KCP 协议的改进"></a>对 KCP 协议的改进</h2><h3 id="更小的协议头"><a href="#更小的协议头" class="headerlink" title="更小的协议头"></a>更小的协议头</h3><p>原生 KCP 协议使用了 24 字节的固定头部，而 mKCP 修改为数据包 18 字节，确认（ACK）包 16 字节。更小的头部有助于躲避特征检查，并加快传输速度。</p><p>另外，原生 KCP 的单个确认包只能确认一个数据包已收到，也就是说当 KCP 需要确认 100 个数据已收到时，它会发出 24 * 100 = 2400 字节的数据。其中包含了大量重复的头部数据，造成带宽的浪费。mKCP 会对多个确认包进行压缩，100 个确认包只需要 16 + 2 + 100 * 4 = 418 字节，相当于原生的六分之一。</p><h3 id="确认包重传"><a href="#确认包重传" class="headerlink" title="确认包重传"></a>确认包重传</h3><p>原生 KCP 协议的确认（ACK）包只发送一次，如果确认包丢失，则一定会导致数据重传，造成不必要的带宽浪费。而 mKCP 会以一定的频率重发确认包，直到发送方确认为止。单个确认包的大小为 22 字节，相比起数据包的 1000 字节以上，重传确认包的代价要小得多。</p><h3 id="连接状态控制"><a href="#连接状态控制" class="headerlink" title="连接状态控制"></a>连接状态控制</h3><p>mKCP 可以有效地开启和关闭连接。当远程主机主动关闭连接时，连接会在两秒钟之内释放；当远程主机断线时，连接会在最多 30 秒内释放。</p><p>原生 KCP 不支持这个场景。</p><h1 id="WebSocket-传输方式"><a href="#WebSocket-传输方式" class="headerlink" title="WebSocket 传输方式"></a>WebSocket 传输方式</h1><p>使用标准的 WebSocket 来传输数据。WebSocket 连接可以被其它 HTTP 服务器（如 NGINX）分流。</p><p>Websocket 会识别 HTTP 请求的 X-Forwarded-For 头来用做流量的源地址。</p><h2 id="示例配置"><a href="#示例配置" class="headerlink" title="示例配置"></a>示例配置</h2><pre><code>{  "path": "/",  "headers": {    "Host": "v2ray.com"  }}</code></pre><blockquote><p><code>path</code> string</p></blockquote><p>WebSocket 所使用的 HTTP 协议路径，默认值为 <code>"/"</code>。</p><blockquote><p><code>headers</code>: map{string: string}</p></blockquote><p>自定义 HTTP 头，一个键值对，每个键表示一个 HTTP 头的名称，对应的值是字符串。默认值为空。</p><h1 id="HTTP-2-传输方式"><a href="#HTTP-2-传输方式" class="headerlink" title="HTTP/2 传输方式"></a>HTTP/2 传输方式</h1><p>V2Ray 3.17 中加入了基于 HTTP/2 的传输方式。它完整按照 HTTP/2 标准实现，可以通过其它的 HTTP 服务器（如 Nginx）进行中转。</p><p>由 HTTP/2 的建议，客户端和服务器必须同时开启 TLS 才可以正常使用这个传输方式。</p><p>V2Ray 4.20 中对服务端的TLS配置的强制条件移除，为了在特殊用途的分流部署环境中，由外部网关组件完成TLS层对话，V2Ray作为后端应用，网关和V2Ray间使用称为<code>h2c</code>的明文http/2进行通讯。</p><h2 id="HttpObject"><a href="#HttpObject" class="headerlink" title="HttpObject"></a>HttpObject</h2><p><code>HttpObject</code>对应传输配置中的<code>httpSettings</code>项。</p><pre><code>{  "host": ["v2ray.com"],  "path": "/random/path"}</code></pre><blockquote><p><code>host</code>: [string]</p></blockquote><p>一个字符串数组，每一个元素是一个域名。客户端会随机从列表中选出一个域名进行通信，服务器会验证域名是否在列表中。</p><blockquote><p><code>path</code> string</p></blockquote><p>HTTP 路径，由<code>/</code>开头。客户端和服务器必须一致。可选参数，默认值为<code>"/"</code>。</p><h1 id="DomainSocket-传输方式"><a href="#DomainSocket-传输方式" class="headerlink" title="DomainSocket 传输方式"></a>DomainSocket 传输方式</h1><p>Domain Socket 使用标准的 Unix domain socket 来传输数据。它的优势是使用了操作系统内建的传输通道，而不会占用网络缓存。相比起本地环回网络（local loopback）来说，Domain socket 速度略快一些。</p><p>目前仅可用于支持 Unix domain socket 的平台，如 macOS 和 Linux。在 Windows 上不可用。</p><p>如果指定了 domain socket 作为传输方式，在入站出站代理中配置的端口和 IP 地址将会失效，所有的传输由 domain socket 取代。</p><h2 id="DomainSocketObject"><a href="#DomainSocketObject" class="headerlink" title="DomainSocketObject"></a>DomainSocketObject</h2><p><code>DomainSocketObject</code>对应传输配置中的<code>dsSettings</code>项。</p><pre><code>{  "path": "/path/to/ds/file"}</code></pre><blockquote><p><code>path</code>: string</p></blockquote><p>一个合法的文件路径。在运行 V2Ray 之前，这个文件必须不存在。</p><h1 id="QUIC-传输方式"><a href="#QUIC-传输方式" class="headerlink" title="QUIC 传输方式"></a>QUIC 传输方式</h1><p>QUIC 全称 Quick UDP Internet Connection，是由 Google 提出的使用 UDP 进行多路并发传输的协议。其主要优势是:</p><ol><li>减少了握手的延迟（1-RTT 或 0-RTT）</li><li>多路复用，并且没有 TCP 的阻塞问题</li><li>连接迁移，（主要是在客户端）当由 Wifi 转移到 4G 时，连接不会被断开。</li></ol><p>QUIC 目前处于实验期，使用了正在标准化过程中的 IETF 实现，不能保证与最终版本的兼容性。</p><h2 id="版本历史"><a href="#版本历史" class="headerlink" title="版本历史"></a>版本历史</h2><p>V2Ray 4.7:</p><ul><li><p>开始支持 QUIC。</p></li><li><p>默认设定:</p><ul><li>12 字节的 Connection ID</li></ul></li><li><p>30 秒没有数据通过时自动断开连接 (可能会影响一些长连接的使用)</p></li></ul><h2 id="QuicObject"><a href="#QuicObject" class="headerlink" title="QuicObject"></a>QuicObject</h2><p>QUIC 的配置对应传输配置中的 <code>quicSettings</code> 项。对接的两端的配置必须完全一致，否则连接失败。QUIC 强制要求开启 TLS，在传输配置中没有开启 TLS 时，V2Ray 会自行签发一个证书进行 TLS 通讯。在使用 QUIC 传输时，可以关闭 VMess 的加密。</p><pre><code>{  "security": "none",  "key": "",  "header": {    "type": "none"  }}</code></pre><blockquote><p><code>security</code>: “none” | “aes-128-gcm” | “chacha20-poly1305”</p></blockquote><p>加密方式。默认值为不加密。</p><p>此加密是对 QUIC 数据包的加密，加密后数据包无法被探测。</p><blockquote><p><code>key</code>: string</p></blockquote><p>加密时所用的密钥。可以是任意字符串。当<code>security</code>不为<code>"none"</code>时有效。</p><blockquote><p><code>header</code>: <a href="https://www.v2ray.com/chapter_02/transport/quic.html#headerobject" target="_blank" rel="noopener">HeaderObject</a></p></blockquote><p>数据包头部伪装设置</p><h3 id="HeaderObject-1"><a href="#HeaderObject-1" class="headerlink" title="HeaderObject"></a>HeaderObject</h3><pre><code>{  "type": "none"}</code></pre><blockquote><p><code>type</code>: string</p></blockquote><p>伪装类型，可选的值有：</p><ul><li><p><code>"none"</code>: 默认值，不进行伪装，发送的数据是没有特征的数据包。</p></li><li><p><code>"srtp"</code>: 伪装成 SRTP 数据包，会被识别为视频通话数据（如 FaceTime）。</p></li><li><p><code>"utp"</code>: 伪装成 uTP 数据包，会被识别为 BT 下载数据。</p></li><li><p><code>"wechat-video"</code>: 伪装成微信视频通话的数据包。</p></li><li><p><code>"dtls"</code>: 伪装成 DTLS 1.2 数据包。</p></li><li><p><code>"wireguard"</code>: 伪装成 WireGuard 数据包。(并不是真正的 WireGuard 协议)</p></li></ul><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>V2Ray 提供以下环境变量以供修改 V2Ray 的一些底层配置。</p><h2 id="每个连接的缓存大小"><a href="#每个连接的缓存大小" class="headerlink" title="每个连接的缓存大小"></a>每个连接的缓存大小</h2><ul><li><p>名称: <code>v2ray.ray.buffer.size</code> 或 <code>V2RAY_RAY_BUFFER_SIZE</code></p></li><li><p>单位: MBytes</p></li><li><p>默认值: 在 x86、amd64、arm64、s390x 上为 2，其它平台上禁用该缓存。</p></li><li><p>特殊值: 0 表示缓存无上限</p></li></ul><p><strong>已过时，请使用本地策略中的 bufferSize</strong></p><p>对于一个代理连接，当上下游网络速度有差距时，V2Ray 会缓存一部分数据，以减小对网络传输的影响。这个配置设置了缓存的大小，越大的缓存会占用更多的内存，也会使网络性能越好。</p><h2 id="资源文件路径"><a href="#资源文件路径" class="headerlink" title="资源文件路径"></a>资源文件路径</h2><ul><li><p>名称: <code>v2ray.location.asset</code> 或 <code>V2RAY_LOCATION_ASSET</code></p></li><li><p>默认值: 和 v2ray 文件同路径</p></li></ul><p>这个环境变量指定了一个文件夹位置，这个文件夹应当包含 geoip.dat 和 geosite.dat 文件。</p><h2 id="配置文件位置"><a href="#配置文件位置" class="headerlink" title="配置文件位置"></a>配置文件位置</h2><ul><li><p>名称: <code>v2ray.location.config</code> 或 <code>V2RAY_LOCATION_CONFIG</code></p></li><li><p>默认值: 和 v2ray 文件同路径</p></li></ul><p>这个环境变量指定了一个文件夹位置，这个文件夹应当包含 config.json 文件。</p><h2 id="分散读取"><a href="#分散读取" class="headerlink" title="分散读取"></a>分散读取</h2><ul><li><p>名称：<code>v2ray.buf.readv</code> 或 <code>V2RAY_BUF_READV</code></p></li><li><p>默认值：<code>auto</code></p></li></ul><p>V2Ray 3.37 开始使用 Scatter/Gather IO，这一特性可以在大流量（超过 100 MByte/s）的时候依然使用较低的内存。可选的值有<code>auto</code>、<code>enable</code>和<code>disable</code>。</p><ul><li><p><code>enable</code>: 强制开启分散读取特性。</p></li><li><p><code>disable</code>: 强制关闭分散读取特性</p></li><li><p><code>auto</code>: 仅在 Windows、MacOS、Linux 并且 CPU 平台为 x86、AMD64、s390x 时，开启此特性。</p></li></ul><p>在流量没有达到 100 MByte/s 时，开启与否在内存使用上没有明显的差异。</p><h1 id="图形客户端"><a href="#图形客户端" class="headerlink" title="图形客户端"></a>图形客户端</h1><blockquote><p>V2RayW </p></blockquote><p>V2RayW 是一个基于 V2Ray 内核的 Windows 客户端。用户可以通过界面生成配置文件，并且可以手动更新 V2Ray 内核。下载：<a href="https://github.com/Cenmrev/V2RayW" target="_blank" rel="noopener">GitHub</a></p><blockquote><p>V2RayN </p></blockquote><p>V2RayN 是一个基于 V2Ray 内核的 Windows 客户端。下载：<a href="https://github.com/2dust/v2rayN" target="_blank" rel="noopener">GitHub</a></p><blockquote><p>Clash for Windows </p></blockquote><p>下载：<a href="https://github.com/Fndroid/clash_for_windows_pkg" target="_blank" rel="noopener">GitHub</a></p><blockquote><p>V2RayX </p></blockquote><p>V2RayX 是一个基于 V2Ray 内核的 Mac OS X 客户端。用户可以通过界面生成配置文件，并且可以手动更新 V2Ray 内核。V2RayX 还可以配置系统代理。下载：<a href="https://github.com/Cenmrev/V2RayX" target="_blank" rel="noopener">Github</a></p><blockquote><p>V2RayU </p></blockquote><p>V2rayU,基于v2ray核心的mac版客户端,界面友好,使用swift4.2编写,支持vmess,shadowsocks,socks5等服务协议,支持订阅, 支持二维码,剪贴板导入,手动配置,二维码分享等。下载：<a href="https://github.com/yanue/V2rayU" target="_blank" rel="noopener">GitHub</a></p><blockquote><p>V2RayC </p></blockquote><p>下载：<a href="https://github.com/gssdromen/V2RayC" target="_blank" rel="noopener">GitHub</a></p><blockquote><p>ClashX </p></blockquote><p>下载：<a href="https://github.com/yichengchen/clashX" target="_blank" rel="noopener">GitHub</a></p><blockquote><p>Qv2ray </p></blockquote><p>Qv2ray：使用 Qt 编写的 v2ray 跨平台 GUI （MacOS, Windows, Linux）支持连接导入和编辑，中英文切换</p><p>下载：<a href="https://github.com/lhy0403/Qv2ray" target="_blank" rel="noopener">GitHub</a></p><p>官网：<a href="https://lhy0403.github.io/Qv2ray" target="_blank" rel="noopener">https://lhy0403.github.io/Qv2ray</a></p><blockquote><p>Mellow </p></blockquote><p>Mellow 是一个基于规则的全局透明代理工具，可以运行在 Windows、macOS 和 Linux 上，也可以配置成路由器透明代理或代理网关，支持 SOCKS、HTTP、Shadowsocks、VMess 等多种代理协议。</p><p>Download: <a href="https://github.com/mellow-io/mellow" target="_blank" rel="noopener">Github</a></p><blockquote><p>Kitsunebi </p></blockquote><p>Kitsunebi 是一个基于 V2Ray 核心的移动平台应用 (iOS, Android)。它可以创建基于 VMess 或者 Shadowsocks 的 VPN 连接。Kitsunebi 支持导入和导出与 V2Ray 兼容的 JSON 配置。</p><p>由于使用 V2Ray 核心，Kitsunebi 几乎支持 V2Ray 的所有功能，比如 Mux 和 mKCP。</p><p>下载：<a href="https://itunes.apple.com/us/app/kitsunebi-proxy-utility/id1446584073?mt=8" target="_blank" rel="noopener">iTunes</a> | <a href="https://play.google.com/store/apps/details?id=fun.kitsunebi.kitsunebi4android&amp;hl=en_US" target="_blank" rel="noopener">Play Store</a></p><blockquote><p>i2Ray </p></blockquote><p>i2Ray 是另一款基于 V2Ray 核心的iOS应用。界面简洁易用，适合新手用户使用。同时兼容Shadowrocket和Quantumult格式的规则导入。</p><p>下载：<a href="https://itunes.apple.com/us/app/i2ray/id1445270056?mt=8" target="_blank" rel="noopener">iTunes</a></p><blockquote><p>Shadowrocket </p></blockquote><p>Shadowrocket 是一个通用的 iOS VPN 应用，它支持众多协议，如 Shadowsocks、VMess、SSR 等。</p><p>下载：<a href="https://itunes.apple.com/us/app/shadowrocket/id932747118?mt=8" target="_blank" rel="noopener">iTunes</a></p><blockquote><p>Pepi（原名ShadowRay）</p></blockquote><p>Pepi 是一个兼容 V2Ray 的 iOS 应用，它可以创建基于 VMess 的 VPN 连接，并与 V2Ray 服务器通信。</p><p>下载：<a href="https://itunes.apple.com/us/app/pepi/id1283082051?mt=8" target="_blank" rel="noopener">iTunes</a></p><blockquote><p>Quantumult </p></blockquote><p>下载：<a href="https://itunes.apple.com/us/app/quantumult/id1252015438?mt=8" target="_blank" rel="noopener">iTunes</a></p><blockquote><p>BifrostV </p></blockquote><p>BifrostV 是一个基于 V2Ray 内核的 Android 应用，它支持 VMess、Shadowsocks、Socks 协议。</p><p>下载：<a href="https://play.google.com/store/apps/details?id=com.github.dawndiy.bifrostv" target="_blank" rel="noopener">Play Store</a> | <a href="https://apkpure.com/bifrostv/com.github.dawndiy.bifrostv" target="_blank" rel="noopener">APK Pure</a></p><blockquote><p>V2RayNG </p></blockquote><p>V2RayNG 是一个基于 V2Ray 内核的 Android 应用，它可以创建基于 VMess 的 VPN 连接。</p><p>下载：<a href="https://play.google.com/store/apps/details?id=com.v2ray.ang" target="_blank" rel="noopener">Play Store</a> | <a href="https://github.com/2dust/v2rayNG" target="_blank" rel="noopener">GitHub</a></p><h2 id="在线工具-资源"><a href="#在线工具-资源" class="headerlink" title="在线工具/资源"></a>在线工具/资源</h2><blockquote><p>VeekXT V2Ray配置生成</p></blockquote><p>支持 4.x 版本的配置文件生成器 <a href="https://www.veekxt.com/utils/v2ray_gen" target="_blank" rel="noopener">veekxt.com</a></p><blockquote><p>V2Ray 配置生成器</p></blockquote><p>静态 V2Ray 配置文件生成页面 <a href="https://github.com/htfy96/v2ray-config-gen" target="_blank" rel="noopener">GitHub</a></p><blockquote><p>UUID Generator</p></blockquote><p>VMess User ID 生成工具 <a href="https://www.uuidgenerator.net/" target="_blank" rel="noopener">uuidgenerator.net</a></p><blockquote><p>vTemplate 项目仓库</p></blockquote><p>一个 V2Ray 配置文件模板收集仓库 <a href="https://github.com/KiriKira/vTemplate" target="_blank" rel="noopener">GitHub</a></p><h1 id="VMess-协议"><a href="#VMess-协议" class="headerlink" title="VMess 协议"></a>VMess 协议</h1><p>VMess 是 V2Ray 原创的加密通讯协议。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>当前版本号为 1。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><h3 id="底层协议"><a href="#底层协议" class="headerlink" title="底层协议"></a>底层协议</h3><p>VMess 是一个基于 TCP 的协议，所有数据使用 TCP 传输。</p><h3 id="用户-ID"><a href="#用户-ID" class="headerlink" title="用户 ID"></a>用户 ID</h3><p>ID 等价于 <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier" target="_blank" rel="noopener">UUID</a>，是一个 16 字节长的随机数，它的作用相当于一个令牌（Token）。 一个 ID 形如：de305d54-75b4-431b-adb2-eb6b9e546014，几乎完全随机，可以使用任何的 UUID 生成器来生成，比如<a href="https://www.uuidgenerator.net/" target="_blank" rel="noopener">这个</a>。</p><p>用户 ID 可在<a href="https://www.v2ray.com/developer/chapter_02/01_overview.md" target="_blank" rel="noopener">配置文件</a>中指定。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul><li><p>MD5: </p><p>MD5 函数</p><ul><li>输入参数为任意长度的 byte 数组</li></ul></li><li><p>输出为一个 16 byte 的数组</p></li><li><p>HMAC: </p><p>HMAC 函数</p><ul><li>输入参数为：<ul><li>H：散列函数</li></ul></li></ul></li><li><p>K：密钥，任意长度的 byte 数组</p></li><li><p>M：消息，任意长度的 byte 数组</p></li><li><p>Shake: </p><p>SHA3-Shake128 函数</p><ul><li>输入参数为任意长度的字符串</li></ul></li><li><p>输出为任意长度的字符串</p></li></ul><h2 id="通讯过程"><a href="#通讯过程" class="headerlink" title="通讯过程"></a>通讯过程</h2><p>VMess 是一个无状态协议，即客户端和服务器之间不需要握手即可直接传输数据，每一次数据传输对之前和之后的其它数据传输没有影响。 VMess 的客户端发起一次请求，服务器判断该请求是否来自一个合法的客户端。如验证通过，则转发该请求，并把获得的响应发回给客户端。 VMess 使用非对称格式，即客户端发出的请求和服务器端的响应使用了不同的格式。</p><h2 id="客户端请求"><a href="#客户端请求" class="headerlink" title="客户端请求"></a>客户端请求</h2><p>无法复制加载中的内容</p><h3 id="认证信息"><a href="#认证信息" class="headerlink" title="认证信息"></a>认证信息</h3><p>认证信息是一个 16 字节的哈希（hash）值，它的计算方式如下：</p><ul><li><p>H = MD5</p></li><li><p>K = 用户 ID (16 字节)</p></li><li><p>M = UTC 时间，精确到秒，取值为当前时间的前后 30 秒随机值(8 字节, Big Endian)</p></li><li><p>Hash = HMAC(H, K, M)</p></li></ul><h3 id="指令部分"><a href="#指令部分" class="headerlink" title="指令部分"></a>指令部分</h3><p>指令部分经过 AES-128-CFB 加密：</p><ul><li><p>Key：MD5(用户 ID + []byte(‘c48619fe-8f02-49e0-b9e9-edf763e17e21’))</p></li><li><p>IV：MD5(X + X + X + X)，X = []byte(认证信息生成的时间) (8 字节, Big Endian)</p></li></ul><p>无法复制加载中的内容</p><p>选项 Opt 细节：（当某一位为 1 时，表示该选项启用）</p><p>无法复制加载中的内容</p><p>其中：</p><ul><li><p>版本号 Ver：始终为 1；</p></li><li><p>数据加密 IV：随机值；</p></li><li><p>数据加密 Key：随机值；</p></li><li><p>响应认证 V：随机值；</p></li><li><p>选项 Opt：</p><ul><li>S (0x01)：标准格式的数据流（建议开启）；</li></ul></li><li><p>R (0x02)：客户端期待重用 TCP 连接（V2Ray 2.23+ 弃用）；</p><ul><li>只有当 S 开启时，这一项才有效；</li></ul></li><li><p>M (0x04)：开启元数据混淆（建议开启）；</p><ul><li>只有当 S 开启时，这一项才有效；</li></ul></li><li><p>当其项开启时，客户端和服务器端需要分别构造两个 Shake 实例，分别为 RequestMask = Shake(请求数据 IV), ResponseMask = Shake(响应数据 IV)。</p></li><li><p>X：保留</p></li><li><p>余量 P：在校验值之前加入 P 字节的随机值；</p></li><li><p>加密方式：指定数据部分的加密方式，可选的值有：</p><ul><li>0x00：AES-128-CFB；</li></ul></li><li><p>0x01：不加密；</p></li><li><p>0x02：AES-128-GCM；</p></li><li><p>0x03：ChaCha20-Poly1305；</p></li><li><p>指令 Cmd：</p><ul><li>0x01：TCP 数据；</li></ul></li><li><p>0x02：UDP 数据；</p></li><li><p>端口 Port：Big Endian 格式的整型端口号；</p></li><li><p>地址类型 T：</p><ul><li>0x01：IPv4</li></ul></li><li><p>0x02：域名</p></li><li><p>0x03：IPv6</p></li><li><p>地址 A：</p><ul><li>当 T = 0x01 时，A 为 4 字节 IPv4 地址；</li></ul></li><li><p>当 T = 0x02 时，A 为 1 字节长度（L） + L 字节域名；</p></li><li><p>当 T = 0x03 时，A 为 16 字节 IPv6 地址；</p></li><li><p>校验 F：指令部分除 F 外所有内容的 FNV1a hash；</p></li></ul><h3 id="数据部分"><a href="#数据部分" class="headerlink" title="数据部分"></a>数据部分</h3><p>数据部分有两种格式，默认为基本格式。</p><h4 id="基本格式-（弃用）"><a href="#基本格式-（弃用）" class="headerlink" title="基本格式 （弃用）"></a>基本格式 （弃用）</h4><p><strong>此格式仅作为向后兼容所用，在之后的版本中可能被删除。</strong></p><p>所有数据均认为是请求的实际内容。这些内容将被发往指令部分所指定的地址。当 Cmd = 0x01 时，这些数据将以 TCP 的形式发送；当 Cmd = 0x02 时，这些数据将以 UDP 形式发送。</p><p>此格式支持“不加密”和“AES-128-CFB”两种加密方式，加密的 Key 和 IV 由指令部分指定。</p><h4 id="标准格式"><a href="#标准格式" class="headerlink" title="标准格式"></a>标准格式</h4><p>当 Opt(S) 开启时，数据部分使用此格式。实际的请求数据被分割为若干个小块，每个小块的格式如下。服务器校验完所有的小块之后，再按基本格式的方式进行转发。</p><p>无法复制加载中的内容</p><p>其中：</p><ul><li><p>长度 L：Big Endian 格式的整型，最大值为 2^14；</p><ul><li>当 Opt(M) 开启时，L 的值 = 真实值 xor Mask。Mask = (RequestMask.NextByte() &lt;&lt; 8) + RequestMask.NextByte()；</li></ul></li><li><p>数据包：由指定的加密方式加密过的数据包；</p></li></ul><p>在传输结束之前，数据包中必须有实际数据，即除了长度和认证数据之外的数据。当传输结束时，客户端必须发送一个空的数据包，即 L = 0（不加密） 或认证数据长度（有加密），来表示传输结束。</p><p>按加密方式不同，数据包的格式如下：</p><ul><li><p>不加密：</p><ul><li>L 字节：实际数据；</li></ul></li><li><p>AES-128-CFB：整个数据部分使用 AES-128-CFB 加密</p><ul><li>4 字节：实际数据的 FNV1a hash；</li></ul></li><li><p>L - 4 字节：实际数据；</p></li><li><p>AES-128-GCM：Key 为指令部分的 Key，IV = count (2 字节) + IV (10 字节)。count 从 0 开始递增，每个数据包加 1；IV 为 指令部分 IV 的第 3 至第 12 字节。</p><ul><li>L - 16 字节：实际数据；</li></ul></li><li><p>16 字节：GCM 认证信息</p></li><li><p>ChaCha20-Poly1305：Key = MD5(指令部分 Key) + MD5(MD5(指令部分 Key))，IV = count (2 字节) + IV (10 字节)。count 从 0 开始递增，每个数据包加 1；IV 为 指令部分 IV 的第 3 至第 12 字节。</p><ul><li>L - 16 字节：实际数据；</li></ul></li><li><p>16 字节：Poly1305 认证信息</p></li></ul><h2 id="服务器应答"><a href="#服务器应答" class="headerlink" title="服务器应答"></a>服务器应答</h2><p>应答头部数据使用 AES-128-CFB 加密，IV 为 MD5(数据加密 IV)，Key 为 MD5(数据加密 Key)。实际应答数据视加密设置不同而不同。</p><p>无法复制加载中的内容</p><p>其中：</p><ul><li><p>响应认证 V：必须和客户端请求中的响应认证 V 一致；</p></li><li><p>选项 Opt：</p><ul><li>0x01：服务器端准备重用 TCP 连接（V2Ray 2.23+ 弃用）；</li></ul></li><li><p>指令 Cmd：</p><ul><li>0x01：动态端口指令</li></ul></li><li><p>实际应答数据：</p><ul><li>如果请求中的 Opt(S) 开启，则使用标准格式，否则使用基本格式。</li></ul></li><li><p>格式均和请求数据相同。</p><ul><li>当 Opt(M) 开启时，长度 L 的值 = 真实值 xor Mask。Mask = (ResponseMask.NextByte() &lt;&lt; 8) + ResponseMask.NextByte()；</li></ul></li></ul><h3 id="动态端口指令"><a href="#动态端口指令" class="headerlink" title="动态端口指令"></a>动态端口指令</h3><p>无法复制加载中的内容</p><p>其中：</p><ul><li><p>端口 Port：Big Endian 格式的整型端口号；</p></li><li><p>有效时间 T：分钟数；</p></li></ul><p>客户端在收到动态端口指令时，服务器已开放新的端口用于通信，这时客户端可以将数据发往新的端口。在 T 分钟之后，这个端口将失效，客户端必须重新使用主端口进行通信。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>为确保向前兼容性，所有保留字段的值必须为 0。</li></ul><h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="mKCP-协议"><a href="#mKCP-协议" class="headerlink" title="mKCP 协议"></a>mKCP 协议</h1><p>mKCP 是流式传输协议，由 <a href="https://github.com/skywind3000/kcp" target="_blank" rel="noopener">KCP 协议</a>修改而来，可以按顺序传输任意的数据流。</p><h2 id="版本-1"><a href="#版本-1" class="headerlink" title="版本"></a>版本</h2><p>mKCP 没有版本号，不保证版本之间兼容性。</p><h2 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h2><h3 id="底层协议-1"><a href="#底层协议-1" class="headerlink" title="底层协议"></a>底层协议</h3><p>mKCP 是一个基于 UDP 的协议，所有通讯使用 UDP 传输。</p><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><ul><li><p>fnv: </p><p>FNV-1a</p><p> 哈希函数</p><ul><li>输入参数为任意长度的字符串；</li></ul></li><li><p>输入出一个 32 位无符号整数；</p></li></ul><h2 id="通讯过程-1"><a href="#通讯过程-1" class="headerlink" title="通讯过程"></a>通讯过程</h2><ol><li>mKCP 将数据流拆成若干个数据包进行发送。一个数据流有一个唯一标识，用以区分不同的数据流。数据流中的每一个数据包都携带了同样的标识。</li><li>mKCP 没有握手过程，当收到一个数据包时，根据其携带的数据流的标识来判断是否为新的通话，或是正在进行中的通话。</li><li>每一个数据包中包含若干个片段（Segment），片段分为三类：数据（Data）、确认（ACK）、心跳（Ping）。每个片段需要单独处理。</li></ol><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><h3 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h3><p>无法复制加载中的内容</p><p>其中：</p><ul><li><p>认证信息 A = fnv(片段部分），big endian；</p></li><li><p>片段部分可能包含多个片段；</p></li></ul><h3 id="数据片段"><a href="#数据片段" class="headerlink" title="数据片段"></a>数据片段</h3><p>无法复制加载中的内容</p><p>其中：</p><ul><li><p>标识 Conv: mKCP 数据流的标识</p></li><li><p>指令 Cmd: 常量 0x01</p></li><li><p>选项 Opt: 可选的值有：</p><ul><li>0x00: 空选项</li></ul></li><li><p>0x01: 对方已发出所有数据</p></li><li><p>时间戳 Ts: 当前片段从远端发送出来时的时间，big endian</p></li><li><p>序列号 Sn: 该数据片段时数据流中的位置，起始片段的序列号为 0，之后每个新片段按顺序加 1</p></li><li><p>未确认序列号 Una: 远端主机正在发送的，且尚未收到确认的最小的 Sn</p></li></ul><h3 id="确认片段"><a href="#确认片段" class="headerlink" title="确认片段"></a>确认片段</h3><p>无法复制加载中的内容</p><p>其中：</p><ul><li><p>标识 Conv: mKCP 数据流的标识</p></li><li><p>指令 Cmd: 常量 0x00</p></li><li><p>选项 Opt: 同上</p></li><li><p>窗口 Wnd: 远端主机可以接收的最大序列号</p></li><li><p>下一接收序列号 Sn: 远端主机未收到的数据片段中的最小序列号</p></li><li><p>时间戳 Ts: 远端主机最新收到的数据片段的时间戳，可用于计算延迟</p></li><li><p>已收到的序列号: 每个 4 字节，表示此序列号的数据已经确认收到</p></li></ul><p>注释：</p><ul><li>远程主机期待收到序列号 [Sn, Wnd) 范围内的数据</li></ul><h3 id="心跳片段"><a href="#心跳片段" class="headerlink" title="心跳片段"></a>心跳片段</h3><p>无法复制加载中的内容</p><p>其中：</p><ul><li><p>标识 Conv: mKCP 数据流的标识</p></li><li><p>指令 Cmd: 可选的值有</p><ul><li>0x02: 远端主机强行终止会话</li></ul></li><li><p>0x03: 正常心跳</p></li><li><p>选项 Opt: 同上</p></li><li><p>未确认序列号 Una: 同数据片段的 Una</p></li><li><p>下一接收序列号 Sn: 同确认片段的 Sn</p></li><li><p>延迟 Rto: 远端主机自己计算出的延迟</p></li></ul><h1 id="Mux-Cool-协议"><a href="#Mux-Cool-协议" class="headerlink" title="Mux.Cool 协议"></a>Mux.Cool 协议</h1><p>Mux.Cool 协议是一个多路复用传输协议，用于在一条已建立的数据流中传输多个各自独立的数据流。</p><h2 id="版本-2"><a href="#版本-2" class="headerlink" title="版本"></a>版本</h2><p>当前版本是 1 Beta。</p><h2 id="依赖-2"><a href="#依赖-2" class="headerlink" title="依赖"></a>依赖</h2><h3 id="底层协议-2"><a href="#底层协议-2" class="headerlink" title="底层协议"></a>底层协议</h3><p>Mux.Cool 必须运行在一个已建立的可靠数据流之上。</p><h2 id="通讯过程-2"><a href="#通讯过程-2" class="headerlink" title="通讯过程"></a>通讯过程</h2><p>一个 Mux.Cool 连接中可传输若干个子连接，每个子连接有一个独立的 ID 和状态。传输过程由帧（Frame）组成，每一帧用于传输一个特定的子连接的数据。</p><h3 id="客户端行为"><a href="#客户端行为" class="headerlink" title="客户端行为"></a>客户端行为</h3><p>当有连接需求时并且没有现有可用的连接时，客户端向服务器发起一个新连接，以下称为“主连接”。</p><ol><li>一个主连接可用于发送若干个子连接。客户端可自主决定主连接可承载的子连接数量。</li><li>对于一个新的子连接，客户端必须发送状态<code>New</code>以通知服务器建立子连接，然后使用状态<code>Keep</code>来传送数据。</li><li>当子连接结束时，客户端发送<code>End</code>状态来通知服务器关闭子连接。</li><li>客户端可自行决定何时关闭主连接，但必须确定服务器也同时保持连接。</li><li>客户端可使用 KeepAlive 状态来避免服务器关闭主连接。</li></ol><h3 id="服务器端行为"><a href="#服务器端行为" class="headerlink" title="服务器端行为"></a>服务器端行为</h3><p>当服务器端接收到新的子连接时，服务器应当按正常的连接来处理。</p><ol><li>当收到状态<code>End</code>时，服务器端可以关闭对目标地址的上行连接。</li><li>在服务器的响应中，必须使用与请求相同的 ID 来传输子连接的数据。</li><li>服务器不能使用<code>New</code>状态。</li><li>服务器可使用 KeepAlive 状态来避免客户端关闭主连接。</li></ol><h2 id="传输格式"><a href="#传输格式" class="headerlink" title="传输格式"></a>传输格式</h2><p>Mux.Cool 使用对称传输格式，即客户端和服务器发送和接收相同格式的数据。</p><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p>无法复制加载中的内容</p><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>元数据有若干种类型，由状态 S 来区分。所有类型的元数据都包含 ID 和 Opt 两项，其含义为：</p><ul><li><p>ID: 子连接的唯一标识</p></li><li><p>Opt:</p><ul><li>D(0x01): 有额外数据</li></ul></li></ul><p>当选项 Opt(D) 开启时，额外数据格式如下：</p><p>无法复制加载中的内容</p><h4 id="新建子连接-New"><a href="#新建子连接-New" class="headerlink" title="新建子连接 (New)"></a>新建子连接 (New)</h4><p>无法复制加载中的内容</p><p>其中：</p><ul><li><p>网络类型 N：</p><ul><li>0x01：TCP，表示当前子连接的流量应当以 TCP 的方式发送至目标。</li></ul></li><li><p>0x02：UDP，表示当前子连接的流量应当以 UDP 的方式发送至目标。</p></li><li><p>地址类型 T：</p><ul><li>0x01：IPv4</li></ul></li><li><p>0x02：域名</p></li><li><p>0x03：IPv6</p></li><li><p>地址 A：</p><ul><li>当 T = 0x01 时，A 为 4 字节 IPv4 地址；</li></ul></li><li><p>当 T = 0x02 时，A 为 1 字节长度（L） + L 字节域名；</p></li><li><p>当 T = 0x03 时，A 为 16 字节 IPv6 地址；</p></li></ul><p>在新建子连接时，若 Opt(D) 开启，则这一帧所带的数据需要被发往目标主机。</p><h4 id="保持子连接-Keep"><a href="#保持子连接-Keep" class="headerlink" title="保持子连接 (Keep)"></a>保持子连接 (Keep)</h4><p>无法复制加载中的内容</p><p>在保持子连接时，若 Opt(D) 开启，则这一帧所带的数据需要被发往目标主机。</p><h4 id="关闭子连接-End"><a href="#关闭子连接-End" class="headerlink" title="关闭子连接 (End)"></a>关闭子连接 (End)</h4><p>无法复制加载中的内容</p><p>在保持子连接时，若 Opt(D) 开启，则这一帧所带的数据需要被发往目标主机。</p><h4 id="保持连接-KeepAlive"><a href="#保持连接-KeepAlive" class="headerlink" title="保持连接 (KeepAlive)"></a>保持连接 (KeepAlive)</h4><p>无法复制加载中的内容</p><p>在保持连接时:</p><ul><li><p>若 Opt(D) 开启，则这一帧所带的数据必须被丢弃。</p></li><li><p>ID 可为随机值。</p></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>Mux.Cool 协议与底层协议无关，理论上可以使用任何可靠的流式连接来传输 Mux.Cool 的协议数据。</p><p>在目标导向的协议如 Shadowsocks 和 VMess 协议中，连接建立时必须包含一个指定的地址。为了保持兼容性，Mux.Cool 协议指定地址为“v1.mux.cool”。即当主连接的目标地址与之匹配时，则进行 Mux.Cool 方式的转发，否则按传统方式进行转发。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VPN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MakeFile详解</title>
      <link href="/posts/dd0c.html"/>
      <url>/posts/dd0c.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-Makefile-呢？"><a href="#什么是-Makefile-呢？" class="headerlink" title="什么是 Makefile 呢？"></a>什么是 Makefile 呢？</h2><p>Makefile 可以简单的认为是一个工程文件的编译规则，描述了整个工程的编译和链接等规则。其中包含了那些文件需要编译，那些文件不需要编译，那些文件需要先编译，那些文件需要后编译，那些文件需要重建等等。编译整个工程需要涉及到的，在 Makefile 中都可以进行描述。换句话说，Makefile 可以使得我们的项目工程的编译变得自动化，不需要每次都手动输入一堆源文件和参数。</p><p>以 Linux 下的C语言开发为例来具体说明一下，多文件编译生成一个文件，编译的命令如下所示：</p><pre><code>gcc -o outfile name1.c name2.c ...</code></pre><p>outfile 要生成的可执行程序的名字，nameN.c 是源文件的名字。这是我们在 Linux 下使用 gcc 编译器编译 C 文件的例子。如果我们遇到的源文件的数量不是很多的话，可以选择这样的编译方式。如果源文件非常的多的话，就会遇到下面的这些问题。</p><p>1) 编译的时候需要链接库的的问题。拿C语言来说，编译的时候 gcc 只会默认链接一些基本的C语言标准库，很多源文件依赖的标准库都需要我们手动链接。</p><p>下面列举了一些需要我们手动链接的标准库：</p><ul><li><p>name1.c 用到了数学计算库 math 中的函数，我们得手动添加参数 -Im；</p></li><li><p>name4.c 用到了小型数据库 SQLite 中的函数，我们得手动添加参数 -lsqlite3；</p></li><li><p>name5.c 使用到了线程，我们需要去手动添加参数 -lpthread。</p></li></ul><p>因为有很多的文件，还要去链接很多的第三方库。所以在编译的时候命令会很长，并且在编译的时候我们可能会涉及到文件链接的顺序问题，所以手动编译会很麻烦。</p><p>如果我们学会使用 Makefile 就不一样了，它会彻底简化编译的操作。把要链接的库文件放在 Makefile 中，制定相应的规则和对应的链接顺序。这样只需要执行 make 命令，工程就会自动编译。每次想要编译工程的时候就执行 make ，省略掉手动编译中的参数选项和命令，非常的方便。</p><p>2) 编译大的工程会花费很长的时间。</p><p>如果我们去做项目开发，免不了要去修改工程项目的源文件，每次修改后都要去重新编译。一个大的工程项目可不止有几个的源文件，里面的源文件个数可能有成百上千个。例如一个内核，或者是一个软件的源码包。这些都是我们做开发经常会遇到的。要完成这样的文件的编译，我们消耗的时间可不是一点点。如果文件特别大的话我们可能要花上半天的时间。</p><p>对于这样的问题我们 Makefile 可以解决吗？当然是可以的，Makefile 支持多线程并发操作，会极大的缩短我们的编译时间，并且当我们修改了源文件之后，编译整个工程的时候，make 命令只会编译我们修改过的文件，没有修改的文件不用重新编译，也极大的解决了我们耗费时间的问题。</p><p>这其实是我们遇到的比较常见的问题，当然可能遇到的问题还会有很多，比如：工程文件中的源文件的类型很多，编译的话需要选择的编译器；文件可能会分布在不同的目录中，使用时需要调价路径。这些问题都可以通过 Makefile 解决。并且文件中的 Makefile 只需要完成一次，一般我们只要不增加或者是删除工程中的文件，Makefile 基本上不用去修改，编译时只用一个 make 命令。为我们提供了极大的便利，很大程度上提高编译的效率。</p><h2 id="Makefile文件中包含哪些规则？"><a href="#Makefile文件中包含哪些规则？" class="headerlink" title="Makefile文件中包含哪些规则？"></a>Makefile文件中包含哪些规则？</h2><p>想要书写一个完整的 Makefile文件，需要了解 Makefile 的相关的书写规则。我们已经知道了 Makefile 描述的是文件编译的相关规则，它的规则主要是两个部分组成，分别是依赖的关系和执行的命令，其结构如下所示：</p><pre><code>targets : prerequisites  command</code></pre><p>或者是</p><pre><code>targets : prerequisites; command  command</code></pre><p>相关说明如下：</p><ul><li><p>targets：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签；</p></li><li><p>prerequisites：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是多个，也可以是没有；</p></li><li><p>command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。</p></li></ul><p>注意：我们的目标和依赖文件之间要使用冒号分隔开，命令的开始一定要使用<code>Tab</code>键。</p><p>通过下面的例子来具体使用一下 Makefile 的规则，Makefile文件中添代码如下：</p><pre><code>test:test.c    gcc -o test test.c</code></pre><p>上述代码实现的功能就是编译 test.c 文件，通过这个实例可以详细的说明 Makefile 的具体的使用。其中 test 是的目标文件，也是我们的最终生成的可执行文件。依赖文件就是 test.c 源文件，重建目标文件需要执行的操作是<code>gcc -o test test.c</code>。这就是 Makefile 的基本的语法规则的使用。使用 Makefile 的方式：首先需要编写好 Makefile 文件，然后在 shell 中执行 make 命令，程序就会自动执行，得到最终的目标文件。</p><p>通过上面的例子我们可以了解到，Makefile 的规则很简单，但这并不是 Makefile 的全部，这个仅仅是它的冰山一角。仅仅靠一个规则满足不了我们对于大的工程项目的编译。甚至几个文件的编译都会出现问题，所以要学习的东西还有很多。</p><p>简单的概括一下Makefile 中的内容，它主要包含有五个部分，分别是：</p><h4 id="1-显式规则"><a href="#1-显式规则" class="headerlink" title="1) 显式规则"></a>1) 显式规则</h4><p>显式规则说明了，如何生成一个或多的的目标文件。这是由 Makefile 的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</p><h4 id="2-隐晦规则"><a href="#2-隐晦规则" class="headerlink" title="2) 隐晦规则"></a>2) 隐晦规则</h4><p>由于我们的 make 命名有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写 Makefile，这是由 make 命令所支持的。</p><h4 id="3-变量的定义"><a href="#3-变量的定义" class="headerlink" title="3) 变量的定义"></a>3) 变量的定义</h4><p>在 Makefile 中我们要定义一系列的变量，变量一般都是字符串，这个有点像C语言中的宏，当 Makefile 被执行时，其中的变量都会被扩展到相应的引用位置上。</p><h4 id="4-文件指示"><a href="#4-文件指示" class="headerlink" title="4) 文件指示"></a>4) 文件指示</h4><p>其包括了三个部分，一个是在一个 Makefile 中引用另一个 Makefile，就像C语言中的 include 一样；另一个是指根据某些情况指定 Makefile 中的有效部分，就像C语言中的预编译 #if 一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</p><h4 id="5-注释"><a href="#5-注释" class="headerlink" title="5) 注释"></a>5) 注释</h4><p>Makefile 中只有行注释，和 UNIX 的 Shell 脚本一样，其注释是用“#”字符，这个就像 C/<a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a> 中的“//”一样。如果你要在你的 Makefile 中使用“#”字符，可以用反斜框进行转义，如：“#”。</p><h2 id="Makefile的工作流程"><a href="#Makefile的工作流程" class="headerlink" title="Makefile的工作流程"></a>Makefile的工作流程</h2><p>Makefile 的具体工作流程可以通过例子来看一下：创建一个包含有多个源文件和 Makefile 的目录文件，源文件之间相互关联。在 Makefile 中添加下面的代码：</p><ol><li>main:main.o test1.o test2.o</li><li>gcc main.o test1.o test2.o -o main</li><li>main.o:main.c test.h</li><li>gcc -c main.c -o main.o</li><li>test1.o:test1.c test.h</li><li>gcc -c test1.c -o test1.o</li><li>test2.o:test2.c test.h</li><li>gcc -c test2.c -o test2.o</li></ol><p>在我们编译项目文件的时候，默认情况下，make 执行的是 Makefile 中的第一规则（Makefile 中出现的第一个依赖关系），此规则的第一目标称之为“最终目标”或者是“终极目标”。</p><p>在 shell 命令行执行的 make 命令，就可以得到可执行文件 main 和中间文件 main.o、test1.o 和 test2.o，main 就是我们要生成的最终文件。通过 Makefile 我们可以发现，目标 main”在 Makefile 中是第一个目标，因此它就是 make 的终极目标，当修改过任何 C 文件后，执行 make 将会重建终极目标 main。</p><p>它的具体工作顺序是：当在 shell 提示符下输入 make 命令以后。 make 读取当前目录下的 Makefile 文件，并将 Makefile 文件中的第一个目标作为其执行的“终极目标”，开始处理第一个规则（终极目标所在的规则）。在我们的例子中，第一个规则就是目标 “main” 所在的规则。规则描述了 “main” 的依赖关系，并定义了链接 “.o” 文件生成目标 “main” 的命令；make 在执行这个规则所定义的命令之前，首先处理目标 “main” 的所有的依赖文件（例子中的那些 “.o” 文件）的更新规则（以这些 “.o” 文件为目标的规则）。</p><p>对这些 “.o” 文件为目标的规则处理有下列三种情况：</p><ul><li><p>目标 “.o” 文件不存在，使用其描述规则创建它；</p></li><li><p>目标 “.o” 文件存在，目标 “.o” 文件所依赖的 “.c” 源文件 “.h” 文件中的任何一个比目标 “.o” 文件“更新”（在上一次 make 之后被修改）。则根据规则重新编译生成它；</p></li><li><p>目标 “.o” 文件存在，目标 “.o” 文件比它的任何一个依赖文件（”.c” 源文件、”.h” 文件）“更新”（它的依赖文件在上一次 make 之后没有被修改），则什么也不做。</p></li></ul><p>通过上面的更新规则我们可以了解到中间文件的作用，也就是编译时生成的 “.o” 文件。作用是检查某个源文件是不是进行过修改，最终目标文件是不是需要重建。我们执行 make 命令时，只有修改过的源文件或者是不存在的目标文件会进行重建，而那些没有改变的文件不用重新编译，这样在很大程度上节省时间，提高编程效率。小的工程项目可能体会不到，项目工程文件越大，效果才越明显。</p><p>当然 make 命令能否顺利的执行，还在于我们是否制定了正确的的依赖规则，当前目录下是不是存在需要的依赖文件，只要任意一点不满足，我们在执行 make 的时候就会出错。所以完成一个正确的 Makefile 不是一件简单的事情。</p><h3 id="清除工作目录中的过程文件"><a href="#清除工作目录中的过程文件" class="headerlink" title="清除工作目录中的过程文件"></a>清除工作目录中的过程文件</h3><p>我们在使用的时候会产生中间文件会让整个文件看起来很乱，所以在编写 Makefile 文件的时候会在末尾加上这样的规则语句：</p><p>.PHONY:clean</p><p>clean:</p><p>rm -rf *.o test</p><p>其中 “*.o” 是执行过程中产生的中间文件，”test” 是最终生成的执行文件。我们可以看到 clean 是独立的，它只是一个伪目标（在《Makefile伪目标》的章节中详细介绍），不是具体的文件。不会与第一个目标文件相关联，所以我们在执行 make 的时候也不会执行下面的命令。在shell 中执行 “make clean” 命令，编译时的中间文件和生成的最终目标文件都会被清除，方便我们下次的使用。</p><h2 id="Makefile通配符的使用"><a href="#Makefile通配符的使用" class="headerlink" title="Makefile通配符的使用"></a>Makefile通配符的使用</h2><p>Makefile 是可以使用 shell 命令的，所以 shell 支持的通配符在 Makefile 中也是同样适用的。 shell 中使用的通配符有：”*”，”?”，”[…]”。具体看一下这些通配符的表示含义和具体的使用方法。</p><style><!--br {mso-data-placement:same-cell;}--> td {white-space:pre-wrap;border:1px solid #dee0e3;}</style> <byte-sheet-html-origin data-id="1hcB1LqrnX-1623856826597" data-version="3" data-is-embed="true"><p>| 关于自动化变量可以理解为由 Makefile 自动产生的变量。在模式规则中，规则的目标和依赖的文件名代表了一类的文件。规则的命令是对所有这一类文件的描述。我们在 Makefile 中描述规则时，依赖文件和目标文件是变动的，显然在命令中不能出现具体的文件名称，否则模式规则将失去意义。 | 使用说明 |<br>|  | 匹配0个或者是任意个字符 |<br>| 那么模式规则命令中该如何表示文件呢？就需要使用“自动化变量”，自动化变量的取值根据执行的规则来决定，取决于执行规则的目标文件和依赖文件。下面是对所有的自动化变量进行的说明： | 匹配任意一个字符 |<br>| [] | 我们可以指定匹配的字符放在 “[]” 中 | </p><p>通配符可以出现在模式的规则中，也可以出现在命令中，详细的使用情况如下。</p><p>实例 1：</p><pre><code>.PHONY:cleanclean:    rm -rf *.o test</code></pre><p>这是在 Makefile 中经常使用的规则语句。这个实例可以说明通配符可以使用在规则的命令当中，表示的是任意的以 .o 结尾的文件。</p><p>实例 2：</p><pre><code>test:*.c    gcc -o $@ $^</code></pre><p>这个实例可以说明我们的通配符不仅可以使用在规则的命令中，还可以使用在规则中。用来表示生所有的以 .c 结尾的文件。</p><p>但是如果我们的通配符使用在依赖的规则中的话一定要注意这个问题：不能通过引用变量的方式来使用，如下所示。</p><pre><code>OBJ=*.ctest:$(OBJ)    gcc -o $@ $^</code></pre><p>我们去执行这个命令的时候会出现错误，提示我们没有 “<em>.c” 文件，实例中我们想要表示的是当前目录下所有的 “.c” 文件，但是我们在使用的时候并没有展开，而是直接识别成了一个文件。文件名是 “</em>.c”。</p><p>如果我们就是相要通过引用变量的话，我们要使用一个函数 “wildcard”，这个函数在我们引用变量的时候，会帮我们展开。我们把上面的代码修改一下就可以使用了。</p><pre><code>OBJ=$(wildcard *.c)test:$(OBJ)    gcc -o $@ $^</code></pre><p>这样我们再去使用的时候就可以了。调用函数的时候，会帮我们自动展开函数。</p><p>还有一个和通配符 “*” 相类似的字符，这个字符是 “%”，也是匹配任意个字符，使用在我们的的规则当中。</p><pre><code>test:test.o test1.o    gcc -o $@ $^%.o:%.c    gcc -o $@ $^</code></pre><p>“%.o” 把我们需要的所有的 “.o” 文件组合成为一个列表，从列表中挨个取出的每一个文件，”%” 表示取出来文件的文件名（不包含后缀），然后找到文件中和 “%”名称相同的 “.c” 文件，然后执行下面的命令，直到列表中的文件全部被取出来为止。</p><p>这个属于 Makefile 中静态模规则：规则存在多个目标，并且不同的目标可以根据目标文件的名字来自动构造出依赖文件。跟我们的多规则目标的意思相近，但是又不相同。</p><h2 id="Makefile变量的定义和使用"><a href="#Makefile变量的定义和使用" class="headerlink" title="Makefile变量的定义和使用"></a>Makefile变量的定义和使用</h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>Makefile 文件中定义变量的基本语法如下：变量的名称=值列表</p><p>Makefile 中的变量的使用其实非常的简单，因为它并没有像其它语言那样定义变量的时候需要使用数据类型。变量的名称可以由大小写字母、阿拉伯数字和下划线构成。等号左右的空白符没有明确的要求，因为在执行 make 的时候多余的空白符会被自动的删除。至于值列表，既可以是零项，又可以是一项或者是多项。如：VALUE_LIST = one two three</p><p>调用变量的时候可以用 “$(VALUE_LIST)” 或者是 “${VALUE_LIST}” 来替换，这就是变量的引用。实例：</p><pre><code>OBJ=main.o test.o test1.o test2.otest:$(OBJ)      gcc -o test $(OBJ)</code></pre><p>这就是引用变量后的 Makefile 的编写，比我们之前的编写方式要简单的多。当要添加或者是删除某个依赖文件的时候，我们只需要改变变量 “OBJ” 的值就可以了。</p><h3 id="变量的基本赋值"><a href="#变量的基本赋值" class="headerlink" title="变量的基本赋值"></a>变量的基本赋值</h3><p>知道了如何定义，下面我们来说一下 Makefile 的变量的四种基本赋值方式：</p><ul><li><p>简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。</p></li><li><p>递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。</p></li><li><p>条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。</p></li><li><p>追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。</p></li></ul><h4 id="简单赋值"><a href="#简单赋值" class="headerlink" title="简单赋值"></a>简单赋值</h4><pre><code>x:=fooy:=$(x)bx:=newtest：      @echo "y=&gt;$(y)"      @echo "x=&gt;$(x)"</code></pre><p>在 shell 命令行执行<code>make test</code>我们会看到:y=&gt;foob</p><p>x=&gt;new</p><h4 id="递归赋值"><a href="#递归赋值" class="headerlink" title="递归赋值"></a>递归赋值</h4><pre><code>x=fooy=$(x)bx=newtest：      @echo "y=&gt;$(y)"      @echo "x=&gt;$(x)"</code></pre><p>在 shell 命令行执行<code>make test</code>我们会看到:y=&gt;newb</p><p>x=&gt;new</p><h4 id="条件赋值"><a href="#条件赋值" class="headerlink" title="条件赋值"></a>条件赋值</h4><pre><code>x:=fooy:=$(x)bx?=newtest：      @echo "y=&gt;$(y)"      @echo "x=&gt;$(x)"</code></pre><p>在 shell 命令行执行<code>make test</code>我们会看到:y=&gt;foob</p><p>x=&gt;foo</p><h4 id="追加赋值"><a href="#追加赋值" class="headerlink" title="追加赋值"></a>追加赋值</h4><pre><code>x:=fooy:=$(x)bx+=$(y)test：      @echo "y=&gt;$(y)"      @echo "x=&gt;$(x)"</code></pre><p>在 shell 命令行执行<code>make test</code>我们会看到:y=&gt;foob</p><p>x=&gt;foo foob</p><p>不同的赋值方式会产生不同的结果，我们使用的时候应该根据具体的情况选择相应的赋值规则。</p><p>变量使用的范围很广，它可以出现在规则的模式中，也可以出现在规则的命令中或者是作为 Makefile 函数的参数来使用。总之，变量的使用在我们的 Makefile 编写中还是非常广泛的，可以说我们的 Makefile 中必不可少的东西。</p><p>其实变量在我们的 Makefile 中还是有很多种类的，它们的意义是不相同的。比如我们的环境变量，自动变量，模式指定变量等。其他的变量我们会在其他的文章里做介绍。</p><h2 id="Makefile自动化变量"><a href="#Makefile自动化变量" class="headerlink" title="Makefile自动化变量"></a>Makefile自动化变量</h2><p>关于自动化变量可以理解为由 Makefile 自动产生的变量。在模式规则中，规则的目标和依赖的文件名代表了一类的文件。规则的命令是对所有这一类文件的描述。我们在 Makefile 中描述规则时，依赖文件和目标文件是变动的，显然在命令中不能出现具体的文件名称，否则模式规则将失去意义。</p><p>那么模式规则命令中该如何表示文件呢？就需要使用“自动化变量”，自动化变量的取值根据执行的规则来决定，取决于执行规则的目标文件和依赖文件。下面是对所有的自动化变量进行的说明：</p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-fae91395a06d6908?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>下面我们就自动化变量的使用举几个例子。</p><p>实例1：</p><pre><code>test:test.o test1.o test2.o         gcc -o $@ $^test.o:test.c test.h         gcc -o $@ $&lt;test1.o:test1.c test1.h         gcc -o $@ $&lt;test2.o:test2.c test2.h         gcc -o $@ $&lt;</code></pre><p>这个规则模式中用到了 “$@” 、”$&lt;” 和 “$^” 这三个自动化变量，对比之前写的 Makefile 中的命令，我们可以发现 “$@” 代表的是目标文件test，“$^”代表的是依赖的文件，“$&lt;”代表的是依赖文件中的第一个。我们在执行 make 的时候，make 会自动识别命令中的自动化变量，并自动实现自动化变量中的值的替换，这个类似于编译C语言文件的时候的预处理的作用。</p><p>实例2：</p><pre><code>lib:test.o test1.o test2.o    ar r $?</code></pre><p>假如我们要做一个库文件，库文件的制作依赖于这三个文件。当修改了其中的某个依赖文件，在命令行执行 make 命令，库文件 “lib” 就会自动更新。”$?” 表示修改的文件。</p><p>GNU make 中在这些变量中加入字符 “D” 或者 “F” 就形成了一系列变种的自动化变量，这些自动化变量可以对文件的名称进行操作。</p><p>下面是一些详细的描述：</p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-177e0130f0d33249?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="Makefile目标文件搜索（VPATH和vpath）"><a href="#Makefile目标文件搜索（VPATH和vpath）" class="headerlink" title="Makefile目标文件搜索（VPATH和vpath）"></a>Makefile目标文件搜索（VPATH和vpath）</h2><p>我们都知道一个工程文件中的源文件有很多，并且存放的位置可能不相同（工程中的文件会被放到不同的目录下），所以按照之前的方式去编写 Makefile 会有问题。</p><p>之前列举的例子，所有的源文件基本上都是存放在与 Makefile 相同的目录下。只要依赖的文件存在，并且依赖规则没有问题，执行 make命令整个工程就会按照对我们编写规则去编译，最终会重建目标文件。那如果需要的文件是存在于不同的路径下，在编译的时候要去怎么办呢（不改变工程的结构）？这就用到了 Makefile 中为我们提供的目录搜索文件的功能。</p><p>常见的搜索的方法的主要有两种：一般搜索<code>VPATH</code>和选择搜索<code>vpath</code>。乍一看只是大小写的区别，其实两者在本质上也是不同的。</p><p>VPATH 和 vpath 的区别：VPATH 是变量，更具体的说是环境变量，Makefile 中的一种特殊变量，使用时需要指定文件的路径；vpath 是关键字，按照模式搜索，也可以说成是选择搜索。搜索的时候不仅需要加上文件的路径，还需要加上相应限制的条件。</p><h4 id="VPATH的使用"><a href="#VPATH的使用" class="headerlink" title="VPATH的使用"></a>VPATH的使用</h4><p>在 Makefile 中可以这样写：VPATH := src</p><p>我们可以这样理解，把 src 的值赋值给变量 VPATH，所以在执行 make 的时候会从 src 目录下找我们需要的文件。</p><p>当存在多个路径的时候我们可以这样写：VPATH := src car</p><p>或者是VPATH := src:car</p><p>多个路径之间要使用空格或者是冒号隔开，表示在多个路径下搜索文件。搜索的顺序为我们书写时的顺序，拿上面的例子来说，我们应该先搜索 src 目录下的文件，再搜索 car 目录下的文件。</p><p>注意：无论你定义了多少路径，make 执行的时候会先搜索当前路径下的文件，当前目录下没有我们要找的文件，才去 VPATH 的路径中去寻找。如果当前目录下有我们要使用的文件，那么 make 就会使用我们当前目录下的文件。</p><p>实例：</p><pre><code>VPATH=src cartest:test.o    gcc -o $@ $^</code></pre><p>假设 test.c 文件没有在当前的目录而在当前文件的子目录 “src” 或者是 “car” 下，程序执行是没有问题的，但是生成的 test 的文件没有在定义的子目录文件中而是在当前的目录下，当然生成文件路径可以指定。</p><h4 id="vpath的使用"><a href="#vpath的使用" class="headerlink" title="vpath的使用"></a>vpath的使用</h4><p>学习了 VPATH的使用，我们再来了解一下关键字搜索 vpath 的使用，这种搜索方式一般被称作选择性搜索。使用上的区别我们可以这样理解：VPATH 是搜索路径下所有的文件，而 vpath 更像是添加了限制条件，会过滤出一部分再去寻找。</p><p>具体用法：</p><p>1) vpath PATTERN DIRECTORIES</p><p>2) vpath PATTERN</p><p>3) vpath</p><p>( PATTERN：可以理解为要寻找的条件，DIRECTORIES：寻找的路径 )</p><p>首先是用法一，命令格式如下：</p><pre><code>vpath test.c src</code></pre><p>可以这样理解，在 src 路径下搜索文件 test.c。多路径的书写规则如下：</p><pre><code>vpath test.c src car     </code></pre><p>或者是</p><pre><code>vpath test.c src : car</code></pre><p>多路径的用法其实和 VPATH 差不多，都是使用空格或者是冒号分隔开，搜索路径的顺序是先 src 目录，然后是 car 目录。</p><p>其次是用法二，命令格式如下：</p><pre><code>vpath test.c</code></pre><p>用法二的意思是清除符合文件 test.c 的搜索目录。</p><p>最后是用法三，命令格式如下：vpath</p><p>vpath 单独使的意思是清除所有已被设置的文件搜索路径。</p><p>另外在使用 vpath 的时候，搜索的条件中可以包含模式字符“%”，这个符号的作用是匹配一个或者是多个字符，例如“%.c”表示搜索路径下所有的 .c 结尾的文件。如果搜索条件中没有包含“%” ，那么搜索的文件就是具体的文件名称。</p><p>使用什么样的搜索方法，主要是基于编译器的执行效率。使用 VPATH 的情况是前路径下的文件较少，或者是搜索的文件不能使用通配符表示，这些情况下使用VPATH最好。如果存在某个路径的文件特别的多或者是可以使用通配符表示的时候，就不建议使用 VPATH 这种方法，为什么呢？因为 VPATH 在去搜索文件的时没有限制条件，所以它回去检索这个目录下的所有文件，每一个文件都会进行对比，搜索和我们目录名相同的文件，不仅速度会很慢，而且效率会很低。我们在这种情况下就可以使用 vpath 搜索，它包含搜索条件的限制，搜索的时候只会从我们规定的条件中搜索目标，过滤掉不符合条件的文件，当然查找的时候也会比较的快。</p><p>为了体验实例的效果的更加明显，我们按照源代码树的布局来放置文件。我们把源代码放置在src目录下，包含的文件文件是：list1.c、list2.c、main.c 文件，我们把头文件包含在 include 的目录下，包含文件 list1.h、list2.h 文件。Makefile 放在这两个目录文件的上一级目录。</p><p>我们按照之前的方式来编写 Makefile 文件：</p><pre><code>main:main.o list1.o list2.o    gcc -o $@ $&lt;main.o:main.c    gcc -o $@ $^list1.o:list1.c list1.h    gcc -o $@ $&lt;list2.o:list2.c list2.h    gcc -o $@ $&lt;</code></pre><p>我们编译执行的 make 时候会发现命令行提示我们：</p><p>make:*** No rule to make target ‘main.c’,need by ‘main.o’. stop.</p><p>出现错误并且编译停止了，为什么会出现错误呢？我们来看一下出现错误的原因，再去重建最终目标文件 main 的时候我们需要 main.o 文件，但是我们再去重建目标main.o 文件的时候，发现没有找到指定的 main.c 文件，这是错误的根本原因。</p><p>这个时候我们就应该添加上路径搜索，我们知道路径搜索的方法有两个：VPATH 和 vpath。我们先来使用一下 VPATH，使用方式很简单，我们只需要在上述的文件开头加上这样一句话：</p><pre><code>VPATH=src include</code></pre><p>再去执行 make 就不会出现错误。所以 Makefile 中的最终写法是这样的：</p><pre><code>VPATH=src includemain:main.o list1.o list2.o    gcc -o $@ $&lt;main.o:main.c    gcc -o $@ $^list1.o:list1.c list1.h    gcc -o $@ $&lt;list2.o:list2.c list2.h    gcc -o $@ $&lt;</code></pre><p>我们使用 vpath 的话同样可以解决这样的问题，只需要把上述代码中的 VPATH 所在行的代码改写成：</p><pre><code>vpath %.c srcvpath %.h include</code></pre><p>这样我们就可以用 vpath 实现功能，代码的最终展示为：</p><pre><code>vpath %.c srcvpath %.h includemain:main.o list1.o list2.o    gcc -o $@ $&lt;main.o:main.c    gcc -o $@ $^list1.o:list1.c list1.h    gcc -o $@ $&lt;list2.o:list2.c list2.h    gcc -o $@ $&lt;</code></pre><h2 id="Makefile隐含规则"><a href="#Makefile隐含规则" class="headerlink" title="Makefile隐含规则"></a>Makefile隐含规则</h2><p>隐含规则就是需要我们做出具体的操作，系统自动完成。编写 Makefile 的时候，可以使用隐含规则来简化Makefile 文件编写。</p><p>实例：</p><pre><code>test:test.o    gcc -o test test.otest.o:test.c</code></pre><p>我们可以在 Makefile 中这样写来编译 test.c 源文件，相比较之前少写了重建 test.o 的命令。但是执行 make，发现依然重建了 test 和 test.o 文件，运行结果却没有改变。这其实就是隐含规则的作用。在某些时候其实不需要给出重建目标文件的命令，有的甚至可以不需要给出规则。实例：</p><pre><code>test:test.o    gcc -o test test.o</code></pre><p>运行的结果是相同的。注意：隐含条件只能省略中间目标文件重建的命令和规则，但是最终目标的命令和规则不能省略。</p><p>隐含规则的具体的工作流程：make 执行过程中找到的隐含规则，提供了此目标的基本依赖关系。确定目标的依赖文件和重建目标需要使用的命令行。隐含规则所提供的依赖文件只是一个基本的（在C语言中，通常他们之间的对应关系是：test.o 对应的是 test.c 文件）。当需要增加这个文件的依赖文件的时候要在 Makefile 中使用没有命令行的规则给出。实例：</p><pre><code>test:test.o    gcc -o test test.otest:test1.h</code></pre><p>其实在有些时候隐含规则的使用会出现问题。因为有一个 make 的“隐含规则库”。库中的每一条隐含规则都有相应的优先级顺序，优先级也就会越高，使用时也就会被优先使用。</p><p>例如在 Makefile 中添加这行代码：</p><pre><code>foo.o:foo.p</code></pre><p>我们都知道 .p 文件是 Pascal 程序的源文件，如果书写规则时不加入命令的话，那么 make 会按照隐含的规则来重建目标文件 foo.o。如果当前目录下恰好存在 foo.c 文件的时候，隐含规则会把 foo.c 当做是 foo.o 的依赖文件进行目标文件的重建。因为编译 .c 文件的隐含规则在编译 .p 文件之前，显然优先级也会越高。当 make 找到生成 foo.o 的文件之后，就不会再去寻找下一条规则。如果我们不想使用隐含规则，在使用的时候不仅要声明规则，也要添加上执行的命令。</p><p>这里讲的是预先设置的隐含规则。如果不明确的写下规则，那么make 就会自己寻找所需要的规则和命令。当然我们也可以使用 make 选项：<code>-r</code>或<code>-n-builtin-rules</code>选项来取消所有的预设值的隐含规则。当然即使是指定了“-r”的参数，某些隐含规则还是会生效。因为有很多的隐含规则都是使用了后缀名的规则来定义的，所以只要隐含规则中含有“后缀列表”那么隐含规则就会生效。默认的列表是：</p><pre><code>.out、.a、.in、.o、.c、.cc、.C、.p、.f、.F、.r、.y、.l、.s、.S、.mod、.sym、.def、.h、.info、.dvi、.tex、.texinfo、.texi、.txinfo、.w、.ch、.web、.sh、.elc、.el。</code></pre><p>下面是一些常用的隐含规则：</p><ul><li><p>编译 C 程序</p></li><li><p>编译 <a href="http://c.biancheng.net/cplus/" target="_blank" rel="noopener">C++</a> 程序</p></li><li><p>编译 Pascal 程序</p></li><li><p>编译 Fortran/Ratfor 程序</p></li><li><p>预处理 Fortran/Ratfor 程序</p></li><li><p>编译 Modula-2 程序</p></li><li><p>汇编和需要预处理的汇编程序</p></li><li><p>链接单一的 object 文件</p></li><li><p>Yacc C 程序</p></li><li><p>Lex C 程序时的隐含规则</p></li></ul><p>上面的编译顺序都是一些常用的编程语言执行隐含规则的顺序，我们在 Makefile 中指定规则时，可以参考这样的列表。当需要编译源文件的时候，考虑是不是需要使用隐含规则。如果不需要，就要把相应的规则和命令全部书写上去。</p><p>内嵌隐含规则的命令中，所使用的变量都是预定义的。我们将这些变量称为“隐含变量”。这些变量允许修改：可以通过命令行参数传递或者是设置系统环境变量的方式都可以对它进行重新定义。无论使用哪种方式，只要 make 在运行的，这些变量的定义有效。Makefile 的隐含规则都会使用到这些变量。</p><p>比如我们编译 .c 文件在我们的 Makefile 中就是隐含的规则，默认使用到的编译命令时<code>cc</code>，执行的命令时<code>cc -c</code>我们可以对用上面的任何一种方式将<code>CC</code>定义为<code>ncc</code>。这样我们就编译 .c 文件的时候就可以用<code>ncc</code>进行编译。</p><p>隐含规则中使用的变量可以分成两类：</p><p>1.代表一个程序的名字。例如：“CC”代表了编译器的这个可执行程序。</p><p>2.代表执行这个程序使用的参数.例如：变量“CFLAGS”。多个参数之间使用空格隔开。</p><p>下面我们来列举一下代表命令的变量，默认都是小写。</p><ul><li><p>AR：函数库打包程序，科创价静态库 .a 文档。</p></li><li><p>AS：应用于汇编程序。</p></li><li><p>CC：C 编译程序。</p></li><li><p>CXX：C++编译程序。</p></li><li><p>CO：从 RCS 中提取文件的程序。</p></li><li><p>CPP：C程序的预处理器。</p></li><li><p>FC：编译器和与处理函数 Fortran 源文件的编译器。</p></li><li><p>GET：从CSSC 中提取文件程序。</p></li><li><p>LEX：将Lex语言转变为 C 或 Ratfo 的程序。</p></li><li><p>PC：Pascal 语言编译器。</p></li><li><p>YACC：Yacc 文法分析器（针对于C语言）</p></li><li><p>YACCR：Yacc 文法分析器。</p></li></ul><h2 id="Makefile-ifeq、ifneq、ifdef和ifndef（条件判断）"><a href="#Makefile-ifeq、ifneq、ifdef和ifndef（条件判断）" class="headerlink" title="Makefile ifeq、ifneq、ifdef和ifndef（条件判断）"></a>Makefile ifeq、ifneq、ifdef和ifndef（条件判断）</h2><p>日常使用 Makefile 编译文件时，可能会遇到需要分条件执行的情况，比如在一个工程文件中，可编译的源文件很多，但是它们的类型是不相同的，所以编译文件使用的编译器也是不同的。手动编译去操作文件显然是不可行的（每个文件编译时需要注意的事项很多），所以 make 为我们提供了条件判断来解决这样的问题。</p><p>需要解决的问题：要根据判断，分条件执行语句。</p><p>条件语句的作用：条件语句可以根据一个变量的值来控制 make 执行或者时忽略 Makefile 的特定部分，条件语句可以是两个不同的变量或者是常量和变量之间的比较。</p><p>条件语句使用优点：Makefile 中使用条件控制可以做到处理的灵活性和高效性。注意：条件语句只能用于控制 make 实际执行的 Makefile 文件部分，不能控制规则的 shell 命令执行的过程。</p><p>下面是条件判断中使用到的一些关键字：</p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-c6000942e12bd2df?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="ifeq-和-ifneq"><a href="#ifeq-和-ifneq" class="headerlink" title="ifeq 和 ifneq"></a>ifeq 和 ifneq</h3><p>条件判断的使用方式如下：</p><p>ifeq (ARG1, ARG2)</p><p>ifeq ‘ARG1’ ‘ARG2’</p><p>ifeq “ARG1” “ARG2”</p><p>ifeq “ARG1” ‘ARG2’</p><p>ifeq ‘ARG1’ “ARG2”</p><p>实例：</p><pre><code>libs_for_gcc= -lgnunormal_libs=foo:$(objects)ifeq($(CC),gcc)    $(CC) -o foo $(objects) $(libs_for_gcc)else    $(CC) -o foo $(objects) $(noemal_libs)endif</code></pre><p>条件语句中使用到三个关键字“ifeq”、“else”、“endif”。其中：“ifeq”表示条件语句的开始，并指定一个比较条件（相等）。括号和关键字之间要使用空格分隔，两个参数之间要使用逗号分隔。参数中的变量引用在进行变量值比较的时候被展开。“ifeq”，后面的是条件满足的时候执行的，条件不满足忽略；“else”表示当条件不满足的时候执行的部分，不是所有的条件语句都要执行此部分；“endif”是判断语句结束标志，Makefile 中条件判断的结束都要有。</p><p>其实 “ifneq” 和 “ifeq” 的使用方法是完全相同的，只不过是满足条件后执行的语句正好相反。</p><p>上面的例子可以换一种更加简介的方式来写：</p><pre><code>libs_for_gcc= -lgnunormal_libs=ifeq($(CC),gcc)    libs=$(libs_for_gcc)else    libs=$(normal_libs)endiffoo:$(objects)    $(CC) -o foo $(objects) $(libs)</code></pre><h3 id="ifdef-和-ifndef"><a href="#ifdef-和-ifndef" class="headerlink" title="ifdef 和 ifndef"></a>ifdef 和 ifndef</h3><p>使用方式如下：</p><pre><code>ifdef VARIABLE-NAME</code></pre><p>它的主要功能是判断变量的值是不是为空，实例：</p><p>实例 1：</p><pre><code>bar =foo = $(bar)all:ifdef foo    @echo yeselse    @echo  noendif</code></pre><p>实例 2：</p><pre><code>foo=all:ifdef foo    @echo yeselse    @echo  noendif</code></pre><p>通过两个实例对比说明：通过打印 “yes” 或 “no” 来演示执行的结果。我们执行 make 可以看到实例 1打印的结果是 “yes” ，实例 2打印的结果是 “no” 。其原因就是在实例 1 中，变量“foo”的定义是“foo = $(bar)”。虽然变量“bar”的值为空，但是“ifdef”的判断结果为真，这种方式判断显然是有不行的，因此当我们需要判断一个变量的值是否为空的时候需要使用“ifeq” 而不是“ifdef”。</p><p>注意：在 make 读取 Makefile 文件时计算表达式的值，并根据表达式的值决定判断语句中的哪一个部分作为此 Makefile 所要执行的内容。因此在条件表达式中不能使用自动化变量，自动化变量在规则命令执行时才有效，更不能将一个完整的条件判断语句分卸在两个不同的 Makefile 的文件中。在一个 Makefile 中使用指示符 “include” 包含另一个 Makefile 文件。</p><h2 id="Makefile伪目标"><a href="#Makefile伪目标" class="headerlink" title="Makefile伪目标"></a>Makefile伪目标</h2><p>伪目标可以这样来理解，它并不会创建目标文件，只是想去执行这个目标下面的命令。伪目标的存在可以帮助我们找到命令并执行。</p><p>使用伪目标有两点原因：</p><ul><li><p>避免我们的 Makefile 中定义的只执行的命令的目标和工作目录下的实际文件出现名字冲突。</p></li><li><p>提高执行 make 时的效率，特别是对于一个大型的工程来说，提高编译的效率也是我们所必需的。</p></li></ul><p>我们先来看一下第一种情况的使用。如果需要书写这样一个规则，规则所定义的命令不是去创建文件，而是通过 make 命令明确指定它来执行一些特定的命令。实例：</p><pre><code>clean:    rm -rf *.o test</code></pre><p>规则中 rm 命令不是创建文件 clean 的命令，而是执行删除任务，删除当前目录下的所有的 .o 结尾和文件名为 test 的文件。当工作目录下不存在以 clean 命令的文件时，在 shell 中输入 make clean 命令，命令 rm -rf *.o test 总会被执行 ，这也是我们期望的结果。</p><p>如果当前目录下存在文件名为 clean 的文件时情况就会不一样了，当我们在 shell 中执行命令 make clean，由于这个规则没有依赖文件，所以目标被认为是最新的而不去执行规则所定义的命令。因此命令 rm 将不会被执行。为了解决这个问题，删除 clean 文件或者是在 Makefile 中将目标 clean 声明为伪目标。将一个目标声明称伪目标的方法是将它作为特殊的目标<code>.PHONY</code>的依赖，如下：</p><p>.PHONY:clean</p><p>这样 clean 就被声明成一个伪目标，无论当前目录下是否存在 clean 这个文件，当我们执行 make clean 后 rm 都会被执行。而且当一个目标被声明为伪目标之后，make 在执行此规则时不会去试图去查找隐含的关系去创建它。这样同样提高了 make 的执行效率，同时也不用担心目标和文件名重名而使我们的编译失败。</p><p>在书写伪目标的时候，需要声明目标是一个伪目标，之后才是伪目标的规则定义。目标 “clean” 的完整书写格式如下：</p><pre><code>.PHONY:cleanclean:    rm -rf *.o test</code></pre><p>伪目标的另一种使用的场合是在 make 的并行和递归执行的过程中，此情况下一般会存在一个变量，定义为所有需要 make 的子目录。对多个目录进行 make 的实现，可以在一个规则的命令行中使用 shell 循环来完成。如下：</p><pre><code>SUBDIRS=foo bar bazsubdirs:    for dir in $(SUBDIRS);do $(MAKE) -C $$dir;done</code></pre><p>代码表达的意思是当前目录下存在三个子文件目录，每个子目录文件都有相对应的 Makefile 文件，代码中实现的部分是用当前目录下的 Makefile 控制其它子模块中的 Makefile 的运行，但是这种实现方法存在以下几个问题：</p><ul><li><p>当子目录执行 make 出现错误时，make 不会退出。就是说，在对某个目录执行 make 失败以后，会继续对其他的目录进行 make。在最终执行失败的情况下，我们很难根据错误提示定位出具体实在那个目录下执行 make 发生的错误。这样给问题定位造成很大的困难。为了解决问题可以在命令部分加入错误检测，在命令执行的错误后主动退出。不幸的是如果在执行 make 时使用了 “-k” 选项，此方式将失效。</p></li><li><p>另外一个问题就是使用这种 shell 循环方式时，没有用到 make 对目录的并行处理功能由于规则的命令时一条完整的 shell 命令，不能被并行处理。</p></li></ul><p>有了伪目标之后，我们可以用它来克服以上方式所存在的两个问题，代码展示如下：</p><pre><code>SUBDIRS=foo bar baz.PHONY:subdirs $(SUBDIRS)subdirs:$(SUBDIRS)$(SUBDIRS):    $(MAKE) -C $@foo:baz</code></pre><p>上面的实例中有一个没有命令行的规则“foo:baz”，这个规则是用来规定三个子目录的编译顺序。因为在规则中 “baz” 的子目录被当作成了 “foo” 的依赖文件，所以 “baz” 要比 “foo” 子目录更先执行，最后执行 “bar” 子目录的编译。</p><p>一般情况下，一个伪目标不作为另外一个目标的依赖。这是因为当一个目标文件的依赖包含伪目标时，每一次在执行这个规则伪目标所定义的命令都会被执行（因为它作为规则的依赖，重建规则目标时需要首先重建规则的所有依赖文件）。当一个伪目标没有任何目标（此目标是一个可被创建或者是已存在的文件）的依赖时，我们只能通过 make 的命令来明确的指定它的终极目标，执行它所在规则所定义的命令。例如 make clean。</p><h4 id="伪目标实现多文件编辑"><a href="#伪目标实现多文件编辑" class="headerlink" title="伪目标实现多文件编辑"></a>伪目标实现多文件编辑</h4><p>如果在一个文件里想要同时生成多个可执行文件，我们可以借助伪目标来实现。使用方式如下：</p><pre><code>.PHONY:allall:test1 test2 test3test1:test1.o    gcc -o $@ $^test2:test2.o    gcc -o $@ $^test3:test3.o    gcc -o $@ $^</code></pre><p>我们在当前目录下创建了三个源文件，目的是把这三个源文件编译成为三个可执行文件。将重建的规则放到 Makefile 中，约定使用 “all” 的伪目标来作为最终目标，它的依赖文件就是要生成的可执行文件。这样的话只需要一个 make 命令，就会同时生成三个可执行文件。</p><p>之所以这样写，是因为伪目标的特性，它总会被执行，所以它依赖的三个文件的目标就不如 “all” 这个目标新，所以，其他的三个目标的规则总是被执行，这也就达到了我们一口气生成多个目标的目的。我们也可以实现单独的编译这三个中的任意一个源文件（我们想去重建 test1，我们可以执行命令<code>make test1</code> 来实现 ）。</p><h2 id="Makefile常用字符串处理函数"><a href="#Makefile常用字符串处理函数" class="headerlink" title="Makefile常用字符串处理函数"></a>Makefile常用字符串处理函数</h2><p>函数的调用和变量的调用很像。引用变量的格式为<code>$(变量名)</code>，函数调用的格式如下：</p><pre><code>$(&lt;function&gt; &lt;arguments&gt;)  或者是   ${&lt;function&gt; &lt;arguments&gt;}</code></pre><p>其中，function 是函数名，arguments 是函数的参数，参数之间要用逗号分隔开。而参数和函数名之间使用空格分开。调用函数的时候要使用字符“$”，后面可以跟小括号也可以使用花括号。这个其实我们并不陌生，我们之前使用过许多的函数，比如说展开通配符的函数 wildcard，以及字符串替换的函数 patsubst ，Makefile 中函数并不是很多。</p><p>今天主要讲的是字符串处理函数，这些都是我们经常使用到的函数，下面是对函数详细的介绍。</p><p>1. 模式字符串替换函数，函数使用格式如下：</p><pre><code>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</code></pre><p>函数说明：函数功能是查找 text 中的单词是否符合模式 pattern，如果匹配的话，则用 replacement 替换。返回值为替换后的新字符串。实例：</p><pre><code>OBJ=$(patsubst %.c,%.o,1.c 2.c 3.c)all:    @echo $(OBJ)</code></pre><p>执行 make 命令，我们可以得到的值是 “1.o 2.o 3.o”，这些都是替换后的值。</p><p>2. 字符串替换函数，函数使用格式如下：</p><pre><code>$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt;)</code></pre><p>函数说明：函数的功能是把字符串中的 form 替换成 to，返回值为替换后的新字符串。实例：</p><pre><code>OBJ=$(subst ee,EE,feet on the street)all:    @echo $(OBJ)</code></pre><p>执行 make 命令，我们得到的值是“fEEt on the strEEt”。</p><p>3. 去空格函数，函数使用格式如下：</p><pre><code>$(strip &lt;string&gt;)</code></pre><p>函数说明：函数的功能是去掉字符串的开头和结尾的字符串，并且将其中的多个连续的空格合并成为一个空格。返回值为去掉空格后的字符串。实例：</p><pre><code>OBJ=$(strip    a       b c)all:    @echo $(OBJ)</code></pre><p>执行完 make 之后，结果是“a b c”。这个只是除去开头和结尾的空格字符，并且将字符串中的空格合并成为一个空格。</p><p>4. 查找字符串函数，函数使用格式如下：</p><pre><code>$(findstring &lt;find&gt;,&lt;in&gt;)</code></pre><p>函数说明：函数的功能是查找 in 中的 find ,如果我们查找的目标字符串存在。返回值为目标字符串，如果不存在就返回空。实例：</p><pre><code>OBJ=$(findstring a,a b c)all:    @echo $(OBJ)</code></pre><p>执行 make 命令，得到的返回的结果就是 “a”。</p><p>5. 过滤函数，函数使用格式如下：</p><pre><code>$(filter &lt;pattern&gt;,&lt;text&gt;)</code></pre><p>函数说明：函数的功能是过滤出 text 中符合模式 pattern 的字符串，可以有多个 pattern 。返回值为过滤后的字符串。实例：</p><pre><code>OBJ=$(filter %.c %.o,1.c 2.o 3.s)all:    @echo $(OBJ)</code></pre><p>执行 make 命令，我们得到的值是“1.c 2.o”。</p><p>6. 反过滤函数，函数使用格式如下：</p><pre><code>$(filter-out &lt;pattern&gt;,&lt;text&gt;)</code></pre><p>函数说明：函数的功能是功能和 filter 函数正好相反，但是用法相同。去除符合模式 pattern 的字符串，保留符合的字符串。返回值是保留的字符串。实例：</p><pre><code>OBJ=$(filter-out 1.c 2.o ,1.o 2.c 3.s)all：    @echo $(OBJ)</code></pre><p>执行 make 命令，打印的结果是“3.s”。</p><p>7. 排序函数，函数使用格式如下：</p><pre><code>$(sort &lt;list&gt;)</code></pre><p>函数说明：函数的功能是将 <code>&lt;list&gt;</code>中的单词排序（升序）。返回值为排列后的字符串。实例：</p><pre><code>OBJ=$(sort foo bar foo lost)all:    @echo $(OBJ)</code></pre><p>执行 make 命令，我们得到的值是“bar foo lost”。注意：sort会去除重复的字符串。</p><p>8. 取单词函数，函数使用格式如下：</p><pre><code>$(word &lt;n&gt;,&lt;text&gt;)</code></pre><p>函数说明：函数的功能是取出函数<code>&lt;text&gt;</code>中的第n个单词。返回值为我们取出的第 n 个单词。实例：</p><pre><code>OBJ=$(word 2,1.c 2.c 3.c)all:    @echo $(OBJ)</code></pre><p>执行 make 命令，我们得到的值是“2.c”。</p><h2 id="Makefile常用文件名操作函数"><a href="#Makefile常用文件名操作函数" class="headerlink" title="Makefile常用文件名操作函数"></a>Makefile常用文件名操作函数</h2><p>我们在编写 Makefile 的时候，很多情况下需要对文件名进行操作。例如获取文件的路径，去除文件的路径，取出文件前缀或后缀等等。当遇到这样的问题的时手动修改是不太可能的，因为文件可能会很多，而且 Makefile 中操作文件名可能不止一次。所以 Makefile 给我们提供了相应的函数去实现文件名的操作。</p><p>注意：下面的每个函数的参数字符串都会被当作或是一个系列的文件名来看待。</p><p>1. 取目录函数，函数使用格式如下：</p><pre><code>$(dir &lt;names&gt;)</code></pre><p>函数说明：函数的功能是从文件名序列 names 中取出目录部分，如果没有 names 中没有 “/“ ，取出的值为 “./“ 。返回值为目录部分，指的是最后一个反斜杠之前的部分。如果没有反斜杠将返回“./”。实例：</p><pre><code>OBJ=$(dir src/foo.c hacks)all:    @echo $(OBJ)</code></pre><p>执行 make 命令，我们可以得到的值是“src/ ./”。提取文件 foo.c 的路径是 “/src” 和文件 hacks 的路径 “./“。</p><p>2. 取文件函数，函数使用格式如下：</p><pre><code>$(notdir &lt;names&gt;)</code></pre><p>函数说明：函数的功能是从文件名序列 names 中取出非目录的部分。非目录的部分是最后一个反斜杠之后的部分。返回值为文件非目录的部分。实例：</p><pre><code>OBJ=$(notdir src/foo.c hacks)all:    @echo $(OBJ)</code></pre><p>执行 make 命令，我们可以得到的值是“foo.c hacks”。</p><p>3. 取后缀名函数，函数使用格式如下：</p><pre><code>$(suffix &lt;names&gt;)</code></pre><p>函数说明：函数的功能是从文件名序列中 names 中取出各个文件的后缀名。返回值为文件名序列 names 中的后缀序列，如果文件没有后缀名，则返回空字符串。实例：</p><pre><code>OBJ=$(suffix src/foo.c hacks)all:    @echo $(OBJ)</code></pre><p>执行 make 命令，我们得到的值是“.c ”。文件 “hacks” 没有后缀名，所以返回的是空值。</p><p>4. 取前缀函数，函数使用格式如下：</p><pre><code>$(basename &lt;names&gt;)</code></pre><p>函数说明：函数的功能是从文件名序列 names 中取出各个文件名的前缀部分。返回值为被取出来的文件的前缀名，如果文件没有前缀名则返回空的字符串。实例：</p><pre><code>OBJ=$(notdir src/foo.c hacks)all:    @echo $(OBJ)</code></pre><p>执行 make 命令，我们可以得到值是“src/foo hacks”。获取的是文件的前缀名，包含文件路径的部分。</p><p>5. 添加后缀名函数，函数使用格式如下：</p><pre><code>$(addsuffix &lt;suffix&gt;,&lt;names&gt;)</code></pre><p>函数说明：函数的功能是把后缀 suffix 加到 names 中的每个单词后面。返回值为添加上后缀的文件名序列。实例：</p><pre><code>OBJ=$(addsuffix .c,src/foo.c hacks)all:    @echo $(OBJ)</code></pre><p>执行 make 后我们可以得到“sec/foo.c.c hack.c”。我们可以看到如果文件名存在后缀名，依然会加上。</p><p>6. 添加前缀名函数，函数使用格式如下：</p><pre><code>$(addperfix &lt;prefix&gt;,&lt;names&gt;)</code></pre><p>函数说明：函数的功能是把前缀 prefix 加到 names 中的每个单词的前面。返回值为添加上前缀的文件名序列。实例：</p><pre><code>OBJ=$(addprefix src/, foo.c hacks)all:    @echo $(OBJ)</code></pre><p>执行 make 命令，我们可以得到值是 “src/foo.c src/hacks” 。我们可以使用这个函数给我们的文件添加路径。</p><p>7. 链接函数，函数使用格式如下：</p><pre><code>$(join &lt;list1&gt;,&lt;list2&gt;)</code></pre><p>函数说明：函数功能是把 list2 中的单词对应的拼接到 list1 的后面。如果 list1 的单词要比 list2的多，那么，list1 中多出来的单词将保持原样，如果 list1 中的单词要比 list2 中的单词少，那么 list2 中多出来的单词将保持原样。返回值为拼接好的字符串。实例：</p><pre><code>OBJ=$(join src car,abc zxc qwe)all:    @echo $(OBJ)</code></pre><p>执行 make 命令，我们可以得到的值是“srcabc carzxc qwe”。很显然<code>&lt;list1&gt;</code>中的文件名比<code>&lt;list2&gt;</code>的少，所以多出来的保持不变。</p><p>8. 获取匹配模式文件名函数，命令使用格式如下：</p><pre><code>$(wildcard PATTERN)</code></pre><p>函数说明：函数的功能是列出当前目录下所有符合模式的 PATTERN 格式的文件名。返回值为空格分隔并且存在当前目录下的所有符合模式 PATTERN 的文件名。实例：</p><pre><code>OBJ=$(wildcard *.c  *.h)all:    @echo $(OBJ)</code></pre><p>执行 make 命令，可以得到当前函数下所有的 “.c “ 和 “.h” 结尾的文件。这个函数通常跟的通配符 “*” 连用，使用在依赖规则的描述的时候被展开（在这里我们的例子如果没有 wildcard 函数，我们的运行结果也是这样，”echo” 属于 shell 命令，在使用通配符的时通配符自动展开，我们这里只是相要说明一下这个函数在使用时，如果通过引用变量出现在规则中要被使用）。</p><h2 id="Makefile中的其它常用函数"><a href="#Makefile中的其它常用函数" class="headerlink" title="Makefile中的其它常用函数"></a>Makefile中的其它常用函数</h2><p>Makefile 中的其他的函数。以下是这些函数的详细说明。</p><pre><code>$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</code></pre><p>函数的功能是：把参数<code>&lt;list&gt;</code>中的单词逐一取出放到参数<code>&lt;var&gt;</code>所指定的变量中，然后再执行<code>&lt;text&gt;</code>所包含的表达式。每一次<code>&lt;text&gt;</code>会返回一个字符串，循环过程中，<code>&lt;text&gt;</code>的返所返回的每个字符串会以空格分割，最后当整个循环结束的时候，<code>&lt;text&gt;</code>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是 foreach 函数的返回值。所以<code>&lt;var&gt;</code>最好是一个变量名，<code>&lt;list&gt;</code>可以是一个表达式，而<code>&lt;text&gt;</code>中一般会只用<code>&lt;var&gt;</code>这个参数来一次枚举<code>&lt;list&gt;</code>中的单词。</p><p>实例：</p><pre><code>name:=a b c dfiles:=$(foreach n,$(names),$(n).o)all:    @echo $(files)</code></pre><p>执行 make 命令，我们得到的值是“a.o b.o c.o d.o”。注意，foreach 中的 <code>&lt;var&gt;</code> 参数是一个临时的局部变量，foreach 函数执行完后，参数<code>&lt;var&gt;</code>的变量将不再作用，其作用域只在 foreach 函数当中。</p><pre><code>$(if &lt;condition&gt;,&lt;then-part&gt;)或(if&lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt;)</code></pre><p>可见，if 函数可以包含<code>else</code>部分，或者是不包含，即if函数的参数可以是两个，也可以是三个。<code>condition</code>参数是 if 表达式，如果其返回的是非空的字符串，那么这个表达式就相当于返回真，于是，<code>then-part</code>就会被计算，否则<code>else-part</code>会被计算。</p><p>而if函数的返回值是：如果<code>condition</code>为真（非空字符串），那么<code>then-part</code>会是整个函数的返回值。如果<code>condition</code>为假（空字符串），那么<code>else-part</code>将会是这个函数的返回值。此时如果<code>else-part</code>没有被定义，那么整个函数返回空字串符。所以，<code>then-part</code>和<code>else-part</code>只会有一个被计算。</p><p>实例：</p><pre><code>OBJ:=foo.cOBJ:=$(if $(OBJ),$(OBJ),main.c)all:      @echo $(OBJ)</code></pre><p>执行 make 命令我们可以得到函数的值是 foo.c，如果变量 OBJ 的值为空的话，我们得到的 OBJ 的值就是<code>main.c</code>。</p><pre><code>$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;,...)</code></pre><p>call 函数是唯一一个可以用来创建新的参数化的函数。我们可以用来写一个非常复杂的表达式，这个表达式中，我们可以定义很多的参数，然后你可以用 call 函数来向这个表达式传递参数。</p><p>当 make 执行这个函数的时候，<code>expression</code>参数中的变量$(1)、$(2)、$(3)等，会被参数<code>parm1</code>，<code>parm2</code>，<code>parm3</code>依次取代。而<code>expression</code>的返回值就是 call 函数的返回值。</p><p>实例 1：</p><pre><code>reverse = $(1) $(2)foo = $(call reverse,a,b)all：      @echo $(foo)</code></pre><p>那么，foo 的值就是“a b”。当然，参数的次序可以是自定义的，不一定是顺序的，</p><p>实例 2：</p><pre><code>reverse = $(2) $(1)foo = $(call reverse,a,b)all:      @echo $(foo)</code></pre><p>此时的 foo 的值就是“b a”。</p><pre><code>$(origin &lt;variable&gt;)</code></pre><p>origin 函数不像其他的函数，它并不操作变量的值，它只是告诉你这个变量是哪里来的。注意： variable 是变量的名字，不应该是引用，所以最好不要在 variable 中使用“$”字符。origin 函数会员其返回值来告诉你这个变量的“出生情况”。</p><p>下面是origin函数返回值：</p><ul><li><p>“undefined”：如果<variable>从来没有定义过，函数将返回这个值。</variable></p></li><li><p>“default”：如果<variable>是一个默认的定义，比如说“CC”这个变量。</variable></p></li><li><p>“environment”：如果<variable>是一个环境变量并且当Makefile被执行的时候，“-e”参数没有被打开。</variable></p></li><li><p>“file”：如果<variable>这个变量被定义在Makefile中，将会返回这个值。</variable></p></li><li><p>“command line”：如果<variable>这个变量是被命令执行的，将会被返回。</variable></p></li><li><p>“override”：如果<variable>是被override指示符重新定义的。</variable></p></li><li><p>“automatic”：如果<variable>是一个命令运行中的自动化变量。</variable></p></li></ul><p>这些信息对于我们编写 Makefile 是非常有用的，例如假设我们有一个 Makefile ，其包含了一个定义文件<code>Make.def</code>，在<code>Make.def</code>中定义了一个变量<code>bletch</code>，而我们的环境变量中也有一个环境变量<code>bletch</code>，我们想去判断一下这个变量是不是环境变量，如果是我们就把它重定义了。如果是非环境变量，那么我们就不重新定义它。于是，我们在 Makefile 中，可以这样写：</p><pre><code>ifdef bletchifeq "$(origin bletch)" "environment"bletch = barf,gag,etcendifendif</code></pre><p>当然，使用<code>override</code>关键字不就可以重新定义环境中的变量了吗，为什么需要使用这样的步骤？是的，我们用<code>override</code>是可以达到这样的效果的，可是<code>override</code>会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不是重新定义命令行传来的。</p><h2 id="Makefile命令的编写"><a href="#Makefile命令的编写" class="headerlink" title="Makefile命令的编写"></a>Makefile命令的编写</h2><p>令是由 shell 命令行组成，他们是一条一条执行的。多个命令之间要使用分号隔开，Makefile 中的任何命令都要以<code>tab</code>键开始。多个命令行之间可以有空行和注释行，在执行规则时空行会被自动忽略。</p><p>通常系统中可能存在不同的 shell 。但是 make 处理 Makefile 过程时，如果没有明确的指定，那么对所有规则中的命令行的解析使用<code>bin/sh</code>来完成。执行过程中使用的 shell 决定了规则中的命令的语法和处理机制。当使用默认的<code>bin/sh</code>时，命令中出现的字符“#”到行末的内容被认为是注释。当然了“#”可以不在此行的行首，此时“#”之前的内容不会被作为注释处理。</p><h4 id="命令回显"><a href="#命令回显" class="headerlink" title="命令回显"></a>命令回显</h4><p>通常 make 在执行命令行之前会把要是执行的命令行输出到标准输出设备。我们称之为 “回显”，就好像我们在 shell 环境下输入命令执行时一样。如果规则的命令行以字符“@”开始，则 make 在执行的时候就不会显示这个将要被执行的命令。典型的用法是在使用<code>echo</code>命令输出一些信息时。</p><p>实例 1：</p><pre><code>OBJ=test main listall:    @echo $(OBJ)</code></pre><p>执行时将会得到<code>test main list</code>这条输出信息，如果在执行命令之前没有字符“@”，那么make的输出将是<code>echo test main list</code>。</p><p>我们在执行 make 时添加上一些参数，可以控制命令行是否输出。当使用 make 的时候机加上参数<code>-n</code>或者是<code>--just-print</code> ，执行时只显示所要执行的命令，但不会真正的执行这个命令。只有在这种情况下 make 才会打印出所有的 make 需要执行的命令，其中包括了使用的“@”字符开始的命令。这个选项对于我们调试 Makefile 非常的有用，使用这个选项就可以按执行顺序打印出 Makefile 中所需要执行的所有命令。而 make 参数<code>-s</code>或者是<code>--slient</code>则是禁止所有的执行命令的显示。就好像所有的命令行都使用“@”开始一样。</p><h4 id="命令的执行"><a href="#命令的执行" class="headerlink" title="命令的执行"></a>命令的执行</h4><p>当规则中的目标需要被重建的时候，此规则所定义的命令将会被执行，如果是多行的命令，那么每一行命令将是在一个独立的子 shell 进程中被执行。因此，多命令行之间的执行命令时是相互独立的，相互之间不存在依赖。</p><p>在 Makefile 中书写在同一行中的多个命令属于一个完整的 shell 命令行，书写在独立行的一条命令是一个独立的 shell 命令行。因此：在一个规则的命令中命令行 “cd”改变目录不会对其后面的命令的执行产生影响。就是说之后的命令执行的工作目录不会是之前使用“cd”进入的那个目录。如果达到这个目的，就不能把“cd”和其后面的命令放在两行来书写。而应该把这两个命令放在一行上用分号隔开。这样才是一个完整的 shell 命令行。</p><p>实例 2：</p><pre><code>foo:bar/lose    cd bar;gobble lose &gt;../foo</code></pre><p>如果想把一个完整的shell命令行书写在多行上，需要使用反斜杠 ()来对处于多行的命令进行连接，表示他们是一个完整的shell命令行。例如上例我们也可以这样书写：</p><pre><code>foo:bar.lose    cd bar; \    gobble lose &gt; ../foo</code></pre><p>make 对所有规则的命令的解析使用环境变量“SHELL”所指定的那个程序。在 GNU make 中，默认的程序时 “/bin/sh”。不像其他的绝大多数变量，他们的只可以直接从同名的系统环境变量那里获得。make 的环境变量 “SHELL”没有使用环境变量的定义。因为系统环境变量“SHELL”指定的那个程序被用来作为用户和系统交互的接口程序，他对于不存在直接交互过程的 make 显然不合适。在 make 环境变量中“SHELL”会被重新赋值；他作为一个变量我们也可以在 Makefile 中明确的给它赋值，变量“SHELL“的默认值时“/bin/sh”。</p><h4 id="并发执行命令"><a href="#并发执行命令" class="headerlink" title="并发执行命令"></a>并发执行命令</h4><p>GNU make 支持同时执行多条命令。通常情况下，同一时刻只有一个命令在执行，下一个命令只有在当前命令结束之后才能够开始执行。不过可以通过 make 命令行选项 “-j” 或者 “–jobs” 来告诉 make 在同一时刻可以允许多条命令同时执行。</p><p>如果选项 “-j” 之后存在一个整数，其含义是告诉 make 在同一时刻可以允许同时执行的命令行的数目。这个数字被称为<code>job slots</code>。当 “-j” 选项中没有出现数字的时候，那么同一时间执行的命令数目没有要求。使用默认的<code>job solts</code>，值为1，表示make将串行的执行规则的命令（同一时刻只能由一条命令被执行）。</p><p>并行执行命令所带来的问题是显而易见的：</p><ul><li><p>多个同时执行的命令的输出信息将同时被输出到终端。当出现错误时很难根据一大堆凌乱的信息来区分那条命令执行错误。</p></li><li><p>在同一时刻可能会存在多个命令执行的进程同时读取到标准输入，但是对于白哦准输入设备来说，在同一时刻只能存在一个进程访问它。就是说在某个时间点，make只能保证此刻正在执行的进程中的一个进程读取标准输入流。而其他的进程键的标准输入流将设置为无效。因此在此一时刻多个执行命令的进程中只有一个进程获得标准输入，而其他的需要读取标准输入流的进程由于输入流无效而导致致命的错误。</p></li></ul><h2 id="Makefile-include文件包含"><a href="#Makefile-include文件包含" class="headerlink" title="Makefile include文件包含"></a>Makefile include文件包含</h2><p>包含其他文件使用的关键字是 “include”，和 C 语言包含头文件的方式相同。</p><p>当 make 读取到 “include” 关键字的时候，会暂停读取当前的 Makefile，而是去读 “include” 包含的文件，读取结束后再继读取当前的 Makefile 文件。”include” 使用的具体方式如下：</p><pre><code>include &lt;filenames&gt;</code></pre><p>filenames 是 shell 支持的文件名（可以使用通配符表示的文件）。注意：”include” 关键字所在的行首可以包含一个或者是多个的空格（读取的时候空格会被自动的忽略），但是不能使用 Tab 开始，否则会把 “include” 当作式命令来处理。包含的多个文件之间要使用空格分隔开。使用 “include” 包含进来的 Makefile 文件中，如果存在函数或者是变量的引用，它们会在包含的 Makefile 中展开。</p><p>include 通常使用在以下的场合：</p><ul><li><p>在一个工程文件中，每一个模块都有一个独立的 Makefile 来描述它的重建规则。它们需要定义一组通用的变量定义或者是模式规则。通用的做法是将这些共同使用的变量或者模式规则定义在一个文件中，需要的时候用 “include” 包含这个文件。</p></li><li><p>当根据源文件自动产生依赖文件时，我们可以将自动产生的依赖关系保存在另一个文件中。然后在 Makefile 中包含这个文件。</p></li></ul><p>注意：如果使用 “include” 包含文件的时候，指定的文件不是文件的绝对路径或者是为当前文件下没有这个文件，make 会根据文件名会在以下几个路径中去找，首先我们在执行 make 命令的时候可以加入选项 “-I” 或 “–include-dir” 后面添加上指定的路径，如果文件存在就会被使用，如果文件不存在将会在其他的几个路径中搜索：”usr/gnu/include”、”usr/local/include” 和 “usr/include”。</p><p>如果在上面的路径没有找到 “include” 指定的文件，make 将会提示一个文件没有找到的警示提示，但是不会退出，而是继续执行 Makefile 的后续的内容。当完成读取整个 Makefile 后，make 将试图使用规则来创建通过 “include” 指定但不存在的文件。当不能创建的时候，文件将会保存退出。</p><p>使用时，通常用 “-include” 来代替 “include” 来忽略文件不存在或者是无法创建的错误提示，使用格式如下：-include <filename></filename></p><p>使用方法和 “include” 的使用方法相同。</p><p>这两种方式之间的区别：</p><ul><li><p>使用 “include <filenames>“ ，make 在处理程序的时候，文件列表中的任意一个文件不存在的时候或者是没有规则去创建这个文件的时候，make 程序将会提示错误并保存退出。</filenames></p></li><li><p>使用 “-include <filenames>“，当包含的文件不存在或者是没有规则去创建它的时候，make 将会继续执行程序，只有真正由于不能完成终极目标重建的时候我们的程序才会提示错误保存退出。</filenames></p></li></ul><h2 id="Makefile嵌套执行make"><a href="#Makefile嵌套执行make" class="headerlink" title="Makefile嵌套执行make"></a>Makefile嵌套执行make</h2><p>我们都知道在一个大的工程文件中，不同的文件按照功能被划分到不同的模块中，也就说很多的源文件被放置在了不同的目录下。每个模块可能都会有自己的编译顺序和规则，如果在一个 Makefile 文件中描述所有模块的编译规则，就会很乱，执行时也会不方便，所以就需要在不同的模块中分别对它们的规则进行描述，也就是每一个模块都编写一个 Makefile 文件，这样不仅方便管理，而且可以迅速发现模块中的问题。这样我们只需要控制其他模块中的 Makefile 就可以实现总体的控制，这就是 make 的嵌套执行。</p><p>如何来使用呢？举例说明如下：</p><pre><code>subsystem:    cd subdir &amp;&amp; $(MAKE)</code></pre><p>这个例子可以这样来理解，在当前目录下有一个目录文件 subdir 和一个 Makefile 文件，子目录 subdir 文件下还有一个 Makefile 文件，这个文件是用来描述这个子目录文件的编译规则。使用时只需要在最外层的目录中执行 make 命令，当命令执行到上述的规则时，程序会进入到子目录中执行 make。这就是嵌套执行 make，我们把最外层的 Makefile 称为是总控 Makefile。</p><p>上述的规则也可以换成另外一种写法：</p><pre><code>subsystem    $(MAKE) -C subdir</code></pre><p>在 make 的嵌套执行中，我们需要了解一个变量 “CURDIR”，此变量代表 make 的工作目录。当使用 make 的选项 “-C” 的时候，命令就会进入指定的目录中，然后此变量就会被重新赋值。总之，如果在 Makefile 中没有对此变量进行显式的赋值操作，那么它就表示 make 的工作目录。我们也可以在 Makefile 中为这个变量赋一个新的值，当然重新赋值后这个变量将不再代表 make 的工作目录。</p><h4 id="export的使用"><a href="#export的使用" class="headerlink" title="export的使用"></a>export的使用</h4><p>使用 make 嵌套执行的时候，变量是否传递也是我们需要注意的。如果需要变量的传递，那么可以这样来使用：export <variable></variable></p><p>如果不需要那么可以这样来写：unexport <variable></variable></p><p><variable>是变量的名字，不需要使用 “$” 这个字符。如果所有的变量都需要传递，那么只需要使用 “export” 就可以，不需要添加变量的名字。</variable></p><p>Makefile 中还有两个变量不管是不是使用关键字 “export” 声明，它们总会传递到下层的 Makefile 中。这两个变量分别是 SHELL 和 MAKEFLAGS，特别是 MAKEFLAGS 变量，包含了 make 的参数信息。如果执行总控 Makefile 时，make 命令带有参数或者在上层的 Makefile 中定义了这个变量，那么 MAKEFLAGS 变量的值将会是 make 命令传递的参数，并且会传递到下层的 Makefile 中，这是一个系统级别的环境变量。</p><p>make 命令中有几个参数选项并不传递，它们是:”-C”、”-f”、”-o”、”-h” 和 “-W”。如果我们不想传递 MAKEFLAGS 变量的值，在 Makefile 中可以这样来写：</p><pre><code>subsystem:    cd subdir &amp;&amp; $(MAKE) MAKEFLAGS=</code></pre><p>案例：通过一个大的项目工程来详细的分析一下如何嵌套执行 make。</p><p>假设有一个 MP3 player 的应用程序，它可以被划分为若干个组件：用户界面（ui）、编解码器（codec）以及数据管理库（db）。它们分别可以用三个程序库来表示：libui.a、libcodec.a 和 libdb.a。将这些组件紧凑的放到一起就可以组成这个应用程序。具体的文件结构展示为（我们展示的只是目录文件，没有展示详细的源文件）:</p><blockquote><p>├──Makefile //最外层的Makefile文件，不是目录文件。</p></blockquote><blockquote><p>├──include //编译的时候需要链接的库文件</p></blockquote><blockquote><p>│ ├──codec //libui.a 库文件所在的目录</p></blockquote><blockquote><p>│ ├──db //libdb.a 库文件所在的目录</p></blockquote><blockquote><p>│ ├──ui //libui.a库文件所在的目录</p></blockquote><blockquote><p>├──lib //源文件所在的目录，子目录文件中包含Makefile文件</p></blockquote><blockquote><p>│ ├──codec //编解码器所在的源文件的目录</p></blockquote><blockquote><p>│ ├──db //数据库源文件所在的目录</p></blockquote><blockquote><p>│ ├──ui //用户界面源文件所在目录</p></blockquote><blockquote><p>├──app</p></blockquote><blockquote><p>│ ├──player</p></blockquote><blockquote><p>└──doc //这个工程编译说明</p></blockquote><p>我们可以看到最外层有一个 Makefile 文件，这就是我们的 “总控Makefile” 文件，我们使用这个 Makefile 调用项目中各个子目录的 Makefile 文件的运行。假设只有我们的 lib 目录下和 app 目录下的各个子目录含有 Makefile 文件。那我们总控的 Makefile 的文件可以这样来写：</p><pre><code>lib_codec := lib/codeclib_db    := lib/dblib_ui     := lib/uilibraries   := $(lib_codec) $(lib_db) $(lib_ui)player    := app/player.PHONY : all $(player) $(libraries)all : $(player)$(player) $(libraries) :    $(MAKE) -C $@</code></pre><p>我们可以看到在 “总控 Makefile” 中，一个规则在工作目标上列出了所有的子目录，它对每一个子目录的 Makefile 调用的代码是：$(player) $(libraries) :</p><pre><code>   $(MAKE) -C $@</code></pre><p>在 Makefile 文件中，MAKE 变量应该总是用来调用 make 程序。make 程序一看到 MAKE 变量就会把它设成 make 的实际路径，所以递归调用中的每次调用都会使用同一个执行文件。此外，当命令 –touch(-t)、–just-print(-n) 和 –question(-q) 被使用时，包含 MAKE 变量的每一行都会受到特别的处理。</p><p>由于这些“工作目标目录”被设成 .PHONY 的依赖文件，所以即使工作目标已经更新，此规则仍旧会进行更新动作。使 –directory(-C) 选项的目的是要让 make 在读取 Makefile 之前先切换到相应的 “工作目录” 。</p><p>当 make 在建立依存图的时候找不到程序库与 app/player 工作目标之间的依存关系时，这意味着建立任何程序库之前，make 将会先执行 app/player 目录中的 Makefile。显然这将会导致失败的结果，因为应用程序的链接需要程序库。为解决这个问题，我们会提供额外的依存信息：</p><pre><code>$(player) : $(libraries)$(lib_ui) : $(lib_db) $(lib_codec)</code></pre><p>我们在此处做了如下的描述：运行 app/player 目录中的 Makefile 之前必须先运行程序库子目录中的 Makefile。此外，编译 lib/ui 目录中的程序代码之前必须先编译 lib/db 和lib/codec 目录中的程序库。这么做可以确保任何自动产生的程序代码，在 lib/ui 目录中的程序代码被编译之前就已经产生出来了。</p><p>更新必要条件的时候，会引发微妙的次序问题。如同所有的依存关系，更新的次序取决于依存图的分析结果，但是当工作目标的必要条件（依赖文件）出现在同一行时，GNU make 将会从左至右的次序进行更新。例如：</p><pre><code>all : a b call : d e f</code></pre><p>如果不存在其他的依存关系，这6个必要条件的更新动作可以是任何次序，不过GNU make将会以从左向右的次序来更新出现在同一行的必要条件，这会产生如下的更新次序：”a b c d e f” 或 “d e f a b c”。注意：不要因为之前这么做更新的次序是对的，就以为每次这么做都是对的，而忘了提供完整的依存信息。</p><p>最后，依存分析可能会产生不同的次序而引发一些问题。所以，如果有一组工作目标需要以特定的次序进行更新时，就必须提供适当的必要条件来实现正确的次序。</p><p>当我们在最外层执行 make 的时候我们会看到l输出的信息：</p><pre><code>make -C lib/dbmake[1]: Entering directory ‘/MP3_player/lib/db’make[1]:Update db library...make[1]: Leaving directory ‘/MP3_player/lib/db’make -C lib/codecmake[1]: Entering directory ‘/MP3_player/lib/codec’make[1]:Update codec library...make[1]: Leaving directory ‘/MP3_player/lib/codec’make -C lib/uimake[1]: Entering directory ‘/MP3_player/lib/ui’make[1]:Update ui library...make[1]: Leaving directory ‘/MP3_player/lib/ui’make -C app/playermake[1]: Entering directory ‘/MP3_player/app/player’make[1]:Update player library...make[1]: Leaving directory ‘/MP3_player/app/player’</code></pre><p>当 make 发觉它正在递归调用另一个 make 时，他会启 用–print-directory(-w) 选项，这会使得 make 输出 Entering directory(进入目录) 和 Leaving directory(离开目录) 的信息。当 –directory(-C) 选项被使用时，也会启用这个选项。我们还可以看到每一行中，MAKELEVEL 这个 make 变量的值加上方括号之后被一起输出。在这个简单的例子里，每个组件的 Makefile 只会输出组件正在更新的信息，而不会真正的更新组件。</p><p>我们通过这个例子应该可以了解，在 make 的嵌套执行执行的时候的调用子目录的方式，还有子目录再去执行 make 时候的顺序。这是一个很典型的例子，我们的每一个工程文件都可以用上面的结构展示出来，我们只要懂得每一个子目录在被调用时候的顺序，我们就可以很轻松的编写 “总控Makefile” 。</p><h2 id="make命令参数和选项大汇总"><a href="#make命令参数和选项大汇总" class="headerlink" title="make命令参数和选项大汇总"></a>make命令参数和选项大汇总</h2><p>我们在在执行 make 命令时，有的时候需要加上一下参数选项来保证我们的程序的执行，其实之前已经遇到过 make 在执行命令的时候需要添加上参数选项，比如只打印命令但不执行使用的参数是 “-n” ，还有只执命令不打印命令的参数选项是 “-s”，包含其它文件的路径参数选项是 “-include”等等。</p><p>我们现在列举一下 make 可以使用的参数选项，以及它们的功能是什么。</p><style><!--br {mso-data-placement:same-cell;}--> td {white-space:pre-wrap;border:1px solid #dee0e3;}</style> <byte-sheet-html-origin data-id="EMJfPwGYuY-1623856826604" data-version="3" data-is-embed="true"><p>| 参数选项 | 功能 |<br>| -b，-m | 忽略，提供其他版本 make 的兼容性 |<br>| -B，–always-make | 强制重建所有的规则目标，不根据规则的依赖描述决定是否重建目标文件。 |<br>| -C DIR，–directory=DIR | 在读取 Makefile 之前，进入到目录 DIR，然后执行 make。当存在多个 “-C” 选项的时候，make 的最终工作目录是第一个目录的相对路径。 |<br>| -d | make 在执行的过程中打印出所有的调试信息，包括 make 认为那些文件需要重建，那些文件需要比较最后的修改时间、比较的结果，重建目标是用的命令，遗憾规则等等。使用 “-d” 选项我们可以看到 make 构造依赖关系链、重建目标过程中的所有的信息。 |<br>| –debug[=OPTIONS] | make 执行时输出调试信息，可以使用 “OPTIONS” 控制调试信息的级别。默认是 “OPTIONS=b” ，”OPTIONS” 的可值为以下这些，首字母有效：all、basic、verbose、implicit、jobs、makefile。 |<br>| -e，–enveronment<br>-overrides | 使用环境变量定义覆盖 Makefile 中的同名变量定义。 |<br>| -f=FILE，–file=FILE，<br>–makefile=FILE | 指定文件 “FILE” 为 make 执行的 Makefile 文件 |<br>| -p，–help | 打印帮助信息。 |<br>| -i，–ignore-errors | 执行过程中忽略规则命令执行的错误。 |<br>| -I DIR，–include-dir=DIR | 指定包含 Makefile 文件的搜索目录，在Makefile中出现另一个 “include” 文件时，将在 “DIR” 目录下搜索。多个 “-i” 指定目录时，搜索目录按照指定的顺序进行。 |<br>| -j [JOBS]，–jobs[=JOBS] | 可指定同时执行的命令数目，爱没有 “-j” 的情况下，执行的命令数目将是系统允许的最大可能数目，存在多个 “-j” 目标时，最后一个目标指定的 JOBS 数有效。 |<br>| -k，–keep-going | 执行命令错误时不终止 make 的执行，make 尽最大可能执行所有的命令，直至出现知名的错误才终止。 |<br>| -l load，–load-average=[=LOAD]，–max-load[=LOAD] | 告诉 make 在存在其他任务执行的时候，如果系统负荷超过 “LOAD”，不在启动新的任务。如果没有指定 “LOAD” 的参数 “-l” 选项将取消之前 “-l” 指定的限制。 |<br>| -n，–just-print，–dry-run | 只打印执行的命令，但是不执行命令。 |<br>| -o FILE，–old-file=FILE，<br>–assume-old=FILE | 指定 “FILE”文件不需要重建，即使是它的依赖已经过期；同时不重建此依赖文件的任何目标。注意：此参数不会通过变量 “MAKEFLAGS” 传递给子目录进程。 |<br>| -p，–print-date-base | 命令执行之前，打印出 make 读取的 Makefile 的所有数据，同时打印出 make 的版本信息。如果只需要打印这些数据信息，可以使用 “make -qp” 命令，查看 make 执行之前预设的规则和变量，可使用命令 “make -p -f /dev/null” |<br>| -q，-question | 称为 “询问模式” ；不运行任何的命令，并且无输出。make 只返回一个查询状态。返回状态 0 表示没有目标表示重建，返回状态 1 表示存在需要重建的目标，返回状态 2 表示有错误发生。 |<br>| -r，–no-builtin-rules | 取消所有的内嵌函数的规则，不过你可以在 Makefile 中使用模式规则来定义规则。同时选项 “-r” 会取消所有后缀规则的隐含后缀列表，同样我们可以在 Makefile 中使用 “.SUFFIXES”，定义我们的后缀名的规则。”-r” 选项不会取消 make 内嵌的隐含变量。 |<br>| -R，–no-builtin-variabes | 取消 make 内嵌的隐含变量，不过我们可以在 Makefile 中明确定义某些变量。注意：”-R” 和 “-r” 选项同时打开，因为没有了隐含变量，所以隐含规则将失去意义。 |<br>| -s，–silent，–quiet | 取消命令执行过程中的打印。 |<br>| -S，–no-keep-going，<br>–stop | 取消 “-k” 的选项在递归的 make 过程中子 make 通过 “MAKEFLAGS” 变量继承了上层的命令行选项那个。我们可以在子 make 中使用“-S”选项取消上层传递的 “-k” 选项，或者取消系统环境变量 “MAKEFLAGS” 中 “-k”选项。 |<br>| -t，–touch | 和 Linux 的 touch 命令实现功能相同，更新所有的目标文件的时间戳到当前系统时间。防止 make 对所有过时目标文件的重建。 |<br>| -v，version | 查看make的版本信息。 |<br>| -w，–print-directory | 在 make 进入一个子目录读取 Makefile 之前打印工作目录，这个选项可以帮助我们调试 Makefile，跟踪定位错误。使用 “-C” 选项时默认打开这个选项。 |<br>| –no-print-directory | 取消 “-w” 选项。可以是 用在递归的 make 调用的过程中 ，取消 “-C” 参数的默认打开 “-w” 的功能。 |<br>| -W FILE，–what-if=FILE，<br>–new-file=FILE，<br>–assume-file=FILE | 设定文件 “FILE” 的时间戳为当前的时间，但不更改文件实际的最后修改时间。此选项主要是为了实现对所有依赖于文件 “FILE” 的目标的强制重建。 |<br>| –warn-undefined-variables | 在发现 Makefile 中存在没有定义的变量进行引用时给出告警信息。此功能可以帮助我们在调试一个存在多级嵌套变量引用的复杂 Makefile。但是建议在书写的时候尽量避免超过三级以上的变量嵌套引用。 | </p><h2 id="Makefile目标类型大汇总"><a href="#Makefile目标类型大汇总" class="headerlink" title="Makefile目标类型大汇总"></a>Makefile目标类型大汇总</h2><p>模式规则中的目标。规则中的目标形式是多种多样的，它可以是一个或多个的文件、可以是一个伪目标，这是我们之前讲到过的，也是经常使用的。其实规则目标还可以是其他的类型，下面是对这些类型的详细的说明。</p><h4 id="强制目标"><a href="#强制目标" class="headerlink" title="强制目标"></a>强制目标</h4><p>如果一个目标中没有命令或者是依赖，并且它的目标不是一个存在的文件名，在执行此规则时，目标总会被认为是最新的。就是说：这个规则一旦被执行，make 就认为它的目标已经被更新过。这样的目标在作为一个规则的依赖时，因为依赖总被认为更新过，因此作为依赖在的规则中定义的命令总会被执行。看一个例子：</p><pre><code>clean:FORCE    rm $(OBJECTS)FORCE:</code></pre><p>这个例子中，目标 “FORCE” 符合上边的条件。它作为目标 “clean” 的依赖，在执行 make 的时候，总被认为更新过。因此 “clean” 所在的规则而在被执行其所定义的那个命令总会被执行。这样的一个目标通常我们将其命名为 “FORCE”。</p><p>例子中使用 “FORCE” 目标的效果和将 “clean” 声明为伪目标的效果相同。</p><h4 id="空目标文件"><a href="#空目标文件" class="headerlink" title="空目标文件"></a>空目标文件</h4><p>空目标文件是伪目标的一个变种，此目标所在的规则执行的目的和伪目标相同——通过 make 命令行指定将其作为终极目标来执行此规则所定义的命令。和伪目标不同的是：这个目标可以是一个存在的文件，但文件的具体内容我们并不关心，通常此文件是一个空文件。</p><p>空目标文件只是用来记录上一次执行的此规则的命令的时间。在这样的规则中，命令部分都会使用 “touch” 在完成所有的命令之后来更新目标文件的时间戳，记录此规则命令的最后执行时间。make 时通过命令行将此目标作为终极目标，当前目标下如果不存在这个文件，”touch” 会在第一次执行时创建一个的文件。</p><p>通常，一个空目标文件应该存在一个或者多个依赖文件。将这个目标作为终极目标，在它所依赖的文件比它更新时，此目标所在的规则的命令行将被执行。就是说如果空目标文件的依赖文件被改变之后，空目标文件所在的规则中定义的命令会被执行。看一个例子：</p><pre><code>print:foot.c bar.c    lpr -p $?    touch print</code></pre><p>执行 “make print” ,当目标文件 “print” 的依赖文件被修改之后，命令 “lpr -p $?” 都会被执行，打印这个被修改的文件。</p><h4 id="特殊的目标"><a href="#特殊的目标" class="headerlink" title="特殊的目标"></a>特殊的目标</h4><style><!--br {mso-data-placement:same-cell;}--> td {white-space:pre-wrap;border:1px solid #dee0e3;}</style> <byte-sheet-html-origin data-id="iPb9ly6NoW-1623856826609" data-version="3" data-is-embed="true"><p>| 名称 | 功能 |<br>| .PHONY: | 这个目标的所有依赖被作为伪目标。伪目标是这样一个目标：当使用 make 命令行指定此目标时，这个目标所在的规则定义的命令、无论目标文件是否存在都会被无条件执行。 |<br>| .SUFFIXES: | 这个目标的所有依赖指出了一系列在后缀规则中需要检查的后缀名 |<br>| .DEFAULT: | Makefile 中，这个特殊目标所在规则定义的命令，被用在重建那些没有具体规则的目标，就是说一个文件作为某个规则的依赖，却不是另外一个规则的目标时，make 程序无法找到重建此文件的规则，这种情况就执行 “.DEFAULT” 所指定的命令。 |<br>| .PRECIOUS: | 这个特殊目标所在的依赖文件在 make 的过程中会被特殊处理：当命令执行的过程中断时，make 不会删除它们。而且如果目标的依赖文件是中间过程文件，同样这些文件不会被删除。 |<br>| .INTERMEDIATE: | 这个特殊目标的依赖文件在 make 执行时被作为中间文件对待。没有任何依赖文件的这个目标没有意义。 |<br>| .SECONDARY: | 这个特殊目标的依赖文件被作为中过程的文件对待。但是这些文件不会被删除。这个目标没有任何依赖文件的含义是：将所有的文件视为中间文件。 |<br>| .IGNORE | 这个目标的依赖文件忽略创建这个文件所执行命令的错误，给此目标指定命令是没有意义的。当此目标没有依赖文件时，将忽略所有命令执行的错误。 |<br>| .DELETE_ON_ERROR: | 如果在 Makefile 中存在特殊的目标 “.DELETE_ON_ERROR” ，make 在执行过程中，荣国规则的命令执行错误，将删除已经被修改的目标文件。 |<br>| .LOW_RESOLUTION_TIME: | 这个目标的依赖文件被 make 认为是低分辨率时间戳文件，给这个目标指定命令是没有意义的。通常的目标都是高分辨率时间戳。 |<br>| .SILENT: | 出现在此目标 “.SILENT” 的依赖文件列表中的文件，make 在创建这些文件时，不打印出此文件所执行的命令。同样，给目标 “SILENT” 指定命令行是没有意义的。 |<br>| .EXPORT_ALL_VARIABLES: | 此目标应该作为一个简单的没有依赖的目标，它的功能是将之后的所有变量传递给子 make 进程。 |<br>| .NOTPARALLEL: | Makefile 中如果出现这个特殊目标，则所有的命令按照串行的方式执行，即使是存在 make 的命令行参数 “-j” 。但在递归调用的子make进程中，命令行可以并行执行。此目标不应该有依赖文件，所有出现的依赖文件将会被忽略。 | </p><h4 id="多规则目标"><a href="#多规则目标" class="headerlink" title="多规则目标"></a>多规则目标</h4><p>Makefile 中，一个文件可以作为多个规则的目标。这种情况时，以这个文件为目标的规则的所有依赖文件将会被合并成此目标一个依赖文件列表，当其中的任何一个依赖文件比目标更新时，make 将会执行特定的命令来重建这个目标。</p><p>对于一个多规则的目标，重建这个目标的命令只能出现在一个规则中。如果多个规则同时给出重建此目标的命令，make 将使用最后一个规则中所定义的命令，同时提示错误信息。某些情况，需要对相同的目标使用不同的规则中所定义的命令，我们需要使用另一种方式——双冒号规则来实现。</p><p>一个仅仅描述依赖关系的描述规则可以用来给出一个或者时多个目标文件的依赖文件。例如，Makefile 中通常存在一个变量，就像我们以前提到的 “objects” ,它定义为所有的需要编译的生成 .o 文件的列表。这些 .o 文件在其源文件中包含的头文件 “config.h” 发生变化之后能够自动的被重建，我们可以使用多目标的方式来书写 Makefile：</p><pre><code>objects=foo.o bar.ofoo.o:defs.hbar.o:defs.h test.h$(objects):config.h</code></pre><p>这样做的好处是：我们可以在源文件增加或者删除了包含的头文件以后不用修改已存在的 Makefile 的规则，只需要增加或者删除某一个 .o 文件依赖的头文件。这种方式很简单也很方便。</p><p>我们也可以通过一个变量来增加目标的依赖文件，使用 make 的命令行来指定某一个目标的依赖头文件，例如：</p><pre><code>extradeps=$(objects):$(exteradeps)</code></pre><p>它的意思是：如果我们执 “make exteradeps=foo.h” 那么 “foo.h” 将作为所有的 .o 文件的依赖文件。当然如果只执行 “make” 的话，就没有指定任何文件作为 .o 文件的依赖文件。</p><h2 id="Makefile变量的高级用法"><a href="#Makefile变量的高级用法" class="headerlink" title="Makefile变量的高级用法"></a>Makefile变量的高级用法</h2><h4 id="变量的替换引用"><a href="#变量的替换引用" class="headerlink" title="变量的替换引用"></a>变量的替换引用</h4><p>我们定义变量的目的是为了简化我们的书写格式，代替我们在代码中频繁出现且冗杂的部分。它可以出现在我们规则的目标中，也可以是我们规则的依赖中。我们使用的时候会经常的对它的值（表示的字符串）进行操作。遇到这样的问题我们可能会想到我们的字符串操作函数，比如 “patsubst” 就是我们经常使用的。但是我们使用变量同样可以解决这样的问题，我们通过下面的例子来具体的分析一下。</p><p>实例：</p><pre><code>foo:=a.c b.c d.cobj:=$(foo:.c=.o)All:    @echo $(obj)</code></pre><p>这段代码实现的功能是字符串的后缀名的替换，把变量 foo 中所有的以 .c 结尾的字符串全部替换成 .o 结尾的字符串。我们在 Makefile 中这样写，然后再 shell 命令行执行 make 命令，就可以看到打印出来的是 “a.o b.o d.o” ，实现了文件名后缀的替换。注意：括号中的变量使用的是变量名而不是变量名的引用，变量名的后面要使用冒号和参数选项分开，表达式中间不能使用空格。第二个变量 obj 是对整体的引用。</p><p>上面的例子我们可以换一种更加通用的方式来写，代码展示如下：</p><pre><code>foo:=a.c b.c d.cobj:=$(foo:%.c=%.o)All:    @echo $(obj)</code></pre><p>我们在 shell 中执行 make 命令，发现结果是相同的。</p><p>对比上面的实例我们可以看到，表达式中使用了 “%” 这个字符，这个字符的含义就是自动匹配一个或多个字符。在开发的过程中，我们通常会使用这种方式来进行变量替换引用的操作。</p><p>为什么这种方式比第一种方式更加实用呢？我们在实际使用的过程中，我们对变量值的操作不只是修改其中的一个部分，甚至是改变其中的多个，那么第一种方式就不能实现了。我们来看一下这种情况：</p><pre><code>foo:=a123c a1234c a12345cobj:=$(foo:a%c=x%y)All:    @echo $(obj)</code></pre><p>我们可以看到这个例子中我们操作的是两个不连续的部分，我们执行 make 后打印的值是 “x123y x1234y x12345y”，这种情况下我们使用第一种情况就不能实现，所以第二种的使用更全面。</p><h4 id="变量的嵌套使用"><a href="#变量的嵌套使用" class="headerlink" title="变量的嵌套使用"></a>变量的嵌套使用</h4><p>变量的嵌套引用的具体含义是这样的，我们可以在一个变量的赋值中引用其他的变量，并且引用变量的数量和和次数是不限制的。下面我们通过几个实例来说明一下。</p><p>实例 1：</p><pre><code>foo:=testvar:=$(foo)All:    @echo $(var)</code></pre><p>这种用法是最常见的使用方法，打印出 var 的值就是 test。我们可以认为是一层的嵌套引用。</p><p>实例 2：</p><pre><code>foo=barvar=testvar:=$($(foo))All:    @echo $(var)</code></pre><p>我们再去执行 make 命令的时候得到的结果也是 test，我们可以来分析一下这段代码执行的过程：$(foo) 代表的字符串是 bar，我们也定义了变量 bar，所以我们可以对 bar 进行引用，变量 bar 表示的值是 test，所以对 bar 的引用就是 test，所以最终 var 的值就是 test。这是变量的二层嵌套执行，当然我们还可以使用三层的嵌套执行，写法跟上面的方式是一样的。嵌套的层数也可以更多，但是不提倡使用。</p><p>我们再去使用变量的时候，我们并不是只能引用一个变量，可以有多个变量的引用，还可以包含很多的变量还可以是一些文本字符。我们可以通过一些例子来说明一下。</p><p>实例 4：</p><pre><code>first_pass=hellobar=firstvar:=$(bar)_passall:    @echo $(var)</code></pre><p>在命令行执行 make 我们可以得到 var 的值是 hello。这是变量嵌套引用的时候可以包含其它字符的使用情况。</p><p>实例 5：</p><pre><code>first_pass=hellobar=firstfoo=passvar:=$(bar)_$(foo)all:    @echo $(var)</code></pre><p>这个实例跟上面实例的运行结果是一样的。我们可以看到这个实例中使用了两个变量的引用还有其它的字符。</p><p>变量的嵌套引用和我们的变量的递归赋值的区别：嵌套引用的使用方法就是用一个变量表示另外一个变量，然后进行多层的引用。而递归展开的变量表示当一个变量存在对其它变量的引用时，对这变量替换的方式。递归展开在另外一个角度描述了这个变量在定义是赋予它的一个属性或者风格。并且我们可以在定义个一个递归展开式的变量时使用套嵌引用的方式，但是建议你的实际编写 Makefile 时要尽量避免这种复杂的用法。</p><p>在实际使用的过程中变量的第一种用法经常使用的，第二种用法我们很少使用，应该说是尽量避免使用变量的嵌套引用。在必须要使用的时候我们应该做到嵌套的层数是越少越好的。因为使用这种方法表达会比较的复杂，如果条理不清楚的话我们就会出错。并且在给其他人看的时候也会不容易理解。</p><h2 id="Makefile控制函数error和warning"><a href="#Makefile控制函数error和warning" class="headerlink" title="Makefile控制函数error和warning"></a>Makefile控制函数error和warning</h2><p>Makefile 中提供了两个控制 make 运行方式的函数。其作用是当 make 执行过程中检测到某些错误时为用户提供消息，并且可以控制 make 执行过程是否继续。这两个函数是 “error” 和 “warning”，我们来详细的介绍一下这两个函数。</p><pre><code>$(error TEXT...)</code></pre><p>函数说明如下：</p><ul><li><p>函数功能：产生致命错误，并提示 “TEXT…” 信息给用户，并退出 make 的执行。需要说明的是：”error” 函数是在函数展开时（函数被调用时）才提示信息并结束 make 进程。因此如果函数出现在命令中或者一个递归的变量定义时，读取 Makefile 时不会出现错误。而只有包含 “error” 函数引用的命令被执行，或者定义中引用此函数的递归变量被展开时，才会提示知名信息 “TEXT…” 同时退出 make。</p></li><li><p>返回值：空</p></li><li><p>函数说明：”error” 函数一般不出现在直接展开式的变量定义中，否则在 make 读取 Makefile 时将会提示致命错误。</p></li></ul><p>我们通过两个例子来说明一下；</p><p>实例 1：</p><pre><code>ERROR1=1234all:    ifdef ERROR1    $(error error is $(ERROR1))    endif     </code></pre><p>make 读取解析 Makefile 时，如果所起的变量名是已经定义好的”ERROR1”，make 将会提示致命错误信息 “error is 1234” 并保存退出。</p><p>实例 2：</p><pre><code>ERR=$(error found an error!).PHONY:errerr:;$(ERR)</code></pre><p>这个例子，在 make 读取 Makefile 时不会出现致命错误。只有目标 “err” 被作为是一个目标被执行时才会出现。</p><pre><code>$(warning TEXT...)</code></pre><p>函数说明如下：</p><ul><li><p>函数功能：函数 “warning” 类似于函数 “error” ，区别在于它不会导致致命错误（make不退出），而只是提示 “TEXT…”，make 的执行过程继续。</p></li><li><p>返回值：空</p></li><li><p>函数说明：用法和 “error” 类似，展开过程相同。</p></li></ul><h2 id="Makefile中常见的错误信息"><a href="#Makefile中常见的错误信息" class="headerlink" title="Makefile中常见的错误信息"></a>Makefile中常见的错误信息</h2><p>make 执行过程的致命错误都带有前缀字符串 “***”。错误信息都有前缀，一种是执行程序名作为错误前缀（通常是 “make”）；另外一种是当 Makefile 本身存在语法错误无法被 make 解析并执行时，前缀包含了 Makefile 文件名和出现错误的行号。</p><p>在下述的错误列表中，省略了普通前缀：</p><pre><code>[FOO] Error NN[FOO] signal description</code></pre><p>这类错误并不是 make 的真正错误。它表示 make 检测到 make 所调用的作为执行命令的程序返回一个非零状态（Error NN），或者此命令程序以非正常方式退出（携带某种信号）。</p><p>如果错误信息中没有附加 “***” 字符串，则是子过程的调用失败，如果 Makefile 中此命令有前缀 “-“，make 会忽略这个错误。</p><pre><code>missing separator. Stop.missing separator (did you mean TAB instead of 8 spaces?). Stop.</code></pre><p>错误的原因：不可识别的命令行，make 在读取 Makefile 过程中不能解析其中包含的内容。GNU make在读取 Makefile 时根据各种分隔符（:, =, [TAB]字符等）来识别 Makefile 的每一行内容。这些错误意味着 make 不能发现一个合法的分隔符。</p><p>出现这些错误信息的可能的原因是（或许是编辑器，绝大部分是ms- windows的编辑器）在 Makefile 中的命令之前使用了4个（或者8个）空格代替了 [Tab] 字符。这种情况，将产生上述的第二种形式产生错误信息。且记，所有的命令行都应该是以 [Tab] 字符开始的。</p><pre><code>commands commence before first target. Stop.missing rule before commands. Stop.</code></pre><p>Makefile 可能是以命令行开始：以 [Tab] 字符开始，但不是一个合法的命令行（例如，一个变量的赋值）。命令行必须和规则一一对应。</p><p>产生第二种的错误的原因可能是一行的第一个非空字符为分号，make 会认为此处遗漏了规则的 “target: prerequisite” 部分。</p><pre><code>No rule to make target 'XXX'.No rule to make target 'XXX ', needed by 'yyy'.</code></pre><p>无法为重建目标“XXX”找到合适的规则，包括明确规则和隐含规则。</p><p>修正这个错误的方法是：在 Makefile 中添加一个重建目标的规则。其它可能导致这些错误的原因是 Makefile 中文件名拼写错误，或者破坏了源文件树（一个文件不能被重建，可能是由于依赖文件的问题）。</p><pre><code>No targets specified and no makefile found. Stop.No targets. Stop.</code></pre><p>第一个错误表示在命令行中没有指定需要重建的目标，并且 make 不能读入任何 Makefile 文件。第二个错误表示能够找到 Makefile 文件，但没有终极目标或者没有在命令行中指出需要重建的目标。这种情况下，make 什么也不做。</p><pre><code>Makefile 'XXX' was not found.Included makefile 'XXX' was not found.</code></pre><p>没有使用 “-f” 指定 Makefile 文件，make 不能在当前目录下找到默认 Makefile（makefile 或者 GNUmakefile）。使用 “-f” 指定文件，但不能读取这个指定的 Makefile 文件。</p><pre><code>warning: overriding commands for target 'XXX'warning: ignoring old commands for target 'XXX'</code></pre><p>对同一目标 “XXX” 存在一个以上的重建命令。GNU make 规定：当同一个文件作为多个规则的目标时，只能有一个规则定义重建它的命令（双冒号规则除外）。如果为一个目标多次指定了相同或者不同的命令，就会产生第一个告警；第二个告警信息说新指定的命令覆盖了上一次指定的命令。</p><pre><code>Circular XXX &lt;- YYY dependency dropped.</code></pre><p>规则的依赖关系产生了循环：目标 “XXX” 的依赖文件为 “YYY”，而依赖 “YYY” 的依赖列表中又包含 “XXX”。Recursive variable ‘XXX’ references itself (eventually). Stop.</p><p>make 的变量 “XXX”（递归展开式）在替换展开时，引用它自身。无论对于直接展开式变量（通过:=定义的）或追加定义（+=），这都是不允许的。</p><pre><code>Unterminated variable reference. Stop.</code></pre><p>变量或者函数引用语法不正确，没有使用完整的的括号（缺少左括号或者右括号）。</p><pre><code>insufficient arguments to function 'XXX'. Stop.</code></pre><p>函数 “XXX” 引用时参数数目不正确。函数缺少参数。</p><pre><code>missing target pattern. Stop.multiple target patterns. Stop.target pattern contains no '%'. Stop.       mixed implicit and static pattern rules. Stop.</code></pre><p>不正确的静态模式规则。</p><p>第一条错误的原因是：静态模式规则的目标段中没有模式目标；</p><p>第二条错误的原因是：静态模式规则的目标段中存在多个模式目标；</p><p>第三条错误的原因是：静态模式规则的目标段目标模式中没有包含模式字符“%”；</p><p>第四条错误的原因是：静态模式规则的三部分都包含了模式字符“%”。正确的应该是只有后两个才可以包含模式字符“%”。</p><pre><code>warning: -jN forced in submake: disabling jobserver mode.</code></pre><p>这一条告警和下条告警信息发生在：make 检测到递归的 make 调用时，可通信的子 make 进程出现并行处理的错误。递归执行的 make 的命令行参数中存在 “-jN” 参数（N的值大于1），在有些情况下可能导致此错误，例如：Makefile 中变量 “MAKE” 被赋值为 “make –j2”，并且递归调用的命令行中使用变量 “MAKE”。在这种情况下，被调用 make 进程不能和其它 make 进程进行通信，其只能简单的独立的并行处理两个任务”。warning: jobserver unavailable: using -j1. Add ‘+’ to parent make rule.</p><p>为了现实 make 进程之间的通信，上层 make 进程将传递信息给子 make 进程。在传递信息过程中可能存在这种情况，子 make 进程不是一个实际的 make 进程，而上层make却不能确定子进程是否是真实的 make 进程。它只是将所有信息传递下去。上层 make 采用正常的算法来决定这些。当出现这种情况，子进程只会接受父进程传递的部分有用的信息。子进程会产生该警告信息，之后按照其内建的顺序方式进行处理。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><a href="https://blog.csdn.net/xinyuan510214/article/details/50457433" target="_blank" rel="noopener">EXTRA_CFLAGS详解</a></p></byte-sheet-html-origin></byte-sheet-html-origin></byte-sheet-html-origin><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MakeFile | Linux Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx学习笔录</title>
      <link href="/posts/blog-program04.html"/>
      <url>/posts/blog-program04.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">官方文档</a></p><h3 id="Http协议简介"><a href="#Http协议简介" class="headerlink" title="Http协议简介"></a>Http协议简介</h3><ul><li><p>http协议：80/tcp,HyperText Transfer Procotol</p></li><li><p>html:Hypertext Mark Language</p></li><li><p>文本：HTTP/1.0 MIME</p></li><li><p>MIME:Multipurpose Internet Mail Extension</p><ul><li>major/minor<ul><li>text/plain</li><li>image/jpeg</li></ul></li></ul></li><li><p>URL:schem://server[:port]/path/to/source</p></li><li><p>http事务：request &lt;——–&gt; response</p><ul><li><p>request:<br><method><url><version></version></url></method></p><header></header></li><li><p>response:<br><version><status><reason phrase=""></reason></status></version></p><header><ul><li>协议格式：文本，二进制</li></ul></header></li></ul></li><li><p>method：<br>GET，HEAD,POST,PUT,DELETE,TRACE,OPTIONS</p></li><li><p>status:<br>1xx: 信息类<br>2xx: 成功类 200（ok）<br>3xx: 重定向类 301,302,304<br>4xx: 客户端错误类 403,404<br>5xx: 服务器端错误 502</p></li><li><p>HEADER：<br>通用首部<br>请求首部：<br>  IF-Modified-Since   IF-None-Match<br>响应首部<br>实体首部<br>扩展首部</p></li></ul><h3 id="Web页面访问及其页面资源"><a href="#Web页面访问及其页面资源" class="headerlink" title="Web页面访问及其页面资源"></a>Web页面访问及其页面资源</h3><ul><li><p>Web页面：多个资源<br>  入口，资源引用</p></li><li><p>认证：<br>基于IP认证<br>基于用户认证</p></li><li><p>资源映射：<br>Alias<br>DocumentRoot</p></li><li><p>httpd：MPM</p><ul><li><p>prefork，worker，event</p><p>prefork：主进程，生成多个子进程，每个子进程处理一个请求<br>worker：主进程，生成多个子进程，每个子进程生成多个线程，每个线程响应一个请求<br>event：主进程，生成多个子进程，每个子进程响应多个请求</p></li></ul></li></ul><h3 id="I-O类型"><a href="#I-O类型" class="headerlink" title="I/O类型"></a>I/O类型</h3><ul><li><p>同步与异步：synchronous，asynchronous<br>关注的是消息通知机制</p><ul><li>同步：调用发生之后不会立即返回，但一旦返回，就返回最终结果</li><li>异步：调用出发之后，被调用方立即返回消息，但返回并非最终结果；被调用通过状态，通知机制来通知调用者，或通过回调函数来处理结果过</li></ul></li><li><p>阻塞与非阻塞：block，nonblock<br>关注的是调用者等待返回调用结果时的状态</p><ul><li>阻塞：调用返回之前，调用者被挂起，只能得到返回结果过才能继续</li><li>非阻塞：调用在结果返回之前，不会被挂起，即调用不会阻塞调用者</li></ul></li></ul><p>###I/O模型</p><ul><li><p>blocking I/O：阻塞式</p></li><li><p>nonblocking I/O：非阻塞式</p></li><li><p>IO multiplexing：复用型<br>  select（），poll（）</p></li><li><p>signal driven IO：事件驱动</p><ul><li>通知：<br>水平触发：多次通知<br>边缘触发：只通知一次</li></ul></li><li><p>asynchronous IO：异步</p></li></ul><p>例如：一次读操作</p><ol><li>等待数据准备好，磁盘到内核内存</li><li>从内核复制到进程内存</li></ol><p>注：前三个为同步，后两个为异步</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ul><li><p><a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a> , C10k</p></li><li><p>Igor Sysoev,Rambler Media;</p><ul><li>engine X:nginx</li><li>tenglne,OpenResty</li></ul></li><li><p>Nginx特性：</p><ol><li>模块化设计，较好的扩展性</li><li>高可靠性：master/worker</li><li>支持热部署：不停机更新配置值文件，更新日志，更新服务器程序版本</li><li>低内存消耗：10000个keep-alive连接模式的非活动链接仅占2.5M</li><li>event-driven，alo，mmap</li></ol></li><li><p>基本功能</p><ul><li><p>静态资源的web服务器</p></li><li><p>http协议的反向代理</p><ul><li>http代理：指的是使用代理服务器使网络用户访问外部网站。代理服务器是介于浏览器和Web服务器之间的一台服务器，是建立在超文本传输协议上的网络浏览方式，作用是可以防伪部分对协议进行了限制的局域网。</li><li>关于HTTP代理服务器的主要功能包括五个方面：<ol><li>突破自身IP访问限制，访问国外站点；</li><li>访问一些单位或团体内部资源，如某大学的内部网，使用<a href="https://www.baidu.com/s?wd=%E6%95%99%E8%82%B2%E7%BD%91&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">教育网</a>内地址段免费代理服务器可以用于对教育 网开放的各类下载上传以及各类资料查询共享等服务；</li></ol></li></ul><ol start="3"><li>突破<a href="https://www.baidu.com/s?wd=%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A1&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">中国电信</a>的<a href="https://www.baidu.com/s?wd=IP%E5%B0%81%E9%94%81&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">IP封锁</a>：<a href="https://www.baidu.com/s?wd=%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A1&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">中国电信</a>有很多网站限制了用户访问，使用HTTP代理可以突破访问限制；</li><li>提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时将信息保存到缓冲区中，当其他用户再访问相同的信息时， 可直接由缓冲区中取出信息传递给用户，提高访问速度；</li><li>隐藏真实IP：HTTP代理可以隐藏IP地址，避免受到网络攻击。<ul><li>http反向代理：所谓反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br>我们常说的代理是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，科学上网工具 Shadowsocks 扮演的就是典型的正向代理角色。在天朝用浏览器访问 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 时会被无情的墙掉，要想翻阅这堵墙，你可以在国外用 Shadowsocks 来搭建一台代理服务器，让代理帮我们去请求 <a href="http://www.google.com，代理再把请求响应结果再返回给我。" target="_blank" rel="noopener">www.google.com，代理再把请求响应结果再返回给我。</a><br>反向代理隐藏了真实的服务端。</li></ul></li></ol></li><li><p>pop3，SMPT，IMap4等邮件协议的反向代理</p></li><li><p>能缓存打开的文件（元数据），支持FastCGI（php-fpm），uWSGI（python web Framwork）等协议</p></li><li><p>模块化，过滤器zip，ssi，ssl</p></li></ul></li><li><p>Web服务相关功能<br>虚拟主机，keepalive，访问日志，url rewrite，路径别名，基于IP及用户的访问控制，支持速率限制及并发数限制；……</p></li><li><p>Nginx基础架构</p><ul><li><p>master/worker<br>一个master进程，可以生成多个worker进程；<br>事件驱动：epoll（Linux），kqueue（FreeBSD），/dev/poll（Solars）</p><ul><li>消息通知：select，poll，rt signals</li></ul><p>支持sendfile，sendfile64<br>支持AIO，mmap</p><p>master：加载配置文件，管理worker进程，平滑升级……<br>worker：http服务，http代理，fastcgl代理……</p></li></ul></li><li><p>模块类型</p><ul><li>核心模块：core module</li><li>Standard HTTP modules</li><li>Optional HTTP modules</li><li>Mail modules</li><li>3rd party modules</li></ul></li><li><p>做什么？<br>静态资源web服务器<br>http服务器反向代理</p></li></ul><h3 id="Nginx安装与配置"><a href="#Nginx安装与配置" class="headerlink" title="Nginx安装与配置"></a>Nginx安装与配置</h3><p><a href="https://www.jianshu.com/p/be46088269ba" target="_blank" rel="noopener">Nginx:Window下安装与配置</a><br> <a href="https://www.jianshu.com/p/8d3e1689b884" target="_blank" rel="noopener">Nginx:Ubuntu下安装与配置</a></p><p><strong>配置文件</strong></p><ul><li>主配置文件：nginx.conf</li><li>mime.types</li><li>fastcgi配置文件：fastcgi_params     uwsgl_params</li><li>proxy.conf</li><li>sites.conf</li></ul><p><strong>配置指令</strong>(必须以分号结尾)</p><pre><code>Directive value1[value2……];</code></pre><p>支持使用变量：</p><ul><li>内置变量：又模块引入</li><li>自定义变量：<pre><code>set variable value</code></pre></li><li>引用变量:$variable</li></ul><p><strong>nginx.conf配置文件组织结构</strong></p><pre><code>main blockevent{...}http{...  upstream{  ...  }  //至少一个server  server{    ...    server_name    root    alias    location /url/{    ...    }  }  server{    ...  }} </code></pre><p><strong>main block配置</strong><br>  类别：</p><ul><li>正常运行必备的配置</li></ul><pre><code>1. user USERNAME [GROUPNAME];  指定用于运行work进程的用户和组.user nginx nginx2. pid /PATH/TO/PID_FILE;  指定nginx进程的pid文路径pid /var/run/nginx.pid3. worker_rlimit_nofile #;  一个work进程所能打开的最大文件描述符数量4. worker_rlimit_slgpending #; 每个用户能够发给worker进程的信号数量</code></pre><ul><li>优化性能相关的配置</li></ul><pre><code>1. work_processes # ;  worker进程的个数，通常为该物理CPU核心数量-1，可以设置为‘auto’2. worker_cpu_affinity CPUMASK CPUMASK ……    CUPMASK:0001    0010    0100    1000worker_cpu_affinity 00000001 00000010 000001003. worker_priority nice;[-20,19]</code></pre><ul><li>用于调试，定位问题的配置</li></ul><pre><code>1. daemon off|on;   是否以守护进程方式启动nginx2. master_process on|off;   是否以master/worker模型运行nginx3. error_log  /PATH/TO/ERROR_LOG level;   错误日志文件及其级别；用于调试需要，可以设为debug，但debug仅在编译时使用‘--with-debug’选项时才生效</code></pre><p><strong>event配置</strong></p><pre><code>1. worker_connections # ; 每个worker进程能够响应最大的并发请求数量worker_proceses * worker_connections2. use [epoll|rgsig|select|poll];定义使用的事件模型，建议让nginx自动选择3. accept_mutex [on|off];  各worker接受用户请求的负载均衡锁；启用时，表示用于让多个worker轮流的，序列的响应新请求4. lock_file /PATH/TO/LOCK_FILE;</code></pre><p><strong>http配置</strong></p><ul><li>套接字或主机相关指令</li></ul><ol><li><p>server{}：//定义虚拟主机</p><pre><code>server{listen PORT；server_name NAME;  root /PATH/TO/DOCUMENTROOT;}</code></pre><p>注：（1）基于port：listen监听不同的端口；<br>（2）基于hostname：server_name指令指向不同主机</p></li><li><p>listen</p><pre><code>listen address[:port][default_server][ssl][http2|spdy]listen port[default_server][ssl][http2|spdy]//default_server:设置默认虚拟主机，用于基于IP地址，或使用任意不能对应任何一个server的name时所返回的站点；//ssl:用于限制只能通过ssl连接提供服务//spdy:SPDY protocol(speedy),在编译时spdy模块情况下，用于支持SPDY协议//http2:http version 2;</code></pre></li><li><p>server_name NAME [……];<br>可跟一个或多个主机名，名称还可以使用通配符和正则表达式（~）；<br>```</p></li><li><p>首先做精准匹配：<a href="http://www.magedu.com" target="_blank" rel="noopener">www.magedu.com</a></p></li><li><p>左侧通配符：*.magedu.com</p></li><li><p>右侧通配符：<a href="http://www.magedu" target="_blank" rel="noopener">www.magedu</a>.*</p></li><li><p>正则表达式：~^.*\magedu.com$</p></li><li><p>default server</p><pre><code></code></pre></li><li><p>tcp_nodelay on|off<br>在keepalive模式下的连接是否使用TCP_NODELAY选项；</p></li><li><p>tcp_nopush on|off<br>是否启用TCP_NOPUSH(FREEBSE)或TCP_CORK(LINUX)选项；仅在sendfile为on时有用</p></li><li><p>sendfile on|off<br>是否启用sendfile功能</p></li></ol><ul><li>路径相关指令</li></ul><ol start="7"><li>root<br>设置web资源的路径映射，用于指明请求的URL所对应的文档目录的路径:<pre><code>server{...root /data/www/vhost1;}// 访问http://www.a.com/image/logo.jpg  --&gt;/data/www/vhost1/image/logo.ipgserver{...server_name www.a.comlocation /image/ { root /data/imgs/; ...}// 访问http://www.a.com/image/logo.jpg  --&gt;/data/imgs/image/logo.ipg</code></pre></li><li>location [= | ~ | <del>* | ^</del>] url{……}<br>location @name {……}</li></ol><p>功能：允许根据用户请求的url来匹配定义的各location，匹配到时，此请求将被相应的location块中的配置所处理，简言之，即用于需要的专用配置的URL提供特定配置。</p><ul><li>=：url的精确匹配</li><li>~：做正则表达式匹配，区分字符大小写</li><li>~*：做正则表达式匹配，不区分字符大小写</li><li>^~：url左半部分匹配，不区分字符大小写</li></ul><p><strong>匹配优先级</strong>：=，^<del>,</del>或~*，不带符号的url；</p><ol start="9"><li><p>alias<br>只能用于location匹配段，定义路径别名</p><pre><code>location /image/{root /data/imgs/;}location /image/{alias /data/imgs/;}</code></pre><p>注：<br>root：给定的路径对应location的“/”这个url<br>/image/test.jpg–&gt;/data/imgs/image/test.jpg<br>alias：给定的路径对应于location的“/url”这个url<br>/image/test.jpg–&gt;/data/imgs/test.jpg</p></li><li><p>index</p><pre><code>index file ……;</code></pre><p>默认主页面</p></li><li><p>error_page code … [=[response]] url<br>根据http的状态码重定向错误页面；</p><pre><code>error_page 404 /404.htmlerror_page 404=200 /404.html   //以指定状态码响应</code></pre></li><li><p>try_files file…… url；<br>try_files file……=code；<br>尝试查找第一个至第N-1个文件，第一个返回给请求者的资源，若N-1文件都不存在，则跳转至最后一个url（必须不能匹配至当前location，而应该匹配至其他location，否则会导致死循环）；</p></li></ol><p><strong>用户请求相关配置</strong><br>13. keepalive_timeout timeout [header_timeout]<br>设定keepalive连接的超时时长；0表示禁止长连接</p><ol start="14"><li><p>keepalive_requests number;<br>在keepalive链接上所允许请求的最大资源数量；默认100</p></li><li><p>keepalive_disable none|browser …;<br>指明禁止为何种浏览器使用keepalive功能；</p></li><li><p>send_timeout #;<br>发送响应报文超时时长，默认60s</p></li><li><p>client_body_buffer_size size;<br>接受客户端请求报文body的缓冲区大小，默认16k；超出此值时，将被移存于磁盘上</p></li><li><p>client_body_temp_path path [level1 [level2 [level3]]];<br>设定用于存储客户端请求body的临时储存路径及子目录结构和数量；</p><pre><code>client_body_temp_path /var/tmp/client_body 2 2</code></pre></li></ol><p><strong>对客户端请求进行限制</strong></p><ol start="19"><li><p>limit_except METHOD{…}<br>对指定范围外的其他方法进行访问控制；</p><pre><code>limit_except GET{allow 172.16.0.0/16;deny all;}</code></pre></li><li><p>limit_rate speed;<br>限制客户端每秒钟所能够传输的字节数，默认为0表示无限制。</p></li></ol><p><strong>文件操作优化相关配置</strong></p><ol start="21"><li><p>aio on|off</p></li><li><p>directio size|off;</p></li><li><p>open_file_cache off;<br>open_file_cache  max=N [inactive=time]</p><p>nginx可以缓存以下三种信息：</p><ol><li>文件描述符，文件大小和最近一次的修改时间</li><li>打开的目录的结构</li><li>没有找到的或者没有权限操作的文件的相关信息</li></ol></li></ol><p>max=N 表示可缓存的最大条目上限，则会使用LUR算法中删除最近最少使用的缓存项；</p><p>inactive=time:在此处指定的时长内没有被访问的缓存项视为非活动缓存项，因此直接删除；</p><ol start="24"><li><p>open_file_cache_errors on|off;<br>是否缓存找不到路径的文件，或没有权限访问的文件相关信息；</p></li><li><p>open_file_cache_valid time;<br>没隔多久检查一次缓存中缓存项的有效性，默认60s；</p></li><li><p>open_file_cache_min_uses number;<br>缓存项在非活动期限内最少应该被访问的次数；</p></li></ol><p><strong>ngx_http_access_module模块(基于IP的访问控制)</strong><br>27. allow address|CIDR|unix|all;</p><ol start="28"><li><p>deny address|CIDR|unix|all;</p><p>  应用上下文：http,server,location,limit_except</p></li></ol><p><strong>ngx_http_auth_basic_module模块(basic认证)</strong></p><ol start="29"><li><p>auth_basic string|off;<br>使用http basic认证协议对用户进行认证</p></li><li><p>auth_basic_user_file file;<br>实现用户认证的账号文件；</p></li></ol><ul><li><p>文件格式：<br>name1:password1<br>name2:password2;commit</p></li><li><p>密码格式：</p></li></ul><p>1.encrypted with the crypt（） function；<br>2.md5加密；</p><pre><code>location /admin/ {auth_basic "admin"auth_basic_user_file /etc/nginx/.ngxhtpasswd;}</code></pre><p><strong>ngx_http_log_module模块(访问日志)</strong><br>31. log_format name string …;<br>定义日志格式及其名称，日志格式一般通过调用内置函数变量来定义</p><ol start="32"><li>access_log path [format[buffer=size[flush=time]]];<br>access_log off;</li></ol><p>访问日志路径，格式名称以及缓存大小的刷写时间间隔；建议定义缓冲以提升性能。</p><ol start="33"><li>open_log_file_cache max=N[inactive=time][min_user=N][valid=time];<br>open_log_file_cache off;</li></ol><p><strong>ngx_http_stub_status_module模块</strong><br>34. stub_status;<br>通过指定的url的stub_status</p><p>Active connections: 291<br>server accepts handled requests<br> 16630948 16630948 31070465<br>Reading: 6 Writing: 179 Waiting: 106 </p><ul><li>Active connections:当前活动客户端连接数，包括<code>Waiting</code>连接数。</li><li>accepts:已接受的客户端连接总数。</li><li>handled:已处理连接的总数。通常，参数值与<code>accepts</code> 除非已达到某些资源限制（例如， <a href="http://nginx.org/en/docs/ngx_core_module.html#worker_connections" target="_blank" rel="noopener">worker_connections</a>限制）相同。</li><li>requests:客户端请求的总数。</li><li>Reading:nginx正在读取请求标头的当前连接数。</li><li>Writing:nginx将响应写回客户端的当前连接数。</li><li>Waiting:当前等待请求的空闲客户端连接数。</li></ul><p><strong>ngx_http_referer_module模块</strong><br>35. valid_referers none | blocked | server_names | string …;</p><ul><li>none 请求标头中不存在“Referer”字段;</li><li>blocked：“Referer”字段出现在请求标头中，但其值已被防火墙或代理服务器删除; 这些值是不以“ http://”或“ https://” 开头的字符串;</li><li>server_names：“Referer”请求头字段包含一个服务器名称;</li><li>arbitrary string:直接字符串，可以使用通配符</li><li>regular expression：以~起始的正则表达式</li></ul><p><strong>内置变量：$invalid_referer(所有不能符合valid_referer指令定义的引用请求均为不合法引用)</strong></p><p>实例：</p><pre><code>valid_referers none blocked server_names               *.example.com example.* www.example.org/galleries/               ~\.google\.;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构与基本命令</title>
      <link href="/posts/blog-program03.html"/>
      <url>/posts/blog-program03.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://redis.io/documentation" target="_blank" rel="noopener">官网文档</a></p><h1 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h1><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><ul><li><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p></li><li><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p></li><li><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p></li></ul><p>实例</p><pre><code>redis 127.0.0.1:6379&gt; SET name "runoob"OKredis 127.0.0.1:6379&gt; GET name"runoob"</code></pre><p>在以上实例中我们使用了 Redis 的 SET 和 GET 命令。键为 name，对应的值为 runoob。<br>注意：一个键最大能存储512MB。</p><h1 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h1><ul><li><p>Redis hash 是一个键值(key=&gt;value)对集合。</p></li><li><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p></li></ul><p>实例<br>DEL runoob 用于删除前面测试用过的 key，不然会报错：(error) WRONGTYPE Operation against a key holding the wrong kind of value</p><pre><code>redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; HMSET myhash field1 "Hello" field2 "World""OK"redis 127.0.0.1:6379&gt; HGET myhash field1"Hello"redis 127.0.0.1:6379&gt; HGET myhash field2"World"</code></pre><p>实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field=&gt;value 对, HGET 获取对应 field 对应的 value。</p><p>每个 hash 可以存储 232 -1 键值对（40多亿）。</p><h1 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h1><ul><li>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</li></ul><p>实例</p><pre><code>redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; lpush runoob redis(integer) 1redis 127.0.0.1:6379&gt; lpush runoob mongodb(integer) 2redis 127.0.0.1:6379&gt; lpush runoob rabitmq(integer) 3redis 127.0.0.1:6379&gt; lrange runoob 0 101) "rabitmq"2) "mongodb"3) "redis"redis 127.0.0.1:6379&gt;</code></pre><p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p><h1 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h1><ul><li><p>Redis的Set是string类型的无序集合。</p></li><li><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p></li></ul><p><strong>sadd 命令</strong><br>添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。</p><pre><code>sadd key member</code></pre><p>实例</p><pre><code>redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; sadd runoob redis(integer) 1redis 127.0.0.1:6379&gt; sadd runoob mongodb(integer) 1redis 127.0.0.1:6379&gt; sadd runoob rabitmq(integer) 1redis 127.0.0.1:6379&gt; sadd runoob rabitmq(integer) 0redis 127.0.0.1:6379&gt; smembers runoob1) "redis"2) "rabitmq"3) "mongodb"</code></pre><p>注意：以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。</p><p>集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。</p><h1 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h1><ul><li><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p></li><li><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p></li><li><p>zset的成员是唯一的,但分数(score)却可以重复。</p></li></ul><p><strong>zadd 命令</strong><br>添加元素到集合，元素在集合中存在则更新对应score</p><pre><code>zadd key score member </code></pre><p>实例</p><pre><code>redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; zadd runoob 0 redis(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 mongodb(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq(integer) 0redis 127.0.0.1:6379&gt; &gt; ZRANGEBYSCORE runoob 0 10001) "mongodb"2) "rabitmq"3) "redis"</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-99872bc3efe32f95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h1><p><a href="https://redis.io/commands" target="_blank" rel="noopener">官网命令大全</a></p><h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h1><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务。</li><li>命令入队。</li><li>执行事务。</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>以下是一个事务的例子， 它先以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <strong>EXEC</strong> 命令触发事务， 一并执行事务中的所有命令：</p><pre><code> MULTIOKredis 127.0.0.1:6379&gt; SET book-name "Mastering C++ in 21 days" QUEUEDredis 127.0.0.1:6379&gt; GET book-nameQUEUEDredis 127.0.0.1:6379&gt; SADD tag "C++"  "Programming"  "Mastering Series" QUEUEDredis 127.0.0.1:6379&gt; SMEMBERS tagQUEUEDredis 127.0.0.1:6379&gt; EXEC 1) OK 2)  "Mastering C++ in 21 days"  3)  (integer)  3  4)  1)  "Mastering Series"  2)  "C++"  3)  "Programming"</code></pre><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p><pre><code>&gt; **这是官网上的说明 From redis docs on [transactions](http://redis.io/topics/transactions):**&gt; &gt; It's important to note that even when a command fails, all the other commands in the queue are processed – Redis will not stop the processing of commands.</code></pre><p>比如：</p><pre><code>multiOKredis 127.0.0.1:7000&gt;  set a aaaQUEUEDredis 127.0.0.1:7000&gt;  set b bbbQUEUEDredis 127.0.0.1:7000&gt;  set c cccQUEUEDredis 127.0.0.1:7000&gt;  exec  1) OK 2) OK 3) OK</code></pre><p>如果在 set b bbb 处失败，set a 已成功不会回滚，set c 还会继续执行。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-8e69d7921e545c59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Redis总结"><a href="#Redis总结" class="headerlink" title="Redis总结"></a>Redis总结</h1><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-2bcace8f72ef86b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6ea16e5fef72a235.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cd603aac9dbd0165.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据库基础知识</title>
      <link href="/posts/blog-program02.html"/>
      <url>/posts/blog-program02.html</url>
      
        <content type="html"><![CDATA[<p>###【redis是什么】</p><p>redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。</p><p>redis的官网地址，非常好记，是redis.io。</p><p>目前，Vmware在资助着redis项目的开发和维护。</p><h3 id="【谁在使用redis】"><a href="#【谁在使用redis】" class="headerlink" title="【谁在使用redis】"></a>【谁在使用redis】</h3><p>Blizzard、digg、stackoverflow、github、flickr …</p><h3 id="【学会安装redis】"><a href="#【学会安装redis】" class="headerlink" title="【学会安装redis】"></a>【学会安装redis】</h3><p>从redis.io下载最新版redis-X.Y.Z.tar.gz后解压，然后进入redis-X.Y.Z文件夹后直接make即可，安装非常简单。</p><p>make成功后会在src文件夹下产生一些二进制可执行文件，包括redis-server、redis-cli等等：</p><pre><code>$ find . -type f -executable./redis-benchmark //用于进行redis性能测试的工具./redis-check-dump //用于修复出问题的dump.rdb文件./redis-cli //redis的客户端./redis-server //redis的服务端./redis-check-aof //用于修复出问题的AOF文件./redis-sentinel //用于集群管理</code></pre><h3 id="【学会启动redis】"><a href="#【学会启动redis】" class="headerlink" title="【学会启动redis】"></a><strong>【学会启动redis】</strong></h3><p>启动redis非常简单，直接./redis-server就可以启动服务端了，还可以用下面的方法指定要加载的配置文件：</p><p>复制代码代码如下:</p><pre><code>./redis-server ../redis.conf</code></pre><p>默认情况下，redis-server会以非daemon的方式来运行，且默认服务端口为6379。</p><h3 id="【使用redis客户端】"><a href="#【使用redis客户端】" class="headerlink" title="【使用redis客户端】"></a><strong>【使用redis客户端】</strong></h3><p>我们直接看一个例子：</p><p>复制代码代码如下:</p><pre><code>//这样来启动redis客户端了$ ./redis-cli//用set指令来设置key、value127.0.0.1:6379&gt; set name "roc" OK//来获取name的值127.0.0.1:6379&gt; get name "roc"//通过客户端来关闭redis服务端127.0.0.1:6379&gt; shutdown 127.0.0.1:6379&gt;</code></pre><h3 id="【redis数据结构-–-简介】"><a href="#【redis数据结构-–-简介】" class="headerlink" title="【redis数据结构 – 简介】"></a>【redis数据结构 – 简介】</h3><p>redis是一种高级的key:value存储系统，其中value支持五种数据类型：</p><p>1.字符串（strings）<br>2.字符串列表（lists）<br>3.字符串集合（sets）<br>4.有序字符串集合（sorted sets）<br>5.哈希（hashes）</p><p>而关于key，有几个点要提醒大家：</p><p>1.key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率；<br>2.key也不要太短，太短的话，key的可读性会降低；<br>3.在一个项目中，key最好使用统一的命名模式，例如user:10000:passwd。</p><h3 id="【redis数据结构-–-strings】"><a href="#【redis数据结构-–-strings】" class="headerlink" title="【redis数据结构 – strings】"></a><strong>【redis数据结构 – strings】</strong></h3><p>有人说，如果只使用redis中的字符串类型，且不使用redis的持久化功能，那么，redis就和memcache非常非常的像了。这说明strings类型是一个很基础的数据类型，也是任何存储系统都必备的数据类型。</p><p>我们来看一个最简单的例子：</p><p>复制代码代码如下:</p><pre><code>set mystr "hello world!" //设置字符串类型get mystr //读取字符串类型</code></pre><p>字符串类型的用法就是这么简单，因为是二进制安全的，所以你完全可以把一个图片文件的内容作为字符串来存储。</p><p>另外，我们还可以通过字符串类型进行数值操作：</p><p>复制代码代码如下:</p><pre><code>127.0.0.1:6379&gt; set mynum "2"OK127.0.0.1:6379&gt; get mynum"2"127.0.0.1:6379&gt; incr mynum(integer) 3127.0.0.1:6379&gt; get mynum"3"</code></pre><p>看，在遇到数值操作时，redis会将字符串类型转换成数值。</p><p>由于INCR等指令本身就具有原子操作的特性，所以我们完全可以利用redis的INCR、INCRBY、DECR、DECRBY等指令来实现原子计数的效果，假如，在某种场景下有3个客户端同时读取了mynum的值（值为2），然后对其同时进行了加1的操作，那么，最后mynum的值一定是5。不少网站都利用redis的这个特性来实现业务上的统计计数需求。</p><h3 id="【redis数据结构-–-lists】"><a href="#【redis数据结构-–-lists】" class="headerlink" title="【redis数据结构 – lists】"></a><strong>【redis数据结构 – lists】</strong></h3><p>redis的另一个重要的数据结构叫做lists，翻译成中文叫做“列表”。</p><p>首先要明确一点，redis中的lists在底层实现上并不是数组，而是链表，也就是说对于一个具有上百万个元素的lists来说，在头部和尾部插入一个新元素，其时间复杂度是常数级别的，比如用LPUSH在10个元素的lists头部插入新元素，和在上千万元素的lists头部插入新元素的速度应该是相同的。</p><p>虽然lists有这样的优势，但同样有其弊端，那就是，链表型lists的元素定位会比较慢，而数组型lists的元素定位就会快得多。</p><p>lists的常用操作包括LPUSH、RPUSH、LRANGE等。我们可以用LPUSH在lists的左侧插入一个新元素，用RPUSH在lists的右侧插入一个新元素，用LRANGE命令从lists中指定一个范围来提取元素。我们来看几个例子：</p><p>复制代码代码如下:</p><pre><code>//新建一个list叫做mylist，并在列表头部插入元素"1"127.0.0.1:6379&gt; lpush mylist "1" //返回当前mylist中的元素个数(integer) 1 //在mylist右侧插入元素"2"127.0.0.1:6379&gt; rpush mylist "2" (integer) 2//在mylist左侧插入元素"0"127.0.0.1:6379&gt; lpush mylist "0" (integer) 3//列出mylist中从编号0到编号1的元素127.0.0.1:6379&gt; lrange mylist 0 1 1) "0"2) "1"//列出mylist中从编号0到倒数第一个元素127.0.0.1:6379&gt; lrange mylist 0 -1 1) "0"2) "1"3) "2"</code></pre><p>lists的应用相当广泛，随便举几个例子：</p><p>1.我们可以利用lists来实现一个消息队列，而且可以确保先后顺序，不必像MySQL那样还需要通过ORDER BY来进行排序。<br>2.利用LRANGE还可以很方便的实现分页的功能。<br>3.在博客系统中，每片博文的评论也可以存入一个单独的list中。</p><h3 id="【redis数据结构-–-集合】"><a href="#【redis数据结构-–-集合】" class="headerlink" title="【redis数据结构 – 集合】"></a><strong>【redis数据结构 – 集合】</strong></h3><p>redis的集合，是一种无序的集合，集合中的元素没有先后顺序。</p><p>集合相关的操作也很丰富，如添加新元素、删除已有元素、取交集、取并集、取差集等。我们来看例子：</p><p>复制代码代码如下:</p><pre><code>//向集合myset中加入一个新元素"one"127.0.0.1:6379&gt; sadd myset "one" (integer) 1127.0.0.1:6379&gt; sadd myset "two"(integer) 1//列出集合myset中的所有元素127.0.0.1:6379&gt; smembers myset 1) "one"2) "two"//判断元素1是否在集合myset中，返回1表示存在127.0.0.1:6379&gt; sismember myset "one" (integer) 1//判断元素3是否在集合myset中，返回0表示不存在127.0.0.1:6379&gt; sismember myset "three" (integer) 0//新建一个新的集合yourset127.0.0.1:6379&gt; sadd yourset "1" (integer) 1127.0.0.1:6379&gt; sadd yourset "2"(integer) 1127.0.0.1:6379&gt; smembers yourset1) "1"2) "2"//对两个集合求并集127.0.0.1:6379&gt; sunion myset yourset 1) "1"2) "one"3) "2"4) "two"</code></pre><p>对于集合的使用，也有一些常见的方式，比如，QQ有一个社交功能叫做“好友标签”，大家可以给你的好友贴标签，比如“大美女”、“土豪”、“欧巴”等等，这时就可以使用redis的集合来实现，把每一个用户的标签都存储在一个集合之中。</p><h3 id="【redis数据结构-–-有序集合】"><a href="#【redis数据结构-–-有序集合】" class="headerlink" title="【redis数据结构 – 有序集合】"></a><strong>【redis数据结构 – 有序集合】</strong></h3><p>redis不但提供了无需集合（sets），还很体贴的提供了有序集合（sorted sets）。有序集合中的每个元素都关联一个序号（score），这便是排序的依据。</p><p>很多时候，我们都将redis中的有序集合叫做zsets，这是因为在redis中，有序集合相关的操作指令都是以z开头的，比如zrange、zadd、zrevrange、zrangebyscore等等</p><p>老规矩，我们来看几个生动的例子：<br>//新增一个有序集合myzset，并加入一个元素baidu.com，给它赋予的序号是1：</p><p>复制代码代码如下:</p><pre><code>127.0.0.1:6379&gt; zadd myzset 1 baidu.com (integer) 1//向myzset中新增一个元素360.com，赋予它的序号是3127.0.0.1:6379&gt; zadd myzset 3 360.com (integer) 1//向myzset中新增一个元素google.com，赋予它的序号是2127.0.0.1:6379&gt; zadd myzset 2 google.com (integer) 1//列出myzset的所有元素，同时列出其序号，可以看出myzset已经是有序的了。127.0.0.1:6379&gt; zrange myzset 0 -1 with scores 1) "baidu.com"2) "1"3) "google.com"4) "2"5) "360.com"6) "3"//只列出myzset的元素127.0.0.1:6379&gt; zrange myzset 0 -1 1) "baidu.com"2) "google.com"3) "360.com"</code></pre><h3 id="【redis数据结构-–-哈希】"><a href="#【redis数据结构-–-哈希】" class="headerlink" title="【redis数据结构 – 哈希】"></a><strong>【redis数据结构 – 哈希】</strong></h3><p>最后要给大家介绍的是hashes，即哈希。哈希是从redis-2.0.0版本之后才有的数据结构。</p><p>hashes存的是字符串和字符串值之间的映射，比如一个用户要存储其全名、姓氏、年龄等等，就很适合使用哈希。</p><p>我们来看一个例子：</p><p>复制代码代码如下:</p><pre><code>//建立哈希，并赋值127.0.0.1:6379&gt; HMSET user:001 username antirez password P1pp0 age 34 OK//列出哈希的内容127.0.0.1:6379&gt; HGETALL user:001 1) "username"2) "antirez"3) "password"4) "P1pp0"5) "age"6) "34"//更改哈希中的某一个值127.0.0.1:6379&gt; HSET user:001 password 12345 (integer) 0//再次列出哈希的内容127.0.0.1:6379&gt; HGETALL user:001 1) "username"2) "antirez"3) "password"4) "12345"5) "age"6) "34"</code></pre><p>有关hashes的操作，同样很丰富，需要时，大家可以从这里<a href="http://redis.io/commands#hash" target="_blank" rel="noopener">查询</a>。</p><h3 id="【聊聊redis持久化-–-两种方式】"><a href="#【聊聊redis持久化-–-两种方式】" class="headerlink" title="【聊聊redis持久化 – 两种方式】"></a>【聊聊redis持久化 – 两种方式】</h3><p>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。</p><p>RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；</p><p>AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</p><p>其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。</p><p>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</p><h3 id="【聊聊redis持久化-–-RDB】"><a href="#【聊聊redis持久化-–-RDB】" class="headerlink" title="【聊聊redis持久化 – RDB】"></a>【聊聊redis持久化 – RDB】</h3><p>RDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。</p><p>redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。</p><p>对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。</p><p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</p><p>虽然RDB有不少优点，但它的缺点也是不容忽视的。如果你对数据的完整性非常敏感，那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。所以，redis还提供了另一种持久化方式，那就是AOF。</p><h3 id="【聊聊redis持久化-–-AOF】"><a href="#【聊聊redis持久化-–-AOF】" class="headerlink" title="【聊聊redis持久化 – AOF】"></a>【聊聊redis持久化 – AOF】</h3><p>AOF，英文是Append Only File，即只允许追加不允许改写的文件。</p><p>如前面介绍的，AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单。</p><p>我们通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。</p><p>默认的AOF持久化策略是每秒钟fsync一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。</p><p>如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。</p><p>因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。举个例子或许更形象，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。</p><p>在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性，这点大家可以放心。</p><p>AOF方式的另一个好处，我们通过一个“场景再现”来说明。某同学在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，这是很悲剧的事情。不过这也不是世界末日，只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。是不是很神奇，这就是AOF持久化方式的好处之一。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了。</p><p>虽然优点多多，但AOF方式也同样存在缺陷，比如在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。</p><p>如果你直接执行BGREWRITEAOF命令，那么redis会生成一个全新的AOF文件，其中便包括了可以恢复现有数据的最少的命令集。</p><p>如果运气比较差，AOF文件出现了被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：</p><p>1.备份被写坏的AOF文件<br>2.运行redis-check-aof –fix进行修复<br>3.用diff -u来看下两个文件的差异，确认问题点<br>4.重启redis，加载修复后的AOF文件</p><h3 id="【聊聊redis持久化-–-AOF重写】"><a href="#【聊聊redis持久化-–-AOF重写】" class="headerlink" title="【聊聊redis持久化 – AOF重写】"></a>【聊聊redis持久化 – AOF重写】</h3><p>AOF重写的内部运行原理，我们有必要了解一下。</p><p>在重写即将开始之际，redis会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</p><p>与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</p><p>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。</p><p>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。</p><h3 id="【聊聊主从-–-用法】"><a href="#【聊聊主从-–-用法】" class="headerlink" title="【聊聊主从 – 用法】"></a>【聊聊主从 – 用法】</h3><p>像MySQL一样，redis是支持主从同步的，而且也支持一主多从以及多级从结构。</p><p>主从结构，一是为了纯粹的冗余备份，二是为了提升读性能，比如很消耗性能的SORT就可以由从服务器来承担。</p><p>redis的主从同步是异步进行的，这意味着主从同步不会影响主逻辑，也不会降低redis的处理性能。</p><p>主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。</p><p>在主从架构中，从服务器通常被设置为只读模式，这样可以避免从服务器的数据被误修改。但是从服务器仍然可以接受CONFIG等指令，所以还是不应该将从服务器直接暴露到不安全的网络环境中。如果必须如此，那可以考虑给重要指令进行重命名，来避免命令被外人误执行。</p><h3 id="【聊聊主从-–-同步原理】"><a href="#【聊聊主从-–-同步原理】" class="headerlink" title="【聊聊主从 – 同步原理】"></a>【聊聊主从 – 同步原理】</h3><p>从服务器会向主服务器发出SYNC指令，当主服务器接到此命令后，就会调用BGSAVE指令来创建一个子进程专门进行数据持久化工作，也就是将主服务器的数据写入RDB文件中。在数据持久化期间，主服务器将执行的写指令都缓存在内存中。</p><p>在BGSAVE指令执行完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器接到此文件后会将其存储到磁盘上，然后再将其读取到内存中。这个动作完成后，主服务器会将这段时间缓存的写指令再以redis协议的格式发送给从服务器。</p><p>另外，要说的一点是，即使有多个从服务器同时发来SYNC指令，主服务器也只会执行一次BGSAVE，然后把持久化好的RDB文件发给多个下游。在redis2.8版本之前，如果从服务器与主服务器因某些原因断开连接的话，都会进行一次主从之间的全量的数据同步；而在2.8版本之后，redis支持了效率更高的增量同步策略，这大大降低了连接断开的恢复成本。</p><p>主服务器会在内存中维护一个缓冲区，缓冲区中存储着将要发给从服务器的内容。从服务器在与主服务器出现网络瞬断之后，从服务器会尝试再次与主服务器连接，一旦连接成功，从服务器就会把“希望同步的主服务器ID”和“希望请求的数据的偏移位置（replication offset）”发送出去。主服务器接收到这样的同步请求后，首先会验证主服务器ID是否和自己的ID匹配，其次会检查“请求的偏移位置”是否存在于自己的缓冲区中，如果两者都满足的话，主服务器就会向从服务器发送增量内容。</p><p>增量同步功能，需要服务器端支持全新的PSYNC指令。这个指令，只有在redis-2.8之后才具有。</p><h3 id="【聊聊redis的事务处理】"><a href="#【聊聊redis的事务处理】" class="headerlink" title="【聊聊redis的事务处理】"></a><strong>【聊聊redis的事务处理】</strong></h3><p>众所周知，事务是指“一个完整的动作，要么全部执行，要么什么也没有做”。</p><p>在聊redis事务处理之前，要先和大家介绍四个redis指令，即MULTI、EXEC、DISCARD、WATCH。这四个指令构成了redis事务处理的基础。</p><p>1.MULTI用来组装一个事务；<br>2.EXEC用来执行一个事务；<br>3.DISCARD用来取消一个事务；<br>4.WATCH用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行。</p><p>纸上得来终觉浅，我们来看一个MULTI和EXEC的例子：</p><p>复制代码代码如下:</p><pre><code>redis&gt; MULTI //标记事务开始OKredis&gt; INCR user_id //多条命令按顺序入队QUEUEDredis&gt; INCR user_idQUEUEDredis&gt; INCR user_idQUEUEDredis&gt; PINGQUEUEDredis&gt; EXEC //执行1) (integer) 12) (integer) 23) (integer) 34) PONG</code></pre><p>在上面的例子中，我们看到了QUEUED的字样，这表示我们在用MULTI组装事务时，每一个命令都会进入到内存队列中缓存起来，如果出现QUEUED则表示我们这个命令成功插入了缓存队列，在将来执行EXEC时，这些被QUEUED的命令都会被组装成一个事务来执行。</p><p>对于事务的执行来说，如果redis开启了AOF持久化的话，那么一旦事务被成功执行，事务中的命令就会通过write命令一次性写到磁盘中去，如果在向磁盘中写的过程中恰好出现断电、硬件故障等问题，那么就可能出现只有部分命令进行了AOF持久化，这时AOF文件就会出现不完整的情况，这时，我们可以使用redis-check-aof工具来修复这一问题，这个工具会将AOF文件中不完整的信息移除，确保AOF文件完整可用。</p><p>有关事务，大家经常会遇到的是两类错误：</p><p>1.调用EXEC之前的错误<br>2.调用EXEC之后的错误</p><p>“调用EXEC之前的错误”，有可能是由于语法有误导致的，也可能时由于内存不足导致的。只要出现某个命令无法成功写入缓冲队列的情况，redis都会进行记录，在客户端调用EXEC时，redis会拒绝执行这一事务。（这时2.6.5版本之后的策略。在2.6.5之前的版本中，redis会忽略那些入队失败的命令，只执行那些入队成功的命令）。我们来看一个这样的例子：</p><p>复制代码代码如下:</p><pre><code>127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; haha //一个明显错误的指令(error) ERR unknown command 'haha'127.0.0.1:6379&gt; pingQUEUED127.0.0.1:6379&gt; exec//redis无情的拒绝了事务的执行，原因是“之前出现了错误”(error) EXECABORT Transaction discarded because of previous errors.</code></pre><p>而对于“调用EXEC之后的错误”，redis则采取了完全不同的策略，即redis不会理睬这些错误，而是继续向下执行事务中的其他命令。这是因为，对于应用层面的错误，并不是redis自身需要考虑和处理的问题，所以一个事务中如果某一条命令执行失败，并不会影响接下来的其他命令的执行。我们也来看一个例子：</p><p>复制代码代码如下:</p><pre><code>127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set age 23QUEUED//age不是集合，所以如下是一条明显错误的指令127.0.0.1:6379&gt; sadd age 15 QUEUED127.0.0.1:6379&gt; set age 29QUEUED127.0.0.1:6379&gt; exec //执行事务时，redis不会理睬第2条指令执行错误1) OK2) (error) WRONGTYPE Operation against a key holding the wrong kind of value3) OK127.0.0.1:6379&gt; get age"29" //可以看出第3条指令被成功执行了</code></pre><p>好了，我们来说说最后一个指令“WATCH”，这是一个很好用的指令，它可以帮我们实现类似于“乐观锁”的效果，即CAS（check and set）。</p><p>WATCH本身的作用是“监视key是否被改动过”，而且支持同时监视多个key，只要还没真正触发事务，WATCH都会尽职尽责的监视，一旦发现某个key被修改了，在执行EXEC时就会返回nil，表示事务无法触发。</p><p>复制代码代码如下:</p><pre><code>127.0.0.1:6379&gt; set age 23OK127.0.0.1:6379&gt; watch age //开始监视ageOK127.0.0.1:6379&gt; set age 24 //在EXEC之前，age的值被修改了OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set age 25QUEUED127.0.0.1:6379&gt; get ageQUEUED127.0.0.1:6379&gt; exec //触发EXEC(nil) //事务无法被执行</code></pre><h3 id="【看懂redis配置-–-简介】"><a href="#【看懂redis配置-–-简介】" class="headerlink" title="【看懂redis配置 – 简介】"></a><strong>【看懂redis配置 – 简介】</strong></h3><p>我们可以在启动redis-server时指定应该加载的配置文件，方法如下：</p><p>复制代码代码如下:</p><pre><code>$ ./redis-server /path/to/redis.conf</code></pre><p>接下来，我们就来讲解下redis配置文件的各个配置项的含义，注意，本文是基于redis-2.8.4版本进行讲解的。</p><p>redis官方提供的redis.conf文件，足有700+行，其中100多行为有效配置行，另外的600多行为注释说明。</p><p>在配置文件的开头部分，首先明确了一些度量单位：</p><p>复制代码代码如下:</p><pre><code># 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes</code></pre><p>可以看出，redis配置中对单位的大小写不敏感，1GB、1Gb和1gB都是相同的。由此也说明，redis只支持bytes，不支持bit单位。</p><p>redis支持“主配置文件中引入外部配置文件”，很像C/C++中的include指令，比如：</p><p>复制代码代码如下:</p><pre><code>include /path/to/other.conf</code></pre><p>如果你看过redis的配置文件，会发现还是很有条理的。redis配置文件被分成了几大块区域，它们分别是：</p><p>1.通用（general）<br>2.快照（snapshotting）<br>3.复制（replication）<br>4.安全（security）<br>5.限制（limits)<br>6.追加模式（append only mode)<br>7.LUA脚本（lua scripting)<br>8.慢日志（slow log)<br>9.事件通知（event notification）</p><p>下面我们就来逐一讲解。</p><h3 id="【看懂redis配置-通用】"><a href="#【看懂redis配置-通用】" class="headerlink" title="【看懂redis配置 -通用】"></a><strong>【看懂redis配置 -通用】</strong></h3><p>默认情况下，redis并不是以daemon形式来运行的。通过daemonize配置项可以控制redis的运行形式，如果改为yes，那么redis就会以daemon形式运行：</p><p>复制代码代码如下:</p><pre><code>daemonize no</code></pre><p>当以daemon形式运行时，redis会生成一个pid文件，默认会生成在/var/run/redis.pid。当然，你可以通过pidfile来指定pid文件生成的位置，比如：</p><p>复制代码代码如下:</p><pre><code>pidfile /path/to/redis.pid</code></pre><p>默认情况下，redis会响应本机所有可用网卡的连接请求。当然，redis允许你通过bind配置项来指定要绑定的IP，比如：</p><p>复制代码代码如下:</p><pre><code>bind 192.168.1.2 10.8.4.2</code></pre><p>redis的默认服务端口是6379，你可以通过port配置项来修改。如果端口设置为0的话，redis便不会监听端口了。</p><p>复制代码代码如下:</p><pre><code>port 6379</code></pre><p>有些同学会问“如果redis不监听端口，还怎么与外界通信呢”，其实redis还支持通过unix socket方式来接收请求。可以通过unixsocket配置项来指定unix socket文件的路径，并通过unixsocketperm来指定文件的权限。</p><p>复制代码代码如下:</p><pre><code>unixsocket /tmp/redis.sockunixsocketperm 755</code></pre><p>当一个redis-client一直没有请求发向server端，那么server端有权主动关闭这个连接，可以通过timeout来设置“空闲超时时限”，0表示永不关闭。</p><p>复制代码代码如下:</p><pre><code>timeout 0</code></pre><p>TCP连接保活策略，可以通过tcp-keepalive配置项来进行设置，单位为秒，假如设置为60秒，则server端会每60秒向连接空闲的客户端发起一次ACK请求，以检查客户端是否已经挂掉，对于无响应的客户端则会关闭其连接。所以关闭一个连接最长需要120秒的时间。如果设置为0，则不会进行保活检测。</p><p>复制代码代码如下:</p><pre><code>tcp-keepalive 0</code></pre><p>redis支持通过loglevel配置项设置日志等级，共分四级，即debug、verbose、notice、warning。</p><p>复制代码代码如下:</p><pre><code>loglevel notice</code></pre><p>redis也支持通过logfile配置项来设置日志文件的生成位置。如果设置为空字符串，则redis会将日志输出到标准输出。假如你在daemon情况下将日志设置为输出到标准输出，则日志会被写到/dev/null中。</p><p>复制代码代码如下:</p><pre><code>logfile ""</code></pre><p>如果希望日志打印到syslog中，也很容易，通过syslog-enabled来控制。另外，syslog-ident还可以让你指定syslog里的日志标志，比如：</p><p>复制代码代码如下:</p><pre><code>syslog-ident redis</code></pre><p>而且还支持指定syslog设备，值可以是USER或LOCAL0-LOCAL7。具体可以参考syslog服务本身的用法。</p><p>复制代码代码如下:</p><pre><code>syslog-facility local0</code></pre><p>对于redis来说，可以设置其数据库的总数量，假如你希望一个redis包含16个数据库，那么设置如下：</p><p>复制代码代码如下:</p><pre><code>databases 16</code></pre><p>这16个数据库的编号将是0到15。默认的数据库是编号为0的数据库。用户可以使用select <dbid>来选择相应的数据库。</dbid></p><h3 id="【看懂redis配置-–-快照】"><a href="#【看懂redis配置-–-快照】" class="headerlink" title="【看懂redis配置 – 快照】"></a><strong>【看懂redis配置 – 快照】</strong></h3><p>快照，主要涉及的是redis的RDB持久化相关的配置，我们来一起看一看。</p><p>我们可以用如下的指令来让数据保存到磁盘上，即控制RDB快照功能：</p><p>复制代码代码如下:</p><pre><code>save &lt;seconds&gt; &lt;changes&gt;</code></pre><p>举例来说：</p><p>复制代码代码如下:</p><pre><code>save 900 1 //表示每15分钟且至少有1个key改变，就触发一次持久化save 300 10 //表示每5分钟且至少有10个key改变，就触发一次持久化save 60 10000 //表示每60秒至少有10000个key改变，就触发一次持久化</code></pre><p>如果你想禁用RDB持久化的策略，只要不设置任何save指令就可以，或者给save传入一个空字符串参数也可以达到相同效果，就像这样：</p><p>复制代码代码如下:</p><pre><code>save ""</code></pre><p>如果用户开启了RDB快照功能，那么在redis持久化数据到磁盘时如果出现失败，默认情况下，redis会停止接受所有的写请求。这样做的好处在于可以让用户很明确的知道内存中的数据和磁盘上的数据已经存在不一致了。如果redis不顾这种不一致，一意孤行的继续接收写请求，就可能会引起一些灾难性的后果。</p><p>如果下一次RDB持久化成功，redis会自动恢复接受写请求。</p><p>当然，如果你不在乎这种数据不一致或者有其他的手段发现和控制这种不一致的话，你完全可以关闭这个功能，以便在快照写入失败时，也能确保redis继续接受新的写请求。配置项如下：</p><p>复制代码代码如下:</p><pre><code>stop-writes-on-bgsave-error yes</code></pre><p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</p><p>复制代码代码如下:</p><pre><code>rdbcompression yes</code></pre><p>在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果你希望获取到最大的性能提升，可以关闭此功能。</p><p>复制代码代码如下:</p><pre><code>rdbchecksum yes</code></pre><p>我们还可以设置快照文件的名称，默认是这样配置的：</p><p>复制代码代码如下:</p><pre><code>dbfilename dump.rdb</code></pre><p>最后，你还可以设置这个快照文件存放的路径。比如默认设置就是当前文件夹：</p><p>复制代码代码如下:</p><pre><code>dir ./</code></pre><h3 id="【看懂redis配置-–-复制】"><a href="#【看懂redis配置-–-复制】" class="headerlink" title="【看懂redis配置 – 复制】"></a><strong>【看懂redis配置 – 复制】</strong></h3><p>redis提供了主从同步功能。</p><p>通过slaveof配置项可以控制某一个redis作为另一个redis的从服务器，通过指定IP和端口来定位到主redis的位置。一般情况下，我们会建议用户为从redis设置一个不同频率的快照持久化的周期，或者为从redis配置一个不同的服务端口等等。</p><p>复制代码代码如下:</p><pre><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></pre><p>如果主redis设置了验证密码的话（使用requirepass来设置），则在从redis的配置中要使用masterauth来设置校验密码，否则的话，主redis会拒绝从redis的访问请求。</p><p>复制代码代码如下:</p><pre><code>masterauth &lt;master-password&gt;</code></pre><p>当从redis失去了与主redis的连接，或者主从同步正在进行中时，redis该如何处理外部发来的访问请求呢？这里，从redis可以有两种选择：</p><p>第一种选择：如果slave-serve-stale-data设置为yes（默认），则从redis仍会继续响应客户端的读写请求。</p><p>第二种选择：如果slave-serve-stale-data设置为no，则从redis会对客户端的请求返回“SYNC with master in progress”，当然也有例外，当客户端发来INFO请求和SLAVEOF请求，从redis还是会进行处理。</p><p>你可以控制一个从redis是否可以接受写请求。将数据直接写入从redis，一般只适用于那些生命周期非常短的数据，因为在主从同步时，这些临时数据就会被清理掉。自从redis2.6版本之后，默认从redis为只读。</p><p>复制代码代码如下:</p><pre><code>slave-read-only yes</code></pre><p>只读的从redis并不适合直接暴露给不可信的客户端。为了尽量降低风险，可以使用rename-command指令来将一些可能有破坏力的命令重命名，避免外部直接调用。比如：</p><p>复制代码代码如下:</p><pre><code>rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</code></pre><p>从redis会周期性的向主redis发出PING包。你可以通过repl_ping_slave_period指令来控制其周期。默认是10秒。</p><p>复制代码代码如下:</p><pre><code>repl-ping-slave-period 10</code></pre><p>在主从同步时，可能在这些情况下会有超时发生：</p><p>1.以从redis的角度来看，当有大规模IO传输时。<br>2.以从redis的角度来看，当数据传输或PING时，主redis超时<br>3.以主redis的角度来看，在回复从redis的PING时，从redis超时</p><p>用户可以设置上述超时的时限，不过要确保这个时限比repl-ping-slave-period的值要大，否则每次主redis都会认为从redis超时。</p><p>复制代码代码如下:</p><pre><code>repl-timeout 60</code></pre><p>我们可以控制在主从同步时是否禁用TCP_NODELAY。如果开启TCP_NODELAY，那么主redis会使用更少的TCP包和更少的带宽来向从redis传输数据。但是这可能会增加一些同步的延迟，大概会达到40毫秒左右。如果你关闭了TCP_NODELAY，那么数据同步的延迟时间会降低，但是会消耗更多的带宽。（如果你不了解TCP_NODELAY，可以到这里来科普一下）。</p><p>复制代码代码如下:</p><pre><code>repl-disable-tcp-nodelay no</code></pre><p>我们还可以设置同步队列长度。队列长度（backlog)是主redis中的一个缓冲区，在与从redis断开连接期间，主redis会用这个缓冲区来缓存应该发给从redis的数据。这样的话，当从redis重新连接上之后，就不必重新全量同步数据，只需要同步这部分增量数据即可。</p><p>复制代码代码如下:</p><pre><code>repl-backlog-size 1mb</code></pre><p>如果主redis等了一段时间之后，还是无法连接到从redis，那么缓冲队列中的数据将被清理掉。我们可以设置主redis要等待的时间长度。如果设置为0，则表示永远不清理。默认是1个小时。</p><p>复制代码代码如下:</p><pre><code>repl-backlog-ttl 3600</code></pre><p>我们可以给众多的从redis设置优先级，在主redis持续工作不正常的情况，优先级高的从redis将会升级为主redis。而编号越小，优先级越高。比如一个主redis有三个从redis，优先级编号分别为10、100、25，那么编号为10的从redis将会被首先选中升级为主redis。当优先级被设置为0时，这个从redis将永远也不会被选中。默认的优先级为100。</p><p>复制代码代码如下:</p><pre><code>slave-priority 100</code></pre><p>假如主redis发现有超过M个从redis的连接延时大于N秒，那么主redis就停止接受外来的写请求。这是因为从redis一般会每秒钟都向主redis发出PING，而主redis会记录每一个从redis最近一次发来PING的时间点，所以主redis能够了解每一个从redis的运行情况。</p><p>复制代码代码如下:</p><pre><code>min-slaves-to-write 3min-slaves-max-lag 10</code></pre><p>上面这个例子表示，假如有大于等于3个从redis的连接延迟大于10秒，那么主redis就不再接受外部的写请求。上述两个配置中有一个被置为0，则这个特性将被关闭。默认情况下min-slaves-to-write为0，而min-slaves-max-lag为10。</p><h3 id="【看懂redis配置-–-安全】"><a href="#【看懂redis配置-–-安全】" class="headerlink" title="【看懂redis配置 – 安全】"></a><strong>【看懂redis配置 – 安全】</strong></h3><p>我们可以要求redis客户端在向redis-server发送请求之前，先进行密码验证。当你的redis-server处于一个不太可信的网络环境中时，相信你会用上这个功能。由于redis性能非常高，所以每秒钟可以完成多达15万次的密码尝试，所以你最好设置一个足够复杂的密码，否则很容易被黑客破解。</p><p>复制代码代码如下:</p><pre><code>requirepass zhimakaimen</code></pre><p>这里我们通过requirepass将密码设置成“芝麻开门”。</p><p>redis允许我们对redis指令进行更名，比如将一些比较危险的命令改个名字，避免被误执行。比如可以把CONFIG命令改成一个很复杂的名字，这样可以避免外部的调用，同时还可以满足内部调用的需要：</p><p>复制代码代码如下:</p><pre><code>rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c89</code></pre><p>我们甚至可以禁用掉CONFIG命令，那就是把CONFIG的名字改成一个空字符串：</p><p>复制代码代码如下:</p><pre><code>rename-command CONFIG ""</code></pre><p>但需要注意的是，如果你使用AOF方式进行数据持久化，或者需要与从redis进行通信，那么更改指令的名字可能会引起一些问题。</p><h3 id="【看懂redis配置-限制】"><a href="#【看懂redis配置-限制】" class="headerlink" title="【看懂redis配置 -限制】"></a><strong>【看懂redis配置 -限制】</strong></h3><p>我们可以设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。当你无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自身内部处理逻辑留一些句柄出来。</p><p>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p><p>复制代码代码如下:</p><pre><code>maxclients 10000</code></pre><p>我们甚至可以设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</p><p>如果redis无法根据移除规则来移除内存中的数据，或者我们设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。但是对于无内存申请的指令，仍然会正常响应，比如GET等。</p><p>复制代码代码如下:</p><pre><code>maxmemory &lt;bytes&gt;</code></pre><p>需要注意的一点是，如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p><p>对于内存移除规则来说，redis提供了多达6种的移除规则。他们是：</p><pre><code>1.volatile-lru：使用LRU算法移除过期集合中的key2.allkeys-lru：使用LRU算法移除key3.volatile-random：在过期集合中移除随机的key4.allkeys-random：移除随机的key5.volatile-ttl：移除那些TTL值最小的key，即那些最近才过期的key。6.noeviction：不进行移除。针对写操作，只是返回错误信息。</code></pre><p>无论使用上述哪一种移除规则，如果没有合适的key可以移除的话，redis都会针对写请求返回错误信息。</p><p>复制代码代码如下:</p><pre><code>maxmemory-policy volatile-lru</code></pre><p>LRU算法和最小TTL算法都并非是精确的算法，而是估算值。所以你可以设置样本的大小。假如redis默认会检查三个key并选择其中LRU的那个，那么你可以改变这个key样本的数量。</p><p>复制代码代码如下:</p><pre><code>maxmemory-samples 3</code></pre><p>最后，我们补充一个信息，那就是到目前版本（2.8.4）为止，redis支持的写指令包括了如下这些：</p><p>复制代码代码如下:</p><pre><code>set setnx setex appendincr decr rpush lpush rpushx lpushx linsert lset rpoplpush saddsinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrbyzunionstore zinterstore hset hsetnx hmset hincrby incrby decrbygetset mset msetnx exec sort</code></pre><h3 id="【看懂redis配置-–-追加模式】"><a href="#【看懂redis配置-–-追加模式】" class="headerlink" title="【看懂redis配置 – 追加模式】"></a><strong>【看懂redis配置 – 追加模式】</strong></h3><p>默认情况下，redis会异步的将数据持久化到磁盘。这种模式在大部分应用程序中已被验证是很有效的，但是在一些问题发生时，比如断电，则这种机制可能会导致数分钟的写请求丢失。</p><p>如博文上半部分中介绍的，追加文件（Append Only File）是一种更好的保持数据一致性的方式。即使当服务器断电时，也仅会有1秒钟的写请求丢失，当redis进程出现问题且操作系统运行正常时，甚至只会丢失一条写请求。</p><p>我们建议大家，AOF机制和RDB机制可以同时使用，不会有任何冲突。对于如何保持数据一致性的讨论，请参见<a href="http://redis.io/topics/persistence" target="_blank" rel="noopener">本文</a>。</p><p>复制代码代码如下:</p><pre><code>appendonly no</code></pre><p>我们还可以设置aof文件的名称：</p><p>复制代码代码如下:</p><pre><code>appendfilename "appendonly.aof"</code></pre><p>fsync()调用，用来告诉操作系统立即将缓存的指令写入磁盘。一些操作系统会“立即”进行，而另外一些操作系统则会“尽快”进行。</p><p>redis支持三种不同的模式：</p><p>1.no：不调用fsync()。而是让操作系统自行决定sync的时间。这种模式下，redis的性能会最快。<br>2.always：在每次写请求后都调用fsync()。这种模式下，redis会相对较慢，但数据最安全。<br>3.everysec：每秒钟调用一次fsync()。这是性能和安全的折衷。</p><p>默认情况下为everysec。有关数据一致性的揭秘，可以参考<a href="http://antirez.com/post/redis-persistence-demystified.html" target="_blank" rel="noopener">本文</a>。</p><p>复制代码代码如下:</p><pre><code>appendfsync everysec</code></pre><p>当fsync方式设置为always或everysec时，如果后台持久化进程需要执行一个很大的磁盘IO操作，那么redis可能会在fsync()调用时卡住。目前尚未修复这个问题，这是因为即使我们在另一个新的线程中去执行fsync()，也会阻塞住同步写调用。</p><p>为了缓解这个问题，我们可以使用下面的配置项，这样的话，当BGSAVE或BGWRITEAOF运行时，fsync()在主进程中的调用会被阻止。这意味着当另一路进程正在对AOF文件进行重构时，redis的持久化功能就失效了，就好像我们设置了“appendsync none”一样。如果你的redis有时延问题，那么请将下面的选项设置为yes。否则请保持no，因为这是保证数据完整性的最安全的选择。</p><p>复制代码代码如下:</p><pre><code>no-appendfsync-on-rewrite no</code></pre><p>我们允许redis自动重写aof。当aof增长到一定规模时，redis会隐式调用BGREWRITEAOF来重写log文件，以缩减文件体积。</p><p>redis是这样工作的：redis会记录上次重写时的aof大小。假如redis自启动至今还没有进行过重写，那么启动时aof文件的大小会被作为基准值。这个基准值会和当前的aof大小进行比较。如果当前aof大小超出所设置的增长比例，则会触发重写。另外，你还需要设置一个最小大小，是为了防止在aof很小时就触发重写。</p><p>复制代码代码如下:</p><pre><code>auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb</code></pre><p>如果设置auto-aof-rewrite-percentage为0，则会关闭此重写功能。</p><h3 id="【看懂redis配置-–-LUA脚本】"><a href="#【看懂redis配置-–-LUA脚本】" class="headerlink" title="【看懂redis配置 – LUA脚本】"></a><strong>【看懂redis配置 – LUA脚本】</strong></h3><p>lua脚本的最大运行时间是需要被严格限制的，要注意单位是毫秒：</p><p>复制代码代码如下:</p><pre><code>lua-time-limit 5000</code></pre><p>如果此值设置为0或负数，则既不会有报错也不会有时间限制。</p><h3 id="【看懂redis配置-–-慢日志】"><a href="#【看懂redis配置-–-慢日志】" class="headerlink" title="【看懂redis配置 – 慢日志】"></a><strong>【看懂redis配置 – 慢日志】</strong></h3><p>redis慢日志是指一个系统进行日志查询超过了指定的时长。这个时长不包括IO操作，比如与客户端的交互、发送响应内容等，而仅包括实际执行查询命令的时间。</p><p>针对慢日志，你可以设置两个参数，一个是执行时长，单位是微秒，另一个是慢日志的长度。当一个新的命令被写入日志时，最老的一条会从命令日志队列中被移除。</p><p>单位是微秒，即1000000表示一秒。负数则会禁用慢日志功能，而0则表示强制记录每一个命令。</p><p>复制代码代码如下:</p><pre><code>slowlog-log-slower-than 10000</code></pre><p>慢日志最大长度，可以随便填写数值，没有上限，但要注意它会消耗内存。你可以使用SLOWLOG RESET来重设这个值。</p><p>复制代码代码如下:</p><pre><code>slowlog-max-len 128</code></pre><h3 id="【教你看懂redis配置-–-事件通知】"><a href="#【教你看懂redis配置-–-事件通知】" class="headerlink" title="【教你看懂redis配置 – 事件通知】"></a><strong>【教你看懂redis配置 – 事件通知】</strong></h3><p>redis可以向客户端通知某些事件的发生。这个特性的具体解释可以参见<a href="http://redis.io/topics/keyspace-events" target="_blank" rel="noopener">本文</a>。</p><h3 id="【教你看懂redis配置-–-高级配置】"><a href="#【教你看懂redis配置-–-高级配置】" class="headerlink" title="【教你看懂redis配置 – 高级配置】"></a><strong>【教你看懂redis配置 – 高级配置】</strong></h3><p>有关哈希数据结构的一些配置项：</p><p>复制代码代码如下:</p><pre><code>hash-max-ziplist-entries 512hash-max-ziplist-value 64</code></pre><p>有关列表数据结构的一些配置项：</p><p>复制代码代码如下:</p><pre><code>list-max-ziplist-entries 512list-max-ziplist-value 64</code></pre><p>有关集合数据结构的配置项：</p><p>复制代码代码如下:</p><pre><code>set-max-intset-entries 512</code></pre><p>有关有序集合数据结构的配置项：</p><p>复制代码代码如下:</p><pre><code>zset-max-ziplist-entries 128zset-max-ziplist-value 64</code></pre><p>关于是否需要再哈希的配置项：</p><p>复制代码代码如下:</p><pre><code>activerehashing yes</code></pre><p>关于客户端输出缓冲的控制项：</p><p>复制代码代码如下:</p><pre><code>client-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60</code></pre><p>有关频率的配置项：</p><p>复制代码代码如下:</p><pre><code>hz 10</code></pre><p>有关重写aof的配置项</p><p>复制代码代码如下:</p><pre><code>aof-rewrite-incremental-fsync yes</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis安装与配置</title>
      <link href="/posts/blog-program01.html"/>
      <url>/posts/blog-program01.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h1><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h1 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h1><ul><li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><p><strong>Redis与其他key-value存储有什么不同？</strong><br>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</p><p>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p><h1 id="Redis的安装和部署"><a href="#Redis的安装和部署" class="headerlink" title="Redis的安装和部署"></a>Redis的安装和部署</h1><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>1、Redis的数据类型：</p><p>　　字符串、列表（lists）、集合（sets）、有序集合（sorts sets）、哈希表（hashs）</p><p>2、Redis和memcache相比的独特之处：</p><p>　　（1）redis可以用来做存储（storge）、而memcache是来做缓存（cache）。这个特点主要是因为其有“持久化”功能</p><p>　　（2）存储的数据有“结构”，对于memcache来说，存储的数据，只有一种类型——“字符串”，而redis则可以存储字符串、链表、集合、有序集合、哈序结构</p><p>3、持久化的两种方式：</p><p>　　Redis将数据存储于内存中，或被配置为使用虚拟内存。</p><p>　　实现数据持久化的两种方式：（1）使用截图的方式，将内存中的数据不断写入磁盘（性能高，但可能会引起一定程度的数据丢失）</p><p>　　　　　　　　　　　　　　　（2）使用类似mysql的方式，记录每次更新的日志</p><p>4、Redis的主从同步：对提高读取性能非常有益</p><p>5、Redis服务端的默认端口是6379</p><h3 id="Linux下安装Redis"><a href="#Linux下安装Redis" class="headerlink" title="Linux下安装Redis"></a>Linux下安装Redis</h3><p>1、先到Redis官网(redis.io)下载redis安装包 </p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-2ecb3feb9e901ed2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>2、将其下载到我的/lamp目录下</p><p>3、解压并进入其目录</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-4ca5b66a7f66c982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>4、编译源程序</p><p>　　make </p><p>　　cd src</p><p>　　make install PREFIX=/usr/local/redis</p><p>5、将配置文件移动到redis目录 </p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-29e9773b382d4062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>6、启动redis服务</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-74252ac88aec7fb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>7、默认情况，Redis不是在后台运行，我们需要把redis放在后台运行</p><p>vim /usr/local/redis/etc/redis.conf </p><p>　　将daemonize的值改为yes</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-454aa911b9af288a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>8、客户端连接</p><p>　　/usr/local/redis/bin/redis-cli </p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-71e41c5b55a58858.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>9、停止redis实例</p><p>　　/usr/local/redis/bin/redis-cli shutdown</p><p>　　或者</p><p>　　pkill redis-server</p><p>10、让redis开机自启</p><p>　　vim /etc/rc.local</p><p>　　加入</p><p>　　/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis-conf</p><p>11、接下来我们看看/usr/local/redis/bin目录下的几个文件时什么</p><p>　　redis-benchmark：redis性能测试工具</p><p>　　redis-check-aof：检查aof日志的工具</p><p>　　redis-check-dump：检查rdb日志的工具</p><p>　　redis-cli：连接用的客户端</p><p>　　redis-server：redis服务进程</p><h3 id="Ubuntu下安装"><a href="#Ubuntu下安装" class="headerlink" title="Ubuntu下安装"></a>Ubuntu下安装</h3><pre><code> sudo apt-get install redis-server</code></pre><h3 id="Redis的配置"><a href="#Redis的配置" class="headerlink" title="Redis的配置"></a>Redis的配置</h3><p>daemonize：如需要在后台运行，把该项的值改为yes</p><p>　　pdifile：把pid文件放在/var/run/redis.pid，可以配置到其他地址</p><p>　　bind：指定redis只接收来自该IP的请求，如果不设置，那么将处理所有请求，在生产环节中最好设置该项</p><p>　　port：监听端口，默认为6379</p><p>　　timeout：设置客户端连接时的超时时间，单位为秒</p><p>　　loglevel：等级分为4级，debug，revbose，notice和warning。生产环境下一般开启notice</p><p>　　logfile：配置log文件地址，默认使用标准输出，即打印在命令行终端的端口上</p><p>　　database：设置数据库的个数，默认使用的数据库是0</p><p>　　save：设置redis进行数据库镜像的频率</p><p>　　rdbcompression：在进行镜像备份时，是否进行压缩</p><p>　　dbfilename：镜像备份文件的文件名</p><p>　　dir：数据库镜像备份的文件放置的路径</p><p>　　slaveof：设置该数据库为其他数据库的从数据库</p><p>　　masterauth：当主数据库连接需要密码验证时，在这里设定</p><p>　　requirepass：设置客户端连接后进行任何其他指定前需要使用的密码</p><p>　　maxclients：限制同时连接的客户端数量</p><p>　　maxmemory：设置redis能够使用的最大内存</p><p>　　appendonly：开启appendonly模式后，redis会把每一次所接收到的写操作都追加到appendonly.aof文件中，当redis重新启动时，会从该文件恢复出之前的状态</p><p>　　appendfsync：设置appendonly.aof文件进行同步的频率</p><p>　　vm_enabled：是否开启虚拟内存支持</p><p>　　vm_swap_file：设置虚拟内存的交换文件的路径</p><p>　　vm_max_momery：设置开启虚拟内存后，redis将使用的最大物理内存的大小，默认为0</p><p>　　vm_page_size：设置虚拟内存页的大小</p><p>　　vm_pages：设置交换文件的总的page数量</p><p>　　vm_max_thrrads：设置vm IO同时使用的线程数量</p><h3 id="安装目录内容详解"><a href="#安装目录内容详解" class="headerlink" title="安装目录内容详解"></a>安装目录内容详解</h3><p>查看redis安装目录(Yum安装)：</p><pre><code>rpm -ql redis</code></pre><p>之后系统打印输出下面28个文件记录：</p><pre><code>/etc/logrotate.d/redis /etc/redis-sentinel.conf /etc/redis.conf /etc/systemd/system/redis-sentinel.service.d /etc/systemd/system/redis-sentinel.service.d/limit.conf /etc/systemd/system/redis.service.d /etc/systemd/system/redis.service.d/limit.conf /usr/bin/redis-benchmark /usr/bin/redis-check-aof /usr/bin/redis-check-rdb /usr/bin/redis-cli /usr/bin/redis-sentinel /usr/bin/redis-server /usr/bin/redis-shutdown /usr/lib/systemd/system/redis-sentinel.service /usr/lib/systemd/system/redis.service /usr/lib/tmpfiles.d/redis.conf /usr/share/doc/redis-3.2.3 /usr/share/doc/redis-3.2.3/00-RELEASENOTES /usr/share/doc/redis-3.2.3/BUGS /usr/share/doc/redis-3.2.3/CONTRIBUTING /usr/share/doc/redis-3.2.3/MANIFESTO /usr/share/doc/redis-3.2.3/README.md /usr/share/licenses/redis-3.2.3 /usr/share/licenses/redis-3.2.3/COPYING /var/lib/redis /var/log/redis /var/run/redis</code></pre><p>文件记录含义解析：</p><pre><code>/etc/logrotate.d/redis</code></pre><blockquote><p>/etc/logrotate.d/ ： 用来存储文件日志文件的轮循(切割转储)设置，（logrotate 程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件，我们把它叫做“转储”。我们可以根据日志文件的大小，也可以根据其天数来转储，这个过程一般通过 cron 程序来执行。<br>logrotate 程序还可以用于压缩日志文件，以及发送日志到指定的E-mail 。）<br>/etc/logrotate.d/文件夹下的redis文件，也就是设置了redis的日志文件的轮循参数配置文件。</p></blockquote><pre><code>[root@aidev02 logrotate.d]# cat redis /var/log/redis/*.log { weekly rotate 10 copytruncate delaycompress compress notifempty missingok } 解析 : weekly : 指定所有的日志文件每周转储一次。 rotate 10 : 指定转储文件保存10份 copytruncate ：用于还在打开中的日志文件，把当前日志备份并截断. delaycompress：和 compress 一起使用时，转储的日志文件到下一次转储时才压缩。 compress：指定压缩转储文件,通过gzip 压缩转储以后的日志，如果不需要压缩，添加注释就可以了 #compress。 notifempty：如果是空文件的话，不转储 missingok：如果日志文件不存在,继续处理下一个文件而不产生报错信息.</code></pre><pre><code>/etc/redis-sentinel.conf</code></pre><blockquote><p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务.</p><blockquote><p>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。<br>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。<br>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。<br>Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</p></blockquote></blockquote><pre><code>/etc/redis.conf</code></pre><blockquote><p>redis的配置信息文件，里面包含redis的host/ip设置、集群设置、日志设置、数据持久化配置等信息。<br>可以通过命令redis-server redis.conf 指定redis配置来启动redis。</p></blockquote><pre><code>/etc/systemd/system/redis-sentinel.service.d</code></pre><blockquote><p>redis-sentinel.service.d是用来存储redis-sentinel在系统服务中相关设置的文件夹。<br>Systemd 是 Linux 系统中最新的初始化系统（init），它主要的设计目标是克服 sysvinit 固有的缺点，提高系统的启动速度Systemd 的很多概念来源于苹果 Mac OS 操作系统上的 launchd。<br>systemd单元文件可以从两个地方加载，优先级从低到高分别是：/usr/lib/systemd/system/: 软件包安装的单元，/etc/systemd/system/ 系统管理员安装的单元。<br>当systemd运行在用户模式下时，使用的加载路径是完全不同的。</p></blockquote><pre><code>/etc/systemd/system/redis-sentinel.service.d/limit.conf</code></pre><blockquote><p>limit.conf 文件是 Linux PAM（插入式认证模块，Pluggable Authentication Modules）中 pam_limits.so 的配置文件，而且只针对于单个会话。<br>cat lomit.conf<br>—– #If you need to change max open file limit. for example, when you change maxclient in configuration, you can change the LimitNOFILE value below, see “man systemd.exec” for information<br>[Service]<br>LimitNOFILE=10240<br>Group=groupName </p></blockquote><pre><code>/etc/systemd/system/redis.service.d</code></pre><blockquote><p>redis.service.d是用来存储redis在系统服务中相关设置的文件夹。</p></blockquote><pre><code>/etc/systemd/system/redis.service.d/limit.conf</code></pre><blockquote><p>和上面/etc/systemd/system/redis-sentinel.service.d/limit.conf配置一样。</p></blockquote><pre><code>/usr/bin/redis-benchmark</code></pre><blockquote><p>redis-benchmark为Redis性能测试工具。 </p><blockquote><p>/usr/bin存放的是一些用户命令， 是你在后期安装的一些软件的运行脚本。<br>/usr/sbin 放置一些用户安装的系统管理的必备程式.<br>/bin,/sbin目录是在系统启动后挂载到根文件系统中的。<br>系统级的组件放在/bin、/lib；<br>根用户才能访问的放在/sbin；<br>系统repository提供的应用程序放在/usr/bin、/usr/lib；<br>用户自己编译的放在/usr/local/XXX。</p></blockquote></blockquote><pre><code>/usr/bin/redis-check-aof</code></pre><p>数据持久化时，用于修复出问题的AOF文件</p><pre><code>/usr/bin/redis-check-rdb</code></pre><p>用于修复出问题的dump.rdb文件</p><pre><code>/usr/bin/redis-cli</code></pre><p>redis的客户端</p><pre><code>/usr/bin/redis-sentinel</code></pre><p>用于集群管理</p><pre><code>/usr/bin/redis-server</code></pre><p>redis的服务端</p><pre><code>/usr/bin/redis-shutdown</code></pre><p>停止所有客户端，进行保存，清空所有追加仅文件(如果AOF启用)，并退出服务器。<br>错误时答复简单字符串。成功时不返回任何结果，因为服务器退出并关闭连接。</p><pre><code>/usr/lib/systemd/system/redis-sentinel.service</code></pre><blockquote><p>/usr/lib/ 程序或子系统的不变的数据文件，包括一些site-wide配置文件.名字lib来源于库(library); 编程的原始库存在/usr/lib 里.<br>/usr/lib/systemd/system/ 文件夹存储 创建单位用的系统配置文件。<br>redis-sentinel.service系统服务配置文件。<br>如下：<br>[Unit]<br>Description=Redis Sentinel<br>After=network.target<br>[Service]<br>ExecStart=/usr/bin/redis-sentinel /etc/redis-sentinel.conf –daemonize no<br>ExecStop=/usr/bin/redis-shutdown redis-sentinel<br>User=redis<br>Group=redis<br>[Install]<br>WantedBy=multi-user.target</p></blockquote><pre><code>/usr/lib/systemd/system/redis.service</code></pre><blockquote><p>同上：<br>[Unit]<br>Description=Redis persistent key-value database<br>After=network.target<br>[Service]<br>ExecStart=/usr/bin/redis-server /etc/redis.conf –daemonize no<br>ExecStop=/usr/bin/redis-shutdown<br>User=redis<br>Group=redis<br>[Install]<br>WantedBy=multi-user.target</p></blockquote><pre><code>/usr/lib/tmpfiles.d/redis.conf </code></pre><blockquote><p>/etc/tmpfiles.d/<em>.conf<br>/run/tmpfiles.d/</em>.conf<br>/usr/lib/tmpfiles.d/*.conf<br>systemd-tmpfiles 使用上述三个目录中的配置文件 来决定如何创建、删除、清理 易变文件与临时文件以及易变目录与临时目录。<br>这些文件与目录通常位于 /run, /var/run(指向 /run 的软连接), /tmp, /var/tmp, /sys, /proc, /var 目录中。<br>系统的守护进程经常需要在 /run 目录下拥有专属的运行时目录，以存放套接字或管道之类的文件<br>.#redis runtime directory<br>d /run/redis 0755 redis redis - </p></blockquote><blockquote><blockquote><p>配置文件的格式是每行对应一个路径，包含下面字段：具体可参考[ <a href="http://www.jinbuguo.com/systemd/tmpfiles.d.html" target="_blank" rel="noopener">http://www.jinbuguo.com/systemd/tmpfiles.d.html</a> ]<br>| 类型 | 路径 | 权限 | 属主 | 属组 | 寿命 | 参数|<br>|Type | Path | Mode | UID | GID | Age | Argument|<br>d /run/user 0755 root root 10d -<br>L /tmp/foobar - - - - /dev/null</p></blockquote></blockquote><pre><code>/usr/share/doc/redis-3.2.3</code></pre><p>/usr/share/放置共享文件的地方</p><pre><code>/usr/share/doc/redis-3.2.3/00-RELEASENOTES</code></pre><p>版本说明</p><pre><code>/usr/share/doc/redis-3.2.3/BUGS</code></pre><p>bugs</p><pre><code>/usr/share/doc/redis-3.2.3/CONTRIBUTING</code></pre><p>github上code捐献信息</p><pre><code>/usr/share/doc/redis-3.2.3/MANIFESTO</code></pre><p>声明</p><pre><code>/usr/share/doc/redis-3.2.3/README.md</code></pre><p>readme文件</p><pre><code>/usr/share/licenses/redis-3.2.3</code></pre><p>存放redis的许可文件</p><pre><code>/usr/share/licenses/redis-3.2.3/COPYING</code></pre><p>redis的许可文件COPYING</p><pre><code>/var/lib/redis</code></pre><p>/var/lib文件夹 存储 系统正常运行时要改变的文件</p><pre><code>指定redis本地数据库存放目录</code></pre><p>[root@aidev02 redis-3.2.3]# cd /var/lib/redis<br>[root@aidev02 redis]# ls<br>dump.rdb</p><pre><code>/var/log/redis</code></pre><p>/var/log 文件夹 ：各种程序的Log文件，特别是login (/var/log/wtmp log所有到系统的登录和注销) 和syslog (/var/log/messages 里存储所有核心和系统程序信息. /var/log 里的文件经常不确定地增长，应该定期清除.</p><p>指定redis本地日志存放目录</p><pre><code>/var/run/redis</code></pre><p>/var/run/文件夹 ： 保存到下次引导前有效的关于系统的信息文件.例如， /var/run/utmp 包含当前登录的用户的信息.</p><p>指定redis引导信息的存放目录</p><h1 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h1><pre><code># redis 配置文件示例# 当你需要为某个配置项指定内存大小的时候，必须要带上单位，# 通常的格式就是 1k 5gb 4m 等酱紫：## 1k  =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m  =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g  =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## 单位是不区分大小写的，你写 1K 5GB 4M 也行################################## INCLUDES #################################### 假如说你有一个可用于所有的 redis server 的标准配置模板，# 但针对某些 server 又需要一些个性化的设置，# 你可以使用 include 来包含一些其他的配置文件，这对你来说是非常有用的。## 但是要注意哦，include 是不能被 config rewrite 命令改写的# 由于 redis 总是以最后的加工线作为一个配置指令值，所以你最好是把 include 放在这个文件的最前面，# 以避免在运行时覆盖配置的改变，相反，你就把它放在后面（外国人真啰嗦）。## include /path/to/local.conf# include /path/to/other.conf################################ 常用 ###################################### 默认情况下 redis 不是作为守护进程运行的，如果你想让它在后台运行，你就把它改成 yes。# 当redis作为守护进程运行的时候，它会写一个 pid 到 /var/run/redis.pid 文件里面。daemonize no# 当redis作为守护进程运行的时候，它会把 pid 默认写到 /var/run/redis.pid 文件里面，# 但是你可以在这里自己制定它的文件位置。pidfile /var/run/redis.pid# 监听端口号，默认为 6379，如果你设为 0 ，redis 将不在 socket 上监听任何客户端连接。port 6379# TCP 监听的最大容纳数量## 在高并发的环境下，你需要把这个值调高以避免客户端连接缓慢的问题。# Linux 内核会一声不响的把这个值缩小成 /proc/sys/net/core/somaxconn 对应的值，# 所以你要修改这两个值才能达到你的预期。tcp-backlog 511# 默认情况下，redis 在 server 上所有有效的网络接口上监听客户端连接。# 你如果只想让它在一个网络接口上监听，那你就绑定一个IP或者多个IP。## 示例，多个IP用空格隔开:## bind 192.168.1.100 10.0.0.1# bind 127.0.0.1# 指定 unix socket 的路径。## unixsocket /tmp/redis.sock# unixsocketperm 755# 指定在一个 client 空闲多少秒之后关闭连接（0 就是不管它）timeout 0# tcp 心跳包。## 如果设置为非零，则在与客户端缺乏通讯的时候使用 SO_KEEPALIVE 发送 tcp acks 给客户端。# 这个之所有有用，主要由两个原因：## 1) 防止死的 peers# 2) Take the connection alive from the point of view of network#    equipment in the middle.## On Linux, the specified value (in seconds) is the period used to send ACKs.# Note that to close the connection the double of the time is needed.# On other kernels the period depends on the kernel configuration.## A reasonable value for this option is 60 seconds.# 推荐一个合理的值就是60秒tcp-keepalive 0# 定义日志级别。# 可以是下面的这些值：# debug (适用于开发或测试阶段)# verbose (many rarely useful info, but not a mess like the debug level)# notice (适用于生产环境)# warning (仅仅一些重要的消息被记录)loglevel notice# 指定日志文件的位置logfile ""# 要想把日志记录到系统日志，就把它改成 yes，# 也可以可选择性的更新其他的syslog 参数以达到你的要求# syslog-enabled no# 设置 syslog 的 identity。# syslog-ident redis# 设置 syslog 的 facility，必须是 USER 或者是 LOCAL0-LOCAL7 之间的值。# syslog-facility local0# 设置数据库的数目。# 默认数据库是 DB 0，你可以在每个连接上使用 select &lt;dbid&gt; 命令选择一个不同的数据库，# 但是 dbid 必须是一个介于 0 到 databasees - 1 之间的值databases 16################################ 快照 ################################## 存 DB 到磁盘：##   格式：save &lt;间隔时间（秒）&gt; &lt;写入次数&gt;##   根据给定的时间间隔和写入次数将数据保存到磁盘##   下面的例子的意思是：#   900 秒内如果至少有 1 个 key 的值变化，则保存#   300 秒内如果至少有 10 个 key 的值变化，则保存#   60 秒内如果至少有 10000 个 key 的值变化，则保存#　　#   注意：你可以注释掉所有的 save 行来停用保存功能。#   也可以直接一个空字符串来实现停用：#   save ""save 900 1save 300 10save 60 10000# 默认情况下，如果 redis 最后一次的后台保存失败，redis 将停止接受写操作，# 这样以一种强硬的方式让用户知道数据不能正确的持久化到磁盘，# 否则就会没人注意到灾难的发生。## 如果后台保存进程重新启动工作了，redis 也将自动的允许写操作。## 然而你要是安装了靠谱的监控，你可能不希望 redis 这样做，那你就改成 no 好了。stop-writes-on-bgsave-error yes# 是否在 dump .rdb 数据库的时候使用 LZF 压缩字符串# 默认都设为 yes# 如果你希望保存子进程节省点 cpu ，你就设置它为 no ，# 不过这个数据集可能就会比较大rdbcompression yes# 是否校验rdb文件rdbchecksum yes# 设置 dump 的文件位置dbfilename dump.rdb# 工作目录# 例如上面的 dbfilename 只指定了文件名，# 但是它会写入到这个目录下。这个配置项一定是个目录，而不能是文件名。dir ./################################# 主从复制 ################################## 主从复制。使用 slaveof 来让一个 redis 实例成为另一个reids 实例的副本。# 注意这个只需要在 slave 上配置。## slaveof &lt;masterip&gt; &lt;masterport&gt;# 如果 master 需要密码认证，就在这里设置# masterauth &lt;master-password&gt;# 当一个 slave 与 master 失去联系，或者复制正在进行的时候，# slave 可能会有两种表现：## 1) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，#    或者数据可能是空的在第一次同步的时候## 2) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，#    slave 都将返回一个 "SYNC with master in progress" 的错误，#slave-serve-stale-data yes# 你可以配置一个 slave 实体是否接受写入操作。# 通过写入操作来存储一些短暂的数据对于一个 slave 实例来说可能是有用的，# 因为相对从 master 重新同步数而言，据数据写入到 slave 会更容易被删除。# 但是如果客户端因为一个错误的配置写入，也可能会导致一些问题。## 从 redis 2.6 版起，默认 slaves 都是只读的。## Note: read only slaves are not designed to be exposed to untrusted clients# on the internet. It's just a protection layer against misuse of the instance.# Still a read only slave exports by default all the administrative commands# such as CONFIG, DEBUG, and so forth. To a limited extent you can improve# security of read only slaves using 'rename-command' to shadow all the# administrative / dangerous commands.# 注意：只读的 slaves 没有被设计成在 internet 上暴露给不受信任的客户端。# 它仅仅是一个针对误用实例的一个保护层。slave-read-only yes# Slaves 在一个预定义的时间间隔内发送 ping 命令到 server 。# 你可以改变这个时间间隔。默认为 10 秒。## repl-ping-slave-period 10# The following option sets the replication timeout for:# 设置主从复制过期时间## 1) Bulk transfer I/O during SYNC, from the point of view of slave.# 2) Master timeout from the point of view of slaves (data, pings).# 3) Slave timeout from the point of view of masters (REPLCONF ACK pings).## It is important to make sure that this value is greater than the value# specified for repl-ping-slave-period otherwise a timeout will be detected# every time there is low traffic between the master and the slave.# 这个值一定要比 repl-ping-slave-period 大## repl-timeout 60# Disable TCP_NODELAY on the slave socket after SYNC?## If you select "yes" Redis will use a smaller number of TCP packets and# less bandwidth to send data to slaves. But this can add a delay for# the data to appear on the slave side, up to 40 milliseconds with# Linux kernels using a default configuration.## If you select "no" the delay for data to appear on the slave side will# be reduced but more bandwidth will be used for replication.## By default we optimize for low latency, but in very high traffic conditions# or when the master and slaves are many hops away, turning this to "yes" may# be a good idea.repl-disable-tcp-nodelay no# 设置主从复制容量大小。这个 backlog 是一个用来在 slaves 被断开连接时# 存放 slave 数据的 buffer，所以当一个 slave 想要重新连接，通常不希望全部重新同步，# 只是部分同步就够了，仅仅传递 slave 在断开连接时丢失的这部分数据。## The biggest the replication backlog, the longer the time the slave can be# disconnected and later be able to perform a partial resynchronization.# 这个值越大，salve 可以断开连接的时间就越长。## The backlog is only allocated once there is at least a slave connected.## repl-backlog-size 1mb# After a master has no longer connected slaves for some time, the backlog# will be freed. The following option configures the amount of seconds that# need to elapse, starting from the time the last slave disconnected, for# the backlog buffer to be freed.# 在某些时候，master 不再连接 slaves，backlog 将被释放。## A value of 0 means to never release the backlog.# 如果设置为 0 ，意味着绝不释放 backlog 。## repl-backlog-ttl 3600# 当 master 不能正常工作的时候，Redis Sentinel 会从 slaves 中选出一个新的 master，# 这个值越小，就越会被优先选中，但是如果是 0 ， 那是意味着这个 slave 不可能被选中。## 默认优先级为 100。slave-priority 100# It is possible for a master to stop accepting writes if there are less than# N slaves connected, having a lag less or equal than M seconds.## The N slaves need to be in "online" state.## The lag in seconds, that must be &lt;= the specified value, is calculated from# the last ping received from the slave, that is usually sent every second.## This option does not GUARANTEES that N replicas will accept the write, but# will limit the window of exposure for lost writes in case not enough slaves# are available, to the specified number of seconds.## For example to require at least 3 slaves with a lag &lt;= 10 seconds use:## min-slaves-to-write 3# min-slaves-max-lag 10## Setting one or the other to 0 disables the feature.## By default min-slaves-to-write is set to 0 (feature disabled) and# min-slaves-max-lag is set to 10.################################## 安全 #################################### Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other# commands.  This might be useful in environments in which you do not trust# others with access to the host running redis-server.## This should stay commented out for backward compatibility and because most# people do not need auth (e.g. they run their own servers).# # Warning: since Redis is pretty fast an outside user can try up to# 150k passwords per second against a good box. This means that you should# use a very strong password otherwise it will be very easy to break.# # 设置认证密码# requirepass foobared# Command renaming.## It is possible to change the name of dangerous commands in a shared# environment. For instance the CONFIG command may be renamed into something# hard to guess so that it will still be available for internal-use tools# but not available for general clients.## Example:## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52## It is also possible to completely kill a command by renaming it into# an empty string:## rename-command CONFIG ""## Please note that changing the name of commands that are logged into the# AOF file or transmitted to slaves may cause problems.################################### 限制 ##################################### Set the max number of connected clients at the same time. By default# this limit is set to 10000 clients, however if the Redis server is not# able to configure the process file limit to allow for the specified limit# the max number of allowed clients is set to the current file limit# minus 32 (as Redis reserves a few file descriptors for internal uses).## 一旦达到最大限制，redis 将关闭所有的新连接# 并发送一个‘max number of clients reached’的错误。## maxclients 10000# 如果你设置了这个值，当缓存的数据容量达到这个值， redis 将根据你选择的# eviction 策略来移除一些 keys。## 如果 redis 不能根据策略移除 keys ，或者是策略被设置为 ‘noeviction’，# redis 将开始响应错误给命令，如 set，lpush 等等，# 并继续响应只读的命令，如 get## This option is usually useful when using Redis as an LRU cache, or to set# a hard memory limit for an instance (using the 'noeviction' policy).## WARNING: If you have slaves attached to an instance with maxmemory on,# the size of the output buffers needed to feed the slaves are subtracted# from the used memory count, so that network problems / resyncs will# not trigger a loop where keys are evicted, and in turn the output# buffer of slaves is full with DELs of keys evicted triggering the deletion# of more keys, and so forth until the database is completely emptied.## In short... if you have slaves attached it is suggested that you set a lower# limit for maxmemory so that there is some free RAM on the system for slave# output buffers (but this is not needed if the policy is 'noeviction').## 最大使用内存# maxmemory &lt;bytes&gt;# 最大内存策略，你有 5 个选择。# # volatile-lru -&gt; remove the key with an expire set using an LRU algorithm# volatile-lru -&gt; 使用 LRU 算法移除包含过期设置的 key 。# allkeys-lru -&gt; remove any key accordingly to the LRU algorithm# allkeys-lru -&gt; 根据 LRU 算法移除所有的 key 。# volatile-random -&gt; remove a random key with an expire set# allkeys-random -&gt; remove a random key, any key# volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)# noeviction -&gt; don't expire at all, just return an error on write operations# noeviction -&gt; 不让任何 key 过期，只是给写入操作返回一个错误# # Note: with any of the above policies, Redis will return an error on write#       operations, when there are not suitable keys for eviction.##       At the date of writing this commands are: set setnx setex append#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby#       getset mset msetnx exec sort## The default is:## maxmemory-policy noeviction# LRU and minimal TTL algorithms are not precise algorithms but approximated# algorithms (in order to save memory), so you can tune it for speed or# accuracy. For default Redis will check five keys and pick the one that was# used less recently, you can change the sample size using the following# configuration directive.## The default of 5 produces good enough results. 10 Approximates very closely# true LRU but costs a bit more CPU. 3 is very fast but not very accurate.## maxmemory-samples 5############################## APPEND ONLY MODE ################################ By default Redis asynchronously dumps the dataset on disk. This mode is# good enough in many applications, but an issue with the Redis process or# a power outage may result into a few minutes of writes lost (depending on# the configured save points).## The Append Only File is an alternative persistence mode that provides# much better durability. For instance using the default data fsync policy# (see later in the config file) Redis can lose just one second of writes in a# dramatic event like a server power outage, or a single write if something# wrong with the Redis process itself happens, but the operating system is# still running correctly.## AOF and RDB persistence can be enabled at the same time without problems.# If the AOF is enabled on startup Redis will load the AOF, that is the file# with the better durability guarantees.## Please check http://redis.io/topics/persistence for more information.appendonly no# The name of the append only file (default: "appendonly.aof")appendfilename "appendonly.aof"# The fsync() call tells the Operating System to actually write data on disk# instead to wait for more data in the output buffer. Some OS will really flush # data on disk, some other OS will just try to do it ASAP.## Redis supports three different modes:## no: don't fsync, just let the OS flush the data when it wants. Faster.# always: fsync after every write to the append only log . Slow, Safest.# everysec: fsync only one time every second. Compromise.## The default is "everysec", as that's usually the right compromise between# speed and data safety. It's up to you to understand if you can relax this to# "no" that will let the operating system flush the output buffer when# it wants, for better performances (but if you can live with the idea of# some data loss consider the default persistence mode that's snapshotting),# or on the contrary, use "always" that's very slow but a bit safer than# everysec.## More details please check the following article:# http://antirez.com/post/redis-persistence-demystified.html## If unsure, use "everysec".# appendfsync alwaysappendfsync everysec# appendfsync no# When the AOF fsync policy is set to always or everysec, and a background# saving process (a background save or AOF log background rewriting) is# performing a lot of I/O against the disk, in some Linux configurations# Redis may block too long on the fsync() call. Note that there is no fix for# this currently, as even performing fsync in a different thread will block# our synchronous write(2) call.## In order to mitigate this problem it's possible to use the following option# that will prevent fsync() from being called in the main process while a# BGSAVE or BGREWRITEAOF is in progress.## This means that while another child is saving, the durability of Redis is# the same as "appendfsync none". In practical terms, this means that it is# possible to lose up to 30 seconds of log in the worst scenario (with the# default Linux settings).# # If you have latency problems turn this to "yes". Otherwise leave it as# "no" that is the safest pick from the point of view of durability.no-appendfsync-on-rewrite no# Automatic rewrite of the append only file.# Redis is able to automatically rewrite the log file implicitly calling# BGREWRITEAOF when the AOF log size grows by the specified percentage.# # This is how it works: Redis remembers the size of the AOF file after the# latest rewrite (if no rewrite has happened since the restart, the size of# the AOF at startup is used).## This base size is compared to the current size. If the current size is# bigger than the specified percentage, the rewrite is triggered. Also# you need to specify a minimal size for the AOF file to be rewritten, this# is useful to avoid rewriting the AOF file even if the percentage increase# is reached but it is still pretty small.## Specify a percentage of zero in order to disable the automatic AOF# rewrite feature.auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb################################ LUA SCRIPTING  ################################ Max execution time of a Lua script in milliseconds.## If the maximum execution time is reached Redis will log that a script is# still in execution after the maximum allowed time and will start to# reply to queries with an error.## When a long running script exceed the maximum execution time only the# SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be# used to stop a script that did not yet called write commands. The second# is the only way to shut down the server in the case a write commands was# already issue by the script but the user don't want to wait for the natural# termination of the script.## Set it to 0 or a negative value for unlimited execution without warnings.lua-time-limit 5000################################ REDIS 集群  ################################# 启用或停用集群# cluster-enabled yes# Every cluster node has a cluster configuration file. This file is not# intended to be edited by hand. It is created and updated by Redis nodes.# Every Redis Cluster node requires a different cluster configuration file.# Make sure that instances running in the same system does not have# overlapping cluster configuration file names.## cluster-config-file nodes-6379.conf# Cluster node timeout is the amount of milliseconds a node must be unreachable # for it to be considered in failure state.# Most other internal time limits are multiple of the node timeout.## cluster-node-timeout 15000# A slave of a failing master will avoid to start a failover if its data# looks too old.## There is no simple way for a slave to actually have a exact measure of# its "data age", so the following two checks are performed:## 1) If there are multiple slaves able to failover, they exchange messages#    in order to try to give an advantage to the slave with the best#    replication offset (more data from the master processed).#    Slaves will try to get their rank by offset, and apply to the start#    of the failover a delay proportional to their rank.## 2) Every single slave computes the time of the last interaction with#    its master. This can be the last ping or command received (if the master#    is still in the "connected" state), or the time that elapsed since the#    disconnection with the master (if the replication link is currently down).#    If the last interaction is too old, the slave will not try to failover#    at all.## The point "2" can be tuned by user. Specifically a slave will not perform# the failover if, since the last interaction with the master, the time# elapsed is greater than:##   (node-timeout * slave-validity-factor) + repl-ping-slave-period## So for example if node-timeout is 30 seconds, and the slave-validity-factor# is 10, and assuming a default repl-ping-slave-period of 10 seconds, the# slave will not try to failover if it was not able to talk with the master# for longer than 310 seconds.## A large slave-validity-factor may allow slaves with too old data to failover# a master, while a too small value may prevent the cluster from being able to# elect a slave at all.## For maximum availability, it is possible to set the slave-validity-factor# to a value of 0, which means, that slaves will always try to failover the# master regardless of the last time they interacted with the master.# (However they'll always try to apply a delay proportional to their# offset rank).## Zero is the only value able to guarantee that when all the partitions heal# the cluster will always be able to continue.## cluster-slave-validity-factor 10# Cluster slaves are able to migrate to orphaned masters, that are masters# that are left without working slaves. This improves the cluster ability# to resist to failures as otherwise an orphaned master can't be failed over# in case of failure if it has no working slaves.## Slaves migrate to orphaned masters only if there are still at least a# given number of other working slaves for their old master. This number# is the "migration barrier". A migration barrier of 1 means that a slave# will migrate only if there is at least 1 other working slave for its master# and so forth. It usually reflects the number of slaves you want for every# master in your cluster.## Default is 1 (slaves migrate only if their masters remain with at least# one slave). To disable migration just set it to a very large value.# A value of 0 can be set but is useful only for debugging and dangerous# in production.## cluster-migration-barrier 1# In order to setup your cluster make sure to read the documentation# available at http://redis.io web site.################################## SLOW LOG #################################### The Redis Slow Log is a system to log queries that exceeded a specified# execution time. The execution time does not include the I/O operations# like talking with the client, sending the reply and so forth,# but just the time needed to actually execute the command (this is the only# stage of command execution where the thread is blocked and can not serve# other requests in the meantime).# # You can configure the slow log with two parameters: one tells Redis# what is the execution time, in microseconds, to exceed in order for the# command to get logged, and the other parameter is the length of the# slow log. When a new command is logged the oldest one is removed from the# queue of logged commands.# The following time is expressed in microseconds, so 1000000 is equivalent# to one second. Note that a negative number disables the slow log, while# a value of zero forces the logging of every command.slowlog-log-slower-than 10000# There is no limit to this length. Just be aware that it will consume memory.# You can reclaim memory used by the slow log with SLOWLOG RESET.slowlog-max-len 128############################# Event notification ############################### Redis can notify Pub/Sub clients about events happening in the key space.# This feature is documented at http://redis.io/topics/keyspace-events# # For instance if keyspace events notification is enabled, and a client# performs a DEL operation on key "foo" stored in the Database 0, two# messages will be published via Pub/Sub:## PUBLISH __keyspace@0__:foo del# PUBLISH __keyevent@0__:del foo## It is possible to select the events that Redis will notify among a set# of classes. Every class is identified by a single character:##  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...#  $     String commands#  l     List commands#  s     Set commands#  h     Hash commands#  z     Sorted set commands#  x     Expired events (events generated every time a key expires)#  e     Evicted events (events generated when a key is evicted for maxmemory)#  A     Alias for g$lshzxe, so that the "AKE" string means all the events.##  The "notify-keyspace-events" takes as argument a string that is composed#  by zero or multiple characters. The empty string means that notifications#  are disabled at all.##  Example: to enable list and generic events, from the point of view of the#           event name, use:##  notify-keyspace-events Elg##  Example 2: to get the stream of the expired keys subscribing to channel#             name __keyevent@0__:expired use:##  notify-keyspace-events Ex##  By default all notifications are disabled because most users don't need#  this feature and the feature has some overhead. Note that if you don't#  specify at least one of K or E, no events will be delivered.notify-keyspace-events ""############################### ADVANCED CONFIG ################################ Hashes are encoded using a memory efficient data structure when they have a# small number of entries, and the biggest entry does not exceed a given# threshold. These thresholds can be configured using the following directives.hash-max-ziplist-entries 512hash-max-ziplist-value 64# Similarly to hashes, small lists are also encoded in a special way in order# to save a lot of space. The special representation is only used when# you are under the following limits:list-max-ziplist-entries 512list-max-ziplist-value 64# Sets have a special encoding in just one case: when a set is composed# of just strings that happens to be integers in radix 10 in the range# of 64 bit signed integers.# The following configuration setting sets the limit in the size of the# set in order to use this special memory saving encoding.set-max-intset-entries 512# Similarly to hashes and lists, sorted sets are also specially encoded in# order to save a lot of space. This encoding is only used when the length and# elements of a sorted set are below the following limits:zset-max-ziplist-entries 128zset-max-ziplist-value 64# HyperLogLog sparse representation bytes limit. The limit includes the# 16 bytes header. When an HyperLogLog using the sparse representation crosses# this limit, it is converted into the dense representation.## A value greater than 16000 is totally useless, since at that point the# dense representation is more memory efficient.# # The suggested value is ~ 3000 in order to have the benefits of# the space efficient encoding without slowing down too much PFADD,# which is O(N) with the sparse encoding. The value can be raised to# ~ 10000 when CPU is not a concern, but space is, and the data set is# composed of many HyperLogLogs with cardinality in the 0 - 15000 range.hll-sparse-max-bytes 3000# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in# order to help rehashing the main Redis hash table (the one mapping top-level# keys to values). The hash table implementation Redis uses (see dict.c)# performs a lazy rehashing: the more operation you run into a hash table# that is rehashing, the more rehashing "steps" are performed, so if the# server is idle the rehashing is never complete and some more memory is used# by the hash table.# # The default is to use this millisecond 10 times every second in order to# active rehashing the main dictionaries, freeing memory when possible.## If unsure:# use "activerehashing no" if you have hard latency requirements and it is# not a good thing in your environment that Redis can reply form time to time# to queries with 2 milliseconds delay.## use "activerehashing yes" if you don't have such hard requirements but# want to free memory asap when possible.activerehashing yes# The client output buffer limits can be used to force disconnection of clients# that are not reading data from the server fast enough for some reason (a# common reason is that a Pub/Sub client can't consume messages as fast as the# publisher can produce them).## The limit can be set differently for the three different classes of clients:## normal -&gt; normal clients# slave  -&gt; slave clients and MONITOR clients# pubsub -&gt; clients subscribed to at least one pubsub channel or pattern## The syntax of every client-output-buffer-limit directive is the following:## client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;## A client is immediately disconnected once the hard limit is reached, or if# the soft limit is reached and remains reached for the specified number of# seconds (continuously).# So for instance if the hard limit is 32 megabytes and the soft limit is# 16 megabytes / 10 seconds, the client will get disconnected immediately# if the size of the output buffers reach 32 megabytes, but will also get# disconnected if the client reaches 16 megabytes and continuously overcomes# the limit for 10 seconds.## By default normal clients are not limited because they don't receive data# without asking (in a push way), but just after a request, so only# asynchronous clients may create a scenario where data is requested faster# than it can read.## Instead there is a default limit for pubsub and slave clients, since# subscribers and slaves receive data in a push fashion.## Both the hard or the soft limit can be disabled by setting them to zero.client-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60# Redis calls an internal function to perform many background tasks, like# closing connections of clients in timeout, purging expired keys that are# never requested, and so forth.## Not all tasks are performed with the same frequency, but Redis checks for# tasks to perform accordingly to the specified "hz" value.## By default "hz" is set to 10. Raising the value will use more CPU when# Redis is idle, but at the same time will make Redis more responsive when# there are many keys expiring at the same time, and timeouts may be# handled with more precision.## The range is between 1 and 500, however a value over 100 is usually not# a good idea. Most users should use the default of 10 and raise this up to# 100 only in environments where very low latency is required.hz 10# When a child rewrites the AOF file, if the following option is enabled# the file will be fsync-ed every 32 MB of data generated. This is useful# in order to commit the file to the disk more incrementally and avoid# big latency spikes.aof-rewrite-incremental-fsync yes</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言</title>
      <link href="/posts/blog-model03.html"/>
      <url>/posts/blog-model03.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h1 id="一-R环境设置"><a href="#一-R环境设置" class="headerlink" title="一.R环境设置"></a>一.R环境设置</h1><h3 id="尝试在线环境"><a href="#尝试在线环境" class="headerlink" title="尝试在线环境"></a>尝试在线环境</h3><p>你真的不需要设置自己的环境来开始学习R编程语言。 原因很简单，我们已经在线设置了R编程环境，以便您可以在进行理论工作的同时在线编译和执行所有可用的示例。 这给你对你正在阅读的信心，并用不同的选项检查结果。 随意修改任何示例并在线执行。<br>实例：</p><pre><code># Print Hello World. print("Hello World") # Add two numbers. print(23.9 + 11.6)</code></pre><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><p>您可以从<a href="https://cran.r-project.org/bin/windows/base/" target="_blank" rel="noopener">R-3.2.2 for Windows（32/64位）</a>下载R的Windows安装程序版本，并将其保存在本地目录中。</p><p>因为它是一个名为“R-version-win.exe”的Windows安装程序（.exe）。 您只需双击并运行安装程序接受默认设置即可。 如果您的Windows是32位版本，它将安装32位版本。 但是如果你的窗口是64位，那么它安装32位和64位版本。</p><p>安装后，您可以找到该图标，以在Windows程序文件下的目录结构“R \ R3.2.2 \ bin \ i386 \ Rgui.exe”中运行程序。 单击此图标会打开R-GUI，它是R控制台来执行R编程。</p><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><p><a href="https://cran.r-project.org/bin/linux/" target="_blank" rel="noopener">R</a>语言适用于多版本的Linux系统。</p><p>各版本Linux的各有不同。具体的安装步骤在上述资源中有对应的教程。但是，如果你是在赶时间，那么你可以用<strong>yum</strong>命令，如下所示的安装指令<br>安装R</p><pre><code>$ yum install R</code></pre><p>以上命令将安装R编程的核心功能与标准包，额外的包需要另外安装，而后你可以按如下提示启动R。</p><pre><code>$ RR version 3.2.0 (2015-04-16) -- "Full of  Ingredients"          Copyright (C) 2015 The R Foundation for Statistical ComputingPlatform: x86_64-redhat-linux-gnu (64-bit)R is free software and comes with ABSOLUTELY NO WARRANTY.You are welcome to redistribute it under certain conditions.Type 'license()' or 'licence()' for distribution details.R is a collaborative project with many  contributors.                    Type 'contributors()' for more information and'citation()' on how to cite R or R packages in publications.Type 'demo()' for some demos, 'help()' for on-line help, or'help.start()' for an HTML browser interface to help.Type 'q()' to quit R.&gt;  </code></pre><p>现在，您可以在R语言提示符下使用install命令安装所需的软件包。 例如，以下命令将安装为3D图表所需的plotrix软件包。</p><pre><code>&gt; install.packages("plotrix")</code></pre><h1 id="二-R语言-基本语法"><a href="#二-R语言-基本语法" class="headerlink" title="二.R语言 基本语法"></a>二.R语言 基本语法</h1><h3 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h3><p>如果你已经配置好R语言环境，那么你只需要按一下的命令便可轻易开启命令提示符</p><pre><code>$ R</code></pre><p>这将启动R语言解释器，你会得到一个提示 &gt; 在那里你可以开始输入你的程序，具体如下。</p><pre><code>&gt; myString &lt;- "Hello, World!"&gt; print ( myString)[1] "Hello, World!"</code></pre><p>在这里，第一个语句先定义一个字符串变量myString，并将“Hello，World！”赋值其中，第二句则使用print()语句将变量myString的内容进行打印。</p><h3 id="脚本文件"><a href="#脚本文件" class="headerlink" title="脚本文件"></a>脚本文件</h3><p>通常，您将通过在脚本文件中编写程序来执行编程，然后在命令提示符下使用R解释器（称为Rscript）来执行这些脚本。 所以让我们开始在一个命名为test.R的文本文件中编写下面的代码</p><pre><code># My first program in R ProgrammingmyString &lt;- "Hello, World!"print ( myString)</code></pre><p>将上述代码保存在test.R文件中，并在Linux命令提示符下执行，如下所示。 即使您使用的是Windows或其他系统，语法也将保持不变。</p><pre><code>$ Rscript test.R </code></pre><p>当我们运行上面的程序，它产生以下结果。</p><pre><code>[1] "Hello, World!"</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释能帮助您解释R语言程序中的脚本，它们在实际执行程序时会被解释器忽略。 单个注释使用＃在语句的开头写入，如下所示</p><pre><code># My first program in R Programming</code></pre><p>R语言不支持多行注释，但你可以使用一个小技巧，如下</p><pre><code>if(FALSE) {   "This is a demo for multi-line comments and it should be put inside either a single      OR double quote"}myString &lt;- "Hello, World!"print ( myString)</code></pre><p>虽然上面的注释将由R解释器执行，但它们不会干扰您的实际程序。 但是你必须为内容加上单引号或双引号。</p><h1 id="三-数据结构"><a href="#三-数据结构" class="headerlink" title="三.数据结构"></a>三.数据结构</h1><p>通常，在使用任何编程语言进行编程时，您需要使用各种变量来存储各种信息。 变量只是保留值的存储位置。 这意味着，当你创建一个变量，你必须在内存中保留一些空间来存储它们。</p><p>您可能想存储各种数据类型的信息，如字符，宽字符，整数，浮点，双浮点，布尔等。基于变量的数据类型，操作系统分配内存并决定什么可以存储在保留内存中。</p><p>与其他编程语言（如C中的C和java）相反，变量不会声明为某种数据类型。 变量分配有R对象，R对象的数据类型变为变量的数据类型。尽管有很多类型的R对象，但经常使用的是：</p><ul><li><p>矢量</p></li><li><p>列表</p></li><li><p>矩阵</p></li><li><p>数组</p></li><li><p>因子</p></li><li><p>数据帧<br>这些对象中最简单的是向量对象，并且这些原子向量有六种数据类型，也称为六类向量。 其他R对象建立在原子向量之上。</p></li><li><p>Logical（逻辑型）：TRUE, FALSE </p></li><li><p>Numeric（数字）    12.3，5，999</p></li><li><p>Integer（整型）    2L，34L，0L</p></li><li><p>Complex（复合型）    3 + 2i</p></li><li><p>Character（字符）    ‘a’ , ‘“good”, “TRUE”, ‘23.4’</p></li><li><p>Raw（原型）    “Hello” 被存储为 48 65 6c 6c 6f<br>在R编程中，非常基本的数据类型是称为向量的R对象，其保存如上所示的不同类的元素。 请注意，在R中，类的数量不仅限于上述六种类型。 例如，我们可以使用许多原子向量并创建一个数组，其类将成为数组。</p><h3 id="Vectors-向量"><a href="#Vectors-向量" class="headerlink" title="Vectors 向量"></a>Vectors 向量</h3><p>当你想用多个元素创建向量时，你应该使用c()函数，这意味着将元素组合成一个向量。</p><pre><code># Create a vector.apple &lt;- c('red','green',"yellow")print(apple)# Get the class of the vector.print(class(apple))</code></pre><p>当我们执行上面的代码，它产生以下结果</p><pre><code>[1] "red"    "green"  "yellow"[1] "character"</code></pre><h3 id="Lists-列表"><a href="#Lists-列表" class="headerlink" title="Lists 列表"></a>Lists 列表</h3><p>列表是一个R对象，它可以在其中包含许多不同类型的元素，如向量，函数甚至其中的另一个列表。</p><pre><code># Create a list.list1 &lt;- list(c(2,5,3),21.3,sin)# Print the list.print(list1)</code></pre><p>当我们执行上面的代码，它产生以下结果</p><pre><code>[[1]][1] 2 5 3[[2]][1] 21.3[[3]]function (x)  .Primitive("sin")### Matrices 矩阵</code></pre><p>矩阵是二维矩形数据集。 它可以使用矩阵函数的向量输入创建。</p><pre><code># Create a matrix.M = matrix( c('a','a','b','c','b','a'), nrow = 2, ncol = 3, byrow = TRUE)print(M)</code></pre><p>当我们执行上面的代码，它产生以下结果</p><pre><code>   [,1] [,2] [,3][1,] "a"  "a"  "b" [2,] "c"  "b"  "a"</code></pre><h3 id="Arrays-数组"><a href="#Arrays-数组" class="headerlink" title="Arrays 数组"></a>Arrays 数组</h3><p>虽然矩阵被限制为二维，但阵列可以具有任何数量的维度。 数组函数使用一个dim属性创建所需的维数。 在下面的例子中，我们创建了一个包含两个元素的数组，每个元素为3x3个矩阵。</p><pre><code># Create an array.a &lt;- array(c('green','yellow'),dim = c(3,3,2))print(a)</code></pre><p>当我们执行上面的代码，它产生以下结果</p><pre><code>, , 1   [,1]     [,2]     [,3]    [1,] "green"  "yellow" "green" [2,] "yellow" "green"  "yellow"[3,] "green"  "yellow" "green" , , 2   [,1]     [,2]     [,3]    [1,] "yellow" "green"  "yellow"[2,] "green"  "yellow" "green" [3,] "yellow" "green"  "yellow"  </code></pre><h3 id="Factors-因子"><a href="#Factors-因子" class="headerlink" title="Factors 因子"></a>Factors 因子</h3><p>因子是使用向量创建的r对象。 它将向量与向量中元素的不同值一起存储为标签。 标签总是字符，不管它在输入向量中是数字还是字符或布尔等。 它们在统计建模中非常有用。<br>使用factor()函数创建因子。nlevels函数给出级别计数。</p><pre><code># Create a vector.apple_colors &lt;- c('green','green','yellow','red','red','red','green')# Create a factor object.factor_apple &lt;- factor(apple_colors)# Print the factor.print(factor_apple)print(nlevels(factor_apple))</code></pre><p>当我们执行上面的代码，它产生以下结果</p><pre><code>[1] green  green  yellow red    red    red    yellow green Levels: green red yellow# applying the nlevels function we can know the number of distinct values[1] 3</code></pre><h3 id="Data-Frames-数据帧"><a href="#Data-Frames-数据帧" class="headerlink" title="Data Frames 数据帧"></a>Data Frames 数据帧</h3><p>数据帧是表格数据对象。 与数据帧中的矩阵不同，每列可以包含不同的数据模式。 第一列可以是数字，而第二列可以是字符，第三列可以是逻辑的。 它是等长度的向量的列表。<br>使用data.frame()函数创建数据帧。</p><pre><code># Create the data frame.BMI &lt;-     data.frame( gender = c("Male", "Male","Female"),  height = c(152, 171.5, 165),  weight = c(81,93, 78), Age = c(42,38,26))print(BMI)</code></pre><p>当我们执行上面的代码，它产生以下结果</p><pre><code>gender height weight Age1   Male  152.0     81  422   Male  171.5     93  383 Female  165.0     78  26  </code></pre><h1 id="四-变量"><a href="#四-变量" class="headerlink" title="四.变量"></a>四.变量</h1><p>变量为我们提供了我们的程序可以操作的命名存储。 R语言中的变量可以存储原子向量，原子向量组或许多Robject的组合。 有效的变量名称由字母，数字和点或下划线字符组成。 变量名以字母或不以数字后跟的点开头。<br>注：有字母，数字，点和下划线，其中只能字母开头</p><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>可以使用向左，向右和等于运算符来为变量分配值。 可以使用print()或cat()函数打印变量的值。 cat()函数将多个项目组合成连续打印输出。</p><pre><code># Assignment using equal operator.var.1 = c(0,1,2,3)           # Assignment using leftward operator.var.2 &lt;- c("learn","R")   # Assignment using rightward operator.   c(TRUE,1) -&gt; var.3           print(var.1)cat ("var.1 is ", var.1 ,"")cat ("var.2 is ", var.2 ,"")cat ("var.3 is ", var.3 ,"")</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 0 1 2 3var.1 is  0 1 2 3 var.2 is  learn R var.3 is  1 1 </code></pre><p>注 - 向量c（TRUE，1）具有逻辑和数值类的混合。 因此，逻辑类强制转换为数字类，使TRUE为1。</p><h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><p>在R语言中，变量本身没有声明任何数据类型，而是获取分配给它的R - 对象的数据类型。 所以R称为动态类型语言，这意味着我们可以在程序中使用同一个变量时，一次又一次地更改变量的数据类型。</p><pre><code>var_x &lt;- "Hello"cat("The class of var_x is ",class(var_x),"")var_x &lt;- 34.5cat("  Now the class of var_x is ",class(var_x),"")var_x &lt;- 27Lcat("   Next the class of var_x becomes ",class(var_x),"")</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>The class of var_x is  character  Now the class of var_x is  numeric     Next the class of var_x becomes  integer</code></pre><h3 id="查找变量"><a href="#查找变量" class="headerlink" title="查找变量"></a>查找变量</h3><p>要知道工作空间中当前可用的所有变量，我们使用ls()函数。 ls()函数也可以使用模式来匹配变量名。</p><pre><code>print(ls())</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "my var"     "my_new_var" "my_var"     "var.1"      [5] "var.2"      "var.3"      "var.name"   "var_name2."[9] "var_x"      "varname" </code></pre><p>注意 - 它是一个示例输出，取决于在您的环境中声明的变量。<br>ls()函数可以使用模式来匹配变量名。<br>ls()函数可以使用模式来匹配变量名。</p><pre><code># List the variables starting with the pattern "var".print(ls(pattern = "var"))   </code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "my var"     "my_new_var" "my_var"     "var.1"      [5] "var.2"      "var.3"      "var.name"   "var_name2."[9] "var_x"      "varname"    </code></pre><p>以点(.)开头的变量被隐藏，它们可以使用ls()函数的“all.names = TRUE”参数列出。</p><pre><code>print(ls(all.name = TRUE))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] ".cars"        ".Random.seed" ".var_name"    ".varname"     ".varname2"   [6] "my var"       "my_new_var"   "my_var"       "var.1"        "var.2"        [11]"var.3"        "var.name"     "var_name2."   "var_x"  </code></pre><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>可以使用rm()函数删除变量。 下面我们删除变量var.3。 打印时，抛出变量错误的值。</p><pre><code>rm(var.3)print(var.3)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "var.3"Error in print(var.3) : object 'var.3' not found</code></pre><p>所有的变量可以通过使用rm()和ls()函数一起删除。</p><pre><code>rm(list = ls())print(ls())</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>character(0)</code></pre><h1 id="五-运算符"><a href="#五-运算符" class="headerlink" title="五.运算符"></a>五.运算符</h1><p>运算符是一个符号，通知编译器执行特定的数学或逻辑操作。 R语言具有丰富的内置运算符，并提供以下类型的运算符。</p></li></ul><h3 id="运算符的类型"><a href="#运算符的类型" class="headerlink" title="运算符的类型"></a>运算符的类型</h3><p>R语言中拥有如下几种运算符类型：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>其他运算符</li><li>算术运算符<br>下表显示了R语言支持的算术运算符。 操作符对向量的每个元素起作用。<br>除了加减乘除</li><li>%%    两个向量求余</li><li>％/％    两个向量相除求商</li><li>^    将第二向量作为第一向量的指数<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3>即大于小于等于以及不等于<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3>下表显示了R语言支持的逻辑运算符。 它只适用于逻辑，数字或复杂类型的向量。 所有大于1的数字被认为是逻辑值TRUE。<br>将第一向量的每个元素与第二向量的相应元素进行比较。 比较的结果是布尔值。</li><li>&amp;    它被称为元素逻辑AND运算符。 它将第一向量的每个元素与第二向量的相应元素组合，并且如果两个元素都为TRUE，则给出输出TRUE。</li><li>|    它被称为元素逻辑或运算符。 它将第一向量的每个元素与第二向量的相应元素组合，并且如果元素为真，则给出输出TRUE。</li><li>!    它被称为逻辑非运算符。 取得向量的每个元素，并给出相反的逻辑值。<br>逻辑运算符&amp;&amp;和|| 只考虑向量的第一个元素，给出单个元素的向量作为输出。</li><li>&amp;&amp;    称为逻辑AND运算符。 取两个向量的第一个元素，并且只有两个都为TRUE时才给出TRUE。</li><li>||    称为逻辑OR运算符。 取两个向量的第一个元素，如果其中一个为TRUE，则给出TRUE。<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3>这些运算符用于向向量赋值。</li><li>&lt;− or = or &lt;&lt;−  称为左分配</li><li>-&gt; or -&gt;&gt;    称为右分配<h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3>这些运算符用于特定目的，而不是一般的数学或逻辑计算。</li><li>:    冒号运算符。 它为向量按顺序创建一系列数字。</li><li>%in%    此运算符用于标识元素是否属于向量。</li><li>%*%    此运算符用于将矩阵与其转置相乘。<h1 id="六-决策"><a href="#六-决策" class="headerlink" title="六.决策"></a>六.决策</h1>决策结构要求程序员指定要由程序评估或测试的一个或多个条件，以及如果条件被确定为真则要执行的一个或多个语句，如果条件为假则执行其他语句。</li></ul><p>以下是在大多数编程语言中的典型决策结构的一般形式</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-295f26be3cad36cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="做决定"></p><p>R提供以下类型的决策语句。 单击以下链接以检查其详细信息。</p><ul><li><a href="https://www.w3cschool.cn/r/r_if_statement.html" target="_blank" rel="noopener">if语句</a></li></ul><p>if语句由一个布尔表达式后跟一个或多个语句组成。</p><ul><li><a href="https://www.w3cschool.cn/r/r_if_else_statement.html" target="_blank" rel="noopener">if … else语句</a></li></ul><p>if语句后面可以有一个可选的else语句，当布尔表达式为false时执行。</p><ul><li><a href="https://www.w3cschool.cn/r/r_switch_statement.html" target="_blank" rel="noopener">switch语句</a></li></ul><p>switch语句允许根据值列表测试变量的相等性。</p><h1 id="七-包"><a href="#七-包" class="headerlink" title="七.包"></a>七.包</h1><p>R语言的包是R函数，编译代码和样本数据的集合。 它们存储在R语言环境中名为“library”的目录下。 默认情况下，R语言在安装期间安装一组软件包。 随后添加更多包，当它们用于某些特定目的时。 当我们启动R语言控制台时，默认情况下只有默认包可用。 已经安装的其他软件包必须显式加载以供将要使用它们的R语言程序使用。</p><p>所有可用的R语言包都列在<a href="https://cran.r-project.org/web/packages/available_packages_by_name.html" target="_blank" rel="noopener">R语言的包</a>。<br>下面是用于检查，验证和使用R包的命令列表。</p><h3 id="检查可用R语言的包"><a href="#检查可用R语言的包" class="headerlink" title="检查可用R语言的包"></a>检查可用R语言的包</h3><p>获取包含R包的库位置</p><pre><code>.libPaths()</code></pre><p>当我们执行上面的代码，它产生以下结果。 它可能会根据您的电脑的本地设置而有所不同。</p><pre><code>[2] "C:/Program Files/R/R-3.2.2/library"</code></pre><p>获取已安装的所有软件包列表</p><pre><code>library()</code></pre><p>当我们执行上面的代码，它产生以下结果。 它可能会根据您的电脑的本地设置而有所不同。</p><pre><code>Packages in library ‘C:/Program Files/R/R-3.2.2/library’:base                    The R Base Packageboot                    Bootstrap Functions (Originally by Angelo Canty                        for S)class                   Functions for Classificationcluster                 "Finding Groups in Data": Cluster Analysis                        Extended Rousseeuw et al.codetools               Code Analysis Tools for Rcompiler                The R Compiler Package</code></pre><p>获取当前在R环境中加载的所有包</p><pre><code>search()</code></pre><p>当我们执行上述代码时，它产生了以下结果。它会根据你的个人电脑的本地设置而异。</p><pre><code>[1] ".GlobalEnv"        "package:stats"     "package:graphics" [4] "package:grDevices" "package:utils"     "package:datasets" [7] "package:methods"   "Autoloads"         "package:base" </code></pre><h3 id="安装一个新的软件包"><a href="#安装一个新的软件包" class="headerlink" title="安装一个新的软件包"></a>安装一个新的软件包</h3><p>有两种方法来添加新的R包。 一个是直接从CRAN目录安装，另一个是将软件包下载到本地系统并手动安装它。</p><h5 id="直接从CRAN安装"><a href="#直接从CRAN安装" class="headerlink" title="直接从CRAN安装"></a>直接从CRAN安装</h5><p>以下命令直接从CRAN网页获取软件包，并将软件包安装在R环境中。 可能会提示您选择最近的镜像。 根据您的位置选择一个。</p><pre><code># Install the package named "XML". install.packages("XML")</code></pre><h5 id="手动安装包"><a href="#手动安装包" class="headerlink" title="手动安装包"></a>手动安装包</h5><p>转到链接<a href="https://cran.r-project.org/web/packages/available_packages_by_name.html" target="_blank" rel="noopener">R Packages</a>下载所需的包。 将包作为.zip文件保存在本地系统中的适当位置。<br>现在您可以运行以下命令在R环境中安装此软件包。</p><pre><code># Install the package named "XML"install.packages("E:/XML_3.98-1.3.zip", repos = NULL, type = "source")</code></pre><h3 id="装载包到库中"><a href="#装载包到库中" class="headerlink" title="装载包到库中"></a>装载包到库中</h3><p>在包可以在代码中使用之前，必须将其加载到当前R环境中。 您还需要加载先前已安装但在当前环境中不可用的软件包。</p><p>使用以下命令加载包：</p><pre><code>library("package Name", lib.loc = "path to library")# Load the package named "XML"install.packages("E:/XML_3.98-1.3.zip", repos = NULL, type = "source")</code></pre><p>#九.循环<br>可能有一种情况，当你需要执行一段代码几次。 通常，顺序执行语句。 首先执行函数中的第一个语句，然后执行第二个语句，依此类推。</p><p>编程语言提供允许更复杂的执行路径的各种控制结构。</p><p>循环语句允许我们多次执行一个语句或一组语句，以下是大多数编程语言中循环语句的一般形式 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-1a49a2a37e122a97.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="环路结构"><br>R编程语言提供以下种类的循环来处理循环需求。 单击以下链接以检查其详细信息。</p><ul><li><a href="https://www.w3cschool.cn/r/r_repeat_loop.html" target="_blank" rel="noopener">repeat循环</a></li></ul><p>多次执行一系列语句，并简化管理循环变量的代码。</p><ul><li><a href="https://www.w3cschool.cn/r/r_while_loop.html" target="_blank" rel="noopener">while循环</a></li></ul><p>在给定条件为真时，重复语句或语句组。 它在执行循环体之前测试条件。</p><ul><li><a href="https://www.w3cschool.cn/r/r_for_loop.html" target="_blank" rel="noopener">for循环</a></li></ul><p>像while语句，不同之处在于它测试在循环体的端部的条件。</p><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><p>循环控制语句从其正常序列改变执行。 当执行离开作用域时，在该作用域中创建的所有自动对象都将被销毁。<br>R语言支持以下控制语句。 单击以下链接以检查其详细信息。</p><ul><li><a href="https://www.w3cschool.cn/r/r_break_statement.html" target="_blank" rel="noopener">break语句</a></li></ul><p>终止循环语句，并将执行转移到循环后立即执行的语句。</p><ul><li><a href="https://www.w3cschool.cn/r/r_next_statement.html" target="_blank" rel="noopener">next语句</a></li></ul><p>next语句模拟R语言switch语句的行为。</p><h1 id="十-数据重塑"><a href="#十-数据重塑" class="headerlink" title="十.数据重塑"></a>十.数据重塑</h1><p>R语言中的数据重塑是关于改变数据被组织成行和列的方式。 大多数时间R语言中的数据处理是通过将输入数据作为数据帧来完成的。 很容易从数据帧的行和列中提取数据，但是在某些情况下，我们需要的数据帧格式与我们接收数据帧的格式不同。 R语言具有许多功能，在数据帧中拆分，合并和将行更改为列，反之亦然。</p><h3 id="于数据帧中加入列和行"><a href="#于数据帧中加入列和行" class="headerlink" title="于数据帧中加入列和行"></a>于数据帧中加入列和行</h3><p>我们可以使用cbind()函数连接多个向量来创建数据帧。 此外，我们可以使用rbind()函数合并两个数据帧。</p><pre><code># Create vector objects.city &lt;- c("Tampa","Seattle","Hartford","Denver")state &lt;- c("FL","WA","CT","CO")zipcode &lt;- c(33602,98104,06161,80294)# Combine above three vectors into one data frame.addresses &lt;- cbind(city,state,zipcode)# Print a header.cat("# # # # The First data frame") # Print the data frame.print(addresses)# Create another data frame with similar columnsnew.address &lt;- data.frame(   city = c("Lowry","Charlotte"),   state = c("CO","FL"),   zipcode = c("80230","33949"),   stringsAsFactors = FALSE)# Print a header.cat("# # # The Second data frame") # Print the data frame.print(new.address)# Combine rows form both the data frames.all.addresses &lt;- rbind(addresses,new.address)# Print a header.cat("# # # The combined data frame") # Print the result.print(all.addresses)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code># # # # The First data frame     city       state zipcode[1,] "Tampa"    "FL"  "33602"[2,] "Seattle"  "WA"  "98104"[3,] "Hartford" "CT"   "6161" [4,] "Denver"   "CO"  "80294"# # # The Second data frame       city       state   zipcode1      Lowry      CO      802302      Charlotte  FL      33949# # # The combined data frame       city      state zipcode1      Tampa     FL    336022      Seattle   WA    981043      Hartford  CT     61614      Denver    CO    802945      Lowry     CO    802306     Charlotte  FL    33949</code></pre><h3 id="合并数据帧"><a href="#合并数据帧" class="headerlink" title="合并数据帧"></a>合并数据帧</h3><p>我们可以使用merge()函数合并两个数据帧。 数据帧必须具有相同的列名称，在其上进行合并。</p><p>在下面的例子中，我们考虑图书馆名称“MASS”中有关Pima Indian Women的糖尿病的数据集。 我们基于血压（“bp”）和体重指数（“bmi”）的值合并两个数据集。 在选择这两列用于合并时，其中这两个变量的值在两个数据集中匹配的记录被组合在一起以形成单个数据帧。</p><pre><code>library(MASS)merged.Pima &lt;- merge(x = Pima.te, y = Pima.tr,   by.x = c("bp", "bmi"),   by.y = c("bp", "bmi"))print(merged.Pima)nrow(merged.Pima)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>   bp  bmi npreg.x glu.x skin.x ped.x age.x type.x npreg.y glu.y skin.y ped.y1  60 33.8       1   117     23 0.466    27     No       2   125     20 0.0882  64 29.7       2    75     24 0.370    33     No       2   100     23 0.3683  64 31.2       5   189     33 0.583    29    Yes       3   158     13 0.2954  64 33.2       4   117     27 0.230    24     No       1    96     27 0.2895  66 38.1       3   115     39 0.150    28     No       1   114     36 0.2896  68 38.5       2   100     25 0.324    26     No       7   129     49 0.4397  70 27.4       1   116     28 0.204    21     No       0   124     20 0.2548  70 33.1       4    91     32 0.446    22     No       9   123     44 0.3749  70 35.4       9   124     33 0.282    34     No       6   134     23 0.54210 72 25.6       1   157     21 0.123    24     No       4    99     17 0.29411 72 37.7       5    95     33 0.370    27     No       6   103     32 0.32412 74 25.9       9   134     33 0.460    81     No       8   126     38 0.16213 74 25.9       1    95     21 0.673    36     No       8   126     38 0.16214 78 27.6       5    88     30 0.258    37     No       6   125     31 0.56515 78 27.6      10   122     31 0.512    45     No       6   125     31 0.56516 78 39.4       2   112     50 0.175    24     No       4   112     40 0.23617 88 34.5       1   117     24 0.403    40    Yes       4   127     11 0.598   age.y type.y1     31     No2     21     No3     24     No4     21     No5     21     No6     43    Yes7     36    Yes8     40     No9     29    Yes10    28     No11    55     No12    39     No13    39     No14    49    Yes15    49    Yes16    38     No17    28     No[1] 17</code></pre><h3 id="melt-拆分数据和cast-数据重构"><a href="#melt-拆分数据和cast-数据重构" class="headerlink" title="melt()拆分数据和cast()数据重构"></a>melt()拆分数据和cast()数据重构</h3><p>R语言编程的一个最有趣的方面是关于在多个步骤中改变数据的形状以获得期望的形状。 用于执行此操作的函数称为melt()和cast()。</p><p>我们考虑称为船舶的数据集称为“MASS”。</p><pre><code>library(MASS)print(ships)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>     type year   period   service   incidents1     A   60     60        127         02     A   60     75         63         03     A   65     60       1095         34     A   65     75       1095         45     A   70     60       1512         6..........................8     A   75     75       2244         119     B   60     60      44882         3910    B   60     75      17176         2911    B   65     60      28609         58........................17    C   60     60      1179          118    C   60     75       552          119    C   65     60       781          0........................</code></pre><h3 id="melt-拆分数据"><a href="#melt-拆分数据" class="headerlink" title="melt()拆分数据"></a>melt()拆分数据</h3><p>现在我们拆分数据进行重组，将除类型和年份以外的所有列转换为多行展示。</p><pre><code>molten.ships &lt;- melt(ships, id = c("type","year"))print(molten.ships)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      type year  variable  value1      A   60    period      602      A   60    period      753      A   65    period      604      A   65    period      75........................9      B   60    period      6010     B   60    period      7511     B   65    period      6012     B   65    period      7513     B   70    period      60......................41     A   60    service    12742     A   60    service     6343     A   65    service   1095......................70     D   70    service   120871     D   75    service      072     D   75    service   205173     E   60    service     4574     E   60    service      075     E   65    service    789......................101    C   70    incidents    6102    C   70    incidents    2103    C   75    incidents    0104    C   75    incidents    1105    D   60    incidents    0106    D   60    incidents    0......................</code></pre><h3 id="cast-重构数据"><a href="#cast-重构数据" class="headerlink" title="cast()重构数据"></a>cast()重构数据</h3><p>我们可以将被拆分的数据转换为一种新形式，使用cast()函数创建每年每种类型的船的总和。</p><pre><code>recasted.ship &lt;- cast(molten.ships, type+year~variable,sum)print(recasted.ship)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>     type year  period  service  incidents1     A   60    135       190      02     A   65    135      2190      73     A   70    135      4865     244     A   75    135      2244     115     B   60    135     62058     686     B   65    135     48979    1117     B   70    135     20163     568     B   75    135      7117     189     C   60    135      1731      210    C   65    135      1457      111    C   70    135      2731      812    C   75    135       274      113    D   60    135       356      014    D   65    135       480      015    D   70    135      1557     1316    D   75    135      2051      417    E   60    135        45      018    E   65    135      1226     1419    E   70    135      3318     1720    E   75    135       542      1</code></pre><h1 id="十一-函数"><a href="#十一-函数" class="headerlink" title="十一.函数"></a>十一.函数</h1><p>函数是一组组合在一起以执行特定任务的语句。 R语言具有大量内置函数，用户可以创建自己的函数。</p><p>在R语言中，函数是一个对象，因此R语言解释器能够将控制传递给函数，以及函数完成动作所需的参数。</p><p>该函数依次执行其任务并将控制返回到解释器以及可以存储在其他对象中的任何结果。</p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>使用关键字函数创建R语言的函数。 R语言的函数定义的基本语法如下</p><pre><code>function_name &lt;- function(arg_1, arg_2, ...) {   Function body }</code></pre><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>函数的不同部分 -</p><ul><li><p>函数名称 -这是函数的实际名称。 它作为具有此名称的对象存储在R环境中。</p></li><li><p>参数 -参数是一个占位符。 当函数被调用时，你传递一个值到参数。 参数是可选的; 也就是说，一个函数可能不包含参数。 参数也可以有默认值。</p></li><li><p>函数体 -函数体包含定义函数的功能的语句集合。</p></li><li><p>返回值 -函数的返回值是要评估的函数体中的最后一个表达式。<br>R语言有许多内置函数，可以在程序中直接调用而无需先定义它们。我们还可以创建和使用我们自己的函数，称为用户定义的函数。</p></li></ul><h3 id="内置功能"><a href="#内置功能" class="headerlink" title="内置功能"></a>内置功能</h3><p>内置函数的简单示例是seq()，mean()，max()，sum(x)和paste(…)等。它们由用户编写的程序直接调用。 您可以参考最广泛使用的R函数。</p><pre><code># Create a sequence of numbers from 32 to 44.print(seq(32,44))# Find mean of numbers from 25 to 82.print(mean(25:82))# Find sum of numbers frm 41 to 68.print(sum(41:68))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 32 33 34 35 36 37 38 39 40 41 42 43 44[1] 53.5[1] 1526</code></pre><h3 id="用户定义的函数"><a href="#用户定义的函数" class="headerlink" title="用户定义的函数"></a>用户定义的函数</h3><p>我们可以在R语言中创建用户定义的函数。它们特定于用户想要的，一旦创建，它们就可以像内置函数一样使用。 下面是一个创建和使用函数的例子。</p><pre><code># Create a function to print squares of numbers in sequence.new.function &lt;- function(a) {   for(i in 1:a) {      b &lt;- i^2      print(b)   }}    </code></pre><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><pre><code># Create a function to print squares of numbers in sequence.new.function &lt;- function(a) {   for(i in 1:a) {      b &lt;- i^2      print(b)   }}# Call the function new.function supplying 6 as an argument.new.function(6)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 1[1] 4[1] 9[1] 16[1] 25[1] 36</code></pre><p>调用没有参数的函数</p><pre><code># Create a function without an argument.new.function &lt;- function() {   for(i in 1:5) {      print(i^2)   }}    # Call the function without supplying an argument.new.function()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 1[1] 4[1] 9[1] 16[1] 25</code></pre><p>使用参数值调用函数（按位置和名称）<br>函数调用的参数可以按照函数中定义的顺序提供，也可以以不同的顺序提供，但分配给参数的名称。</p><pre><code># Create a function with arguments.new.function &lt;- function(a,b,c) {   result &lt;- a * b + c   print(result)}# Call the function by position of arguments.new.function(5,3,11)# Call the function by names of the arguments.new.function(a = 11, b = 5, c = 3)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 26[1] 58</code></pre><p>使用默认参数调用函数<br>我们可以在函数定义中定义参数的值，并调用函数而不提供任何参数以获取默认结果。 但是我们也可以通过提供参数的新值来获得非默认结果来调用这样的函数。</p><pre><code># Create a function with arguments.new.function &lt;- function(a = 3, b = 6) {   result &lt;- a * b   print(result)}# Call the function without giving any argument.new.function()# Call the function with giving new values of the argument.new.function(9,5)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 18[1] 45</code></pre><p>功能的延迟计算<br>对函数的参数进行延迟评估，这意味着它们只有在函数体需要时才进行评估。</p><pre><code># Create a function with arguments.new.function &lt;- function(a, b) {   print(a^2)   print(a)   print(b)}# Evaluate the function without supplying one of the arguments.new.function(6)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 36[1] 6Error in print(b) : argument "b" is missing, with no default</code></pre><h1 id="十二-字符串"><a href="#十二-字符串" class="headerlink" title="十二.字符串"></a>十二.字符串</h1><p>在R语言中的单引号或双引号对中写入的任何值都被视为字符串.R语言存储的每个字符串都在双引号内，即使是使用单引号创建的依旧如此。</p><h3 id="在字符串构造中应用的规则"><a href="#在字符串构造中应用的规则" class="headerlink" title="在字符串构造中应用的规则"></a>在字符串构造中应用的规则</h3><p>在字符串的开头和结尾的引号应该是两个双引号或两个单引号。它们不能被混合。</p><ul><li><p>双引号可以插入到以单引号开头和结尾的字符串中。</p></li><li><p>单引号可以插入以双引号开头和结尾的字符串。</p></li><li><p>双引号不能插入以双引号开头和结尾的字符串。</p></li><li><p>单引号不能插入以单引号开头和结尾的字符串。</p></li></ul><h5 id="有效字符串的示例"><a href="#有效字符串的示例" class="headerlink" title="有效字符串的示例"></a>有效字符串的示例</h5><p>以下示例阐明了在ř 语言中创建³³字符串的规则。</p><pre><code>a &lt;- 'Start and end with single quote'print(a)b &lt;- "Start and end with double quotes"print(b)c &lt;- "single quote ' in between double quotes"print(c)d &lt;- 'Double quotes " in between single quote'print(d)</code></pre><p>当运行上面的代码，我们得到以下输出 -</p><pre><code>[1] "Start and end with single quote"[1] "Start and end with double quotes"[1] "single quote ' in between double quote"[1] "Double quote " in between single quote"</code></pre><h5 id="无效字符串的示例"><a href="#无效字符串的示例" class="headerlink" title="无效字符串的示例"></a>无效字符串的示例</h5><pre><code>e &lt;- 'Mixed quotes" print(e)f &lt;- 'Single quote ' inside single quote'print(f)g &lt;- "Double quotes " inside double quotes"print(g)</code></pre><p>当我们运行脚本失败给下面的结果。</p><pre><code>...: unexpected INCOMPLETE_STRING.... unexpected symbol 1: f &lt;- 'Single quote ' insideunexpected symbol1: g &lt;- "Double quotes " inside</code></pre><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h5 id="连接字符串-paste（）函数"><a href="#连接字符串-paste（）函数" class="headerlink" title="连接字符串 - paste（）函数"></a>连接字符串 - paste（）函数</h5><p>R 语言中的许多字符串使用paste（）函数组合。它可以采取任何数量的参数组合在一起。</p><p>#####语法<br>对于粘贴功能的基本语法是 -</p><pre><code>paste(..., sep = " ", collapse = NULL)</code></pre><p>以下是所使用的参数的说明 -</p><ul><li><p>…表示要组合的任意数量的自变量。</p></li><li><p>九月表示参数之间的任何分隔符。它是可选的。</p></li><li><p>collapse用于消除两个字符串之间的空格。但不是一个字符串的两个字内的空间。</p></li></ul><p>例</p><pre><code>a &lt;- "Hello"b &lt;- 'How'c &lt;- "are you? "print(paste(a,b,c))print(paste(a,b,c, sep = "-"))print(paste(a,b,c, sep = "", collapse = ""))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "Hello How are you? "[1] "Hello-How-are you? "[1] "HelloHoware you? "</code></pre><h5 id="格式化数字和字符串-format（）函数"><a href="#格式化数字和字符串-format（）函数" class="headerlink" title="格式化数字和字符串 - format（）函数"></a>格式化数字和字符串 - format（）函数</h5><p>可以使用格式（）函数将数字和字符串格式化为特定样式。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>格式化函数的基本语法是 -</p><pre><code>format(x, digits, nsmall, scientific, width, justify = c("left", "right", "centre", "none")) </code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>X是向量输入。</p></li><li><p>数字是显示的总位数。</p></li><li><p>nsmall是小数点右边的最小位数。</p></li><li><p>科学设置为TRUE以显示科学记数法。</p></li><li><p>宽度指示通过在开始处填充空白来显示的最小宽度。</p></li><li><p>理由是字符串向左，右或中心的显示。</p></li></ul><p>例</p><pre><code># Total number of digits displayed. Last digit rounded off.result &lt;- format(23.123456789, digits = 9)print(result)# Display numbers in scientific notation.result &lt;- format(c(6, 13.14521), scientific = TRUE)print(result)# The minimum number of digits to the right of the decimal point.result &lt;- format(23.47, nsmall = 5)print(result)# Format treats everything as a string.result &lt;- format(6)print(result)# Numbers are padded with blank in the beginning for width.result &lt;- format(13.7, width = 6)print(result)# Left justify strings.result &lt;- format("Hello", width = 8, justify = "l")print(result)# Justfy string with center.result &lt;- format("Hello", width = 8, justify = "c")print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "23.1234568"[1] "6.000000e+00" "1.314521e+01"[1] "23.47000"[1] "6"[1] "  13.7"[1] "Hello   "[1] " Hello  "</code></pre><h5 id="计算字符串中的字符数-nchar（）函数"><a href="#计算字符串中的字符数-nchar（）函数" class="headerlink" title="计算字符串中的字符数 - nchar（）函数"></a>计算字符串中的字符数 - nchar（）函数</h5><p>此函数计算字符串中包含空格的字符数。</p><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><p>nchar（）函数的基本语法是 -</p><p>nchar(x)<br>以下是所使用的参数的描述 - </p><ul><li>X是向量输入。</li></ul><p>例</p><pre><code>result &lt;- nchar("Count the number of characters")print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 30</code></pre><h5 id="更改案例-toupper（）和tolower（）函数"><a href="#更改案例-toupper（）和tolower（）函数" class="headerlink" title="更改案例 - toupper（）和tolower（）函数"></a>更改案例 - toupper（）和tolower（）函数</h5><p>这些函数改变字符串的字符的大小写。</p><h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><p>toupper（）和tolower（）函数的基本语法是 -</p><pre><code>toupper(x)tolower(x)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li>X是向量输入。</li></ul><p>例</p><pre><code># Changing to Upper case.result &lt;- toupper("Changing To Upper")print(result)# Changing to lower case.result &lt;- tolower("Changing To Lower")print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "CHANGING TO UPPER"[1] "changing to lower"</code></pre><h5 id="提取字符串的一部分-substring（）函数"><a href="#提取字符串的一部分-substring（）函数" class="headerlink" title="提取字符串的一部分 - substring（）函数"></a>提取字符串的一部分 - substring（）函数</h5><p>此函数提取字符串的部分。</p><h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h5><p>substring（）函数的基本语法是 -</p><pre><code>substring(x,first,last)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>X是字符向量输入。</p></li><li><p>首先是要提取的第一个字符的位置。</p></li><li><p>最后是要提取的最后一个字符的位置。</p></li></ul><p>例</p><pre><code># Extract characters from 5th to 7th position.result &lt;- substring("Extract", 5, 7)print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "act"</code></pre><h1 id="十三-向量"><a href="#十三-向量" class="headerlink" title="十三.向量"></a>十三.向量</h1><p>向量是最基本的R语言数据对象，有六种类型的原子向量。 它们是逻辑，整数，双精度，复杂，字符和原始。</p><h3 id="创建向量"><a href="#创建向量" class="headerlink" title="创建向量"></a>创建向量</h3><h5 id="单元素向量"><a href="#单元素向量" class="headerlink" title="单元素向量"></a>单元素向量</h5><p>即使在R语言中只写入一个值，它也将成为长度为1的向量，并且属于上述向量类型之一。</p><pre><code># Atomic vector of type character.print("abc");# Atomic vector of type double.print(12.5)# Atomic vector of type integer.print(63L)# Atomic vector of type logical.print(TRUE)# Atomic vector of type complex.print(2+3i)# Atomic vector of type raw.print(charToRaw('hello'))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "abc"[1] 12.5[1] 63[1] TRUE[1] 2+3i[1] 68 65 6c 6c 6f</code></pre><h5 id="多元素向量"><a href="#多元素向量" class="headerlink" title="多元素向量"></a>多元素向量</h5><p>对数值数据使用冒号运算符</p><pre><code># Creating a sequence from 5 to 13.v &lt;- 5:13print(v)# Creating a sequence from 6.6 to 12.6.v &lt;- 6.6:12.6print(v)# If the final element specified does not belong to the sequence then it is discarded.v &lt;- 3.8:11.4print(v)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1]  5  6  7  8  9 10 11 12 13[1]  6.6  7.6  8.6  9.6 10.6 11.6 12.6[1]  3.8  4.8  5.8  6.8  7.8  8.8  9.8 10.8</code></pre><h5 id="使用sequence-Seq-序列运算符"><a href="#使用sequence-Seq-序列运算符" class="headerlink" title="使用sequence (Seq.)序列运算符"></a>使用sequence (Seq.)序列运算符</h5><pre><code># Create vector with elements from 5 to 9 incrementing by 0.4.print(seq(5, 9, by = 0.4))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 5.0 5.4 5.8 6.2 6.6 7.0 7.4 7.8 8.2 8.6 9.0</code></pre><h5 id="使用C-函数"><a href="#使用C-函数" class="headerlink" title="使用C()函数"></a>使用C()函数</h5><p>如果其中一个元素是字符，则非字符值被强制转换为字符类型。</p><pre><code># The logical and numeric values are converted to characters.s &lt;- c('apple','red',5,TRUE)print(s)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "apple" "red"   "5"     "TRUE" </code></pre><h3 id="访问向量元素"><a href="#访问向量元素" class="headerlink" title="访问向量元素"></a>访问向量元素</h3><p>使用索引访问向量的元素。 []括号用于建立索引。 索引从位置1开始。在索引中给出负值会丢弃来自result.TRUE，FALSE或0和1的元素，也可用于索引。</p><pre><code># Accessing vector elements using position.t &lt;- c("Sun","Mon","Tue","Wed","Thurs","Fri","Sat")u &lt;- t[c(2,3,6)]print(u)# Accessing vector elements using logical indexing.v &lt;- t[c(TRUE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE)]print(v)# Accessing vector elements using negative indexing.x &lt;- t[c(-2,-5)]print(x)# Accessing vector elements using 0/1 indexing.y &lt;- t[c(0,0,0,0,0,0,1)]print(y)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "Mon" "Tue" "Fri"[1] "Sun" "Fri"[1] "Sun" "Tue" "Wed" "Fri" "Sat"[1] "Sun"</code></pre><h3 id="向量操作"><a href="#向量操作" class="headerlink" title="向量操作"></a>向量操作</h3><h5 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h5><p>可以添加，减去，相乘或相除两个相同长度的向量，将结果作为向量输出。</p><pre><code># Create two vectors.v1 &lt;- c(3,8,4,5,0,11)v2 &lt;- c(4,11,0,8,1,2)# Vector addition.add.result &lt;- v1+v2print(add.result)# Vector substraction.sub.result &lt;- v1-v2print(sub.result)# Vector multiplication.multi.result &lt;- v1*v2print(multi.result)# Vector division.divi.result &lt;- v1/v2print(divi.result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1]  7 19  4 13  1 13[1] -1 -3  4 -3 -1  9[1] 12 88  0 40  0 22[1] 0.7500000 0.7272727       Inf 0.6250000 0.0000000 5.5000000</code></pre><h5 id="向量元素回收"><a href="#向量元素回收" class="headerlink" title="向量元素回收"></a>向量元素回收</h5><p>如果我们对不等长的两个向量应用算术运算，则较短向量的元素被循环以完成操作。</p><pre><code>v1 &lt;- c(3,8,4,5,0,11)v2 &lt;- c(4,11)# V2 becomes c(4,11,4,11,4,11)add.result &lt;- v1+v2print(add.result)sub.result &lt;- v1-v2print(sub.result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1]  7 19  8 16  4 22[1] -1 -3  0 -6 -4  0</code></pre><h3 id="向量元素排序"><a href="#向量元素排序" class="headerlink" title="向量元素排序"></a>向量元素排序</h3><p>向量中的元素可以使用sort()函数排序。</p><pre><code>v &lt;- c(3,8,4,5,0,11, -9, 304)# Sort the elements of the vector.sort.result &lt;- sort(v)print(sort.result)# Sort the elements in the reverse order.revsort.result &lt;- sort(v, decreasing = TRUE)print(revsort.result)# Sorting character vectors.v &lt;- c("Red","Blue","yellow","violet")sort.result &lt;- sort(v)print(sort.result)# Sorting character vectors in reverse order.revsort.result &lt;- sort(v, decreasing = TRUE)print(revsort.result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1]  -9   0   3   4   5   8  11 304[1] 304  11   8   5   4   3   0  -9[1] "Blue"   "Red"    "violet" "yellow"[1] "yellow" "violet" "Red"    "Blue" </code></pre><p>#十四.列表<br>列表是R语言对象，它包含不同类型的元素，如数字，字符串，向量和其中的另一个列表。列表还可以包含矩阵或函数作为其元素。列表是使用list（）函数创建的。</p><h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><p>以下是创建包含字符串，数字，向量和逻辑值的列表的示例</p><pre><code># Create a list containing strings, numbers, vectors and a logical values.list_data &lt;- list("Red", "Green", c(21,32,11), TRUE, 51.23, 119.1)print(list_data)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[[1]][1] "Red"[[2]][1] "Green"[[3]][1] 21 32 11[[4]][1] TRUE[[5]][1] 51.23[[6]][1] 119.1</code></pre><h3 id="命名列表元素"><a href="#命名列表元素" class="headerlink" title="命名列表元素"></a>命名列表元素</h3><p>列表元素可以给出名称，并且可以使用这些名称访问它们。</p><pre><code># Create a list containing a vector, a matrix and a list.list_data &lt;- list(c("Jan","Feb","Mar"), matrix(c(3,9,5,1,-2,8), nrow = 2),   list("green",12.3))# Give names to the elements in the list.names(list_data) &lt;- c("1st Quarter", "A_Matrix", "A Inner list")# Show the list.print(list_data)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>$`1st_Quarter`[1] "Jan" "Feb" "Mar"$A_Matrix     [,1] [,2] [,3][1,]    3    5   -2[2,]    9    1    8$A_Inner_list$A_Inner_list[[1]][1] "green"$A_Inner_list[[2]][1] 12.3</code></pre><h3 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h3><p>列表的元素可以通过列表中元素的索引访问。在命名列表的情况下，它也可以使用名称来访问。</p><p>我们继续使用在上面的例子列表 -</p><pre><code># Create a list containing a vector, a matrix and a list.list_data &lt;- list(c("Jan","Feb","Mar"), matrix(c(3,9,5,1,-2,8), nrow = 2),   list("green",12.3))# Give names to the elements in the list.names(list_data) &lt;- c("1st Quarter", "A_Matrix", "A Inner list")# Access the first element of the list.print(list_data[1])# Access the thrid element. As it is also a list, all its elements will be printed.print(list_data[3])# Access the list element using the name of the element.print(list_data$A_Matrix)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>$`1st_Quarter`[1] "Jan" "Feb" "Mar"$A_Inner_list$A_Inner_list[[1]][1] "green"$A_Inner_list[[2]][1] 12.3     [,1] [,2] [,3][1,]    3    5   -2[2,]    9    1    8</code></pre><h3 id="操控列表元素"><a href="#操控列表元素" class="headerlink" title="操控列表元素"></a>操控列表元素</h3><p>我们可以添加，删除和更新列表元素，如下所示。我们只能在列表的末尾添加和删除元素。但我们可以更新任何元素。</p><pre><code># Create a list containing a vector, a matrix and a list.list_data &lt;- list(c("Jan","Feb","Mar"), matrix(c(3,9,5,1,-2,8), nrow = 2),   list("green",12.3))# Give names to the elements in the list.names(list_data) &lt;- c("1st Quarter", "A_Matrix", "A Inner list")# Add element at the end of the list.list_data[4] &lt;- "New element"print(list_data[4])# Remove the last element.list_data[4] &lt;- NULL# Print the 4th Element.print(list_data[4])# Update the 3rd Element.list_data[3] &lt;- "updated element"print(list_data[3])</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[[1]][1] "New element"$NULL$`A Inner list`[1] "updated element"</code></pre><h3 id="合并列表"><a href="#合并列表" class="headerlink" title="合并列表"></a>合并列表</h3><p>通过将所有列表放在一个列表（）函数中，您可以将许多列表合并到一个列表中。</p><pre><code># Create two lists.list1 &lt;- list(1,2,3)list2 &lt;- list("Sun","Mon","Tue")# Merge the two lists.merged.list &lt;- c(list1,list2)# Print the merged list.print(merged.list)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[[1]][1] 1[[2]][1] 2[[3]][1] 3[[4]][1] "Sun"[[5]][1] "Mon"[[6]][1] "Tue"</code></pre><h3 id="将列表转换为向量"><a href="#将列表转换为向量" class="headerlink" title="将列表转换为向量"></a>将列表转换为向量</h3><p>列表可以转换为向量，使得向量的元素可以用于进一步的操作。可以在将列表转换为向量之后应用对向量的所有算术运算。要做这个转换，我们使用unlist（）函数。它将列表作为输入并生成向量。</p><pre><code># Create lists.list1 &lt;- list(1:5)print(list1)list2 &lt;-list(10:14)print(list2)# Convert the lists to vectors.v1 &lt;- unlist(list1)v2 &lt;- unlist(list2)print(v1)print(v2)# Now add the vectorsresult &lt;- v1+v2print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[[1]][1] 1 2 3 4 5[[1]][1] 10 11 12 13 14[1] 1 2 3 4 5[1] 10 11 12 13 14[1] 11 13 15 17 19</code></pre><h1 id="十五-矩阵"><a href="#十五-矩阵" class="headerlink" title="十五.矩阵"></a>十五.矩阵</h1><p>矩阵是其中元素以二维矩形布局布置的R对象。 它们包含相同原子类型的元素。 虽然我们可以创建一个只包含字符或只包含逻辑值的矩阵，但它们没有太多用处。 我们使用包含数字元素的矩阵用于数学计算。</p><p>使用matrix()函数创建一个矩阵。</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>在R语言中创建矩阵的基本语法是 -</p><pre><code>matrix(data, nrow, ncol, byrow, dimnames)</code></pre><p>以下是所使用的参数的说明 -</p><ul><li><p>数据是成为矩阵的数据元素的输入向量。</p></li><li><p>nrow是要创建的行数。</p></li><li><p>ncol是要创建的列数。</p></li><li><p>byrow是一个逻辑线索。 如果为TRUE，则输入向量元素按行排列。</p></li><li><p>dimname是分配给行和列的名称。</p></li></ul><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>创建一个以数字向量作为输入的矩阵</p><pre><code># Elements are arranged sequentially by row.M &lt;- matrix(c(3:14), nrow = 4, byrow = TRUE)print(M)# Elements are arranged sequentially by column.N &lt;- matrix(c(3:14), nrow = 4, byrow = FALSE)print(N)# Define the column and row names.rownames = c("row1", "row2", "row3", "row4")colnames = c("col1", "col2", "col3")P &lt;- matrix(c(3:14), nrow = 4, byrow = TRUE, dimnames = list(rownames, colnames))print(P)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>     [,1] [,2] [,3][1,]    3    4    5[2,]    6    7    8[3,]    9   10   11[4,]   12   13   14     [,1] [,2] [,3][1,]    3    7   11[2,]    4    8   12[3,]    5    9   13[4,]    6   10   14     col1 col2 col3row1    3    4    5row2    6    7    8row3    9   10   11row4   12   13   14</code></pre><h3 id="访问矩阵的元素"><a href="#访问矩阵的元素" class="headerlink" title="访问矩阵的元素"></a>访问矩阵的元素</h3><p>可以通过使用元素的列和行索引来访问矩阵的元素。 我们考虑上面的矩阵P找到下面的具体元素。</p><pre><code># Define the column and row names.rownames = c("row1", "row2", "row3", "row4")colnames = c("col1", "col2", "col3")# Create the matrix.P &lt;- matrix(c(3:14), nrow = 4, byrow = TRUE, dimnames = list(rownames, colnames))# Access the element at 3rd column and 1st row.print(P[1,3])# Access the element at 2nd column and 4th row.print(P[4,2])# Access only the  2nd row.print(P[2,])# Access only the 3rd column.print(P[,3])</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 5[1] 13col1 col2 col3    6    7    8 row1 row2 row3 row4    5    8   11   14 </code></pre><h3 id="矩阵计算"><a href="#矩阵计算" class="headerlink" title="矩阵计算"></a>矩阵计算</h3><p>使用R运算符对矩阵执行各种数学运算。 操作的结果也是一个矩阵。<br>对于操作中涉及的矩阵，维度（行数和列数）应该相同。</p><h5 id="矩阵加法和减法"><a href="#矩阵加法和减法" class="headerlink" title="矩阵加法和减法"></a>矩阵加法和减法</h5><pre><code># Create two 2x3 matrices.matrix1 &lt;- matrix(c(3, 9, -1, 4, 2, 6), nrow = 2)print(matrix1)matrix2 &lt;- matrix(c(5, 2, 0, 9, 3, 4), nrow = 2)print(matrix2)# Add the matrices.result &lt;- matrix1 + matrix2cat("Result of addition","")print(result)# Subtract the matricesresult &lt;- matrix1 - matrix2cat("Result of subtraction","")print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>     [,1] [,2] [,3][1,]    3   -1    2[2,]    9    4    6     [,1] [,2] [,3][1,]    5    0    3[2,]    2    9    4Result of addition      [,1] [,2] [,3][1,]    8   -1    5[2,]   11   13   10Result of subtraction      [,1] [,2] [,3][1,]   -2   -1   -1[2,]    7   -5    2</code></pre><h5 id="矩阵乘法和除法"><a href="#矩阵乘法和除法" class="headerlink" title="矩阵乘法和除法"></a>矩阵乘法和除法</h5><pre><code># Create two 2x3 matrices.matrix1 &lt;- matrix(c(3, 9, -1, 4, 2, 6), nrow = 2)print(matrix1)matrix2 &lt;- matrix(c(5, 2, 0, 9, 3, 4), nrow = 2)print(matrix2)# Multiply the matrices.result &lt;- matrix1 * matrix2cat("Result of multiplication","")print(result)# Divide the matricesresult &lt;- matrix1 / matrix2cat("Result of division","")print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>     [,1] [,2] [,3][1,]    3   -1    2[2,]    9    4    6     [,1] [,2] [,3][1,]    5    0    3[2,]    2    9    4Result of multiplication      [,1] [,2] [,3][1,]   15    0    6[2,]   18   36   24Result of division      [,1]      [,2]      [,3][1,]  0.6      -Inf 0.6666667[2,]  4.5 0.4444444 1.5000000</code></pre><h1 id="十六-数组"><a href="#十六-数组" class="headerlink" title="十六.数组"></a>十六.数组</h1><p>数组对可以在两个以上维度中存储数据的R数据对象。例如 - 如果我们创建一个维度（2,3,4）的数组，则它创造4个矩形矩阵，每个矩阵具有2行和3列数组只能存储数据类型。<br>使用array（）函数创建数组。它使用向量作为输入，并使用dim参数中的值创建数组。</p><h3 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h3><p>以下示例创建一个由两个3x3的矩阵组成的数组，每个矩阵具有3行和3列。</p><pre><code># Create two vectors of different lengths.vector1 &lt;- c(5,9,3)vector2 &lt;- c(10,11,12,13,14,15)# Take these vectors as input to the array.result &lt;- array(c(vector1,vector2),dim = c(3,3,2))print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>, , 1     [,1] [,2] [,3][1,]    5   10   13[2,]    9   11   14[3,]    3   12   15, , 2     [,1] [,2] [,3][1,]    5   10   13[2,]    9   11   14[3,]    3   12   15</code></pre><h3 id="命名列和行"><a href="#命名列和行" class="headerlink" title="命名列和行"></a>命名列和行</h3><p>我们可以使用dimnames参数给数组中的行，列和矩阵命名。</p><pre><code># Create two vectors of different lengths.vector1 &lt;- c(5,9,3)vector2 &lt;- c(10,11,12,13,14,15)column.names &lt;- c("COL1","COL2","COL3")row.names &lt;- c("ROW1","ROW2","ROW3")matrix.names &lt;- c("Matrix1","Matrix2")# Take these vectors as input to the array.result &lt;- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,   matrix.names))print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>, , Matrix1     COL1 COL2 COL3ROW1    5   10   13ROW2    9   11   14ROW3    3   12   15, , Matrix2     COL1 COL2 COL3ROW1    5   10   13ROW2    9   11   14ROW3    3   12   15</code></pre><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><pre><code># Create two vectors of different lengths.vector1 &lt;- c(5,9,3)vector2 &lt;- c(10,11,12,13,14,15)column.names &lt;- c("COL1","COL2","COL3")row.names &lt;- c("ROW1","ROW2","ROW3")matrix.names &lt;- c("Matrix1","Matrix2")# Take these vectors as input to the array.result &lt;- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,   column.names, matrix.names))# Print the third row of the second matrix of the array.print(result[3,,2])# Print the element in the 1st row and 3rd column of the 1st matrix.print(result[1,3,1])# Print the 2nd Matrix.print(result[,,2])</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>COL1 COL2 COL3    3   12   15 [1] 13     COL1 COL2 COL3ROW1    5   10   13ROW2    9   11   14ROW3    3   12   15</code></pre><h3 id="操作数组元素"><a href="#操作数组元素" class="headerlink" title="操作数组元素"></a>操作数组元素</h3><p>由于数组由多维构成矩阵，所以对数组元素的操作通过访问矩阵的元素来执行。</p><pre><code># Create two vectors of different lengths.vector1 &lt;- c(5,9,3)vector2 &lt;- c(10,11,12,13,14,15)# Take these vectors as input to the array.array1 &lt;- array(c(vector1,vector2),dim = c(3,3,2))# Create two vectors of different lengths.vector3 &lt;- c(9,1,0)vector4 &lt;- c(6,0,11,3,14,1,2,6,9)array2 &lt;- array(c(vector1,vector2),dim = c(3,3,2))# create matrices from these arrays.matrix1 &lt;- array1[,,2]matrix2 &lt;- array2[,,2]# Add the matrices.result &lt;- matrix1+matrix2print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>     [,1] [,2] [,3][1,]   10   20   26[2,]   18   22   28[3,]    6   24   30</code></pre><h3 id="跨数组元素的计算"><a href="#跨数组元素的计算" class="headerlink" title="跨数组元素的计算"></a>跨数组元素的计算</h3><p>我们可以使用适用（）函数在数组中的元素上进行计算。</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><pre><code>apply(x, margin, fun)</code></pre><p>以下是所使用的参数的说明 -</p><ul><li><p>X是一个数组。</p></li><li><p>保证金是所使用的数据集的名称。</p></li><li><p>有趣的是要应用于数组元素的函数。</p></li></ul><p>例<br>我们使用下面的适用（）函数计算所有矩阵中数组行中元素的总和。</p><pre><code># Create two vectors of different lengths.vector1 &lt;- c(5,9,3)vector2 &lt;- c(10,11,12,13,14,15)# Take these vectors as input to the array.new.array &lt;- array(c(vector1,vector2),dim = c(3,3,2))print(new.array)# Use apply to calculate the sum of the rows across all the matrices.result &lt;- apply(new.array, c(1), sum)print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>, , 1     [,1] [,2] [,3][1,]    5   10   13[2,]    9   11   14[3,]    3   12   15, , 2     [,1] [,2] [,3][1,]    5   10   13[2,]    9   11   14[3,]    3   12   15[1] 56 68 60</code></pre><p>#十七.因子<br>因子是用于对数据进行分类并将其存储为级别的数据对象。 它们可以存储字符串和整数。 它们在具有有限数量的唯一值的列中很有用。 像“男性”，“女性”和True，False等。它们在统计建模的数据分析中很有用。<br>使用factor()函数通过将向量作为输入创建因子。<br>例</p><pre><code># Create a vector as input.data &lt;- c("East","West","East","North","North","East","West","West","West","East","North")print(data)print(is.factor(data))# Apply the factor function.factor_data &lt;- factor(data)print(factor_data)print(is.factor(factor_data))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code> [1] "East"  "West"  "East"  "North" "North" "East"  "West"  "West"  "West"  "East" "North"[1] FALSE [1] East  West  East  North North East  West  West  West  East  NorthLevels: East North West[1] TRUE</code></pre><h3 id="数据帧的因子"><a href="#数据帧的因子" class="headerlink" title="数据帧的因子"></a>数据帧的因子</h3><p>在创建具有文本数据列的任何数据框时，R语言将文本列视为分类数据并在其上创建因子。</p><pre><code># Create the vectors for data frame.height &lt;- c(132,151,162,139,166,147,122)weight &lt;- c(48,49,66,53,67,52,40)gender &lt;- c("male","male","female","female","male","female","male")# Create the data frame.input_data &lt;- data.frame(height,weight,gender)print(input_data)# Test if the gender column is a factor.print(is.factor(input_data$gender))# Print the gender column so see the levels.print(input_data$gender)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>  height weight gender1    132     48   male2    151     49   male3    162     66 female4    139     53 female5    166     67   male6    147     52 female7    122     40   male[1] TRUE[1] male   male   female female male   female male  Levels: female male</code></pre><h3 id="更改级别顺序"><a href="#更改级别顺序" class="headerlink" title="更改级别顺序"></a>更改级别顺序</h3><p>可以通过使用新的等级次序再次应用因子函数来改变因子中的等级的顺序。</p><pre><code>data &lt;- c("East","West","East","North","North","East","West","West","West","East","North")# Create the factorsfactor_data &lt;- factor(data)print(factor_data)# Apply the factor function with required order of the level.new_order_data &lt;- factor(factor_data,levels = c("East","West","North"))print(new_order_data)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code> [1] East  West  East  North North East  West  West  West  East  NorthLevels: East North West [1] East  West  East  North North East  West  West  West  East  NorthLevels: East West North</code></pre><h3 id="生成因子级别"><a href="#生成因子级别" class="headerlink" title="生成因子级别"></a>生成因子级别</h3><p>我们可以使用gl()函数生成因子级别。 它需要两个整数作为输入，指示每个级别有多少级别和多少次。</p><p>语法</p><pre><code>gl(n, k, labels)</code></pre><p>以下是所使用的参数的说明 -</p><ul><li><p>n是给出级数的整数。</p></li><li><p>k是给出复制数目的整数。</p></li><li><p>labels是所得因子水平的标签向量。</p></li></ul><p>例</p><pre><code>v &lt;- gl(3, 4, labels = c("Tampa", "Seattle","Boston"))print(v)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Tampa   Tampa   Tampa   Tampa   Seattle Seattle Seattle Seattle Boston [10] Boston  Boston  Boston Levels: Tampa Seattle Boston</code></pre><p>#十八.数据帧<br>数据帧是表或二维阵列状结构，其中每一列包含一个变量的值，并且每一行包含来自每一列的一组值。<br>以下是数据帧的特性。</p><ul><li><p>列名称应为非空。</p></li><li><p>行名称应该是唯一的。</p></li><li><p>存储在数据帧中的数据可以是数字，因子或字符类型。</p></li><li><p>每个列应包含相同数量的数据项。</p><h3 id="创建数据帧"><a href="#创建数据帧" class="headerlink" title="创建数据帧"></a>创建数据帧</h3><pre><code># Create the data frame.emp.data &lt;- data.frame( emp_id = c (1:5),  emp_name = c("Rick","Dan","Michelle","Ryan","Gary"), salary = c(623.3,515.2,611.0,729.0,843.25),  start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11",    "2015-03-27")), stringsAsFactors = FALSE)# Print the data frame.            print(emp.data) </code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>emp_id    emp_name     salary     start_date1     1     Rick        623.30     2012-01-012     2     Dan         515.20     2013-09-233     3     Michelle    611.00     2014-11-154     4     Ryan        729.00     2014-05-115     5     Gary        843.25     2015-03-27</code></pre><h3 id="获取数据帧的结构"><a href="#获取数据帧的结构" class="headerlink" title="获取数据帧的结构"></a>获取数据帧的结构</h3><p>通过使用str()函数可以看到数据帧的结构。</p><pre><code># Create the data frame.emp.data &lt;- data.frame( emp_id = c (1:5),  emp_name = c("Rick","Dan","Michelle","Ryan","Gary"), salary = c(623.3,515.2,611.0,729.0,843.25),  start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11",    "2015-03-27")), stringsAsFactors = FALSE)# Get the structure of the data frame.str(emp.data)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>'data.frame':   5 obs. of  4 variables:$ emp_id    : int  1 2 3 4 5$ emp_name  : chr  "Rick" "Dan" "Michelle" "Ryan" ...$ salary    : num  623 515 611 729 843$ start_date: Date, format: "2012-01-01" "2013-09-23" "2014-11-15" "2014-05-11" ...</code></pre><h3 id="数据框中的数据摘要"><a href="#数据框中的数据摘要" class="headerlink" title="数据框中的数据摘要"></a>数据框中的数据摘要</h3><p>可以通过应用summary()函数获取数据的统计摘要和性质。</p><pre><code># Create the data frame.emp.data &lt;- data.frame( emp_id = c (1:5),  emp_name = c("Rick","Dan","Michelle","Ryan","Gary"), salary = c(623.3,515.2,611.0,729.0,843.25),  start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11",    "2015-03-27")), stringsAsFactors = FALSE)# Print the summary.print(summary(emp.data))  </code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>   emp_id    emp_name             salary        start_date        Min.   :1   Length:5           Min.   :515.2   Min.   :2012-01-01  1st Qu.:2   Class :character   1st Qu.:611.0   1st Qu.:2013-09-23  Median :3   Mode  :character   Median :623.3   Median :2014-05-11  Mean   :3                      Mean   :664.4   Mean   :2014-01-14  3rd Qu.:4                      3rd Qu.:729.0   3rd Qu.:2014-11-15  Max.   :5                      Max.   :843.2   Max.   :2015-03-27 </code></pre><h3 id="从数据帧提取数据"><a href="#从数据帧提取数据" class="headerlink" title="从数据帧提取数据"></a>从数据帧提取数据</h3><p>使用列名称从数据框中提取特定列。</p><pre><code># Create the data frame.emp.data &lt;- data.frame( emp_id = c (1:5), emp_name = c("Rick","Dan","Michelle","Ryan","Gary"), salary = c(623.3,515.2,611.0,729.0,843.25), start_date = as.Date(c("2012-01-01","2013-09-23","2014-11-15","2014-05-11",    "2015-03-27")), stringsAsFactors = FALSE)# Extract Specific columns.result &lt;- data.frame(emp.data$emp_name,emp.data$salary)print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>emp.data.emp_name emp.data.salary1              Rick          623.302               Dan          515.203          Michelle          611.004              Ryan          729.005              Gary          843.25</code></pre><p>先提取前两行，然后提取所有列</p><pre><code># Create the data frame.emp.data &lt;- data.frame( emp_id = c (1:5), emp_name = c("Rick","Dan","Michelle","Ryan","Gary"), salary = c(623.3,515.2,611.0,729.0,843.25), start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11",    "2015-03-27")), stringsAsFactors = FALSE)# Extract first two rows.result &lt;- emp.data[1:2,]print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>emp_id    emp_name   salary    start_date1      1     Rick      623.3     2012-01-012      2     Dan       515.2     2013-09-23</code></pre><p>用第2和第4列提取第3和第5行</p><pre><code># Create the data frame.emp.data &lt;- data.frame( emp_id = c (1:5),  emp_name = c("Rick","Dan","Michelle","Ryan","Gary"), salary = c(623.3,515.2,611.0,729.0,843.25),   start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11",    "2015-03-27")), stringsAsFactors = FALSE)# Extract 3rd and 5th row with 2nd and 4th column.result &lt;- emp.data[c(3,5),c(2,4)]print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>emp_name start_date3 Michelle 2014-11-155     Gary 2015-03-27</code></pre><h3 id="扩展数据帧"><a href="#扩展数据帧" class="headerlink" title="扩展数据帧"></a>扩展数据帧</h3><p>可以通过添加列和行来扩展数据帧。</p></li></ul><h3 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h3><p>只需使用新的列名称添加列向量。</p><pre><code># Create the data frame.emp.data &lt;- data.frame(   emp_id = c (1:5),    emp_name = c("Rick","Dan","Michelle","Ryan","Gary"),   salary = c(623.3,515.2,611.0,729.0,843.25),    start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11",      "2015-03-27")),   stringsAsFactors = FALSE)# Add the "dept" coulmn.emp.data$dept &lt;- c("IT","Operations","IT","HR","Finance")v &lt;- emp.dataprint(v)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>  emp_id   emp_name    salary    start_date       dept1     1    Rick        623.30    2012-01-01       IT2     2    Dan         515.20    2013-09-23       Operations3     3    Michelle    611.00    2014-11-15       IT4     4    Ryan        729.00    2014-05-11       HR5     5    Gary        843.25    2015-03-27       Finance</code></pre><h3 id="添加行"><a href="#添加行" class="headerlink" title="添加行"></a>添加行</h3><p>要将更多行永久添加到现有数据帧，我们需要引入与现有数据帧相同结构的新行，并使用rbind()函数。<br>在下面的示例中，我们创建一个包含新行的数据帧，并将其与现有数据帧合并以创建最终数据帧。</p><pre><code># Create the first data frame.emp.data &lt;- data.frame(   emp_id = c (1:5),    emp_name = c("Rick","Dan","Michelle","Ryan","Gary"),   salary = c(623.3,515.2,611.0,729.0,843.25),    start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11",      "2015-03-27")),   dept = c("IT","Operations","IT","HR","Finance"),   stringsAsFactors = FALSE)# Create the second data frameemp.newdata &lt;-     data.frame(   emp_id = c (6:8),    emp_name = c("Rasmi","Pranab","Tusar"),   salary = c(578.0,722.5,632.8),    start_date = as.Date(c("2013-05-21","2013-07-30","2014-06-17")),   dept = c("IT","Operations","Fianance"),   stringsAsFactors = FALSE)# Bind the two data frames.emp.finaldata &lt;- rbind(emp.data,emp.newdata)print(emp.finaldata)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>  emp_id     emp_name    salary     start_date       dept1      1     Rick        623.30     2012-01-01       IT2      2     Dan         515.20     2013-09-23       Operations3      3     Michelle    611.00     2014-11-15       IT4      4     Ryan        729.00     2014-05-11       HR5      5     Gary        843.25     2015-03-27       Finance6      6     Rasmi       578.00     2013-05-21       IT7      7     Pranab      722.50     2013-07-30       Operations8      8     Tusar       632.80     2014-06-17       Fianance</code></pre><h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h3 id="1-条形图"><a href="#1-条形图" class="headerlink" title="1.条形图"></a>1.条形图</h3><p>条形图表示矩形条中的数据，条的长度与变量的值成比例。 R语言使用函数barplot()创建条形图。 R语言可以在条形图中绘制垂直和水平条。 在条形图中，每个条可以给予不同的颜色。</p><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><p>在R语言中创建条形图的基本语法是 -</p><pre><code>barplot(H, xlab, ylab, main, names.arg, col)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>H是包含在条形图中使用的数值的向量或矩阵。</p></li><li><p>xlab是x轴的标签。</p></li><li><p>ylab是y轴的标签。</p></li><li><p>main是条形图的标题。</p></li><li><p>names.arg是在每个条下出现的名称的向量。</p></li><li><p>col用于向图中的条形提供颜色。</p></li></ul><h3 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h3><p>使用输入向量和每个条的名称创建一个简单的条形图。<br>以下脚本将创建并保存当前R语言工作目录中的条形图。</p><pre><code># Give the chart file a name.png(file = "barchart.png")# Plot the bar chart.barplot(H)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-af941155a8438fb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="，使用R条形图"></p><h3 id="条形图标签，标题和颜色"><a href="#条形图标签，标题和颜色" class="headerlink" title="条形图标签，标题和颜色"></a>条形图标签，标题和颜色</h3><p>可以通过添加更多参数来扩展条形图的功能。 主要参数用于添加标题。 col参数用于向条形添加颜色。 args.name是具有与输入向量相同数量的值的向量，以描述每个条的含义。</p><h3 id="例-3"><a href="#例-3" class="headerlink" title="例"></a>例</h3><p>以下脚本将在当前R语言工作目录中创建并保存条形图。</p><pre><code># Create the data for the chart.H &lt;- c(7,12,28,3,41)M &lt;- c("Mar","Apr","May","Jun","Jul")# Give the chart file a name.png(file = "barchart_months_revenue.png")# Plot the bar chart.barplot(H,names.arg = M,xlab = "Month",ylab = "Revenue",col = "blue",main = "Revenue chart",border = "red")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a3dc0f0b8e0d50aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="条形图使用R型"></p><h3 id="组合条形图和堆积条形图"><a href="#组合条形图和堆积条形图" class="headerlink" title="组合条形图和堆积条形图"></a>组合条形图和堆积条形图</h3><p>我们可以使用矩阵作为输入值，在每个条中创建条形图和堆叠组的条形图。<br>超过两个变量表示为用于创建组合条形图和堆叠条形图的矩阵。</p><pre><code># Create the input vectors.colors &lt;- c("green","orange","brown")months &lt;- c("Mar","Apr","May","Jun","Jul")regions &lt;- c("East","West","North")# Create the matrix of the values.Values &lt;- matrix(c(2,9,3,11,9,4,8,7,3,12,5,2,8,10,11),nrow = 3,ncol = 5,byrow = TRUE)# Give the chart file a name.png(file = "barchart_stacked.png")# Create the bar chart.barplot(Values,main = "total revenue",names.arg = months,xlab = "month",ylab = "revenue",   col = colors)# Add the legend to the chart.legend("topleft", regions, cex = 1.3, fill = colors)# Save the file.dev.off()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-3ef47da5f49d5985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="，使用R堆叠条形图"></p><h1 id="2-箱线图"><a href="#2-箱线图" class="headerlink" title="2.箱线图"></a>2.箱线图</h1><p>箱线图是数据集中的数据分布良好的度量。 它将数据集分成三个四分位数。 此图表表示数据集中的最小值，最大值，中值，第一四分位数和第三四分位数。 它还可用于通过绘制每个数据集的箱线图来比较数据集之间的数据分布。</p><p>R语言中使用boxplot()函数来创建箱线图。</p><h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><p>在R语言中创建箱线图的基本语法是 -</p><pre><code>boxplot(x, data, notch, varwidth, names, main)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>x是向量或公式。</p></li><li><p>数据是数据帧。</p></li><li><p>notch是逻辑值。 设置为TRUE以绘制凹口。</p></li><li><p>varwidth是一个逻辑值。 设置为true以绘制与样本大小成比例的框的宽度。</p></li><li><p>names是将打印在每个箱线图下的组标签。</p></li><li><p>main用于给图表标题。</p></li></ul><h3 id="例-4"><a href="#例-4" class="headerlink" title="例"></a>例</h3><p>我们使用R语言环境中可用的数据集“mtcars”来创建基本箱线图。 让我们看看mtcars中的列“mpg”和“cyl”。</p><pre><code>input &lt;- mtcars[,c('mpg','cyl')]print(head(input))</code></pre><p>当我们执行上面的代码，它会产生以下结果 -</p><pre><code>                  mpg  cylMazda RX4         21.0   6Mazda RX4 Wag     21.0   6Datsun 710        22.8   4Hornet 4 Drive    21.4   6Hornet Sportabout 18.7   8Valiant           18.1   6</code></pre><h3 id="创建箱线图"><a href="#创建箱线图" class="headerlink" title="创建箱线图"></a>创建箱线图</h3><p>以下脚本将为mpg（英里/加仑）和cyl（气缸数）之间的关系创建箱线图。</p><pre><code># Give the chart file a name.png(file = "boxplot.png")# Plot the chart.boxplot(mpg ~ cyl, data = mtcars, xlab = "Number of Cylinders",   ylab = "Miles Per Gallon", main = "Mileage Data")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-7cc9e4b9fd59b64c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="#"></p><h3 id="带槽的箱线图"><a href="#带槽的箱线图" class="headerlink" title="带槽的箱线图"></a>带槽的箱线图</h3><p>我们可以绘制带槽的箱线图，以了解不同数据组的中值如何相互匹配。<br>以下脚本将为每个数据组创建一个带缺口的箱线图。</p><pre><code># Give the chart file a name.png(file = "boxplot_with_notch.png")# Plot the chart.boxplot(mpg ~ cyl, data = mtcars,    xlab = "Number of Cylinders",   ylab = "Miles Per Gallon",    main = "Mileage Data",   notch = TRUE,    varwidth = TRUE,    col = c("green","yellow","purple"),   names = c("High","Medium","Low"))# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p>[图片上传中…(image-9f3e39-1552623568628-0)]</p><h1 id="3-直方图"><a href="#3-直方图" class="headerlink" title="3.直方图"></a>3.直方图</h1><p>直方图表示被存储到范围中的变量的值的频率。 直方图类似于条形图，但不同之处在于将值分组为连续范围。 直方图中的每个柱表示该范围中存在的值的数量的高度。</p><p>R语言使用hist()函数创建直方图。 此函数使用向量作为输入，并使用一些更多的参数来绘制直方图。</p><h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><p>使用R语言创建直方图的基本语法是 -</p><pre><code>hist(v,main,xlab,xlim,ylim,breaks,col,border)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>v是包含直方图中使用的数值的向量。</p></li><li><p>main表示图表的标题。</p></li><li><p>col用于设置条的颜色。</p></li><li><p>border用于设置每个条的边框颜色。</p></li><li><p>xlab用于给出x轴的描述。</p></li><li><p>xlim用于指定x轴上的值的范围。</p></li><li><p>ylim用于指定y轴上的值的范围。</p></li><li><p>break用于提及每个条的宽度。</p></li></ul><h3 id="例-5"><a href="#例-5" class="headerlink" title="例"></a>例</h3><p>使用输入vector，label，col和边界参数创建一个简单的直方图。<br>下面给出的脚本将创建并保存当前R语言工作目录中的直方图。</p><pre><code># Create data for the graph.v &lt;-  c(9,13,21,8,36,22,12,41,31,33,19)# Give the chart file a name.png(file = "histogram.png")# Create the histogram.hist(v,xlab = "Weight",col = "yellow",border = "blue")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-454ddc512d1ede06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="直方图诉"></p><h3 id="X和Y值的范围"><a href="#X和Y值的范围" class="headerlink" title="X和Y值的范围"></a>X和Y值的范围</h3><p>要指定X轴和Y轴允许的值的范围，我们可以使用<strong>xlim</strong>和<strong>ylim</strong>参数。<br>每个条的宽度可以通过使用间隔来确定。</p><pre><code># Create data for the graph.v &lt;- c(9,13,21,8,36,22,12,41,31,33,19)# Give the chart file a name.png(file = "histogram_lim_breaks.png")# Create the histogram.hist(v,xlab = "Weight",col = "green",border = "red", xlim = c(0,40), ylim = c(0,5),   breaks = 5)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p>[图片上传中…(image-d6f09b-1552623852107-0)]</p><h1 id="4-折线图"><a href="#4-折线图" class="headerlink" title="4.折线图"></a>4.折线图</h1><p>折线图是通过在它们之间绘制线段来连接一系列点的图。这些点在它们的坐标（通常是x坐标）值之一中排序。折线图通常用于识别数据中的趋势。</p><p>R语言中的情节（）函数用于创建折线图。</p><p>###语法<br>在R语言中创建折线图的基本语法是 -</p><pre><code>plot(v,type,col,xlab,ylab)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>是包含数值的向量。</p></li><li><p>类型采用值“P”仅绘制点，“升”仅绘制线和“o”的绘制点和线。</p></li><li><p>xlab是X轴的标签。</p></li><li><p>ylab是Ÿ轴的标签。</p></li><li><p>主要是图表的标题。</p></li><li><p>山坳用于给点和线的颜色。</p><h3 id="例-6"><a href="#例-6" class="headerlink" title="例"></a>例</h3></li></ul><p>使用输入向量和类型参数“O”创建简单的折线图。以下脚本将在当前R工作目录中创建并保存折线图。</p><pre><code># Create the data for the chart.v &lt;- c(7,12,28,3,41)# Give the chart file a name.png(file = "line_chart.jpg")# Plot the bar chart. plot(v,type = "o")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p>[图片上传中…(image-469771-1552624000469-2)]</p><h3 id="折线图标题，颜色和标签"><a href="#折线图标题，颜色和标签" class="headerlink" title="折线图标题，颜色和标签"></a>折线图标题，颜色和标签</h3><p>线图的特征可以通过使用附加参数来扩展。我们向点和线添加颜色，为图表添加标题，并向轴添加标签。</p><h3 id="例-7"><a href="#例-7" class="headerlink" title="例"></a>例</h3><pre><code># Create the data for the chart.v &lt;- c(7,12,28,3,41)# Give the chart file a name.png(file = "line_chart_label_colored.jpg")# Plot the bar chart.plot(v,type = "o", col = "red", xlab = "Month", ylab = "Rain fall",   main = "Rain fall chart")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-72f5dbe282491b3f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="折线图标记在ř型"></p><h3 id="多线型折线图"><a href="#多线型折线图" class="headerlink" title="多线型折线图"></a>多线型折线图</h3><p>通过使用lines（）函数，可以在同一个图表上绘制多条线。<br>在绘制第一行之后，lines （）函数可以使用一个额外的向量作为输入来绘制图表中的第二行。</p><pre><code># Create the data for the chart.v &lt;- c(7,12,28,3,41)t &lt;- c(14,7,6,19,3)# Give the chart file a name.png(file = "line_chart_2_lines.jpg")# Plot the bar chart.plot(v,type = "o",col = "red", xlab = "Month", ylab = "Rain fall",    main = "Rain fall chart")lines(t, type = "o", col = "blue")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-d6bf122981e16411.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="折线图与ř中多行"></p><h1 id="5-散点图"><a href="#5-散点图" class="headerlink" title="5.散点图"></a>5.散点图</h1><p>散点图显示在笛卡尔平面中绘制的许多点。 每个点表示两个变量的值。 在水平轴上选择一个变量，在垂直轴上选择另一个变量。<br>使用plot()函数创建简单散点图。</p><h3 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h3><p>在R语言中创建散点图的基本语法是 -</p><pre><code>plot(x, y, main, xlab, ylab, xlim, ylim, axes)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>x是其值为水平坐标的数据集。</p></li><li><p>y是其值是垂直坐标的数据集。</p></li><li><p>main要是图形的图块。</p></li><li><p>xlab是水平轴上的标签。</p></li><li><p>ylab是垂直轴上的标签。</p></li><li><p>xlim是用于绘图的x的值的极限。</p></li><li><p>ylim是用于绘图的y的值的极限。</p></li><li><p>axes指示是否应在绘图上绘制两个轴。</p></li></ul><h3 id="例-8"><a href="#例-8" class="headerlink" title="例"></a>例</h3><p>我们使用R语言环境中可用的数据集“mtcars”来创建基本散点图。 让我们使用mtcars中的“wt”和“mpg”列。</p><pre><code>input &lt;- mtcars[,c('wt','mpg')]print(head(input))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>              wt      mpgMazda RX4           2.620   21.0Mazda RX4 Wag       2.875   21.0Datsun 710          2.320   22.8Hornet 4 Drive      3.215   21.4Hornet Sportabout   3.440   18.7Valiant             3.460   18.1</code></pre><h3 id="创建散点图"><a href="#创建散点图" class="headerlink" title="创建散点图"></a>创建散点图</h3><p>以下脚本将为wt（重量）和mpg（英里/加仑）之间的关系创建一个散点图。</p><pre><code># Get the input values.input &lt;- mtcars[,c('wt','mpg')]# Give the chart file a name.png(file = "scatterplot.png")# Plot the chart for cars with weight between 2.5 to 5 and mileage between 15 and 30.plot(x = input$wt,y = input$mpg,   xlab = "Weight",   ylab = "Milage",   xlim = c(2.5,5),   ylim = c(15,30),            main = "Weight vs Milage")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a7bdc1378f986796.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="，使用R散点图"></p><h3 id="散点图矩阵"><a href="#散点图矩阵" class="headerlink" title="散点图矩阵"></a>散点图矩阵</h3><p>当我们有两个以上的变量，我们想找到一个变量和其余变量之间的相关性，我们使用散点图矩阵。 我们使用<strong>pairs()</strong>函数创建散点图的矩阵。</p><h3 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h3><p>在R中创建散点图矩阵的基本语法是 -</p><pre><code>pairs(formula, data)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>formula</strong>表示成对使用的一系列变量。</p></li><li><p><strong>data</strong>表示将从其获取变量的数据集。</p></li></ul><h3 id="例-9"><a href="#例-9" class="headerlink" title="例"></a>例</h3><p>每个变量与每个剩余变量配对。 为每对绘制散点图。</p><pre><code># Give the chart file a name.png(file = "scatterplot_matrices.png")# Plot the matrices between 4 variables giving 12 plots.# One variable with 3 others and total 4 variables.pairs(~wt+mpg+disp+cyl,data = mtcars,   main = "Scatterplot Matrix")# Save the file.dev.off()</code></pre><p>当执行上面的代码中，我们得到以下输出。</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-ee1ea88d0af3338a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="散点图矩阵，使用R"></p><h1 id="6-饼状图"><a href="#6-饼状图" class="headerlink" title="6.饼状图"></a>6.饼状图</h1><p>R编程语言有许多库来创建图表和图表。 饼图是将值表示为具有不同颜色的圆的切片。 切片被标记，并且对应于每个片的数字也在图表中表示。<br>在R语言中，饼图是使用pie()函数创建的，它使用正数作为向量输入。 附加参数用于控制标签，颜色，标题等。</p><h3 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h3><p>使用R语言创建饼图的基本语法是 -</p><pre><code>pie(x, labels, radius, main, col, clockwise)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>x是包含饼图中使用的数值的向量。</p></li><li><p>labels用于给出切片的描述。</p></li><li><p>radius表示饼图圆的半径（值-1和+1之间）。</p></li><li><p>main表示图表的标题。</p></li><li><p>col表示调色板。</p></li><li><p>clockwise是指示片段是顺时针还是逆时针绘制的逻辑值。</p><h3 id="例-10"><a href="#例-10" class="headerlink" title="例"></a>例</h3></li></ul><p>使用输入向量和标签创建一个非常简单的饼图。 以下脚本将创建并保存当前R语言工作目录中的饼图。</p><pre><code># Create data for the graph.x &lt;- c(21, 62, 10, 53)labels &lt;- c("London", "New York", "Singapore", "Mumbai")# Give the chart file a name.png(file = "city.jpg")# Plot the chart.pie(x,labels)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-4755d4a765c7629f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="#"></p><h3 id="饼图标题和颜色"><a href="#饼图标题和颜色" class="headerlink" title="饼图标题和颜色"></a>饼图标题和颜色</h3><p>我们可以通过向函数中添加更多参数来扩展图表的功能。 我们将使用参数+ + <strong>main</strong>向图表添加标题，另一个参数是<strong>col</strong>，它将在绘制图表时使用彩虹色板。 托盘的长度应与图表中的值的数量相同。 因此，我们使用<strong>length(x)</strong>。</p><h3 id="例-11"><a href="#例-11" class="headerlink" title="例"></a>例</h3><p>以下脚本将创建并保存当前R语言工作目录中的饼图。</p><pre><code># Create data for the graph.x &lt;- c(21, 62, 10, 53)labels &lt;- c("London", "New York", "Singapore", "Mumbai")# Give the chart file a name.png(file = "city_title_colours.jpg")# Plot the chart with title and rainbow color pallet.pie(x, labels, main = "City pie chart", col = rainbow(length(x)))# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-04c9f73085247abe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="饼图以标题和颜色"></p><h3 id="切片百分比和图表图例"><a href="#切片百分比和图表图例" class="headerlink" title="切片百分比和图表图例"></a>切片百分比和图表图例</h3><p>我们可以通过创建其他图表变量来添加切片百分比和图表图例。</p><pre><code># Create data for the graph.x &lt;-  c(21, 62, 10,53)labels &lt;-  c("London","New York","Singapore","Mumbai")piepercent&lt;- round(100*x/sum(x), 1)# Give the chart file a name.png(file = "city_percentage_legends.jpg")# Plot the chart.pie(x, labels = piepercent, main = "City pie chart",col = rainbow(length(x)))legend("topright", c("London","New York","Singapore","Mumbai"), cex = 0.8,   fill = rainbow(length(x)))# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p>[图片上传中…(image-f4714e-1552624406629-1)]</p><h3 id="3D饼图"><a href="#3D饼图" class="headerlink" title="3D饼图"></a>3D饼图</h3><p>可以使用其他软件包绘制具有3个维度的饼图。 软件包plotrix有一个名为pie3D（）的函数，用于此。</p><pre><code># Get the library.library(plotrix)# Create data for the graph.x &lt;-  c(21, 62, 10,53)lbl &lt;-  c("London","New York","Singapore","Mumbai")# Give the chart file a name.png(file = "3d_pie_chart.jpg")# Plot the chart.pie3D(x,labels = lbl,explode = 0.1, main = "Pie Chart of Countries ")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-1463f87a12242a45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3D饼图"></p><h1 id="7-CSV文件"><a href="#7-CSV文件" class="headerlink" title="7.CSV文件"></a>7.CSV文件</h1><p>在R语言中，我们可以从存储在R语言环境外的文件中读取数据。我们还可以将数据写入将被操作系统存储和访问的文件.R语言可以读取和写入各种文件格式，如CSV，EXCEL，XML等。</p><p>在本章中，我们将学习从csv文件读取数据，然后将数据写入csv文件。该文件应该存在于当前工作目录中，以便R语言可以读取它。当然我们也可以设置我们自己的目录并从那里读取文件。</p><h3 id="获取和设置工作目录"><a href="#获取和设置工作目录" class="headerlink" title="获取和设置工作目录"></a>获取和设置工作目录</h3><p>您可以使用getwd（）函数检查R语言工作区指向的目录。您还可以使用setwd（）函数设置新的工作目录。</p><pre><code># Get and print current working directory.print(getwd())# Set current working directory.setwd("/web/com")# Get and print current working directory.print(getwd())</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "/web/com/1441086124_2016"[1] "/web/com"</code></pre><p>此结果取决于您的操作系统和您当前工作的目录。</p><h3 id="输入为CSV文件"><a href="#输入为CSV文件" class="headerlink" title="输入为CSV文件"></a>输入为CSV文件</h3><p>CSV文件是一个文本文件，其中列中的值由逗号分隔。让我们考虑名为input.csv的文件中出现的以下数据。<br>您可以通过复制和粘贴此数据使用的Windows记事本创建此文件。使用记事本中的保存为所有文件（<em>。</em>）选项将文件保存为input.csv。</p><pre><code>id,name,salary,start_date,dept1,Rick,623.3,2012-01-01,IT2,Dan,515.2,2013-09-23,Operations3,Michelle,611,2014-11-15,IT4,Ryan,729,2014-05-11,HR ,Gary,843.25,2015-03-27,Finance6,Nina,578,2013-05-21,IT7,Simon,632.8,2013-07-30,Operations8,Guru,722.5,2014-06-17,Finance</code></pre><h3 id="读取CSV文件"><a href="#读取CSV文件" class="headerlink" title="读取CSV文件"></a>读取CSV文件</h3><p>以下是read.csv（）函数的一个简单示例，用于读取当前工作目录中可用的CSV文件 -</p><p>data &lt;- read.csv(“input.csv”)<br>print(data)<br>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      id,   name,    salary,   start_date,     dept1      1    Rick     623.30    2012-01-01      IT2      2    Dan      515.20    2013-09-23      Operations3      3    Michelle 611.00    2014-11-15      IT4      4    Ryan     729.00    2014-05-11      HR5     NA    Gary     843.25    2015-03-27      Finance6      6    Nina     578.00    2013-05-21      IT7      7    Simon    632.80    2013-07-30      Operations8      8    Guru     722.50    2014-06-17      Finance</code></pre><h3 id="分析CSV文件"><a href="#分析CSV文件" class="headerlink" title="分析CSV文件"></a>分析CSV文件</h3><p>默认情况下，read.csv（）函数将输出作为数据帧。这可以容易地如下检查。此外，我们可以检查列和行的数量。</p><pre><code>data &lt;- read.csv("input.csv")print(is.data.frame(data))print(ncol(data))print(nrow(data))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] TRUE[1] 5[1] 8</code></pre><p>一旦我们读取数据帧中的数据，我们可以应用所有适用于数据帧的函数，如下一节所述。</p><p>获得最高工资</p><pre><code># Create a data frame.data &lt;- read.csv("input.csv")# Get the max salary from data frame.sal &lt;- max(data$salary)print(sal)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 843.25</code></pre><p>获取具有最高工资的人的详细信息<br>我们可以获取满足特定过滤条件的行，类似于SQL where子句。</p><pre><code># Create a data frame.data &lt;- read.csv("input.csv")# Get the max salary from data frame.sal &lt;- max(data$salary)# Get the person detail having max salary.retval &lt;- subset(data, salary == max(salary))print(retval)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      id    name  salary  start_date    dept5     NA    Gary  843.25  2015-03-27    Finance</code></pre><p>获取所有的IT部门员工的信息</p><pre><code># Create a data frame.data &lt;- read.csv("input.csv")retval &lt;- subset( data, dept == "IT")print(retval)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>       id   name      salary   start_date   dept1      1    Rick      623.3    2012-01-01   IT3      3    Michelle  611.0    2014-11-15   IT6      6    Nina      578.0    2013-05-21   IT</code></pre><p>获得工资大于600的IT部门的人员</p><pre><code># Create a data frame.data &lt;- read.csv("input.csv")info &lt;- subset(data, salary &gt; 600 &amp; dept == "IT")print(info)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>       id   name      salary   start_date   dept1      1    Rick      623.3    2012-01-01   IT3      3    Michelle  611.0    2014-11-15   IT</code></pre><p>获得2014年或之后加入的人</p><pre><code># Create a data frame.data &lt;- read.csv("input.csv")retval &lt;- subset(data, as.Date(start_date) &gt; as.Date("2014-01-01"))print(retval)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>       id   name     salary   start_date    dept3      3    Michelle 611.00   2014-11-15    IT4      4    Ryan     729.00   2014-05-11    HR5     NA    Gary     843.25   2015-03-27    Finance8      8    Guru     722.50   2014-06-17    Finance</code></pre><h3 id="写入CSV文件"><a href="#写入CSV文件" class="headerlink" title="写入CSV文件"></a>写入CSV文件</h3><p>R语言可以创建csv文件形式的现有数据帧.write.csv（）函数用于创建csv文件。此文件在工作目录中创建。</p><pre><code># Create a data frame.data &lt;- read.csv("input.csv")retval &lt;- subset(data, as.Date(start_date) &gt; as.Date("2014-01-01"))# Write filtered data into a new file.write.csv(retval,"output.csv")newdata &lt;- read.csv("output.csv")print(newdata)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>  X      id   name      salary   start_date    dept1 3      3    Michelle  611.00   2014-11-15    IT2 4      4    Ryan      729.00   2014-05-11    HR3 5     NA    Gary      843.25   2015-03-27    Finance4 8      8    Guru      722.50   2014-06-17    Finance</code></pre><p>这里列X来自数据集newper。这可以在写入文件时使用附加参数删除。</p><pre><code># Create a data frame.data &lt;- read.csv("input.csv")retval &lt;- subset(data, as.Date(start_date) &gt; as.Date("2014-01-01"))# Write filtered data into a new file.write.csv(retval,"output.csv", row.names = FALSE)newdata &lt;- read.csv("output.csv")print(newdata)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      id    name      salary   start_date    dept1      3    Michelle  611.00   2014-11-15    IT2      4    Ryan      729.00   2014-05-11    HR3     NA    Gary      843.25   2015-03-27    Finance4      8    Guru      722.50   2014-06-17    Finance</code></pre><h1 id="8-Excel文件"><a href="#8-Excel文件" class="headerlink" title="8.Excel文件"></a>8.Excel文件</h1><p>Microsoft Excel是最广泛使用的电子表格程序，以.xls或.xlsx格式存储数据。 R语言可以直接从这些文件使用一些excel特定的包。 很少这样的包是 - XLConnect，xlsx，gdata等。我们将使用xlsx包。 R语言也可以使用这个包写入excel文件。</p><h3 id="安装xlsx软件包"><a href="#安装xlsx软件包" class="headerlink" title="安装xlsx软件包"></a>安装xlsx软件包</h3><p>您可以在R控制台中使用以下命令来安装“xlsx”软件包。 它可能会要求安装一些额外的软件包这个软件包依赖。 按照具有所需软件包名称的同一命令安装其他软件包。</p><pre><code>install.packages("xlsx")</code></pre><h3 id="验证并加载“xlsx”软件包"><a href="#验证并加载“xlsx”软件包" class="headerlink" title="验证并加载“xlsx”软件包"></a>验证并加载“xlsx”软件包</h3><p>使用以下命令验证并加载“xlsx”软件包。</p><pre><code># Verify the package is installed.any(grepl("xlsx",installed.packages()))# Load the library into R workspace.library("xlsx")</code></pre><p>当脚本运行，我们得到以下输出。</p><pre><code>[1] TRUELoading required package: rJavaLoading required package: methodsLoading required package: xlsxjars</code></pre><h3 id="输入为xlsx文件"><a href="#输入为xlsx文件" class="headerlink" title="输入为xlsx文件"></a>输入为xlsx文件</h3><p>打开Microsoft Excel。 将以下数据复制并粘贴到名为sheet1的工作表中。</p><pre><code>id    name      salary    start_date    dept1    Rick      623.3        1/1/2012    IT2    Dan       515.2     9/23/2013   Operations3    Michelle  611        11/15/2014    IT4    Ryan      729        5/11/2014    HR5    Gary      843.25    3/27/2015    Finance6    Nina      578       5/21/2013    IT7    Simon      632.8        7/30/2013    Operations8    Guru      722.5        6/17/2014    Finance</code></pre><p>还要将以下数据复制并粘贴到另一个工作表，并将此工作表重命名为“city”。</p><pre><code>name     cityRick     SeattleDan      TampaMichelle ChicagoRyan     SeattleGary     HoustonNina     BostonSimon     MumbaiGuru     Dallas</code></pre><p>将Excel文件另存为“input.xlsx”。 应将其保存在R工作区的当前工作目录中。</p><h3 id="读取Excel文件"><a href="#读取Excel文件" class="headerlink" title="读取Excel文件"></a>读取Excel文件</h3><p>通过使用read.xlsx()函数读取input.xlsx，如下所示。 结果作为数据帧存储在R语言环境中。</p><pre><code># Read the first worksheet in the file input.xlsx.data &lt;- read.xlsx("input.xlsx", sheetIndex = 1)print(data)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      id,   name,    salary,   start_date,     dept1      1    Rick     623.30    2012-01-01      IT2      2    Dan      515.20    2013-09-23      Operations3      3    Michelle 611.00    2014-11-15      IT4      4    Ryan     729.00    2014-05-11      HR5     NA    Gary     843.25    2015-03-27      Finance6      6    Nina     578.00    2013-05-21      IT7      7    Simon    632.80    2013-07-30      Operations8      8    Guru     722.50    2014-06-17      Finance</code></pre><h1 id="9-二进制文件"><a href="#9-二进制文件" class="headerlink" title="9.二进制文件"></a>9.二进制文件</h1><p>二进制文件是包含仅以位和字节（0和1）的形式存储的信息的文件。它们不是人类可读的，因为它中的字节转换为包含许多其他不可打印字符的字符和符号。尝试使用任何文本编辑器读取二进制文件将显示如Ø和d的字符。</p><p>二进制文件必须由特定程序读取才能使用。例如，Microsoft Word程序的二进制文件只能通过Word程序读取到人类可读的形式。这表示，除了人类可读的文本之外，还有更多的信息，例如字符和页码等的格式化，它们也与字母数字字符一起存储。最后一个二进制文件是一个连续的字节序列。我们在文本文件中看到的换行符是连接第一行到下一行的字符。</p><p>有时，由其他程序生成的数据需要由ř作为二进制文件处理。另外，R语言是创建可以与其他程序共享的二进制文件所必需的。</p><p>ř语言有两个函数WriteBin（）和readBin（）来创建和读取二进制文件。</p><h3 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h3><pre><code>writeBin(object, con)readBin(con, what, n )</code></pre><p>以下是所使用的参数的描述 -</p><ul><li><p>CON是读取或写入二进制文件的连接对象。</p></li><li><p>对象是要写入的二进制文件。</p></li><li><p>什么是模式，如字符，整数等表示要读取的字节。</p></li><li><p>ñ是从二进制文件读取的字节数。</p></li></ul><h3 id="例-12"><a href="#例-12" class="headerlink" title="例"></a>例</h3><p>我们考虑R语言内置数据“mtcars”。首先，我们从它创建一个csv文件，并将其转换为二进制文件，并将其存储为操作系统文件。接下来我们读取这个创建的二进制文件。</p><h3 id="写入二进制文件"><a href="#写入二进制文件" class="headerlink" title="写入二进制文件"></a>写入二进制文件</h3><p>我们将数据帧“mtcars”读取为CSV文件，然后将其作为二进制文件写入操作系统。</p><pre><code># Read the "mtcars" data frame as a csv file and store only the columns    "cyl", "am" and "gear".write.table(mtcars, file = "mtcars.csv",row.names = FALSE, na = "",    col.names = TRUE, sep = ",")# Store 5 records from the csv file as a new data frame.new.mtcars &lt;- read.table("mtcars.csv",sep = ",",header = TRUE,nrows = 5)# Create a connection object to write the binary file using mode "wb".write.filename = file("/web/com/binmtcars.dat", "wb")# Write the column names of the data frame to the connection object.writeBin(colnames(new.mtcars), write.filename)# Write the records in each of the column to the file.writeBin(c(new.mtcars$cyl,new.mtcars$am,new.mtcars$gear), write.filename)# Close the file for writing so that it can be read by other program.close(write.filename)</code></pre><h3 id="读取二进制文件"><a href="#读取二进制文件" class="headerlink" title="读取二进制文件"></a>读取二进制文件</h3><p>上面创建的二进制文件将所有数据存储为连续字节。因此，我们将通过选择适当的列名称值和列值来读取它。</p><pre><code># Create a connection object to read the file in binary mode using "rb".read.filename &lt;- file("/web/com/binmtcars.dat", "rb")# First read the column names. n = 3 as we have 3 columns.column.names &lt;- readBin(read.filename, character(),  n = 3)# Next read the column values. n = 18 as we have 3 column names and 15 values.read.filename &lt;- file("/web/com/binmtcars.dat", "rb")bindata &lt;- readBin(read.filename, integer(),  n = 18)# Print the data.print(bindata)# Read the values from 4th byte to 8th byte which represents "cyl".cyldata = bindata[4:8]print(cyldata)# Read the values form 9th byte to 13th byte which represents "am".amdata = bindata[9:13]print(amdata)# Read the values form 9th byte to 13th byte which represents "gear".geardata = bindata[14:18]print(geardata)# Combine all the read values to a dat frame.finaldata = cbind(cyldata, amdata, geardata)colnames(finaldata) = column.namesprint(finaldata)</code></pre><p>当我们执行上面的代码，它产生以下结果和图表 -</p><pre><code> [1]    7108963 1728081249    7496037          6          6          4 [7]          6          8          1          1          1          0[13]          0          4          4          4          3          3[1] 6 6 4 6 8[1] 1 1 1 0 0[1] 4 4 4 3 3     cyl am gear[1,]   6  1    4[2,]   6  1    4[3,]   4  1    4[4,]   6  0    3[5,]   8  0    3</code></pre><p>正如我们所看到的，我们通过读取 - [R中的二进制文件得到原始数据。</p><h1 id="10-XML文件"><a href="#10-XML文件" class="headerlink" title="10.XML文件"></a>10.XML文件</h1><p>XML是一种文件格式，它使用标准ASCII文本共享万维网，内部网和其他地方的文件格式和数据。它代表可扩展标记语言（XML）。类似于HTML它包含标记标签。但是与HTML中的标记标记描述页面的结构不同，在XML中，标记标记描述了包含在文件中的数据的含义。</p><p>您可以使用“XML”包读取R语言中的xml文件。此软件包可以使用以下命令安装。</p><pre><code>install.packages("XML")</code></pre><h3 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h3><p>通过将以下数据复制到文本编辑器（如记事本）中来创建XMl文件。使用.xml扩展名保存文件，并将文件类型选择为所有文件（<em>。</em>）。</p><pre><code>&lt;RECORDS&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;1&lt;/ID&gt;      &lt;NAME&gt;Rick&lt;/NAME&gt;      &lt;SALARY&gt;623.3&lt;/SALARY&gt;      &lt;STARTDATE&gt;1/1/2012&lt;/STARTDATE&gt;      &lt;DEPT&gt;IT&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;2&lt;/ID&gt;      &lt;NAME&gt;Dan&lt;/NAME&gt;      &lt;SALARY&gt;515.2&lt;/SALARY&gt;      &lt;STARTDATE&gt;9/23/2013&lt;/STARTDATE&gt;      &lt;DEPT&gt;Operations&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;3&lt;/ID&gt;      &lt;NAME&gt;Michelle&lt;/NAME&gt;      &lt;SALARY&gt;611&lt;/SALARY&gt;      &lt;STARTDATE&gt;11/15/2014&lt;/STARTDATE&gt;      &lt;DEPT&gt;IT&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;4&lt;/ID&gt;      &lt;NAME&gt;Ryan&lt;/NAME&gt;      &lt;SALARY&gt;729&lt;/SALARY&gt;      &lt;STARTDATE&gt;5/11/2014&lt;/STARTDATE&gt;      &lt;DEPT&gt;HR&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;5&lt;/ID&gt;      &lt;NAME&gt;Gary&lt;/NAME&gt;      &lt;SALARY&gt;843.25&lt;/SALARY&gt;      &lt;STARTDATE&gt;3/27/2015&lt;/STARTDATE&gt;      &lt;DEPT&gt;Finance&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;6&lt;/ID&gt;      &lt;NAME&gt;Nina&lt;/NAME&gt;      &lt;SALARY&gt;578&lt;/SALARY&gt;      &lt;STARTDATE&gt;5/21/2013&lt;/STARTDATE&gt;      &lt;DEPT&gt;IT&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;7&lt;/ID&gt;      &lt;NAME&gt;Simon&lt;/NAME&gt;      &lt;SALARY&gt;632.8&lt;/SALARY&gt;      &lt;STARTDATE&gt;7/30/2013&lt;/STARTDATE&gt;      &lt;DEPT&gt;Operations&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;8&lt;/ID&gt;      &lt;NAME&gt;Guru&lt;/NAME&gt;      &lt;SALARY&gt;722.5&lt;/SALARY&gt;      &lt;STARTDATE&gt;6/17/2014&lt;/STARTDATE&gt;      &lt;DEPT&gt;Finance&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;&lt;/RECORDS&gt;</code></pre><h3 id="读取XML文件"><a href="#读取XML文件" class="headerlink" title="读取XML文件"></a>读取XML文件</h3><p>xml文件由R语言使用函数xmlParse（）读取。它作为列表存储在R语言中。</p><pre><code># Load the package required to read XML files.library("XML")# Also load the other required package.library("methods")# Give the input file name to the function.result &lt;- xmlParse(file = "input.xml")# Print the result.print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>1    Rick    623.3    1/1/2012    IT    2    Dan    515.2    9/23/2013    Operations    3    Michelle    611    11/15/2014    IT    4    Ryan    729    5/11/2014    HR    5    Gary    843.25    3/27/2015    Finance    6    Nina    578    5/21/2013    IT    7    Simon    632.8    7/30/2013    Operations    8    Guru    722.5    6/17/2014    Finance</code></pre><h3 id="获取XML文件中存在的节点数"><a href="#获取XML文件中存在的节点数" class="headerlink" title="获取XML文件中存在的节点数"></a>获取XML文件中存在的节点数</h3><pre><code># Load the packages required to read XML files.library("XML")library("methods")# Give the input file name to the function.result &lt;- xmlParse(file = "input.xml")# Exract the root node form the xml file.rootnode &lt;- xmlRoot(result)# Find number of nodes in the root.rootsize &lt;- xmlSize(rootnode)# Print the result.print(rootsize)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>output[1] 8</code></pre><h3 id="第一个节点的详细信息"><a href="#第一个节点的详细信息" class="headerlink" title="第一个节点的详细信息"></a>第一个节点的详细信息</h3><p>让我们看看解析文件的第一条记录。它将给我们一个关于存在于顶层节点中的各种元素的想法。</p><pre><code># Load the packages required to read XML files.library("XML")library("methods")# Give the input file name to the function.result &lt;- xmlParse(file = "input.xml")# Exract the root node form the xml file.rootnode &lt;- xmlRoot(result)# Print the result.print(rootnode[1])</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>$EMPLOYEE  1  Rick  623.3  1/1/2012  ITattr(,"class")[1] "XMLInternalNodeList" "XMLNodeList" </code></pre><p>获取节点的不同元素</p><pre><code># Load the packages required to read XML files.library("XML")library("methods")# Give the input file name to the function.result &lt;- xmlParse(file = "input.xml")# Exract the root node form the xml file.rootnode &lt;- xmlRoot(result)# Get the first element of the first node.print(rootnode[[1]][[1]])# Get the fifth element of the first node.print(rootnode[[1]][[5]])# Get the second element of the third node.print(rootnode[[3]][[2]])</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>1 IT Michelle </code></pre><h3 id="XML到数据帧"><a href="#XML到数据帧" class="headerlink" title="XML到数据帧"></a>XML到数据帧</h3><p>为了在大文件中有效地处理数据，我们将xml文件中的数据作为数据框读取。然后处理数据帧以进行数据分析。</p><pre><code># Load the packages required to read XML files.library("XML")library("methods")# Convert the input xml file to a data frame.xmldataframe &lt;- xmlToDataFrame("input.xml")print(xmldataframe)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      ID    NAME     SALARY    STARTDATE       DEPT 1      1    Rick     623.30    2012-01-01      IT2      2    Dan      515.20    2013-09-23      Operations3      3    Michelle 611.00    2014-11-15      IT4      4    Ryan     729.00    2014-05-11      HR5     NA    Gary     843.25    2015-03-27      Finance6      6    Nina     578.00    2013-05-21      IT7      7    Simon    632.80    2013-07-30      Operations8      8    Guru     722.50    2014-06-17      Finance</code></pre><p>由于数据现在可以作为数据帧，我们可以使用数据帧相关函数来读取和操作文件。</p><h1 id="11-JSON文件"><a href="#11-JSON文件" class="headerlink" title="11.JSON文件"></a>11.JSON文件</h1><p>JSON文件以人类可读格式将数据存储为文本.Json代表JavaScript Object Notation.R可以使用rjson包读取JSON文件。</p><h3 id="安装rjson包"><a href="#安装rjson包" class="headerlink" title="安装rjson包"></a>安装rjson包</h3><p>在ř语言控制台中，您可以发出以下命令来安装rjson包。</p><pre><code>install.packages("rjson")</code></pre><h3 id="输入数据-1"><a href="#输入数据-1" class="headerlink" title="输入数据"></a>输入数据</h3><p>通过将以下数据复制到文本编辑器（如记事本）中来创建JSON文件。使用.json扩展名保存文件，并将文件类型选择为所有文件（<em>。</em>）。</p><pre><code>{    "ID":["1","2","3","4","5","6","7","8" ],   "Name":["Rick","Dan","Michelle","Ryan","Gary","Nina","Simon","Guru" ],   "Salary":["623.3","515.2","611","729","843.25","578","632.8","722.5" ],   "StartDate":[ "1/1/2012","9/23/2013","11/15/2014","5/11/2014","3/27/2015","5/21/2013",      "7/30/2013","6/17/2014"],   "Dept":[ "IT","Operations","IT","HR","Finance","IT","Operations","Finance"]}</code></pre><h3 id="读取JSON文件"><a href="#读取JSON文件" class="headerlink" title="读取JSON文件"></a>读取JSON文件</h3><p>JSON文件由R使用来自JSON（）的函数读取。它作为列表存储在R中。</p><pre><code># Load the package required to read JSON files.library("rjson")# Give the input file name to the function.result &lt;- fromJSON(file = "input.json")# Print the result.print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>$ID[1] "1"   "2"   "3"   "4"   "5"   "6"   "7"   "8"$Name[1] "Rick"     "Dan"      "Michelle" "Ryan"     "Gary"     "Nina"     "Simon"    "Guru"$Salary[1] "623.3"  "515.2"  "611"    "729"    "843.25" "578"    "632.8"  "722.5"$StartDate[1] "1/1/2012"   "9/23/2013"  "11/15/2014" "5/11/2014"  "3/27/2015"  "5/21/2013"   "7/30/2013"  "6/17/2014"$Dept[1] "IT"         "Operations" "IT"         "HR"         "Finance"    "IT"   "Operations" "Finance"</code></pre><h3 id="将JSON转换为数据帧"><a href="#将JSON转换为数据帧" class="headerlink" title="将JSON转换为数据帧"></a>将JSON转换为数据帧</h3><p>我们可以使用as.data.frame（）函数将上面提取的数据转换为ř语言数据帧以进行进一步分析。</p><pre><code># Load the package required to read JSON files.library("rjson")# Give the input file name to the function.result &lt;- fromJSON(file = "input.json")# Convert JSON file to a data frame.json_data_frame &lt;- as.data.frame(result)print(json_data_frame)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      id,   name,    salary,   start_date,     dept1      1    Rick     623.30    2012-01-01      IT2      2    Dan      515.20    2013-09-23      Operations3      3    Michelle 611.00    2014-11-15      IT4      4    Ryan     729.00    2014-05-11      HR5     NA    Gary     843.25    2015-03-27      Finance6      6    Nina     578.00    2013-05-21      IT7      7    Simon    632.80    2013-07-30      Operations8      8    Guru     722.50    2014-06-17      Finance</code></pre><h1 id="13-Web数据"><a href="#13-Web数据" class="headerlink" title="13.Web数据"></a>13.Web数据</h1><p>许多网站提供数据供其用户使用。例如，世界卫生组织（WHO）以CSV，txt和XML文件的形式提供健康和医疗信息的报告。使用R语言程序，我们可以从这些网站以编程方式提取特定数据R语言中用于从网站中提取数据的一些包是“RCurl”，XML“和”stringr“，它们用于连接到URL，识别文件所需的链接并将它们下载到本地环境。</p><h3 id="安装-R语言的包"><a href="#安装-R语言的包" class="headerlink" title="安装 - [R语言的包"></a>安装 - [R语言的包</h3><p>处理URL和链接到文件需要以下的包。如果它们在R语言环境中不可用，您可以使用以下命令安装它们。</p><pre><code>install.packages("RCurl")install.packages("XML")install.packages("stringr")install.packages("plyr")</code></pre><h3 id="输入数据-2"><a href="#输入数据-2" class="headerlink" title="输入数据"></a>输入数据</h3><p>我们将访问URL <a href="http://www.geos.ed.ac.uk/~weather/jcmb_ws/" target="_blank" rel="noopener">天气数据</a>，并使用[R在2015年下载CSV文件。</p><h3 id="例-13"><a href="#例-13" class="headerlink" title="例"></a>例</h3><p>我们将使用函数getHTMLLinks（）来收集文件的URL。然后我们将使用函数downlaod.file（）将文件保存到本地系统。由于我们将对多个文件一次又一次地应用相同的代码，因此我们将创建一个被多次调用的函数。文件名作为参数以R列表对象的形式传递到此函数。</p><pre><code># Read the URL.url &lt;- "http://www.geos.ed.ac.uk/~weather/jcmb_ws/"# Gather the html links present in the webpage.links &lt;- getHTMLLinks(url)# Identify only the links which point to the JCMB 2015 files. filenames &lt;- links[str_detect(links, "JCMB_2015")]# Store the file names as a list.filenames_list &lt;- as.list(filenames)# Create a function to download the files by passing the URL and filename list.downloadcsv &lt;- function (mainurl,filename) {   filedetails &lt;- str_c(mainurl,filename)   download.file(filedetails,filename)}# Now apply the l_ply function and save the files into the current R working directory.l_ply(filenames,downloadcsv,mainurl = "http://www.geos.ed.ac.uk/~weather/jcmb_ws/")</code></pre><h3 id="验证文件下载"><a href="#验证文件下载" class="headerlink" title="验证文件下载"></a>验证文件下载</h3><p>运行上述代码后，您可以在当前ř语言工作目录中找到以下文件。</p><pre><code>"JCMB_2015.csv" "JCMB_2015_Apr.csv" "JCMB_2015_Feb.csv" "JCMB_2015_Jan.csv"   "JCMB_2015_Mar.csv"</code></pre><h1 id="14-数据库"><a href="#14-数据库" class="headerlink" title="14.数据库"></a>14.数据库</h1><p>Sql查询。但R语言可以轻松地连接到许多关系数据库，如MySql，Oracle，Sql服务器等，并数据是从它们获取记录作为数据框。一旦数据在R语言环境中可用，它就变成正常的R语言数据集，并且可以使用所有强大的包和函数来操作或分析。<br>在本教程中，我们将使用MySQL的作为连接到- [R语言的参考数据库。</p><h3 id="RMySQL包"><a href="#RMySQL包" class="headerlink" title="RMySQL包"></a>RMySQL包</h3><p>R语言有一个名为“RMySQL”的内置包，它提供与MySql数据库之间的本地连接。您可以使用以下命令在R语言环境中安装此软件包。</p><pre><code>install.packages("RMySQL")</code></pre><h3 id="将r连接到MySQL的"><a href="#将r连接到MySQL的" class="headerlink" title="将ř连接到MySQL的"></a>将ř连接到MySQL的</h3><p>一旦安装了包，我们在R中创建一个连接对象以连接到数据库。它使用用户名，密码，数据库名称和主机名作为输入。</p><pre><code># Create a connection Object to MySQL database.# We will connect to the sampel database named "sakila" that comes with MySql installation.mysqlconnection = dbConnect(MySQL(), user = 'root', password = '', dbname = 'sakila',   host = 'localhost')# List the tables available in this database. dbListTables(mysqlconnection)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code> [1] "actor"                      "actor_info"                 [3] "address"                    "category"                   [5] "city"                       "country"                    [7] "customer"                   "customer_list"              [9] "film"                       "film_actor"                [11] "film_category"              "film_list"                 [13] "film_text"                  "inventory"                 [15] "language"                   "nicer_but_slower_film_list"[17] "payment"                    "rental"                    [19] "sales_by_film_category"     "sales_by_store"            [21] "staff"                      "staff_list"                [23] "store"     </code></pre><h3 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a>查询表</h3><p>我们可以使用函数dbSendQuery（）查询MySql中的数据库表。查询在MySql中执行，并使用R语言fetch（）函数返回结果集。最后，它被存储为R语言中的数据帧。</p><pre><code># Query the "actor" tables to get all the rows.result = dbSendQuery(mysqlconnection, "select * from actor")# Store the result in a R data frame object. n = 5 is used to fetch first 5 rows.data.frame = fetch(result, n = 5)print(data.frame)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>        actor_id   first_name    last_name         last_update1        1         PENELOPE      GUINESS           2006-02-15 04:34:332        2         NICK          WAHLBERG          2006-02-15 04:34:333        3         ED            CHASE             2006-02-15 04:34:334        4         JENNIFER      DAVIS             2006-02-15 04:34:335        5         JOHNNY        LOLLOBRIGIDA      2006-02-15 04:34:33</code></pre><h3 id="带过滤条件的查询"><a href="#带过滤条件的查询" class="headerlink" title="带过滤条件的查询"></a>带过滤条件的查询</h3><p>我们可以传递任何有效的选择查询来获取结果。</p><pre><code>result = dbSendQuery(mysqlconnection, "select * from actor where last_name = 'TORN'")# Fetch all the records(with n = -1) and store it as a data frame.data.frame = fetch(result, n = -1)print(data)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>        actor_id    first_name     last_name         last_update1        18         DAN            TORN              2006-02-15 04:34:332        94         KENNETH        TORN              2006-02-15 04:34:333       102         WALTER         TORN              2006-02-15 04:34:33</code></pre><h3 id="更新表中的行"><a href="#更新表中的行" class="headerlink" title="更新表中的行"></a>更新表中的行</h3><p>我们可以通过将更新查询传递给dbSendQuery（）函数来更新Mysql的表中的行。</p><pre><code>dbSendQuery(mysqlconnection, "update mtcars set disp = 168.5 where hp = 110")</code></pre><p>在执行上面的代码后，我们可以看到在MySQL的环境中更新的表。<br>将数据插入表中</p><pre><code>dbSendQuery(mysqlconnection,   "insert into mtcars(row_names, mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb)   values('New Mazda RX4 Wag', 21, 6, 168.5, 110, 3.9, 2.875, 17.02, 0, 1, 4, 4)")</code></pre><p>在执行上面的代码后，我们可以看到插入到MySQL的环境中的表中的行。</p><h3 id="在MySQL的中创建表"><a href="#在MySQL的中创建表" class="headerlink" title="在MySQL的中创建表"></a>在MySQL的中创建表</h3><p>我们可以在MySql中使用函数dbWriteTable（）创建表。如果表已经存在，它将覆盖该表，并将数据帧用作输入。</p><pre><code># Create the connection object to the database where we want to create the table.mysqlconnection = dbConnect(MySQL(), user = 'root', password = '', dbname = 'sakila',    host = 'localhost')# Use the R data frame "mtcars" to create the table in MySql.# All the rows of mtcars are taken inot MySql.dbWriteTable(mysqlconnection, "mtcars", mtcars[, ], overwrite = TRUE)</code></pre><p>执行上面的代码后，我们可以看到在MySQL的环境中创建的表。</p><h3 id="删除的MySQL中的表"><a href="#删除的MySQL中的表" class="headerlink" title="删除的MySQL中的表"></a>删除的MySQL中的表</h3><p>我们可以删除MySql数据库中的表，将drop table语句传递到dbSendQuery（）中，就像我们使用它查询表中的数据一样。</p><pre><code>dbSendQuery(mysqlconnection, 'drop table if exists mtcars')</code></pre><p>执行上面的代码后，我们可以看到表在MySQL的环境中被删除。</p><h1 id="15-外部资源"><a href="#15-外部资源" class="headerlink" title="15.外部资源"></a>15.外部资源</h1><p>以下资源包含有关R语言编程的其他信息。 请使用它们获得有关此主题的更深入的知识。</p><h3 id="R语言编程的相关链接"><a href="#R语言编程的相关链接" class="headerlink" title="R语言编程的相关链接"></a>R语言编程的相关链接</h3><ul><li><p><a href="https://www.r-project.org/" target="_blank" rel="noopener">R项目</a> - 官方R软件和文档。</p></li><li><p><a href="https://en.wikipedia.org/wiki/R_(programming_language)" target="_blank" rel="noopener">R编程语言</a> - 维基百科解释R编程语言。</p></li><li><p><a href="https://www.rstudio.com/" target="_blank" rel="noopener">R Studio</a> - 强大的R编程IDE。</p></li></ul><h3 id="R上的编程有用的书籍"><a href="#R上的编程有用的书籍" class="headerlink" title="R上的编程有用的书籍"></a>R上的编程有用的书籍</h3><ul><li>[<img src="/images/loading.gif" data-original="http://www.amazon.com/exec/obidos/ASIN/1593273843/httpwwwtuto0a-20" alt=" -  [R编程的艺术](http://upload-images.jianshu.io/upload_images/14093662-65265032b61c772f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"> </li><li><a href="http://www.amazon.com/exec/obidos/ASIN/1449357105/httpwwwtuto0a-20" target="_blank" rel="noopener"><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-3c35398cdd7d47d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="学习ř"></a> </li><li><a href="http://www.amazon.com/exec/obidos/ASIN/1617291382/httpwwwtuto0a-20" target="_blank" rel="noopener"><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-3bd16a1f1ffae949.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中的R行动"></a> </li><li><a href="http://www.amazon.com/exec/obidos/ASIN/1617291560/httpwwwtuto0a-20" target="_blank" rel="noopener"><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-70a071fbcd01af9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="有R实用的数据科学"></a> </li><li><a href="http://www.amazon.com/exec/obidos/ASIN/111816430X/httpwwwtuto0a-20" target="_blank" rel="noopener"><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-da63af7c2a617b81.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="有R实用的数据科学"></a> </li><li><a href="http://www.amazon.com/exec/obidos/ASIN/111816430X/httpwwwtuto0a-20" target="_blank" rel="noopener"><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-053f2b8cf827ec94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="有R实用的数据科学"></a><h1 id="16-常见面试题"><a href="#16-常见面试题" class="headerlink" title="16.常见面试题"></a>16.常见面试题</h1><h3 id="什么是R语言编程？"><a href="#什么是R语言编程？" class="headerlink" title="什么是R语言编程？"></a>什么是R语言编程？</h3></li></ul><p>R语言是一种用于统计分析和为此目的创建图形的编程语言。不是数据类型，它具有用于计算的数据对象。它用于数据挖掘，回归分析，概率估计等领域，使用其中可用的许多软件包。</p><h3 id="R语言中的不同数据对象是什么？"><a href="#R语言中的不同数据对象是什么？" class="headerlink" title="R语言中的不同数据对象是什么？"></a>R语言中的不同数据对象是什么？</h3><p>它们是R语言中的6个数据对象。它们是向量，列表，数组，矩阵，数据框和表。</p><h3 id="什么使R语言中的有效变量名？"><a href="#什么使R语言中的有效变量名？" class="headerlink" title="什么使R语言中的有效变量名？"></a>什么使R语言中的有效变量名？</h3><p>有效的变量名称由字母，数字和点或下划线字符组成。变量名以字母或不以数字后跟的点开头。</p><h3 id="数组和矩阵之间的主要区别是什么？"><a href="#数组和矩阵之间的主要区别是什么？" class="headerlink" title="数组和矩阵之间的主要区别是什么？"></a>数组和矩阵之间的主要区别是什么？</h3><p>矩阵总是二维的，因为它只有行和列。但是阵列可以具有任何数量的维度，并且每个维度是矩阵。例如，3x3x2阵列表示维度为3x3的2个矩阵。</p><h3 id="R语言中的哪个数据对象用于存储和处理分类数据？"><a href="#R语言中的哪个数据对象用于存储和处理分类数据？" class="headerlink" title="R语言中的哪个数据对象用于存储和处理分类数据？"></a>R语言中的哪个数据对象用于存储和处理分类数据？</h3><p>R语言中的因子数据对象用于存储和处理R语言中的分类数据。</p><h3 id="如何在R语言中加载和使用csv文件？"><a href="#如何在R语言中加载和使用csv文件？" class="headerlink" title="如何在R语言中加载和使用csv文件？"></a>如何在R语言中加载和使用csv文件？</h3><p>可以使用R语言ead.csv函数加载csv文件。 R语言在使用此函数读取csv文件时创建数据框。</p><h3 id="如何获取R语言中当前工作目录的名称？"><a href="#如何获取R语言中当前工作目录的名称？" class="headerlink" title="如何获取R语言中当前工作目录的名称？"></a>如何获取R语言中当前工作目录的名称？</h3><p>命令getwd()给出了R语言环境中的当前工作目录。</p><h3 id="什么是R语言-Base包？"><a href="#什么是R语言-Base包？" class="headerlink" title="什么是R语言 Base包？"></a>什么是R语言 Base包？</h3><p>这是在R语言环境设置时默认加载的包。它提供了R语言环境中的基本功能，如输入/输出，算术计算等。</p><h3 id="在逻辑回归中如何使用R语言？"><a href="#在逻辑回归中如何使用R语言？" class="headerlink" title="在逻辑回归中如何使用R语言？"></a>在逻辑回归中如何使用R语言？</h3><p>逻辑回归处理测量二元响应变量的概率。在R语言中，函数glm()用于创建逻辑回归。</p><h3 id="如何访问名为M的矩阵的第2列和第4行中的元素？"><a href="#如何访问名为M的矩阵的第2列和第4行中的元素？" class="headerlink" title="如何访问名为M的矩阵的第2列和第4行中的元素？"></a>如何访问名为M的矩阵的第2列和第4行中的元素？</h3><p>表达式M [4,2]给出了第4行和第2列的元素。</p><h3 id="什么是向量中元素的回收？举个例子。"><a href="#什么是向量中元素的回收？举个例子。" class="headerlink" title="什么是向量中元素的回收？举个例子。"></a>什么是向量中元素的回收？举个例子。</h3><p>当在操作中涉及不同长度的两个向量时，较短向量的元素被重用以完成操作。这被称为元素循环。示例-v1 &lt;-c（4,1,0,6）和V2 &lt;-c（2,4），则v1 * v2给出（8,4,0,24）。重复元件2和4。</p><h3 id="在R语言中调用函数有什么不同的方法？"><a href="#在R语言中调用函数有什么不同的方法？" class="headerlink" title="在R语言中调用函数有什么不同的方法？"></a>在R语言中调用函数有什么不同的方法？</h3><p>我们可以用3种方式在R语言中调用一个函数。第一种方法是通过使用参数的位置来调用。第二个方法id通过使用参数的名称来调用，第三个方法是通过默认参数调用。</p><h3 id="什么是R语言中的延迟函数评估？"><a href="#什么是R语言中的延迟函数评估？" class="headerlink" title="什么是R语言中的延迟函数评估？"></a>什么是R语言中的延迟函数评估？</h3><p>函数的延迟评估意味着，只有当它在函数体内部使用时，才会评估参数。如果没有对函数体中的参数的引用，则它被简单地忽略。</p><h3 id="如何在R语言中安装软件包？"><a href="#如何在R语言中安装软件包？" class="headerlink" title="如何在R语言中安装软件包？"></a>如何在R语言中安装软件包？</h3><p>要在R语言中安装一个包，我们使用下面的命令。</p><pre><code>install.packages（"package Name"）</code></pre><p>命名用于读取XML文件的R语言包。<br>名为“XML”的包用于读取和处理XML文件。</p><h3 id="我们可以更新和删除列表中的任何元素吗？"><a href="#我们可以更新和删除列表中的任何元素吗？" class="headerlink" title="我们可以更新和删除列表中的任何元素吗？"></a>我们可以更新和删除列表中的任何元素吗？</h3><p>我们可以更新任何元素，但我们只能删除列表末尾的元素。</p><p>给一般表达式在R语言中创建一个矩阵。<br>在R语言中创建矩阵的一般表达式是 - matrix（data，nrow，ncol，byrow，dimnames）</p><h3 id="该函数用于在R语言中创建boxplot图形？"><a href="#该函数用于在R语言中创建boxplot图形？" class="headerlink" title="该函数用于在R语言中创建boxplot图形？"></a>该函数用于在R语言中创建boxplot图形？</h3><p>boxplot()函数用于在R语言中创建箱线图。它使用公式和数据框作为输入创建箱线图。</p><h3 id="在做时间序列分析时，在ts-函数中fR语言equency-6是什么意思？"><a href="#在做时间序列分析时，在ts-函数中fR语言equency-6是什么意思？" class="headerlink" title="在做时间序列分析时，在ts()函数中fR语言equency = 6是什么意思？"></a>在做时间序列分析时，在ts()函数中fR语言equency = 6是什么意思？</h3><p>频率6表示时间序列数据的时间间隔是每10分钟一小时。</p><h3 id="什么是R语言中的数据重塑？"><a href="#什么是R语言中的数据重塑？" class="headerlink" title="什么是R语言中的数据重塑？"></a>什么是R语言中的数据重塑？</h3><p>在R语言中，数据对象可以从一种形式转换为另一种形式。例如，我们可以通过合并许多列表来创建数据框。这涉及一系列R语言命令，以将数据带入新格式。这被称为数据整形。</p><h3 id="R语言unif（4）的输出是什么？"><a href="#R语言unif（4）的输出是什么？" class="headerlink" title="R语言unif（4）的输出是什么？"></a>R语言unif（4）的输出是什么？</h3><p>它生成0和1之间的4个随机数。</p><h3 id="如何获得R语言中安装的所有软件包的列表？"><a href="#如何获得R语言中安装的所有软件包的列表？" class="headerlink" title="如何获得R语言中安装的所有软件包的列表？"></a>如何获得R语言中安装的所有软件包的列表？</h3><p>使用命令</p><pre><code>installed.packages()</code></pre><h3 id="运行命令-strsplit（x，“e”）是什么意思？"><a href="#运行命令-strsplit（x，“e”）是什么意思？" class="headerlink" title="运行命令 - strsplit（x，“e”）是什么意思？"></a>运行命令 - strsplit（x，“e”）是什么意思？</h3><p>它将向量x中的字符串拆分为字母e位置处的子字符串。</p><p>给一个R脚本从字符串中提取大写的所有唯一字 - “快速的棕色狐狸跳过懒惰的狗”。</p><pre><code>x &lt;- “快速的棕色狐狸跳过懒惰的狗”split.string &lt;- strsplit(x，"")extract.words &lt;- split.string [[1]]result &lt;- unique(tolower(extract.words))print(result)</code></pre><h3 id="向量v是c（1-2-3-4），列表x是列表（5：8），v-x-1-的输出是什么？"><a href="#向量v是c（1-2-3-4），列表x是列表（5：8），v-x-1-的输出是什么？" class="headerlink" title="向量v是c（1,2,3,4），列表x是列表（5：8），v * x [1]的输出是什么？"></a>向量v是c（1,2,3,4），列表x是列表（5：8），v * x [1]的输出是什么？</h3><p>v * x [1]中的错误：二进制运算符的非数值参数</p><h3 id="向量v是c（1-2-3-4），列表x是列表（5：8），v-x-1-的输出是什么？-1"><a href="#向量v是c（1-2-3-4），列表x是列表（5：8），v-x-1-的输出是什么？-1" class="headerlink" title="向量v是c（1,2,3,4），列表x是列表（5：8），v * x [[1]]的输出是什么？"></a>向量v是c（1,2,3,4），列表x是列表（5：8），v * x [[1]]的输出是什么？</h3><pre><code>[1] 5 12 21 32s</code></pre><h3 id="unlist-是什么？"><a href="#unlist-是什么？" class="headerlink" title="unlist()是什么？"></a>unlist()是什么？</h3><p>它将列表转换为向量。</p><p>给予R语言表达式，从使用pbinom的硬币51个硬币中得到26个或更少的头。</p><pre><code>x &lt;- pbinom(26,51,0.5)print(x)</code></pre><h3 id="X是向量c-5-9-2-3-8-51，NA-，mean-x-的输出是什么？"><a href="#X是向量c-5-9-2-3-8-51，NA-，mean-x-的输出是什么？" class="headerlink" title="X是向量c(5,9.2,3,8.51，NA)，mean(x)的输出是什么？"></a>X是向量c(5,9.2,3,8.51，NA)，mean(x)的输出是什么？</h3><p>NA</p><p>###如何将JSON文件中的数据转换为数据框？<br>使用函数as.data.frame()</p><p>###在R语言中给出一个函数，用向量的元素的和代替向量x的所有缺失值？</p><pre><code>function(x){x [is.na(x)] &lt;sum(x,na.rm = TRUE); x }</code></pre><h3 id="apply-在R语言中的用途是什么？"><a href="#apply-在R语言中的用途是什么？" class="headerlink" title="apply()在R语言中的用途是什么？"></a>apply()在R语言中的用途是什么？</h3><p>它用于对数组中的每个元素应用相同的函数。例如，查找每行中行的平均值。</p><h3 id="是数组称为矩阵还是矩阵称为数组？"><a href="#是数组称为矩阵还是矩阵称为数组？" class="headerlink" title="是数组称为矩阵还是矩阵称为数组？"></a>是数组称为矩阵还是矩阵称为数组？</h3><p>每个矩阵可以称为数组，但不能相反。矩阵总是二维的，但数组可以是任何维度。</p><h3 id="如何找到缺失值的帮助页面？"><a href="#如何找到缺失值的帮助页面？" class="headerlink" title="如何找到缺失值的帮助页面？"></a>如何找到缺失值的帮助页面？</h3><p>?NA</p><h3 id="如何获得向量x的标准偏差？"><a href="#如何获得向量x的标准偏差？" class="headerlink" title="如何获得向量x的标准偏差？"></a>如何获得向量x的标准偏差？</h3><pre><code>sd(x,na.rm = TRUE)</code></pre><h3 id="如何在R语言中设置当前工作目录的路径？"><a href="#如何在R语言中设置当前工作目录的路径？" class="headerlink" title="如何在R语言中设置当前工作目录的路径？"></a>如何在R语言中设置当前工作目录的路径？</h3><pre><code>setwd("Path")</code></pre><h3 id="“-”和”-”之间有什么区别？"><a href="#“-”和”-”之间有什么区别？" class="headerlink" title="“%%”和”%/%”之间有什么区别？"></a>“%%”和”%/%”之间有什么区别？</h3><p>“%%”给出第一向量与第二向量的除法的余数，而”%/%”给出第一向量与第二向量的除法的商。</p><h3 id="col-max-x-是什么？"><a href="#col-max-x-是什么？" class="headerlink" title="col.max(x)是什么？"></a>col.max(x)是什么？</h3><p>查找该列具有每行的最大值。</p><p>###给出创建直方图的命令。</p><pre><code>hist()</code></pre><h3 id="如何从R语言工作区中删除向量？"><a href="#如何从R语言工作区中删除向量？" class="headerlink" title="如何从R语言工作区中删除向量？"></a>如何从R语言工作区中删除向量？</h3><pre><code>rm(x)</code></pre><h3 id="列出包”MASS”中可用的数据集"><a href="#列出包”MASS”中可用的数据集" class="headerlink" title="列出包”MASS”中可用的数据集"></a>列出包”MASS”中可用的数据集</h3><pre><code>data(package ="MASS")</code></pre><p>###列出所有可用软件包中可用的数据集。</p><pre><code>data(package = .packages(all.available = TRUE))</code></pre><h3 id="什么是命令的使用-install-packages-file-choose-repos-NULL-？"><a href="#什么是命令的使用-install-packages-file-choose-repos-NULL-？" class="headerlink" title="什么是命令的使用 - install.packages(file.choose(),repos = NULL)？"></a>什么是命令的使用 - install.packages(file.choose(),repos = NULL)？</h3><p>它用于通过浏览和选择文件从本地目录安装R语言包。</p><h3 id="给出命令以检查元素15是否存在于向量x中。"><a href="#给出命令以检查元素15是否存在于向量x中。" class="headerlink" title="给出命令以检查元素15是否存在于向量x中。"></a>给出命令以检查元素15是否存在于向量x中。</h3><pre><code>15%在%x</code></pre><h3 id="给出创建散点图矩阵的语法。"><a href="#给出创建散点图矩阵的语法。" class="headerlink" title="给出创建散点图矩阵的语法。"></a>给出创建散点图矩阵的语法。</h3><pre><code>pairs(formula, data)</code></pre><p>其中公式表示成对使用的变量系列，数据表示从中获取变量的数据集。</p><h3 id="R语言中的subset-函数和sample-函数有什么区别？"><a href="#R语言中的subset-函数和sample-函数有什么区别？" class="headerlink" title="R语言中的subset()函数和sample()函数有什么区别？"></a>R语言中的subset()函数和sample()函数有什么区别？</h3><p>subset()函数用于选择变量和观察值。 sample()函数用于从数据集中选择大小为n的随机样本。</p><h3 id="如何检查”m”是R语言中的矩阵数据对象？"><a href="#如何检查”m”是R语言中的矩阵数据对象？" class="headerlink" title="如何检查”m”是R语言中的矩阵数据对象？"></a>如何检查”m”是R语言中的矩阵数据对象？</h3><p>is.matrix(m)应该重新运行TRUE。</p><h3 id="下面的表达式all-NA-NA-的输出是什么？"><a href="#下面的表达式all-NA-NA-的输出是什么？" class="headerlink" title="下面的表达式all(NA == NA)的输出是什么？"></a>下面的表达式all(NA == NA)的输出是什么？</h3><p>[1] NA</p><h3 id="如何获得矩阵在R语言中的转置？"><a href="#如何获得矩阵在R语言中的转置？" class="headerlink" title="如何获得矩阵在R语言中的转置？"></a>如何获得矩阵在R语言中的转置？</h3><p>函数t()用于转置矩阵。示例-t(m)，其中m是矩阵。</p><h3 id="在R语言中使用”next”语句是什么？"><a href="#在R语言中使用”next”语句是什么？" class="headerlink" title="在R语言中使用”next”语句是什么？"></a>在R语言中使用”next”语句是什么？</h3><p>当我们想要跳过循环的当前迭代而不终止它时，R编程语言中的”next”语句是有用的。</p><h1 id="统计篇"><a href="#统计篇" class="headerlink" title="统计篇"></a>统计篇</h1><h1 id="1-平均值，中位数和模式"><a href="#1-平均值，中位数和模式" class="headerlink" title="1.平均值，中位数和模式"></a>1.平均值，中位数和模式</h1><p>R中的统计分析通过使用许多内置函数来执行。 这些函数大多数是R基础包的一部分。 这些函数将R向量作为输入和参数，并给出结果。</p><p>我们在本章中讨论的功能是平均值，中位数和模式。</p><h3 id="Mean平均值"><a href="#Mean平均值" class="headerlink" title="Mean平均值"></a>Mean平均值</h3><p>通过求出数据集的和再除以求和数的总量得到平均值</p><p>函数mean()用于在R语言中计算平均值。</p><h3 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h3><p>用于计算R中的平均值的基本语法是 -</p><pre><code>mean(x, trim = 0, na.rm = FALSE, ...)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>x是输入向量。</p></li><li><p>trim用于从排序向量的两端丢弃一些观察结果。</p></li><li><p>na.rm用于从输入向量中删除缺失值。</p></li></ul><h3 id="例-14"><a href="#例-14" class="headerlink" title="例"></a>例</h3><pre><code># Create a vector. x &lt;- c(12,7,3,4.2,18,2,54,-21,8,-5)# Find Mean.result.mean &lt;- mean(x)print(result.mean)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 8.22</code></pre><h3 id="应用修剪选项"><a href="#应用修剪选项" class="headerlink" title="应用修剪选项"></a>应用修剪选项</h3><p>当提供trim参数时，向量中的值被排序，然后从计算平均值中减去所需的观察值。 </p><p>当trim = 0.3时，来自每端的3个值将从计算中减去以找到均值。</p><p>在这种情况下，排序的向量是（-21，-5,2,3,4.2,7,8,12,18,54），并且从用于计算平均值的向量中移除的值是（-21，-5,2） 从左边和（12,18,54）从右边。</p><pre><code># Create a vector.x &lt;- c(12,7,3,4.2,18,2,54,-21,8,-5)# Find Mean.result.mean &lt;-  mean(x,trim = 0.3)print(result.mean)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 5.55</code></pre><h3 id="应用NA选项"><a href="#应用NA选项" class="headerlink" title="应用NA选项"></a>应用NA选项</h3><p>如果有缺失值，则平均函数返回NA。</p><p>要从计算中删除缺少的值，请使用na.rm = TRUE。 这意味着去除NA值。</p><pre><code># Create a vector. x &lt;- c(12,7,3,4.2,18,2,54,-21,8,-5,NA)# Find mean.result.mean &lt;-  mean(x)print(result.mean)# Find mean dropping NA values.result.mean &lt;-  mean(x,na.rm = TRUE)print(result.mean)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] NA[1] 8.22</code></pre><h3 id="Median中位数"><a href="#Median中位数" class="headerlink" title="Median中位数"></a>Median中位数</h3><p>数据系列中的最中间值称为中值。 在R语言中使用median()函数来计算此值。</p><h3 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h3><p>计算R语言中位数的基本语法是 -</p><pre><code>median(x, na.rm = FALSE)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>x是输入向量。</p></li><li><p>na.rm用于从输入向量中删除缺失值。</p></li></ul><h3 id="例-15"><a href="#例-15" class="headerlink" title="例"></a>例</h3><pre><code># Create the vector.x &lt;- c(12,7,3,4.2,18,2,54,-21,8,-5)# Find the median.median.result &lt;- median(x)print(median.result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 5.6</code></pre><h3 id="Mode模式"><a href="#Mode模式" class="headerlink" title="Mode模式"></a>Mode模式</h3><p>模式是一组数据中出现次数最多的值。 Unike平均值和中位数，模式可以同时包含数字和字符数据。</p><p>R语言没有标准的内置函数来计算模式。 因此，我们创建一个用户函数来计算R语言中的数据集的模式。该函数将向量作为输入，并将模式值作为输出。</p><h3 id="例-16"><a href="#例-16" class="headerlink" title="例"></a>例</h3><pre><code># Create the function.getmode &lt;- function(v) {   uniqv &lt;- unique(v)   uniqv[which.max(tabulate(match(v, uniqv)))]}# Create the vector with numbers.v &lt;- c(2,1,2,3,1,2,3,4,1,5,5,3,2,3)# Calculate the mode using the user function.result &lt;- getmode(v)print(result)# Create the vector with characters.charv &lt;- c("o","it","the","it","it")# Calculate the mode using the user function.result &lt;- getmode(charv)print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 2[1] "it"</code></pre><h1 id="2-线性回归"><a href="#2-线性回归" class="headerlink" title="2.线性回归"></a>2.线性回归</h1><p>回归分析是一种非常广泛使用的统计工具，用于建立两个变量之间的关系模型。 这些变量之一称为预测变量，其值通过实验收集。 另一个变量称为响应变量，其值从预测变量派生。</p><p>在线性回归中，这两个变量通过方程相关，其中这两个变量的指数（幂）为1.数学上，线性关系表示当绘制为曲线图时的直线。 任何变量的指数不等于1的非线性关系将创建一条曲线。</p><p>线性回归的一般数学方程为 -</p><pre><code>y = ax + b</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>y</strong>是响应变量。</p></li><li><p><strong>x</strong>是预测变量。</p></li><li><p><strong>a</strong>和<strong>b</strong>被称为系数常数。</p></li></ul><h3 id="建立回归的步骤"><a href="#建立回归的步骤" class="headerlink" title="建立回归的步骤"></a>建立回归的步骤</h3><p>回归的简单例子是当人的身高已知时预测人的体重。 为了做到这一点，我们需要有一个人的身高和体重之间的关系。</p><p>创建关系的步骤是 - </p><ul><li><p>进行收集高度和相应重量的观测值的样本的实验。</p></li><li><p>使用R语言中的<strong>lm()</strong>函数创建关系模型。</p></li><li><p>从创建的模型中找到系数，并使用这些创建数学方程</p></li><li><p>获得关系模型的摘要以了解预测中的平均误差。 也称为残差。</p></li><li><p>为了预测新人的体重，使用R中的<strong>predict()</strong>函数。</p></li></ul><h3 id="输入数据-3"><a href="#输入数据-3" class="headerlink" title="输入数据"></a>输入数据</h3><p>下面是代表观察的样本数据 -</p><pre><code># Values of height151, 174, 138, 186, 128, 136, 179, 163, 152, 131# Values of weight.63, 81, 56, 91, 47, 57, 76, 72, 62, 48</code></pre><h3 id="LM-函数"><a href="#LM-函数" class="headerlink" title="LM()函数"></a>LM()函数</h3><p>此函数创建预测变量和响应变量之间的关系模型。</p><h3 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h3><p>线性回归中<strong>lm()</strong>函数的基本语法是 -</p><pre><code>lm(formula,data)</code></pre><p>以下是所使用的参数的说明 -</p><ul><li><p>公式是表示<strong>x</strong>和<strong>y</strong>之间的关系的符号。</p></li><li><p>数据是应用公式的向量。</p></li></ul><h3 id="创建关系模型并获取系数"><a href="#创建关系模型并获取系数" class="headerlink" title="创建关系模型并获取系数"></a>创建关系模型并获取系数</h3><pre><code>x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)# Apply the lm() function.relation &lt;- lm(y~x)print(relation)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Call:lm(formula = y ~ x)Coefficients:(Intercept)            x     -38.4551          0.6746 </code></pre><h3 id="获取相关的摘要"><a href="#获取相关的摘要" class="headerlink" title="获取相关的摘要"></a>获取相关的摘要</h3><pre><code>x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)# Apply the lm() function.relation &lt;- lm(y~x)print(summary(relation))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Call:lm(formula = y ~ x)Residuals:    Min      1Q     Median      3Q     Max -6.3002    -1.6629  0.0412    1.8944  3.9775 Coefficients:             Estimate Std. Error t value Pr(&gt;|t|)    (Intercept) -38.45509    8.04901  -4.778  0.00139 ** x             0.67461    0.05191  12.997 1.16e-06 ***---Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1Residual standard error: 3.253 on 8 degrees of freedomMultiple R-squared:  0.9548,    Adjusted R-squared:  0.9491 F-statistic: 168.9 on 1 and 8 DF,  p-value: 1.164e-06</code></pre><h3 id="predict-函数"><a href="#predict-函数" class="headerlink" title="predict()函数"></a>predict()函数</h3><h3 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h3><p>线性回归中的predict（）的基本语法是 -</p><pre><code>predict(object, newdata)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>object</strong>是已使用<strong>lm()</strong>函数创建的公式。</p></li><li><p><strong>newdata</strong>是包含预测变量的新值的向量。</p></li></ul><h3 id="预测新人的体重"><a href="#预测新人的体重" class="headerlink" title="预测新人的体重"></a>预测新人的体重</h3><pre><code># The predictor vector.x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)# The resposne vector.y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)# Apply the lm() function.relation &lt;- lm(y~x)# Find weight of a person with height 170.a &lt;- data.frame(x = 170)result &lt;-  predict(relation,a)print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      1 76.22869 </code></pre><h3 id="以图形方式可视化回归"><a href="#以图形方式可视化回归" class="headerlink" title="以图形方式可视化回归"></a>以图形方式可视化回归</h3><pre><code># Create the predictor and response variable.x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)relation &lt;- lm(y~x)# Give the chart file a name.png(file = "linearregression.png")# Plot the chart.plot(y,x,col = "blue",main = "Height &amp; Weight Regression",abline(lm(x~y)),cex = 1.3,pch = 16,xlab = "Weight in Kg",ylab = "Height in cm")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-4fefe7ec44266e7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="R中线性回归"></p><h1 id="3-多重回归"><a href="#3-多重回归" class="headerlink" title="3.多重回归"></a>3.多重回归</h1><p>多元回归是线性回归到两个以上变量之间的关系的延伸。 在简单线性关系中，我们有一个预测变量和一个响应变量，但在多元回归中，我们有多个预测变量和一个响应变量。</p><p>多元回归的一般数学方程为 -</p><pre><code>y = a + b1x1 + b2x2 +...bnxn</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>y是响应变量。</p></li><li><p>a，b1，b2 … bn是系数。</p></li><li><p>x1，x2，… xn是预测变量。</p></li></ul><p>我们使用R语言中的lm()函数创建回归模型。模型使用输入数据确定系数的值。 接下来，我们可以使用这些系数来预测给定的一组预测变量的响应变量的值。</p><h3 id="lm-函数"><a href="#lm-函数" class="headerlink" title="lm()函数"></a>lm()函数</h3><p>此函数创建预测变量和响应变量之间的关系模型。</p><h3 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h3><p>lm()函数在多元回归中的基本语法是 -</p><pre><code>lm(y ~ x1+x2+x3...,data)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>公式是表示响应变量和预测变量之间的关系的符号。</p></li><li><p>数据是应用公式的向量。</p></li></ul><h3 id="例-17"><a href="#例-17" class="headerlink" title="例"></a>例</h3><p>输入数据<br>考虑在R语言环境中可用的数据集“mtcars”。 它给出了每加仑里程（mpg），气缸排量（“disp”），马力（“hp”），汽车重量（“wt”）和一些其他参数的不同汽车模型之间的比较。</p><p>模型的目标是建立“mpg”作为响应变量与“disp”，“hp”和“wt”作为预测变量之间的关系。 为此，我们从mtcars数据集中创建这些变量的子集。</p><pre><code>input &lt;- mtcars[,c("mpg","disp","hp","wt")]print(head(input))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>                   mpg   disp   hp    wtMazda RX4          21.0  160    110   2.620Mazda RX4 Wag      21.0  160    110   2.875Datsun 710         22.8  108     93   2.320Hornet 4 Drive     21.4  258    110   3.215Hornet Sportabout  18.7  360    175   3.440Valiant            18.1  225    105   3.460</code></pre><p>创建关系模型并获取系数</p><pre><code>input &lt;- mtcars[,c("mpg","disp","hp","wt")]# Create the relationship model.model &lt;- lm(mpg~disp+hp+wt, data = input)# Show the model.print(model)# Get the Intercept and coefficients as vector elements.cat("# # # # The Coefficient Values # # # ","")a &lt;- coef(model)[1]print(a)Xdisp &lt;- coef(model)[2]Xhp &lt;- coef(model)[3]Xwt &lt;- coef(model)[4]print(Xdisp)print(Xhp)print(Xwt)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Call:lm(formula = mpg ~ disp + hp + wt, data = input)Coefficients:(Intercept)         disp           hp           wt    37.105505      -0.000937        -0.031157    -3.800891  # # # # The Coefficient Values # # # (Intercept)    37.10551          disp -0.0009370091          hp -0.03115655        wt -3.800891 </code></pre><h3 id="创建回归模型的方程"><a href="#创建回归模型的方程" class="headerlink" title="创建回归模型的方程"></a>创建回归模型的方程</h3><p>基于上述截距和系数值，我们创建了数学方程。</p><pre><code>Y = a+Xdisp.x1+Xhp.x2+Xwt.x3orY = 37.15+(-0.000937)*x1+(-0.0311)*x2+(-3.8008)*x3</code></pre><h3 id="应用方程预测新值"><a href="#应用方程预测新值" class="headerlink" title="应用方程预测新值"></a>应用方程预测新值</h3><p>当提供一组新的位移，马力和重量值时，我们可以使用上面创建的回归方程来预测里程数。<br>对于disp = 221，hp = 102和wt = 2.91的汽车，预测里程为 -</p><pre><code>Y = 37.15+(-0.000937)*221+(-0.0311)*102+(-3.8008)*2.91 = 22.7104</code></pre><h1 id="4-逻辑回归"><a href="#4-逻辑回归" class="headerlink" title="4.逻辑回归"></a>4.逻辑回归</h1><p>逻辑回归是回归模型，其中响应变量（因变量）具有诸如True / False或0/1的分类值。它实际上基于将其与预测变量相关的数学方程测量二元响应的概率作为响应变量的值。</p><p>逻辑回归的一般数学方程为 -</p><pre><code>y = 1/(1+e^-(a+b1x1+b2x2+b3x3+...))</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>Ÿ是响应变量。</p></li><li><p>X是预测变量。</p></li><li><p>一和b是作为数字常数的系数。</p></li></ul><h3 id="用于创建回归模型的函数是GLM（）函数。"><a href="#用于创建回归模型的函数是GLM（）函数。" class="headerlink" title="用于创建回归模型的函数是GLM（）函数。"></a>用于创建回归模型的函数是GLM（）函数。</h3><p>###语法<br>逻辑回归中glm（）函数的基本语法是 -</p><pre><code>glm(formula,data,family)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>式是表示变量之间的关系的符号。</p></li><li><p>数据是给出这些变量的值的数据集。</p></li><li><p>family是R语言对象来指定模型的细节。它的值是二项逻辑回归。</p></li></ul><h3 id="例-18"><a href="#例-18" class="headerlink" title="例"></a>例</h3><p>内置数据集“mtcars”描述具有各种发动机规格的汽车的不同型号。在“mtcars”数据集中，传输模式（自动或手动）由am列描述，它是一个二进制值（0或1）。我们可以在列“是”和其他3列（马力，重量和CYL）之间创建逻辑回归模型。</p><pre><code># Select some columns form mtcars.input &lt;- mtcars[,c("am","cyl","hp","wt")]print(head(input))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>                  am   cyl  hp    wtMazda RX4          1   6    110   2.620Mazda RX4 Wag      1   6    110   2.875Datsun 710         1   4     93   2.320Hornet 4 Drive     0   6    110   3.215Hornet Sportabout  0   8    175   3.440Valiant            0   6    105   3.460</code></pre><h3 id="创建回归模型"><a href="#创建回归模型" class="headerlink" title="创建回归模型"></a>创建回归模型</h3><p>我们使用GLM（）函数创建回归模型，并得到其摘要进行分析。</p><pre><code>input &lt;- mtcars[,c("am","cyl","hp","wt")]am.data = glm(formula = am ~ cyl + hp + wt, data = input, family = binomial)print(summary(am.data))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Call:glm(formula = am ~ cyl + hp + wt, family = binomial, data = input)Deviance Residuals:      Min        1Q      Median        3Q       Max  -2.17272     -0.14907  -0.01464     0.14116   1.27641  Coefficients:            Estimate Std. Error z value Pr(&gt;|z|)  (Intercept) 19.70288    8.11637   2.428   0.0152 *cyl          0.48760    1.07162   0.455   0.6491  hp           0.03259    0.01886   1.728   0.0840 .wt          -9.14947    4.15332  -2.203   0.0276 *---Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1(Dispersion parameter for binomial family taken to be 1)    Null deviance: 43.2297  on 31  degrees of freedomResidual deviance:  9.8415  on 28  degrees of freedomAIC: 17.841Number of Fisher Scoring iterations: 8</code></pre><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在总结中，对于变量“cyl”和“hp”，最后一列中的p值大于0.05，我们认为它们对变量“am”的值有贡献是无关紧要的。只有重量（wt）影响该回归模型中的“是”值。</p><h1 id="5-标准分布"><a href="#5-标准分布" class="headerlink" title="5.标准分布"></a>5.标准分布</h1><p>在来自独立源的数据的随机集合中，通常观察到数据的分布是正常的。这意味着，在绘制水平轴上的变量值和垂直轴上的值的计数的图形时，我们得到钟形曲线。曲线的中心表示数据集的平均值。在图中，50％的值位于平均值的左侧，另外50％位于图表的右侧。这在统计学中被称为正态分布。</p><p>R语言有四个内置函数来产生正态分布。它们描述如下。</p><pre><code>dnorm(x, mean, sd)pnorm(x, mean, sd)qnorm(p, mean, sd)rnorm(n, mean, sd)</code></pre><p>以下是在上述功能中使用的参数的描述 - </p><ul><li><p><strong>X</strong>是数字的向量。</p></li><li><p><strong>p</strong>是概率的向量。</p></li><li><p><strong>Ñ</strong>是观察的数量（样本大小）。</p></li><li><p><strong>mean</strong>是样本数据的平均值。它的默认值为零。</p></li><li><p><strong>sd</strong>是标准偏差。它的默认值为1。</p></li></ul><h3 id="dnorm（）"><a href="#dnorm（）" class="headerlink" title="dnorm（）"></a>dnorm（）</h3><p>该函数给出给定平均值和标准偏差在每个点的概率分布的高度。</p><pre><code># Create a sequence of numbers between -10 and 10 incrementing by 0.1.x &lt;- seq(-10, 10, by = .1)# Choose the mean as 2.5 and standard deviation as 0.5.y &lt;- dnorm(x, mean = 2.5, sd = 0.5)# Give the chart file a name.png(file = "dnorm.png")plot(x,y)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0d46ed17cdbd4403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dnorm（）图"></p><h3 id="pnorm（）"><a href="#pnorm（）" class="headerlink" title="pnorm（）"></a>pnorm（）</h3><p>该函数给出正态分布随机数的概率小于给定数的值。它也被称为“累积分布函数”。</p><pre><code># Create a sequence of numbers between -10 and 10 incrementing by 0.2.x &lt;- seq(-10,10,by = .2)# Choose the mean as 2.5 and standard deviation as 2\. y &lt;- pnorm(x, mean = 2.5, sd = 2)# Give the chart file a name.png(file = "pnorm.png")# Plot the graph.plot(x,y)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-9de1d7c995b83620.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pnorm（）图"></p><h3 id="qnorm（）"><a href="#qnorm（）" class="headerlink" title="qnorm（）"></a>qnorm（）</h3><p>该函数采用概率值，并给出累积值与概率值匹配的数字。</p><pre><code># Create a sequence of probability values incrementing by 0.02.x &lt;- seq(0, 1, by = 0.02)# Choose the mean as 2 and standard deviation as 3.y &lt;- qnorm(x, mean = 2, sd = 1)# Give the chart file a name.png(file = "qnorm.png")# Plot the graph.plot(x,y)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-89ef8e62a5568e24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="qnorm（）图"></p><h3 id="RNORM（）"><a href="#RNORM（）" class="headerlink" title="RNORM（）"></a>RNORM（）</h3><p>此函数用于生成分布正常的随机数。它将样本大小作为输入，并生成许多随机数。我们绘制一个直方图来显示生成的数字的分布。</p><pre><code># Create a sample of 50 numbers which are normally distributed.y &lt;- rnorm(50)# Give the chart file a name.png(file = "rnorm.png")# Plot the histogram for this sample.hist(y, main = "Normal DIstribution")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-8dee5625b739e0e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RNORM（）图"></p><h1 id="6-二项分布"><a href="#6-二项分布" class="headerlink" title="6.二项分布"></a>6.二项分布</h1><p>二项分布模型处理在一系列实验中仅发现两个可能结果的事件的成功概率。 例如，掷硬币总是给出头或尾。 在二项分布期间估计在10次重复抛掷硬币中精确找到3个头的概率。</p><p>R语言有四个内置函数来生成二项分布。 它们描述如下。</p><pre><code>dbinom(x, size, prob)pbinom(x, size, prob)qbinom(p, size, prob)rbinom(n, size, prob)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>x</strong>是数字的向量。</p></li><li><p><strong>p</strong>是概率向量。</p></li><li><p><strong>n</strong>是观察的数量。</p></li><li><p><strong>size</strong>是试验的数量。</p></li><li><p><strong>prob</strong>是每个试验成功的概率。</p></li></ul><h3 id="dbinom（）"><a href="#dbinom（）" class="headerlink" title="dbinom（）"></a>dbinom（）</h3><p>该函数给出每个点的概率密度分布。</p><pre><code># Create a sample of 50 numbers which are incremented by 1.x &lt;- seq(0,50,by = 1)# Create the binomial distribution.y &lt;- dbinom(x,50,0.5)# Give the chart file a name.png(file = "dbinom.png")# Plot the graph for this sample.plot(x,y)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-b294a38ff32aebfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dbinom（）图"></p><h3 id="pbinom（）"><a href="#pbinom（）" class="headerlink" title="pbinom（）"></a>pbinom（）</h3><p>此函数给出事件的累积概率。 它是表示概率的单个值。</p><pre><code># Probability of getting 26 or less heads from a 51 tosses of a coin.x &lt;- pbinom(26,51,0.5)print(x)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 0.610116</code></pre><h3 id="qbinom（）"><a href="#qbinom（）" class="headerlink" title="qbinom（）"></a>qbinom（）</h3><p>该函数采用概率值，并给出累积值与概率值匹配的数字。</p><pre><code># How many heads will have a probability of 0.25 will come out when a coin is tossed 51 times.x &lt;- qbinom(0.25,51,1/2)print(x)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 23</code></pre><h3 id="rbinom（）"><a href="#rbinom（）" class="headerlink" title="rbinom（）"></a>rbinom（）</h3><p>该函数从给定样本产生给定概率的所需数量的随机值。</p><pre><code># Find 8 random values from a sample of 150 with probability of 0.4.x &lt;- rbinom(8,150,.4)print(x)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 58 61 59 66 55 60 61 67</code></pre><h1 id="7-泊松回归"><a href="#7-泊松回归" class="headerlink" title="7.泊松回归"></a>7.泊松回归</h1><p>泊松回归包括回归模型，其中响应变量是计数而不是分数的形式。 例如，足球比赛系列中的出生次数或胜利次数。 此外，响应变量的值遵循泊松分布。</p><p>泊松回归的一般数学方程为 -</p><pre><code>log(y) = a + b1x1 + b2x2 + bnxn.....</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>y是响应变量。</p></li><li><p>a和b是数字系数。</p></li><li><p>x是预测变量。</p></li></ul><p>###用于创建泊松回归模型的函数是glm()函数。</p><h3 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h3><p>在泊松回归中glm()函数的基本语法是 -</p><pre><code>glm(formula,data,family)</code></pre><p>以下是在上述功能中使用的参数的描述 - </p><ul><li><p>formula是表示变量之间的关系的符号。</p></li><li><p>data是给出这些变量的值的数据集。</p></li><li><p>family是R语言对象来指定模型的细节。 它的值是“泊松”的逻辑回归。</p></li></ul><h3 id="例-19"><a href="#例-19" class="headerlink" title="例"></a>例</h3><p>我们有内置的数据集“warpbreaks”，其描述了羊毛类型（A或B）和张力（低，中或高）对每个织机的经纱断裂数量的影响。 让我们考虑“休息”作为响应变量，它是休息次数的计数。 羊毛“类型”和“张力”作为预测变量。</p><p>输入数据</p><pre><code>input &lt;- warpbreaksprint(head(input))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      breaks   wool  tension1     26       A     L2     30       A     L3     54       A     L4     25       A     L5     70       A     L6     52       A     L</code></pre><p>创建回归模型</p><pre><code>output &lt;-glm(formula = breaks ~ wool+tension,                    data = warpbreaks,                  family = poisson)print(summary(output))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Call:glm(formula = breaks ~ wool + tension, family = poisson, data = warpbreaks)Deviance Residuals:     Min       1Q     Median       3Q      Max    -3.6871  -1.6503  -0.4269     1.1902   4.2616  Coefficients:            Estimate Std. Error z value Pr(&gt;|z|)    (Intercept)  3.69196    0.04541  81.302  &lt; 2e-16 ***woolB       -0.20599    0.05157  -3.994 6.49e-05 ***tensionM    -0.32132    0.06027  -5.332 9.73e-08 ***tensionH    -0.51849    0.06396  -8.107 5.21e-16 ***---Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1(Dispersion parameter for poisson family taken to be 1)    Null deviance: 297.37  on 53  degrees of freedomResidual deviance: 210.39  on 50  degrees of freedomAIC: 493.06Number of Fisher Scoring iterations: 4</code></pre><p>在摘要中，我们查找最后一列中的p值小于0.05，以考虑预测变量对响应变量的影响。 如图所示，具有张力类型M和H的羊毛类型B对断裂计数有影响。</p><h1 id="8-协方差分析"><a href="#8-协方差分析" class="headerlink" title="8.协方差分析"></a>8.协方差分析</h1><p>我们使用回归分析创建模型，描述变量在预测变量对响应变量的影响。 有时，如果我们有一个类别变量，如Yes / No或Male / Female等。简单的回归分析为分类变量的每个值提供多个结果。 在这种情况下，我们可以通过将分类变量与预测变量一起使用并比较分类变量的每个级别的回归线来研究分类变量的效果。 这样的分析被称为协方差分析，也称为ANCOVA。</p><h3 id="例-20"><a href="#例-20" class="headerlink" title="例"></a>例</h3><p>考虑在数据集mtcars中内置的R语言。 在其中我们观察到字段“am”表示传输的类型（自动或手动）。 它是值为0和1的分类变量。汽车的每加仑英里数（mpg）也可以取决于马力（“hp”）的值。</p><p>我们研究“am”的值对“mpg”和“hp”之间回归的影响。 它是通过使用aov()函数，然后使用anova()函数来比较多个回归来完成的。</p><h3 id="输入数据-4"><a href="#输入数据-4" class="headerlink" title="输入数据"></a>输入数据</h3><p>从数据集mtcars创建一个包含字段“mpg”，“hp”和“am”的数据框。 这里我们取“mpg”作为响应变量，“hp”作为预测变量，“am”作为分类变量。</p><pre><code>input &lt;- mtcars[,c("am","mpg","hp")]print(head(input))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>                   am   mpg   hpMazda RX4          1    21.0  110Mazda RX4 Wag      1    21.0  110Datsun 710         1    22.8   93Hornet 4 Drive     0    21.4  110Hornet Sportabout  0    18.7  175Valiant            0    18.1  105</code></pre><h3 id="协方差分析"><a href="#协方差分析" class="headerlink" title="协方差分析"></a>协方差分析</h3><p>我们创建一个回归模型，以“hp”作为预测变量，“mpg”作为响应变量，考虑“am”和“hp”之间的相互作用。</p><p>模型与分类变量和预测变量之间的相互作用</p><pre><code># Get the dataset.input &lt;- mtcars# Create the regression model.result &lt;- aov(mpg~hp*am,data = input)print(summary(result))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>            Df Sum Sq Mean Sq F value   Pr(&gt;F)    hp           1  678.4   678.4  77.391 1.50e-09 ***am           1  202.2   202.2  23.072 4.75e-05 ***hp:am        1    0.0     0.0   0.001    0.981    Residuals   28  245.4     8.8                     ---Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</code></pre><p>这个结果表明，马力和传输类型对每加仑的英里有显着的影响，因为两种情况下的p值都小于0.05。 但是这两个变量之间的相互作用不显着，因为p值大于0.05。</p><p>没有分类变量和预测变量之间相互作用的模型</p><pre><code># Get the dataset.input &lt;- mtcars# Create the regression model.result &lt;- aov(mpg~hp+am,data = input)print(summary(result))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>            Df  Sum Sq  Mean Sq   F value   Pr(&gt;F)    hp           1  678.4   678.4   80.15 7.63e-10 ***am           1  202.2   202.2   23.89 3.46e-05 ***Residuals   29  245.4     8.5                     ---Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</code></pre><p>这个结果表明，马力和传输类型对每加仑的英里有显着的影响，因为两种情况下的p值都小于0.05。</p><h3 id="比较两个模型"><a href="#比较两个模型" class="headerlink" title="比较两个模型"></a>比较两个模型</h3><p>现在我们可以比较两个模型来得出结论，变量的相互作用是否真正重要。 为此，我们使用anova()函数。</p><pre><code># Get the dataset.input &lt;- mtcars# Create the regression models.result1 &lt;- aov(mpg~hp*am,data = input)result2 &lt;- aov(mpg~hp+am,data = input)# Compare the two models.print(anova(result1,result2))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Model 1: mpg ~ hp * amModel 2: mpg ~ hp + am  Res.Df    RSS Df  Sum of Sq     F Pr(&gt;F)1     28 245.43                           2     29 245.44 -1 -0.0052515 6e-04 0.9806</code></pre><p>由于p值大于0.05，我们得出结论，马力和传播类型之间的相互作用不显着。 因此，在汽车和手动变速器模式下，每加仑的里程将以类似的方式取决于汽车的马力。</p><h1 id="9-时间序列分析"><a href="#9-时间序列分析" class="headerlink" title="9.时间序列分析"></a>9.时间序列分析</h1><p>时间序列是一系列数据点，其中每个数据点与时间戳相关联。 一个简单的例子是股票在某一天的不同时间点的股票价格。 另一个例子是一个地区在一年中不同月份的降雨量。 R语言使用许多函数来创建，操作和绘制时间序列数据。 时间序列的数据存储在称为时间序列对象的R对象中。 它也是一个R语言数据对象，如矢量或数据帧。</p><p>使用ts()函数创建时间序列对象。</p><h2 id="语法-19"><a href="#语法-19" class="headerlink" title="语法"></a>语法</h2><p>时间序列分析中<strong>ts()</strong>函数的基本语法是 -</p><pre><code>timeseries.object.name &lt;-  ts(data, start, end, frequency)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>data</strong>是包含在时间序列中使用的值的向量或矩阵。</p></li><li><p><strong>start</strong>以时间序列指定第一次观察的开始时间。</p></li><li><p><strong>end</strong>指定时间序列中最后一次观测的结束时间。</p></li><li><p><strong>frequency</strong>指定每单位时间的观测数。</p></li></ul><p>除了参数“data”，所有其他参数是可选的。</p><h2 id="例-21"><a href="#例-21" class="headerlink" title="例"></a>例</h2><p>考虑从2012年1月开始的一个地方的年降雨量细节。我们创建一个R时间序列对象为期12个月并绘制它。</p><pre><code># Get the data points in form of a R vector.rainfall &lt;- c(799,1174.8,865.1,1334.6,635.4,918.5,685.5,998.6,784.2,985,882.8,1071)# Convert it to a time series object.rainfall.timeseries &lt;- ts(rainfall,start = c(2012,1),frequency = 12)# Print the timeseries data.print(rainfall.timeseries)# Give the chart file a name.png(file = "rainfall.png")# Plot a graph of the time series.plot(rainfall.timeseries)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果及图表 -</p><pre><code>Jan    Feb    Mar    Apr    May     Jun    Jul    Aug    Sep2012  799.0  1174.8  865.1  1334.6  635.4  918.5  685.5  998.6  784.2        Oct    Nov    Dec2012  985.0  882.8 1071.0</code></pre><p>时间序列图 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-cb2f3ea239650e3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="时间序列，使用R"></p><h2 id="不同的时间间隔"><a href="#不同的时间间隔" class="headerlink" title="不同的时间间隔"></a>不同的时间间隔</h2><p><strong>ts()</strong>函数中的频率参数值决定了测量数据点的时间间隔。 值为12表示时间序列为12个月。 其他值及其含义如下 - </p><ul><li><p>频率= 12指定一年中每个月的数据点。</p></li><li><p>频率= 4每年的每个季度的数据点。</p></li><li><p>频率= 6每小时的10分钟的数据点。</p></li><li><p>频率= 24 * 6将一天的每10分钟的数据点固定。</p></li></ul><h2 id="多时间序列"><a href="#多时间序列" class="headerlink" title="多时间序列"></a>多时间序列</h2><p>我们可以通过将两个系列组合成一个矩阵，在一个图表中绘制多个时间序列。</p><pre><code># Get the data points in form of a R vector.rainfall1 &lt;- c(799,1174.8,865.1,1334.6,635.4,918.5,685.5,998.6,784.2,985,882.8,1071)rainfall2 &lt;-            c(655,1306.9,1323.4,1172.2,562.2,824,822.4,1265.5,799.6,1105.6,1106.7,1337.8)# Convert them to a matrix.combined.rainfall &lt;-  matrix(c(rainfall1,rainfall2),nrow = 12)# Convert it to a time series object.rainfall.timeseries &lt;- ts(combined.rainfall,start = c(2012,1),frequency = 12)# Print the timeseries data.print(rainfall.timeseries)# Give the chart file a name.png(file = "rainfall_combined.png")# Plot a graph of the time series.plot(rainfall.timeseries, main = "Multiple Time Series")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果及图表 -</p><pre><code>          Series 1  Series 2Jan 2012    799.0    655.0Feb 2012   1174.8   1306.9Mar 2012    865.1   1323.4Apr 2012   1334.6   1172.2May 2012    635.4    562.2Jun 2012    918.5    824.0Jul 2012    685.5    822.4Aug 2012    998.6   1265.5Sep 2012    784.2    799.6Oct 2012    985.0   1105.6Nov 2012    882.8   1106.7Dec 2012   1071.0   1337.8</code></pre><p>多时间序列图 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-5bfab3dbfb998f01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结合时间序列，使用R"></p><h1 id="10-非线性最小二乘"><a href="#10-非线性最小二乘" class="headerlink" title="10.非线性最小二乘"></a>10.非线性最小二乘</h1><p>当模拟真实世界数据用于回归分析时，我们观察到，很少情况下，模型的方程是给出线性图的线性方程。大多数时候，真实世界数据模型的方程涉及更高程度的数学函数，如3的指数或sin函数。在这种情况下，模型的图给出了曲线而不是线。线性和非线性回归的目的是调整模型参数的值，以找到最接近您的数据的线或曲线。在找到这些值时，我们将能够以良好的精确度估计响应变量。</p><p>在最小二乘回归中，我们建立了一个回归模型，其中来自回归曲线的不同点的垂直距离的平方和被最小化。我们通常从定义的模型开始，并假设系数的一些值。然后我们应用R语言的<strong>nls()</strong>函数获得更准确的值以及置信区间。</p><h2 id="语法-20"><a href="#语法-20" class="headerlink" title="语法"></a>语法</h2><p>在R语言中创建非线性最小二乘测试的基本语法是 -</p><pre><code>nls(formula, data, start)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>formula</strong>是包括变量和参数的非线性模型公式。</p></li><li><p><strong>data</strong>是用于计算公式中变量的数据框。</p></li><li><p><strong>start</strong>是起始估计的命名列表或命名数字向量。</p></li></ul><h2 id="例-22"><a href="#例-22" class="headerlink" title="例"></a>例</h2><p>我们将考虑一个假设其系数的初始值的非线性模型。 接下来，我们将看到这些假设值的置信区间是什么，以便我们可以判断这些值在模型中有多好。</p><p>所以让我们考虑下面的方程为这个目的 -</p><pre><code>a = b1*x^2+b2</code></pre><p>让我们假设初始系数为1和3，并将这些值拟合到<strong>nls()</strong>函数中。</p><pre><code>xvalues &lt;- c(1.6,2.1,2,2.23,3.71,3.25,3.4,3.86,1.19,2.21)yvalues &lt;- c(5.19,7.43,6.94,8.11,18.75,14.88,16.06,19.12,3.21,7.58)# Give the chart file a name.png(file = "nls.png")# Plot these values.plot(xvalues,yvalues)# Take the assumed values and fit into the model.model &lt;- nls(yvalues ~ b1*xvalues^2+b2,start = list(b1 = 1,b2 = 3))# Plot the chart with new data by fitting it to a prediction from 100 data points.new.data &lt;- data.frame(xvalues = seq(min(xvalues),max(xvalues),len = 100))lines(new.data$xvalues,predict(model,newdata = new.data))# Save the file.dev.off()# Get the sum of the squared residuals.print(sum(resid(model)^2))# Get the confidence intervals on the chosen values of the coefficients.print(confint(model))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 1.081935Waiting for profiling to be done...       2.5%    97.5%b1 1.137708 1.253135b2 1.497364 2.496484</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-064077d964aabf50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="非线性至少方块R"></p><p>我们可以得出结论，b1的值更接近1，而b2的值更接近2而不是3。</p><h1 id="11-决策树"><a href="#11-决策树" class="headerlink" title="11.决策树"></a>11.决策树</h1><p>决策树是以树的形式表示选择及其结果的图。图中的节点表示事件或选择，并且图的边缘表示决策规则或条件。它主要用于使用R的机器学习和数据挖掘应用程序。</p><p>决策树的使用的例子是 - 预测电子邮件是垃圾邮件或非垃圾邮件，预测肿瘤癌变，或者基于这些因素预测贷款的信用风险。通常，使用观测数据（也称为训练数据）来创建模型。然后使用一组验证数据来验证和改进模型。 R具有用于创建和可视化决策树的包。对于新的预测变量集合，我们使用此模型来确定R包“party”用于创建决策树。</p><h2 id="安装R语言包"><a href="#安装R语言包" class="headerlink" title="安装R语言包"></a>安装R语言包</h2><p>在R语言控制台中使用以下命令安装软件包。您还必须安装相关软件包（如果有）。</p><pre><code>install.packages("party")</code></pre><p>“party”包具有用于创建和分析决策树的函数<strong>ctree()</strong>。</p><h2 id="语法-21"><a href="#语法-21" class="headerlink" title="语法"></a>语法</h2><p>在R中创建决策树的基本语法是 -</p><pre><code>ctree(formula, data)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>formula</strong>是描述预测变量和响应变量的公式。</p></li><li><p><strong>data</strong>是所使用的数据集的名称。</p></li></ul><h2 id="输入数据-5"><a href="#输入数据-5" class="headerlink" title="输入数据"></a>输入数据</h2><p>我们将使用名为readingSkills的R内置数据集来创建决策树。 它描述了某人的readingSkills的分数，如果我们知道变量“年龄”，“shoesize”，“分数”，以及该人是否为母语者。</p><p>这里是示例数据。</p><pre><code># Load the party package. It will automatically load other dependent packages.library(party)# Print some records from data set readingSkills.print(head(readingSkills))</code></pre><p>当我们执行上面的代码，它产生以下结果及图表 -</p><pre><code>  nativeSpeaker   age   shoeSize      score1           yes     5   24.83189   32.293852           yes     6   25.95238   36.631053            no    11   30.42170   49.605934           yes     7   28.66450   40.284565           yes    11   31.88207   55.460856           yes    10   30.07843   52.83124Loading required package: methodsLoading required package: grid..............................................................</code></pre><h2 id="例-23"><a href="#例-23" class="headerlink" title="例"></a>例</h2><p>我们将使用<strong>ctree()</strong>函数创建决策树并查看其图形。</p><pre><code># Load the party package. It will automatically load other dependent packages.library(party)# Create the input data frame.input.dat &lt;- readingSkills[c(1:105),]# Give the chart file a name.png(file = "decision_tree.png")# Create the tree.  output.tree &lt;- ctree(  nativeSpeaker ~ age + shoeSize + score,   data = input.dat)# Plot the tree.plot(output.tree)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>null device           1 Loading required package: methodsLoading required package: gridLoading required package: mvtnormLoading required package: modeltoolsLoading required package: stats4Loading required package: strucchangeLoading required package: zooAttaching package: ‘zoo’The following objects are masked from ‘package:base’:    as.Date, as.Date.numericLoading required package: sandwich</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-7bb24598b2a6db61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="决策树，使用R"></p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>从上面显示的决策树，我们可以得出结论，其readingSkills分数低于38.3和年龄超过6的人不是一个母语者。</p><h1 id="12-随机森林算法"><a href="#12-随机森林算法" class="headerlink" title="12.随机森林算法"></a>12.随机森林算法</h1><p>在随机森林方法中，创建大量的决策树。每个观察被馈入每个决策树。每个观察的最常见的结果被用作最终输出。新的观察结果被馈入所有的树并且对 - 个分类模型取多数投票。</p><p>对构建树时未使用的情况进行错误估计。这称为OOB（袋外）误差估计，其被提及为百分比。</p><p>[R语言包“随机森林”用于创建随机森林。</p><p>安装 - [R包<br>在R语言控制台中使用以下命令安装软件包。您还必须安装相关软件包（如果有）。</p><pre><code>install.packages("randomForest)</code></pre><p>包“随机森林”具有函数随机森林（），用于创建和分析随机森林。</p><h3 id="语法-22"><a href="#语法-22" class="headerlink" title="语法"></a>语法</h3><p>在R语言中创建随机森林的基本语法是 -</p><pre><code>randomForest(formula, data)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>式是描述预测变量和响应变量的公式。</p></li><li><p>数据是所使用的数据集的名称。</p></li></ul><h3 id="输入数据-6"><a href="#输入数据-6" class="headerlink" title="输入数据"></a>输入数据</h3><p>我们将使用名为readingSkills的R语言内置数据集来创建决策树。它描述了某人的阅读技能的分数，如果我们知道变量“age”，“shoesize”，“score”，以及该人是否是母语。</p><p>以下是示例数据。</p><pre><code># Load the party package. It will automatically load other required packages.library(party)# Print some records from data set readingSkills.print(head(readingSkills))</code></pre><p>当我们执行上面的代码，它产生以下结果及图表 -</p><pre><code>  nativeSpeaker   age   shoeSize      score1           yes     5   24.83189   32.293852           yes     6   25.95238   36.631053            no    11   30.42170   49.605934           yes     7   28.66450   40.284565           yes    11   31.88207   55.460856           yes    10   30.07843   52.83124Loading required package: methodsLoading required package: grid..............................................................</code></pre><h3 id="例-24"><a href="#例-24" class="headerlink" title="例"></a>例</h3><p>我们将使用随机森林（）函数来创建决策树并查看它的图。</p><pre><code># Load the party package. It will automatically load other required packages.library(party)library(randomForest)# Create the forest.output.forest &lt;- randomForest(nativeSpeaker ~ age + shoeSize + score,            data = readingSkills)# View the forest results.print(output.forest) # Importance of each predictor.print(importance(fit,type = 2)) </code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Call: randomForest(formula = nativeSpeaker ~ age + shoeSize + score,                      data = readingSkills)               Type of random forest: classification                     Number of trees: 500No. of variables tried at each split: 1        OOB estimate of  error rate: 1%Confusion matrix:    no yes class.errorno  99   1        0.01yes  1  99        0.01         MeanDecreaseGiniage              13.95406shoeSize         18.91006score            56.73051</code></pre><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>从上面显示的随机森林，我们可以得出结论，鞋码和成绩是决定如果某人是母语者或不是母语的重要因素。此外，该模型只有1％的误差，这意味着我们可以预测精度为99％。</p><h1 id="13-生存分析"><a href="#13-生存分析" class="headerlink" title="13.生存分析"></a>13.生存分析</h1><p>生存分析处理预测特定事件将要发生的时间。 它也被称为故障时间分析或分析死亡时间。 例如，预测患有癌症的人将存活的天数或预测机械系统将失败的时间。</p><p>命名为<strong>survival</strong>的R语言包用于进行生存分析。 此包包含函数Surv（），它将输入数据作为R语言公式，并在选择的变量中创建一个生存对象用于分析。 然后我们使用函数<strong>survfit()</strong>创建一个分析图。</p><h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><pre><code>install.packages("survival")</code></pre><h3 id="语法-23"><a href="#语法-23" class="headerlink" title="语法"></a>语法</h3><p>在R语言中创建生存分析的基本语法是 -</p><pre><code>Surv(time,event)survfit(formula)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>time</strong>是直到事件发生的跟踪时间。</p></li><li><p><strong>event</strong>指示预期事件的发生的状态。</p></li><li><p><strong>formula</strong>是预测变量之间的关系。</p></li></ul><h3 id="例-25"><a href="#例-25" class="headerlink" title="例"></a>例</h3><p>我们将考虑在上面安装的生存包中存在的名为“pbc”的数据集。 它描述了关于受肝原发性胆汁性肝硬化（PBC）影响的人的生存数据点。 在数据集中存在的许多列中，我们主要关注字段“time”和“status”。 时间表示在接受肝移植或患者死亡的患者的登记和事件的较早之间的天数。</p><pre><code># Load the library.library("survival")# Print first few rows.print(head(pbc))</code></pre><p>当我们执行上面的代码，它产生以下结果及图表 -</p><pre><code>  id time status trt      age sex ascites hepato spiders edema bili chol1  1  400      2   1 58.76523   f       1      1       1   1.0 14.5  2612  2 4500      0   1 56.44627   f       0      1       1   0.0  1.1  3023  3 1012      2   1 70.07255   m       0      0       0   0.5  1.4  1764  4 1925      2   1 54.74059   f       0      1       1   0.5  1.8  2445  5 1504      1   2 38.10541   f       0      1       1   0.0  3.4  2796  6 2503      2   2 66.25873   f       0      1       0   0.0  0.8  248  albumin copper alk.phos    ast trig platelet protime stage1    2.60    156   1718.0 137.95  172      190    12.2     42    4.14     54   7394.8 113.52   88      221    10.6     33    3.48    210    516.0  96.10   55      151    12.0     44    2.54     64   6121.8  60.63   92      183    10.3     45    3.53    143    671.0 113.15   72      136    10.9     36    3.98     50    944.0  93.00   63       NA    11.0     3</code></pre><p>从上述数据，我们正在考虑分析的时间和状态。</p><h3 id="应用Surv（）和survfit（）函数"><a href="#应用Surv（）和survfit（）函数" class="headerlink" title="应用Surv（）和survfit（）函数"></a>应用Surv（）和survfit（）函数</h3><p>现在我们继续应用<strong>Surv()</strong>函数到上面的数据集，并创建一个将显示趋势图。</p><pre><code># Load the library.library("survival")# Create the survival object. survfit(Surv(pbc$time,pbc$status == 2)~1)# Give the chart file a name.png(file = "survival.png")# Plot the graph. plot(survfit(Surv(pbc$time,pbc$status == 2)~1))# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果及图表 -</p><pre><code>Call: survfit(formula = Surv(pbc$time, pbc$status == 2) ~ 1)      n  events  median 0.95LCL 0.95UCL     418     161    3395    3090    3853 </code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-302e42c422d00625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="，使用R生存分析"></p><p>上图中的趋势有助于我们预测在特定天数结束时的生存概率。</p><h1 id="14-卡方检验"><a href="#14-卡方检验" class="headerlink" title="14.卡方检验"></a>14.卡方检验</h1><p>卡方检验是一种确定两个分类变量之间是否存在显着相关性的统计方法。这两个变量应该来自相同的人口，他们应该是类似 - 是/否，男/女，红/绿等。</p><p>例如，我们可以建立一个观察人们的冰淇淋购买模式的数据集，并尝试将一个人的性别与他们喜欢的冰淇淋的味道相关联。如果发现相关性，我们可以通过了解访问的人的性别的数量来计划适当的味道库存。</p><h3 id="语法-24"><a href="#语法-24" class="headerlink" title="语法"></a>语法</h3><p>用于执行卡方检验的函数是chisq.test（）。<br>在R语言中创建卡方检验的基本语法是 -</p><pre><code>chisq.test(data)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li>数据是以包含观察中变量的计数值的表的形式的数据。</li></ul><h3 id="例-26"><a href="#例-26" class="headerlink" title="例"></a>例</h3><p>我们将在“大众”图书馆中获取Cars93数据，该图书馆代表1993年年不同型号汽车的销售额。</p><pre><code>library("MASS")print(str(Cars93))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>'data.frame':   93 obs. of  27 variables:  $ Manufacturer      : Factor w/ 32 levels "Acura","Audi",..: 1 1 2 2 3 4 4 4 4 5 ...  $ Model             : Factor w/ 93 levels "100","190E","240",..: 49 56 9 1 6 24 54 74 73 35 ...  $ Type              : Factor w/ 6 levels "Compact","Large",..: 4 3 1 3 3 3 2 2 3 2 ...  $ Min.Price         : num  12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ...  $ Price             : num  15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ...  $ Max.Price         : num  18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ...  $ MPG.city          : int  25 18 20 19 22 22 19 16 19 16 ...  $ MPG.highway       : int  31 25 26 26 30 31 28 25 27 25 ...  $ AirBags           : Factor w/ 3 levels "Driver &amp; Passenger",..: 3 1 2 1 2 2 2 2 2 2 ...  $ DriveTrain        : Factor w/ 3 levels "4WD","Front",..: 2 2 2 2 3 2 2 3 2 2 ...  $ Cylinders         : Factor w/ 6 levels "3","4","5","6",..: 2 4 4 4 2 2 4 4 4 5 ...  $ EngineSize        : num  1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ...  $ Horsepower        : int  140 200 172 172 208 110 170 180 170 200 ...  $ RPM               : int  6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ...  $ Rev.per.mile      : int  2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ...  $ Man.trans.avail   : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 1 1 1 1 1 ...  $ Fuel.tank.capacity: num  13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ...  $ Passengers        : int  5 5 5 6 4 6 6 6 5 6 ...  $ Length            : int  177 195 180 193 186 189 200 216 198 206 ...  $ Wheelbase         : int  102 115 102 106 109 105 111 116 108 114 ...  $ Width             : int  68 71 67 70 69 69 74 78 73 73 ...  $ Turn.circle       : int  37 38 37 37 39 41 42 45 41 43 ...  $ Rear.seat.room    : num  26.5 30 28 31 27 28 30.5 30.5 26.5 35 ...  $ Luggage.room      : int  11 15 14 17 13 16 17 21 14 18 ...  $ Weight            : int  2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ...  $ Origin            : Factor w/ 2 levels "USA","non-USA": 2 2 2 2 2 1 1 1 1 1 ...  $ Make              : Factor w/ 93 levels "Acura Integra",..: 1 2 4 3 5 6 7 9 8 10 ... </code></pre><p>上述结果表明数据集有很多因素变量，可以被认为是分类变量。对于我们的模型，我们将考虑变量“AirBags”和“Type”。在这里，我们的目标是找出所售的汽车类型和安全如果观察到相关性，我们可以估计哪种类型的汽车可以更好地卖什么类型的气囊。</p><pre><code># Load the library.library("MASS")# Create a data frame from the main data set.car.data &lt;- data.frame(Cars93$AirBags, Cars93$Type)# Create a table with the needed variables.car.data = table(Cars93$AirBags, Cars93$Type) print(car.data)# Perform the Chi-Square test.print(chisq.test(car.data))当我们执行上面的代码，它产生以下结果 -                     Compact Large Midsize Small Sporty Van  Driver &amp; Passenger       2     4       7     0      3   0  Driver only              9     7      11     5      8   3  None                     5     0       4    16      3   6        Pearson's Chi-squared testdata:  car.dataX-squared = 33.001, df = 10, p-value = 0.0002723Warning message:In chisq.test(car.data) : Chi-squared approximation may be incorrect</code></pre><h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>结果显示p值小于0.05，这表明字符串相关。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Server：数据库基础</title>
      <link href="/posts/blog-model02.html"/>
      <url>/posts/blog-model02.html</url>
      
        <content type="html"><![CDATA[<h3 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h3><h5 id="1-1-数据、信息与数据处理"><a href="#1-1-数据、信息与数据处理" class="headerlink" title="1.1 数据、信息与数据处理"></a>1.1 数据、信息与数据处理</h5><p><strong>(1) 数据(Data)</strong>：是数据库中存储的基本对象；</p><ul><li>定义：描述事物的符号记录，是信息的符号表示，或称载体；</li><li>种类：数字、文本、图形、图像、声音、视频，学生的档案记录(40951001, 王二小，男，1988，内蒙，tx1201)等。</li></ul><p><strong>(2) 信息</strong>：数据的内涵，是数据的语义解释。</p><p><strong>(3)数据处理</strong>：将数据转换成信息的过程;<strong>数据管理</strong>： 是数据处理的核心。</p><h6 id="1-2-数据管理技术的产生与发展"><a href="#1-2-数据管理技术的产生与发展" class="headerlink" title="1.2  数据管理技术的产生与发展"></a>1.2  数据管理技术的产生与发展</h6><ol><li>人工管理阶段（20世纪50年代中期前）</li></ol><ul><li>数据不保存</li><li>应用程序管理数据</li><li>数据不具有独立性和共享性</li></ul><ol start="2"><li>文件系统阶段（20世纪50年代后期到60年代中期）</li></ol><ul><li>数据以文件形式可以长期保存在外存储设备上</li><li>由文件系统管理数据（ “按名访问，按记录存取 ” ）</li><li>数据共享性差，冗余度大（ 面向应用 ）</li><li>数据独立性差</li></ul><ol start="3"><li>数据库系统阶段（20世纪60年代后期至今）</li></ol><ul><li>数据结构化, 并与程序分离</li><li>数据的共享性高，冗余度低，易扩充（集中存储）</li><li>数据独立性高</li><li>数据由数据库管理系统统一控制<h6 id="数据库系统阶段——数据独立性高"><a href="#数据库系统阶段——数据独立性高" class="headerlink" title="数据库系统阶段——数据独立性高"></a><strong>数据库系统阶段——数据独立性高</strong></h6><ul><li>物理独立性<br>用户的应用程序与数据库中数据相互独立。当数据的存储格式和组织方法改变时，不影响数据库的逻辑结构，从而不影响应用程序。</li></ul></li><li>逻辑独立性<br>指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序不用改变。</li><li>数据独立性由DBMS的二级映像功能来保证。<h6 id="数据库系统阶段——DBMS提供数据控制功能"><a href="#数据库系统阶段——DBMS提供数据控制功能" class="headerlink" title="数据库系统阶段——DBMS提供数据控制功能"></a>数据库系统阶段——DBMS提供数据控制功能</h6>(1) 数据的安全性（ （Security） ） 控制<br>保护数据 ， 以防止不合法的使用造成的数据的泄密和破坏 。<br>(2) 数据的完整性（ （Integrity） ） 控制<br>将数据控制在有效范围内 ， 或保证数据间满足一定的关系 。<br>(3) 并发（ （Concurrency） ） 控制<br>对多用户的并发操作加以控制和协调 ， 防止相互干扰 。<br>(4) 数据恢复（ （Recovery） ）<br>将数据库从错误状态恢复到某一已知的正确状态 。<h6 id="数据库系统的发展"><a href="#数据库系统的发展" class="headerlink" title="数据库系统的发展"></a>数据库系统的发展</h6></li><li>初级阶段——第一代数据库<br>出现了层次模型、网状模型的数据库</li><li>中级阶段——第二代数据库<br>关系型数据库和结构化查询语言</li><li>高级阶段——新一代数据库<br>“面向对象”型数据库<h5 id="1-3-数据库系统的组成"><a href="#1-3-数据库系统的组成" class="headerlink" title="1.3 数据库系统的组成"></a>1.3 数据库系统的组成</h5>数据库系统（Database System，DBS）包括以下5部分:</li><li>数据库</li><li>数据库管理系统</li><li>硬件系统</li><li>软件系统</li><li>人员(管理员、分析员、设计员、程序员和用户)<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-fe9f7b337ec796e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><ol><li><strong>数据库</strong>(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。<br><strong>数据库的基本特征</strong></li></ol><ul><li>数据按一定的数据模型组织、描述和储存</li><li>可为各种用户共享</li><li>冗余度较小</li><li>数据独立性较高</li><li>易扩展</li></ul><ol start="2"><li><strong>数据库管理系统</strong>（Database ManagementSystem ，简称DBMS）</li></ol><ul><li>管理数据库的系统软件 ，是 数据库系统的<strong>核心</strong> 。</li><li>位于用户与操作系统之间的一层数据管理软件。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-399946837f6ca08e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p><strong>DBMS的主要功能</strong></p><ul><li>数据定义功能（DDL） </li><li>数据操纵功能（DML） </li><li>数据库的事务管理和运行管理</li><li>数据库的建立和维护功能</li><li>数据通信</li></ul><ol start="3"><li><strong>硬件系统</strong><br>硬件系统要有足够的内存用来存放操作系统、DBMS的核心模块、数据缓存、应用程序及数据备份等。</li><li><strong>软件系统</strong><br>包括DBMS、支持DBMS运行的操作系统和具有数据访问接口的高级语言及其编程环境。<h5 id="1-4数据模型"><a href="#1-4数据模型" class="headerlink" title="1.4数据模型"></a>1.4数据模型</h5><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-47b70c171a5ba1bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><p><strong>根据应用目的，模型分为两个层次：</strong></p><ol><li>概念模型( 信息模型)</li></ol><ul><li>按用户的观点 ，独立于计算机实现的，只用来描述和组织 所关心的信息 结构的概念数据模型， 强调语义</li><li>数据库设计人员和用户之间进行交流的语言</li><li>对应于信息世界</li></ul><ol start="2"><li>数据模型</li></ol><ul><li>按计算机系统的观点，直接面向计算机系统的，描述数据库中数据的逻辑结构的基本数据模型</li><li>对应于数据世界（机器世界）</li><li>包括<strong>逻辑模型</strong>和<strong>物理模型</strong><h6 id="概念模型（信息世界中）的基本概念"><a href="#概念模型（信息世界中）的基本概念" class="headerlink" title="概念模型（信息世界中）的基本概念"></a>概念模型（信息世界中）的基本概念</h6></li><li>实体Entity ：客观存在并相互区别的事物。具体的人、事、物，抽象的概念（订货）</li><li>属性Attribute ：实体或联系的特征。学生（学号，姓名，性别）</li><li>码，键Key ：唯一标识实体的属性或属性组</li><li>域Domain ：属性的取值范围。性别（男，女）</li><li>实体型Entity Type ：实体名＋属性名集合</li><li>实体集Entity Set ：同型实体的集合</li><li>联系Relationship: 实体与实体之间的联系<h6 id="实体间的联系"><a href="#实体间的联系" class="headerlink" title="实体间的联系"></a>实体间的联系</h6>实体之间的对应关系称为联系，它反映了现实世界事物之间的相互关联。<br>联系的类型：</li><li>一对一联系  记为1  ：1。</li><li>一对多联系  记为 １：n。</li><li>多对多联系  记为m  ：n。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-3bdcdf53d623fc1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="概念模型的表示方法"><a href="#概念模型的表示方法" class="headerlink" title="概念模型的表示方法"></a>概念模型的表示方法</h6>E-R图：提供了表示实体、属性和实体间联系的方法<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6a97096c79a17a91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="建立E-R图的步骤"><a href="#建立E-R图的步骤" class="headerlink" title="建立E-R图的步骤"></a>建立E-R图的步骤</h6></li></ul><ol><li>确定实体和实体的属性</li><li>确定实体和实体之间的联系及联系的类型</li><li>给联系和实体加上属性。<h6 id="E-R模型实例"><a href="#E-R模型实例" class="headerlink" title="E-R模型实例"></a>E-R模型实例</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-9514470fa22b9388.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><h6 id="数据模型定义"><a href="#数据模型定义" class="headerlink" title="数据模型定义"></a>数据模型定义</h6><ul><li>数据模型是表示实体类型和实体间联系的模型，是机器世界对现实世界中的数据和信息 抽象、表示和处理 。</li><li>包括逻辑模型和物理模型。<h6 id="数据模型的组成要素-三要素"><a href="#数据模型的组成要素-三要素" class="headerlink" title="数据模型的组成要素(三要素)"></a>数据模型的组成要素(三要素)</h6>数据结构、 数据操作和 数据完整性约束<h6 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h6></li></ul><ol><li>数据结构的概念</li></ol><ul><li>实体及实体间联系的 表示方法，描述了系统的 静态特性.</li></ul><ol start="2"><li>数据结构描述的内容</li></ol><ul><li>对象的数据类型、内容、性质有关的对象；</li><li>与数据之间联系有关的对象；<h6 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h6><ol><li>概念</li></ol></li><li>对数据库中各种对象(型)的实例(值)允许执行的操作及有关的操作规则，是对系统 动态特性的描述。</li></ul><ol start="2"><li>数据操作的类型（2大类）</li></ol><ul><li>数据检索（查询）</li><li>数据更新(包括插入、删除、修改)<h6 id="数据完整性约束"><a href="#数据完整性约束" class="headerlink" title="数据完整性约束"></a>数据完整性约束</h6></li></ul><ol><li>概念：完整性规则是给定的数据模型中数据及其联系所具有的 制约和依存规则。</li><li>作用：限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。</li><li>四种类型：实体完整性约束、域完整性约束、参照完整性约束和用户自定义完整性约束。<h6 id="最常用的数据模型"><a href="#最常用的数据模型" class="headerlink" title="最常用的数据模型"></a>最常用的数据模型</h6>非关系模型</li></ol><ul><li><p>层次模型(Hierarchical Model)<br>层次模型是数据库系统中最早出现的数据模型;<br>层次数据库系统的典型代表是IBM 公司1968年 年推出的IMS(Information Management System);<br>层次模型用 树形结构(“ 有向树”) 来表示各类实体以及实体间的联系.<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-05ff0f08c6ff3309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>网状模型(Network Model)<br>典型代表是DBTG;<br>通过 有向图结构 表示实体及联系。“网”中每个结点表示一个实体( 型) ，结点之间箭头表示实体( 型);<br>网状数据模型可能有多个根结点，某些非根结点可能有多个父结点，适合表示实体的多对多联系。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cc1bd2bdbff23958.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>关系模型(Relational Model)</p></li><li><p>1970年美国IBM公司San Jose研究室的研究员E.F.Codd首次提出了数据库系统的关系模型</p></li><li><p>关系数据结构：规范化的<strong>二维表</strong>（关系）<br>一个关系就是没有重复行和重复列的二维表，二维表的每一行在关系中称为元组，每一列在关系中称为属性。学生关系的每一行代表一个学生的记录，每一列代表学生记录的一个字段。属性个数（n）称为关系的元。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-399f462d3ee8d12a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h6 id="三种模型比较"><a href="#三种模型比较" class="headerlink" title="三种模型比较"></a>三种模型比较</h6><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-bd7aa6765cb17898.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="1-5数据库系统结构"><a href="#1-5数据库系统结构" class="headerlink" title="1.5数据库系统结构"></a>1.5数据库系统结构</h5></li><li><p>数据库系统内部的体系结构<br>从数据库管理系统角度看，数据库系统通常采用三级模式结构，是数据库系统内部的系统结构。</p></li><li><p>数据库系统外部的体系结构<br>从数据库最终用户角度看，数据库系统的结构分为:集中式结构；客户/服务器结构；浏览器／应用服务器／数据库服务器多层结构等。</p></li><li><p>为了有效地组织、管理数据，提高数据库的逻辑独立性和物理独立性，数据库设计的标准体系结构是3 级模式结构，即<strong>外模式</strong> ,<strong>模式</strong>和<strong>内模式</strong> </p></li><li><p>对应于体系结构，用户或程序员看到或使用的数据库内容被称为视图，可把视图相应分为：</p></li></ul><ol><li>对应于用户的外部视图（ 用户视图）</li><li>对应于应用程序员的 (概念视图)</li><li>对应于系统程序员的内部视图（ 存储视图）<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-ef6509f0c60dc3ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><ul><li>模式（Schema，也称逻辑模式，概念视图）</li></ul><p>– 数据库中 全体数据的逻辑结构和特征 的描述。<br>– 一个数据库只有一个模式<br>– 模式的地位：是数据库系统模式结构的中间层</p><ul><li>外模式（External Schema）</li></ul><p>– 也称 子模式或用户模式；<br>–  数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。<br>– 外模式的地位：介于模式与应用之间<br>–  外模式通常是模式的子集<br>– 一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求</p><ul><li>内模式（Internal Schema）</li></ul><p>–  是 数据物理结构 和 存储方式<br>– 是数据在数据库内部的表示方式<br><strong>3级模式是对数据的三个抽象级别</strong><br> 2级映象在DBMS 内部实现这三个抽象层次的联系和转换 ；</p><ul><li>外模式\ 模式映像<br>– 保证数据的<strong>逻辑独立性</strong><br>– 同一个模式可以有任意多个外模式，外模式／模式映象定义外模式与模式之间的对应关系；<br>– 当模式改变时，外模式／模式映象使外模式保持不变；<br>– 应用程序是依据数据的外模式编写的，从而不必修改应用程序，保证了数据与程序的逻辑独立性<ul><li>模式\内模式映像</li></ul>– 保证数据的<strong>物理独立性</strong>。<br>– 模式／内模式映象定义了数据 全局逻辑结构与 存储结构之间的对应关系。<br>– 当数据库的存储结构改变了，模式／内模式映象使模式保持不变。<br>– 应用程序不受影响。保证了数据与程序的物理独立性。</li></ul><p>从数据库最终用户角度看（数据库系统外部的体系结构） ，数据库系统的结构分为:</p><ul><li>集中式数据库系统</li><li>客户/服务器（C/S）系统结构</li><li>分布式数据库系统结构</li><li>浏览器／服务器（B/S）系统结构</li></ul><h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><h5 id="2-1关系数据模型的基本概念"><a href="#2-1关系数据模型的基本概念" class="headerlink" title="2.1关系数据模型的基本概念"></a>2.1关系数据模型的基本概念</h5><p>关系模型的组成（三要素）</p><ul><li>关系数据结构（静态特性）<br>现实世界的实体以及实体间的各种联系均用关系来表示;<br>数据的逻辑结构—-二维表</li><li>关系操作集合（动态特性）<br>插入、删除、修改、查询（选择、投影、连接、除、并、交、差）</li><li>关系完整性约束<br>实体完整性、参照完整性、域完整性、用户定义完整性</li></ul><p>1） 关系: 通常将一个无重复行、重复列的二维表看成一个关系，每个关系都有一个关系名。<br> 2） 元组: 二维表的每一行在关系中称为元组。描述了现实世界中的一个实体或不同实体间的一种联系。<br> 3） 属性: 二维表的每一列在关系中称为属性，每个属性都有一个属性名，各个属性的取值称为属性值。每个属性有一定的取值范围，称为值域。<br> 4）域 （Domain): 关系中每个属性所对应的变化范围叫做属性的变域或简称域，关系中所有属性的实际取值必须来自它对应的域。<br> 5）分量: 一个元组在一个属性域上的取值称为该元组在此属性上的分量。<br>6）关系模式: 二维表的表头那一行称为关系模式，即一个关系的关系名及其全部属性名的集合。关系模式是概念模型中实体型及实体型之间联系的数据模型表示。 一般表示为：<br>关系名（属性名1，属性名2 ， ……，属性名n）<br> 关系模式指出了一个关系的结构；而关系则是由满足关系模式结构的元组构成的集合。关系模式是稳定的、静态的，而关系则是随时间变化的、动态的。<br> 7） 候选码（Candidate key）: 若关系中的某一属性或属性组合的值能唯一地标识一个元组，则称该属性组为候选码<br> 在最简单的情况下，候选码只包含一个属性。<br> 在最极端的情况下，关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）<br>8） 主码: 若一个关系有多个候选码，则选定其中一个为主<br>码（Primary key）<br> 9）主属性和非主属性<br>– 主码的各个属性称为主属性（Prime attribute）。<br>– 不包含在任何候选码中的属性称为非主属性Non-key attribute）<br>10）外码: 如果关系中某个属性或属性组合并非码，但却是另一个关系的主码，则称此属性或属性组合为本关系的外码或外键(ForeignKey)。在关系数据库中，用外码表示两个表间的联系。</p><h5 id="2-2关系数据模型的集合论定义"><a href="#2-2关系数据模型的集合论定义" class="headerlink" title="2.2关系数据模型的集合论定义"></a>2.2关系数据模型的集合论定义</h5><h6 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h6><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-35b3920ae7c425db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>笛卡尔积可表示为一个二维表。表中的每行对应一个元组，表中的每列对应一个域。</li><li>基数（Cardinal number）<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-e72b5c4eb4172ed2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h6></li><li>笛卡尔积中的任意子集叫作在域 上的n元 关系，简称关系。</li><li>n元关系就会有n个属性。一个关系中的每一个属性的属性名都不同，对应参与笛卡儿积运算的每个集合的名称。</li><li>一个属性的取值范围Di 称为该属性的域（Domain）。<h6 id="基本关系的性质"><a href="#基本关系的性质" class="headerlink" title="基本关系的性质"></a>基本关系的性质</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-debda60472f76fbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-45ee559f7f0dda04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h5 id="2-3-关系模型的完整性约束"><a href="#2-3-关系模型的完整性约束" class="headerlink" title="2.3 关系模型的完整性约束"></a>2.3 关系模型的完整性约束</h5>数据库系统提供的监测机制，确保存储数据的规范，称为完整性约束。<ul><li>实体完整性<br>实体完整性通过定义 主码 来实现的。若属性A A 是关系R R 的主属性，则A A 不能取空值且取值唯一 ；<br>一个关系模型中的所有 元组都是惟一 的，没有两个完全相同的元组，也就是一个二维表中没有两个完全相同行，也称为<strong>行完整性</strong>。</li></ul></li><li>域完整性<br>对关系R R 中属性（列）数据的规范，也称<strong>列完整性</strong>，限制属性的 数据类型、格式、取值范围、是否允许空值 等。</li><li>参照完整性<br>参照完整性是通过定义 外 键 FK （ 存在或为空） 来建立实体间联系的。<br>如外键取空，则 FK 中的每个属性的分量都是空值。</li><li>用户定义完整性<br>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。<h5 id="2-4关系代数"><a href="#2-4关系代数" class="headerlink" title="2.4关系代数"></a>2.4关系代数</h5><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-ea7ed5cbbc5c6656.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="笛卡尔积-1"><a href="#笛卡尔积-1" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-5357bd667e805062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="选择（限制）"><a href="#选择（限制）" class="headerlink" title="选择（限制）"></a>选择（限制）</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f2be1caa785865c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="投影（Projection）"><a href="#投影（Projection）" class="headerlink" title="投影（Projection）"></a>投影（Projection）</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-101949584da22ebc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="连接（Join-）"><a href="#连接（Join-）" class="headerlink" title="连接（Join ）"></a>连接（Join ）</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-35e9d9de19d368dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7d1d6e58891ec025.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-01b05c7400e325d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="除（Division-）"><a href="#除（Division-）" class="headerlink" title="除（Division ）"></a>除（Division ）</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-be0e4bcd638b5800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><h3 id="SQL-Server-2008-数据库基础"><a href="#SQL-Server-2008-数据库基础" class="headerlink" title="SQL Server 2008 数据库基础"></a>SQL Server 2008 数据库基础</h3><h5 id="SQL-Server-简介"><a href="#SQL-Server-简介" class="headerlink" title="SQL Server  简介"></a>SQL Server  简介</h5><ul><li>常见数据库产品包括甲骨文公司的Oracle系统，IBM 公司的DB2 系统和Informix 系统，赛贝斯公司的Sybase ASE 系统，微软公司的Microsoft SQL Server 系统和Access 系统，以及MySQL</li><li>2008 年8 月，微软发布Microsoft SQL Server 2008 系统，其代码是Katmai 。该系统在 安全性、可用性、易管理性、可扩展性、商业智能 等方面有了更多的改进和提高，支持 更强大 的数据存储和应用需求。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-60fd472b70d4ded7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-8164b6115ac57a00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-677d8c29fac82083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="SQL-Server-2008登录"><a href="#SQL-Server-2008登录" class="headerlink" title="SQL Server 2008登录"></a>SQL Server 2008登录</h5><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-fa20d7cd219167ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="SQL-Server-Management-Studio-简介"><a href="#SQL-Server-Management-Studio-简介" class="headerlink" title="SQL Server Management Studio 简介"></a>SQL Server Management Studio 简介</h5><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-5d81798645335bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-a610b30296329114.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6f9ecf6f88f08272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="SQL-Server-2008-数据库的创建与维护"><a href="#SQL-Server-2008-数据库的创建与维护" class="headerlink" title="SQL Server 2008 数据库的创建与维护"></a>SQL Server 2008 数据库的创建与维护</h5><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-5883c454c6f7a6ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-e6d897155dd42e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>SQL Server 2008 数据存储结构<br>（1 ）数据库文件<ul><li>主数据文件.mdf</li><li>次要数据文件  .ndf</li><li>日志文件 .ldf</li><li>数据文件结构组成</li><li>页<br>_ SQL Server最小存储数据单位<br>_ 一个页大小是8K</li><li>区<br>_ 管理空间的基本单位<br>_ 8个物理上连续的页（64 KB）<br>_ 表被存储在区</li></ul></li></ul><p>（2)数据库文件组</p><p>   (3)数据库创建<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-1dda20b927c861fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-91fe4f34a3024f2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-0e525d5bef964169.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（4）数据库修改<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-ed3ad2d39c3ee70d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（5）数据库删除<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-20761a3678583d98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="Transact-SQL-程序设计基础"><a href="#Transact-SQL-程序设计基础" class="headerlink" title="Transact-SQL 程序设计基础"></a>Transact-SQL 程序设计基础</h5><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-80514da0fd443c28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f670b1769ebef9fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p> （1 ）标识符分类<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-bf864b95cce9e8fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>（2）数据类型<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-12e48ff37e968ca5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>（3）全局变量<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-33ccaabeb7cc1d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>（4）运算符<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-64ced3ebc711c21e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>（5）批处理<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-d7a6907c4f80d3ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>（6）函数<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f0c631e6054b93ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-499317578ee5382d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-15bf357ae64f9596.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-27ddaea8d1404fa7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-c831b45529b4d02e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-c62055abc13acd9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-092b47701f26afdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>（7）流程控制<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cb8591968e265754.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="关系数据库标准语言SQL"><a href="#关系数据库标准语言SQL" class="headerlink" title="关系数据库标准语言SQL"></a>关系数据库标准语言SQL</h3><h5 id="SQL-的三级模式结构"><a href="#SQL-的三级模式结构" class="headerlink" title="SQL 的三级模式结构"></a>SQL 的三级模式结构</h5><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-adf8c173d8cb82a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="SQL-的数据定义"><a href="#SQL-的数据定义" class="headerlink" title="SQL 的数据定义"></a>SQL 的数据定义</h5><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-78f2cfea179fdc0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-eafd189c9bcc48cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-b8c403c084b124ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>基本表定义<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-a427874f6b8bf74c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>基本表的修改与删除<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cf6f5f472950c7ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-87b5c1382852441a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>索引的建立和删除<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-485dfefc9bc92188.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-4b090d4cd4c308a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-66084115e6f0e91c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-e68483f5777f3b90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-d85e38c2be78d419.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>查询语句</li></ul><p>查询的基本结构包括了三个子句： SELECT、 FROM 、 WHERE。</p><p> 从表中（From子句）,选择满足记录选择条件（Where子句）的记录，并对他们进行分组（Group子句, Having子句表达组选择条件）、统计(统计函数）、排序（Order by 子句）和投影（Select子句） ，形成查询结果集。</p><ol><li>单表无条件查询<br>DISTINCT 保留字的使用：可以使查询的结果中重复列值只保留一个。<br>查询列中含有运算的表达式。<br>查询列中含有字符串常量。<br>查询列中含有聚合函数。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-4269cf6900924f85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>单表有条件查询<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-de218e073d682650.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6e1d17b7fd1686d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-ef18dc9879307b63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-9246eb55e2ff1fbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-aa5687129ee936e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f251334d0273ca72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol start="3"><li>分组查询和排序查询<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-9d684cdddb748dec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f47f13e912d00a61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7ad8d00c7760ed96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol start="4"><li>多表查询</li></ol><ul><li>SQL通过连接查询、笛卡尔积、并操作、交操作、差操作5种关系代数中的运算功能来实现多个数据表的查询。SQL通过连接查询、笛卡尔积、并操作、交操作、差操作5种关系代数中的运算功能来实现多个数据表的查询。</li><li>SQL  提供在子句中列出每个关系 然后在SELECT子句和WHERE子句中引用FROM子句中的关系属性，而WHERE子句中用来连接两个关系的条件。在SELECT子句和WHERE子句中引用FROM子句中的关系属性，而WHERE子句中用来连接两个关系的条件。</li><li>连接查询包括等值连接、非等值连接、自身连接、内连接和外连接等值连接、非等值连接、自身连接、内连接和外连接等。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-613643b8abd2eac2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-0b49b0c1e63fad45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-2210533ddf510600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-17cf467c7e2ffe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-c2ab3b2e10701077.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>5. 嵌套查询<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7f3ff4167da21bf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>SQL 的数据操纵</li></ul><ol><li>插入数据<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-e13879ce99f31716.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>修改数据<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-b2bf14419f69c096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>删除数据<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-8c604762cc491273.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-ac07719ed45b7981.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><ul><li>视图<ul><li>视图是 外模式的基本单位，实际上视图是从若干个基本表或视图导出来的虚表。</li><li>当基本表的数据发生变化时，相应的视图数据也会随之改变。</li><li>视图定义后，可以被用户查询、更新，但通过视图来更新基本表中的数据要有一定的限制。</li></ul></li></ul><ol><li>定义视图<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-39ab5bc2a15ff835.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-9b81c14c878915b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>2. 删除视图<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-05fd835292b32c8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>3. 查询视图<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-09aaebc6645eb617.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>4. 更新视图<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7f9b79f85735e4b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol start="5"><li>视图的作用<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-50bd3300fa23944e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><ul><li>存储过程<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-716ab4c40c76b8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-84f68facfdc8522a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><ol><li>创建执行<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-9be1ef35f2a34908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-0d5ec5c3e796e622.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>修改删除<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-09d98763060572d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>查看储存<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-1949b6e387c3af91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><ul><li>触发器<ul><li>触发器是一种特殊的存储过程，在对表或视图执行，触发器是一种特殊的存储过程，在对表或视图执行 UPDATE 、 INSERT 或 DELETE 操作时自动触发执行操作时自动触发执行。<ul><li>触发器技术是保证数据完整性的高级技术，触发器还可以用于对系统的高级监测，用于实施完整性和强制执行业务规则。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-ab4ae5ede4a56a4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-5bf52f7c4445adc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-fadc22d3bcb224ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul></li></ul></li></ul><h2 id="关系数据库规范化理论"><a href="#关系数据库规范化理论" class="headerlink" title="关系数据库规范化理论"></a>关系数据库规范化理论</h2><h4 id="关系模式的形式化定义"><a href="#关系模式的形式化定义" class="headerlink" title="关系模式的形式化定义"></a>关系模式的形式化定义</h4><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-e5f0c7cebec49b56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="函数依赖的基本概念"><a href="#函数依赖的基本概念" class="headerlink" title="函数依赖的基本概念"></a>函数依赖的基本概念</h4><ul><li>函数依赖<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-94b8e0cbe088b538.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-26de88d0f64c48b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f214117ed707487a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-b027c589734a6da5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>码的函数依赖<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-61635ad1e416e1be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><h4 id="关系模式的规范化"><a href="#关系模式的规范化" class="headerlink" title="关系模式的规范化"></a>关系模式的规范化</h4><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-b089a70ae3c6ec87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol><li>第 1 范式 1NF<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-2e2899d8ae270523.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>第 2 范式 2NF<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-a67970f2bd29db0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>第 3 范式 3NF<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cbf667c69059ef8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>BCNF 范式<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-175efc68db852a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>多值依赖与第 4 范式<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6036188b83ab363c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f874267376e88bd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f683d0adf226bdad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-0d3b954ed895f4fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h4><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-fab819be603f3833.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h4><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-8fc150ea215d96f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h4><h4 id="数据库实施"><a href="#数据库实施" class="headerlink" title="数据库实施"></a>数据库实施</h4><h4 id="数据库运行与维护"><a href="#数据库运行与维护" class="headerlink" title="数据库运行与维护"></a>数据库运行与维护</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模算法学习</title>
      <link href="/posts/blog-model01.html"/>
      <url>/posts/blog-model01.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://blog.csdn.net/qwl755/article/details/73558416" target="_blank" rel="noopener">相关模型解决的问题</a><br><a href="https://blog.csdn.net/anxixiaomu/article/details/69075286" target="_blank" rel="noopener">数据分析类算法一览</a><br><a href="https://blog.csdn.net/w_t_y_y/article/details/68952519" target="_blank" rel="noopener">100个经典动态规划方程</a></p></blockquote><h3 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h3><ul><li>线性规划</li></ul><ol><li><strong>简介</strong>：线性规划的目标函数可以是求最大值，也可以是求最小值，约束条件的不等号可以是小于号也可以是大于号。为了避免这种形式多样性带来的不便，Matlab 中规定线性规划的标准形式为<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-9044bd07c3f2399a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性规划"><br>其中 c 和 x 为 n 维列向量， A 、 Aeq 为适当维数的矩阵， b 、 beq 为适当维数的列向量。</li><li><strong>代码实现</strong></li></ol><p><strong>MATLAB实现</strong>：MATLAB中求解线性规划的命令为：<br>[ x，fval ]=linprog（f，A，b）<br>[ x，fval ]=linprog（f，A，b，Aeq，beq）<br>[ x，fval ]=linprog（f，A，b，Aeq，beq，lb，ub）<br>其中：返回的x为决策向量的取值； 返回的fval是目标函数的最大值；f为价值向量；A和b对应的是线性不等式约束；Aeq和beq对应的是线性等式约束；lb和ub分别对应的是决策向量的下界向量和上界向量。<br>eg1:<img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-34d792f1f57ef43f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性规划"><br>(1)化为Matlab标准型，即<img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6c2b7cc03d8c2e8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性规划"><br>(2)求解的Matlab程序如下：</p><pre><code>f=[-2,-3,5]'A=[-2,5,-1;1,3,1];  b=[-10;12];Aeq=[1,1,1];    beq=7;[x,fval]=linprog(f,A,b,Aeq,beq,zeros(3,1));xfval=-fval</code></pre><p>这里的zeros(3,1)是为了产生3行1列的全0矩阵，对应着x1,x2,x3均大于等于0的约束条件。<br> eg2:可以转化为线性规划的问题<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-1e8c867f5afe3a4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性规划"><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-c9708cba53ff0815.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性规划"><br>可进一步把模型改写为：<img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-e64ab0f6f9e2c5a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性规划"><br><a href="https://blog.csdn.net/u013414501/article/details/50473855" target="_blank" rel="noopener">参考链接</a><br><strong>应用</strong>：运输问题(产销平衡)、指派问题（匈牙利算法）、对偶理论与灵敏度分析、投资的收益和风险</p><ul><li>非线性规划</li></ul><ol><li><strong>简介</strong>：如果线性规划的最优解存在，其最优解只能在其可行域的边界上达到（特别是可行域的顶点上达到）；而非线性规划的最优解（如果最优解存在）则可能在其可行域的任意一点达到。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-c27cae1fa529323f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="非线性规划"><br>其中f(x)是标量函数， Beq,Aeq,B,A 是相应维数的矩阵和向量， Ceq(x),C(x) 是非线性向量函数。</li><li><strong>代码实现</strong>：<br>MATLAB代码实现：<pre><code>x = fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)</code></pre></li></ol><blockquote><p>1.fun为目标函数<br>2.x0为初始值<br>3.A是不等式约束AX&lt;=b的系数矩阵<br>4.b是不等式约束AX&lt;=b的常数项<br>5.Aeq是等式约束AeqX=beq的系数矩阵，<br>6.beq是等式约束AeqX=beq的常数项，<br>7.lb是X的下限，<br>8.ub是X的上限，<br>9.nonlcon为非线性不等式约束<br>10.option为设置fmincon的参数<br>eg：<img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-eba3d23d7bd5ebf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="非线性规划"><br>形如上述这样的就是非线性规划：</p></blockquote><pre><code>function f=fun1(x)f=x(1)^2+x(2)^2+8;function [g,h]=fun2(x)g=-x(1)^2+x(2);h=-x(1)-x(2)^2+2;%约束等式options=optimset;[x,y]=fmincon('fun1',rand(2,1),[],[],[],[],zeros(2,1),[],'fun2',options)x =    1.0000    1.0000y =   10.0000</code></pre><blockquote><p><a href="https://blog.csdn.net/starmoth/article/details/88412527" target="_blank" rel="noopener">参考链接</a></p></blockquote><ul><li>整数规划</li></ul><ol><li><strong>简介</strong>：规划中的变量（部分或全部）限制为整数时，称为整数规划。若在线性规划模型中，变量限制为整数，则称为整数线性规划。目前所流行的求解整数规划的方法，往往只适用于整数线性规划。目前还没有一种方法能有效地求解一切整数规划。如不加特殊说明，一般指整数线性规划。对于整数线性规划模型大致可分为两类：<br>1   变量全限制为整数时，称纯（完全）整数规划。<br>2   变量部分限制为整数的，称混合整数规划。</li><li><strong>代码实现</strong><blockquote><p> <a href="https://zhuanlan.zhihu.com/p/38042197" target="_blank" rel="noopener">参考链接</a><br><a href="https://baike.baidu.com/item/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E8%BF%87%E7%A8%8B/2952385?fr=aladdin" target="_blank" rel="noopener">马尔可夫过程</a></p></blockquote></li></ol><ul><li>动态规划</li></ul><ol><li><strong>简介</strong>：动态规划（dynamic programming）是运筹学的一个分支，是求解决策过程（decisionprocess）最优化的数学方法。例如最短路线、库存管理、资源分配、设备更新、排序、装载等问题，用动态规划方法比用其它方法求解更为方便。</li><li><strong>代码实现</strong>：<blockquote><p><a href="https://blog.csdn.net/zw6161080123/article/details/80639932" target="_blank" rel="noopener">参考链接</a><br>具体问题具体分析</p></blockquote></li></ol><h3 id="排队论"><a href="#排队论" class="headerlink" title="排队论"></a>排队论</h3><blockquote><p><a href="https://wenku.baidu.com/view/aac30b9fc8d376eeafaa315c.html" target="_blank" rel="noopener">PPT参考</a><br><a href="https://blog.csdn.net/sunyueqinghit/article/details/81562138" target="_blank" rel="noopener">参考资料</a><br><a href="https://blog.csdn.net/weixin_40725491/article/details/82190598" target="_blank" rel="noopener">案例与代码</a><br><a href="https://blog.csdn.net/qq_29831163/article/details/89735320" target="_blank" rel="noopener">排队论详解及Lingo实现</a></p></blockquote><ol><li><strong>简介</strong>：排队论（Queuing Theory）也称随机服务系统理论，就是为解决上述问题而发展 的一门学科。它研究的内容有下列三部分：<br>（i）性态问题，即研究各种排队系统的概率规律性，主要是研究队长分布、等待时间分布和忙期分布等，包括了瞬态和稳态两种情形。<br>（ii）优化问题，又分静态优和动态优，前者指优设计。后者指现有排队系统的优运营。<br>（iii）排队系统的统计推断，即判断一个给定的排队系统符合于哪种模型，以便根据排队理论进行分析研究。</li><li><strong>符号说明</strong>：<br>排队模型用六个符号表示，在符号之间用斜线隔开，即 X/Y/Z/A/B/C 。<blockquote><p>第一 个符号 X 表示顾客到达流或顾客到达间隔时间的分布；<br>第二个符号Y 表示服务时间的 分布；<br>第三个符号Z 表示服务台数目；<br>第四个符号 A是系统容量限制；<br>第五个符号B 是 顾客源数目；<br>第六个符号C 是服务规则，如先到先服务 FCFS，后到先服务 LCFS 等。<br>并约定，如略去后三项，即指X/Y/Z/∞/∞/FCFS的情形。我们只讨论先到先服务 FCFS 的情形，所以略去第六项。</p></blockquote></li></ol><p>表示顾客到达间隔时间和服务时间的分布的约定符号为：</p><blockquote><p>M —指数分布（M 是 Markov 的字头，因为指数分布具有无记忆性，即 Markov 性）；<br>D—确定型（Deterministic）；<br>Ek —k 阶爱尔朗(Erlang)分布；<br>G —一般（general）服务时间的分布；<br>GI —一般相互独立（General Independent）的时间间隔的分布。<br>例如，M/M/1表示相继到达间隔时间为指数分布、服务时间为指数分布、单服务台、等待制系统。<br>D/M/c/表示确定的到达时间、服务时间为指数分布、c个平行服务台（但顾客是一队）的模型。</p></blockquote><ol start="3"><li><strong>参数指标</strong>：为了研究排队系统运行的效率，估计其服务质量，确定系统的优参数，评价系统 的结构是否合理并研究其改进的措施，必须确定用以判断系统运行优劣的基本数量指标，这些数量指标通常是：<blockquote><p>(i)平均队长：指系统内顾客数（包括正被服务的顾客与排队等待服务的顾客）的数学期望，记作Ls 。<br>(ii)平均排队长:指系统内等待服务的顾客数的数学期望，记作 Lq 。<br>(iii)平均逗留时间：顾客在系统内逗留时间（包括排队等待的时间和接受服务的时间）的数学期望，记作Ws 。<br>(iv）平均等待时间：指一个顾客在排队系统中排队等待时间的数学期望，记作Wq 。<br>(v）平均忙期：指服务机构连续繁忙时间（顾客到达空闲服务机构起，到服务机构再次空闲止的时间）长度的数学期望，记为 Tb</p></blockquote></li></ol><h3 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h3><blockquote><p><a href="https://wenku.baidu.com/view/7906bbcd89eb172ded63b732.html" target="_blank" rel="noopener">PPT参考</a><br><a href="https://zhuanlan.zhihu.com/p/38207837" target="_blank" rel="noopener">详细实现</a><br><a href="https://blog.csdn.net/qq_38173003/article/details/81741263" target="_blank" rel="noopener">代码实现</a></p></blockquote><ol><li><strong>简介</strong>：层次分析法（Analytic Hierarchy Process，简称 AHP）是对一些较为复杂、较为模糊的问题作出决策的简易方法，它特别适用于那些难于完全定量分析的问题。</li><li><strong>步骤</strong>：<blockquote><p>（i）建立递阶层次结构模型；<br>（ii）构造出各层次中的所有判断矩阵；<br>（iii）层次单排序及一致性检验；<br>（iv）层次总排序及一致性检验。</p></blockquote></li><li><strong>概念</strong>：应用 AHP 分析决策问题时，首先要把问题条理化、层次化，构造出一个有层次的结构模型。在这个模型下，复杂问题被分解为元素的组成部分。这些元素又按其属性及关系形成若干层次。上一层次的元素作为准则对下一层次有关元素起支配作用。<br>这些层次可以分为三类：<blockquote><p>（i）最高层：这一层次中只有一个元素，一般它是分析问题的预定目标或理想结果，因此也称为目标层。<br>（ii）中间层：这一层次中包含了为实现目标所涉及的中间环节，它可以由若干个层次组成，包括所需考虑的准则、子准则，因此也称为准则层。<br>（iii）最底层：这一层次包括了为实现目标可供选择的各种措施、决策方案等，因此也称为措施层或方案层。</p></blockquote></li></ol><p>递阶层次结构中的层次数与问题的复杂程度及需要分析的详尽程度有关，一般地层次数不受限制。每一层次中各元素所支配的元素一般不要超过 9 个。这是因为支配的元素过多会给两两比较判断带来困难。</p><h3 id="多属性决策"><a href="#多属性决策" class="headerlink" title="多属性决策"></a>多属性决策</h3><blockquote><p><a href="https://wenku.baidu.com/view/c6091c5cae45b307e87101f69e3143323968f58e.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://www.cnblogs.com/Qling/p/9295414.html" target="_blank" rel="noopener">参考资料</a></p></blockquote><p><strong>简介</strong>：多属性决策是现代决策科学的一个重要组成部分，它的理论和方法在工程设计、经济、管理和军事等诸多领域中有着广泛的应用，如：投资决策、项目评估、维修服务、武器系统性能评定、工厂选址、投标 招标、产业 部门发展排序和经济效益综合评价等．多属性决策的实质是利用已有的决策信息通过一定的方式对一组( ( 有限个) ) 备选方案进行排序或择优．它主要由两部分组成：</p><blockquote><p>(l) 获取决策信息．决策信息一般包括两个方面的内容：属性权重和属性值( ( 属性值主要有三种形式：实数、区间数和语言) ) ．其中，属性权重的确定是多属性决策中的一个重要研究内容；<br>(2)通过一定的方式对决策信息进行集结并对方案进行排序和择优．</p></blockquote><p>###主成分分析法</p><blockquote><p><a href="https://wenku.baidu.com/view/d797eda7112de2bd960590c69ec3d5bbfd0adabf.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://blog.csdn.net/Murray_/article/details/79945148" target="_blank" rel="noopener">参考资料</a><br><a href="https://my.oschina.net/u/3888421/blog/2249132" target="_blank" rel="noopener">Python实现</a></p></blockquote><p><strong>简介</strong>：主成分分析（Principal Component Analysis，PCA）， 是一种统计方法。通过正交变换将一组可能存在相关性的变量转换为一组线性不相关的变量，转换后的这组变量叫主成分。</p><h3 id="商权法"><a href="#商权法" class="headerlink" title="商权法"></a>商权法</h3><blockquote><p><a href="https://blog.csdn.net/qq_32942549/article/details/80019005" target="_blank" rel="noopener">参考资料</a><br><a href="https://www.jianshu.com/p/477d4b22de6d" target="_blank" rel="noopener">基本步骤</a></p></blockquote><p><strong>简介</strong>：按照信息论基本原理的解释，信息是系统有序程度的一个度量，熵是系统无序程度的一个度量；如果指标的信息熵越小，该指标提供的信息量越大，在综合评价中所起作用理当越大，权重就应该越高。因此，可利用信息熵这个工具，计算出各个指标的权重，为多指标综合评价提供依据。</p><h3 id="插值与拟合"><a href="#插值与拟合" class="headerlink" title="插值与拟合"></a>插值与拟合</h3><ol><li><strong>简介</strong>：插值：求过已知有限个数据点的近似函数。<br>拟合：已知有限个数据点，求近似函数，不要求过已知数据点，只要求在某种意义下它在这些点上的总偏差最小。<br>插值和拟合都是要根据一组数据构造一个函数作为近似，由于近似的要求不同，二者的数学方法上是完全不同的。而面对一个实际问题，究竟应该用插值还是拟合，有时容易确定，有时则并不明显。</li></ol><ul><li><p>插值方法：<br>几种基本的、常用的插值：拉格朗日多项式插值、牛顿插值、分段线性插值、Hermite 插值和三次样条插值。</p></li><li><p>曲线拟合的线性最小二乘法（线性最小二乘法）：<br>最小二乘优化（lsqlin 函数、lsqcurvefit 函数、lsqnonlin 函数、lsqnonneg 函数）</p></li></ul><ol start="2"><li><strong>代码实现</strong>：<blockquote><p><a href="https://www.cnblogs.com/henuliulei/p/9473260.html" target="_blank" rel="noopener">参考链接</a></p></blockquote></li></ol><h3 id="方差分析"><a href="#方差分析" class="headerlink" title="方差分析"></a>方差分析</h3><blockquote><p><a href="https://wenku.baidu.com/view/01e7060f0975f46526d3e153.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://www.jianshu.com/p/f5f54a39cb19" target="_blank" rel="noopener">案例分析</a><br><a href="https://blog.csdn.net/Moxiaoaijing/article/details/81079990" target="_blank" rel="noopener">SPSS实现</a></p></blockquote><ol><li><strong>简介</strong>：为了使生产过程稳定，达到优质、高产，需要对影响产品质量的因素进行分析，找出有显著影响的那些因素，除了从机理方面进行研究外，常常要作许多试验，对结果作分析、比较，寻求规律。用数理统计分析试验结果、鉴别各因素对结果影响程度的方法称为方差分析（Analysis Of Variance），记作 ANOVA。</li><li><strong>分类</strong>:<br>§1 单因素方差分析<br>只考虑一个因素 A 对所关心的指标的影响， A 取几个水平，在每个水平上作若干个试验，试验过程中除 A 外其它影响指标的因素都保持不变（只有随机因素存在），我们的任务是从试验结果推断，因素 A 对指标有无显著影响，即当 A 取不同水平时指标有无显著差别。A 取某个水平下的指标视为随机变量，判断 A 取不同水平时指标有无显著差别，相当于检验若干总体的均值是否相等。<br>§2 双因素方差分析<br>如果要考虑两个因素 B A, 对指标的影响， B A, 各划分几个水平，对每一个水平组合作若干次试验，对所得数据进行方差分析，检验两因素是否分别对指标有显著影响，或者还要进一步检验两因素是否对指标有显著的交互影响。<br>§3 正交试验设计与方差分析<br>由于因素较少时，我们可以对不同因素的所有可能的水平组合做试验，这叫做全面试验。当因素较多时，虽然理论上仍可采用前面的方法进行全面试验后再做相应的方差分析，但是在实际中有时会遇到试验次数太多的问题。如果考虑更多的因素及水平，则全面试验的次数可能会大得惊人。因此在实际应用中，对于多因素做全面试验是不现实的。于是我们考虑是否可以选择其中一部分组合进行试验，这就要用到试验设计方法选择合理的试验方案，使得试验次数不多，但也能得到比较满意的结果。</li></ol><h3 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h3><blockquote><p><a href="https://www.jianshu.com/p/bbe0c702b5ad" target="_blank" rel="noopener">概念理解</a><br><a href="https://wenku.baidu.com/view/d7a2b92b58fb770bf78a55fe.html" target="_blank" rel="noopener">PPT参考</a><br><a href="https://blog.csdn.net/red_stone1/article/details/81122926" target="_blank" rel="noopener">参考资料</a><br><a href="https://blog.csdn.net/weixin_41893675/article/details/83047162" target="_blank" rel="noopener">代码实现</a><br><a href="https://zhuanlan.zhihu.com/p/42300484" target="_blank" rel="noopener">多元回归分析代码</a><br><a href="https://wenku.baidu.com/view/a8979f02cd1755270722192e453610661ed95a3e.html" target="_blank" rel="noopener">SPSS分析</a></p></blockquote><ol><li><strong>简介</strong>：曲线拟合问题的特点是，根据得到的若干有关变量的一组数据，寻找因变量与（一个或几个）自变量之间的一个函数，使这个函数对那组数据拟合得最好。通常，函数的形式可以由经验、先验知识或对数据的直观观察决定，要作的工作是由数据用最小二乘法计算函数中的待定系数。从计算的角度看，问题似乎已经完全解决了，还有进一步研究的必要吗?从数理统计的观点看，这里涉及的都是随机变量，我们根据一个样本计算出的那些系数，只是它们的一个（点）估计，应该对它们作区间估计或假设检验，如果置信区间太大，甚至包含了零点，那么系数的估计值是没有多大意义的。另外也可以用方差分析方法对模型的误差进行分析，对拟合的优劣给出评价。简单地说，回归分析就是对拟合问题作的统计分析。</li><li><strong>研究的问题</strong>：<blockquote><p>（i）建立因变量 y 与自变量 x1,x2,……，xm之间的回归模型（经验公式）；<br>（ii）对回归模型的可信度进行检验；<br>（iii）判断每个自变量xi=(i=1,2,……，m)对 y 的影响是否显著；<br>（iv）诊断回归模型是否适合这组数据；<br>（v）利用回归模型对 y 进行预报或控制。</p></blockquote></li></ol><h3 id="微分方程建模"><a href="#微分方程建模" class="headerlink" title="微分方程建模"></a>微分方程建模</h3><blockquote><p><a href="https://wenku.baidu.com/view/285699a06394dd88d0d233d4b14e852458fb3981.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://blog.csdn.net/hesays/article/details/39899047" target="_blank" rel="noopener">微分方程求解代码</a></p></blockquote><ol><li><strong>简介</strong>：微分方程建模是数学建模的重要方法，因为许多实际问题的数学描述将导致求解微分方程的定解问题。把形形色色的实际问题化成微分方程的定解问题，大体上可以按以下几步：<blockquote><ul><li>根据实际要求确定要研究的量(自变量、未知函数、必要的参数等)并确定坐标系。</li><li>找出这些量所满足的基本规律(物理的、几何的、化学的或生物学的等等)。</li><li>运用这些规律列出方程和定解条件。</li></ul></blockquote></li><li><strong>方法</strong>：列方程常见的方法有：<blockquote><p>（i）按规律直接列方程<br>在数学、力学、物理、化学等学科中许多自然现象所满足的规律已为人们所熟悉，并直接由微分方程所描述。如牛顿第二定律、放射性物质的放射性规律等。我们常利用这些规律对某些实际问题列出微分方程。<br>（ii）微元分析法与任意区域上取积分的方法<br>自然界中也有许多现象所满足的规律是通过变量的微元之间的关系式来表达的。对于这类问题，我们不能直接列出自变量和未知函数及其变化率之间的关系式，而是通过微元分析法，利用已知的规律建立一些变量（自变量与未知函数）的微元之间的关系式，然后再通过取极限的方法得到微分方程，或等价地通过任意区域上取积分的方法来建立微分方程。<br>（iii）模拟近似法<br>在生物、经济等学科中，许多现象所满足的规律并不很清楚而且相当复杂，因而需要根据实际资料或大量的实验数据，提出各种假设。在一定的假设下，给出实际现象所满足的规律，然后利用适当的数学方法列出微分方程。在实际的微分方程建模过程中，也往往是上述方法的综合应用。不论应用哪种方法，通常要根据实际情况，作出一定的假设与简化，并要把模型的理论或计算结果与实际情况进行对照验证，以修改模型使之更准确地描述实际问题并进而达到预测预报的目的。</p></blockquote></li></ol><h3 id="马氏链模型"><a href="#马氏链模型" class="headerlink" title="马氏链模型"></a>马氏链模型</h3><blockquote><p><a href="https://wenku.baidu.com/view/174a64f19e31433239689346.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://www.zhihu.com/question/26665048" target="_blank" rel="noopener">通俗解释</a><br><a href="https://blog.csdn.net/asd20172016/article/details/81392938" target="_blank" rel="noopener">Python代码实现</a></p></blockquote><p> <strong>简介</strong>：马尔可夫链的定义<br>现实世界中有很多这样的现象：某一系统在已知现在情况的条件下，系统未来时刻的情况只与现在有关，而与过去的历史无直接关系。比如，研究一个商店的累计销售额，如果现在时刻的累计销售额已知，则未来某一时刻的累计销售额与现在时刻以前的任一时刻累计销售额无关。上节中的几个例子也均属此类。描述这类随机现象的数学模型称为马氏模型。</p><h3 id="时间序列模型"><a href="#时间序列模型" class="headerlink" title="时间序列模型"></a>时间序列模型</h3><blockquote><p><a href="https://blog.csdn.net/mengjizhiyou/article/details/82683448" target="_blank" rel="noopener">概念理解</a><br><a href="https://www.jianshu.com/p/c7cb0de104f4" target="_blank" rel="noopener">参考资料</a></p></blockquote><p><strong>简介</strong>：时间序列是按时间顺序排列的、随时间变化且相互关联的数据序列。分析时间序列的方法构成数据分析的一个重要领域，即时间序列分析。<br>时间序列根据所研究的依据不同，可有不同的分类。</p><blockquote><p>1．按所研究的对象的多少分，有一元时间序列和多元时间序列。<br>2．按时间的连续性可将时间序列分为离散时间序列和连续时间序列两种。<br>3．按序列的统计特性分，有平稳时间序列和非平稳时间序列。如果一个时间序列的概率分布与时间 t 无关，则称该序列为严格的（狭义的）平稳时间序列。如果序列的一、二阶矩存在，而且对任意时刻 t 满足：<br>（1）均值为常数<br>（2）协方差为时间间隔 τ 的函数。<br>则称该序列为宽平稳时间序列，也叫广义平稳时间序列。我们以后所研究的时间序列主要是宽平稳时间序列。<br>4．按时间序列的分布规律来分，有高斯型时间序列和非高斯型时间序列。</p></blockquote><h3 id="模糊数学模型"><a href="#模糊数学模型" class="headerlink" title="模糊数学模型"></a>模糊数学模型</h3><blockquote><p><a href="https://wenku.baidu.com/view/891d403cabea998fcc22bcd126fff705cc175c8e.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://wenku.baidu.com/view/543cbf9cf8c75fbfc77db296.html" target="_blank" rel="noopener">参考资料</a></p></blockquote><p> <strong>简介</strong>：模糊是指客观事物差异的中间过渡中的“不分明性”或“亦此亦彼性”。如高个子与矮个子、年轻人与老年人、热水与凉水、环境污染严重与不严重等。在决策中，也有这种模糊的现象，如选举一个好干部，但怎样才算一个好干部？好干部与不好干部之间没有绝对分明和固定不变的界限。这些现象很难用经典的数学来描述。</p><h3 id="灰色系统理论及其应用"><a href="#灰色系统理论及其应用" class="headerlink" title="灰色系统理论及其应用"></a>灰色系统理论及其应用</h3><blockquote><p><a href="https://blog.csdn.net/qq547276542/article/details/77865341/" target="_blank" rel="noopener">灰色预测</a><br><a href="https://wenku.baidu.com/view/6fc36073657d27284b73f242336c1eb91a3733f2.html" target="_blank" rel="noopener">PPT资料l</a><br><a href="https://blog.csdn.net/wys7541/article/details/82354152" target="_blank" rel="noopener">代码实现</a></p></blockquote><p><strong>简介</strong>：客观世界的很多实际问题，其内部的结构、参数以及特征并未全部被人们了解，人们不可能象研究白箱问题那样将其内部机理研究清楚，只能依据某种思维逻辑与推断来构造模型。对这类部分信息已知而部分信息未知的系统，我们称之为灰色系统。</p><h3 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h3><blockquote><p><a href="https://wenku.baidu.com/view/28c079ae0c22590103029d2b.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://blog.csdn.net/wsp_1138886114/article/details/80475981" target="_blank" rel="noopener">K-means算法实现及详解</a><br><a href="https://blog.csdn.net/LuYi_WeiLin/article/details/91129037" target="_blank" rel="noopener">SPSS聚类分析</a></p></blockquote><p><strong>简介</strong>：将认识对象进行分类是人类认识世界的一种重要方法，比如有关世界的时间进程的研究，就形成了历史学，也有关世界空间地域的研究，则形成了地理学。又如在生物学中，为了研究生物的演变，需要对生物进行分类，生物学家根据各种生物的特征，将它们归属于不同的界、门、纲、目、科、属、种之中。事实上，分门别类地对事物进行研究，要远比在一个混杂多变的集合中更清晰、明了和细致，这是因为同一类事物会具有更多的近似特性。在企业的经营管理中，为了确定其目标市场，首先要进行市场细分。因为无论一个企业多么庞大和成功，它也无法满足整个市场的各种需求。而市场细分，可以帮助企业找到适合自己特色，并使企业具有竞争力的分市场，将其作为自己的重点开发目标。通常，人们可以凭经验和专业知识来实现分类。而聚类分析（cluster analyses）作为一种定量方法，将从数据分析的角度，给出一个更准确、细致的分类工具。</p><h3 id="存贮论"><a href="#存贮论" class="headerlink" title="存贮论"></a>存贮论</h3><blockquote><p><a href="https://wenku.baidu.com/view/7ab4704b366baf1ffc4ffe4733687e21af45ffbd.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://blog.csdn.net/qq_29831163/article/details/89891256" target="_blank" rel="noopener">参考资料及Lingo实现</a></p></blockquote><p><strong>简介</strong>：存贮论（或称为库存论）是定量方法和技术最早的领域之一，是研究存贮系统的性质、运行规律以及如何寻找最优存贮策略的一门学科，是运筹学的重要分支。存贮论的数学模型一般分成两类：一类是确定性模型，它不包含任何随机因素，另一类是带有随机因素的随机存贮模型。</p><h3 id="现代优化算法"><a href="#现代优化算法" class="headerlink" title="现代优化算法"></a>现代优化算法</h3><ul><li><p>模拟退火</p><blockquote><p><a href="https://baike.baidu.com/item/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/355508?fr=aladdin" target="_blank" rel="noopener">概念理解</a><br><a href="https://wenku.baidu.com/view/0ec00e6fef06eff9aef8941ea76e58fafab0450f.html" target="_blank" rel="noopener">PPT资料啊</a><br><a href="https://zhuanlan.zhihu.com/p/33184423" target="_blank" rel="noopener">参考资料</a><br><a href="https://www.cnblogs.com/sench/p/9427193.html" target="_blank" rel="noopener">模拟退火TSP问题</a><br><a href="https://www.jianshu.com/p/0ef29fcfe7b1" target="_blank" rel="noopener">代码实现</a></p></blockquote></li><li><p>遗传算法</p><blockquote><p><a href="https://baike.baidu.com/item/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/838140?fr=aladdin" target="_blank" rel="noopener">概念理解</a><br><a href="https://www.jianshu.com/p/ae5157c26af9" target="_blank" rel="noopener">参考资料</a><br><a href="https://blog.csdn.net/yy2050645/article/details/80724857" target="_blank" rel="noopener">Python实现</a><br><a href="https://blog.csdn.net/qq_35109096/article/details/81105522" target="_blank" rel="noopener">代码实现</a></p></blockquote></li></ul><p><strong>简介</strong>：遗传算法（Genetic Algorithm, GA）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。其主要特点是直接对结构对象进行操作，不存在求导和函数连续性的限定；具有内在的隐并行性和更好的全局寻优能力；采用概率化的寻优方法，不需要确定的规则就能自动获取和指导优化的搜索空间，自适应地调整搜索方向。遗传算法以一种群体中的所有个体为对象，并利用随机化技术指导对一个被编码的参数空间进行高效搜索。其中，选择、交叉和变异构成了遗传算法的遗传操作；参数编码、初始群体的设定、适应度函数的设计、遗传操作设计、控制参数设定五个要素组成了遗传算法的核心内容。</p><ul><li>禁忌搜索<blockquote><p><a href="https://baike.baidu.com/item/%E7%A6%81%E5%BF%8C%E6%90%9C%E7%B4%A2/6987733?fr=aladdin" target="_blank" rel="noopener">概念理解</a><br><a href="https://wenku.baidu.com/view/2a32329977eeaeaad1f34693daef5ef7bb0d124b.html" target="_blank" rel="noopener">PPT资料</a></p></blockquote></li></ul><p><strong>简介</strong>：禁忌搜索（Tabu Search，TS）是一种现代启发式算法，由美国科罗拉多大学教授Fred Glover在1986年左右提出的，是一个用来跳脱局部最优解的搜索方法。算法基于局部搜索算法改进而来，通过引入禁忌表来克服局部搜索算法容易陷入局部最优的缺点，具有全局寻优能力。</p><ul><li>蚁群算法<blockquote><p><a href="https://wenku.baidu.com/view/025b2aa887c24028905fc374.html" target="_blank" rel="noopener">参考过程</a><br><a href="https://blog.csdn.net/lyxleft/article/details/82980760" target="_blank" rel="noopener">算法详解及代码</a><br><a href="https://www.jb51.net/article/128117.htm" target="_blank" rel="noopener">Python实现</a></p></blockquote></li></ul><h3 id="神经网络模型"><a href="#神经网络模型" class="headerlink" title="神经网络模型"></a>神经网络模型</h3><blockquote><p><a href="https://wenku.baidu.com/view/0814339d988fcc22bcd126fff705cc1755275ffc.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://blog.csdn.net/qq_24690701/article/details/81868048" target="_blank" rel="noopener">概念理解</a><br><a href="https://blog.csdn.net/dujiahei/article/details/80965661" target="_blank" rel="noopener">模型一览</a><br><a href="https://blog.csdn.net/qq_29831163/article/details/89509279" target="_blank" rel="noopener">案例及代码实现</a><br><a href="https://blog.csdn.net/ximingren/article/details/79981620" target="_blank" rel="noopener">Python实现</a></p></blockquote><p><strong>简介</strong>：人工神经网络（artificial neural network，以下简称 NN）有三个基本要素：</p><blockquote><p>（i）一组连接（对应于生物神经元的突触），连接强度由各连接上的权值表示，权值为正表示激活，为负表示抑制。<br>（ii）一个求和单元，用于求取各输入信号的加权和（线性组合）。<br>（iii）一个非线性激活函数，起非线性映射作用并将神经元输出幅度限制在一定范围内（一般限制在 （0,1） 或（-1,1） 之间）。</p></blockquote><h3 id="粒子群优化算法"><a href="#粒子群优化算法" class="headerlink" title="粒子群优化算法"></a>粒子群优化算法</h3><blockquote><p><a href="https://wenku.baidu.com/view/e920ac483968011ca3009189.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://www.cnblogs.com/GraceSkyer/p/8448348.html" target="_blank" rel="noopener">代码实现</a></p></blockquote><h3 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h3><blockquote><p><a href="https://blog.csdn.net/u011815404/article/details/80313879" target="_blank" rel="noopener">算法汇总</a></p></blockquote><ul><li>迪杰斯特拉算法<blockquote><p><a href="https://www.jianshu.com/p/ff6db00ad866" target="_blank" rel="noopener">算法理解及实现</a></p></blockquote></li></ul><p><strong>简介</strong>：Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。</p><ul><li>弗洛伊德Floyd算法<blockquote><p><a href="https://wenku.baidu.com/view/8bb2ea6ca31614791711cc7931b765ce04087a5a.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://blog.csdn.net/weixin_38361153/article/details/88415181" target="_blank" rel="noopener">Python实现</a></p></blockquote></li></ul><p><strong>简介</strong>：Floyd算法又称为插点法，是一种利用<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408" target="_blank" rel="noopener">动态规划</a>的思想寻找给定的<a href="https://baike.baidu.com/item/%E5%8A%A0%E6%9D%83%E5%9B%BE/10579361" target="_blank" rel="noopener">加权图</a>中多源点之间<a href="https://baike.baidu.com/item/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/6334920" target="_blank" rel="noopener">最短路径</a>的算法，与Dijkstra算法类似。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实战：小道具小功能实现</title>
      <link href="/posts/blog-python12.html"/>
      <url>/posts/blog-python12.html</url>
      
        <content type="html"><![CDATA[<h5 id="文末有所有项目的源码地址，可供参考："><a href="#文末有所有项目的源码地址，可供参考：" class="headerlink" title="文末有所有项目的源码地址，可供参考："></a>文末有所有项目的源码地址，可供参考：</h5><h3 id="Image-Edit"><a href="#Image-Edit" class="headerlink" title="Image-Edit"></a>Image-Edit</h3><h5 id="几个基本的图片编辑工具，包括一下功能："><a href="#几个基本的图片编辑工具，包括一下功能：" class="headerlink" title="几个基本的图片编辑工具，包括一下功能："></a>几个基本的图片编辑工具，包括一下功能：</h5><ul><li>文件：打开，保存，退出</li><li>编辑：放大，缩小，灰度，亮度，旋转，截图</li><li>变换：傅里叶变换，离散余弦变换，Radon变换</li><li>噪声：高斯，椒盐，斑点，泊松</li><li>滤波：高通，低通，平滑，锐化</li><li>直方图统计：R直方图，G直方图，B直方图</li><li>图像增强：伪彩色，真彩色，直方图均衡，NTSC颜色模型，YCbCr颜色模型，HSV颜色模型</li><li>阈值分割</li><li>生态学处理</li><li>特征提取</li><li>图像分类与识别</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-dd904df9db6b4a24?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库文件需要"><a href="#库文件需要" class="headerlink" title="库文件需要"></a>库文件需要</h5><pre><code> 1. PyQt5 2. sys 3. os 4. opencv2 5. numpy 6. scipy 7. matplotlib</code></pre><h3 id="Beautify-Camera"><a href="#Beautify-Camera" class="headerlink" title="Beautify-Camera"></a>Beautify-Camera</h3><h5 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>文件：打开，保存，打开摄像头</li><li>操作：还原，人脸识别</li><li>滤镜：怀旧，木刻，灰色，彩色，风格化，增强细节</li><li>调节：亮度，饱和度，伽马变换，边缘保持</li><li>磨皮美白：美白度，磨皮程度，磨皮精度</li><li>灰度直方图</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-08e784fc5ae40737?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库文件需要-1"><a href="#库文件需要-1" class="headerlink" title="库文件需要"></a>库文件需要</h5><pre><code> 1. PyQt5 2. sys 3. opencv2 4. numpy 5. matplotlib</code></pre><h5 id="相关代码说明"><a href="#相关代码说明" class="headerlink" title="相关代码说明"></a>相关代码说明</h5><ul><li><p>人脸识别</p><pre><code># 人脸识别  def detect_face(self):      img = self.raw_image      face_cascade = cv2.CascadeClassifier('./haarcascade_frontalface_default.xml')      gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)      faces = face_cascade.detectMultiScale(gray, 1.3, 5)      return faces</code></pre></li><li><p>皮肤识别</p><pre><code># 皮肤识别  def detect_skin(self):      img = self.raw_image      rows, cols, channals = img.shape      for r in range(rows):          for c in range(cols):              B = img.item(r, c, 0)              G = img.item(r, c, 1)              R = img.item(r, c, 2)              if (abs(R - G) &gt; 15) and (R &gt; G) and (R &gt; B):                  if (R &gt; 95) and (G &gt; 40) and (B &gt; 20) and (max(R, G, B) - min(R, G, B) &gt; 15):                      self.imgskin[r, c] = (1, 1, 1)                  elif (R &gt; 220) and (G &gt; 210) and (B &gt; 170):                      self.imgskin[r, c] = (1, 1, 1)</code></pre></li><li><p>其他不做详解</p></li></ul><h3 id="Calculator"><a href="#Calculator" class="headerlink" title="Calculator"></a>Calculator</h3><h5 id="主要功能-1"><a href="#主要功能-1" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>基本的加减乘除和开根号等运算</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f9b852ac6c40ef25?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库文件需求"><a href="#库文件需求" class="headerlink" title="库文件需求"></a>库文件需求</h5><pre><code>1.math2.tkinter</code></pre><h3 id="pyQt5-Calculator"><a href="#pyQt5-Calculator" class="headerlink" title="pyQt5-Calculator"></a>pyQt5-Calculator</h3><h5 id="主要功能-2"><a href="#主要功能-2" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>基本的加减乘除和开根号等运算</li></ul><p>1.calculator.py</p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-08132a3099f58ccd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><p>2.Calculator_.py</p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-3b052cc5951cb1f3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库文件需求-1"><a href="#库文件需求-1" class="headerlink" title="库文件需求"></a>库文件需求</h5><pre><code>1.PyQt52.sys3.math</code></pre><h3 id="Painting绘画"><a href="#Painting绘画" class="headerlink" title="Painting绘画"></a>Painting绘画</h3><h5 id="主要功能-3"><a href="#主要功能-3" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>File：新建画板，打开图片，保存图片</li><li>Edit：复制，清空画板</li><li>Image：翻转</li><li>工具：基本画笔，橡皮擦，图形创建工具等</li><li>编辑区，色彩调节区，字体调节区等</li></ul><h5 id="库文件需求-2"><a href="#库文件需求-2" class="headerlink" title="库文件需求"></a>库文件需求</h5><pre><code>1.PyQt52.random3.type4.os</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-94153ceb969517fd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h3 id="NotePad"><a href="#NotePad" class="headerlink" title="NotePad"></a>NotePad</h3><h5 id="主要功能-4"><a href="#主要功能-4" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>基本文本编辑，类似于记事本</li></ul><h5 id="库文件需求-3"><a href="#库文件需求-3" class="headerlink" title="库文件需求"></a>库文件需求</h5><pre><code>1.pyQt52.sys3.os</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-054412aceafbc63f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h3 id="RandomPassWord"><a href="#RandomPassWord" class="headerlink" title="RandomPassWord"></a>RandomPassWord</h3><h5 id="主要功能-5"><a href="#主要功能-5" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>随机生成一串密码，包括大小写字母，数字，符号，可指定长度</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f815c1dd28390162.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库文件引入"><a href="#库文件引入" class="headerlink" title="库文件引入"></a>库文件引入</h5><pre><code>1.secrets2.pyQt53.sys</code></pre><h3 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h3><h5 id="主要功能-6"><a href="#主要功能-6" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>基本浏览器功能</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-c4addcf72cd0bbd3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库函数需求"><a href="#库函数需求" class="headerlink" title="库函数需求"></a>库函数需求</h5><pre><code>1.pyQt52.os3.sys</code></pre><h3 id="MusicPlayer"><a href="#MusicPlayer" class="headerlink" title="MusicPlayer"></a>MusicPlayer</h3><h5 id="主要功能-7"><a href="#主要功能-7" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>音乐播放器</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-630c03ab25054cbb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库函数引用"><a href="#库函数引用" class="headerlink" title="库函数引用"></a>库函数引用</h5><pre><code>1.os2.sys3.time4.pyQt5</code></pre><h3 id="PyTunes"><a href="#PyTunes" class="headerlink" title="PyTunes"></a>PyTunes</h3><h5 id="主要功能-8"><a href="#主要功能-8" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>轻量级音乐播放器</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-33d57b3fd6ebd253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库函数引用-1"><a href="#库函数引用-1" class="headerlink" title="库函数引用"></a>库函数引用</h5><pre><code>1.sys2.pyQt5</code></pre><p><strong>源码地址：</strong><a href="https://github.com/JackHCC/Mini-Tools" target="_blank" rel="noopener">https://github.com/JackHCC/Mini-Tools</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-机器学习模块PyTorch</title>
      <link href="/posts/blog-python11.html"/>
      <url>/posts/blog-python11.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/JackHCC/API-for-PyTorch" target="_blank" rel="noopener">点击访问：PyTorch中文API应用具体代码地址</a></p><h1 id="自动求导机制"><a href="#自动求导机制" class="headerlink" title="自动求导机制"></a>自动求导机制</h1><p>本说明将概述Autograd如何工作并记录操作。了解这些并不是绝对必要的，但我们建议您熟悉它，因为它将帮助您编写更高效，更简洁的程序，并可帮助您进行调试。</p><h2 id="从后向中排除子图"><a href="#从后向中排除子图" class="headerlink" title="从后向中排除子图"></a>从后向中排除子图</h2><p>每个变量都有两个标志：<code>requires_grad</code>和<code>volatile</code>。它们都允许从梯度计算中精细地排除子图，并可以提高效率。</p><h3 id="requires-grad"><a href="#requires-grad" class="headerlink" title="requires_grad"></a><code>requires_grad</code></h3><p>如果有一个单一的输入操作需要梯度，它的输出也需要梯度。相反，只有所有输入都不需要梯度，输出才不需要。如果其中所有的变量都不需要梯度进行，后向计算不会在子图中执行。</p><pre><code>&gt;&gt;&gt; x = Variable(torch.randn(5, 5))&gt;&gt;&gt; y = Variable(torch.randn(5, 5))&gt;&gt;&gt; z = Variable(torch.randn(5, 5), requires_grad=True)&gt;&gt;&gt; a = x + y&gt;&gt;&gt; a.requires_gradFalse&gt;&gt;&gt; b = a + z&gt;&gt;&gt; b.requires_gradTrue</code></pre><p>这个标志特别有用，当您想要冻结部分模型时，或者您事先知道不会使用某些参数的梯度。例如，如果要对预先训练的CNN进行优化，只要切换冻结模型中的<code>requires_grad</code>标志就足够了，直到计算到最后一层才会保存中间缓冲区，其中的仿射变换将使用需要梯度的权重并且网络的输出也将需要它们。</p><pre><code>model = torchvision.models.resnet18(pretrained=True)for param in model.parameters():    param.requires_grad = False# Replace the last fully-connected layer# Parameters of newly constructed modules have requires_grad=True by defaultmodel.fc = nn.Linear(512, 100)# Optimize only the classifieroptimizer = optim.SGD(model.fc.parameters(), lr=1e-2, momentum=0.9)</code></pre><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h3><p>纯粹的inference模式下推荐使用<code>volatile</code>，当你确定你甚至不会调用<code>.backward()</code>时。它比任何其他自动求导的设置更有效——它将使用绝对最小的内存来评估模型。<code>volatile</code>也决定了<code>require_grad is False</code>。</p><p><code>volatile</code>不同于<code>require_grad</code>的传递。如果一个操作甚至只有有一个<code>volatile</code>的输入，它的输出也将是<code>volatile</code>。<code>Volatility</code>比“不需要梯度”更容易传递——只需要一个<code>volatile</code>的输入即可得到一个<code>volatile</code>的输出，相对的，需要所有的输入“不需要梯度”才能得到不需要梯度的输出。使用volatile标志，您不需要更改模型参数的任何设置来用于inference。创建一个<code>volatile</code>的输入就够了，这将保证不会保存中间状态。</p><pre><code>&gt;&gt;&gt; regular_input = Variable(torch.randn(5, 5))&gt;&gt;&gt; volatile_input = Variable(torch.randn(5, 5), volatile=True)&gt;&gt;&gt; model = torchvision.models.resnet18(pretrained=True)&gt;&gt;&gt; model(regular_input).requires_gradTrue&gt;&gt;&gt; model(volatile_input).requires_gradFalse&gt;&gt;&gt; model(volatile_input).volatileTrue&gt;&gt;&gt; model(volatile_input).creator is NoneTrue</code></pre><h2 id="自动求导如何编码历史信息"><a href="#自动求导如何编码历史信息" class="headerlink" title="自动求导如何编码历史信息"></a>自动求导如何编码历史信息</h2><p>每个变量都有一个<code>.creator</code>属性，它指向把它作为输出的函数。这是一个由<code>Function</code>对象作为节点组成的有向无环图（DAG）的入口点，它们之间的引用就是图的边。每次执行一个操作时，一个表示它的新<code>Function</code>就被实例化，它的<code>forward()</code>方法被调用，并且它输出的<code>Variable</code>的创建者被设置为这个<code>Function</code>。然后，通过跟踪从任何变量到叶节点的路径，可以重建创建数据的操作序列，并自动计算梯度。</p><p>需要注意的一点是，整个图在每次迭代时都是从头开始重新创建的，这就允许使用任意的Python控制流语句，这样可以在每次迭代时改变图的整体形状和大小。在启动训练之前不必对所有可能的路径进行编码—— what you run is what you differentiate.</p><h2 id="Variable上的In-place操作"><a href="#Variable上的In-place操作" class="headerlink" title="Variable上的In-place操作"></a>Variable上的In-place操作</h2><p>在自动求导中支持in-place操作是一件很困难的事情，我们在大多数情况下都不鼓励使用它们。Autograd的缓冲区释放和重用非常高效，并且很少场合下in-place操作能实际上明显降低内存的使用量。除非您在内存压力很大的情况下，否则您可能永远不需要使用它们。</p><p>限制in-place操作适用性主要有两个原因：</p><p>１．覆盖梯度计算所需的值。这就是为什么变量不支持<code>log_</code>。它的梯度公式需要原始输入，而虽然通过计算反向操作可以重新创建它，但在数值上是不稳定的，并且需要额外的工作，这往往会与使用这些功能的目的相悖。</p><p>２．每个in-place操作实际上需要实现重写计算图。不合适的版本只需分配新对象并保留对旧图的引用，而in-place操作则需要将所有输入的<code>creator</code>更改为表示此操作的<code>Function</code>。这就比较棘手，特别是如果有许多变量引用相同的存储（例如通过索引或转置创建的），并且如果被修改输入的存储被任何其他<code>Variable</code>引用，则in-place函数实际上会抛出错误。</p><h2 id="In-place正确性检查"><a href="#In-place正确性检查" class="headerlink" title="In-place正确性检查"></a>In-place正确性检查</h2><p>每个变量保留有version counter，它每次都会递增，当在任何操作中被使用时。当<code>Function</code>保存任何用于后向的tensor时，还会保存其包含变量的version counter。一旦访问<code>self.saved_tensors</code>，它将被检查，如果它大于保存的值，则会引起错误。</p><h1 id="CUDA语义"><a href="#CUDA语义" class="headerlink" title="CUDA语义"></a>CUDA语义</h1><p><code>torch.cuda</code>会记录当前选择的GPU，并且分配的所有CUDA张量将在上面创建。可以使用<code>torch.cuda.device</code>上下文管理器更改所选设备。</p><p>但是，一旦张量被分配，您可以直接对其进行操作，而不考虑所选择的设备，结果将始终放在与张量相同的设备上。</p><p>默认情况下，不支持跨GPU操作，唯一的例外是<code>copy_()</code>。 除非启用对等存储器访问，否则对分布不同设备上的张量任何启动操作的尝试都将会引发错误。</p><p>下面你可以找到一个展示如下的小例子：</p><pre><code>x = torch.cuda.FloatTensor(1)# x.get_device() == 0y = torch.FloatTensor(1).cuda()# y.get_device() == 0with torch.cuda.device(1):    # allocates a tensor on GPU 1    a = torch.cuda.FloatTensor(1)    # transfers a tensor from CPU to GPU 1    b = torch.FloatTensor(1).cuda()    # a.get_device() == b.get_device() == 1    c = a + b    # c.get_device() == 1    z = x + y    # z.get_device() == 0    # even within a context, you can give a GPU id to the .cuda call    d = torch.randn(2).cuda(2)    # d.get_device() == 2</code></pre><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="使用固定的内存缓冲区"><a href="#使用固定的内存缓冲区" class="headerlink" title="使用固定的内存缓冲区"></a>使用固定的内存缓冲区</h3><p>当副本来自固定（页锁）内存时，主机到GPU的复制速度要快很多。CPU张量和存储开放了一个<code>pin_memory()</code>方法，它返回该对象的副本，而它的数据放在固定区域中。</p><p>另外，一旦固定了张量或存储，就可以使用异步的GPU副本。只需传递一个额外的<code>async=True</code>参数到<code>cuda()</code>的调用。这可以用于将数据传输与计算重叠。</p><p>通过将<code>pin_memory=True</code>传递给其构造函数，可以使<code>DataLoader</code>将batch返回到固定内存中。</p><h3 id="使用-nn-DataParallel-替代-multiprocessing"><a href="#使用-nn-DataParallel-替代-multiprocessing" class="headerlink" title="使用 nn.DataParallel 替代 multiprocessing"></a>使用 nn.DataParallel 替代 multiprocessing</h3><p>大多数涉及批量输入和多个GPU的情况应默认使用<code>DataParallel</code>来使用多个GPU。尽管有GIL的存在，单个python进程也可能使多个GPU饱和。</p><p>从0.1.9版本开始，大量的GPU(8+)可能未被充分利用。然而，这是一个已知的问题，也正在积极开发。和往常一样，测试你的用例吧。</p><p>调用<code>multiprocessing</code>来利用CUDA模型存在重要的注意事项；使用具有多处理功能的CUDA模型有重要的注意事项; 除非就是需要谨慎地满足数据处理需求，否则您的程序很可能会出现错误或未定义的行为。</p><h1 id="扩展PyTorch"><a href="#扩展PyTorch" class="headerlink" title="扩展PyTorch"></a>扩展PyTorch</h1><h2 id="扩展-torch-autograd"><a href="#扩展-torch-autograd" class="headerlink" title="扩展 torch.autograd"></a>扩展 torch.autograd</h2><p>如果你想要添加一个新的 <code>Operation</code> 到<code>autograd</code>的话，你的<code>Operation</code>需要继承 <code>class Function</code>。<code>autograd</code>使用<code>Function</code>计算结果和梯度，同时编码 <code>operation</code>的历史。每个新的 <code>operation(function)</code> 都需要实现三个方法：</p><ul><li><p><code>__init__ (optional)</code> - 如果你的<code>operation</code>包含非<code>Variable</code>参数，那么就将其作为<code>__init__</code>的参数传入到<code>operation</code>中。例如：<code>AddConstant Function</code>加一个常数，<code>Transpose Function</code>需要指定哪两个维度需要交换。如果你的<code>operation</code>不需要额外的参数，你可以忽略<code>__init__</code>。</p></li><li><p><code>forward()</code> - 在里面写执行此<code>operation</code>的代码。可以有任意数量的参数。如果你对某些参数指定了默认值，则这些参数是可传可不传的。记住：<code>forward()</code>的参数只能是<code>Variable</code>。函数的返回值既可以是 <code>Variable</code>也可以是<code>Variables</code>的<code>tuple</code>。同时，请参考 <code>Function</code>[function]的 <code>doc</code>，查阅有哪些 方法是只能在<code>forward</code>中调用的。</p></li><li><p><code>backward()</code> - 梯度计算公式。 参数的个数和<code>forward</code>返回值的个数一样，每个参数代表传回到此<code>operation</code>的梯度. <code>backward()</code>的返回值的个数应该和此<code>operation</code>输入的个数一样，每个返回值对应了输入值的梯度。如果<code>operation</code>的输入不需要梯度，或者不可导，你可以返回<code>None</code>。 如果<code>forward()</code>存在可选参数，你可以返回比输入更多的梯度，只是返回的是<code>None</code>。</p></li></ul><p>下面是 <code>Linear</code> 的实现代码：</p><pre><code># Inherit from Functionclass Linear(Function):    # bias is an optional argument    def forward(self, input, weight, bias=None):        self.save_for_backward(input, weight, bias)        output = input.mm(weight.t())        if bias is not None:            output += bias.unsqueeze(0).expand_as(output)        return output    # This function has only a single output, so it gets only one gradient    def backward(self, grad_output):        # This is a pattern that is very convenient - at the top of backward        # unpack saved_tensors and initialize all gradients w.r.t. inputs to        # None. Thanks to the fact that additional trailing Nones are        # ignored, the return statement is simple even when the function has        # optional inputs.        input, weight, bias = self.saved_tensors        grad_input = grad_weight = grad_bias = None        # These needs_input_grad checks are optional and there only to        # improve efficiency. If you want to make your code simpler, you can        # skip them. Returning gradients for inputs that don't require it is        # not an error.        if self.needs_input_grad[0]:            grad_input = grad_output.mm(weight)        if self.needs_input_grad[1]:            grad_weight = grad_output.t().mm(input)        if bias is not None and self.needs_input_grad[2]:            grad_bias = grad_output.sum(0).squeeze(0)        return grad_input, grad_weight, grad_bias</code></pre><p>现在，为了可以更简单的使用自定义的<code>operation</code>，我们建议将其用一个简单的 <code>helper function</code> 包装起来。 functions:</p><pre><code>def linear(input, weight, bias=None):    # First braces create a Function object. Any arguments given here    # will be passed to __init__. Second braces will invoke the __call__    # operator, that will then use forward() to compute the result and    # return it.    return Linear()(input, weight, bias)</code></pre><p>你可能想知道你刚刚实现的 <code>backward</code>方法是否正确的计算了梯度。你可以使用 小的有限的差分进行数值估计。</p><pre><code>from torch.autograd import gradcheck# gradchek takes a tuple of tensor as input, check if your gradient# evaluated with these tensors are close enough to numerical# approximations and returns True if they all verify this condition.input = (Variable(torch.randn(20,20).double(), requires_grad=True),)test = gradcheck.gradcheck(Linear(), input, eps=1e-6, atol=1e-4)print(test)</code></pre><h2 id="扩展-torch-nn"><a href="#扩展-torch-nn" class="headerlink" title="扩展 torch.nn"></a>扩展 torch.nn</h2><p><code>nn</code> 包含两种接口 - <code>modules</code>和他们的<code>functional</code>版本。通过这两个接口，你都可以扩展<code>nn</code>。但是我们建议，在扩展<code>layer</code>的时候，使用<code>modules</code>， 因为<code>modules</code>保存着参数和<code>buffer</code>。如果不需要参数的话，那么建议使用<code>functional</code>(激活函数，pooling，这些都不需要参数)。</p><p>增加一个<code>operation</code>的 <code>functional</code>版本已经在上面一节介绍完毕。</p><p>增加一个模块(<code>module</code>)。 由于<code>nn</code>重度使用<code>autograd</code>。所以，添加一个新<code>module</code>需要实现一个 用来执行 计算 和 计算梯度 的<code>Function</code>。从现在开始，假定我们想要实现一个<code>Linear module</code>，记得之前我们已经实现了一个<code>Linear Funciton</code>。 只需要很少的代码就可以完成这个工作。 现在，我们需要实现两个方法：</p><ul><li><p><code>__init__ (optional)</code> - 输入参数，例如<code>kernel sizes</code>, <code>numbers of features</code>, 等等。同时初始化 <code>parameters</code>和<code>buffers</code>。</p></li><li><p><code>forward()</code> - 实例化一个执行<code>operation</code>的<code>Function</code>，使用它执行<code>operation</code>。和<code>functional wrapper(上面实现的那个简单的wrapper)</code>十分类似。</p></li></ul><p><code>Linear module</code>实现代码:</p><pre><code>class Linear(nn.Module):    def __init__(self, input_features, output_features, bias=True):        self.input_features = input_features        self.output_features = output_features        # nn.Parameter is a special kind of Variable, that will get        # automatically registered as Module's parameter once it's assigned        # as an attribute. Parameters and buffers need to be registered, or        # they won't appear in .parameters() (doesn't apply to buffers), and        # won't be converted when e.g. .cuda() is called. You can use        # .register_buffer() to register buffers.        # nn.Parameters can never be volatile and, different than Variables,        # they require gradients by default.        self.weight = nn.Parameter(torch.Tensor(input_features, output_features))        if bias:            self.bias = nn.Parameter(torch.Tensor(output_features))        else:            # You should always register all possible parameters, but the            # optional ones can be None if you want.            self.register_parameter('bias', None)        # Not a very smart way to initialize weights        self.weight.data.uniform_(-0.1, 0.1)        if bias is not None:            self.bias.data.uniform_(-0.1, 0.1)    def forward(self, input):        # See the autograd section for explanation of what happens here.        return Linear()(input, self.weight, self.bias)        #注意这个Linear是之前实现过的Linear</code></pre><h2 id="编写自定义C扩展"><a href="#编写自定义C扩展" class="headerlink" title="编写自定义C扩展"></a>编写自定义<code>C</code>扩展</h2><p>Coming soon. For now you can find an example at <a href="https://github.com/pytorch/extension-ffi" target="_blank" rel="noopener">GitHub</a>.</p><h1 id="多进程最佳实践"><a href="#多进程最佳实践" class="headerlink" title="多进程最佳实践"></a>多进程最佳实践</h1><p><code>torch.multiprocessing</code>是Python<code>multiprocessing</code>的替代品。它支持完全相同的操作，但扩展了它以便通过<code>multiprocessing.Queue</code>发送的所有张量将其数据移动到共享内存中，并且只会向其他进程发送一个句柄。</p><blockquote><p><strong>Note</strong></p><p>当<code>Variable</code>发送到另一个进程时，<code>Variable.data</code>和<code>Variable.grad.data</code>都将被共享。</p></blockquote><p>这允许实现各种训练方法，如Hogwild，A3C或需要异步操作的任何其他方法。</p><h2 id="共享CUDA张量"><a href="#共享CUDA张量" class="headerlink" title="共享CUDA张量"></a>共享CUDA张量</h2><p>仅在Python 3中使用<code>spawn</code>或<code>forkserver</code>启动方法才支持在进程之间共享CUDA张量。Python 2中的<code>multiprocessing</code>只能使用<code>fork</code>创建子进程，并且不被CUDA运行时所支持。</p><blockquote><p><strong>Warning</strong></p><p>CUDA API要求导出到其他进程的分配，只要它们被使用就要一直保持有效。您应该小心，确保您共享的CUDA张量只要有必要就不要超出范围。这不是共享模型参数的问题，但传递其他类型的数据应该小心。注意，此限制不适用于共享CPU内存。</p></blockquote><h2 id="最佳实践和提示"><a href="#最佳实践和提示" class="headerlink" title="最佳实践和提示"></a>最佳实践和提示</h2><h3 id="避免和抵制死锁"><a href="#避免和抵制死锁" class="headerlink" title="避免和抵制死锁"></a>避免和抵制死锁</h3><p>当一个新进程被产生时，有很多事情可能会出错，最常见的死锁原因是后台线程。如果有任何线程持有锁或导入模块，并且<code>fork</code>被调用，则子进程很可能处于损坏的状态，并以不同的方式死锁或失败。注意，即使您没有，Python内置的库也可能会这样做 —— 不需要看得比<code>multiprocessing</code>更远。<code>multiprocessing.Queue</code>实际上是一个非常复杂的类，它产生用于序列化，发送和接收对象的多个线程，它们也可能引起上述问题。如果您发现自己处于这种情况，请尝试使用<code>multiprocessing.queues.SimpleQueue</code>，这不会使用任何其他线程。</p><p>我们正在竭尽全力把它设计得更简单，并确保这些死锁不会发生，但有些事情无法控制。如果有任何问题您无法一时无法解决，请尝试在论坛上提出，我们将看看是否可以解决问题。</p><h3 id="重用经过队列的缓冲区"><a href="#重用经过队列的缓冲区" class="headerlink" title="重用经过队列的缓冲区"></a>重用经过队列的缓冲区</h3><p>记住每次将<code>Tensor</code>放入<code>multiprocessing.Queue</code>时，必须将其移动到共享内存中。如果它已经被共享，它是一个无效的操作，否则会产生一个额外的内存副本，这会减缓整个进程。即使你有一个进程池来发送数据到一个进程，使它返回缓冲区 —— 这几乎是免费的，并且允许你在发送下一个batch时避免产生副本。</p><h3 id="异步多进程训练（例如Hogwild）"><a href="#异步多进程训练（例如Hogwild）" class="headerlink" title="异步多进程训练（例如Hogwild）"></a>异步多进程训练（例如Hogwild）</h3><p>使用<code>torch.multiprocessing</code>，可以异步地训练模型，参数可以一直共享，也可以定期同步。在第一种情况下，我们建议发送整个模型对象，而在后者中，我们建议只发送<code>state_dict()</code>。</p><p>我们建议使用<code>multiprocessing.Queue</code>来在进程之间传递各种PyTorch对象。例如， 当使用fork启动方法时，可能会继承共享内存中的张量和存储器，但这是非常容易出错的，应谨慎使用，而且只能由高级用户使用。队列虽然有时是一个较不优雅的解决方案，但基本上能在所有情况下正常工作。</p><blockquote><p><strong>Warning</strong> 你应该注意有关全局语句，它们没有被<code>if __name__ == '__main__'</code>保护。如果使用与<code>fork</code>不同的启动方法，则它们将在所有子进程中执行。</p></blockquote><h4 id="Hogwild"><a href="#Hogwild" class="headerlink" title="Hogwild"></a>Hogwild</h4><p>在<a href="https://github.com/pytorch/examples/tree/master/mnist_hogwild" target="_blank" rel="noopener">examples repository</a>中可以找到具体的Hogwild实现，可以展示代码的整体结构。下面也有一个小例子：</p><pre><code>import torch.multiprocessing as mpfrom model import MyModeldef train(model):    # Construct data_loader, optimizer, etc.    for data, labels in data_loader:        optimizer.zero_grad()        loss_fn(model(data), labels).backward()        optimizer.step()  # This will update the shared parametersif __name__ == '__main__':    num_processes = 4    model = MyModel()    # NOTE: this is required for the ``fork`` method to work    model.share_memory()    processes = []    for rank in range(num_processes):        p = mp.Process(target=train, args=(model,))        p.start()        processes.append(p)    for p in processes:      p.join()</code></pre><h1 id="序列化语义"><a href="#序列化语义" class="headerlink" title="序列化语义"></a>序列化语义</h1><h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="保存模型的推荐方法"><a href="#保存模型的推荐方法" class="headerlink" title="保存模型的推荐方法"></a>保存模型的推荐方法</h3><p>这主要有两种方法序列化和恢复模型。</p><p>第一种（推荐）只保存和加载模型参数：</p><pre><code>torch.save(the_model.state_dict(), PATH)</code></pre><p>然后：</p><pre><code>the_model = TheModelClass(*args, **kwargs)the_model.load_state_dict(torch.load(PATH))</code></pre><p>第二种保存和加载整个模型：</p><pre><code>torch.save(the_model, PATH)</code></pre><p>然后：</p><pre><code>the_model = torch.load(PATH)</code></pre><p>然而，在这种情况下，序列化的数据被绑定到特定的类和固定的目录结构，所以当在其他项目中使用时，或者在一些严重的重构器之后它可能会以各种方式break。</p><h1 id="torch"><a href="#torch" class="headerlink" title="torch"></a>torch</h1><p>包 <code>torch</code> 包含了多维张量的数据结构以及基于其上的多种数学操作。另外，它也提供了多种工具，其中一些可以更有效地对张量和任意类型进行序列化。</p><p>它有CUDA 的对应实现，可以在NVIDIA GPU上进行张量运算(计算能力&gt;=2.0)。</p><h1 id="张量-Tensors"><a href="#张量-Tensors" class="headerlink" title="张量 Tensors"></a>张量 Tensors</h1><p><strong>torch.is_tensor</strong><a href="http://pytorch.org/docs/_modules/torch.html#is_tensor" target="_blank" rel="noopener">[source]</a></p><pre><code>torch.is_tensor(obj)</code></pre><p>如果<em>obj</em> 是一个pytorch张量，则返回True</p><ul><li>参数： obj (Object) – 判断对象</li></ul><hr><p><strong>torch.is_storage</strong> <a href="http://pytorch.org/docs/_modules/torch.html#is_storage" target="_blank" rel="noopener">[source]</a></p><pre><code>torch.is_storage(obj)</code></pre><p>如何<em>obj</em> 是一个pytorch storage对象，则返回True</p><ul><li>参数： input (Object) – 判断对象</li></ul><hr><p><strong>torch.</strong>set_default_tensor_type****<a href="http://pytorch.org/docs/_modules/torch.html#set_default_tensor_type" target="_blank" rel="noopener">[source]</a></p><pre><code>torch.set_default_tensor_type(t)</code></pre><hr><p><strong>torch.numel</strong></p><pre><code>torch.numel(input)-&gt;int</code></pre><p>返回<code>input</code> 张量中的元素个数</p><ul><li>参数: input (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener"><em>Tensor</em></a>) – 输入张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; a = torch.randn(1,2,3,4,5)&gt;&gt;&gt; torch.numel(a)120&gt;&gt;&gt; a = torch.zeros(4,4)&gt;&gt;&gt; torch.numel(a)16</code></pre><hr><p><strong>torch.set_printoptions</strong><a href="http://pytorch.org/docs/_modules/torch/_tensor_str.html#set_printoptions" target="_blank" rel="noopener">[source]</a></p><pre><code>torch.set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, profile=None)</code></pre><p>设置打印选项。 完全参考自<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.set_printoptions.html" target="_blank" rel="noopener"> Numpy</a>。</p><p>参数:</p><ul><li>precision – 浮点数输出的精度位数 (默认为8 )</li><li>threshold – 阈值，触发汇总显示而不是完全显示(repr)的数组元素的总数 （默认为1000）</li><li>edgeitems – 汇总显示中，每维（轴）两端显示的项数（默认值为3）</li><li>linewidth – 用于插入行间隔的每行字符数（默认为80）。Thresholded matricies will ignore this parameter.</li><li>profile – pretty打印的完全默认值。 可以覆盖上述所有选项 (默认为short, full)</li></ul><h2 id="创建操作-Creation-Ops"><a href="#创建操作-Creation-Ops" class="headerlink" title="创建操作 Creation Ops"></a>创建操作 Creation Ops</h2><p><strong>torch.eye</strong></p><pre><code>torch.eye(n, m=None, out=None)</code></pre><p>返回一个2维张量，对角线位置全1，其它位置全0</p><p>参数:</p><ul><li>n (<a href="https://docs.python.org/2/library/functions.html#int" target="_blank" rel="noopener">int</a> ) – 行数</li><li>m (<a href="https://docs.python.org/2/library/functions.html#int" target="_blank" rel="noopener">int</a>, <em>optional</em>) – 列数.如果为None,则默认为<em>n</em></li><li>out (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener"><em>Tensor</em></a>, <em>optinal</em>) - Output tensor</li></ul><p>返回值: 对角线位置全1，其它位置全0的2维张量</p><p>返回值类型: <a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener">Tensor</a></p><p>例子:</p><pre><code>&gt;&gt;&gt; torch.eye(3) 1  0  0 0  1  0 0  0  1[torch.FloatTensor of size 3x3]</code></pre><hr><p><strong>from_numpy</strong></p><pre><code>torch.from_numpy(ndarray) → Tensor</code></pre><p>Numpy桥，将<code>numpy.ndarray</code> 转换为pytorch的 <code>Tensor</code>。 返回的张量tensor和numpy的ndarray共享同一内存空间。修改一个会导致另外一个也被修改。返回的张量不能改变大小。</p><p>例子:</p><pre><code>&gt;&gt;&gt; a = numpy.array([1, 2, 3])&gt;&gt;&gt; t = torch.from_numpy(a)&gt;&gt;&gt; ttorch.LongTensor([1, 2, 3])&gt;&gt;&gt; t[0] = -1&gt;&gt;&gt; aarray([-1,  2,  3])</code></pre><p><strong>torch.linspace</strong></p><pre><code>torch.linspace(start, end, steps=100, out=None) → Tensor</code></pre><p>返回一个1维张量，包含在区间<code>start</code> 和 <code>end</code> 上均匀间隔的<code>steps</code>个点。 输出1维张量的长度为<code>steps</code>。</p><p>参数:</p><ul><li>start (float) – 序列的起始点</li><li>end (float) – 序列的最终值</li><li>steps (int) – 在<code>start</code> 和 <code>end</code>间生成的样本数</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; torch.linspace(3, 10, steps=5)  3.0000  4.7500  6.5000  8.2500 10.0000[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.linspace(-10, 10, steps=5)-10 -5  0  5 10[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.linspace(start=-10, end=10, steps=5)-10 -5  0  5 10[torch.FloatTensor of size 5]</code></pre><hr><p><strong>torch.logspace</strong></p><pre><code>torch.logspace(start, end, steps=100, out=None) → Tensor</code></pre><p>返回一个1维张量，包含在区间 10的start次方到10的end次方上以对数刻度均匀间隔的<code>steps</code>个点。 输出1维张量的长度为<code>steps</code>。</p><p>参数:</p><ul><li>start (float) – 序列的起始点</li><li>end (float) – 序列的最终值</li><li>steps (int) – 在<code>start</code> 和 <code>end</code>间生成的样本数</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; torch.logspace(start=-10, end=10, steps=5) 1.0000e-10 1.0000e-05 1.0000e+00 1.0000e+05 1.0000e+10[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.logspace(start=0.1, end=1.0, steps=5)  1.2589  2.1135  3.5481  5.9566 10.0000[torch.FloatTensor of size 5]</code></pre><p><strong>torch.ones</strong></p><pre><code>torch.ones(*sizes, out=None) → Tensor</code></pre><p>返回一个全为1 的张量，形状由可变参数<code>sizes</code>定义。</p><p>参数:</p><ul><li>sizes (int…) – 整数序列，定义了输出形状</li><li>out (Tensor, optional) – 结果张量 例子:</li></ul><pre><code>&gt;&gt;&gt; torch.ones(2, 3) 1  1  1 1  1  1[torch.FloatTensor of size 2x3]&gt;&gt;&gt; torch.ones(5) 1 1 1 1 1[torch.FloatTensor of size 5]</code></pre><hr><p><strong>torch.rand</strong></p><pre><code>torch.rand(*sizes, out=None) → Tensor</code></pre><p>返回一个张量，包含了从区间[0,1)的均匀分布中抽取的一组随机数，形状由可变参数<code>sizes</code> 定义。</p><p>参数:</p><ul><li>sizes (int…) – 整数序列，定义了输出形状</li><li>out (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener"><em>Tensor</em></a>, <em>optinal</em>) - 结果张量 例子：</li></ul><pre><code>&gt;&gt;&gt; torch.rand(4) 0.9193 0.3347 0.3232 0.7715[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.rand(2, 3) 0.5010  0.5140  0.0719 0.1435  0.5636  0.0538[torch.FloatTensor of size 2x3]</code></pre><hr><p><strong>torch.randn</strong></p><pre><code>torch.randn(*sizes, out=None) → Tensor</code></pre><p>返回一个张量，包含了从标准正态分布(均值为0，方差为 1，即高斯白噪声)中抽取一组随机数，形状由可变参数<code>sizes</code>定义。 参数:</p><ul><li>sizes (int…) – 整数序列，定义了输出形状</li><li>out (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener"><em>Tensor</em></a>, <em>optinal</em>) - 结果张量</li></ul><p>例子：:</p><pre><code>&gt;&gt;&gt; torch.randn(4)-0.1145 0.0094-1.1717 0.9846[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.randn(2, 3) 1.4339  0.3351 -1.0999 1.5458 -0.9643 -0.3558[torch.FloatTensor of size 2x3]</code></pre><hr><p><strong>torch.randperm</strong></p><pre><code>torch.randperm(n, out=None) → LongTensor</code></pre><p>给定参数<code>n</code>，返回一个从<code>0</code> 到<code>n -1</code> 的随机整数排列。</p><p>参数:</p><ul><li>n (int) – 上边界(不包含)</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.randperm(4) 2 1 3 0[torch.LongTensor of size 4]</code></pre><hr><p><strong>torch.arange</strong></p><pre><code>torch.arange(start, end, step=1, out=None) → Tensor</code></pre><p>参数:</p><ul><li>start (float) – 序列的起始点</li><li>end (float) – 序列的终止点</li><li>step (float) – 相邻点的间隔大小</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.arange(1, 4) 1 2 3[torch.FloatTensor of size 3]&gt;&gt;&gt; torch.arange(1, 2.5, 0.5) 1.0000 1.5000 2.0000[torch.FloatTensor of size 3]</code></pre><hr><p><strong>torch.range</strong></p><pre><code>torch.range(start, end, step=1, out=None) → Tensor</code></pre><p><strong>警告</strong>：建议使用函数 <code>torch.arange()</code></p><p>参数:</p><ul><li>start (float) – 序列的起始点</li><li>end (float) – 序列的最终值</li><li>step (int) – 相邻点的间隔大小</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.range(1, 4) 1 2 3 4[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.range(1, 4, 0.5) 1.0000 1.5000 2.0000 2.5000 3.0000 3.5000 4.0000[torch.FloatTensor of size 7]</code></pre><hr><p><strong>torch.zeros</strong></p><pre><code>torch.zeros(*sizes, out=None) → Tensor</code></pre><p>返回一个全为标量 0 的张量，形状由可变参数<code>sizes</code> 定义。</p><p>参数:</p><ul><li>sizes (int…) – 整数序列，定义了输出形状</li><li>out (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener">Tensor</a>, <em>optional</em>) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.zeros(2, 3) 0  0  0 0  0  0[torch.FloatTensor of size 2x3]&gt;&gt;&gt; torch.zeros(5) 0 0 0 0 0[torch.FloatTensor of size 5]</code></pre><hr><h2 id="索引-切片-连接-换位Indexing-Slicing-Joining-Mutating-Ops"><a href="#索引-切片-连接-换位Indexing-Slicing-Joining-Mutating-Ops" class="headerlink" title="索引,切片,连接,换位Indexing, Slicing, Joining, Mutating Ops"></a>索引,切片,连接,换位Indexing, Slicing, Joining, Mutating Ops</h2><h3 id="torch-cat"><a href="#torch-cat" class="headerlink" title="torch.cat"></a>torch.cat</h3><pre><code>torch.cat(inputs, dimension=0) → Tensor</code></pre><p>在给定维度上对输入的张量序列<code>seq</code> 进行连接操作。</p><p><code>torch.cat()</code>可以看做 <code>torch.split()</code> 和 <code>torch.chunk()</code>的反操作。 <code>cat()</code> 函数可以通过下面例子更好的理解。</p><p>参数:</p><ul><li>inputs (<em>sequence of Tensors</em>) – 可以是任意相同Tensor 类型的python 序列</li><li>dimension (<em>int</em>, <em>optional</em>) – 沿着此维连接张量序列。</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.randn(2, 3)&gt;&gt;&gt; x 0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735[torch.FloatTensor of size 2x3]&gt;&gt;&gt; torch.cat((x, x, x), 0) 0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735 0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735 0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735[torch.FloatTensor of size 6x3]&gt;&gt;&gt; torch.cat((x, x, x), 1) 0.5983 -0.0341  2.4918  0.5983 -0.0341  2.4918  0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735  1.5981 -0.5265 -0.8735  1.5981 -0.5265 -0.8735[torch.FloatTensor of size 2x9]</code></pre><h3 id="torch-chunk"><a href="#torch-chunk" class="headerlink" title="torch.chunk"></a>torch.chunk</h3><pre><code>torch.chunk(tensor, chunks, dim=0)</code></pre><p>在给定维度(轴)上将输入张量进行分块儿。</p><p>参数:</p><ul><li>tensor (Tensor) – 待分块的输入张量</li><li>chunks (int) – 分块的个数</li><li>dim (int) – 沿着此维度进行分块</li></ul><h3 id="torch-gather"><a href="#torch-gather" class="headerlink" title="torch.gather"></a>torch.gather</h3><pre><code>torch.gather(input, dim, index, out=None) → Tensor</code></pre><p>沿给定轴<code>dim</code>，将输入索引张量<code>index</code>指定位置的值进行聚合。</p><p>对一个3维张量，输出可以定义为：</p><pre><code>out[i][j][k] = tensor[index[i][j][k]][j][k]  # dim=0out[i][j][k] = tensor[i][index[i][j][k]][k]  # dim=1out[i][j][k] = tensor[i][j][index[i][j][k]]  # dim=3</code></pre><p>例子：</p><pre><code>&gt;&gt;&gt; t = torch.Tensor([[1,2],[3,4]])&gt;&gt;&gt; torch.gather(t, 1, torch.LongTensor([[0,0],[1,0]])) 1  1 4  3[torch.FloatTensor of size 2x2]</code></pre><p>参数:</p><ul><li>input (Tensor) – 源张量</li><li>dim (int) – 索引的轴</li><li>index (LongTensor) – 聚合元素的下标</li><li>out (Tensor, optional) – 目标张量</li></ul><h3 id="torch-index-select"><a href="#torch-index-select" class="headerlink" title="torch.index_select"></a>torch.index_select</h3><pre><code>torch.index_select(input, dim, index, out=None) → Tensor</code></pre><p>沿着指定维度对输入进行切片，取<code>index</code>中指定的相应项(<code>index</code>为一个LongTensor)，然后返回到一个新的张量， 返回的张量与原始张量_Tensor_有相同的维度(在指定轴上)。</p><p>注意： 返回的张量不与原始张量共享内存空间。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 索引的轴</li><li>index (LongTensor) – 包含索引下标的一维张量</li><li>out (Tensor, optional) – 目标张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.randn(3, 4)&gt;&gt;&gt; x 1.2045  2.4084  0.4001  1.1372 0.5596  1.5677  0.6219 -0.7954 1.3635 -1.2313 -0.5414 -1.8478[torch.FloatTensor of size 3x4]&gt;&gt;&gt; indices = torch.LongTensor([0, 2])&gt;&gt;&gt; torch.index_select(x, 0, indices) 1.2045  2.4084  0.4001  1.1372 1.3635 -1.2313 -0.5414 -1.8478[torch.FloatTensor of size 2x4]&gt;&gt;&gt; torch.index_select(x, 1, indices) 1.2045  0.4001 0.5596  0.6219 1.3635 -0.5414[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-masked-select"><a href="#torch-masked-select" class="headerlink" title="torch.masked_select"></a>torch.masked_select</h3><pre><code>torch.masked_select(input, mask, out=None) → Tensor</code></pre><p>根据掩码张量<code>mask</code>中的二元值，取输入张量中的指定项( <code>mask</code>为一个 <em>ByteTensor</em>)，将取值返回到一个新的1D张量，</p><p>张量 <code>mask</code>须跟<code>input</code>张量有相同数量的元素数目，但形状或维度不需要相同。 注意： 返回的张量不与原始张量共享内存空间。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>mask (ByteTensor) – 掩码张量，包含了二元索引值</li><li>out (Tensor, optional) – 目标张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.randn(3, 4)&gt;&gt;&gt; x 1.2045  2.4084  0.4001  1.1372 0.5596  1.5677  0.6219 -0.7954 1.3635 -1.2313 -0.5414 -1.8478[torch.FloatTensor of size 3x4]&gt;&gt;&gt; indices = torch.LongTensor([0, 2])&gt;&gt;&gt; torch.index_select(x, 0, indices) 1.2045  2.4084  0.4001  1.1372 1.3635 -1.2313 -0.5414 -1.8478[torch.FloatTensor of size 2x4]&gt;&gt;&gt; torch.index_select(x, 1, indices) 1.2045  0.4001 0.5596  0.6219 1.3635 -0.5414[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-nonzero"><a href="#torch-nonzero" class="headerlink" title="torch.nonzero"></a>torch.nonzero</h3><pre><code>torch.nonzero(input, out=None) → LongTensor</code></pre><p>返回一个包含输入<code>input</code>中非零元素索引的张量。输出张量中的每行包含输入中非零元素的索引。</p><p>如果输入<code>input</code>有<code>n</code>维，则输出的索引张量<code>output</code>的形状为 z x n, 这里 z 是输入张量<code>input</code>中所有非零元素的个数。</p><p>参数:</p><ul><li>input (Tensor) – 源张量</li><li>out (LongTensor, optional) – 包含索引值的结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.nonzero(torch.Tensor([1, 1, 1, 0, 1])) 0 1 2 4[torch.LongTensor of size 4x1]&gt;&gt;&gt; torch.nonzero(torch.Tensor([[0.6, 0.0, 0.0, 0.0],...                             [0.0, 0.4, 0.0, 0.0],...                             [0.0, 0.0, 1.2, 0.0],...                             [0.0, 0.0, 0.0,-0.4]])) 0  0 1  1 2  2 3  3[torch.LongTensor of size 4x2]</code></pre><h3 id="torch-split"><a href="#torch-split" class="headerlink" title="torch.split"></a>torch.split</h3><pre><code>torch.split(tensor, split_size, dim=0)</code></pre><p>将输入张量分割成相等形状的chunks（如果可分）。 如果沿指定维的张量形状大小不能被<code>split_size</code> 整分， 则最后一个分块会小于其它分块。</p><p>参数:</p><ul><li>tensor (Tensor) – 待分割张量</li><li>split_size (int) – 单个分块的形状大小</li><li>dim (int) – 沿着此维进行分割</li></ul><h3 id="torch-squeeze"><a href="#torch-squeeze" class="headerlink" title="torch.squeeze"></a>torch.squeeze</h3><pre><code>torch.squeeze(input, dim=None, out=None)</code></pre><p>注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int, optional) – 如果给定，则<code>input</code>只会在给定维度挤压</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.zeros(2,1,2,1,2)&gt;&gt;&gt; x.size()(2L, 1L, 2L, 1L, 2L)&gt;&gt;&gt; y = torch.squeeze(x)&gt;&gt;&gt; y.size()(2L, 2L, 2L)&gt;&gt;&gt; y = torch.squeeze(x, 0)&gt;&gt;&gt; y.size()(2L, 1L, 2L, 1L, 2L)&gt;&gt;&gt; y = torch.squeeze(x, 1)&gt;&gt;&gt; y.size()(2L, 2L, 1L, 2L)</code></pre><h3 id="torch-stack-source"><a href="#torch-stack-source" class="headerlink" title="torch.stack[source]"></a>torch.stack<a href="http://pytorch.org/docs/_modules/torch/functional.html#stack" target="_blank" rel="noopener">[source]</a></h3><pre><code>torch.stack(sequence, dim=0)</code></pre><p>沿着一个新维度对输入张量序列进行连接。 序列中所有的张量都应该为相同形状。</p><p>参数:</p><ul><li>sqequence (Sequence) – 待连接的张量序列</li><li>dim (int) – 插入的维度。必须介于 0 与 待连接的张量序列数之间。</li></ul><h3 id="torch-t"><a href="#torch-t" class="headerlink" title="torch.t"></a>torch.t</h3><pre><code>torch.t(input, out=None) → Tensor</code></pre><p>输入一个矩阵（2维张量），并转置0, 1维。 可以被视为函数<code>transpose(input, 0, 1)</code>的简写函数。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 结果张量</li></ul><pre><code>&gt;&gt;&gt; x = torch.randn(2, 3)&gt;&gt;&gt; x 0.4834  0.6907  1.3417-0.1300  0.5295  0.2321[torch.FloatTensor of size 2x3]&gt;&gt;&gt; torch.t(x) 0.4834 -0.1300 0.6907  0.5295 1.3417  0.2321[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-transpose"><a href="#torch-transpose" class="headerlink" title="torch.transpose"></a>torch.transpose</h3><pre><code>torch.transpose(input, dim0, dim1, out=None) → Tensor</code></pre><p>返回输入矩阵<code>input</code>的转置。交换维度<code>dim0</code>和<code>dim1</code>。 输出张量与输入张量共享内存，所以改变其中一个会导致另外一个也被修改。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>dim0 (int) – 转置的第一维</li><li>dim1 (int) – 转置的第二维</li></ul><pre><code>&gt;&gt;&gt; x = torch.randn(2, 3)&gt;&gt;&gt; x 0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735[torch.FloatTensor of size 2x3]&gt;&gt;&gt; torch.transpose(x, 0, 1) 0.5983  1.5981-0.0341 -0.5265 2.4918 -0.8735[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-unbind"><a href="#torch-unbind" class="headerlink" title="torch.unbind"></a>torch.unbind</h3><pre><code>torch.unbind(tensor, dim=0)[source]</code></pre><p>移除指定维后，返回一个元组，包含了沿着指定维切片后的各个切片</p><p>参数:</p><ul><li>tensor (Tensor) – 输入张量</li><li>dim (int) – 删除的维度</li></ul><h3 id="torch-unsqueeze"><a href="#torch-unsqueeze" class="headerlink" title="torch.unsqueeze"></a>torch.unsqueeze</h3><pre><code>torch.unsqueeze(input, dim, out=None)</code></pre><p>返回一个新的张量，对输入的制定位置插入维度 1</p><p>注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。</p><p>参数:</p><ul><li>tensor (Tensor) – 输入张量</li><li>dim (int) – 插入维度的索引</li><li>out (Tensor, optional) – 结果张量</li></ul><pre><code>&gt;&gt;&gt; x = torch.Tensor([1, 2, 3, 4])&gt;&gt;&gt; torch.unsqueeze(x, 0) 1  2  3  4[torch.FloatTensor of size 1x4]&gt;&gt;&gt; torch.unsqueeze(x, 1) 1 2 3 4[torch.FloatTensor of size 4x1]</code></pre><hr><h2 id="随机抽样-Random-sampling"><a href="#随机抽样-Random-sampling" class="headerlink" title="随机抽样 Random sampling"></a>随机抽样 Random sampling</h2><h3 id="torch-manual-seed"><a href="#torch-manual-seed" class="headerlink" title="torch.manual_seed"></a>torch.manual_seed</h3><pre><code>torch.manual_seed(seed)</code></pre><p>设定生成随机数的种子，并返回一个 <em>torch._C.Generator</em> 对象.</p><p>参数: seed (int or long) – 种子.</p><h3 id="torch-initial-seed"><a href="#torch-initial-seed" class="headerlink" title="torch.initial_seed"></a>torch.initial_seed</h3><pre><code>torch.initial_seed()</code></pre><p>返回生成随机数的原始种子值（python long）。</p><h3 id="torch-get-rng-state"><a href="#torch-get-rng-state" class="headerlink" title="torch.get_rng_state"></a>torch.get_rng_state</h3><pre><code>torch.get_rng_state()[source]</code></pre><p>返回随机生成器状态(<em>ByteTensor</em>)</p><h3 id="torch-set-rng-state"><a href="#torch-set-rng-state" class="headerlink" title="torch.set_rng_state"></a>torch.set_rng_state</h3><pre><code>torch.set_rng_state(new_state)[source]</code></pre><p>设定随机生成器状态 参数: new_state (torch.ByteTensor) – 期望的状态</p><h3 id="torch-default-generator"><a href="#torch-default-generator" class="headerlink" title="torch.default_generator"></a>torch.default_generator</h3><pre><code>torch.default_generator = &lt;torch._C.Generator object&gt;</code></pre><h3 id="torch-bernoulli"><a href="#torch-bernoulli" class="headerlink" title="torch.bernoulli"></a>torch.bernoulli</h3><pre><code>torch.bernoulli(input, out=None) → Tensor</code></pre><p>从伯努利分布中抽取二元随机数(0 或者 1)。</p><p>输出张量的第<em><code>i</code></em>个元素值， 将会以输入张量的第<em><code>i</code></em>个概率值等于<code>1</code>。</p><p>返回值将会是与输入相同大小的张量，每个值为0或者1 参数:</p><ul><li>input (Tensor) – 输入为伯努利分布的概率值</li><li>out (Tensor, optional) – 输出张量(可选)</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.Tensor(3, 3).uniform_(0, 1) # generate a uniform random matrix with range [0, 1]&gt;&gt;&gt; a 0.7544  0.8140  0.9842 0.5282  0.0595  0.6445 0.1925  0.9553  0.9732[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.bernoulli(a) 1  1  1 0  0  1 0  1  1[torch.FloatTensor of size 3x3]&gt;&gt;&gt; a = torch.ones(3, 3) # probability of drawing "1" is 1&gt;&gt;&gt; torch.bernoulli(a) 1  1  1 1  1  1 1  1  1[torch.FloatTensor of size 3x3]&gt;&gt;&gt; a = torch.zeros(3, 3) # probability of drawing "1" is 0&gt;&gt;&gt; torch.bernoulli(a) 0  0  0 0  0  0 0  0  0[torch.FloatTensor of size 3x3]</code></pre><hr><h3 id="torch-multinomial"><a href="#torch-multinomial" class="headerlink" title="torch.multinomial"></a>torch.multinomial</h3><pre><code>torch.multinomial(input, num_samples,replacement=False, out=None) → LongTensor</code></pre><p>返回一个张量，每行包含从<code>input</code>相应行中定义的多项分布中抽取的<code>num_samples</code>个样本。</p><p><strong>[注意]</strong>:输入<code>input</code>每行的值不需要总和为1 (这里我们用来做权重)，但是必须非负且总和不能为0。</p><p>当抽取样本时，依次从左到右排列(第一个样本对应第一列)。</p><p>如果参数<code>replacement</code> 为 <em>True</em>, 则样本抽取可以重复。否则，一个样本在每行不能被重复抽取。</p><p>参数<code>num_samples</code>必须小于<code>input</code>长度(即，<code>input</code>的列数，如果是<code>input</code>是一个矩阵)。</p><p>参数:</p><ul><li>input (Tensor) – 包含概率值的张量</li><li>num_samples (int) – 抽取的样本数</li><li>replacement (bool, optional) – 布尔值，决定是否能重复抽取</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; weights = torch.Tensor([0, 10, 3, 0]) # create a Tensor of weights&gt;&gt;&gt; torch.multinomial(weights, 4) 1 2 0 0[torch.LongTensor of size 4]&gt;&gt;&gt; torch.multinomial(weights, 4, replacement=True) 1 2 1 2[torch.LongTensor of size 4]</code></pre><h3 id="torch-normal"><a href="#torch-normal" class="headerlink" title="torch.normal()"></a>torch.normal()</h3><pre><code>torch.normal(means, std, out=None)</code></pre><p>返回一个张量，包含从给定参数<code>means</code>,<code>std</code>的离散正态分布中抽取随机数。 均值<code>means</code>是一个张量，包含每个输出元素相关的正态分布的均值。 <code>std</code>是一个张量，包含每个输出元素相关的正态分布的标准差。 均值和标准差的形状不须匹配，但每个张量的元素个数须相同。</p><p>参数:</p><ul><li>means (Tensor) – 均值</li><li>std (Tensor) – 标准差</li><li>out (Tensor) – 可选的输出张量</li></ul><pre><code>torch.normal(means=torch.arange(1, 11), std=torch.arange(1, 0, -0.1)) 1.5104 1.6955 2.4895 4.9185 4.9895 6.9155 7.3683 8.1836 8.7164 9.8916[torch.FloatTensor of size 10]</code></pre><pre><code>torch.normal(mean=0.0, std, out=None)</code></pre><p>与上面函数类似，所有抽取的样本共享均值。</p><p>参数:</p><ul><li>means (Tensor,optional) – 所有分布均值</li><li>std (Tensor) – 每个元素的标准差</li><li>out (Tensor) – 可选的输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; torch.normal(mean=0.5, std=torch.arange(1, 6))  0.5723  0.0871 -0.3783 -2.5689 10.7893[torch.FloatTensor of size 5]</code></pre><pre><code>torch.normal(means, std=1.0, out=None)</code></pre><p>与上面函数类似，所有抽取的样本共享标准差。</p><p>参数:</p><ul><li>means (Tensor) – 每个元素的均值</li><li>std (float, optional) – 所有分布的标准差</li><li>out (Tensor) – 可选的输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; torch.normal(means=torch.arange(1, 6)) 1.1681 2.8884 3.7718 2.5616 4.2500[torch.FloatTensor of size 5]</code></pre><hr><h2 id="序列化-Serialization"><a href="#序列化-Serialization" class="headerlink" title="序列化 Serialization"></a>序列化 Serialization</h2><h3 id="torch-saves-source"><a href="#torch-saves-source" class="headerlink" title="torch.saves[source]"></a>torch.saves<a href="http://pytorch.org/docs/_modules/torch/serialization.html#save" target="_blank" rel="noopener">[source]</a></h3><pre><code>torch.save(obj, f, pickle_module=&lt;module 'pickle' from '/home/jenkins/miniconda/lib/python3.5/pickle.py'&gt;, pickle_protocol=2)</code></pre><p>保存一个对象到一个硬盘文件上 参考: <a href="http://pytorch.org/docs/notes/serialization.html#recommend-saving-models" target="_blank" rel="noopener">Recommended approach for saving a model</a> 参数：</p><ul><li>obj – 保存对象</li><li>f － 类文件对象 (返回文件描述符)或一个保存文件名的字符串</li><li>pickle_module – 用于pickling元数据和对象的模块</li><li>pickle_protocol – 指定pickle protocal 可以覆盖默认参数</li></ul><h3 id="torch-load-source"><a href="#torch-load-source" class="headerlink" title="torch.load[source]"></a>torch.load<a href="http://pytorch.org/docs/_modules/torch/serialization.html#load" target="_blank" rel="noopener">[source]</a></h3><pre><code>torch.load(f, map_location=None, pickle_module=&lt;module 'pickle' from '/home/jenkins/miniconda/lib/python3.5/pickle.py'&gt;)</code></pre><p>从磁盘文件中读取一个通过<code>torch.save()</code>保存的对象。 <code>torch.load()</code> 可通过参数<code>map_location</code> 动态地进行内存重映射，使其能从不动设备中读取文件。一般调用时，需两个参数: storage 和 location tag. 返回不同地址中的storage，或着返回None (此时地址可以通过默认方法进行解析). 如果这个参数是字典的话，意味着其是从文件的地址标记到当前系统的地址标记的映射。 默认情况下， location tags中 “cpu”对应host tensors，‘cuda:device_id’ (e.g. ‘cuda:2’) 对应cuda tensors。 用户可以通过register_package进行扩展，使用自己定义的标记和反序列化方法。</p><p>参数:</p><ul><li>f – 类文件对象 (返回文件描述符)或一个保存文件名的字符串</li><li>map_location – 一个函数或字典规定如何remap存储位置</li><li>pickle_module – 用于unpickling元数据和对象的模块 (必须匹配序列化文件时的pickle_module )</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; torch.load('tensors.pt')# Load all tensors onto the CPU&gt;&gt;&gt; torch.load('tensors.pt', map_location=lambda storage, loc: storage)# Map tensors from GPU 1 to GPU 0&gt;&gt;&gt; torch.load('tensors.pt', map_location={'cuda:1':'cuda:0'})</code></pre><h2 id="并行化-Parallelism"><a href="#并行化-Parallelism" class="headerlink" title="并行化 Parallelism"></a>并行化 Parallelism</h2><h3 id="torch-get-num-threads"><a href="#torch-get-num-threads" class="headerlink" title="torch.get_num_threads"></a>torch.get_num_threads</h3><pre><code>torch.get_num_threads() → int</code></pre><p>获得用于并行化CPU操作的OpenMP线程数</p><hr><h3 id="torch-set-num-threads"><a href="#torch-set-num-threads" class="headerlink" title="torch.set_num_threads"></a>torch.set_num_threads</h3><pre><code>torch.set_num_threads(int)</code></pre><p>设定用于并行化CPU操作的OpenMP线程数</p><h1 id="数学操作Math-operations"><a href="#数学操作Math-operations" class="headerlink" title="数学操作Math operations"></a>数学操作Math operations</h1><h2 id="Pointwise-Ops"><a href="#Pointwise-Ops" class="headerlink" title="Pointwise Ops"></a>Pointwise Ops</h2><h3 id="torch-abs"><a href="#torch-abs" class="headerlink" title="torch.abs"></a>torch.abs</h3><pre><code>torch.abs(input, out=None) → Tensor</code></pre><p>计算输入张量的每个元素绝对值</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.abs(torch.FloatTensor([-1, -2, 3]))FloatTensor([1, 2, 3])</code></pre><h3 id="torch-acos-input-out-None-→-Tensor"><a href="#torch-acos-input-out-None-→-Tensor" class="headerlink" title="torch.acos(input, out=None) → Tensor"></a>torch.acos(input, out=None) → Tensor</h3><pre><code>torch.acos(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入张量每个元素的反余弦。 参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener">Tensor</a>, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.acos(a) 2.2608 1.2956 1.1075    nan[torch.FloatTensor of size 4]</code></pre><h3 id="torch-add"><a href="#torch-add" class="headerlink" title="torch.add()"></a>torch.add()</h3><pre><code>torch.add(input, value, out=None)</code></pre><p>如果输入<code>input</code>是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>value</code>取整数、实数皆可。】</p><ul><li>input (Tensor) – 输入张量</li><li>value (Number) – 添加到输入每个元素的数</li><li>out (Tensor, optional) – 结果张量</li></ul><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 0.4050-1.2227 1.8688-0.4185[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.add(a, 20) 20.4050 18.7773 21.8688 19.5815[torch.FloatTensor of size 4]</code></pre><pre><code>torch.add(input, value=1, other, out=None)</code></pre><p>两个张量 <code>input</code> and <code>other</code>的尺寸不需要匹配，但元素总数必须一样。</p><p><strong>注意</strong> :当两个张量形状不匹配时，输入张量的形状会作为输出张量的尺寸。</p><p>如果<code>other</code>是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>value</code>取整数、实数皆可。】</p><p>参数:</p><ul><li>input (Tensor) – 第一个输入张量</li><li>value (Number) – 用于第二个张量的尺寸因子</li><li>other (Tensor) – 第二个输入张量</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; import torch&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.9310 2.0330 0.0852-0.2941[torch.FloatTensor of size 4]&gt;&gt;&gt; b = torch.randn(2, 2)&gt;&gt;&gt; b 1.0663  0.2544-0.1513  0.0749[torch.FloatTensor of size 2x2]&gt;&gt;&gt; torch.add(a, 10, b) 9.7322 4.5770-1.4279 0.4552[torch.FloatTensor of size 4]</code></pre><h3 id="torch-addcdiv"><a href="#torch-addcdiv" class="headerlink" title="torch.addcdiv"></a>torch.addcdiv</h3><pre><code>torch.addcdiv(tensor, value=1, tensor1, tensor2, out=None) → Tensor</code></pre><p>用<code>tensor2</code>对<code>tensor1</code>逐元素相除，然后乘以标量值<code>value</code> 并加到<code>tensor</code>。</p><p>张量的形状不需要匹配，但元素数量必须一致。</p><p>如果输入是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。</p><p>参数：</p><ul><li>tensor (Tensor) – 张量，对 tensor1 ./ tensor 进行相加</li><li>value (Number, optional) – 标量，对 tensor1 ./ tensor2 进行相乘</li><li>tensor1 (Tensor) – 张量，作为被除数(分子)</li><li>tensor2 (Tensor) –张量，作为除数(分母)</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; t = torch.randn(2, 3)&gt;&gt;&gt; t1 = torch.randn(1, 6)&gt;&gt;&gt; t2 = torch.randn(6, 1)&gt;&gt;&gt; torch.addcdiv(t, 0.1, t1, t2) 0.0122 -0.0188 -0.2354 0.7396 -1.5721  1.2878[torch.FloatTensor of size 2x3]</code></pre><h3 id="torch-addcmul"><a href="#torch-addcmul" class="headerlink" title="torch.addcmul"></a>torch.addcmul</h3><pre><code>torch.addcmul(tensor, value=1, tensor1, tensor2, out=None) → Tensor</code></pre><p>用<code>tensor2</code>对<code>tensor1</code>逐元素相乘，并对结果乘以标量值<code>value</code>然后加到<code>tensor</code>。 张量的形状不需要匹配，但元素数量必须一致。 如果输入是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。</p><p>参数：</p><ul><li>tensor (Tensor) – 张量，对tensor1 ./ tensor 进行相加</li><li>value (Number, optional) – 标量，对 tensor1 . tensor2 进行相乘</li><li>tensor1 (Tensor) – 张量，作为乘子1</li><li>tensor2 (Tensor) –张量，作为乘子2</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; t = torch.randn(2, 3)&gt;&gt;&gt; t1 = torch.randn(1, 6)&gt;&gt;&gt; t2 = torch.randn(6, 1)&gt;&gt;&gt; torch.addcmul(t, 0.1, t1, t2) 0.0122 -0.0188 -0.2354 0.7396 -1.5721  1.2878[torch.FloatTensor of size 2x3]</code></pre><h3 id="torch-asin"><a href="#torch-asin" class="headerlink" title="torch.asin"></a>torch.asin</h3><pre><code>torch.asin(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的反正弦函数</p><p>参数：</p><ul><li>tensor (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.asin(a)-0.6900 0.2752 0.4633    nan[torch.FloatTensor of size 4]</code></pre><h3 id="torch-atan"><a href="#torch-atan" class="headerlink" title="torch.atan"></a>torch.atan</h3><pre><code>torch.atan(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的反正切函数</p><p>参数：</p><ul><li>tensor (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.atan(a)-0.5669 0.2653 0.4203 0.9196[torch.FloatTensor of size 4]</code></pre><h3 id="torch-atan2"><a href="#torch-atan2" class="headerlink" title="torch.atan2"></a>torch.atan2</h3><pre><code>torch.atan2(input1, input2, out=None) → Tensor</code></pre><p>返回一个新张量，包含两个输入张量<code>input1</code>和<code>input2</code>的反正切函数</p><p>参数：</p><ul><li>input1 (Tensor) – 第一个输入张量</li><li>input2 (Tensor) – 第二个输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.atan2(a, torch.randn(4))-2.4167 2.9755 0.9363 1.6613[torch.FloatTensor of size 4]</code></pre><h3 id="torch-ceil"><a href="#torch-ceil" class="headerlink" title="torch.ceil"></a>torch.ceil</h3><pre><code>torch.ceil(input, out=None) → Tensor</code></pre><p>天井函数，对输入<code>input</code>张量每个元素向上取整, 即取不小于每个元素的最小整数，并返回结果到输出。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.ceil(a) 2 1-0-0[torch.FloatTensor of size 4]</code></pre><h3 id="torch-clamp"><a href="#torch-clamp" class="headerlink" title="torch.clamp"></a>torch.clamp</h3><pre><code>torch.clamp(input, min, max, out=None) → Tensor</code></pre><p>操作定义如下：</p><pre><code>      | min, if x_i &lt; miny_i = | x_i, if min &lt;= x_i &lt;= max      | max, if x_i &gt; max</code></pre><p>如果输入是FloatTensor or DoubleTensor类型，则参数<code>min</code> <code>max</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>min</code>， <code>max</code>取整数、实数皆可。】</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>min (Number) – 限制范围下限</li><li>max (Number) – 限制范围上限</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.clamp(a, min=-0.5, max=0.5) 0.5000 0.3912-0.5000-0.5000[torch.FloatTensor of size 4]</code></pre><pre><code>torch.clamp(input, *, min, out=None) → Tensor</code></pre><p>将输入<code>input</code>张量每个元素的限制到不小于<code>min</code> ，并返回结果到一个新张量。</p><p>如果输入是FloatTensor or DoubleTensor类型，则参数 <code>min</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>min</code>取整数、实数皆可。】</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>value (Number) – 限制范围下限</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.clamp(a, min=0.5) 1.3869 0.5000 0.5000 0.5000[torch.FloatTensor of size 4]</code></pre><pre><code>torch.clamp(input, *, max, out=None) → Tensor</code></pre><p>将输入<code>input</code>张量每个元素的限制到不大于<code>max</code> ，并返回结果到一个新张量。</p><p>如果输入是FloatTensor or DoubleTensor类型，则参数 <code>max</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>max</code>取整数、实数皆可。】</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>value (Number) – 限制范围上限</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.clamp(a, max=0.5) 0.5000 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]</code></pre><h3 id="torch-cos"><a href="#torch-cos" class="headerlink" title="torch.cos"></a>torch.cos</h3><pre><code>torch.cos(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的余弦。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.cos(a) 0.8041 0.9633 0.9018 0.2557[torch.FloatTensor of size 4]</code></pre><h3 id="torch-cosh"><a href="#torch-cosh" class="headerlink" title="torch.cosh"></a>torch.cosh</h3><pre><code>torch.cosh(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的双曲余弦。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.cosh(a) 1.2095 1.0372 1.1015 1.9917[torch.FloatTensor of size 4]</code></pre><h3 id="torch-div"><a href="#torch-div" class="headerlink" title="torch.div()"></a>torch.div()</h3><pre><code>torch.div(input, value, out=None)</code></pre><p>如果输入是FloatTensor or DoubleTensor类型，则参数 <code>value</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>value</code>取整数、实数皆可。】</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>value (Number) – 除数</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(5)&gt;&gt;&gt; a-0.6147-1.1237-0.1604-0.6853 0.1063[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.div(a, 0.5)-1.2294-2.2474-0.3208-1.3706 0.2126[torch.FloatTensor of size 5]</code></pre><pre><code>torch.div(input, other, out=None)</code></pre><p>两张量形状不须匹配，但元素数须一致。</p><p>注意：当形状不匹配时，<code>input</code>的形状作为输出张量的形状。</p><p>参数：</p><ul><li>input (Tensor) – 张量(分子)</li><li>other (Tensor) – 张量(分母)</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4,4)&gt;&gt;&gt; a-0.1810  0.4017  0.2863 -0.1013 0.6183  2.0696  0.9012 -1.5933 0.5679  0.4743 -0.0117 -0.1266-0.1213  0.9629  0.2682  1.5968[torch.FloatTensor of size 4x4]&gt;&gt;&gt; b = torch.randn(8, 2)&gt;&gt;&gt; b 0.8774  0.7650 0.8866  1.4805-0.6490  1.1172 1.4259 -0.8146 1.4633 -0.1228 0.4643 -0.6029 0.3492  1.5270 1.6103 -0.6291[torch.FloatTensor of size 8x2]&gt;&gt;&gt; torch.div(a, b)-0.2062  0.5251  0.3229 -0.0684-0.9528  1.8525  0.6320  1.9559 0.3881 -3.8625 -0.0253  0.2099-0.3473  0.6306  0.1666 -2.5381[torch.FloatTensor of size 4x4]</code></pre><h3 id="torch-exp"><a href="#torch-exp" class="headerlink" title="torch.exp"></a>torch.exp</h3><pre><code>torch.exp(tensor, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的指数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><pre><code>&gt;&gt;&gt; torch.exp(torch.Tensor([0, math.log(2)]))torch.FloatTensor([1, 2])</code></pre><h3 id="torch-floor"><a href="#torch-floor" class="headerlink" title="torch.floor"></a>torch.floor</h3><pre><code>torch.floor(input, out=None) → Tensor</code></pre><p>床函数: 返回一个新张量，包含输入<code>input</code>张量每个元素的floor，即不小于元素的最大整数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.floor(a) 1 0-1-1[torch.FloatTensor of size 4]</code></pre><h3 id="torch-fmod"><a href="#torch-fmod" class="headerlink" title="torch.fmod"></a>torch.fmod</h3><pre><code>torch.fmod(input, divisor, out=None) → Tensor</code></pre><p>计算除法余数。 除数与被除数可能同时含有整数和浮点数。此时，余数的正负与被除数相同。</p><p>参数： - input (Tensor) – 被除数 - divisor (Tensor or float) – 除数，一个数或与被除数相同类型的张量 - out (Tensor, optional) – 输出张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.fmod(torch.Tensor([-3, -2, -1, 1, 2, 3]), 2)torch.FloatTensor([-1, -0, -1, 1, 0, 1])&gt;&gt;&gt; torch.fmod(torch.Tensor([1, 2, 3, 4, 5]), 1.5)torch.FloatTensor([1.0, 0.5, 0.0, 1.0, 0.5])</code></pre><p>参考: <a href="http://pytorch.org/docs/torch.html#torch.remainder" target="_blank" rel="noopener"><code>torch.remainder()</code></a>, 计算逐元素余数， 相当于python 中的 % 操作符。</p><h3 id="torch-frac"><a href="#torch-frac" class="headerlink" title="torch.frac"></a>torch.frac</h3><pre><code>torch.frac(tensor, out=None) → Tensor</code></pre><p>返回每个元素的分数部分。</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.frac(torch.Tensor([1, 2.5, -3.2])torch.FloatTensor([0, 0.5, -0.2])</code></pre><h3 id="torch-lerp"><a href="#torch-lerp" class="headerlink" title="torch.lerp"></a>torch.lerp</h3><pre><code>torch.lerp(start, end, weight, out=None)</code></pre><p>参数：</p><ul><li>start (Tensor) – 起始点张量</li><li>end (Tensor) – 终止点张量</li><li>weight (float) – 插值公式的weight</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; start = torch.arange(1, 5)&gt;&gt;&gt; end = torch.Tensor(4).fill_(10)&gt;&gt;&gt; start 1 2 3 4[torch.FloatTensor of size 4]&gt;&gt;&gt; end 10 10 10 10[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.lerp(start, end, 0.5) 5.5000 6.0000 6.5000 7.0000[torch.FloatTensor of size 4]</code></pre><h3 id="torch-log"><a href="#torch-log" class="headerlink" title="torch.log"></a>torch.log</h3><pre><code>torch.log(input, out=None) → Tensor</code></pre><p>计算<code>input</code> 的自然对数</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(5)&gt;&gt;&gt; a-0.4183 0.3722-0.3091 0.4149 0.5857[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.log(a)    nan-0.9883    nan-0.8797-0.5349[torch.FloatTensor of size 5]</code></pre><h3 id="torch-log1p"><a href="#torch-log1p" class="headerlink" title="torch.log1p"></a>torch.log1p</h3><pre><code>torch.log1p(input, out=None) → Tensor</code></pre><p>注意：对值比较小的输入，此函数比<code>torch.log()</code>更准确。</p><p>如果输入是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(5)&gt;&gt;&gt; a-0.4183 0.3722-0.3091 0.4149 0.5857[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.log1p(a)-0.5418 0.3164-0.3697 0.3471 0.4611[torch.FloatTensor of size 5]</code></pre><h3 id="torch-mul"><a href="#torch-mul" class="headerlink" title="torch.mul"></a>torch.mul</h3><pre><code>torch.mul(input, value, out=None)</code></pre><p>如果输入是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>value</code>取整数、实数皆可。】</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>value (Number) – 乘到每个元素的数</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(3)&gt;&gt;&gt; a-0.9374-0.5254-0.6069[torch.FloatTensor of size 3]&gt;&gt;&gt; torch.mul(a, 100)-93.7411-52.5374-60.6908[torch.FloatTensor of size 3]</code></pre><pre><code>torch.mul(input, other, out=None)</code></pre><p>两计算张量形状不须匹配，但总元素数须一致。 <strong>注意</strong>：当形状不匹配时，<code>input</code>的形状作为输入张量的形状。</p><p>参数：</p><ul><li>input (Tensor) – 第一个相乘张量</li><li>other (Tensor) – 第二个相乘张量</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4,4)&gt;&gt;&gt; a-0.7280  0.0598 -1.4327 -0.5825-0.1427 -0.0690  0.0821 -0.3270-0.9241  0.5110  0.4070 -1.1188-0.8308  0.7426 -0.6240 -1.1582[torch.FloatTensor of size 4x4]&gt;&gt;&gt; b = torch.randn(2, 8)&gt;&gt;&gt; b 0.0430 -1.0775  0.6015  1.1647 -0.6549  0.0308 -0.1670  1.0742-1.2593  0.0292 -0.0849  0.4530  1.2404 -0.4659 -0.1840  0.5974[torch.FloatTensor of size 2x8]&gt;&gt;&gt; torch.mul(a, b)-0.0313 -0.0645 -0.8618 -0.6784 0.0934 -0.0021 -0.0137 -0.3513 1.1638  0.0149 -0.0346 -0.5068-1.0304 -0.3460  0.1148 -0.6919[torch.FloatTensor of size 4x4]</code></pre><h3 id="torch-neg"><a href="#torch-neg" class="headerlink" title="torch.neg"></a>torch.neg</h3><pre><code>torch.neg(input, out=None) → Tensor</code></pre><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(5)&gt;&gt;&gt; a-0.4430 1.1690-0.8836-0.4565 0.2968[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.neg(a) 0.4430-1.1690 0.8836 0.4565-0.2968[torch.FloatTensor of size 5]</code></pre><h3 id="torch-pow"><a href="#torch-pow" class="headerlink" title="torch.pow"></a>torch.pow</h3><pre><code>torch.pow(input, exponent, out=None)</code></pre><p>对输入<code>input</code>的按元素求<code>exponent</code>次幂值，并返回结果张量。 幂值<code>exponent</code> 可以为单一 <code>float</code> 数或者与<code>input</code>相同元素数的张量。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>exponent (float or Tensor) – 幂值</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.5274-0.8232-2.1128 1.7558[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.pow(a, 2) 0.2781 0.6776 4.4640 3.0829[torch.FloatTensor of size 4]&gt;&gt;&gt; exp = torch.arange(1, 5)&gt;&gt;&gt; a = torch.arange(1, 5)&gt;&gt;&gt; a 1 2 3 4[torch.FloatTensor of size 4]&gt;&gt;&gt; exp 1 2 3 4[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.pow(a, exp)   1   4  27 256[torch.FloatTensor of size 4]</code></pre><pre><code>torch.pow(base, input, out=None)</code></pre><p><code>base</code> 为标量浮点值,<code>input</code>为张量， 返回的输出张量 <code>out</code> 与输入张量相同形状。</p><p>参数：</p><ul><li>base (float) – 标量值，指数的底</li><li>input ( Tensor) – 幂值</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; exp = torch.arange(1, 5)&gt;&gt;&gt; base = 2&gt;&gt;&gt; torch.pow(base, exp)  2  4  8 16[torch.FloatTensor of size 4]</code></pre><h3 id="torch-reciprocal"><a href="#torch-reciprocal" class="headerlink" title="torch.reciprocal"></a>torch.reciprocal</h3><pre><code>torch.reciprocal(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的倒数，即 1.0/x。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.reciprocal(a) 0.7210 2.5565-1.1583-1.8289[torch.FloatTensor of size 4]</code></pre><h3 id="torch-remainder"><a href="#torch-remainder" class="headerlink" title="torch.remainder"></a>torch.remainder</h3><pre><code>torch.remainder(input, divisor, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的除法余数。 除数与被除数可能同时包含整数或浮点数。余数与除数有相同的符号。</p><p>参数：</p><ul><li>input (Tensor) – 被除数</li><li>divisor (Tensor or float) – 除数，一个数或者与除数相同大小的张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.remainder(torch.Tensor([-3, -2, -1, 1, 2, 3]), 2)torch.FloatTensor([1, 0, 1, 1, 0, 1])&gt;&gt;&gt; torch.remainder(torch.Tensor([1, 2, 3, 4, 5]), 1.5)torch.FloatTensor([1.0, 0.5, 0.0, 1.0, 0.5])</code></pre><p><strong>参考</strong>: 函数<code>torch.fmod()</code> 同样可以计算除法余数，相当于 C 的 库函数<code>fmod()</code></p><h3 id="torch-round"><a href="#torch-round" class="headerlink" title="torch.round"></a>torch.round</h3><pre><code>torch.round(input, out=None) → Tensor</code></pre><p>返回一个新张量，将输入<code>input</code>张量每个元素舍入到最近的整数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.2290 1.3409-0.5662-0.0899[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.round(a) 1 1-1-0[torch.FloatTensor of size 4]</code></pre><h3 id="torch-rsqrt"><a href="#torch-rsqrt" class="headerlink" title="torch.rsqrt"></a>torch.rsqrt</h3><pre><code>torch.rsqrt(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的平方根倒数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.2290 1.3409-0.5662-0.0899[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.rsqrt(a) 0.9020 0.8636    nan    nan[torch.FloatTensor of size 4]</code></pre><h3 id="torch-sigmoid"><a href="#torch-sigmoid" class="headerlink" title="torch.sigmoid"></a>torch.sigmoid</h3><pre><code>torch.sigmoid(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的sigmoid值。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.4972 1.3512 0.1056-0.2650[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.sigmoid(a) 0.3782 0.7943 0.5264 0.4341[torch.FloatTensor of size 4]</code></pre><h3 id="torch-sign"><a href="#torch-sign" class="headerlink" title="torch.sign"></a>torch.sign</h3><pre><code>torch.sign(input, out=None) → Tensor</code></pre><p>符号函数：返回一个新张量，包含输入<code>input</code>张量每个元素的正负。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.sign(a)-1 1 1 1[torch.FloatTensor of size 4]</code></pre><h3 id="torch-sin"><a href="#torch-sin" class="headerlink" title="torch.sin"></a>torch.sin</h3><pre><code>torch.sin(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的正弦。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.sin(a)-0.5944 0.2684 0.4322 0.9667[torch.FloatTensor of size 4]</code></pre><h3 id="torch-sinh"><a href="#torch-sinh" class="headerlink" title="torch.sinh"></a>torch.sinh</h3><pre><code>torch.sinh(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的双曲正弦。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.sinh(a)-0.6804 0.2751 0.4619 1.7225[torch.FloatTensor of size 4]</code></pre><h3 id="torch-sqrt"><a href="#torch-sqrt" class="headerlink" title="torch.sqrt"></a>torch.sqrt</h3><pre><code>torch.sqrt(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的平方根。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.2290 1.3409-0.5662-0.0899[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.sqrt(a) 1.1086 1.1580    nan    nan[torch.FloatTensor of size 4]</code></pre><h3 id="torch-tan"><a href="#torch-tan" class="headerlink" title="torch.tan"></a>torch.tan</h3><pre><code>torch.tan(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的正切。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.tan(a)-0.7392 0.2786 0.4792 3.7801[torch.FloatTensor of size 4]</code></pre><h3 id="torch-tanh"><a href="#torch-tanh" class="headerlink" title="torch.tanh"></a>torch.tanh</h3><pre><code>torch.tanh(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的双曲正切。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.tanh(a)-0.5625 0.2653 0.4193 0.8648[torch.FloatTensor of size 4]</code></pre><h3 id="torch-trunc"><a href="#torch-trunc" class="headerlink" title="torch.trunc"></a>torch.trunc</h3><pre><code>torch.trunc(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的截断值(标量x的截断值是最接近其的整数，其比x更接近零。简而言之，有符号数的小数部分被舍弃)。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.4972 1.3512 0.1056-0.2650[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.trunc(a)-0 1 0-0[torch.FloatTensor of size 4]</code></pre><h2 id="Reduction-Ops"><a href="#Reduction-Ops" class="headerlink" title="Reduction Ops"></a>Reduction Ops</h2><h3 id="torch-cumprod"><a href="#torch-cumprod" class="headerlink" title="torch.cumprod"></a>torch.cumprod</h3><pre><code>torch.cumprod(input, dim, out=None) → Tensor</code></pre><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 累积积操作的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(10)&gt;&gt;&gt; a 1.1148 1.8423 1.4143-0.4403 1.2859-1.2514-0.4748 1.1735-1.6332-0.4272[torch.FloatTensor of size 10]&gt;&gt;&gt; torch.cumprod(a, dim=0) 1.1148 2.0537 2.9045-1.2788-1.6444 2.0578-0.9770-1.1466 1.8726-0.8000[torch.FloatTensor of size 10]&gt;&gt;&gt; a[5] = 0.0&gt;&gt;&gt; torch.cumprod(a, dim=0) 1.1148 2.0537 2.9045-1.2788-1.6444-0.0000 0.0000 0.0000-0.0000 0.0000[torch.FloatTensor of size 10]</code></pre><h3 id="torch-cumsum"><a href="#torch-cumsum" class="headerlink" title="torch.cumsum"></a>torch.cumsum</h3><pre><code>torch.cumsum(input, dim, out=None) → Tensor</code></pre><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 累积和操作的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(10)&gt;&gt;&gt; a-0.6039-0.2214-0.3705-0.0169 1.3415-0.1230 0.9719 0.6081-0.1286 1.0947[torch.FloatTensor of size 10]&gt;&gt;&gt; torch.cumsum(a, dim=0)-0.6039-0.8253-1.1958-1.2127 0.1288 0.0058 0.9777 1.5858 1.4572 2.5519[torch.FloatTensor of size 10]</code></pre><hr><h3 id="torch-dist"><a href="#torch-dist" class="headerlink" title="torch.dist"></a>torch.dist</h3><pre><code>torch.dist(input, other, p=2, out=None) → Tensor</code></pre><p>返回 (<code>input</code> - <code>other</code>) 的 <code>p</code>范数 。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>other (Tensor) – 右侧输入张量</li><li>p (float, optional) – 所计算的范数</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.randn(4)&gt;&gt;&gt; x 0.2505-0.4571-0.3733 0.7807[torch.FloatTensor of size 4]&gt;&gt;&gt; y = torch.randn(4)&gt;&gt;&gt; y 0.7782-0.5185 1.4106-2.4063[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.dist(x, y, 3.5)3.302832063224223&gt;&gt;&gt; torch.dist(x, y, 3)3.3677282206393286&gt;&gt;&gt; torch.dist(x, y, 0)inf&gt;&gt;&gt; torch.dist(x, y, 1)5.560028076171875</code></pre><h3 id="torch-mean"><a href="#torch-mean" class="headerlink" title="torch.mean"></a>torch.mean</h3><pre><code>torch.mean(input) → float</code></pre><p>返回输入张量所有元素的均值。</p><p>参数： input (Tensor) – 输入张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a-0.2946 -0.9143  2.1809[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.mean(a)0.32398951053619385</code></pre><pre><code>torch.mean(input, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维度<code>dim</code>上每行的均值。</p><p>输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – the dimension to reduce</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 4)&gt;&gt;&gt; a-1.2738 -0.3058  0.1230 -1.9615 0.8771 -0.5430 -0.9233  0.9879 1.4107  0.0317 -0.6823  0.2255-1.3854  0.4953 -0.2160  0.2435[torch.FloatTensor of size 4x4]&gt;&gt;&gt; torch.mean(a, 1)-0.8545 0.0997 0.2464-0.2157[torch.FloatTensor of size 4x1]</code></pre><h3 id="torch-median"><a href="#torch-median" class="headerlink" title="torch.median"></a>torch.median</h3><pre><code>torch.median(input, dim=-1, values=None, indices=None) -&gt; (Tensor, LongTensor)</code></pre><p>返回输入张量给定维度每行的中位数，同时返回一个包含中位数的索引的<code>LongTensor</code>。</p><p><code>dim</code>值默认为输入张量的最后一维。 输出形状与输入相同，除了给定维度上为1.</p><p><em>注意</em>: 这个函数还没有在<code>torch.cuda.Tensor</code>中定义</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 缩减的维度</li><li>values (Tensor, optional) – 结果张量</li><li>indices (Tensor, optional) – 返回的索引结果张量</li></ul><pre><code>&gt;&gt;&gt; a -0.6891 -0.6662 0.2697  0.7412 0.5254 -0.7402 0.5528 -0.2399[torch.FloatTensor of size 4x2]&gt;&gt;&gt; a = torch.randn(4, 5)&gt;&gt;&gt; a 0.4056 -0.3372  1.0973 -2.4884  0.4334 2.1336  0.3841  0.1404 -0.1821 -0.7646-0.2403  1.3975 -2.0068  0.1298  0.0212-1.5371 -0.7257 -0.4871 -0.2359 -1.1724[torch.FloatTensor of size 4x5]&gt;&gt;&gt; torch.median(a, 1)( 0.4056 0.1404 0.0212-0.7257[torch.FloatTensor of size 4x1], 0 2 4 1[torch.LongTensor of size 4x1])</code></pre><h3 id="torch-mode"><a href="#torch-mode" class="headerlink" title="torch.mode"></a>torch.mode</h3><pre><code>torch.mode(input, dim=-1, values=None, indices=None) -&gt; (Tensor, LongTensor)</code></pre><p>返回给定维<code>dim</code>上，每行的众数值。 同时返回一个<code>LongTensor</code>，包含众数职的索引。<code>dim</code>值默认为输入张量的最后一维。</p><p>输出形状与输入相同，除了给定维度上为1.</p><p><em>注意</em>: 这个函数还没有在<code>torch.cuda.Tensor</code>中定义</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 缩减的维度</li><li>values (Tensor, optional) – 结果张量</li><li>indices (Tensor, optional) – 返回的索引张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a -0.6891 -0.6662 0.2697  0.7412 0.5254 -0.7402 0.5528 -0.2399[torch.FloatTensor of size 4x2]&gt;&gt;&gt; a = torch.randn(4, 5)&gt;&gt;&gt; a 0.4056 -0.3372  1.0973 -2.4884  0.4334 2.1336  0.3841  0.1404 -0.1821 -0.7646-0.2403  1.3975 -2.0068  0.1298  0.0212-1.5371 -0.7257 -0.4871 -0.2359 -1.1724[torch.FloatTensor of size 4x5]&gt;&gt;&gt; torch.mode(a, 1)(-2.4884-0.7646-2.0068-1.5371[torch.FloatTensor of size 4x1], 3 4 2 0[torch.LongTensor of size 4x1])</code></pre><h3 id="torch-norm"><a href="#torch-norm" class="headerlink" title="torch.norm"></a>torch.norm</h3><pre><code>torch.norm(input, p=2) → float</code></pre><p>返回输入张量<code>input</code> 的p 范数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>p (float,optional) – 范数计算中的幂指数值</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a-0.4376 -0.5328  0.9547[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.norm(a, 3)1.0338925067372466</code></pre><pre><code>torch.norm(input, p, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维<code>dim</code> 上每行的p 范数。 输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>p (float) – 范数计算中的幂指数值</li><li>dim (int) – 缩减的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 2)&gt;&gt;&gt; a-0.6891 -0.6662 0.2697  0.7412 0.5254 -0.7402 0.5528 -0.2399[torch.FloatTensor of size 4x2]&gt;&gt;&gt; torch.norm(a, 2, 1) 0.9585 0.7888 0.9077 0.6026[torch.FloatTensor of size 4x1]&gt;&gt;&gt; torch.norm(a, 0, 1) 2 2 2 2[torch.FloatTensor of size 4x1]</code></pre><h3 id="torch-prod"><a href="#torch-prod" class="headerlink" title="torch.prod"></a>torch.prod</h3><pre><code>torch.prod(input) → float</code></pre><p>返回输入张量<code>input</code> 所有元素的积。</p><p>参数：input (Tensor) – 输入张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a 0.6170  0.3546  0.0253[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.prod(a)0.005537458061418483</code></pre><pre><code>torch.prod(input, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维度上每行的积。 输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 缩减的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 2)&gt;&gt;&gt; a 0.1598 -0.6884-0.1831 -0.4412-0.9925 -0.6244-0.2416 -0.8080[torch.FloatTensor of size 4x2]&gt;&gt;&gt; torch.prod(a, 1)-0.1100 0.0808 0.6197 0.1952[torch.FloatTensor of size 4x1]</code></pre><h3 id="torch-std"><a href="#torch-std" class="headerlink" title="torch.std"></a>torch.std</h3><pre><code>torch.std(input) → float</code></pre><p>返回输入张量<code>input</code> 所有元素的标准差。</p><p>参数：- input (Tensor) – 输入张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a-1.3063  1.4182 -0.3061[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.std(a)1.3782334731508061</code></pre><pre><code>torch.std(input, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维度上每行的标准差。 输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 缩减的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 4)&gt;&gt;&gt; a 0.1889 -2.4856  0.0043  1.8169-0.7701 -0.4682 -2.2410  0.4098 0.1919 -1.1856 -1.0361  0.9085 0.0173  1.0662  0.2143 -0.5576[torch.FloatTensor of size 4x4]&gt;&gt;&gt; torch.std(a, dim=1) 1.7756 1.1025 1.0045 0.6725[torch.FloatTensor of size 4x1]</code></pre><h3 id="torch-sum"><a href="#torch-sum" class="headerlink" title="torch.sum"></a>torch.sum</h3><pre><code>torch.sum(input) → float</code></pre><p>返回输入张量<code>input</code> 所有元素的和。</p><p>输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a 0.6170  0.3546  0.0253[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.sum(a)0.9969287421554327</code></pre><pre><code>torch.sum(input, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维度上每行的和。 输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 缩减的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 4)&gt;&gt;&gt; a-0.4640  0.0609  0.1122  0.4784-1.3063  1.6443  0.4714 -0.7396-1.3561 -0.1959  1.0609 -1.9855 2.6833  0.5746 -0.5709 -0.4430[torch.FloatTensor of size 4x4]&gt;&gt;&gt; torch.sum(a, 1) 0.1874 0.0698-2.4767 2.2440[torch.FloatTensor of size 4x1]</code></pre><h3 id="torch-var"><a href="#torch-var" class="headerlink" title="torch.var"></a>torch.var</h3><pre><code>torch.var(input) → float</code></pre><p>返回输入张量所有元素的方差</p><p>输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a-1.3063  1.4182 -0.3061[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.var(a)1.899527506513334</code></pre><pre><code>torch.var(input, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维度上每行的方差。 输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – the dimension to reduce</li><li>out (Tensor, optional) – 结果张量 例子：</li></ul><pre><code>&gt;&gt;&gt; a = torch.randn(4, 4)&gt;&gt;&gt; a-1.2738 -0.3058  0.1230 -1.9615 0.8771 -0.5430 -0.9233  0.9879 1.4107  0.0317 -0.6823  0.2255-1.3854  0.4953 -0.2160  0.2435[torch.FloatTensor of size 4x4]&gt;&gt;&gt; torch.var(a, 1) 0.8859 0.9509 0.7548 0.6949[torch.FloatTensor of size 4x1]</code></pre><h2 id="比较操作-Comparison-Ops"><a href="#比较操作-Comparison-Ops" class="headerlink" title="比较操作 Comparison Ops"></a>比较操作 Comparison Ops</h2><h3 id="torch-eq"><a href="#torch-eq" class="headerlink" title="torch.eq"></a>torch.eq</h3><pre><code>torch.eq(input, other, out=None) → Tensor</code></pre><p>比较元素相等性。第二个参数可为一个数或与第一个参数同类型形状的张量。</p><p>参数：</p><ul><li>input (Tensor) – 待比较张量</li><li>other (Tensor or float) – 比较张量或数</li><li>out (Tensor, optional) – 输出张量，须为 ByteTensor类型 or 与<code>input</code>同类型</li></ul><p>返回值： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果(相等为1，不等为0 )</p><p>返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.eq(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]]))1  00  1[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-equal"><a href="#torch-equal" class="headerlink" title="torch.equal"></a>torch.equal</h3><pre><code>torch.equal(tensor1, tensor2) → bool</code></pre><p>如果两个张量有相同的形状和元素值，则返回<code>True</code> ，否则 <code>False</code>。</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.equal(torch.Tensor([1, 2]), torch.Tensor([1, 2]))True</code></pre><h3 id="torch-ge"><a href="#torch-ge" class="headerlink" title="torch.ge"></a>torch.ge</h3><pre><code>torch.ge(input, other, out=None) → Tensor</code></pre><p>如果两个张量有相同的形状和元素值，则返回<code>True</code> ，否则 <code>False</code>。 第二个参数可以为一个数或与第一个参数相同形状和类型的张量</p><p>参数:</p><ul><li>input (Tensor) – 待对比的张量</li><li>other (Tensor or float) – 对比的张量或<code>float</code>值</li><li>out (Tensor, optional) – 输出张量。必须为<code>ByteTensor</code>或者与第一个参数<code>tensor</code>相同类型。</li></ul><p>返回值： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果(是否 input &gt;= other )。 返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.ge(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]])) 1  1 0  1[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-gt"><a href="#torch-gt" class="headerlink" title="torch.gt"></a>torch.gt</h3><pre><code>torch.gt(input, other, out=None) → Tensor</code></pre><p>参数:</p><ul><li>input (Tensor) – 要对比的张量</li><li>other (Tensor or float) – 要对比的张量或<code>float</code>值</li><li>out (Tensor, optional) – 输出张量。必须为<code>ByteTensor</code>或者与第一个参数<code>tensor</code>相同类型。</li></ul><p>返回值： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果(是否 input &gt;= other )。 返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.gt(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]])) 0  1 0  0[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-kthvalue"><a href="#torch-kthvalue" class="headerlink" title="torch.kthvalue"></a>torch.kthvalue</h3><pre><code>torch.kthvalue(input, k, dim=None, out=None) -&gt; (Tensor, LongTensor)</code></pre><p>取输入张量<code>input</code>指定维上第k 个最小值。如果不指定<code>dim</code>，则默认为<code>input</code>的最后一维。</p><p>返回一个元组 <em>(values,indices)</em>，其中<code>indices</code>是原始输入张量<code>input</code>中沿<code>dim</code>维的第 <code>k</code> 个最小值下标。</p><p>参数:</p><ul><li>input (Tensor) – 要对比的张量</li><li>k (int) – 第 <code>k</code> 个最小值</li><li>dim (int, optional) – 沿着此维进行排序</li><li>out (tuple, optional) – 输出元组 (Tensor, LongTensor) 可选地给定作为 输出 buffers</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.arange(1, 6)&gt;&gt;&gt; x 1 2 3 4 5[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.kthvalue(x, 4)( 4[torch.FloatTensor of size 1], 3[torch.LongTensor of size 1])</code></pre><h3 id="torch-le"><a href="#torch-le" class="headerlink" title="torch.le"></a>torch.le</h3><pre><code>torch.le(input, other, out=None) → Tensor</code></pre><p>参数:</p><ul><li>input (Tensor) – 要对比的张量</li><li>other (Tensor or float ) – 对比的张量或<code>float</code>值</li><li>out (Tensor, optional) – 输出张量。必须为<code>ByteTensor</code>或者与第一个参数<code>tensor</code>相同类型。</li></ul><p>返回值： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果(是否 input &gt;= other )。 返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.le(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]])) 1  0 1  1[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-lt"><a href="#torch-lt" class="headerlink" title="torch.lt"></a>torch.lt</h3><pre><code>torch.lt(input, other, out=None) → Tensor</code></pre><p>第二个参数可以为一个数或与第一个参数相同形状和类型的张量</p><p>参数:</p><ul><li>input (Tensor) – 要对比的张量</li><li>other (Tensor or float ) – 对比的张量或<code>float</code>值</li><li>out (Tensor, optional) – 输出张量。必须为<code>ByteTensor</code>或者与第一个参数<code>tensor</code>相同类型。</li></ul><p>input： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果(是否 tensor &gt;= other )。 返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.lt(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]])) 0  0 1  0[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-max"><a href="#torch-max" class="headerlink" title="torch.max"></a>torch.max</h3><pre><code>torch.max()</code></pre><p>返回输入张量所有元素的最大值。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a 0.4729 -0.2266 -0.2085[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.max(a)0.4729</code></pre><pre><code>torch.max(input, dim, max=None, max_indices=None) -&gt; (Tensor, LongTensor)</code></pre><p>返回输入张量给定维度上每行的最大值，并同时返回每个最大值的位置索引。</p><p>输出形状中，将<code>dim</code>维设定为1，其它与输入形状保持一致。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 指定的维度</li><li>max (Tensor, optional) – 结果张量，包含给定维度上的最大值</li><li>max_indices (LongTensor, optional) – 结果张量，包含给定维度上每个最大值的位置索引</li></ul><p>例子：</p><pre><code>&gt;&gt; a = torch.randn(4, 4)&gt;&gt; a0.0692  0.3142  1.2513 -0.54280.9288  0.8552 -0.2073  0.64091.0695 -0.0101 -2.4507 -1.22300.7426 -0.7666  0.4862 -0.6628torch.FloatTensor of size 4x4]&gt;&gt;&gt; torch.max(a, 1)( 1.2513 0.9288 1.0695 0.7426[torch.FloatTensor of size 4x1], 2 0 0 0[torch.LongTensor of size 4x1])</code></pre><pre><code>torch.max(input, other, out=None) → Tensor</code></pre><p>输出形状中，将<code>dim</code>维设定为1，其它与输入形状保持一致。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>other (Tensor) – 输出张量</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; b = torch.randn(4)&gt;&gt;&gt; b 1.0067-0.8010 0.6258 0.3627[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.max(a, b) 1.3869 0.3912 0.6258 0.3627[torch.FloatTensor of size 4]</code></pre><h3 id="torch-min"><a href="#torch-min" class="headerlink" title="torch.min"></a>torch.min</h3><pre><code>torch.min(input) → float</code></pre><p>返回输入张量所有元素的最小值。</p><p>参数: input (Tensor) – 输入张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a 0.4729 -0.2266 -0.2085[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.min(a)-0.22663167119026184</code></pre><pre><code>torch.min(input, dim, min=None, min_indices=None) -&gt; (Tensor, LongTensor)</code></pre><p>返回输入张量给定维度上每行的最小值，并同时返回每个最小值的位置索引。</p><p>输出形状中，将<code>dim</code>维设定为1，其它与输入形状保持一致。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 指定的维度</li><li>min (Tensor, optional) – 结果张量，包含给定维度上的最小值</li><li>min_indices (LongTensor, optional) – 结果张量，包含给定维度上每个最小值的位置索引</li></ul><p>例子：</p><pre><code>&gt;&gt; a = torch.randn(4, 4)&gt;&gt; a0.0692  0.3142  1.2513 -0.54280.9288  0.8552 -0.2073  0.64091.0695 -0.0101 -2.4507 -1.22300.7426 -0.7666  0.4862 -0.6628torch.FloatTensor of size 4x4]&gt;&gt; torch.min(a, 1)0.54280.20732.45070.7666torch.FloatTensor of size 4x1]3221torch.LongTensor of size 4x1]</code></pre><pre><code>torch.min(input, other, out=None) → Tensor</code></pre><p>两张量形状不需匹配，但元素数须相同。</p><p>注意：当形状不匹配时，<code>input</code>的形状作为返回张量的形状。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>other (Tensor) – 第二个输入张量</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; b = torch.randn(4)&gt;&gt;&gt; b 1.0067-0.8010 0.6258 0.3627[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.min(a, b) 1.0067-0.8010-0.8634-0.5468[torch.FloatTensor of size 4]</code></pre><h3 id="torch-ne"><a href="#torch-ne" class="headerlink" title="torch.ne"></a>torch.ne</h3><pre><code>torch.ne(input, other, out=None) → Tensor</code></pre><p>参数:</p><ul><li>input (Tensor) – 待对比的张量</li><li>other (Tensor or float) – 对比的张量或<code>float</code>值</li><li>out (Tensor, optional) – 输出张量。必须为<code>ByteTensor</code>或者与<code>input</code>相同类型。</li></ul><p>返回值： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果 (如果 tensor != other 为<code>True</code> ，返回<code>1</code>)。</p><p>返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.ne(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]])) 0  1 1  0[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-sort"><a href="#torch-sort" class="headerlink" title="torch.sort"></a>torch.sort</h3><pre><code>torch.sort(input, dim=None, descending=False, out=None) -&gt; (Tensor, LongTensor)</code></pre><p>对输入张量<code>input</code>沿着指定维按升序排序。如果不给定<code>dim</code>，则默认为输入的最后一维。如果指定参数<code>descending</code>为<code>True</code>，则按降序排序</p><p>返回元组 (sorted_tensor, sorted_indices) ， <code>sorted_indices</code> 为原始输入中的下标。</p><p>参数:</p><ul><li>input (Tensor) – 要对比的张量</li><li>dim (int, optional) – 沿着此维排序</li><li>descending (bool, optional) – 布尔值，控制升降排序</li><li>out (tuple, optional) – 输出张量。必须为<code>ByteTensor</code>或者与第一个参数<code>tensor</code>相同类型。</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.randn(3, 4)&gt;&gt;&gt; sorted, indices = torch.sort(x)&gt;&gt;&gt; sorted-1.6747  0.0610  0.1190  1.4137-1.4782  0.7159  1.0341  1.3678-0.3324 -0.0782  0.3518  0.4763[torch.FloatTensor of size 3x4]&gt;&gt;&gt; indices 0  1  3  2 2  1  0  3 3  1  0  2[torch.LongTensor of size 3x4]&gt;&gt;&gt; sorted, indices = torch.sort(x, 0)&gt;&gt;&gt; sorted-1.6747 -0.0782 -1.4782 -0.3324 0.3518  0.0610  0.4763  0.1190 1.0341  0.7159  1.4137  1.3678[torch.FloatTensor of size 3x4]&gt;&gt;&gt; indices 0  2  1  2 2  0  2  0 1  1  0  1[torch.LongTensor of size 3x4]</code></pre><h3 id="torch-topk"><a href="#torch-topk" class="headerlink" title="torch.topk"></a>torch.topk</h3><pre><code>torch.topk(input, k, dim=None, largest=True, sorted=True, out=None) -&gt; (Tensor, LongTensor)</code></pre><p>沿给定<code>dim</code>维度返回输入张量<code>input</code>中 <code>k</code> 个最大值。 如果不指定<code>dim</code>，则默认为<code>input</code>的最后一维。 如果为<code>largest</code>为 <code>False</code> ，则返回最小的 <code>k</code> 个值。</p><p>返回一个元组 <em>(values,indices)</em>，其中<code>indices</code>是原始输入张量<code>input</code>中测元素下标。 如果设定布尔值<code>sorted</code> 为_True_，将会确保返回的 <code>k</code> 个值被排序。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>k (int) – “top-k”中的<code>k</code></li><li>dim (int, optional) – 排序的维</li><li>largest (bool, optional) – 布尔值，控制返回最大或最小值</li><li>sorted (bool, optional) – 布尔值，控制返回值是否排序</li><li>out (tuple, optional) – 可选输出张量 (Tensor, LongTensor) output buffers</li></ul><pre><code>&gt;&gt;&gt; x = torch.arange(1, 6)&gt;&gt;&gt; x 1 2 3 4 5[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.topk(x, 3)( 5 4 3[torch.FloatTensor of size 3], 4 3 2[torch.LongTensor of size 3])&gt;&gt;&gt; torch.topk(x, 3, 0, largest=False)( 1 2 3[torch.FloatTensor of size 3], 0 1 2[torch.LongTensor of size 3])</code></pre><h2 id="其它操作-Other-Operations"><a href="#其它操作-Other-Operations" class="headerlink" title="其它操作 Other Operations"></a>其它操作 Other Operations</h2><h3 id="torch-cross"><a href="#torch-cross" class="headerlink" title="torch.cross"></a>torch.cross</h3><pre><code>torch.cross(input, other, dim=-1, out=None) → Tensor</code></pre><p>返回沿着维度<code>dim</code>上，两个张量<code>input</code>和<code>other</code>的向量积（叉积）。 <code>input</code>和<code>other</code> 必须有相同的形状，且指定的<code>dim</code>维上size必须为<code>3</code>。</p><p>如果不指定<code>dim</code>，则默认为第一个尺度为<code>3</code>的维。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>other (Tensor) – 第二个输入张量</li><li>dim (int, optional) – 沿着此维进行叉积操作</li><li>out (Tensor,optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 3)&gt;&gt;&gt; a-0.6652 -1.0116 -0.6857 0.2286  0.4446 -0.5272 0.0476  0.2321  1.9991 0.6199  1.1924 -0.9397[torch.FloatTensor of size 4x3]&gt;&gt;&gt; b = torch.randn(4, 3)&gt;&gt;&gt; b-0.1042 -1.1156  0.1947 0.9947  0.1149  0.4701-1.0108  0.8319 -0.0750 0.9045 -1.3754  1.0976[torch.FloatTensor of size 4x3]&gt;&gt;&gt; torch.cross(a, b, dim=1)-0.9619  0.2009  0.6367 0.2696 -0.6318 -0.4160-1.6805 -2.0171  0.2741 0.0163 -1.5304 -1.9311[torch.FloatTensor of size 4x3]&gt;&gt;&gt; torch.cross(a, b)-0.9619  0.2009  0.6367 0.2696 -0.6318 -0.4160-1.6805 -2.0171  0.2741 0.0163 -1.5304 -1.9311[torch.FloatTensor of size 4x3]</code></pre><h3 id="torch-diag"><a href="#torch-diag" class="headerlink" title="torch.diag"></a>torch.diag</h3><pre><code>torch.diag(input, diagonal=0, out=None) → Tensor</code></pre><ul><li>如果输入是一个向量(1D 张量)，则返回一个以<code>input</code>为对角线元素的2D方阵</li><li>如果输入是一个矩阵(2D 张量)，则返回一个包含<code>input</code>对角线元素的1D张量</li></ul><p>参数<code>diagonal</code>指定对角线:</p><ul><li><code>diagonal</code> = 0, 主对角线</li><li><code>diagonal</code> &gt; 0, 主对角线之上</li><li><code>diagonal</code> &lt; 0, 主对角线之下</li></ul><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>diagonal (int, optional) – 指定对角线</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><ul><li>取得以<code>input</code>为对角线的方阵：</li></ul><pre><code>&gt;&gt;&gt; a = torch.randn(3)&gt;&gt;&gt; a 1.0480-2.3405-1.1138[torch.FloatTensor of size 3]&gt;&gt;&gt; torch.diag(a) 1.0480  0.0000  0.0000 0.0000 -2.3405  0.0000 0.0000  0.0000 -1.1138[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.diag(a, 1) 0.0000  1.0480  0.0000  0.0000 0.0000  0.0000 -2.3405  0.0000 0.0000  0.0000  0.0000 -1.1138 0.0000  0.0000  0.0000  0.0000[torch.FloatTensor of size 4x4]</code></pre><ul><li>取得给定矩阵第<code>k</code>个对角线:</li></ul><pre><code>&gt;&gt;&gt; a = torch.randn(3, 3)&gt;&gt;&gt; a-1.5328 -1.3210 -1.5204 0.8596  0.0471 -0.2239-0.6617  0.0146 -1.0817[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.diag(a, 0)-1.5328 0.0471-1.0817[torch.FloatTensor of size 3]&gt;&gt;&gt; torch.diag(a, 1)-1.3210-0.2239[torch.FloatTensor of size 2]</code></pre><h3 id="torch-histc"><a href="#torch-histc" class="headerlink" title="torch.histc"></a>torch.histc</h3><pre><code>torch.histc(input, bins=100, min=0, max=0, out=None) → Tensor</code></pre><p>计算输入张量的直方图。以<code>min</code>和<code>max</code>为range边界，将其均分成<code>bins</code>个直条，然后将排序好的数据划分到各个直条(bins)中。如果<code>min</code>和<code>max</code>都为0, 则利用数据中的最大最小值作为边界。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>bins (int) – 直方图 bins(直条)的个数(默认100个)</li><li>min (int) – range的下边界(包含)</li><li>max (int) – range的上边界(包含)</li><li>out (Tensor, optional) – 结果张量</li></ul><p>返回： 直方图 返回类型：张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.histc(torch.FloatTensor([1, 2, 1]), bins=4, min=0, max=3)FloatTensor([0, 2, 1, 0])</code></pre><h3 id="torch-renorm"><a href="#torch-renorm" class="headerlink" title="torch.renorm"></a>torch.renorm</h3><pre><code>torch.renorm(input, p, dim, maxnorm, out=None) → Tensor</code></pre><p>返回一个张量，包含规范化后的各个子张量，使得沿着<code>dim</code>维划分的各子张量的p范数小于<code>maxnorm</code>。</p><p><strong>注意</strong> 如果p范数的值小于<code>maxnorm</code>，则当前子张量不需要修改。</p><p><strong>注意</strong>: 更详细解释参考<a href="http://torch7.readthedocs.io/en/rtd/maths/" target="_blank" rel="noopener">torch7</a> 以及<a href="https://arxiv.org/pdf/1207.0580.pdf" target="_blank" rel="noopener">Hinton et al. 2012, p. 2</a></p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>p (float) – 范数的p</li><li>dim (int) – 沿着此维切片，得到张量子集</li><li>maxnorm (float) – 每个子张量的范数的最大值</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.ones(3, 3)&gt;&gt;&gt; x[1].fill_(2)&gt;&gt;&gt; x[2].fill_(3)&gt;&gt;&gt; x 1  1  1 2  2  2 3  3  3[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.renorm(x, 1, 0, 5) 1.0000  1.0000  1.0000 1.6667  1.6667  1.6667 1.6667  1.6667  1.6667[torch.FloatTensor of size 3x3]</code></pre><h3 id="torch-trace"><a href="#torch-trace" class="headerlink" title="torch.trace"></a>torch.trace</h3><pre><code>torch.trace(input) → float</code></pre><p>返回输入2维矩阵对角线元素的和(迹)</p><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.arange(1, 10).view(3, 3)&gt;&gt;&gt; x 1  2  3 4  5  6 7  8  9[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.trace(x)15.0</code></pre><h3 id="torch-tril"><a href="#torch-tril" class="headerlink" title="torch.tril"></a>torch.tril</h3><pre><code>torch.tril(input, k=0, out=None) → Tensor</code></pre><p>返回一个张量<code>out</code>，包含输入矩阵(2D张量)的下三角部分，<code>out</code>其余部分被设为<code>0</code>。这里所说的下三角部分为矩阵指定对角线<code>diagonal</code>之上的元素。</p><p>参数<code>k</code>控制对角线: - <code>k</code> = 0, 主对角线 - <code>k</code> &gt; 0, 主对角线之上 - <code>k</code> &lt; 0, 主对角线之下</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>k (int, optional) – 指定对角线</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(3,3)&gt;&gt;&gt; a 1.3225  1.7304  1.4573-0.3052 -0.3111 -0.1809 1.2469  0.0064 -1.6250[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.tril(a) 1.3225  0.0000  0.0000-0.3052 -0.3111  0.0000 1.2469  0.0064 -1.6250[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.tril(a, k=1) 1.3225  1.7304  0.0000-0.3052 -0.3111 -0.1809 1.2469  0.0064 -1.6250[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.tril(a, k=-1) 0.0000  0.0000  0.0000-0.3052  0.0000  0.0000 1.2469  0.0064  0.0000[torch.FloatTensor of size 3x3]</code></pre><h3 id="torch-triu"><a href="#torch-triu" class="headerlink" title="torch.triu"></a>torch.triu</h3><pre><code>torch.triu(input, k=0, out=None) → Tensor</code></pre><p>返回一个张量，包含输入矩阵(2D张量)的上三角部分，其余部分被设为<code>0</code>。这里所说的上三角部分为矩阵指定对角线<code>diagonal</code>之上的元素。</p><p>参数<code>k</code>控制对角线: - <code>k</code> = 0, 主对角线 - <code>k</code> &gt; 0, 主对角线之上 - <code>k</code> &lt; 0, 主对角线之下</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>k (int, optional) – 指定对角线</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(3,3)&gt;&gt;&gt; a 1.3225  1.7304  1.4573-0.3052 -0.3111 -0.1809 1.2469  0.0064 -1.6250[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.triu(a) 1.3225  1.7304  1.4573 0.0000 -0.3111 -0.1809 0.0000  0.0000 -1.6250[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.triu(a, k=1) 0.0000  1.7304  1.4573 0.0000  0.0000 -0.1809 0.0000  0.0000  0.0000[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.triu(a, k=-1) 1.3225  1.7304  1.4573-0.3052 -0.3111 -0.1809 0.0000  0.0064 -1.6250[torch.FloatTensor of size 3x3]</code></pre><h2 id="BLAS-and-LAPACK-Operations"><a href="#BLAS-and-LAPACK-Operations" class="headerlink" title="BLAS and LAPACK Operations"></a>BLAS and LAPACK Operations</h2><h3 id="torch-addbmm"><a href="#torch-addbmm" class="headerlink" title="torch.addbmm"></a>torch.addbmm</h3><pre><code>torch.addbmm(beta=1, mat, alpha=1, batch1, batch2, out=None) → Tensor</code></pre><p>对类型为 <em>FloatTensor</em> 或 <em>DoubleTensor</em> 的输入，<code>alpha</code>and <code>beta</code>必须为实数，否则两个参数须为整数。</p><p>参数：</p><ul><li>beta (Number, optional) – 用于<code>mat</code>的乘子</li><li>mat (Tensor) – 相加矩阵</li><li>batch1 (Tensor) – 第一批相乘矩阵</li><li>batch2 (Tensor) – 第二批相乘矩阵</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; M = torch.randn(3, 5)&gt;&gt;&gt; batch1 = torch.randn(10, 3, 4)&gt;&gt;&gt; batch2 = torch.randn(10, 4, 5)&gt;&gt;&gt; torch.addbmm(M, batch1, batch2) -3.1162  11.0071   7.3102   0.1824  -7.6892  1.8265   6.0739   0.4589  -0.5641  -5.4283 -9.3387  -0.1794  -1.2318  -6.8841  -4.7239[torch.FloatTensor of size 3x5]</code></pre><h3 id="torch-addmm"><a href="#torch-addmm" class="headerlink" title="torch.addmm"></a>torch.addmm</h3><pre><code>torch.addmm(beta=1, mat, alpha=1, mat1, mat2, out=None) → Tensor</code></pre><p>对类型为 <em>FloatTensor</em> 或 <em>DoubleTensor</em> 的输入，<code>beta</code>and <code>alpha</code>必须为实数，否则两个参数须为整数。</p><p>参数 ：</p><ul><li><p>beta (Number, optional) – 用于<code>mat</code>的乘子</p></li><li><p>mat (Tensor) – 相加矩阵</p></li><li><p>mat1 (Tensor) – 第一个相乘矩阵</p></li><li><p>mat2 (Tensor) – 第二个相乘矩阵</p></li><li><p>out (Tensor, optional) – 输出张量</p></li></ul><pre><code>&gt;&gt;&gt; M = torch.randn(2, 3)&gt;&gt;&gt; mat1 = torch.randn(2, 3)&gt;&gt;&gt; mat2 = torch.randn(3, 3)&gt;&gt;&gt; torch.addmm(M, mat1, mat2)-0.4095 -1.9703  1.3561 5.7674 -4.9760  2.7378[torch.FloatTensor of size 2x3]</code></pre><h3 id="torch-addmv"><a href="#torch-addmv" class="headerlink" title="torch.addmv"></a>torch.addmv</h3><pre><code>torch.addmv(beta=1, tensor, alpha=1, mat, vec, out=None) → Tensor</code></pre><p>对类型为_FloatTensor_或_DoubleTensor_的输入，<code>alpha</code>and <code>beta</code>必须为实数，否则两个参数须为整数。</p><p>参数 ：</p><ul><li>beta (Number, optional) – 用于<code>mat</code>的乘子</li><li>mat (Tensor) – 相加矩阵</li><li>mat (Tensor) – 相乘矩阵</li><li>vec (Tensor) – 相乘向量</li><li>out (Tensor, optional) – 输出张量</li></ul><pre><code>&gt;&gt;&gt; M = torch.randn(2)&gt;&gt;&gt; mat = torch.randn(2, 3)&gt;&gt;&gt; vec = torch.randn(3)&gt;&gt;&gt; torch.addmv(M, mat, vec)-2.0939-2.2950[torch.FloatTensor of size 2]</code></pre><h3 id="torch-addr"><a href="#torch-addr" class="headerlink" title="torch.addr"></a>torch.addr</h3><pre><code>torch.addr(beta=1, mat, alpha=1, vec1, vec2, out=None) → Tensor</code></pre><p>对类型为_FloatTensor_或_DoubleTensor_的输入，<code>alpha</code>and <code>beta</code>必须为实数，否则两个参数须为整数。</p><p>参数 ：</p><ul><li>beta (Number, optional) – 用于<code>mat</code>的乘子</li><li>mat (Tensor) – 相加矩阵</li><li>vec1 (Tensor) – 第一个相乘向量</li><li>vec2 (Tensor) – 第二个相乘向量</li><li>out (Tensor, optional) – 输出张量</li></ul><pre><code>&gt;&gt;&gt; vec1 = torch.arange(1, 4)&gt;&gt;&gt; vec2 = torch.arange(1, 3)&gt;&gt;&gt; M = torch.zeros(3, 2)&gt;&gt;&gt; torch.addr(M, vec1, vec2) 1  2 2  4 3  6[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-baddbmm"><a href="#torch-baddbmm" class="headerlink" title="torch.baddbmm"></a>torch.baddbmm</h3><pre><code>torch.baddbmm(beta=1, mat, alpha=1, batch1, batch2, out=None) → Tensor</code></pre><p>对类型为_FloatTensor_或_DoubleTensor_的输入，<code>alpha</code>and <code>beta</code>必须为实数，否则两个参数须为整数。</p><p>参数：</p><ul><li>beta (Number, optional) – 用于<code>mat</code>的乘子</li><li>mat (Tensor) – 相加矩阵</li><li>batch1 (Tensor) – 第一批相乘矩阵</li><li>batch2 (Tensor) – 第二批相乘矩阵</li><li>out (Tensor, optional) – 输出张量</li></ul><pre><code>&gt;&gt;&gt; M = torch.randn(10, 3, 5)&gt;&gt;&gt; batch1 = torch.randn(10, 3, 4)&gt;&gt;&gt; batch2 = torch.randn(10, 4, 5)&gt;&gt;&gt; torch.baddbmm(M, batch1, batch2).size()torch.Size([10, 3, 5])</code></pre><h3 id="torch-bmm"><a href="#torch-bmm" class="headerlink" title="torch.bmm"></a>torch.bmm</h3><pre><code>torch.bmm(batch1, batch2, out=None) → Tensor</code></pre><p>对类型为 <em>FloatTensor</em> 或 <em>DoubleTensor</em> 的输入，<code>alpha</code>and <code>beta</code>必须为实数，否则两个参数须为整数。</p><p>参数：</p><ul><li>batch1 (Tensor) – 第一批相乘矩阵</li><li>batch2 (Tensor) – 第二批相乘矩阵</li><li>out (Tensor, optional) – 输出张量</li></ul><pre><code>&gt;&gt;&gt; batch1 = torch.randn(10, 3, 4)&gt;&gt;&gt; batch2 = torch.randn(10, 4, 5)&gt;&gt;&gt; res = torch.bmm(batch1, batch2)&gt;&gt;&gt; res.size()torch.Size([10, 3, 5])</code></pre><h3 id="torch-btrifact"><a href="#torch-btrifact" class="headerlink" title="torch.btrifact"></a>torch.btrifact</h3><pre><code>torch.btrifact(A, info=None) → Tensor, IntTensor</code></pre><p>返回一个元组，包含LU 分解和<code>pivots</code> 。 可选参数<code>info</code>决定是否对每个minibatch样本进行分解。<code>info</code> are from dgetrf and a non-zero value indicates an error occurred. 如果用CUDA的话，这个值来自于CUBLAS，否则来自LAPACK。</p><p>参数： A (Tensor) – 待分解张量</p><pre><code>&gt;&gt;&gt; A = torch.randn(2, 3, 3)&gt;&gt;&gt; A_LU = A.btrifact()</code></pre><h3 id="torch-btrisolve"><a href="#torch-btrisolve" class="headerlink" title="torch.btrisolve"></a>torch.btrisolve</h3><pre><code>torch.btrisolve(b, LU_data, LU_pivots) → Tensor</code></pre><p>参数：</p><ul><li>b (Tensor) – RHS 张量.</li><li>LU_data (Tensor) – Pivoted LU factorization of A from btrifact.</li><li>LU_pivots (IntTensor) – LU 分解的Pivots.</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; A = torch.randn(2, 3, 3)&gt;&gt;&gt; b = torch.randn(2, 3)&gt;&gt;&gt; A_LU = torch.btrifact(A)&gt;&gt;&gt; x = b.btrisolve(*A_LU)&gt;&gt;&gt; torch.norm(A.bmm(x.unsqueeze(2)) - b)6.664001874625056e-08</code></pre><h3 id="torch-dot"><a href="#torch-dot" class="headerlink" title="torch.dot"></a>torch.dot</h3><pre><code>torch.dot(tensor1, tensor2) → float</code></pre><p>计算两个张量的点乘(内乘),两个张量都为1-D 向量.</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.dot(torch.Tensor([2, 3]), torch.Tensor([2, 1]))7.0</code></pre><h3 id="torch-eig"><a href="#torch-eig" class="headerlink" title="torch.eig"></a>torch.eig</h3><pre><code>torch.eig(a, eigenvectors=False, out=None) -&gt; (Tensor, Tensor)</code></pre><p>计算实方阵<code>a</code> 的特征值和特征向量</p><p>参数：</p><ul><li>a (Tensor) – 方阵，待计算其特征值和特征向量</li><li>eigenvectors (bool) – 布尔值，如果<code>True</code>，则同时计算特征值和特征向量，否则只计算特征值。</li><li>out (tuple, optional) – 输出元组</li></ul><p>返回值： 元组，包括：</p><ul><li>e (Tensor): a 的右特征向量</li><li>v (Tensor): 如果<code>eigenvectors</code>为<code>True</code>，则为包含特征向量的张量; 否则为空张量</li></ul><p>返回值类型： (Tensor, Tensor)</p><h3 id="torch-gels"><a href="#torch-gels" class="headerlink" title="torch.gels"></a>torch.gels</h3><pre><code>torch.gels(B, A, out=None) → Tensor</code></pre><p>注意： 返回矩阵总是被转置，无论输入矩阵的原始布局如何，总会被转置；即，总是有 stride (1, m) 而不是 (m, 1).</p><p>参数：</p><ul><li>B (Tensor) – 矩阵B</li><li>out (tuple, optional) – 输出元组</li></ul><p>返回值： 元组，包括：</p><ul><li>X (Tensor): 最小二乘解</li><li>qr (Tensor): QR 分解的细节</li></ul><p>返回值类型： (Tensor, Tensor)</p><p>例子：</p><pre><code>&gt;&gt;&gt; A = torch.Tensor([[1, 1, 1],...                   [2, 3, 4],...                   [3, 5, 2],...                   [4, 2, 5],...                   [5, 4, 3]])&gt;&gt;&gt; B = torch.Tensor([[-10, -3],                      [ 12, 14],                      [ 14, 12],                      [ 16, 16],                      [ 18, 16]])&gt;&gt;&gt; X, _ = torch.gels(B, A)&gt;&gt;&gt; X2.0000  1.00001.0000  1.00001.0000  2.0000[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-geqrf"><a href="#torch-geqrf" class="headerlink" title="torch.geqrf"></a>torch.geqrf</h3><pre><code>torch.geqrf(input, out=None) -&gt; (Tensor, Tensor)</code></pre><p>这是一个直接调用LAPACK的底层函数。 一般使用<code>torch.qr()</code></p><p>计算输入的QR 分解，但是并不会分别创建Q,R两个矩阵，而是直接调用LAPACK 函数 Rather, this directly calls the underlying LAPACK function ?geqrf which produces a sequence of ‘elementary reflectors’.</p><p>参考 <a href="https://software.intel.com/en-us/node/521004" target="_blank" rel="noopener">LAPACK文档</a>获取更详细信息。</p><p>参数:</p><ul><li>input (Tensor) – 输入矩阵</li><li>out (tuple, optional) – 元组，包含输出张量 (Tensor, Tensor)</li></ul><h3 id="torch-ger"><a href="#torch-ger" class="headerlink" title="torch.ger"></a>torch.ger</h3><pre><code>torch.ger(vec1, vec2, out=None) → Tensor</code></pre><p>计算两向量<code>vec1</code>,<code>vec2</code>的张量积。如果<code>vec1</code>的长度为<code>n</code>,<code>vec2</code>长度为<code>m</code>，则输出<code>out</code>应为形如n x m的矩阵。</p><p>参数:</p><ul><li>vec1 (Tensor) – 1D 输入向量</li><li>vec2 (Tensor) – 1D 输入向量</li><li>out (tuple, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; v1 = torch.arange(1, 5)&gt;&gt;&gt; v2 = torch.arange(1, 4)&gt;&gt;&gt; torch.ger(v1, v2)  1   2   3  2   4   6  3   6   9  4   8  12[torch.FloatTensor of size 4x3]</code></pre><h3 id="torch-gesv"><a href="#torch-gesv" class="headerlink" title="torch.gesv"></a>torch.gesv</h3><pre><code>torch.gesv(B, A, out=None) -&gt; (Tensor, Tensor)</code></pre><p>例子:</p><pre><code>&gt;&gt;&gt; A = torch.Tensor([[6.80, -2.11,  5.66,  5.97,  8.23],...                   [-6.05, -3.30,  5.36, -4.44,  1.08],...                   [-0.45,  2.58, -2.70,  0.27,  9.04],...                   [8.32,  2.71,  4.35,  -7.17,  2.14],...                   [-9.67, -5.14, -7.26,  6.08, -6.87]]).t()&gt;&gt;&gt; B = torch.Tensor([[4.02,  6.19, -8.22, -7.57, -3.03],...                   [-1.56,  4.00, -8.67,  1.75,  2.86],...                   [9.81, -4.09, -4.57, -8.61,  8.99]]).t()&gt;&gt;&gt; X, LU = torch.gesv(B, A)&gt;&gt;&gt; torch.dist(B, torch.mm(A, X))9.250057093890353e-06</code></pre><h3 id="torch-inverse"><a href="#torch-inverse" class="headerlink" title="torch.inverse"></a>torch.inverse</h3><pre><code>torch.inverse(input, out=None) → Tensor</code></pre><p>对方阵输入<code>input</code> 取逆。</p><p><em>注意</em> ： Irrespective of the original strides, the returned matrix will be transposed, i.e. with strides (1, m) instead of (m, 1)</p><p>参数 ：</p><ul><li>input (Tensor) – 输入2维张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; x = torch.rand(10, 10)&gt;&gt;&gt; x 0.7800  0.2267  0.7855  0.9479  0.5914  0.7119  0.4437  0.9131  0.1289  0.1982 0.0045  0.0425  0.2229  0.4626  0.6210  0.0207  0.6338  0.7067  0.6381  0.8196 0.8350  0.7810  0.8526  0.9364  0.7504  0.2737  0.0694  0.5899  0.8516  0.3883 0.6280  0.6016  0.5357  0.2936  0.7827  0.2772  0.0744  0.2627  0.6326  0.9153 0.7897  0.0226  0.3102  0.0198  0.9415  0.9896  0.3528  0.9397  0.2074  0.6980 0.5235  0.6119  0.6522  0.3399  0.3205  0.5555  0.8454  0.3792  0.4927  0.6086 0.1048  0.0328  0.5734  0.6318  0.9802  0.4458  0.0979  0.3320  0.3701  0.0909 0.2616  0.3485  0.4370  0.5620  0.5291  0.8295  0.7693  0.1807  0.0650  0.8497 0.1655  0.2192  0.6913  0.0093  0.0178  0.3064  0.6715  0.5101  0.2561  0.3396 0.4370  0.4695  0.8333  0.1180  0.4266  0.4161  0.0699  0.4263  0.8865  0.2578[torch.FloatTensor of size 10x10]&gt;&gt;&gt; x = torch.rand(10, 10)&gt;&gt;&gt; y = torch.inverse(x)&gt;&gt;&gt; z = torch.mm(x, y)&gt;&gt;&gt; z 1.0000  0.0000  0.0000 -0.0000  0.0000  0.0000  0.0000  0.0000 -0.0000 -0.0000 0.0000  1.0000 -0.0000  0.0000  0.0000  0.0000 -0.0000 -0.0000 -0.0000 -0.0000 0.0000  0.0000  1.0000 -0.0000 -0.0000  0.0000  0.0000  0.0000 -0.0000 -0.0000 0.0000  0.0000  0.0000  1.0000  0.0000  0.0000  0.0000 -0.0000 -0.0000  0.0000 0.0000  0.0000 -0.0000 -0.0000  1.0000  0.0000  0.0000 -0.0000 -0.0000 -0.0000 0.0000  0.0000  0.0000 -0.0000  0.0000  1.0000 -0.0000 -0.0000 -0.0000 -0.0000 0.0000  0.0000  0.0000 -0.0000  0.0000  0.0000  1.0000  0.0000 -0.0000  0.0000 0.0000  0.0000 -0.0000 -0.0000  0.0000  0.0000 -0.0000  1.0000 -0.0000  0.0000-0.0000  0.0000 -0.0000 -0.0000  0.0000  0.0000 -0.0000 -0.0000  1.0000 -0.0000-0.0000  0.0000 -0.0000 -0.0000 -0.0000  0.0000 -0.0000 -0.0000  0.0000  1.0000[torch.FloatTensor of size 10x10]&gt;&gt;&gt; torch.max(torch.abs(z - torch.eye(10))) # Max nonzero5.096662789583206e-07</code></pre><h3 id="torch-mm"><a href="#torch-mm" class="headerlink" title="torch.mm"></a>torch.mm</h3><pre><code>torch.mm(mat1, mat2, out=None) → Tensor</code></pre><p>参数 ：</p><ul><li>mat1 (Tensor) – 第一个相乘矩阵</li><li>mat2 (Tensor) – 第二个相乘矩阵</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; mat1 = torch.randn(2, 3)&gt;&gt;&gt; mat2 = torch.randn(3, 3)&gt;&gt;&gt; torch.mm(mat1, mat2) 0.0519 -0.3304  1.2232 4.3910 -5.1498  2.7571[torch.FloatTensor of size 2x3]</code></pre><h3 id="torch-mv"><a href="#torch-mv" class="headerlink" title="torch.mv"></a>torch.mv</h3><pre><code>torch.mv(mat, vec, out=None) → Tensor</code></pre><p>参数 ：</p><ul><li>mat (Tensor) – 相乘矩阵</li><li>vec (Tensor) – 相乘向量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; mat = torch.randn(2, 3)&gt;&gt;&gt; vec = torch.randn(3)&gt;&gt;&gt; torch.mv(mat, vec)-2.0939-2.2950[torch.FloatTensor of size 2]</code></pre><h3 id="torch-orgqr"><a href="#torch-orgqr" class="headerlink" title="torch.orgqr"></a>torch.orgqr</h3><pre><code>torch.orgqr()</code></pre><h3 id="torch-ormqr"><a href="#torch-ormqr" class="headerlink" title="torch.ormqr"></a>torch.ormqr</h3><pre><code>torch.ormqr()</code></pre><h3 id="torch-potrf"><a href="#torch-potrf" class="headerlink" title="torch.potrf"></a>torch.potrf</h3><pre><code>torch.potrf()</code></pre><h3 id="torch-potri"><a href="#torch-potri" class="headerlink" title="torch.potri"></a>torch.potri</h3><pre><code>torch.potri()</code></pre><h3 id="torch-potrs"><a href="#torch-potrs" class="headerlink" title="torch.potrs"></a>torch.potrs</h3><pre><code>torch.potrs()</code></pre><h3 id="torch-pstrf"><a href="#torch-pstrf" class="headerlink" title="torch.pstrf"></a>torch.pstrf</h3><pre><code>torch.pstrf()</code></pre><h3 id="torch-qr"><a href="#torch-qr" class="headerlink" title="torch.qr"></a>torch.qr</h3><pre><code>torch.qr(input, out=None) -&gt; (Tensor, Tensor)</code></pre><p>本函数返回一个thin(reduced)QR分解。</p><p><strong>注意</strong> 如果输入很大，可能可能会丢失精度。</p><p><strong>注意</strong> 本函数依赖于你的LAPACK实现，虽然总能返回一个合法的分解，但不同平台可能得到不同的结果。</p><p>Irrespective of the original strides, the returned matrix q will be transposed, i.e. with strides (1, m) instead of (m, 1).</p><p>参数：</p><ul><li>input (Tensor) – 输入的2维张量</li><li>out (tuple, optional) – 输出元组<code>tuple</code>，包含Q和R</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; a = torch.Tensor([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])&gt;&gt;&gt; q, r = torch.qr(a)&gt;&gt;&gt; q-0.8571  0.3943  0.3314-0.4286 -0.9029 -0.0343 0.2857 -0.1714  0.9429[torch.FloatTensor of size 3x3]&gt;&gt;&gt; r -14.0000  -21.0000   14.0000   0.0000 -175.0000   70.0000   0.0000    0.0000  -35.0000[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.mm(q, r).round()  12  -51    4   6  167  -68  -4   24  -41[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.mm(q.t(), q).round() 1 -0  0-0  1  0 0  0  1[torch.FloatTensor of size 3x3]</code></pre><h3 id="torch-svd"><a href="#torch-svd" class="headerlink" title="torch.svd"></a>torch.svd</h3><pre><code>torch.svd(input, some=True, out=None) -&gt; (Tensor, Tensor, Tensor)</code></pre><p><code>some</code> 代表了需要计算的奇异值数目。如果 <code>some=True</code>, it computes some and some=False computes all.</p><p>Irrespective of the original strides, the returned matrix U will be transposed, i.e. with strides (1, n) instead of (n, 1).</p><p>参数：</p><ul><li>input (Tensor) – 输入的2维张量</li><li>some (bool, optional) – 布尔值，控制需计算的奇异值数目</li><li>out (tuple, optional) – 结果<code>tuple</code></li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.Tensor([[8.79,  6.11, -9.15,  9.57, -3.49,  9.84],...                   [9.93,  6.91, -7.93,  1.64,  4.02,  0.15],...                   [9.83,  5.04,  4.86,  8.83,  9.80, -8.99],...                   [5.45, -0.27,  4.85,  0.74, 10.00, -6.02],...                   [3.16,  7.98,  3.01,  5.80,  4.27, -5.31]]).t()&gt;&gt;&gt; a  8.7900   9.9300   9.8300   5.4500   3.1600  6.1100   6.9100   5.0400  -0.2700   7.9800 -9.1500  -7.9300   4.8600   4.8500   3.0100  9.5700   1.6400   8.8300   0.7400   5.8000 -3.4900   4.0200   9.8000  10.0000   4.2700  9.8400   0.1500  -8.9900  -6.0200  -5.3100[torch.FloatTensor of size 6x5]&gt;&gt;&gt; u, s, v = torch.svd(a)&gt;&gt;&gt; u-0.5911  0.2632  0.3554  0.3143  0.2299-0.3976  0.2438 -0.2224 -0.7535 -0.3636-0.0335 -0.6003 -0.4508  0.2334 -0.3055-0.4297  0.2362 -0.6859  0.3319  0.1649-0.4697 -0.3509  0.3874  0.1587 -0.5183 0.2934  0.5763 -0.0209  0.3791 -0.6526[torch.FloatTensor of size 6x5]&gt;&gt;&gt; s 27.4687 22.6432  8.5584  5.9857  2.0149[torch.FloatTensor of size 5]&gt;&gt;&gt; v-0.2514  0.8148 -0.2606  0.3967 -0.2180-0.3968  0.3587  0.7008 -0.4507  0.1402-0.6922 -0.2489 -0.2208  0.2513  0.5891-0.3662 -0.3686  0.3859  0.4342 -0.6265-0.4076 -0.0980 -0.4932 -0.6227 -0.4396[torch.FloatTensor of size 5x5]&gt;&gt;&gt; torch.dist(a, torch.mm(torch.mm(u, torch.diag(s)), v.t()))8.934150226306685e-06</code></pre><h3 id="torch-symeig"><a href="#torch-symeig" class="headerlink" title="torch.symeig"></a>torch.symeig</h3><pre><code>torch.symeig(input, eigenvectors=False, upper=True, out=None) -&gt; (Tensor, Tensor)</code></pre><p><strong>注意</strong>: 不管原来Irrespective of the original strides, the returned matrix V will be transposed, i.e. with strides (1, m) instead of (m, 1)</p><p>参数：</p><ul><li>input (Tensor) – 输入对称矩阵</li><li>eigenvectors (boolean, optional) – 布尔值（可选），控制是否计算特征向量</li><li>upper (boolean, optional) – 布尔值（可选），控制是否考虑上三角或下三角区域</li><li>out (tuple, optional) – 输出元组(Tensor, Tensor)</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.Tensor([[ 1.96,  0.00,  0.00,  0.00,  0.00],...                   [-6.49,  3.80,  0.00,  0.00,  0.00],...                   [-0.47, -6.39,  4.17,  0.00,  0.00],...                   [-7.20,  1.50, -1.51,  5.70,  0.00],...                   [-0.65, -6.34,  2.67,  1.80, -7.10]]).t()&gt;&gt;&gt; e, v = torch.symeig(a, eigenvectors=True)&gt;&gt;&gt; e-11.0656 -6.2287  0.8640  8.8655 16.0948[torch.FloatTensor of size 5]&gt;&gt;&gt; v-0.2981 -0.6075  0.4026 -0.3745  0.4896-0.5078 -0.2880 -0.4066 -0.3572 -0.6053-0.0816 -0.3843 -0.6600  0.5008  0.3991-0.0036 -0.4467  0.4553  0.6204 -0.4564-0.8041  0.4480  0.1725  0.3108  0.1622[torch.FloatTensor of size 5x5]</code></pre><h3 id="torch-trtrs"><a href="#torch-trtrs" class="headerlink" title="torch.trtrs"></a>torch.trtrs</h3><pre><code> torch.trtrs()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-关键词动态爬取图片保存于本地</title>
      <link href="/posts/blog-python10.html"/>
      <url>/posts/blog-python10.html</url>
      
        <content type="html"><![CDATA[<h1 id="利用关键词动态爬取想要的图片"><a href="#利用关键词动态爬取想要的图片" class="headerlink" title="利用关键词动态爬取想要的图片"></a>利用关键词动态爬取想要的图片</h1><h3 id="导入相关库"><a href="#导入相关库" class="headerlink" title="导入相关库"></a>导入相关库</h3><p>主要是requests库</p><pre><code>import re  # 导入正则表达式模块import requests  # python HTTP客户端 编写爬虫和测试服务器经常用到的模块import random  # 随机生成一个数，范围[0,1]import os #创建路径</code></pre><h3 id="写爬虫爬取图片函数"><a href="#写爬虫爬取图片函数" class="headerlink" title="写爬虫爬取图片函数"></a>写爬虫爬取图片函数</h3><pre><code>def spiderPic(html, keyword):       #html：网页；keyword：关键词    print('正在查找 ' + keyword + ' 对应的图片,请稍后......')    for addr in re.findall('"objURL":"(.*?)"', html, re.S):  # 动态查找URL        print('正在爬取URL地址：' + str(addr)[0:40] + '...')  # 爬取的地址长度超过40时，用'...'代替后面的内容        try:            pics = requests.get(addr, timeout=10)  # 请求URL时间（最大10秒）        except requests.exceptions.ConnectionError:            print('您当前请求的URL地址出现错误')            continue        fq = open('E:\\img\\' + (keyword + '_' + str(random.randrange(0, 1000, 4)) + '.jpg'), 'wb')  # 下载图片，并保存和命名        fq.write(pics.content)        fq.close()</code></pre><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><pre><code>if __name__ == '__main__':    word = input('请输入你要搜索的图片关键字：')    result = requests.get(        # 通过百度引擎搜索关键词链接        'http://image.baidu.com/search/index?tn=baiduimage&amp;ps=1&amp;ct=201326592&amp;lm=-1&amp;cl=2&amp;nc=1&amp;ie=utf-8&amp;word=' + word)</code></pre><h3 id="存放图片文件夹创建"><a href="#存放图片文件夹创建" class="headerlink" title="存放图片文件夹创建"></a>存放图片文件夹创建</h3><p>加入判断是否存在该文件目录</p><pre><code>path='E:\\img\\';# 判断路径是否存在isExists = os.path.exists(path)### 判断结果if not isExists:    # 如果不存在则创建目录    # 创建目录操作函数    os.makedirs(path)    print    path + '创建成功'else:    # 如果目录存在则不创建，并提示目录已存在    print    path + ' 目录已存在'</code></pre><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><pre><code>spiderPic(result.text, word)</code></pre><h3 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h3><p>我们在输入提示后输入关键词 “风景”并开始爬取图片<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-15547726d83bbca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"><br>爬取的图片在img文件夹中</p><p>源码地址：<a href="https://github.com/JackHCC/KeyWord-Crawler" target="_blank" rel="noopener">https://github.com/JackHCC/KeyWord-Crawler</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-照片墙设计布局爱心形状</title>
      <link href="/posts/blog-python09.html"/>
      <url>/posts/blog-python09.html</url>
      
        <content type="html"><![CDATA[<h1 id="python照片墙设计"><a href="#python照片墙设计" class="headerlink" title="python照片墙设计"></a>python照片墙设计</h1><h3 id="代码规划："><a href="#代码规划：" class="headerlink" title="代码规划："></a>代码规划：</h3><ul><li>将爬虫爬取的图片进行处理，减小尺寸</li><li>将处理好的图片进行照片墙设计<h3 id="图片处理ImageSolve-py-批量处理"><a href="#图片处理ImageSolve-py-批量处理" class="headerlink" title="图片处理ImageSolve.py:批量处理"></a>图片处理ImageSolve.py:批量处理</h3></li><li>导入库：PIL:图像处理；glob<pre><code>from PIL import Imageimport os.pathimport glob</code></pre></li><li>定义ReSize函数：<pre><code>#由于爬虫获取的照片尺寸太大，我们更改爬虫获取的照片尺寸大小def Resize(file, outdir, width, height):  imgFile = Image.open(file)  try:      newImage = imgFile.resize((width, height), Image.BILINEAR)    #更改尺寸      newImage.save(os.path.join(outdir, os.path.basename(file)))     #输出保存图片  except Exception as e:      print(e)</code></pre></li><li>处理后照片的存储<pre><code>for file in glob.glob("res\\*.jpg"):  # 图片所在的目录  Resize(file, "new", 100, 100)  # 新图片存放的目录</code></pre><h3 id="照片墙展示"><a href="#照片墙展示" class="headerlink" title="照片墙展示"></a>照片墙展示</h3></li><li>导入库<pre><code>import sysfrom PyQt5.QtGui import QPixmapfrom PyQt5.QtWidgets import *</code></pre></li><li>Qt窗口基本创建<pre><code>app = QApplication(sys.argv)</code></pre></li></ul><p>win = QWidget()<br>win.resize(760, 540)<br>win.move(0, 0)<br>layout=QGridLayout(win)</p><p>positionSet()<br>win.setWindowTitle(‘GUI’)<br>win.show()</p><pre><code>+ 背景图设置</code></pre><p>b=QLabel(win)<br>b.setPixmap(QPixmap(“bg.jpg”))<br>b.setGeometry(0,0,820,640)</p><pre><code>+ 布局函数</code></pre><p>def positionSet():</p><p>```</p><h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-0d7f2df2852585b1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><p>源码地址：<a href="https://github.com/JackHCC/SlideShow" target="_blank" rel="noopener">https://github.com/JackHCC/SlideShow</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PIL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-机器学习Scikit-learn</title>
      <link href="/posts/blog-python08.html"/>
      <url>/posts/blog-python08.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h1><p><a href="http://sklearn.apachecn.org/#/" target="_blank" rel="noopener">官方中文文档</a></p><h1 id="机器学习方式"><a href="#机器学习方式" class="headerlink" title="机器学习方式"></a>机器学习方式</h1><p>机器学习可以分为以下五个大类：</p><p>(1 )监督学习：从给定的训练数据集中学习出-一个函数，当新的数据到来时，可以根据这个函数预测结果。监督学习的训练集要求是输人和输出，也可以说是特征和目标。训练集中的目标是由人标注的。常见的监督学习算法包括回归与分类。</p><p>(2)无监督学习：无监督学习与监督学习相比，训练集没有人为标注的结果。常见的无监督学习算法有聚类等。</p><p>(3)半监督学习：这是一”种介于监督学习与无监督学习之间的方法。</p><p>(4)迁移学习：将已经训练好的模型参数迁移到新的模型来帮助新模型训练数据集。</p><p>(5)增强学习：通过观察周围环境来学习。每个动作都会对环境有所影响，学习对象根据观察到的周围环境的反馈来做出判断。</p><h1 id="sklearn使用"><a href="#sklearn使用" class="headerlink" title="sklearn使用"></a>sklearn使用</h1><h2 id="1-获取数据"><a href="#1-获取数据" class="headerlink" title="1. 获取数据"></a>1. 获取数据</h2><h3 id="1-1-导入sklearn数据集"><a href="#1-1-导入sklearn数据集" class="headerlink" title="1.1 导入sklearn数据集"></a>1.1 导入sklearn数据集</h3><p>　　sklearn中包含了大量的优质的数据集，在你学习机器学习的过程中，你可以通过使用这些数据集实现出不同的模型，从而提高你的动手实践能力，同时这个过程也可以加深你对理论知识的理解和把握。（这一步我也亟需加强，一起加油！^-^）</p><p>首先呢，要想使用sklearn中的数据集，必须导入datasets模块：</p><pre><code>from sklearn import datasets</code></pre><p> 下图中包含了大部分sklearn中数据集，调用方式也在图中给出，这里我们拿iris的数据来举个例子：</p><p>　　<img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a9d7246ca1e92847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-c6aff0d49c840280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><pre><code>iris = datasets.load_iris() # 导入数据集X = iris.data # 获得其特征向量y = iris.target # 获得样本label</code></pre><h3 id="1-2-创建数据集"><a href="#1-2-创建数据集" class="headerlink" title="1.2 创建数据集"></a>1.2 创建数据集</h3><p>　　你除了可以使用sklearn自带的数据集，还可以自己去创建训练样本，具体用法参见《<a href="http://scikit-learn.org/stable/datasets/" target="_blank" rel="noopener">Dataset loading utilities</a>》，这里我们简单介绍一些，sklearn中的samples generator包含的大量创建样本数据的方法：</p><p>　　 <img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0253a891a44411bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-257e1464a9a2a74d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>下面我们拿分类问题的样本生成器举例子：</p><pre><code>from sklearn.datasets.samples_generator import make_classificationX, y = make_classification(n_samples=6, n_features=5, n_informative=2,     n_redundant=2, n_classes=2, n_clusters_per_class=2, scale=1.0,     random_state=20) # n_samples：指定样本数 # n_features：指定特征数 # n_classes：指定几分类 # random_state：随机种子，使得随机状可重</code></pre><pre><code>&gt;&gt;&gt; for x_,y_ in zip(X,y): print(y_,end=': ') print(x_)0: [-0.6600737  -0.0558978   0.82286793  1.1003977  -0.93493796] 1: [ 0.4113583   0.06249216 -0.90760075 -1.41296696  2.059838 ] 1: [ 1.52452016 -0.01867812  0.20900899  1.34422289 -1.61299022]0: [-1.25725859  0.02347952 -0.28764782 -1.32091378 -0.88549315]0: [-3.28323172  0.03899168 -0.43251277 -2.86249859 -1.10457948] 1: [ 1.68841011  0.06754955 -1.02805579 -0.83132182  0.93286635]</code></pre><h2 id="2-数据预处理"><a href="#2-数据预处理" class="headerlink" title="2. 数据预处理"></a>2. 数据预处理</h2><p>　　数据预处理阶段是机器学习中不可缺少的一环，它会使得数据更加有效的被模型或者评估器识别。下面我们来看一下sklearn中有哪些平时我们常用的函数：</p><pre><code>from sklearn import preprocessing</code></pre><h3 id="2-1-数据归一化"><a href="#2-1-数据归一化" class="headerlink" title="2.1 数据归一化"></a>2.1 数据归一化</h3><p>　　为了使得训练数据的标准化规则与测试数据的标准化规则同步，preprocessing中提供了很多Scaler：</p><pre><code>data = [[0, 0], [0, 0], [1, 1], [1, 1]] # 1\. 基于mean和std的标准化scaler = preprocessing.StandardScaler().fit(train_data)scaler.transform(train_data)scaler.transform(test_data) # 2\. 将每个特征值归一化到一个固定范围scaler = preprocessing.MinMaxScaler(feature_range=(0, 1)).fit(train_data)scaler.transform(train_data)scaler.transform(test_data) #feature_range: 定义归一化范围，注用（）括起来</code></pre><h3 id="2-2-正则化（normalize）"><a href="#2-2-正则化（normalize）" class="headerlink" title="2.2 正则化（normalize）"></a>2.2 正则化（<code>normalize</code>）</h3><p>　　当你想要计算两个样本的相似度时必不可少的一个操作，就是正则化。其思想是：首先求出样本的p-范数，然后该样本的所有元素都要除以该范数，这样最终使得每个样本的范数都为1。</p><pre><code>&gt;&gt;&gt; X = [[ 1., -1.,  2.],...      [ 2.,  0.,  0.],...      [ 0., 1., -1.]] &gt;&gt;&gt; X_normalized = preprocessing.normalize(X, norm='l2') &gt;&gt;&gt; X_normalized                                      array([[ 0.40..., -0.40...,  0.81...],       [ 1.  ...,  0\.  ...,  0\.  ...],       [ 0\.  ..., 0.70..., -0.70...]])</code></pre><h3 id="2-3-one-hot编码"><a href="#2-3-one-hot编码" class="headerlink" title="2.3 one-hot编码"></a>2.3 one-hot编码</h3><p>　　one-hot编码是一种对离散特征值的编码方式，在LR模型中常用到，用于给线性模型增加非线性能力。</p><pre><code>data = [[0, 0, 3], [1, 1, 0], [0, 2, 1], [1, 0, 2]]encoder = preprocessing.OneHotEncoder().fit(data)enc.transform(data).toarray()</code></pre><h2 id="3-数据集拆分"><a href="#3-数据集拆分" class="headerlink" title="3. 数据集拆分"></a>3. 数据集拆分</h2><p>　　在得到训练数据集时，通常我们经常会把训练数据集进一步拆分成训练集和验证集，这样有助于我们模型参数的选取。</p><pre><code># 作用：将数据集划分为 训练集和测试集 # 格式：train_test_split(*arrays, **options)from sklearn.mode_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42) """ 参数           返回---arrays：样本数组，包含特征向量和标签test_size：　　float-获得多大比重的测试样本 （默认：0.25）　　int - 获得多少个测试样本train_size: 同test_sizerandom_state:　　int - 随机种子（种子固定，实验可复现）shuffle - 是否在分割之前对数据进行洗牌（默认True）分割后的列表，长度=2*len(arrays), 　　(train-test split) """</code></pre><h2 id="4-定义模型"><a href="#4-定义模型" class="headerlink" title="4. 定义模型"></a>4. 定义模型</h2><p>　　在这一步我们首先要分析自己数据的类型，搞清出你要用什么模型来做，然后我们就可以在sklearn中定义模型了。sklearn为所有模型提供了非常相似的接口，这样使得我们可以更加快速的熟悉所有模型的用法。在这之前我们先来看看模型的常用属性和功能：</p><pre><code># 拟合模型model.fit(X_train, y_train) # 模型预测model.predict(X_test) # 获得这个模型的参数model.get_params() # 为模型进行打分model.score(data_X, data_y) # 线性回归：R square； 分类问题： acc</code></pre><h3 id="4-1-线性回归"><a href="#4-1-线性回归" class="headerlink" title="4.1 线性回归"></a>4.1 线性回归</h3><pre><code>from sklearn.linear_model import LinearRegression # 定义线性回归模型model = LinearRegression(fit_intercept=True, normalize=False,     copy_X=True, n_jobs=1) """ 参数---    fit_intercept：是否计算截距。False-模型没有截距    normalize： 当fit_intercept设置为False时，该参数将被忽略。 如果为真，则回归前的回归系数X将通过减去平均值并除以l2-范数而归一化。     n_jobs：指定线程数 """</code></pre><p>　　　　　　<img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-fe12917cfabb9875.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="4-2-逻辑回归LR"><a href="#4-2-逻辑回归LR" class="headerlink" title="4.2 逻辑回归LR"></a>4.2 逻辑回归LR</h3><pre><code>from sklearn.linear_model import LogisticRegression # 定义逻辑回归模型model = LogisticRegression(penalty=’l2’, dual=False, tol=0.0001, C=1.0,     fit_intercept=True, intercept_scaling=1, class_weight=None,     random_state=None, solver=’liblinear’, max_iter=100, multi_class=’ovr’,     verbose=0, warm_start=False, n_jobs=1) """参数---    penalty：使用指定正则化项（默认：l2）    dual: n_samples &gt; n_features取False（默认）    C：正则化强度的反，值越小正则化强度越大    n_jobs: 指定线程数    random_state：随机数生成器    fit_intercept: 是否需要常量 """</code></pre><h3 id="4-3-朴素贝叶斯算法NB"><a href="#4-3-朴素贝叶斯算法NB" class="headerlink" title="4.3 朴素贝叶斯算法NB"></a>4.3 朴素贝叶斯算法NB</h3><pre><code>from sklearn import naive_bayesmodel = naive_bayes.GaussianNB() # 高斯贝叶斯model = naive_bayes.MultinomialNB(alpha=1.0, fit_prior=True, class_prior=None)model = naive_bayes.BernoulliNB(alpha=1.0, binarize=0.0, fit_prior=True, class_prior=None) """ 文本分类问题常用MultinomialNB参数---    alpha：平滑参数    fit_prior：是否要学习类的先验概率；false-使用统一的先验概率    class_prior: 是否指定类的先验概率；若指定则不能根据参数调整    binarize: 二值化的阈值，若为None，则假设输入由二进制向量组成 """</code></pre><h3 id="4-4-决策树DT"><a href="#4-4-决策树DT" class="headerlink" title="4.4 决策树DT"></a>4.4 决策树DT</h3><pre><code>from sklearn import tree model = tree.DecisionTreeClassifier(criterion=’gini’, max_depth=None,     min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0,     max_features=None, random_state=None, max_leaf_nodes=None,     min_impurity_decrease=0.0, min_impurity_split=None,     class_weight=None, presort=False) """参数---    criterion ：特征选择准则gini/entropy    max_depth：树的最大深度，None-尽量下分    min_samples_split：分裂内部节点，所需要的最小样本树    min_samples_leaf：叶子节点所需要的最小样本数    max_features: 寻找最优分割点时的最大特征数    max_leaf_nodes：优先增长到最大叶子节点数    min_impurity_decrease：如果这种分离导致杂质的减少大于或等于这个值，则节点将被拆分。 """</code></pre><h3 id="4-5-支持向量机SVM"><a href="#4-5-支持向量机SVM" class="headerlink" title="4.5 支持向量机SVM"></a>4.5 支持向量机SVM</h3><pre><code>from sklearn.svm import SVCmodel = SVC(C=1.0, kernel=’rbf’, gamma=’auto’) """参数---    C：误差项的惩罚参数C    gamma: 核相关系数。浮点数，If gamma is ‘auto’ then 1/n_features will be used instead. """</code></pre><h3 id="4-6-k近邻算法KNN"><a href="#4-6-k近邻算法KNN" class="headerlink" title="4.6 k近邻算法KNN"></a>4.6 k近邻算法KNN</h3><pre><code>from sklearn import neighbors #定义kNN分类模型model = neighbors.KNeighborsClassifier(n_neighbors=5, n_jobs=1) # 分类model = neighbors.KNeighborsRegressor(n_neighbors=5, n_jobs=1) # 回归"""参数---    n_neighbors： 使用邻居的数目    n_jobs：并行任务数 """</code></pre><h3 id="4-7-多层感知机（神经网络）"><a href="#4-7-多层感知机（神经网络）" class="headerlink" title="4.7 多层感知机（神经网络）"></a>4.7 多层感知机（神经网络）</h3><pre><code>from sklearn.neural_network import MLPClassifier # 定义多层感知机分类算法model = MLPClassifier(activation='relu', solver='adam', alpha=0.0001) """参数---    hidden_layer_sizes: 元祖    activation：激活函数    solver ：优化算法{‘lbfgs’, ‘sgd’, ‘adam’}    alpha：L2惩罚(正则化项)参数。 """</code></pre><h2 id="5-模型评估与选择篇"><a href="#5-模型评估与选择篇" class="headerlink" title="5. 模型评估与选择篇"></a>5. 模型评估与选择篇</h2><h3 id="5-1-交叉验证"><a href="#5-1-交叉验证" class="headerlink" title="5.1 交叉验证"></a>5.1 交叉验证</h3><pre><code>from sklearn.model_selection import cross_val_scorecross_val_score(model, X, y=None, scoring=None, cv=None, n_jobs=1) """参数---    model：拟合数据的模型    cv ： k-fold    scoring: 打分参数-‘accuracy’、‘f1’、‘precision’、‘recall’ 、‘roc_auc’、'neg_log_loss'等等 """</code></pre><h3 id="5-2-检验曲线"><a href="#5-2-检验曲线" class="headerlink" title="5.2 检验曲线"></a>5.2 检验曲线</h3><p>　　使用检验曲线，我们可以更加方便的改变模型参数，获取模型表现。</p><pre><code>from sklearn.model_selection import validation_curvetrain_score, test_score = validation_curve(model, X, y, param_name, param_range, cv=None, scoring=None, n_jobs=1) """参数---    model:用于fit和predict的对象    X, y: 训练集的特征和标签    param_name：将被改变的参数的名字    param_range： 参数的改变范围    cv：k-fold返回值---   train_score: 训练集得分（array）    test_score: 验证集得分（array） """</code></pre><p><a href="http://scikit-learn.org/stable/auto_examples/model_selection/plot_validation_curve.html#sphx-glr-auto-examples-model-selection-plot-validation-curve-py" target="_blank" rel="noopener">例子</a></p><h2 id="6-保存模型"><a href="#6-保存模型" class="headerlink" title="6. 保存模型"></a>6. 保存模型</h2><p>　　最后，我们可以将我们训练好的model保存到本地，或者放到线上供用户使用，那么如何保存训练好的model呢？主要有下面两种方式：</p><h3 id="6-1-保存为pickle文件"><a href="#6-1-保存为pickle文件" class="headerlink" title="6.1 保存为pickle文件"></a>6.1 保存为pickle文件</h3><pre><code>import pickle # 保存模型with open('model.pickle', 'wb') as f:    pickle.dump(model, f) # 读取模型with open('model.pickle', 'rb') as f:    model = pickle.load(f)model.predict(X_test)</code></pre><h3 id="6-2-sklearn自带方法joblib"><a href="#6-2-sklearn自带方法joblib" class="headerlink" title="6.2 sklearn自带方法joblib"></a>6.2 sklearn自带方法joblib</h3><pre><code>from sklearn.externals import joblib # 保存模型joblib.dump(model, 'model.pickle') #载入模型model = joblib.load('model.pickle')</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Matplotlib数据可视化</title>
      <link href="/posts/blog-python07.html"/>
      <url>/posts/blog-python07.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://link.jianshu.com/?t=https://www.gitbook.com/book/wizardforcel/matplotlib-intro-tut/details" target="_blank" rel="noopener">在线阅读</a></li><li><a href="https://link.jianshu.com/?t=https://www.gitbook.com/download/pdf/book/wizardforcel/matplotlib-intro-tut" target="_blank" rel="noopener">PDF格式</a></li><li><a href="https://link.jianshu.com/?t=https://www.gitbook.com/download/epub/book/wizardforcel/matplotlib-intro-tut" target="_blank" rel="noopener">EPUB格式</a></li><li><a href="https://link.jianshu.com/?t=https://www.gitbook.com/download/mobi/book/wizardforcel/matplotlib-intro-tut" target="_blank" rel="noopener">MOBI格式</a></li><li><a href="https://link.jianshu.com/?t=https://github.com/wizardforcel/matplotlib-intro-tut-zh" target="_blank" rel="noopener">代码仓库</a><h1 id="第一章-Matplotlib-简介"><a href="#第一章-Matplotlib-简介" class="headerlink" title="第一章 Matplotlib 简介"></a>第一章 Matplotlib 简介</h1></li></ul><p>这里涉及Matplotlib 数据可视化模块的多个方面。 Matplotlib 能够创建多数类型的图表，如条形图，散点图，条形图，饼图，堆叠图，3D 图和地图图表。</p><p>首先，为了实际使用 Matplotlib，我们需要安装它。</p><p>如果你安装了更高版本的 Python，你应该能够打开<code>cmd.exe</code>或终端，然后执行：</p><pre><code>pip install matplotlib</code></pre><p>注意：如果上面的较短命令不工作，你可能需要执行<code>C:/Python34/Scripts/pip install matplotlib</code>。</p><p>如果在导入<code>matplotlib</code>时，你会收到类似『无命名模块』和模块名称的错误，这意味着你还需要安装该模块。 一个常见的问题是缺少名为<code>six</code>的模块。 这意味着你需要使用<code>pip</code>安装<code>six</code>。</p><p>或者，你可以前往 Matplotlib.org 并通过访问下载页面下载适当的版本进行安装。 请记住，因为你的操作系统为 64 位，你不一定需要 64 位版本的 Python。 如果你不打算尝试 64 位，你可以使用 32 位。 打开 IDLE 并阅读顶部。 如果它说你是 64 位，你就是 64 位，如果它说是 32 位，那么你就是 32 位。 一旦你安装了 Python，你就做好了准备，你可以编写任何你想要的逻辑。 我喜欢使用 IDLE 来编程，但你可以随意使用任何你喜欢的东西。</p><pre><code>import matplotlib.pyplot as plt</code></pre><p>这一行导入集成的<code>pyplot</code>，我们将在整个系列中使用它。 我们将<code>pyplot</code>导入为<code>plt</code>，这是使用<code>pylot</code>的 python 程序的传统惯例。</p><pre><code>plt.plot([1,2,3],[5,7,4])</code></pre><p>接下来，我们调用<code>plot</code>的<code>.plot</code>方法绘制一些坐标。 这个<code>.plot</code>需要许多参数，但前两个是<code>'x'</code>和<code>'y'</code>坐标，我们放入列表。 这意味着，根据这些列表我们拥有 3 个坐标：<code>1,5</code> <code>2,7</code>和<code>3,4</code>。</p><p><code>plt.plot</code>在后台『绘制』这个绘图，但绘制了我们想要的一切之后，当我们准备好的时候，我们需要把它带到屏幕上。</p><pre><code>plt.show()</code></pre><p>这样，应该弹出一个图形。 如果没有，有时它可以弹出，或者你可能得到一个错误。 你的图表应如下所示：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-fd9dc5b819eee2af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这个窗口是一个 matplotlib 窗口，它允许我们查看我们的图形，以及与它进行交互和访问。 你可以将鼠标悬停在图表上，并查看通常在右下角的坐标。 你也可以使用按钮。 它们可能在不同的位置，但在上图中，这些按钮在左下角。</p><h2 id="Home（主页）"><a href="#Home（主页）" class="headerlink" title="Home（主页）"></a><code>Home</code>（主页）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-ab1c99dc1ef372d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>一旦你开始浏览你的图表，主页按钮会帮助你。 如果你想要返回原始视图，可以单击它。 在浏览图表之前单击此按钮将不会生效。</p><h2 id="Forward-Back（前进-后退）"><a href="#Forward-Back（前进-后退）" class="headerlink" title="Forward/Back（前进/后退）"></a><code>Forward/Back</code>（前进/后退）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-99b6fdd250908e9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这些按钮可以像浏览器中的前进和后退按钮一样使用。 你可以单击这些来移回到你之前的位置，或再次前进。</p><h2 id="Pan（平移）"><a href="#Pan（平移）" class="headerlink" title="Pan（平移）"></a><code>Pan</code>（平移）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-38a450e6ab426002.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>你可以点击平移按钮，之后点击并拖拽你的图表。</p><h2 id="Zoom（缩放）"><a href="#Zoom（缩放）" class="headerlink" title="Zoom（缩放）"></a><code>Zoom</code>（缩放）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-986d4901b894c101.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>缩放按钮可让你单击它，然后单击并拖动出要放大的方形区域。 放大需要左键单击并拖动。 你也可以右键单击并拖动来缩小。</p><h2 id="Configure-Subplots（配置子图）"><a href="#Configure-Subplots（配置子图）" class="headerlink" title="Configure Subplots（配置子图）"></a><code>Configure Subplots</code>（配置子图）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-cf8ab1dd29554afc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>此按钮允许你对图形和绘图配置各种间距选项。 点击它会弹出：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-97d5ced902265b4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>每个蓝色条形都是一个滑块，它允许你调整内边距。 其中有些现在没有任何效果，因为没有任何其他子图。 前四个值调整图形到窗口边缘的边距。 之后<code>wspace</code>和<code>hspace</code>对应于当你绘制多个子图时，它们的水平或竖直间距。</p><h2 id="Save（保存）"><a href="#Save（保存）" class="headerlink" title="Save（保存）"></a><code>Save</code>（保存）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0e48f4e59778e08a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>此按钮允许你以各种形式保存图形。</p><p>所以这是 matplotlib 的快速介绍，我们之后会涉及更多。</p><h1 id="第二章-图例、标题和标签"><a href="#第二章-图例、标题和标签" class="headerlink" title="第二章 图例、标题和标签"></a>第二章 图例、标题和标签</h1><p>在本教程中，我们将讨论 Matplotlib 中的图例，标题和标签。 很多时候，图形可以不言自明，但是图形带有标题，轴域上的标签和图例，来解释每一行是什么非常必要。</p><blockquote><p>注：轴域（<code>Axes</code>）即两条坐标轴围城的区域。</p></blockquote><p>从这里开始：</p><pre><code>import matplotlib.pyplot as pltx = [1,2,3]y = [5,7,4]x2 = [1,2,3]y2 = [10,14,12]</code></pre><p>这样我们可以画出两个线条，接下来：</p><pre><code>plt.plot(x, y, label='First Line')plt.plot(x2, y2, label='Second Line')</code></pre><p>在这里，我们绘制了我们已经看到的东西，但这次我们添加另一个参数<code>label</code>。 这允许我们为线条指定名称，我们以后可以在图例中显示它。 我们的其余代码为：</p><pre><code>plt.xlabel('Plot Number')plt.ylabel('Important var')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p>使用<code>plt.xlabel</code>和<code>plt.ylabel</code>，我们可以为这些相应的轴创建标签。 接下来，我们可以使用<code>plt.title</code>创建图的标题，然后我们可以使用<code>plt.legend()</code>生成默认图例。 结果图如下：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-74fabfe13552bc2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第三章-条形图和直方图"><a href="#第三章-条形图和直方图" class="headerlink" title="第三章 条形图和直方图"></a>第三章 条形图和直方图</h1><p>这个教程中我们会涉及条形图和直方图。我们先来看条形图：</p><pre><code>import matplotlib.pyplot as pltplt.bar([1,3,5,7,9],[5,2,7,8,2], label="Example one")plt.bar([2,4,6,8,10],[8,6,2,5,6], label="Example two", color='g')plt.legend()plt.xlabel('bar number')plt.ylabel('bar height')plt.title('Epic Graph\nAnother Line! Whoa')plt.show()</code></pre><p><code>plt.bar</code>为我们创建条形图。 如果你没有明确选择一种颜色，那么虽然做了多个图，所有的条看起来会一样。 这让我们有机会使用一个新的 Matplotlib 自定义选项。 你可以在任何类型的绘图中使用颜色，例如<code>g</code>为绿色，<code>b</code>为蓝色，<code>r</code>为红色，等等。 你还可以使用十六进制颜色代码，如<code>#191970</code>。</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-52b8c12da35ac96d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>接下来，我们会讲解直方图。 直方图非常像条形图，倾向于通过将区段组合在一起来显示分布。 这个例子可能是年龄的分组，或测试的分数。 我们并不是显示每一组的年龄，而是按照 20 ~ 25，25 ~ 30… 等等来显示年龄。 这里有一个例子：</p><pre><code>import matplotlib.pyplot as pltpopulation_ages = [22,55,62,45,21,22,34,42,42,4,99,102,110,120,121,122,130,111,115,112,80,75,65,54,44,43,42,48]bins = [0,10,20,30,40,50,60,70,80,90,100,110,120,130]plt.hist(population_ages, bins, histtype='bar', rwidth=0.8)plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p>产生的图表为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-f9bc20699e3270fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>对于<code>plt.hist</code>，你首先需要放入所有的值，然后指定放入哪个桶或容器。 在我们的例子中，我们绘制了一堆年龄，并希望以 10 年的增量来显示它们。 我们将条形的宽度设为 0.8，但是如果你想让条形变宽，或者变窄，你可以选择其他的宽度。</p><h1 id="第四章-散点图"><a href="#第四章-散点图" class="headerlink" title="第四章 散点图"></a>第四章 散点图</h1><p>接下来，我们将介绍散点图。散点图通常用于比较两个变量来寻找相关性或分组，如果你在 3 维绘制则是 3 个。</p><p>散点图的一些示例代码：</p><pre><code>import matplotlib.pyplot as pltx = [1,2,3,4,5,6,7,8]y = [5,2,4,2,1,4,5,2]plt.scatter(x,y, label='skitscat', color='k', s=25, marker="o")plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-65aedb5516804258.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><code>plt.scatter</code>不仅允许我们绘制<code>x</code>和<code>y</code>，而且还可以让我们决定所使用的标记颜色，大小和类型。 有一堆标记选项，请参阅 <a href="https://link.jianshu.com?t=http://matplotlib.org/api/markers_api.html" target="_blank" rel="noopener">Matplotlib 标记文档</a>中的所有选项。</p><h1 id="第五章-堆叠图"><a href="#第五章-堆叠图" class="headerlink" title="第五章 堆叠图"></a>第五章 堆叠图</h1><p>在这篇 Matplotlib 数据可视化教程中，我们要介绍如何创建堆叠图。 堆叠图用于显示『部分对整体』随时间的关系。 堆叠图基本上类似于饼图，只是随时间而变化。</p><p>让我们考虑一个情况，我们一天有 24 小时，我们想看看我们如何花费时间。 我们将我们的活动分为：睡觉，吃饭，工作和玩耍。</p><p>我们假设我们要在 5 天的时间内跟踪它，因此我们的初始数据将如下所示：</p><pre><code>import matplotlib.pyplot as pltdays = [1,2,3,4,5]sleeping = [7,8,6,11,7]eating =   [2,3,4,3,2]working =  [7,8,7,2,2]playing =  [8,5,7,8,13]</code></pre><p>因此，我们的<code>x</code>轴将包括<code>day</code>变量，即 1, 2, 3, 4 和 5。然后，日期的各个成分保存在它们各自的活动中。 像这样绘制它们：</p><pre><code>plt.stackplot(days, sleeping,eating,working,playing, colors=['m','c','r','k'])plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-e840375ace5b8641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>在这里，我们可以至少在颜色上看到，我们如何花费我们的时间。 问题是，如果不回头看代码，我们不知道什么颜色是什么。 下一个问题是，对于多边形来说，我们实际上不能为数据添加『标签』。 因此，在任何不止是线条，带有像这样的填充或堆叠图的地方，我们不能以固有方式标记出特定的部分。 这不应该阻止程序员。 我们可以解决这个问题：</p><pre><code>import matplotlib.pyplot as pltdays = [1,2,3,4,5]sleeping = [7,8,6,11,7]eating =   [2,3,4,3,2]working =  [7,8,7,2,2]playing =  [8,5,7,8,13]plt.plot([],[],color='m', label='Sleeping', linewidth=5)plt.plot([],[],color='c', label='Eating', linewidth=5)plt.plot([],[],color='r', label='Working', linewidth=5)plt.plot([],[],color='k', label='Playing', linewidth=5)plt.stackplot(days, sleeping,eating,working,playing, colors=['m','c','r','k'])plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0e5233d43903c2a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>我们在这里做的是画一些空行，给予它们符合我们的堆叠图的相同颜色，和正确标签。 我们还使它们线宽为 5，使线条在图例中显得较宽。 现在，我们可以很容易地看到，我们如何花费我们的时间。</p><h1 id="第六章-饼图"><a href="#第六章-饼图" class="headerlink" title="第六章 饼图"></a>第六章 饼图</h1><p>饼图很像堆叠图，只是它们位于某个时间点。 通常，饼图用于显示部分对于整体的情况，通常以％为单位。 幸运的是，Matplotlib 会处理切片大小以及一切事情，我们只需要提供数值。</p><pre><code>import matplotlib.pyplot as pltslices = [7,2,2,13]activities = ['sleeping','eating','working','playing']cols = ['c','m','r','b']plt.pie(slices,        labels=activities,        colors=cols,        startangle=90,        shadow= True,        explode=(0,0.1,0,0),        autopct='%1.1f%%')plt.title('Interesting Graph\nCheck it out')plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-f22a951b92ef4824.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>在<code>plt.pie</code>中，我们需要指定『切片』，这是每个部分的相对大小。 然后，我们指定相应切片的颜色列表。 接下来，我们可以选择指定图形的『起始角度』。 这使你可以在任何地方开始绘图。 在我们的例子中，我们为饼图选择了 90 度角，这意味着第一个部分是一个竖直线条。 接下来，我们可以选择给绘图添加一个字符大小的阴影，然后我们甚至可以使用<code>explode</code>拉出一个切片。</p><p>我们总共有四个切片，所以对于<code>explode</code>，如果我们不想拉出任何切片，我们传入<code>0,0,0,0</code>。 如果我们想要拉出第一个切片，我们传入<code>0.1,0,0,0</code>。</p><p>最后，我们使用<code>autopct</code>，选择将百分比放置到图表上面。</p><h1 id="第七章-从文件加载数据"><a href="#第七章-从文件加载数据" class="headerlink" title="第七章 从文件加载数据"></a>第七章 从文件加载数据</h1><p>很多时候，我们想要绘制文件中的数据。 有许多类型的文件，以及许多方法，你可以使用它们从文件中提取数据来图形化。 在这里，我们将展示几种方法。 首先，我们将使用内置的<code>csv</code>模块加载CSV文件，然后我们将展示如何使用 NumPy（第三方模块）加载文件。</p><pre><code>import matplotlib.pyplot as pltimport csvx = []y = []with open('example.txt','r') as csvfile:    plots = csv.reader(csvfile, delimiter=',')    for row in plots:        x.append(int(row[0]))        y.append(int(row[1]))plt.plot(x,y, label='Loaded from file!')plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-5cdf1d5247930ab3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这里，我们打开样例文件，包含以下数据：</p><pre><code>1,52,33,44,75,46,37,58,79,410,4</code></pre><p>接下来，我们使用<code>csv</code>模块读取数据。 <code>csv</code>读取器自动按行分割文件，然后使用我们选择的分隔符分割文件中的数据。 在我们的例子中，这是一个逗号。 注意：<code>csv</code>模块和<code>csv reader</code>不需要文件在字面上是一个.csv文件。 它可以是任何具有分隔数据的简单的文本文件。</p><p>一旦我们这样做了，我们将索引为 0 的元素存储到<code>x</code>列表，将索引为 1 的元素存储到<code>y</code>列表中。 之后，我们都设置好了，准备绘图，然后显示数据。</p><p>虽然使用 CSV 模块是完全正常的，但使用 NumPy 模块来加载我们的文件和数据，可能对我们更有意义。 如果你没有 NumPy，你需要按下面的步骤来获取它。 为了了解安装模块的更多信息，请参阅 <a href="https://link.jianshu.com?t=http://pythonprogramming.net/using-pip-install-for-python-modules/" target="_blank" rel="noopener">pip 教程</a>。 大多数人应该都能打开命令行，并执行<code>pip install numpy</code>。</p><p>如果不能，请参阅链接中的教程。</p><p>一旦你安装了 NumPy，你可以编写如下代码：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npx, y = np.loadtxt('example.txt', delimiter=',', unpack=True)plt.plot(x,y, label='Loaded from file!')plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p>结果应该是相同的图表。 稍后，当我们加载数据时，我们可以利用 NumPy 为我们做一些更多的工作，但这是教程未来的内容。 就像<code>csv</code>模块不需要一个特地的<code>.csv</code>一样，<code>loadtxt</code>函数不要求文件是一个<code>.txt</code>文件，它可以是一个<code>.csv</code>，它甚至可以是一个 python 列表对象。</p><h1 id="第八章-从网络加载数据"><a href="#第八章-从网络加载数据" class="headerlink" title="第八章 从网络加载数据"></a>第八章 从网络加载数据</h1><p>除了从文件加载数据，另一个流行的数据源是互联网。 我们可以用各种各样的方式从互联网加载数据，但对我们来说，我们只是简单地读取网站的源代码，然后通过简单的拆分来分离数据。</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport matplotlib.dates as mdatesdef graph_data(stock):    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line:                stock_data.append(line)</code></pre><p>这里有很多步骤。首先，我们看到<code>import</code>。 <code>pyplot</code>像往常一样导入，然后导入了<code>numpy</code>，然后是用于访问互联网的<code>urllib</code>，然后导入了<code>matplotlib.dates</code>作为<code>mdates</code>，它对于将日期戳转换为 matplotlib 可以理解的日期很有用。</p><p>接下来，我们开始构建我们的<code>graph_data</code>函数。在这里，我们首先定义包含股票数据的网址。之后，我们写一些<code>urllib</code>代码来访问该 URL，然后使用<code>.read</code>读取源代码，之后我们继续解码该数据。如果你使用 Python 2，则不必使用<code>decode</code>。</p><p>然后，我们定义一个空列表，这是我们将要放置股票数据的地方，我们也开始使用<code>split_source</code>变量拆分数据，以换行符拆分。</p><p>现在，如果你去看源代码，用<code>stock</code>替换 URL 中的<code>+stock+</code>，像 AAPL 那样，你可以看到大多数页面数据确实是股票定价信息，但有一些头信息我们需要过滤掉。为此，我们使用一些基本的过滤，检查它们来确保每行有 6 个数据点，然后确保术语<code>values</code>不在行中。</p><p>现在，我们已经解析了数据，并做好了准备。我们将使用 NumPy：</p><pre><code>date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                      delimiter=',',                                                      unpack=True,                                                      # %Y = full year. 2015                                                      # %y = partial year 15                                                      # %m = number month                                                      # %d = number day                                                      # %H = hours                                                      # %M = minutes                                                      # %S = seconds                                                      # 12-06-2014                                                      # %m-%d-%Y                                                      converters={0: bytespdate2num('%Y%m%d')})</code></pre><p>我们在这里所做的是，使用<code>numpy</code>的<code>loadtxt</code>函数，并将这六个元素解构到六个变量。 这里的第一个参数是<code>stock_data</code>，这是我们加载的数据。 然后，我们指定<code>delimiter</code>（这里是逗号），然后我们指定我们确实想要在这里解包变量，不是一个变量，而是我们定义的这组变量。 最后，我们使用可选的<code>converters</code>参数来指定我们要转换的元素（<code>0</code>），以及我们打算要怎么做。 我们传递一个名为<code>bytespdate2num</code>的函数，它还不存在，但我们下面会编写它。</p><h1 id="第九章-时间戳的转换"><a href="#第九章-时间戳的转换" class="headerlink" title="第九章 时间戳的转换"></a>第九章 时间戳的转换</h1><p>本教程的重点是将来自 Yahoo finance API 的日期转换为 Matplotlib 可理解的日期。 为了实现它，我们要写一个新的函数，<code>bytespdate2num</code>。</p><pre><code>def bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverter</code></pre><p>此函数接受数据，基于编码来解码数据，然后返回它。</p><p>将此应用于我们的程序的其余部分：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          # %Y = full year. 2015                                                          # %y = partial year 15                                                          # %m = number month                                                          # %d = number day                                                          # %H = hours                                                          # %M = minutes                                                          # %S = seconds                                                          # 12-06-2014                                                          # %m-%d-%Y                                                          converters={0: bytespdate2num('%Y%m%d')})    plt.plot_date(date, closep,'-', label='Price')    plt.xlabel('Date')    plt.ylabel('Price')    plt.title('Interesting Graph\nCheck it out')    plt.legend()    plt.show()graph_data('TSLA')</code></pre><p>如果你绘制 TSLA，结果图应该看起来像这样：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-4ecbc2e94a4d3abc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第十章-基本的自定义"><a href="#第十章-基本的自定义" class="headerlink" title="第十章 基本的自定义"></a>第十章 基本的自定义</h1><p>在 Matplotlib 教程中，我们将讨论一些可能的图表自定义。 为了开始修改子图，我们必须定义它们。 我们很快会谈论他们，但有两种定义并构造子图的主要方法。 现在，我们只使用其中一个，但我们会很快解释它们。</p><p>现在，修改我们的<code>graph_data</code>函数：</p><pre><code>def graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))</code></pre><p>为了修改图表，我们需要引用它，所以我们将它存储到变量<code>fig</code>。 然后我们将<code>ax1</code>定义为图表上的子图。 我们在这里使用<code>subplot2grid</code>，这是获取子图的两种主要方法之一。 我们将深入讨论这些东西，但现在，你应该看到我们有 2 个元组，它们提供了<code>(1,1)</code>和<code>(0,0)</code>。 <code>1,1</code>表明这是一个 1×1 网格。 然后<code>0,0</code>表明这个子图的『起点』将为<code>0,0</code>。</p><p>接下来，通过我们已经编写的代码来获取和解析数据：</p><pre><code>stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'source_code = urllib.request.urlopen(stock_price_url).read().decode()stock_data = []split_source = source_code.split('\n')for line in split_source:    split_line = line.split(',')    if len(split_line) == 6:        if 'values' not in line and 'labels' not in line:            stock_data.append(line)date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                      delimiter=',',                                                      unpack=True,                                                      converters={0: bytespdate2num('%Y%m%d')})</code></pre><p>下面，我们这样绘制数据：</p><pre><code>ax1.plot_date(date, closep,'-', label='Price')</code></pre><p>现在，由于我们正在绘制日期，我们可能会发现，如果我们放大，日期会在水平方向上移动。但是，我们可以自定义这些刻度标签，像这样：</p><pre><code>for label in ax1.xaxis.get_ticklabels():    label.set_rotation(45)</code></pre><p>这将使标签转动到对角线方向。 接下来，我们可以添加一个网格：</p><pre><code>ax1.grid(True)</code></pre><p>然后，其它东西我们保留默认，但我们也可能需要略微调整绘图，因为日期跑到了图表外面。 记不记得我们在第一篇教程中讨论的<code>configure subplots</code>按钮？ 我们不仅可以以这种方式配置图表，我们还可以在代码中配置它们，以下是我们设置这些参数的方式：</p><pre><code>plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)</code></pre><p>现在，为了防止我们把你遗留在某个地方，这里是完整的代码：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    ax1.plot_date(date, closep,'-', label='Price')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.grid(True)#, color='g', linestyle='-', linewidth=5)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title('Interesting Graph\nCheck it out')    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('TSLA')</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-e13743e9a0142564.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第十一章-Unix-时间"><a href="#第十一章-Unix-时间" class="headerlink" title="第十一章 Unix 时间"></a>第十一章 Unix 时间</h1><p>在这个 Matplotlib 教程中，我们将介绍如何处理 unix 时间戳的转换，然后在图形中绘制日期戳。 使用 Yahoo Finance API，你会注意到，如果你使用较大的时间间隔，如<code>1y</code>（一年），你会得到我们一直在使用的日期戳，但如果你使用<code>10d</code>（10 天），反之你会得到 unix 时间的时间戳。</p><p>Unix 时间是 1970 年 1 月 1 日以后的秒数，它是跨程序的标准化时间表示方法。 也就是说，Matplotlib 并不欢迎 unix 时间戳。 这里是你可以使用 Matplotlib 来处理 unix 时间的方式：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10d/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True)    dateconv = np.vectorize(dt.datetime.fromtimestamp)    date = dateconv(date)##    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,##                                                          delimiter=',',##                                                          unpack=True,##                                                          converters={0: bytespdate2num('%Y%m%d')})    ax1.plot_date(date, closep,'-', label='Price')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.grid(True)#, color='g', linestyle='-', linewidth=5)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title('Interesting Graph\nCheck it out')    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('TSLA')</code></pre><p>所以在这里，我们所做的是 unix 时间的写入处理，并注释掉我们以前的代码，因为我们为之后的使用而保存它。 这里的主要区别是：</p><pre><code>dateconv = np.vectorize(dt.datetime.fromtimestamp)date = dateconv(date)</code></pre><p>这里，我们将时间戳转换为日期戳，然后将其转换为 Matplotlib 想要的时间。</p><p>现在，由于某些原因，我的 unix 时间带有另一行包含 6 个元素的数据，并且它包含了术语<code>label</code>，因此，在我们解析数据的<code>for</code>循环中，我们为你再添加一个需要注意的检查：</p><pre><code>for line in split_source:    split_line = line.split(',')    if len(split_line) == 6:        if 'values' not in line and 'labels' not in line:            stock_data.append(line)</code></pre><p>现在你的图表应该类似：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-4de0a34533b0fca1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这里的所有扁平线条的原因是市场关闭。 有了这个短期数据，我们可以得到日内数据。 所以交易开放时有很多点，然后市场关闭时就没有了，然后又是一堆，然后又是没有。</p><h1 id="第十二章-颜色和填充"><a href="#第十二章-颜色和填充" class="headerlink" title="第十二章 颜色和填充"></a>第十二章 颜色和填充</h1><p>在本教程中，我们将介绍一些更多的自定义，比如颜色和线条填充。</p><p>我们要做的第一个改动是将<code>plt.title</code>更改为<code>stock</code>变量。</p><pre><code>plt.title(stock)</code></pre><p>现在，让我们来介绍一下如何更改标签颜色。 我们可以通过修改我们的轴对象来实现：</p><pre><code>ax1.xaxis.label.set_color('c')ax1.yaxis.label.set_color('r')</code></pre><p>如果我们运行它，我们会看到标签改变了颜色，就像在单词中那样。</p><p>接下来，我们可以为要显示的轴指定具体数字，而不是像这样的自动选择：</p><pre><code>ax1.set_yticks([0,25,50,75])</code></pre><p>接下来，我想介绍填充。 填充所做的事情，是在变量和你选择的一个数值之间填充颜色。 例如，我们可以这样：</p><pre><code>ax1.fill_between(date, 0, closep)</code></pre><p>所以到这里，我们的代码为：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    ax1.fill_between(date, 0, closep)    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.grid(True)#, color='g', linestyle='-', linewidth=5)    ax1.xaxis.label.set_color('c')    ax1.yaxis.label.set_color('r')    ax1.set_yticks([0,25,50,75])    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-f2b03db492944c72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>填充的一个问题是，我们可能最后会把东西都覆盖起来。 我们可以用透明度来解决它：</p><pre><code>ax1.fill_between(date, 0, closep)</code></pre><p>现在，让我们介绍条件填充。 让我们假设图表的起始位置是我们开始买入 eBay 的地方。 这里，如果价格低于这个价格，我们可以向上填充到原来的价格，然后如果它超过了原始价格，我们可以向下填充。 我们可以这样做：</p><pre><code>ax1.fill_between(date, closep[0], closep)</code></pre><p>会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-57b56f07db5bece0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>如果我们想用红色和绿色填充来展示收益/损失，那么与原始价格相比，绿色填充用于上升（注：国外股市的颜色和国内相反），红色填充用于下跌？ 没问题！ 我们可以添加一个<code>where</code>参数，如下所示：</p><pre><code>ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5)</code></pre><p>这里，我们填充当前价格和原始价格之间的区域，其中当前价格高于原始价格。 我们给予它绿色的前景色，因为这是一个上升，而且我们使用微小的透明度。</p><p>我们仍然不能对多边形数据（如填充）应用标签，但我们可以像以前一样实现空线条，因此我们可以：</p><pre><code>ax1.plot([],[],linewidth=5, label='loss', color='r',alpha=0.5)ax1.plot([],[],linewidth=5, label='gain', color='g',alpha=0.5)ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5)ax1.fill_between(date, closep, closep[0],where=(closep &lt; closep[0]), facecolor='r', alpha=0.5)</code></pre><p>这向我们提供了一些填充，以及用于处理标签的空线条，我们打算将其显示在图例中。这里完整的代码是：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    ax1.plot_date(date, closep,'-', label='Price')    ax1.plot([],[],linewidth=5, label='loss', color='r',alpha=0.5)    ax1.plot([],[],linewidth=5, label='gain', color='g',alpha=0.5)    ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5)    ax1.fill_between(date, closep, closep[0],where=(closep &lt; closep[0]), facecolor='r', alpha=0.5)    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.grid(True)#, color='g', linestyle='-', linewidth=5)    ax1.xaxis.label.set_color('c')    ax1.yaxis.label.set_color('r')    ax1.set_yticks([0,25,50,75])    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>现在我们的结果是：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-069af451720b65f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第十三章-边框和水平线条"><a href="#第十三章-边框和水平线条" class="headerlink" title="第十三章 边框和水平线条"></a>第十三章 边框和水平线条</h1><p>欢迎阅读另一个定制教程，在这里我们使用 Matplotlib 讨论边框和水平线条。 有时候你可能想做的事情是改变边框的颜色，或者甚至完全删除它们。</p><p>图形的边框基本上是图形的边界，其中有刻度线等东西。为了改变边框的颜色，你可以做一些类似这样的事情：</p><pre><code>ax1.spines['left'].set_color('c')</code></pre><p>在这里，我们引用了我们的边框字典，表示我们要调整左边框，然后我们使用<code>set_color</code>方法将颜色设置为<code>'c'</code>，它是青色。</p><p>如果我们想删除所有边框怎么办？ 我们可以这样做：</p><pre><code>ax1.spines['right'].set_visible(False)ax1.spines['top'].set_visible(False)</code></pre><p>这是非常类似的代码，删除了右边框和上边框。</p><p>很难看到我们修改了左边框的颜色，所以让我们通过修改线宽来使它变得很明显：</p><pre><code>ax1.spines['left'].set_linewidth(5)</code></pre><p>现在，左边框变成了非常粗也非常显眼的青色。 最后，如果我们想修改刻度参数怎么办？ 假如不想要黑色的日期，我们想要一些橙色的日期？ 没问题！</p><pre><code>ax1.tick_params(axis='x', colors='#f06215')</code></pre><p>现在我们的日期是橙色了！ 接下来，让我们来看看我们如何绘制一条水平线。 你当然可以将你创建的一组新数据绘制成一条水平线，但你不需要这样做。 你可以：</p><pre><code>ax1.axhline(closep[0], color='k', linewidth=5)</code></pre><p>所以在这里，我们的整个代码是：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    ax1.plot_date(date, closep,'-', label='Price')    ax1.plot([],[],linewidth=5, label='loss', color='r',alpha=0.5)    ax1.plot([],[],linewidth=5, label='gain', color='g',alpha=0.5)    ax1.axhline(closep[0], color='k', linewidth=5)    ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5)    ax1.fill_between(date, closep, closep[0],where=(closep &lt; closep[0]), facecolor='r', alpha=0.5)    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.grid(True)    #ax1.xaxis.label.set_color('c')    #ax1.yaxis.label.set_color('r')    ax1.set_yticks([0,25,50,75])    ax1.spines['left'].set_color('c')    ax1.spines['right'].set_visible(False)    ax1.spines['top'].set_visible(False)    ax1.spines['left'].set_linewidth(5)    ax1.tick_params(axis='x', colors='#f06215')    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('ebay')</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-18c832847bc0f71c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第十四章-OHLC-K-线图"><a href="#第十四章-OHLC-K-线图" class="headerlink" title="第十四章 OHLC K 线图"></a>第十四章 OHLC K 线图</h1><p>在 Matplotlib 教程中，我们将介绍如何在 Matplotlib 中创建开，高，低，关（OHLC）的 K 线图。 这些图表用于以精简形式显示时间序列股价信息。 为了实现它，我们首先需要导入一些模块：</p><pre><code>import matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlc</code></pre><p>我们引入了<code>ticker</code>，允许我们修改图表底部的<code>ticker</code>信息。 然后我们从<code>matplotlib.finance</code>模块中引入<code>candlestick_ohlc</code>功能。</p><p>现在，我们需要组织我们的数据来和 matplotlib 协作。 如果你刚刚加入我们，我们得到的数据如下：</p><pre><code>stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv'source_code = urllib.request.urlopen(stock_price_url).read().decode()stock_data = []split_source = source_code.split('\n')for line in split_source:    split_line = line.split(',')    if len(split_line) == 6:        if 'values' not in line and 'labels' not in line:            stock_data.append(line)date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                      delimiter=',',                                                      unpack=True,                                                      converters={0: bytespdate2num('%Y%m%d')})</code></pre><p>现在，我们需要构建一个 Python 列表，其中每个元素都是数据。 我们可以修改我们的<code>loadtxt</code>函数，使其不解构，但随后我们还是希望引用特定的数据点。 我们可以解决这个问题，但是我们最后可能只拥有两个单独的数据集。 为此，我们执行以下操作：</p><pre><code>x = 0y = len(date)ohlc = []while x &lt; y:    append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]    ohlc.append(append_me)    x+=1</code></pre><p>有了这个，我们现在将 OHLC 数据列表存储到我们的变量<code>ohlc</code>。 现在我们可以这样绘制：</p><pre><code>candlestick_ohlc(ax1, ohlc)</code></pre><p>图表应该是这样：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-60ffe36a409afe6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>不幸的是，<code>x</code>轴上的<code>datetime</code>数据不是日期戳的形式。 我们可以处理它：</p><pre><code>ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))</code></pre><p>此外，红/黑着色依我看不是最好的选择。 我们应该使用绿色表示上升和红色表示下降。 为此，我们可以：</p><pre><code>candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')</code></pre><p>最后，我们可以将<code>x</code>标签设置为我们想要的数量，像这样：</p><pre><code>ax1.xaxis.set_major_locator(mticker.MaxNLocator(10))</code></pre><p>现在，完整代码现在是这样：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcimport numpy as npimport urllibimport datetime as dtdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax1.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax1.grid(True)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-4f2d9fb663f851cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>还要注意，我们从前面的教程中删除了大部分<code>ax1</code>的修改。</p><h1 id="第十五章-样式"><a href="#第十五章-样式" class="headerlink" title="第十五章 样式"></a>第十五章 样式</h1><p>在这个 Matplotlib 教程中，我们将讨论样式。 我们用于 Matplotlib 的样式非常相似于用于 HTML 页面的 CSS（层叠样式表）。 正如你在这里可以看到的，我们对图形所做的所有修改都会叠加，而且我们目前只有一个轴域。 我们可以使用<code>for</code>循环，至少使代码量降低，但我们也可以在 Matplotlib 中利用这些样式。</p><p>样式页的想法是将自定义样式写入文件，然后，为了使用这些更改并将其应用于图形，所有你需要做的就是导入样式，然后使用该特定样式。 这样，让我们假设你发现自己总是改变图形的各种元素。 你不必为每个图表编写 25 ~ 200 行自定义代码，只需将其写入一个样式，然后加载该样式，并以两行应用所有这些更改即可！ 让我们开始吧。</p><pre><code>from matplotlib import style</code></pre><p>接下来，我们指定要使用的样式。 Matplotlib 已经有了几种样式。</p><p>我们可以这样来使用样式：</p><pre><code>style.use('ggplot')</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-3ad2c87140de8855.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>除了标题，标签的颜色是灰色的，轴域的背景是浅灰色，我们可以立即分辨字体是不同的。 我们还注意到，网格实际上是一个白色的实线。 我们的 K 线图保持不变，主要是因为我们在事后定制它。 在样式中加载时，更改会生效，但如果在加载样式后编写新的自定义代码，你的更改也会生效。</p><p>因为我们试图展示样式模块，但是让我们继续，简单绘制几行，并暂且注释掉 K 线图：</p><pre><code>#candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')ax1.plot(date,closep)ax1.plot(date,openp)</code></pre><p>会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-8fa5b684a13eb408.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>已经比默认值好多了！</p><p>样式的另一个例子是<code>fivethirtyeight</code>：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-390e540781b5f0de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>你可以这样查看所有的可用样式：</p><pre><code>print(plt.style.available)</code></pre><p>我这里它提供了<code>['bmh', 'dark_background', 'ggplot', 'fivethirtyeight', 'grayscale']</code>。</p><p>让我们尝试<code>dark_background</code>：</p><pre><code>style.use('dark_background')</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-040521aa581616e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>现在，如果你想制作自己的风格呢？ 首先，你需要找到样式目录。 为了实现它，如果你知道它在哪里，你可以前往你的 matplotlib 目录，或者你可以找到该目录。 如果你不知道如何找到该目录，你可以执行以下操作：</p><pre><code>print(plt.__file__)</code></pre><p>这至少会告诉你<code>pyplot</code>模块的位置。</p><p>在 matplotlib 目录中，你需要寻找<code>mpl-data</code>。 然后在那里，你需要寻找<code>stylelib</code>。 在 Windows 上 ，我的完整路径是：<code>C:\Python34\Lib\site-packages\matplotlib\mpl-data\stylelib</code>。</p><p>那里应该显示了所有可用的<code>.mplstyle</code>文件。 你可以编辑、复制或重命名它们，然后在那里修改为你想要的东西。 然后，无论你用什么来命名<code>.mplstyle</code>文件，都要放在<code>style.use</code>中。</p><h1 id="第十六章-实时图表"><a href="#第十六章-实时图表" class="headerlink" title="第十六章 实时图表"></a>第十六章 实时图表</h1><p>在这篇 Matplotlib 教程中，我们将介绍如何创建实时更新图表，可以在数据源更新时更新其图表。 你可能希望将此用于绘制股票实时定价数据，或者可以将传感器连接到计算机，并且显示传感器实时数据。 为此，我们使用 Matplotlib 的动画功能。</p><p>最开始：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.animation as animationfrom matplotlib import style</code></pre><p>这里，唯一的新增导入是<code>matplotlib.animation as animation</code>。 这是一个模块，允许我们在显示之后对图形进行动画处理。</p><p>接下来，我们添加一些你熟悉的代码，如果你一直关注这个系列：</p><pre><code>style.use('fivethirtyeight')fig = plt.figure()ax1 = fig.add_subplot(1,1,1)</code></pre><p>现在我们编写动画函数：</p><pre><code>def animate(i):    graph_data = open('example.txt','r').read()    lines = graph_data.split('\n')    xs = []    ys = []    for line in lines:        if len(line) &gt; 1:            x, y = line.split(',')            xs.append(x)            ys.append(y)    ax1.clear()    ax1.plot(xs, ys)</code></pre><p>我们在这里做的是构建数据，然后绘制它。 注意我们这里不调用<code>plt.show()</code>。 我们从一个示例文件读取数据，其内容如下：</p><pre><code>1,52,33,44,75,46,37,58,79,410,4</code></pre><p>我们打开上面的文件，然后存储每一行，用逗号分割成<code>xs</code>和<code>ys</code>，我们将要绘制它。 然后：</p><pre><code>ani = animation.FuncAnimation(fig, animate, interval=1000)plt.show()</code></pre><p>我们运行动画，将动画放到图表中（<code>fig</code>），运行<code>animate</code>的动画函数，最后我们设置了 1000 的间隔，即 1000 毫秒或 1 秒。</p><p>运行此图表的结果应该像往常一样生成图表。 然后，你应该能够使用新的坐标更新<code>example.txt</code>文件。 这样做会生成一个自动更新的图表，如下：</p><p>[图片上传失败…(image-3aca35-1558443769838)]</p><h1 id="第十七章-注解和文本"><a href="#第十七章-注解和文本" class="headerlink" title="第十七章 注解和文本"></a>第十七章 注解和文本</h1><p>在本教程中，我们将讨论如何向 Matplotlib 图形添加文本。 我们可以通过两种方式来实现。 一种是将文本放置在图表上的某个位置。 另一个是专门注解图表上的绘图，来引起注意。</p><p>这里的起始代码是教程 15，它在这里：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)def bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax1.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax1.grid(True)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('ebay')</code></pre><p>所以这里是 Yahoo Finance API 的 eBay 的 OHLC K 线图。 这里我们要讲解的第一件事是向图形添加文本。</p><pre><code>font_dict = {'family':'serif',             'color':'darkred',             'size':15}ax1.text(date[10], closep[1],'Text Example', fontdict=font_dict)</code></pre><p>在这里，我们需要做一些事情。 首先，我们使用<code>ax1.text</code>添加文本。 我们使用我们的数据，以坐标形式给出此文本的位置。 首先给出文本的坐标，然后给出要放置的实际文本。 接下来，我们使用<code>fontdict</code>参数添加一个数据字典，来使用所用的字体。 在我们的字体字典中，我们将字体更改为<code>serif</code>，颜色为『深红色』，然后将字体大小更改为 15。这将全部应用于我们的图表上的文本，如下所示：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-31586a626a3d1952.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>太棒了，接下来我们可以做的是，注解某个特定的绘图。 我们希望这样做来给出更多的信息。 在 eBay 的例子中，也许我们想解释某个具体绘图，或给出一些关于发生了什么的信息。 在股价的例子中，也许有一些发生的新闻会影响价格。 你可以注解新闻来自哪里，这将有助于解释定价变化。</p><pre><code>ax1.annotate('Bad News!',(date[9],highp[9]),             xytext=(0.8, 0.9), textcoords='axes fraction',             arrowprops = dict(facecolor='grey',color='grey'))</code></pre><p>这里，我们用<code>ax1.annotate</code>来注解。 我们首先传递我们想要注解的文本，然后传递我们让这个注解指向的坐标。 我们这样做，是因为当我们注释时，我们可以绘制线条和指向特定点的箭头。 接下来，我们指定<code>xytext</code>的位置。 它可以是像我们用于文本放置的坐标位置，但是让我们展示另一个例子。 它可以为轴域小数，所以我们使用 0.8 和 0.9。 这意味着文本的位置在<code>x</code>轴的80％和<code>y</code>轴的90％处。 这样，如果我们移动图表，文本将保持在相同位置。</p><p>执行它，会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-2693ab1290c82f96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>根据你学习这个教程的时间，所指向的点可能有所不同，这只是一个注解的例子，其中有一些合理的想法，即为什么我们需要注解一些东西。</p><p>当图表启动时，请尝试单击平移按钮（蓝色十字），然后移动图表。 你会看到文本保持不动，但箭头跟随移动并继续指向我们想要的具体的点。 这很酷吧！</p><p>最后一个图表的完整代码：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)def bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax1.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax1.grid(True)    ax1.annotate('Bad News!',(date[9],highp[9]),                 xytext=(0.8, 0.9), textcoords='axes fraction',                 arrowprops = dict(facecolor='grey',color='grey'))##    # Text placement example:##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    ax1.text(date[10], closep[1],'Text Example', fontdict=font_dict)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    #plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('ebay')</code></pre><p>现在，使用注解，我们可以做一些其他事情，如注解股票图表的最后价格。 这就是我们接下来要做的。</p><h1 id="第十八章-注解股票图表的最后价格"><a href="#第十八章-注解股票图表的最后价格" class="headerlink" title="第十八章 注解股票图表的最后价格"></a>第十八章 注解股票图表的最后价格</h1><p>在这个 Matplotlib 教程中，我们将展示如何跟踪股票的最后价格的示例，通过将其注解到轴域的右侧，就像许多图表应用程序会做的那样。</p><p>虽然人们喜欢在他们的实时图表中看到历史价格，他们也想看到最新的价格。 大多数应用程序做的是，在价格的<code>y</code>轴高度处注释最后价格，然后突出显示它，并在价格变化时，在框中将其略微移动。 使用我们最近学习的注解教程，我们可以添加一个<code>bbox</code>。</p><p>我们的核心代码是：</p><pre><code>bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)ax1.annotate(str(closep[-1]), (date[-1], closep[-1]),             xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)</code></pre><p>我们使用<code>ax1.annotate</code>来放置最后价格的字符串值。 我们不在这里使用它，但我们将要注解的点指定为图上最后一个点。 接下来，我们使用<code>xytext</code>将我们的文本放置到特定位置。 我们将它的<code>y</code>坐标指定为最后一个点的<code>y</code>坐标，<code>x</code>坐标指定为最后一个点的<code>x</code>坐标，再加上几个点。我们这样做是为了将它移出图表。 将文本放在图形外面就足够了，但现在它只是一些浮动文本。</p><p>我们使用<code>bbox</code>参数在文本周围创建一个框。 我们使用<code>bbox_props</code>创建一个属性字典，包含盒子样式，然后是白色（<code>w</code>）前景色，黑色（<code>k</code>）边框颜色并且线宽为 1。 更多框样式请参阅 <a href="https://link.jianshu.com?t=http://matplotlib.org/users/annotations_guide.html" target="_blank" rel="noopener">matplotlib 注解文档</a>。</p><p>最后，这个注解向右移动，需要我们使用<code>subplots_adjust</code>来创建一些新空间：</p><pre><code>plt.subplots_adjust(left=0.11, bottom=0.24, right=0.87, top=0.90, wspace=0.2, hspace=0)</code></pre><p>这里的完整代码如下：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)def bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax1.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax1.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax1.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+3, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax1.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text##    ax1.text(date[10], closep[1],'Text Example', fontdict=font_dict)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    #plt.legend()    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.87, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-80de7ea61e49212b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第十九章-子图"><a href="#第十九章-子图" class="headerlink" title="第十九章 子图"></a>第十九章 子图</h1><p>在这个 Matplotlib 教程中，我们将讨论子图。 有两种处理子图的主要方法，用于在同一图上创建多个图表。 现在，我们将从一个干净的代码开始。 如果你一直关注这个教程，那么请确保保留旧的代码，或者你可以随时重新查看上一个教程的代码。</p><p>首先，让我们使用样式，创建我们的图表，然后创建一个随机创建示例绘图的函数：</p><pre><code>import randomimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use('fivethirtyeight')fig = plt.figure()def create_plots():    xs = []    ys = []    for i in range(10):        x = i        y = random.randrange(10)        xs.append(x)        ys.append(y)    return xs, ys</code></pre><p>现在，我们开始使用<code>add_subplot</code>方法创建子图：</p><pre><code>ax1 = fig.add_subplot(221)ax2 = fig.add_subplot(222)ax3 = fig.add_subplot(212)</code></pre><p>它的工作原理是使用 3 个数字，即：行数（<code>numRows</code>）、列数（<code>numCols</code>）和绘图编号（<code>plotNum</code>）。</p><p>所以，221 表示两行两列的第一个位置。222 是两行两列的第二个位置。最后，212 是两行一列的第二个位置。</p><pre><code>2x2：+-----+-----+|  1  |  2  |+-----+-----+|  3  |  4  |+-----+-----+2x1：+-----------+|     1     |+-----------+|     2     |+-----------+</code></pre><blockquote><p>译者注：原文此处表述有误，译文已更改。</p></blockquote><blockquote><p>译者注：<code>221</code>是缩写形式，仅在行数乘列数小于 10 时有效，否则要写成<code>2,2,1</code>。</p></blockquote><p>此代码结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-c927e9ad943f9c86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这就是<code>add_subplot</code>。 尝试一些你认为可能很有趣的配置，然后尝试使用<code>add_subplot</code>创建它们，直到你感到满意。</p><p>接下来，让我们介绍另一种方法，它是<code>subplot2grid</code>。</p><p>删除或注释掉其他轴域定义，然后添加：</p><pre><code>ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1)ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1)</code></pre><p>所以，<code>add_subplot</code>不能让我们使一个绘图覆盖多个位置。 但是这个新的<code>subplot2grid</code>可以。 所以，<code>subplot2grid</code>的工作方式是首先传递一个元组，它是网格形状。 我们传递了<code>(6,1)</code>，这意味着整个图表分为六行一列。 下一个元组是左上角的起始点。 对于<code>ax1</code>，这是<code>0,0</code>，因此它起始于顶部。 接下来，我们可以选择指定<code>rowspan</code>和<code>colspan</code>。 这是轴域所占的行数和列数。</p><pre><code>6x1：          colspan=1(0,0)   +-----------+        |    ax1    | rowspan=1(1,0)   +-----------+        |           |        |    ax2    | rowspan=4        |           |        |           |(5,0)   +-----------+        |    ax3    | rowspan=1        +-----------+</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-efd554f7f908c9fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>显然，我们在这里有一些重叠的问题，我们可以调整子图来处理它。</p><p>再次，尝试构思各种配置的子图，使用<code>subplot2grid</code>制作出来，直到你感到满意！</p><p>我们将继续使用<code>subplot2grid</code>，将它应用到我们已经逐步建立的代码中，我们将在下一个教程中继续。</p><h1 id="第二十一章-更多指标数据"><a href="#第二十一章-更多指标数据" class="headerlink" title="第二十一章 更多指标数据"></a>第二十一章 更多指标数据</h1><p>在这篇 Matplotlib 教程中，我们介绍了添加一些简单的函数来计算数据，以便我们填充我们的轴域。 一个是简单的移动均值，另一个是简单的价格 HML 计算。</p><p>这些新函数是：</p><pre><code>def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lows</code></pre><p>你不需要太过专注于理解移动均值的工作原理，我们只是对样本数据来计算它，以便可以学习更多自定义 Matplotlib 的东西。</p><p>我们还想在脚本顶部为移动均值定义一些值：</p><pre><code>MA1 = 10MA2 = 30</code></pre><p>下面，在我们的<code>graph_data</code>函数中：</p><pre><code>ma1 = moving_average(closep,MA1)ma2 = moving_average(closep,MA2)start = len(date[MA2-1:])h_l = list(map(high_minus_low, highp, lowp))</code></pre><p>在这里，我们计算两个移动均值和 HML。</p><p>我们还定义了一个『起始』点。 我们这样做是因为我们希望我们的数据排成一行。 例如，20 天的移动均值需要 20 个数据点。 这意味着我们不能在第 5 天真正计算 20 天的移动均值。 因此，当我们计算移动均值时，我们会失去一些数据。 为了处理这种数据的减法，我们使用起始变量来计算应该有多少数据。 这里，我们可以安全地使用<code>[-start:]</code>绘制移动均值，并且如果我们希望的话，对所有绘图进行上述步骤来排列数据。</p><p>接下来，我们可以在<code>ax1</code>上绘制 HML，通过这样：</p><pre><code>ax1.plot_date(date,h_l,'-')</code></pre><p>最后我们可以通过这样向<code>ax3</code>添加移动均值：</p><pre><code>ax3.plot(date[-start:], ma1[-start:])ax3.plot(date[-start:], ma2[-start:])</code></pre><p>我们的完整代码，包括增加我们所用的时间范围：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1)    plt.xlabel('Date')    plt.ylabel('Price')    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1)    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date,h_l,'-')    candlestick_ohlc(ax2, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax2.xaxis.get_ticklabels():        label.set_rotation(45)    ax2.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax2.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax3.plot(date[-start:], ma1[-start:])    ax3.plot(date[-start:], ma2[-start:])    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>代码效果如图：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-d289f6cde6d705de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第二十二章-自定义填充、修剪和清除"><a href="#第二十二章-自定义填充、修剪和清除" class="headerlink" title="第二十二章 自定义填充、修剪和清除"></a>第二十二章 自定义填充、修剪和清除</h1><p>欢迎阅读另一个 Matplotlib 教程！ 在本教程中，我们将清除图表，然后再做一些自定义。</p><p>我们当前的代码是：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1)    plt.xlabel('Date')    plt.ylabel('Price')    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1)    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date,h_l,'-')    candlestick_ohlc(ax2, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax2.xaxis.get_ticklabels():        label.set_rotation(45)    ax2.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax2.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax3.plot(date[-start:], ma1[-start:])    ax3.plot(date[-start:], ma2[-start:])    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>现在我认为向我们的移动均值添加自定义填充是一个很好的主意。 移动均值通常用于说明价格趋势。 这个想法是，你可以计算一个快速和一个慢速的移动均值。 一般来说，移动均值用于使价格变得『平滑』。 他们总是『滞后』于价格，但是我们的想法是计算不同的速度。 移动均值越大就越『慢』。 所以这个想法是，如果『较快』的移动均值超过『较慢』的均值，那么价格就会上升，这是一件好事。 如果较快的 MA 从较慢的 MA 下方穿过，则这是下降趋势并且通常被视为坏事。 我的想法是在快速和慢速 MA 之间填充，『上升』趋势为绿色，然后下降趋势为红色。 方法如下：</p><pre><code>ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                 where=(ma1[-start:] &lt; ma2[-start:]),                 facecolor='r', edgecolor='r', alpha=0.5)ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                 where=(ma1[-start:] &gt; ma2[-start:]),                 facecolor='g', edgecolor='g', alpha=0.5)</code></pre><p>下面，我们会碰到一些我们可解决的问题：</p><pre><code>ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))for label in ax3.xaxis.get_ticklabels():    label.set_rotation(45)plt.setp(ax1.get_xticklabels(), visible=False)plt.setp(ax2.get_xticklabels(), visible=False)</code></pre><p>这里，我们剪切和粘贴<code>ax2</code>日期格式，然后我们将<code>x</code>刻度标签设置为<code>false</code>，去掉它们！</p><p>我们还可以通过在轴域定义中执行以下操作，为每个轴域提供自定义标签：</p><pre><code>fig = plt.figure()ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)plt.title(stock)ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1)plt.xlabel('Date')plt.ylabel('Price')ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1)</code></pre><p>接下来，我们可以看到，我们<code>y</code>刻度有许多数字，经常互相覆盖。 我们也看到轴之间互相重叠。 我们可以这样：</p><pre><code>ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=5, prune='lower'))</code></pre><p>所以，这里发生的是，我们通过首先将<code>nbins</code>设置为 5 来修改我们的<code>y</code>轴对象。这意味着我们显示的标签最多为 5 个。然后我们还可以『修剪』标签，因此，在我们这里， 我们修剪底部标签，这会使它消失，所以现在不会有任何文本重叠。 我们仍然可能打算修剪<code>ax2</code>的顶部标签，但这里是我们目前为止的源代码：</p><p>当前的源码：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    plt.ylabel('H-L')    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1)    plt.ylabel('Price')    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1)    plt.ylabel('MAvgs')    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date,h_l,'-')    ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=5, prune='lower'))    candlestick_ohlc(ax2, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax3.plot(date[-start:], ma1[-start:], linewidth=1)    ax3.plot(date[-start:], ma2[-start:], linewidth=1)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &lt; ma2[-start:]),                     facecolor='r', edgecolor='r', alpha=0.5)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &gt; ma2[-start:]),                     facecolor='g', edgecolor='g', alpha=0.5)    ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))    for label in ax3.xaxis.get_ticklabels():        label.set_rotation(45)    plt.setp(ax1.get_xticklabels(), visible=False)    plt.setp(ax2.get_xticklabels(), visible=False)    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-228d950fb6e2a065.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>看起来好了一些，但是仍然有一些东西需要清除。</p><h1 id="第二十三章-共享-X-轴"><a href="#第二十三章-共享-X-轴" class="headerlink" title="第二十三章 共享 X 轴"></a>第二十三章 共享 X 轴</h1><p>在这个 Matplotlib 数据可视化教程中，我们将讨论<code>sharex</code>选项，它允许我们在图表之间共享<code>x</code>轴。将<code>sharex</code>看做『复制 x』也许更好。</p><p>在我们开始之前，首先我们要做些修剪并在另一个轴上设置最大刻度数，如下所示：</p><pre><code>ax2.yaxis.set_major_locator(mticker.MaxNLocator(nbins=7, prune='upper'))</code></pre><p>以及</p><pre><code>ax3.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='upper'))</code></pre><p>现在，让我们共享所有轴域之间的<code>x</code>轴。 为此，我们需要将其添加到轴域定义中：</p><pre><code>fig = plt.figure()ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)plt.title(stock)plt.ylabel('H-L')ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1, sharex=ax1)plt.ylabel('Price')ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1, sharex=ax1)plt.ylabel('MAvgs')</code></pre><p>上面，对于<code>ax2</code>和<code>ax3</code>，我们添加一个新的参数，称为<code>sharex</code>，然后我们说，我们要与<code>ax1</code>共享<code>x</code>轴。</p><p>使用这种方式，我们可以加载图表，然后我们可以放大到一个特定的点，结果将是这样：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-5edfc228b965924d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>所以这意味着所有轴域沿着它们的<code>x</code>轴一起移动。 这很酷吧！</p><p>接下来，让我们将<code>[-start:]</code>应用到所有数据，所以所有轴域都起始于相同地方。 我们最终的代码为：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    plt.ylabel('H-L')    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1, sharex=ax1)    plt.ylabel('Price')    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1, sharex=ax1)    plt.ylabel('MAvgs')    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date[-start:],h_l[-start:],'-')    ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='lower'))    candlestick_ohlc(ax2, ohlc[-start:], width=0.4, colorup='#77d879', colordown='#db3f3f')    ax2.yaxis.set_major_locator(mticker.MaxNLocator(nbins=7, prune='upper'))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax3.plot(date[-start:], ma1[-start:], linewidth=1)    ax3.plot(date[-start:], ma2[-start:], linewidth=1)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &lt; ma2[-start:]),                     facecolor='r', edgecolor='r', alpha=0.5)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &gt; ma2[-start:]),                     facecolor='g', edgecolor='g', alpha=0.5)    ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax3.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='upper'))    for label in ax3.xaxis.get_ticklabels():        label.set_rotation(45)    plt.setp(ax1.get_xticklabels(), visible=False)    plt.setp(ax2.get_xticklabels(), visible=False)    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>下面我们会讨论如何创建多个<code>y</code>轴。</p><h1 id="第二十四章-多个-Y-轴"><a href="#第二十四章-多个-Y-轴" class="headerlink" title="第二十四章 多个 Y 轴"></a>第二十四章 多个 Y 轴</h1><p>在这篇 Matplotlib 教程中，我们将介绍如何在同一子图上使用多个 Y 轴。 在我们的例子中，我们有兴趣在同一个图表及同一个子图上绘制股票价格和交易量。</p><p>为此，首先我们需要定义一个新的轴域，但是这个轴域是<code>ax2</code>仅带有<code>x</code>轴的『双生子』。</p><p>这足以创建轴域了。我们叫它<code>ax2v</code>，因为这个轴域是<code>ax2</code>加交易量。</p><p>现在，我们在轴域上定义绘图，我们将添加：</p><pre><code>ax2v.fill_between(date[-start:],0, volume[-start:], facecolor='#0079a3', alpha=0.4)</code></pre><p>我们在 0 和当前交易量之间填充，给予它蓝色的前景色，然后给予它一个透明度。 我们想要应用幽冥毒，以防交易量最终覆盖其它东西，所以我们仍然可以看到这两个元素。</p><p>所以，到现在为止，我们的代码为：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    plt.ylabel('H-L')    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1, sharex=ax1)    plt.ylabel('Price')    ax2v = ax2.twinx()    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1, sharex=ax1)    plt.ylabel('MAvgs')    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date[-start:],h_l[-start:],'-')    ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='lower'))    candlestick_ohlc(ax2, ohlc[-start:], width=0.4, colorup='#77d879', colordown='#db3f3f')    ax2.yaxis.set_major_locator(mticker.MaxNLocator(nbins=7, prune='upper'))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax2v.fill_between(date[-start:],0, volume[-start:], facecolor='#0079a3', alpha=0.4)    ax3.plot(date[-start:], ma1[-start:], linewidth=1)    ax3.plot(date[-start:], ma2[-start:], linewidth=1)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &lt; ma2[-start:]),                     facecolor='r', edgecolor='r', alpha=0.5)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &gt; ma2[-start:]),                     facecolor='g', edgecolor='g', alpha=0.5)    ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax3.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='upper'))    for label in ax3.xaxis.get_ticklabels():        label.set_rotation(45)    plt.setp(ax1.get_xticklabels(), visible=False)    plt.setp(ax2.get_xticklabels(), visible=False)    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('GOOG')</code></pre><p>会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0afba1786b413e08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>太棒了，到目前为止还不错。 接下来，我们可能要删除新<code>y</code>轴上的标签，然后我们也可能不想让交易量占用太多空间。 没问题：</p><p>首先：</p><pre><code>ax2v.axes.yaxis.set_ticklabels([])</code></pre><p>上面将<code>y</code>刻度标签设置为一个空列表，所以不会有任何标签了。</p><blockquote><p>译者注：所以将标签删除之后，添加新轴的意义是什么？直接在原轴域上绘图就可以了。</p></blockquote><p>接下来，我们可能要将网格设置为<code>false</code>，使轴域上不会有双网格：</p><pre><code>ax2v.grid(False)</code></pre><p>最后，为了处理交易量占用很多空间，我们可以做以下操作：</p><pre><code>ax2v.set_ylim(0, 3*volume.max())</code></pre><p>所以这设置<code>y</code>轴显示范围从 0 到交易量的最大值的 3 倍。 这意味着，在最高点，交易量最多可占据图形的33％。 所以，增加<code>volume.max</code>的倍数越多，空间就越小/越少。</p><p>现在，我们的图表为：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    plt.ylabel('H-L')    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1, sharex=ax1)    plt.ylabel('Price')    ax2v = ax2.twinx()    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1, sharex=ax1)    plt.ylabel('MAvgs')    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date[-start:],h_l[-start:],'-')    ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='lower'))    candlestick_ohlc(ax2, ohlc[-start:], width=0.4, colorup='#77d879', colordown='#db3f3f')    ax2.yaxis.set_major_locator(mticker.MaxNLocator(nbins=7, prune='upper'))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+5, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax2v.fill_between(date[-start:],0, volume[-start:], facecolor='#0079a3', alpha=0.4)    ax2v.axes.yaxis.set_ticklabels([])    ax2v.grid(False)    ax2v.set_ylim(0, 3*volume.max())    ax3.plot(date[-start:], ma1[-start:], linewidth=1)    ax3.plot(date[-start:], ma2[-start:], linewidth=1)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &lt; ma2[-start:]),                     facecolor='r', edgecolor='r', alpha=0.5)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &gt; ma2[-start:]),                     facecolor='g', edgecolor='g', alpha=0.5)    ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax3.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='upper'))    for label in ax3.xaxis.get_ticklabels():        label.set_rotation(45)    plt.setp(ax1.get_xticklabels(), visible=False)    plt.setp(ax2.get_xticklabels(), visible=False)    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('GOOG')</code></pre><p>到这里，我们差不多完成了。 这里唯一的缺陷是一个好的图例。 一些线条是显而易见的，但人们可能会好奇移动均值的参数是什么，我们这里是 10 和 30。 添加自定义图例是下一个教程中涉及的内容。</p><h1 id="第二十五章-自定义图例"><a href="#第二十五章-自定义图例" class="headerlink" title="第二十五章 自定义图例"></a>第二十五章 自定义图例</h1><p>在这篇 Matplotlib 教程中，我们将讨论自定义图例。 我们已经介绍了<a href="https://link.jianshu.com?t=http://pythonprogramming.net/legends-titles-labels-matplotlib-tutorial/" target="_blank" rel="noopener">添加图例的基础知识</a>。</p><p>图例的主要问题通常是图例阻碍了数据的展示。 这里有几个选项。 一个选项是将图例放在轴域外，但是我们在这里有多个子图，这是非常困难的。 相反，我们将使图例稍微小一点，然后应用一个透明度。</p><p>首先，为了创建一个图例，我们需要向我们的数据添加我们想要显示在图例上的标签。</p><pre><code>ax1.plot_date(date[-start:],h_l[-start:],'-', label='H-L')...ax2v.plot([],[], color='#0079a3', alpha=0.4, label='Volume')...ax3.plot(date[-start:], ma1[-start:], linewidth=1, label=(str(MA1)+'MA'))ax3.plot(date[-start:], ma2[-start:], linewidth=1, label=(str(MA2)+'MA'))</code></pre><p>请注意，我们通过创建空行为交易量添加了标签。 请记住，我们不能对任何填充应用标签，所以这就是我们添加这个空行的原因。</p><p>现在，我们可以在右下角添加图例，通过在<code>plt.show()</code>之前执行以下操作：</p><pre><code>ax1.legend()ax2v.legend()ax3.legend()</code></pre><p>会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-8ed0949ea9e20edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>所以，我们可以看到，图例还是占用了一些位置。 让我们更改位置，大小并添加透明度：</p><pre><code>ax1.legend()leg = ax1.legend(loc=9, ncol=2,prop={'size':11})leg.get_frame().set_alpha(0.4)ax2v.legend()leg = ax2v.legend(loc=9, ncol=2,prop={'size':11})leg.get_frame().set_alpha(0.4)ax3.legend()leg = ax3.legend(loc=9, ncol=2,prop={'size':11})leg.get_frame().set_alpha(0.4)</code></pre><p>所有的图例位于位置 9（上中间）。 有很多地方可放置图例，我们可以为参数传入不同的位置号码，来看看它们都位于哪里。 <code>ncol</code>参数允许我们指定图例中的列数。 这里只有一列，如果图例中有 2 个项目，他们将堆叠在一列中。 最后，我们将尺寸规定为更小。 之后，我们对整个图例应用<code>0.4</code>的透明度。</p><p>现在我们的结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-395f6c13913c7a53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>完整的代码为：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure(facecolor='#f0f0f0')    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    plt.ylabel('H-L')    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1, sharex=ax1)    plt.ylabel('Price')    ax2v = ax2.twinx()    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1, sharex=ax1)    plt.ylabel('MAvgs')    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date[-start:],h_l[-start:],'-', label='H-L')    ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='lower'))    candlestick_ohlc(ax2, ohlc[-start:], width=0.4, colorup='#77d879', colordown='#db3f3f')    ax2.yaxis.set_major_locator(mticker.MaxNLocator(nbins=7, prune='upper'))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax2v.plot([],[], color='#0079a3', alpha=0.4, label='Volume')    ax2v.fill_between(date[-start:],0, volume[-start:], facecolor='#0079a3', alpha=0.4)    ax2v.axes.yaxis.set_ticklabels([])    ax2v.grid(False)    ax2v.set_ylim(0, 3*volume.max())    ax3.plot(date[-start:], ma1[-start:], linewidth=1, label=(str(MA1)+'MA'))    ax3.plot(date[-start:], ma2[-start:], linewidth=1, label=(str(MA2)+'MA'))    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &lt; ma2[-start:]),                     facecolor='r', edgecolor='r', alpha=0.5)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &gt; ma2[-start:]),                     facecolor='g', edgecolor='g', alpha=0.5)    ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax3.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='upper'))    for label in ax3.xaxis.get_ticklabels():        label.set_rotation(45)    plt.setp(ax1.get_xticklabels(), visible=False)    plt.setp(ax2.get_xticklabels(), visible=False)    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    ax1.legend()    leg = ax1.legend(loc=9, ncol=2,prop={'size':11})    leg.get_frame().set_alpha(0.4)    ax2v.legend()    leg = ax2v.legend(loc=9, ncol=2,prop={'size':11})    leg.get_frame().set_alpha(0.4)    ax3.legend()    leg = ax3.legend(loc=9, ncol=2,prop={'size':11})    leg.get_frame().set_alpha(0.4)    plt.show()    fig.savefig('google.png', facecolor=fig.get_facecolor())graph_data('GOOG')</code></pre><p>现在我们可以看到图例，但也看到了图例下的任何信息。 还要注意额外函数<code>fig.savefig</code>。 这是自动保存图形的图像的方式。 我们还可以设置所保存的图形的前景色，使背景不是白色的，如我们的例子所示。</p><p>这就是目前为止，我想要显示的典型 Matplotlib 图表。 接下来，我们将涉及<code>Basemap</code>，它是一个 Matplotlib 扩展，用于绘制地理位置，然后我打算讲解 Matplotlib 中的 3D 图形。</p><h1 id="第二十六章-Basemap-地理绘图"><a href="#第二十六章-Basemap-地理绘图" class="headerlink" title="第二十六章 Basemap 地理绘图"></a>第二十六章 Basemap 地理绘图</h1><p>在这个 Matplotlib 教程中，我们将涉及地理绘图模块<code>Basemap</code>。 <code>Basemap</code>是 Matplotlib 的扩展。</p><p>为了使用<code>Basemap</code>，我们首先需要安装它。 为了获得<code>Basemap</code>，你可以从这里获取：<a href="https://link.jianshu.com?t=http://matplotlib.org/basemap/users/download.html" target="_blank" rel="noopener">http://matplotlib.org/basemap/users/download.html</a>，或者你可以访问<a href="https://link.jianshu.com?t=http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a>。</p><p>如果你在安装<code>Basemap</code>时遇到问题，请查看<a href="https://link.jianshu.com?t=http://pythonprogramming.net/using-pip-install-for-python-modules/" target="_blank" rel="noopener"><code>pip</code>安装教程</a>。</p><p>一旦你安装了<code>Basemap</code>，你就可以创建地图了。 首先，让我们投影一个简单的地图。 为此，我们需要导入<code>Basemap</code>，<code>pyplot</code>，创建投影，至少绘制某种轮廓或数据，然后我们可以显示图形。</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill')m.drawcoastlines()plt.show()</code></pre><p>上面的代码结果如下：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-569ad48f57937c8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这是使用 Miller 投影完成的，这只是许多<a href="https://link.jianshu.com?t=http://matplotlib.org/basemap/users/mapsetup.html" target="_blank" rel="noopener"><code>Basemap</code>投影选项</a>之一。</p><h1 id="第二十七章-Basemap-自定义"><a href="#第二十七章-Basemap-自定义" class="headerlink" title="第二十七章 Basemap 自定义"></a>第二十七章 Basemap 自定义</h1><p>在这篇 Matplotlib 教程中，我们继续使用<code>Basemap</code>地理绘图扩展。 我们将展示一些我们可用的自定义选项。</p><p>首先，从上一个教程中获取我们的起始代码：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill')m.drawcoastlines()plt.show()</code></pre><p>我们可以从放大到特定区域来开始：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill',            llcrnrlat = -40,            llcrnrlon = -40,            urcrnrlat = 50,            urcrnrlon = 75)m.drawcoastlines()plt.show()</code></pre><p>这里的参数是：</p><ul><li><code>llcrnrlat</code> - 左下角的纬度</li><li><code>llcrnrlon</code> - 左下角的经度</li><li><code>urcrnrlat</code> - 右上角的纬度</li><li><code>urcrnrlon</code> - 右上角的经度</li></ul><p>此外，坐标需要转换，其中西经和南纬坐标是负值，北纬和东经坐标是正值。</p><p>使用这些坐标，<code>Basemap</code>会选择它们之间的区域。</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-05da7c940b2df3ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>下面，我们要使用一些东西，类似：</p><pre><code>m.drawcountries(linewidth=2)</code></pre><p>这会画出国家，并使用线宽为 2 的线条生成分界线。</p><p>另一个选项是：</p><pre><code>m.drawstates(color='b')</code></pre><p>这会用蓝色线条画出州。</p><p>你也可以执行：</p><pre><code>m.drawcounties(color='darkred')</code></pre><p>这会画出国家。</p><p>所以，我们的代码是：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill',            llcrnrlat = -90,            llcrnrlon = -180,            urcrnrlat = 90,            urcrnrlon = 180)m.drawcoastlines()m.drawcountries(linewidth=2)m.drawstates(color='b')m.drawcounties(color='darkred')plt.title('Basemap Tutorial')plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0defc2500a817a8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>很难说，但我们定义了美国的区县的线条。 我们可以使用放大镜放大<code>Basemap</code>图形，就像其他图形那样，会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a7a79fe24a963910.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>另一个有用的选项是<code>Basemap</code>调用中的『分辨率』选项。</p><pre><code>m = Basemap(projection='mill',            llcrnrlat = -90,            llcrnrlon = -180,            urcrnrlat = 90,            urcrnrlon = 180,            resolution='l')</code></pre><p>分辨率的选项为：</p><ul><li><code>c</code> - 粗糙</li><li><code>l</code> - 低</li><li><code>h</code> - 高</li><li><code>f</code> - 完整</li></ul><p>对于更高的分辨率，你应该放大到很大，否则这可能只是浪费。</p><p>另一个选项是使用<code>etopo()</code>绘制地形，如：</p><pre><code>m.etopo()</code></pre><p>使用<code>drawcountries</code>方法绘制此图形会生成：</p><p>[图片上传失败…(image-eaca82-1558445064342)]</p><p>最后，有一个蓝色的大理石版本，你可以调用：</p><pre><code>m.bluemarble()</code></pre><p>会生成：</p><p>[图片上传失败…(image-3f9978-1558445064342)]</p><p>目前为止的代码：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill',            llcrnrlat = -90,            llcrnrlon = -180,            urcrnrlat = 90,            urcrnrlon = 180,            resolution='l')m.drawcoastlines()m.drawcountries(linewidth=2)##m.drawstates(color='b')##m.drawcounties(color='darkred')#m.fillcontinents()#m.etopo()m.bluemarble()plt.title('Basemap Tutorial')plt.show()</code></pre><h1 id="第二十八章-在-Basemap-中绘制坐标"><a href="#第二十八章-在-Basemap-中绘制坐标" class="headerlink" title="第二十八章 在 Basemap 中绘制坐标"></a>第二十八章 在 Basemap 中绘制坐标</h1><p>欢迎阅读另一个 Matplotlib Basemap 教程。 在本教程中，我们将介绍如何绘制单个坐标，以及如何在地理区域中连接这些坐标。</p><p>首先，我们将从一些基本的起始数据开始：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill',            llcrnrlat = 25,            llcrnrlon = -130,            urcrnrlat = 50,            urcrnrlon = -60,            resolution='l')m.drawcoastlines()m.drawcountries(linewidth=2)m.drawstates(color='b')</code></pre><p>接下来，我们可以绘制坐标，从获得它们的实际坐标开始。 记住，南纬和西经坐标需要转换为负值。 例如，纽约市是北纬<code>40.7127</code>西经<code>74.0059</code>。 我们可以在我们的程序中定义这些坐标，如：</p><pre><code>NYClat, NYClon = 40.7127, -74.0059</code></pre><p>之后我们将这些转换为要绘制的<code>x</code>和<code>y</code>坐标。</p><pre><code>xpt, ypt = m(NYClon, NYClat)</code></pre><p>注意这里，我们现在已经将坐标顺序翻转为<code>lon, lat</code>（纬度，经度）。 坐标通常以<code>lat, lon</code>顺序给出。 然而，在图形中，<code>lat, long</code>转换为<code>y, x</code>，我们显然不需要。 在某些时候，你必须翻转它们。 不要忘记这部分！</p><p>最后，我们可以绘制如下的坐标：</p><pre><code>m.plot(xpt, ypt, 'c*', markersize=15)</code></pre><p>这个图表上有一个青色的星，大小为 15。更多标记类型请参阅：<a href="https://link.jianshu.com?t=http://matplotlib.org/api/markers_api.html" target="_blank" rel="noopener">Matplotlib 标记文档</a>。</p><p>接下来，让我们再画一个位置，洛杉矶，加利福尼亚：</p><pre><code>LAlat, LAlon = 34.05, -118.25xpt, ypt = m(LAlon, LAlat)m.plot(xpt, ypt, 'g^', markersize=15)</code></pre><p>这次我们画出一个绿色三角，执行代码会生成：</p><p>[图片上传失败…(image-8e5eff-1558445064342)]</p><p>如果我们想连接这些图块怎么办？原来，我们可以像其它 Matplotlib 图表那样实现它。</p><p>首先，我们将那些<code>xpt</code>和<code>ypt</code>坐标保存到列表，类似这样的东西：</p><pre><code>xs = []ys = []NYClat, NYClon = 40.7127, -74.0059xpt, ypt = m(NYClon, NYClat)xs.append(xpt)ys.append(ypt)m.plot(xpt, ypt, 'c*', markersize=15)LAlat, LAlon = 34.05, -118.25xpt, ypt = m(LAlon, LAlat)xs.append(xpt)ys.append(ypt)m.plot(xpt, ypt, 'g^', markersize=15)m.plot(xs, ys, color='r', linewidth=3, label='Flight 98')</code></pre><p>会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-d8819d892b150a41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>太棒了。有时我们需要以圆弧连接图上的两个坐标。如何实现呢？</p><pre><code>m.drawgreatcircle(NYClon, NYClat, LAlon, LAlat, color='c', linewidth=3, label='Arc')</code></pre><p>我们的完整代码为：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill',            llcrnrlat = 25,            llcrnrlon = -130,            urcrnrlat = 50,            urcrnrlon = -60,            resolution='l')m.drawcoastlines()m.drawcountries(linewidth=2)m.drawstates(color='b')#m.drawcounties(color='darkred')#m.fillcontinents()#m.etopo()#m.bluemarble()xs = []ys = []NYClat, NYClon = 40.7127, -74.0059xpt, ypt = m(NYClon, NYClat)xs.append(xpt)ys.append(ypt)m.plot(xpt, ypt, 'c*', markersize=15)LAlat, LAlon = 34.05, -118.25xpt, ypt = m(LAlon, LAlat)xs.append(xpt)ys.append(ypt)m.plot(xpt, ypt, 'g^', markersize=15)m.plot(xs, ys, color='r', linewidth=3, label='Flight 98')m.drawgreatcircle(NYClon, NYClat, LAlon, LAlat, color='c', linewidth=3, label='Arc')plt.legend(loc=4)plt.title('Basemap Tutorial')plt.show()</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-865c2809f199d4c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这就是<code>Basemap</code>的全部了，下一章关于 Matplotlib 的 3D 绘图。</p><h1 id="第二十九章-3D-绘图"><a href="#第二十九章-3D-绘图" class="headerlink" title="第二十九章 3D 绘图"></a>第二十九章 3D 绘图</h1><p>您好，欢迎阅读 Matplotlib 教程中的 3D 绘图。 Matplotlib 已经内置了三维图形，所以我们不需要再下载任何东西。 首先，我们需要引入一些完整的模块：</p><pre><code>from mpl_toolkits.mplot3d import axes3dimport matplotlib.pyplot as plt</code></pre><p>使用<code>axes3d</code>是因为它需要不同种类的轴域，以便在三维中实际绘制一些东西。 下面：</p><pre><code>fig = plt.figure()ax1 = fig.add_subplot(111, projection='3d')</code></pre><p>在这里，我们像通常一样定义图形，然后我们将<code>ax1</code>定义为通常的子图，只是这次使用 3D 投影。 我们需要这样做，以便提醒 Matplotlib 我们要提供三维数据。</p><p>现在让我们创建一些 3D 数据：</p><pre><code>x = [1,2,3,4,5,6,7,8,9,10]y = [5,6,7,8,2,5,6,3,7,2]z = [1,2,6,3,2,7,3,3,7,2]</code></pre><p>接下来，我们绘制它。 首先，让我们展示一个简单的线框示例：</p><pre><code>ax1.plot_wireframe(x,y,z)</code></pre><p>最后：</p><pre><code>ax1.set_xlabel('x axis')ax1.set_ylabel('y axis')ax1.set_zlabel('z axis')plt.show()</code></pre><p>我们完整的代码是：</p><pre><code>from mpl_toolkits.mplot3d import axes3dimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use('fivethirtyeight')fig = plt.figure()ax1 = fig.add_subplot(111, projection='3d')x = [1,2,3,4,5,6,7,8,9,10]y = [5,6,7,8,2,5,6,3,7,2]z = [1,2,6,3,2,7,3,3,7,2]ax1.plot_wireframe(x,y,z)ax1.set_xlabel('x axis')ax1.set_ylabel('y axis')ax1.set_zlabel('z axis')plt.show()</code></pre><p>结果为（包括所用的样式）：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-9d239adc0dcb7a4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这些 3D 图形可以进行交互。 首先，您可以使用鼠标左键单击并拖动来移动图形。 您还可以使用鼠标右键单击并拖动来放大或缩小。</p><h1 id="第三十章-3D-散点图"><a href="#第三十章-3D-散点图" class="headerlink" title="第三十章 3D 散点图"></a>第三十章 3D 散点图</h1><p>欢迎阅读另一个 3D Matplotlib 教程，会涉及如何绘制三维散点图。</p><p>绘制 3D 散点图非常类似于通常的散点图以及 3D 线框图。</p><p>一个简单示例：</p><pre><code>from mpl_toolkits.mplot3d import axes3dimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use('ggplot')fig = plt.figure()ax1 = fig.add_subplot(111, projection='3d')x = [1,2,3,4,5,6,7,8,9,10]y = [5,6,7,8,2,5,6,3,7,2]z = [1,2,6,3,2,7,3,3,7,2]x2 = [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]y2 = [-5,-6,-7,-8,-2,-5,-6,-3,-7,-2]z2 = [1,2,6,3,2,7,3,3,7,2]ax1.scatter(x, y, z, c='g', marker='o')ax1.scatter(x2, y2, z2, c ='r', marker='o')ax1.set_xlabel('x axis')ax1.set_ylabel('y axis')ax1.set_zlabel('z axis')plt.show()</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a225497e6ca29fad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>要记住你可以修改这些绘图的大小和标记，就像通常的散点图那样。</p><h1 id="第三十一章-3D-条形图"><a href="#第三十一章-3D-条形图" class="headerlink" title="第三十一章 3D 条形图"></a>第三十一章 3D 条形图</h1><p>在这个 Matplotlib 教程中，我们要介绍 3D 条形图。 3D 条形图是非常独特的，因为它允许我们绘制多于 3 个维度。 不，你不能超过第三个维度来绘制，但你可以绘制多于 3 个维度。</p><p>对于条形图，你需要拥有条形的起点，条形的高度和宽度。 但对于 3D 条形图，你还有另一个选项，就是条形的深度。 大多数情况下，条形图从轴上的条形平面开始，但是你也可以通过打破此约束来添加另一个维度。 然而，我们会让它非常简单：</p><pre><code>from mpl_toolkits.mplot3d import axes3dimport matplotlib.pyplot as pltimport numpy as npfrom matplotlib import stylestyle.use('ggplot')fig = plt.figure()ax1 = fig.add_subplot(111, projection='3d')x3 = [1,2,3,4,5,6,7,8,9,10]y3 = [5,6,7,8,2,5,6,3,7,2]z3 = np.zeros(10)dx = np.ones(10)dy = np.ones(10)dz = [1,2,3,4,5,6,7,8,9,10]ax1.bar3d(x3, y3, z3, dx, dy, dz)ax1.set_xlabel('x axis')ax1.set_ylabel('y axis')ax1.set_zlabel('z axis')plt.show()</code></pre><p>注意这里，我们必须定义<code>x</code>、<code>y</code>和<code>z</code>，然后是 3 个维度的宽度、高度和深度。 这会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-f56fa917c5a3b201.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第三十二章-总结"><a href="#第三十二章-总结" class="headerlink" title="第三十二章 总结"></a>第三十二章 总结</h1><p>欢迎阅读最后的 Matplotlib 教程。 在这里我们将整理整个系列，并显示一个稍微更复杂的 3D 线框图：</p><pre><code>from mpl_toolkits.mplot3d import axes3dimport matplotlib.pyplot as pltimport numpy as npfrom matplotlib import stylestyle.use('ggplot')fig = plt.figure()ax1 = fig.add_subplot(111, projection='3d')x, y, z = axes3d.get_test_data()print(axes3d.__file__)ax1.plot_wireframe(x,y,z, rstride = 3, cstride = 3)ax1.set_xlabel('x axis')ax1.set_ylabel('y axis')ax1.set_zlabel('z axis')plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-ae3534e87f53f7f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>如果你从一开始就关注这个教程的话，那么你已经学会了 Matplotlib 提供的大部分内容。 你可能不相信，但Matplotlib 仍然可以做很多其他的事情！ 请继续学习，你可以随时访问 Matplotlib.org，并查看示例和图库页面。</p><p>如果你发现自己大量使用 Matplotlib，请考虑捐助给 <a href="https://link.jianshu.com?t=http://numfocus.org/news/2012/08/28/johnhunter/" target="_blank" rel="noopener">John Hunter Memorial 基金</a>。</p><blockquote><p>注：空间曲面的画法</p></blockquote><blockquote><pre><code># 二次抛物面 z = x^2 + y^2x = np.linspace(-10, 10, 101)y = xx, y = np.meshgrid(x, y)z = x ** 2 + y ** 2ax = plot.subplot(111, projection='3d')ax.plot_wireframe(x, y, z)plot.show()</code></pre></blockquote><blockquote><p><img src="/images/loading.gif" data-original="//upload-images.jianshu.io/upload_images/118142-c9f07724a4639d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="image"></p></blockquote><blockquote><pre><code># 半径为 1 的球t = np.linspace(0, np.pi * 2, 100)s = np.linspace(0, np.pi, 100)t, s = np.meshgrid(t, s)x = np.cos(t) * np.sin(s)y = np.sin(t) * np.sin(s)z = np.cos(s)ax = plot.subplot(111, projection='3d')ax.plot_wireframe(x, y, z)plot.show()</code></pre></blockquote><blockquote><p><img src="/images/loading.gif" data-original="//upload-images.jianshu.io/upload_images/118142-de70433e1947688e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="image"></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-GUI图像化开发PyQt5</title>
      <link href="/posts/blog-python06.html"/>
      <url>/posts/blog-python06.html</url>
      
        <content type="html"><![CDATA[<h3 id="创建第一个GUI界面"><a href="#创建第一个GUI界面" class="headerlink" title="创建第一个GUI界面"></a>创建第一个GUI界面</h3><p>首先，我们使用pyqt5的窗口小部件创建一个最基本的GUI：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import *app = QApplication(sys.argv)   #应用程序对象win = QWidget()   #窗口控件对象win.show()sys.exit(app.exec_())    #事件循环发生在应用程序中</code></pre><ol><li>在上面的程序中，我们首先引用了需要的模块：sys和pyqt5的QtWidgets模块：</li></ol><ul><li>sys模块提供了访问由解释器使用或维护的变量和与解释器进行交互的函数；</li><li>QtWidgets模块包含提供一组UI元素以创建经典桌面式用户界面的方法，可以让我们很方便地创建窗口对象。</li></ul><ol start="2"><li>接着，我们实例化了一个应用程序对象QApplication()，在PyQt5中，每个应用程序都必须实例化一个QApplication()：</li><li>然后我们创建了一个QWidget()对象，它是pyqt5中所有的图形用户界面的基类:</li><li>再是使用QWidget对象的show()方法将创建的窗口显示出来:</li><li>最后，我们调用应用程序对象的exec_()方法来运行程序的主循环，并使用sys.exit()方法确保程序能够完美的退出。<h3 id="设置窗口标题、大小和位置"><a href="#设置窗口标题、大小和位置" class="headerlink" title="设置窗口标题、大小和位置"></a>设置窗口标题、大小和位置</h3><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import *app = QApplication(sys.argv)win = QWidget()win.resize(450,150)win.move(0,300)win.setWindowTitle('GUI')win.show()sys.exit(app.exec_())</code></pre>在这个程序中，我们设置了以下三点：</li></ol><ul><li>使用QWidget()对象的resize()方法设置窗口的大小为450*150；</li><li>使用QWidget()对象的move()方法，将窗口移动到显示器上x=0，y=300的位置；</li><li>使用QWidget()对象的setWindowTitle()方法，为我们的窗口设置了一个标题。<h3 id="面向对象化"><a href="#面向对象化" class="headerlink" title="面向对象化"></a>面向对象化</h3>前面的例子中，我们使用的是面向函数的编程方式。Python支持面对函数和面向对象两种编程方式，在PyQt5中，使用面向对象的编程方式更加符合其特点。所以接下来我们使用面对对象的编程方式来创建GUI程序。</li></ul><p>我们先将上一篇的例子，改造为面对对象的形式：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QWidgetclass GUi():    def __init__(self):        self.initUI()    def initUI(self):        self.win = QWidget()        self.win.setWindowTitle('GUI')if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUi()    gui.win.show()    sys.exit(app.exec_())</code></pre><p>在这里，我们创建了一个名为GUi的类，通过initUI()方法来创建窗口，并在初始化方法init()中调用它。</p><h3 id="在类中继承"><a href="#在类中继承" class="headerlink" title="在类中继承"></a>在类中继承</h3><p>除了使用原生的类，我们还能从pyqt5中继承一些模块，以此来获得相关模块的属性。比如，我们创建一个继承于QWidget()的类，那么它就拥有了QWidget()的方法和属性，这样我们就可以不实例化一个QWidget()对象而直接拥有QWidget()的属性：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QWidget# 继承自QWidgetclass GUi(QWidget):    def __init__(self):        # 实例化super类，用来创建窗口        super().__init__()        self.initUI()    def initUI(self):        self.setWindowTitle('GUI')if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUi()    gui.show()    sys.exit(app.exec_())</code></pre><h3 id="添加状态栏"><a href="#添加状态栏" class="headerlink" title="添加状态栏"></a>添加状态栏</h3><p>我们可以通过QMainWindow的statusBar()方法来设置GUI窗口底部的状态消息栏。</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QMainWindow,QApplicationclass GUI(QMainWindow):    def __init__(self):        super().__init__()        self.iniUI()    def iniUI(self):        self.setWindowTitle("州的先生Zmister.com Python GUI教程")        self.resize(400,300)        # 设置状态消息栏文本        self.statusBar().showMessage("文本状态栏")if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUI()    gui.show()    sys.exit(app.exec_())</code></pre><h3 id="添加菜单栏"><a href="#添加菜单栏" class="headerlink" title="添加菜单栏"></a>添加菜单栏</h3><p>同时，我们可以使用QMainWindow的statusBar()方法来在窗口中添加一个菜单栏：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QActionclass GUI(QMainWindow):    def __init__(self):        super().__init__()        self.iniUI()    def iniUI(self):        self.setWindowTitle("州的先生zmister.com PythonGUI教程")        self.statusBar().showMessage("文本状态栏")        self.resize(400, 300)        # 创建一个菜单栏        menu = self.menuBar()        # 创建一个菜单        file_menu = menu.addMenu("文件")        # 创建一个行为        new_action = QAction('新文件',self)        # 添加一个行为到菜单        file_menu.addAction(new_action)        # 更新状态栏文本        new_action.setStatusTip('新的文件')if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUI()    gui.show()    sys.exit(app.exec_())</code></pre><p>接下来，我们添加一个“修改”菜单按钮，再添加一个退出行为，用于后面进行退出关闭窗口：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QActionclass GUI(QMainWindow):    def __init__(self):        super().__init__()        self.iniUI()    def iniUI(self):        self.setWindowTitle("州的先生zmister.com PythonGUI教程")        self.statusBar().showMessage("文本状态栏")        self.resize(400, 300)        # 创建一个菜单栏        menu = self.menuBar()        # 创建两个个菜单        file_menu = menu.addMenu("文件")        file_menu.addSeparator()        edit_menu = menu.addMenu('修改')        # 创建一个行为        new_action = QAction('新的文件',self)        # 更新状态栏文本        new_action.setStatusTip('打开新的文件')        # 添加一个行为到菜单        file_menu.addAction(new_action)        # 创建退出行为        exit_action = QAction('退出',self)        # 退出操作        exit_action.setStatusTip("点击退出应用程序")        # 点击关闭程序        exit_action.triggered.connect(self.close)        # 设置退出快捷键        exit_action.setShortcut('Ctrl+Q')        # 添加退出行为到菜单上        file_menu.addAction(exit_action)if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUI()    gui.show()    sys.exit(app.exec_())</code></pre><p>我们像创建第一个菜单那样创建了第二个菜单“修改”菜单，然后创建了一个“退出”行为，重点看一下它的代码：</p><pre><code># 创建退出行为 exit_action = QAction('退出',self)# 退出操作exit_action.setStatusTip("点击退出应用程序")# 点击关闭程序exit_action.triggered.connect(self.close)# 设置退出快捷键exit_action.setShortcut('Ctrl+Q')# 添加退出行为到菜单上file_menu.addAction(exit_action)</code></pre><p>首先使用QAction()对象创建一个行为，然后使用setStatusTip()方法设置他的状态文本提示，接着使用triggered.connect()方法调用关闭窗口的接口，再使用setShortcut()方法设置了行为的快捷键，最后添加行为到菜单上。</p><h3 id="添加Label标签部件"><a href="#添加Label标签部件" class="headerlink" title="添加Label标签部件"></a>添加Label标签部件</h3><p>我们先在窗口中添加一个标签Label，使用QLabel模块。</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabelclass GUI(QMainWindow):    def __init__(self):        super().__init__()        self.iniUI()    def iniUI(self):        self.setWindowTitle("GUI")        self.resize(400, 300)        self.add_menu_and_statu()        self.add_position_layout()    # 添加菜单栏和状态栏    def add_menu_and_statu(self):        self.statusBar().showMessage("文本状态栏")        # 创建一个菜单栏        menu = self.menuBar()        # 创建两个菜单        file_menu = menu.addMenu("文件")        file_menu.addSeparator()        edit_menu = menu.addMenu('修改')        # 创建一个行为        new_action = QAction('新的文件',self)        # 更新状态栏文本        new_action.setStatusTip('打开新的文件')        # 添加一个行为到菜单        file_menu.addAction(new_action)        # 创建退出行为        exit_action = QAction('退出',self)        # 退出操作        exit_action.setStatusTip("点击退出应用程序")        # 点击关闭程序        exit_action.triggered.connect(self.close)        # 设置退出快捷键        exit_action.setShortcut('Ctrl+Q')        # 添加退出行为到菜单上        file_menu.addAction(exit_action)    # 添加布局部件    def add_position_layout(self):        label = QLabel("第一个标签",self)if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUI()    gui.show()    sys.exit(app.exec_())</code></pre><p>与之前的代码不同的是，我们新增了一个add_position_layout()方法，并在里面实例化了一个QLabel对象。<br>我们在add_position_layout方法中添加:</p><pre><code>label.move(10,20)</code></pre><p>这样一句代码，将label向右移动10个像素，向下移动20个像素<br>手动设置移动的高度很不灵活，我们可以先获取菜单栏的高度，再确定label标签移动的位置。<br>我们可以使用部件的size()方法获取部件的宽和高，使用height()方法获取部件的高度，使用width()方法获取到部件的宽度：</p><pre><code>    # 添加布局部件    def add_position_layout(self):        # 获取菜单栏的高度        mbar_height = self.menuBar().height()        # 第一个标签        label_1 = QLabel("第一个标签",self)        label_1.move(10,mbar_height)        # 第二个标签        label_2 = QLabel('第二个标签',self)        label_2.move(10,mbar_height*2)</code></pre><p>在add_position_layout()方法中，我们首先使用self.menuBar().height()获取到菜单栏的高度，然后新建了两个Label标签，移动的高度分别为菜单栏高度的一倍和两倍</p><h3 id="添加按钮部件"><a href="#添加按钮部件" class="headerlink" title="添加按钮部件"></a>添加按钮部件</h3><p>除了添加Label标签，我们还可以在窗口中使用QPushButton对象来创建按钮部件：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabel,QPushButtonclass GUI(QMainWindow):    def __init__(self):        super().__init__()        self.iniUI()    def iniUI(self):        self.setWindowTitle("Python")        self.resize(400, 300)        self.add_menu_and_statu()        self.add_position_layout()    # 添加菜单栏和状态栏    def add_menu_and_statu(self):        self.statusBar().showMessage("文本状态栏")        # 创建一个菜单栏        menu = self.menuBar()        # 创建两个菜单        file_menu = menu.addMenu("文件")        file_menu.addSeparator()        edit_menu = menu.addMenu('修改')        # 创建一个行为        new_action = QAction('新的文件',self)        # 更新状态栏文本        new_action.setStatusTip('打开新的文件')        # 添加一个行为到菜单        file_menu.addAction(new_action)        # 创建退出行为        exit_action = QAction('退出',self)        # 退出操作        exit_action.setStatusTip("点击退出应用程序")        # 点击关闭程序        exit_action.triggered.connect(self.close)        # 设置退出快捷键        exit_action.setShortcut('Ctrl+Q')        # 添加退出行为到菜单上        file_menu.addAction(exit_action)    # 添加布局部件    def add_position_layout(self):        # 获取菜单栏的高度        mbar_height = self.menuBar().height()        # 第一个标签        label_1 = QLabel("第一个标签",self)        label_1.move(10,mbar_height)        # 第二个标签        label_2 = QLabel('第二个标签',self)        label_2.move(10,mbar_height*2)        # 第一个按钮        button_1 = QPushButton("按钮1",self)        button_1.move(label_1.width(),mbar_height)        # 第二个按钮        button_2 = QPushButton("按钮2",self)        button_2.move(label_2.width(),mbar_height*2)if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUI()    gui.show()    sys.exit(app.exec_())</code></pre><h3 id="使用水平垂直布局"><a href="#使用水平垂直布局" class="headerlink" title="使用水平垂直布局"></a>使用水平垂直布局</h3><p>在前面的程序中，我们使用部件的move()方法来指定部件的位置，虽然很灵活，但是如果部件很多的话，就会很繁琐。<br>PyQt5提供了布局管理模块来支持部件的水平布局和垂直布局：</p><ul><li><p>QHBoxLayout：水平布局；</p></li><li><p>QVBoxLayout ：垂直布局。<br>接下来，我们在程序中使用这两种布局来讲label标签和button按钮放入布局中。</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabel,QPushButton,QVBoxLayout,QHBoxLayout,QWidgetclass GUI(QMainWindow):  def __init__(self):      super().__init__()      self.iniUI()  def iniUI(self):      self.setWindowTitle("PythonGUI")      self.resize(400, 300)      self.add_menu_and_statu()      self.horizontal_vertical_box_layout()  # 添加菜单栏和状态栏  def add_menu_and_statu(self):      self.statusBar().showMessage("文本状态栏")      # 创建一个菜单栏      menu = self.menuBar()      # 创建两个菜单      file_menu = menu.addMenu("文件")      file_menu.addSeparator()      edit_menu = menu.addMenu('修改')      # 创建一个行为      new_action = QAction('新的文件',self)      # 更新状态栏文本      new_action.setStatusTip('打开新的文件')      # 添加一个行为到菜单      file_menu.addAction(new_action)      # 创建退出行为      exit_action = QAction('退出',self)      # 退出操作      exit_action.setStatusTip("点击退出应用程序")      # 点击关闭程序      exit_action.triggered.connect(self.close)      # 设置退出快捷键      exit_action.setShortcut('Ctrl+Q')      # 添加退出行为到菜单上      file_menu.addAction(exit_action)  # 水平垂直布局  def horizontal_vertical_box_layout(self):      # 两个标签      label_1 = QLabel('第一个标签')      label_2 = QLabel('第二个标签')      # 两个按钮      button_1 = QPushButton('第一个按钮')      button_2 = QPushButton('第二个按钮')      # 创建两个水平盒子      hbox_1 = QHBoxLayout()      hbox_2 = QHBoxLayout()      # 在水平盒子1中添加一个标签和一个按钮      hbox_1.addWidget(label_1)      hbox_1.addWidget(button_1)      # 在水平盒子2中添加标签2和按钮2      hbox_2.addWidget(label_2)      hbox_2.addWidget(button_2)      # 创建一个垂直盒子，包含两个水平盒子      vbox = QVBoxLayout()      vbox.addLayout(hbox_1)      vbox.addLayout(hbox_2)      # 创建一个窗口部件，设置布局为垂直盒子      layout_widget = QWidget()      layout_widget.setLayout(vbox)      self.setCentralWidget(layout_widget)if __name__ == '__main__':  app = QApplication(sys.argv)  gui = GUI()  gui.show()  sys.exit(app.exec_())</code></pre><p>我们在horizontal_vertical_box_layout()方法中创建了一个窗口部件、一个垂直盒子、两个水平盒子、两个按钮和两个文本标签，分别进行了嵌套.</p><h3 id="使用网格布局"><a href="#使用网格布局" class="headerlink" title="使用网格布局"></a>使用网格布局</h3><p>在PyQt5中，除了能够使用垂直布局和水平布局，我们还可以使用网格布局来管理窗口部件。<br>网格布局使用QGridLayout模块来创建，然后使用addWidget()方法添加窗口小部件以及它的位置：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabel,QPushButton,QVBoxLayout,QHBoxLayout,QWidget,QGridLayoutclass GUI(QMainWindow):  def __init__(self):      super().__init__()      self.iniUI()  def iniUI(self):      self.setWindowTitle("PythonGUI")      self.resize(400, 300)      self.add_menu_and_statu()      self.grid_layout()  # 添加菜单栏和状态栏  def add_menu_and_statu(self):      self.statusBar().showMessage("文本状态栏")      # 创建一个菜单栏      menu = self.menuBar()      # 创建两个菜单      file_menu = menu.addMenu("文件")      file_menu.addSeparator()      edit_menu = menu.addMenu('修改')      # 创建一个行为      new_action = QAction('新的文件',self)      # 更新状态栏文本      new_action.setStatusTip('打开新的文件')      # 添加一个行为到菜单      file_menu.addAction(new_action)      # 创建退出行为      exit_action = QAction('退出',self)      # 退出操作      exit_action.setStatusTip("点击退出应用程序")      # 点击关闭程序      exit_action.triggered.connect(self.close)      # 设置退出快捷键      exit_action.setShortcut('Ctrl+Q')      # 添加退出行为到菜单上      file_menu.addAction(exit_action)  # 网格布局  def grid_layout(self):      # 两个标签      label_1 = QLabel('第一个标签')      label_2 = QLabel('第二个标签')      # 两个按钮      button_1 = QPushButton('第一个按钮')      button_2 = QPushButton('第二个按钮')      # 创建一个网格布局对象      grid_layout = QGridLayout()      # 在网格中添加窗口部件      grid_layout.addWidget(label_1,0,0) # 放置在0行0列      grid_layout.addWidget(button_1,0,1) # 0行1列      grid_layout.addWidget(label_2,1,0) # 1行0列      grid_layout.addWidget(button_2,1,1) # 1行1列      # 创建一个窗口对象      layout_widget = QWidget()      # 设置窗口的布局层      layout_widget.setLayout(grid_layout)      self.setCentralWidget(layout_widget)if __name__ == '__main__':  app = QApplication(sys.argv)  gui = GUI()  gui.show()  sys.exit(app.exec_())</code></pre><p>在网格布局中，我们可以指定表格的对齐方式，使用网格布局对象的setAlignment()方法：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabel,QPushButton,QVBoxLayout,QHBoxLayout,QWidget,QGridLayoutfrom PyQt5.QtCore import Qtclass GUI(QMainWindow):  def __init__(self):      super().__init__()      self.iniUI()  def iniUI(self):      self.setWindowTitle("PythonGUI")      self.resize(400, 300)      self.add_menu_and_statu()      self.grid_layout()  # 添加菜单栏和状态栏  def add_menu_and_statu(self):      self.statusBar().showMessage("文本状态栏")      # 创建一个菜单栏      menu = self.menuBar()      # 创建两个菜单      file_menu = menu.addMenu("文件")      file_menu.addSeparator()      edit_menu = menu.addMenu('修改')      # 创建一个行为      new_action = QAction('新的文件',self)      # 更新状态栏文本      new_action.setStatusTip('打开新的文件')      # 添加一个行为到菜单      file_menu.addAction(new_action)      # 创建退出行为      exit_action = QAction('退出',self)      # 退出操作      exit_action.setStatusTip("点击退出应用程序")      # 点击关闭程序      exit_action.triggered.connect(self.close)      # 设置退出快捷键      exit_action.setShortcut('Ctrl+Q')      # 添加退出行为到菜单上      file_menu.addAction(exit_action)  # 网格布局  def grid_layout(self):      # 两个标签      label_1 = QLabel('第一个标签')      label_2 = QLabel('第二个标签')      # 两个按钮      button_1 = QPushButton('第一个按钮')      button_2 = QPushButton('第二个按钮')      # 创建一个网格布局对象      grid_layout = QGridLayout()      # 在网格中添加窗口部件      grid_layout.addWidget(label_1,0,0) # 放置在0行0列      grid_layout.addWidget(button_1,0,1) # 0行1列      grid_layout.addWidget(label_2,1,0) # 1行0列      grid_layout.addWidget(button_2,1,1) # 1行1列      grid_layout.setAlignment(Qt.AlignTop)      # 创建一个窗口对象      layout_widget = QWidget()      # 设置窗口的布局层      layout_widget.setLayout(grid_layout)      self.setCentralWidget(layout_widget)if __name__ == '__main__':  app = QApplication(sys.argv)  gui = GUI()  gui.show()  sys.exit(app.exec_())</code></pre><p>我们从PyQt5的QtCore模块中导入了Qt模块，用来指定对齐方式：</p><pre><code>from PyQt5.QtCore import Qt</code></pre><p>然后在创建的网格布局对象下，使用setAlignment来指定这个表格布局的对齐方式，内容为Qt的AlignTop属性，表示顶部对齐：</p><pre><code>grid_layout.setAlignment(Qt.AlignTop)</code></pre><p>除了对网格布局对象设置对齐方式，还能够对窗口小部件单独设置对齐方式，同样使用setAlignment()方法，传递两个参数，一个使部件名，一个使对齐方式：</p><pre><code>grid_layout.setAlignment(label_1,Qt.AlignRight)</code></pre><p>在对窗口部件设置行列的位置的时候，我们除了可以指定其行数和列数，还能够指定其跨越多少行以及跨越多少列，我们新建一个按钮，让其占1行和5列，看看效果：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabel,QPushButton,QVBoxLayout,QHBoxLayout,QWidget,QGridLayoutfrom PyQt5.QtCore import Qtclass GUI(QMainWindow):  def __init__(self):      super().__init__()      self.iniUI()  def iniUI(self):      self.setWindowTitle("PythonGUI")      self.resize(400, 300)      self.add_menu_and_statu()      self.grid_layout()  # 添加菜单栏和状态栏  def add_menu_and_statu(self):      self.statusBar().showMessage("文本状态栏")      # 创建一个菜单栏      menu = self.menuBar()      # 创建两个菜单      file_menu = menu.addMenu("文件")      file_menu.addSeparator()      edit_menu = menu.addMenu('修改')      # 创建一个行为      new_action = QAction('新的文件',self)      # 更新状态栏文本      new_action.setStatusTip('打开新的文件')      # 添加一个行为到菜单      file_menu.addAction(new_action)      # 创建退出行为      exit_action = QAction('退出',self)      # 退出操作      exit_action.setStatusTip("点击退出应用程序")      # 点击关闭程序      exit_action.triggered.connect(self.close)      # 设置退出快捷键      exit_action.setShortcut('Ctrl+Q')      # 添加退出行为到菜单上      file_menu.addAction(exit_action)  # 表格布局  def grid_layout(self):      # 两个标签      label_1 = QLabel('第一个标签')      label_2 = QLabel('第二个标签')      # 两个按钮      button_1 = QPushButton('第一个按钮')      button_2 = QPushButton('第二个按钮')      button_3 = QPushButton('第三个按钮')      # 创建一个表格布局对象      grid_layout = QGridLayout()      # 在表格中添加窗口部件      grid_layout.addWidget(label_1,0,0) # 放置在0行0列      grid_layout.addWidget(button_1,0,1) # 0行1列      grid_layout.addWidget(label_2,1,0) # 1行0列      grid_layout.addWidget(button_2,1,1) # 1行1列      grid_layout.addWidget(button_3,2,0,1,5)      # 对齐方式      grid_layout.setAlignment(Qt.AlignTop)      grid_layout.setAlignment(label_1,Qt.AlignRight)      # 创建一个窗口对象      layout_widget = QWidget()      # 设置窗口的布局层      layout_widget.setLayout(grid_layout)      self.setCentralWidget(layout_widget)if __name__ == '__main__':  app = QApplication(sys.argv)  gui = GUI()  gui.show()  sys.exit(app.exec_())</code></pre><h3 id="安装PyQt5-设计师工具"><a href="#安装PyQt5-设计师工具" class="headerlink" title="安装PyQt5 设计师工具"></a>安装PyQt5 设计师工具</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h5><pre><code>pip install pyqt5-tools</code></pre><h5 id="使用Qt-Designer创建GUI窗口"><a href="#使用Qt-Designer创建GUI窗口" class="headerlink" title="使用Qt Designer创建GUI窗口:"></a>使用Qt Designer创建GUI窗口:</h5><p>打开qt设计师之后，我们可以在“新建窗体”窗口中选择各种窗口的模板来进行窗口的创建:<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-bc7cabd3e6a1c5df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>接下来，我们使用qt设计师创建一个GUI 窗口程序。</p></li><li><p>通过Qt Designer创建第一个GUI窗口<br>我们在“新建窗体”窗口中选择“Main Window”来创建一个空白的主窗口：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-bee59060c47e97ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>qt设计师的主面板出现了一个空白的窗口GUI，我们可以使用快捷键Ctrl+R对窗口进行预览：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-76e68a9e2646ece2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>在右侧的选项栏中，可以对窗口的各种属性进行设置：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-12b41190aa24829b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>如图我们修改了窗口的大小。</p></li><li><p>修改窗口标题<br>新建的窗口使用的是默认的标题，我们可以在右侧的“windowTitle”选项中修改窗口标题：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-ff16218e32bcd75a.gif?imageMogr2/auto-orient/strip" alt="image"></p></li><li><p>在GUI中添加菜单栏和子菜单<br>使用qt设计师也可以很方便地创建菜单和子菜单，直接点击操作，简单迅速：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-ccbca8c01d8c18c8.gif?imageMogr2/auto-orient/strip" alt="image"></p></li><li><p>为菜单选项添加图标<br>菜单创建之后，只有文字很是单调，我们可以在icon选项中为菜单添加图标：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-8842fbf61cd48fda.gif?imageMogr2/auto-orient/strip" alt="image"></p></li><li><p>添加文本到状态栏<br>在上一篇中，我们使用statusBar()方法来设置窗口状态栏的文本，在qt设计师中，通过“statusTip”选项同样可以快速设置：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-ce9e37e9db5074ac.gif?imageMogr2/auto-orient/strip" alt="image"></p></li><li><p>保存UI设计<br>最后，我们保存设计好的qt设计文件，以供日后使用：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-5c18c91ca1a91d94.gif?imageMogr2/auto-orient/strip" alt="image"></p></li></ul><h3 id="通过Qt设计师在GUI中添加窗口部件"><a href="#通过Qt设计师在GUI中添加窗口部件" class="headerlink" title="通过Qt设计师在GUI中添加窗口部件"></a>通过Qt设计师在GUI中添加窗口部件</h3><h5 id="继续添加一个菜单"><a href="#继续添加一个菜单" class="headerlink" title="继续添加一个菜单"></a>继续添加一个菜单</h5><p>使用代码创建了GUI，我们继续在GUI窗口中创建一个“修改”菜单：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-3dbc23ea52c30731.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="为“退出”菜单添加状态栏信息"><a href="#为“退出”菜单添加状态栏信息" class="headerlink" title="为“退出”菜单添加状态栏信息"></a>为“退出”菜单添加状态栏信息</h5><p>目前使用qt设计师创建的GUI中，当鼠标移动到菜单项时，底部的状态栏是不会有变化的：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-d8b0d93f1e465283.gif?imageMogr2/auto-orient/strip" alt="image"><br>我们通过右侧的属性设置列表中的“statusTip”，设置为：当鼠标移动到“退出”按钮时，状态栏提示“点击退出应用程序”：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-99bc57de238dcded.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="为“退出”菜单添加一个关闭信号，来实现点击关闭程序"><a href="#为“退出”菜单添加一个关闭信号，来实现点击关闭程序" class="headerlink" title="为“退出”菜单添加一个关闭信号，来实现点击关闭程序"></a>为“退出”菜单添加一个关闭信号，来实现点击关闭程序</h5><p>在qt设计师面板右侧的“信号/槽编辑器”中，我们可以添加一个信号/槽。<br>在Pyqt中，响应和操作可以通过信号/槽来实现，一个信号槽由发送者、信号、接收者和槽组成，发送者发生信号，然后接收者调用槽。</p><p>我们使用信号槽来为“退出”菜单添加一个关闭窗口的操作：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-6bf581dba81dfd8b.gif?imageMogr2/auto-orient/strip" alt="image"><br>其中：</p><ul><li>发送者为“退出”菜单的name;</li><li>信号为triggerd()，也就是触发的意思；</li><li>接收者为主窗口；</li><li>槽为close()方法，也就是退出操作。<h5 id="为“退出”菜单项添加一个快捷键"><a href="#为“退出”菜单项添加一个快捷键" class="headerlink" title="为“退出”菜单项添加一个快捷键"></a>为“退出”菜单项添加一个快捷键</h5>在实现了“退出”菜单项的功能之后，我们可以为菜单项设置一个快捷键，以进行快捷操作。</li></ul><p>快捷键的设置在“动作编辑器”选项卡中进行编辑设置：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-c92b1d59432250c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>双击快捷键，弹出快捷键的编辑窗口：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-bfe8f55ad08f2edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>我们设置Ctrl+Q作为退出的快捷键：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-fe7e220f47863d06.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="在窗口中添加选项卡"><a href="#在窗口中添加选项卡" class="headerlink" title="在窗口中添加选项卡"></a>在窗口中添加选项卡</h5><p>选项卡在GUI程序中是很常见的小部件，可以分隔不同的内。在qt设计师中，可以直接从左侧的部件列表中拖拽添加到窗口中：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-2a1c6967cf418ac1.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="在选项卡中添加按钮和其他小部件"><a href="#在选项卡中添加按钮和其他小部件" class="headerlink" title="在选项卡中添加按钮和其他小部件"></a>在选项卡中添加按钮和其他小部件</h5><p>在主窗口中添加选项卡部件后，我们可以在选项卡部件中继续添加其他的小部件，我们分别拖拽添加一个按钮部件和一个刻度盘部件（添加部件之后，部件属性可以在右侧的属性列表中进行设置）：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-9529263f1638cf1e.gif?imageMogr2/auto-orient/strip" alt="image"></p><h3 id="使用Qt设计师进行窗口布局"><a href="#使用Qt设计师进行窗口布局" class="headerlink" title="使用Qt设计师进行窗口布局"></a>使用Qt设计师进行窗口布局</h3><h5 id="垂直布局"><a href="#垂直布局" class="headerlink" title="垂直布局"></a>垂直布局</h5><p>从左侧面板的“Layouts”栏中拖拽“Vertical Layout”到GUI窗口中，设置好布局大小，再在“Buttons”栏中拖拽3个“Push Button”到设置好大小的“Vertical Layout”中：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-34b3153b7bf7984e.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="水平布局"><a href="#水平布局" class="headerlink" title="水平布局"></a>水平布局</h5><p>从左侧面板的“Layouts”栏中拖拽“Horizontal Layout”到GUI窗口中，设置好布局大小，再在“Buttons”栏中拖拽3个“Push Button”到设置好大小的“Horizontal Layout”中：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-3d63f8db65137bb8.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="使用水平布局、垂直布局的另一种方式"><a href="#使用水平布局、垂直布局的另一种方式" class="headerlink" title="使用水平布局、垂直布局的另一种方式"></a>使用水平布局、垂直布局的另一种方式</h5><p>上面我们使用的是先设置一个布局部件，再将窗口部件放入布局部件之中布局方式。除此之外，我们还可以先在GUI窗口中放置窗口部件，框选需要进行布局的部件，再使用工具栏中的“水平布局”、“垂直布局”按钮对窗口部件进行布局管理：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-cd216aa5919da58c.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h5><p>与垂直布局和水平布局一样，网格布局也可以使用上述的两种方法来对窗口部件进行布局管理：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-02e34c849829440b.gif?imageMogr2/auto-orient/strip" alt="image"><br>除了对部件进行布局之外，我们还可以在网格中再进行嵌套布局：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-18d6689d1cdfae1f.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="容器布局"><a href="#容器布局" class="headerlink" title="容器布局"></a>容器布局</h5><p>除了使用布局控件之外，我们还能使用容器进行粗略的布局，下面以groupBox容器作为演示：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-a80aa69e355d5d6d.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="使用“Spacer”间隔"><a href="#使用“Spacer”间隔" class="headerlink" title="使用“Spacer”间隔"></a>使用“Spacer”间隔</h5><p>我们在布局部件中放置的窗口部件都是等距离的，如果我们需要对其中某个部件的距离设置远一点呢，可以使用“Spacer”间隔部件。<br>“Spacer”部件分为两种：</p><ul><li>Horizontal Spacer：垂直间隔；</li><li>Vertical Spacer：水平间隔。<br>间隔部件在左侧部件的“Spacer”栏中，下面我们演示一下：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-c812a0136a6addc1.gif?imageMogr2/auto-orient/strip" alt="image"><h5 id="为标签设置“伙伴”"><a href="#为标签设置“伙伴”" class="headerlink" title="为标签设置“伙伴”"></a>为标签设置“伙伴”</h5>Pyqt中有一个好用的基本功能就是“伙伴”部件，当用户键入标签的快捷键时，光标的焦点会出现在标签的伙伴上。例如：我们有一个用户名的标签和一个用户名的输入框，设置用户名标签与用户名输入框为“伙伴”，设置用户名标签的文本为”用户名(&amp;2)”，表示用户名标签的快捷键为Alt+2，如果我们按快捷键Alt+2，那么光标的输入符就会移动到用户名的输入框中。</li></ul><p>qt设计师中，“伙伴”功能，在工具栏的“编辑伙伴”按钮中：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-ac1289af24eee320.gif?imageMogr2/auto-orient/strip" alt="image"></p><h3 id="转换qt设计师的ui代码为Python代码"><a href="#转换qt设计师的ui代码为Python代码" class="headerlink" title="转换qt设计师的ui代码为Python代码"></a>转换qt设计师的ui代码为Python代码</h3><h5 id="查看qt设计师生成的UI文件"><a href="#查看qt设计师生成的UI文件" class="headerlink" title="查看qt设计师生成的UI文件"></a>查看qt设计师生成的UI文件</h5><p>我们在qt设计师中设计好的GUI窗口都会被保存为.ui格式的文件。<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-3bdca8401cdc4b77.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>实质上，.ui文件依然是文本格式文件，我们使用notepad++打开刚刚保存的.ui文件：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-aec4627b7ae4eb76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840" alt="image"><br>可以发现，.ui文件其实是一个xml文件，其通过不同的标签来表示不同的窗口部件或是行为和信号槽的声明和描述。</p><h5 id="通过pyuic5转换UI文件为Python文件"><a href="#通过pyuic5转换UI文件为Python文件" class="headerlink" title="通过pyuic5转换UI文件为Python文件"></a>通过pyuic5转换UI文件为Python文件</h5><p>设计好的UI文件如何需要转换为Python文件，该怎么办？毕竟我们需要使用Python来扩展GUI的功能。</p><p>我们可以使用PyQt自带的pyuic5工具，对Qt设计师保存的.ui文件进行转换。</p><p>pyuic5是一个命令行工具，直接在cmd命令行界面运行即可。下面我们使用pyuic5将刚刚保存的UI文件转换问Python代码：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-01778d3227a1f501.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>运行之后，便会自动生成一个ui2py.py的python文件，我们打开看看：</p><pre><code>from PyQt5 import QtCore, QtGui, QtWidgetsclass Ui_MainWindow(object):    def setupUi(self, MainWindow):        MainWindow.setObjectName("MainWindow")        MainWindow.resize(585, 477)        self.centralwidget = QtWidgets.QWidget(MainWindow)        self.centralwidget.setObjectName("centralwidget")        self.pushButton = QtWidgets.QPushButton(self.centralwidget)        self.pushButton.setGeometry(QtCore.QRect(170, 140, 75, 23))        self.pushButton.setObjectName("pushButton")        MainWindow.setCentralWidget(self.centralwidget)        self.menubar = QtWidgets.QMenuBar(MainWindow)        self.menubar.setGeometry(QtCore.QRect(0, 0, 585, 23))        self.menubar.setObjectName("menubar")        self.menu = QtWidgets.QMenu(self.menubar)        self.menu.setObjectName("menu")        MainWindow.setMenuBar(self.menubar)        self.statusbar = QtWidgets.QStatusBar(MainWindow)        self.statusbar.setObjectName("statusbar")        MainWindow.setStatusBar(self.statusbar)        self.actionMen1 = QtWidgets.QAction(MainWindow)        self.actionMen1.setObjectName("actionMen1")        self.actionMen2 = QtWidgets.QAction(MainWindow)        self.actionMen2.setObjectName("actionMen2")        self.menu.addAction(self.actionMen1)        self.menu.addSeparator()        self.menu.addAction(self.actionMen2)        self.menubar.addAction(self.menu.menuAction())        self.retranslateUi(MainWindow)        QtCore.QMetaObject.connectSlotsByName(MainWindow)    def retranslateUi(self, MainWindow):        _translate = QtCore.QCoreApplication.translate        MainWindow.setWindowTitle(_translate("MainWindow", "州的先生zmister.com PythonGUI教程"))        self.pushButton.setText(_translate("MainWindow", "PushButton"))        self.menu.setTitle(_translate("MainWindow", "文件"))        self.actionMen1.setText(_translate("MainWindow", "men1"))        self.actionMen2.setText(_translate("MainWindow", "men2"))if __name__ == "__main__":    import sys    app = QtWidgets.QApplication(sys.argv)    MainWindow = QtWidgets.QMainWindow()    ui = Ui_MainWindow()    ui.setupUi(MainWindow)    MainWindow.show()    sys.exit(app.exec_())</code></pre><p>生成的是标准的Python代码，运行一下，看看是否和qt设计师中的一致：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-872443049a153b3e.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h5 id="修改信号槽"><a href="#修改信号槽" class="headerlink" title="修改信号槽"></a>修改信号槽</h5><p>除了直接使用UI文件转换而来的PythonGUI代码，我们有时候也需要对部分事件进行修改。<br>我们可以在qt设计师中添加简单的信号槽，复制的信号槽还是得自己在python代码中定义。</p><p>首先，我们在窗口中添加一个label标签，设置一个信号槽为：点击按钮的时候，label标签就清空。<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-740601008cb3ac84.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>然后使用pyuic5将其转换为Python代码，运行正常，按钮的信号槽也正常：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-bdb8602afe300755.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-bdb8602afe300755.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>下面，我们并不想在点击button按钮的时候label标签消失，而是换一个文字。我们该怎么做呢？</p><p>直接在Python代码中进行修改，添加一个方法，并连接到信号槽上：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-563c759f395572c3.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>现在点击按钮之后，label标签会变为“zmister”而不是像之前那样清空。</p><h3 id="在主窗口中调用对话框"><a href="#在主窗口中调用对话框" class="headerlink" title="在主窗口中调用对话框"></a>在主窗口中调用对话框</h3><h5 id="一、创建两个窗口"><a href="#一、创建两个窗口" class="headerlink" title="一、创建两个窗口"></a>一、创建两个窗口</h5><p>根据本篇的最终目标——在主窗口中调用对话窗口，我们先使用qt设计师创建两个窗口，其中一个主窗口MainWindows，一个含有两个按钮的对话窗口Dialog。</p><p>通过qt设计师新建一个MainWindows窗口，并在其中放置一个按钮：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-3fa60dd34af48bb7.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>保存为UI文件，再新建一个对话窗口：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-c22ddf8df0584532.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>同样保存为UI文件。<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-cd8246c55fc7c0ee.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>这样我们本地文件夹有两个可供转换为Python代码的UI文件：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-0b2049c78e7aa45e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h5 id="二、转换UI文件为Python代码文件"><a href="#二、转换UI文件为Python代码文件" class="headerlink" title="二、转换UI文件为Python代码文件"></a>二、转换UI文件为Python代码文件</h5><p>保存好两个窗口的UI文件之后，我们继续使用pyuic5工具，将这两个UI文件转换为Python代码文件。<br>打开命令行输入：</p><pre><code>pyuic5 -x -o mainWindow.py mainWindow.uipyuic5 -x -o dialog.py dialog.ui</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-52f229f250597097.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>运行一下转换出来的Python文件，是否正常：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-1ad78cb14b74c934.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h5 id="三、从主窗口中调用对话框窗口"><a href="#三、从主窗口中调用对话框窗口" class="headerlink" title="三、从主窗口中调用对话框窗口"></a>三、从主窗口中调用对话框窗口</h5><p>在进行下一步之前，我们先在主窗口mainWindow中添加一个文本标签，设置文本为空，字体加大：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-fa3cc63b4314a492.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>有个这个label我们可以将对对话框的操作，反馈在label标签中。</p><p>保存UI文件，使用pyuic5重新转换一次Python代码。</p><p>为了在主窗口代码中调用对话框窗口，我们需要在mainWindow.py文件中引入对话框窗口：</p><pre><code>from GUI import dialog</code></pre><p>然后定义在主窗口的主类中定义一个方法，用来显示对话框窗口：</p><pre><code>def click_button(self):    Dialog = QtWidgets.QDialog()    ui = dialog.Ui_Dialog()    ui.setupUi(Dialog)    Dialog.show()    Dialog.exec_()</code></pre><p>定义好了方法，我们需要对按钮进行点击调用的绑定，这在setupUi()方法中进行设置：</p><pre><code>self.pushButton.clicked.connect(self.click_button)</code></pre><p>这样就实现了按钮点击绑定对话框。<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-85b9c1c0986b3142.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>我们知道，我们的对话框是有两个按钮的，一个“OK”，一个“Cancel”，在我们的GUI程序中，点击任意一个都会关闭对话框，效果似乎是一样的，但在PyQt5的内部机制的，这是两个不同的事件，下面我们就通过之前设置的label标签，展示其不同的机制。</p><p>我们修改一下click_button()方法，修改如下：</p><pre><code>def click_button(self):    Dialog = QtWidgets.QDialog()    ui = dialog.Ui_Dialog()    ui.setupUi(Dialog)    Dialog.show()    # Dialog.exec_()    rsp = Dialog.exec_()    if rsp == QtWidgets.QDialog.Accepted:        self.label.setText("点击了OK")    else:        self.label.setText("点击了Cannel")</code></pre><p>在这里我们将对话框的运行赋值给了一个变量，然后将其与QtWidgets.QDialog.Accepted进行比较，QtWidgets.QDialog.Accepted表示的是对话框的接收事件，也就是“OK”代表的事件，如果为接收时间，设置label标签为“点击了OK”，否则设置label标签为“点击了Cannel”<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-38b164313cdf120b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | PyQt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Pandas详解</title>
      <link href="/posts/blog-python05.html"/>
      <url>/posts/blog-python05.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、生成数据表"><a href="#一、生成数据表" class="headerlink" title="一、生成数据表"></a>一、生成数据表</h1><h2 id="1、首先导入pandas库，一般都会用到numpy库，所以我们先导入备用："><a href="#1、首先导入pandas库，一般都会用到numpy库，所以我们先导入备用：" class="headerlink" title="1、首先导入pandas库，一般都会用到numpy库，所以我们先导入备用："></a>1、首先导入pandas库，一般都会用到numpy库，所以我们先导入备用：</h2><p>import numpy as np<br>import pandas as pd</p><h2 id="2、导入CSV或者xlsx文件："><a href="#2、导入CSV或者xlsx文件：" class="headerlink" title="2、导入CSV或者xlsx文件："></a>2、导入CSV或者xlsx文件：</h2><p>df = pd.DataFrame(pd.read_csv(‘name.csv’,header=1))<br>df = pd.DataFrame(pd.read_excel(‘name.xlsx’))</p><h2 id="3、用pandas创建数据表："><a href="#3、用pandas创建数据表：" class="headerlink" title="3、用pandas创建数据表："></a>3、用pandas创建数据表：</h2><pre><code>df = pd.DataFrame({"id":[1001,1002,1003,1004,1005,1006],  "date":pd.date_range('20130102', periods=6),  "city":['Beijing ', 'SH', ' guangzhou ', 'Shenzhen', 'shanghai', 'BEIJING '], "age":[23,44,54,32,34,32], "category":['100-A','100-B','110-A','110-C','210-A','130-F'],  "price":[1200,np.nan,2133,5433,np.nan,4432]},  columns =['id','date','city','category','age','price'])</code></pre><h1 id="二、数据表信息查看"><a href="#二、数据表信息查看" class="headerlink" title="二、数据表信息查看"></a>二、数据表信息查看</h1><h2 id="1、维度查看："><a href="#1、维度查看：" class="headerlink" title="1、维度查看："></a>1、维度查看：</h2><p>df.shape</p><h2 id="2、数据表基本信息（维度、列名称、数据格式、所占空间等）："><a href="#2、数据表基本信息（维度、列名称、数据格式、所占空间等）：" class="headerlink" title="2、数据表基本信息（维度、列名称、数据格式、所占空间等）："></a>2、数据表基本信息（维度、列名称、数据格式、所占空间等）：</h2><p>df.info()</p><h2 id="3、每一列数据的格式："><a href="#3、每一列数据的格式：" class="headerlink" title="3、每一列数据的格式："></a>3、每一列数据的格式：</h2><p>df.dtypes</p><h2 id="4、某一列格式："><a href="#4、某一列格式：" class="headerlink" title="4、某一列格式："></a>4、某一列格式：</h2><p>df[‘B’].dtype</p><h2 id="5、空值："><a href="#5、空值：" class="headerlink" title="5、空值："></a>5、空值：</h2><p>df.isnull()</p><h2 id="6、查看某一列空值："><a href="#6、查看某一列空值：" class="headerlink" title="6、查看某一列空值："></a>6、查看某一列空值：</h2><p>df.isnull()</p><h2 id="7、查看某一列的唯一值："><a href="#7、查看某一列的唯一值：" class="headerlink" title="7、查看某一列的唯一值："></a>7、查看某一列的唯一值：</h2><p>df[‘B’].unique()</p><h2 id="8、查看数据表的值："><a href="#8、查看数据表的值：" class="headerlink" title="8、查看数据表的值："></a>8、查看数据表的值：</h2><p>df.values</p><h2 id="9、查看列名称："><a href="#9、查看列名称：" class="headerlink" title="9、查看列名称："></a>9、查看列名称：</h2><p>df.columns</p><h2 id="10、查看前10行数据、后10行数据："><a href="#10、查看前10行数据、后10行数据：" class="headerlink" title="10、查看前10行数据、后10行数据："></a>10、查看前10行数据、后10行数据：</h2><p>df.head() #默认前10行数据<br>df.tail() #默认后10 行数据</p><h1 id="三、数据表清洗"><a href="#三、数据表清洗" class="headerlink" title="三、数据表清洗"></a>三、数据表清洗</h1><h2 id="1、用数字0填充空值："><a href="#1、用数字0填充空值：" class="headerlink" title="1、用数字0填充空值："></a>1、用数字0填充空值：</h2><p>df.fillna(value=0)</p><h2 id="2、使用列prince的均值对NA进行填充："><a href="#2、使用列prince的均值对NA进行填充：" class="headerlink" title="2、使用列prince的均值对NA进行填充："></a>2、使用列prince的均值对NA进行填充：</h2><p>df[‘prince’].fillna(df[‘prince’].mean())</p><h2 id="3、清楚city字段的字符空格："><a href="#3、清楚city字段的字符空格：" class="headerlink" title="3、清楚city字段的字符空格："></a>3、清楚city字段的字符空格：</h2><p>df[‘city’]=df[‘city’].map(str.strip)</p><h2 id="4、大小写转换："><a href="#4、大小写转换：" class="headerlink" title="4、大小写转换："></a>4、大小写转换：</h2><p>df[‘city’]=df[‘city’].str.lower()</p><h2 id="5、更改数据格式："><a href="#5、更改数据格式：" class="headerlink" title="5、更改数据格式："></a>5、更改数据格式：</h2><p>df[‘price’].astype(‘int’)</p><h2 id="6、更改列名称："><a href="#6、更改列名称：" class="headerlink" title="6、更改列名称："></a>6、更改列名称：</h2><p>df.rename(columns={‘category’: ‘category-size’})</p><h2 id="7、删除后出现的重复值："><a href="#7、删除后出现的重复值：" class="headerlink" title="7、删除后出现的重复值："></a>7、删除后出现的重复值：</h2><p>df[‘city’].drop_duplicates()</p><h2 id="8、删除先出现的重复值："><a href="#8、删除先出现的重复值：" class="headerlink" title="8、删除先出现的重复值："></a>8、删除先出现的重复值：</h2><p>df[‘city’].drop_duplicates(keep=’last’)</p><h2 id="9、数据替换："><a href="#9、数据替换：" class="headerlink" title="9、数据替换："></a>9、数据替换：</h2><p>df[‘city’].replace(‘sh’, ‘shanghai’)</p><h1 id="四、数据预处理"><a href="#四、数据预处理" class="headerlink" title="四、数据预处理"></a>四、数据预处理</h1><pre><code>df1=pd.DataFrame({"id":[1001,1002,1003,1004,1005,1006,1007,1008], "gender":['male','female','male','female','male','female','male','female'],"pay":['Y','N','Y','Y','N','Y','N','Y',],"m-point":[10,12,20,40,40,40,30,20]})</code></pre><h2 id="1、数据表合并"><a href="#1、数据表合并" class="headerlink" title="1、数据表合并"></a>1、数据表合并</h2><h3 id="1-1-merge"><a href="#1-1-merge" class="headerlink" title="1.1 merge"></a>1.1 merge</h3><pre><code>df_inner=pd.merge(df,df1,how='inner')  # 匹配合并，交集df_left=pd.merge(df,df1,how='left')        #df_right=pd.merge(df,df1,how='right')df_outer=pd.merge(df,df1,how='outer')  #并集</code></pre><h3 id="1-2-append"><a href="#1-2-append" class="headerlink" title="1.2 append"></a>1.2 append</h3><pre><code>result = df1.append(df2)</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-1a90a4c989ad7427?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p><h3 id="1-3-join"><a href="#1-3-join" class="headerlink" title="1.3 join"></a>1.3 join</h3><pre><code>result = left.join(right, on='key')</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-e674e35fb121bf4b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p><h3 id="1-4-concat"><a href="#1-4-concat" class="headerlink" title="1.4 concat"></a>1.4 concat</h3><pre><code>pd.concat(objs, axis=0, join='outer', join_axes=None, ignore_index=False,          keys=None, levels=None, names=None, verify_integrity=False,          copy=True)</code></pre><p>objs︰ 一个序列或系列、 综合或面板对象的映射。如果字典中传递，将作为键参数，使用排序的键，除非它传递，在这种情况下的值将会选择 （见下文）。任何没有任何反对将默默地被丢弃，除非他们都没有在这种情况下将引发 ValueError。<br>axis: {0，1，…}，默认值为 0。要连接沿轴。<br>join: {‘内部’、 ‘外’}，默认 ‘外’。如何处理其他 axis(es) 上的索引。联盟内、 外的交叉口。<br>ignore_index︰ 布尔值、 默认 False。如果为 True，则不要串联轴上使用的索引值。由此产生的轴将标记 0，…，n-1。这是有用的如果你串联串联轴没有有意义的索引信息的对象。请注意在联接中仍然受到尊重的其他轴上的索引值。<br>join_axes︰ 索引对象的列表。具体的指标，用于其他 n-1 轴而不是执行内部/外部设置逻辑。<br>keys︰ 序列，默认为无。构建分层索引使用通过的键作为最外面的级别。如果多个级别获得通过，应包含元组。<br>levels︰ 列表的序列，默认为无。具体水平 （唯一值） 用于构建多重。否则，他们将推断钥匙。<br>names︰ 列表中，默认为无。由此产生的分层索引中的级的名称。<br>verify_integrity︰ 布尔值、 默认 False。检查是否新的串联的轴包含重复项。这可以是相对于实际数据串联非常昂贵。<br>副本︰ 布尔值、 默认 True。如果为 False，请不要，不必要地复制数据。</p><p>例子：1.frames = [df1, df2, df3]<br>2.result = pd.concat(frames)<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a9599d77ce922494?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p><h2 id="2、设置索引列"><a href="#2、设置索引列" class="headerlink" title="2、设置索引列"></a>2、设置索引列</h2><p>df_inner.set_index(‘id’)</p><h2 id="3、按照特定列的值排序："><a href="#3、按照特定列的值排序：" class="headerlink" title="3、按照特定列的值排序："></a>3、按照特定列的值排序：</h2><p>df_inner.sort_values(by=[‘age’])</p><h2 id="4、按照索引列排序："><a href="#4、按照索引列排序：" class="headerlink" title="4、按照索引列排序："></a>4、按照索引列排序：</h2><p>df_inner.sort_index()</p><h2 id="5、如果prince列的值-gt-3000，group列显示high，否则显示low："><a href="#5、如果prince列的值-gt-3000，group列显示high，否则显示low：" class="headerlink" title="5、如果prince列的值>3000，group列显示high，否则显示low："></a>5、如果prince列的值&gt;3000，group列显示high，否则显示low：</h2><p>df_inner[‘group’] = np.where(df_inner[‘price’] &gt; 3000,’high’,’low’)</p><h2 id="6、对复合多个条件的数据进行分组标记"><a href="#6、对复合多个条件的数据进行分组标记" class="headerlink" title="6、对复合多个条件的数据进行分组标记"></a>6、对复合多个条件的数据进行分组标记</h2><p>df_inner.loc[(df_inner[‘city’] == ‘beijing’) &amp; (df_inner[‘price’] &gt;= 4000), ‘sign’]=1</p><h2 id="7、对category字段的值依次进行分列，并创建数据表，索引值为df-inner的索引列，列名称为category和size"><a href="#7、对category字段的值依次进行分列，并创建数据表，索引值为df-inner的索引列，列名称为category和size" class="headerlink" title="7、对category字段的值依次进行分列，并创建数据表，索引值为df_inner的索引列，列名称为category和size"></a>7、对category字段的值依次进行分列，并创建数据表，索引值为df_inner的索引列，列名称为category和size</h2><p>pd.DataFrame((x.split(‘-‘) for x in df_inner[‘category’]),index=df_inner.index,columns=[‘category’,’size’]))</p><h2 id="8、将完成分裂后的数据表和原df-inner数据表进行匹配"><a href="#8、将完成分裂后的数据表和原df-inner数据表进行匹配" class="headerlink" title="8、将完成分裂后的数据表和原df_inner数据表进行匹配"></a>8、将完成分裂后的数据表和原df_inner数据表进行匹配</h2><p>df_inner=pd.merge(df_inner,split,right_index=True, left_index=True)</p><h1 id="五、数据提取"><a href="#五、数据提取" class="headerlink" title="五、数据提取"></a>五、数据提取</h1><p>主要用到的三个函数：loc,iloc和ix，loc函数按标签值进行提取，iloc按位置进行提取，ix可以同时按标签和位置进行提取。</p><h2 id="1、按索引提取单行的数值"><a href="#1、按索引提取单行的数值" class="headerlink" title="1、按索引提取单行的数值"></a>1、按索引提取单行的数值</h2><p>df_inner.loc[3]</p><h2 id="2、按索引提取区域行数值"><a href="#2、按索引提取区域行数值" class="headerlink" title="2、按索引提取区域行数值"></a>2、按索引提取区域行数值</h2><p>df_inner.iloc[0:5]</p><h2 id="3、重设索引"><a href="#3、重设索引" class="headerlink" title="3、重设索引"></a>3、重设索引</h2><p>df_inner.reset_index()</p><h2 id="4、设置日期为索引"><a href="#4、设置日期为索引" class="headerlink" title="4、设置日期为索引"></a>4、设置日期为索引</h2><p>df_inner=df_inner.set_index(‘date’)</p><h2 id="5、提取4日之前的所有数据"><a href="#5、提取4日之前的所有数据" class="headerlink" title="5、提取4日之前的所有数据"></a>5、提取4日之前的所有数据</h2><p>df_inner[:’2013-01-04’]</p><h2 id="6、使用iloc按位置区域提取数据"><a href="#6、使用iloc按位置区域提取数据" class="headerlink" title="6、使用iloc按位置区域提取数据"></a>6、使用iloc按位置区域提取数据</h2><p>df_inner.iloc[:3,:2] #冒号前后的数字不再是索引的标签名称，而是数据所在的位置，从0开始，前三行，前两列。</p><h2 id="7、适应iloc按位置单独提起数据"><a href="#7、适应iloc按位置单独提起数据" class="headerlink" title="7、适应iloc按位置单独提起数据"></a>7、适应iloc按位置单独提起数据</h2><p>df_inner.iloc[[0,2,5],[4,5]] #提取第0、2、5行，4、5列</p><h2 id="8、使用ix按索引标签和位置混合提取数据"><a href="#8、使用ix按索引标签和位置混合提取数据" class="headerlink" title="8、使用ix按索引标签和位置混合提取数据"></a>8、使用ix按索引标签和位置混合提取数据</h2><p>df_inner.ix[:’2013-01-03’,:4] #2013-01-03号之前，前四列数据</p><h2 id="9、判断city列的值是否为北京"><a href="#9、判断city列的值是否为北京" class="headerlink" title="9、判断city列的值是否为北京"></a>9、判断city列的值是否为北京</h2><p>df_inner[‘city’].isin([‘beijing’])</p><h2 id="10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来"><a href="#10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来" class="headerlink" title="10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来"></a>10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来</h2><p>df_inner.loc[df_inner[‘city’].isin([‘beijing’,’shanghai’])]</p><h2 id="11、提取前三个字符，并生成数据表"><a href="#11、提取前三个字符，并生成数据表" class="headerlink" title="11、提取前三个字符，并生成数据表"></a>11、提取前三个字符，并生成数据表</h2><p>pd.DataFrame(category.str[:3])</p><h1 id="六、数据筛选"><a href="#六、数据筛选" class="headerlink" title="六、数据筛选"></a>六、数据筛选</h1><p>使用与、或、非三个条件配合大于、小于、等于对数据进行筛选，并进行计数和求和。</p><h2 id="1、使用“与”进行筛选"><a href="#1、使用“与”进行筛选" class="headerlink" title="1、使用“与”进行筛选"></a>1、使用“与”进行筛选</h2><p>df_inner.loc[(df_inner[‘age’] &gt; 25) &amp; (df_inner[‘city’] == ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]]</p><h2 id="2、使用“或”进行筛选"><a href="#2、使用“或”进行筛选" class="headerlink" title="2、使用“或”进行筛选"></a>2、使用“或”进行筛选</h2><p>df_inner.loc[(df_inner[‘age’] &gt; 25) | (df_inner[‘city’] == ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]].sort([‘age’])</p><h2 id="3、使用“非”条件进行筛选"><a href="#3、使用“非”条件进行筛选" class="headerlink" title="3、使用“非”条件进行筛选"></a>3、使用“非”条件进行筛选</h2><p>df_inner.loc[(df_inner[‘city’] != ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]].sort([‘id’])</p><h2 id="4、对筛选后的数据按city列进行计数"><a href="#4、对筛选后的数据按city列进行计数" class="headerlink" title="4、对筛选后的数据按city列进行计数"></a>4、对筛选后的数据按city列进行计数</h2><p>df_inner.loc[(df_inner[‘city’] != ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]].sort([‘id’]).city.count()</p><h2 id="5、使用query函数进行筛选"><a href="#5、使用query函数进行筛选" class="headerlink" title="5、使用query函数进行筛选"></a>5、使用query函数进行筛选</h2><p>df_inner.query(‘city == [“beijing”, “shanghai”]’)</p><h2 id="6、对筛选后的结果按prince进行求和"><a href="#6、对筛选后的结果按prince进行求和" class="headerlink" title="6、对筛选后的结果按prince进行求和"></a>6、对筛选后的结果按prince进行求和</h2><p>df_inner.query(‘city == [“beijing”, “shanghai”]’).price.sum()</p><h1 id="七、数据汇总"><a href="#七、数据汇总" class="headerlink" title="七、数据汇总"></a>七、数据汇总</h1><p>主要函数是groupby和pivote_table</p><h2 id="1、对所有的列进行计数汇总"><a href="#1、对所有的列进行计数汇总" class="headerlink" title="1、对所有的列进行计数汇总"></a>1、对所有的列进行计数汇总</h2><p>df_inner.groupby(‘city’).count()</p><h2 id="2、按城市对id字段进行计数"><a href="#2、按城市对id字段进行计数" class="headerlink" title="2、按城市对id字段进行计数"></a>2、按城市对id字段进行计数</h2><p>df_inner.groupby(‘city’)[‘id’].count()</p><h2 id="3、对两个字段进行汇总计数"><a href="#3、对两个字段进行汇总计数" class="headerlink" title="3、对两个字段进行汇总计数"></a>3、对两个字段进行汇总计数</h2><p>df_inner.groupby([‘city’,’size’])[‘id’].count()</p><h2 id="4、对city字段进行汇总，并分别计算prince的合计和均值"><a href="#4、对city字段进行汇总，并分别计算prince的合计和均值" class="headerlink" title="4、对city字段进行汇总，并分别计算prince的合计和均值"></a>4、对city字段进行汇总，并分别计算prince的合计和均值</h2><p>df_inner.groupby(‘city’)[‘price’].agg([len,np.sum, np.mean])</p><h1 id="八、数据统计"><a href="#八、数据统计" class="headerlink" title="八、数据统计"></a>八、数据统计</h1><p>数据采样，计算标准差，协方差和相关系数</p><h2 id="1、简单的数据采样"><a href="#1、简单的数据采样" class="headerlink" title="1、简单的数据采样"></a>1、简单的数据采样</h2><p>df_inner.sample(n=3)</p><h2 id="2、手动设置采样权重"><a href="#2、手动设置采样权重" class="headerlink" title="2、手动设置采样权重"></a>2、手动设置采样权重</h2><p>weights = [0, 0, 0, 0, 0.5, 0.5]<br>df_inner.sample(n=2, weights=weights)</p><h2 id="3、采样后不放回"><a href="#3、采样后不放回" class="headerlink" title="3、采样后不放回"></a>3、采样后不放回</h2><p>df_inner.sample(n=6, replace=False)</p><h2 id="4、采样后放回"><a href="#4、采样后放回" class="headerlink" title="4、采样后放回"></a>4、采样后放回</h2><p>df_inner.sample(n=6, replace=True)</p><h2 id="5、-数据表描述性统计"><a href="#5、-数据表描述性统计" class="headerlink" title="5、 数据表描述性统计"></a>5、 数据表描述性统计</h2><p>df_inner.describe().round(2).T #round函数设置显示小数位，T表示转置</p><h2 id="6、计算列的标准差"><a href="#6、计算列的标准差" class="headerlink" title="6、计算列的标准差"></a>6、计算列的标准差</h2><p>df_inner[‘price’].std()</p><h2 id="7、计算两个字段间的协方差"><a href="#7、计算两个字段间的协方差" class="headerlink" title="7、计算两个字段间的协方差"></a>7、计算两个字段间的协方差</h2><p>df_inner[‘price’].cov(df_inner[‘m-point’])</p><h2 id="8、数据表中所有字段间的协方差"><a href="#8、数据表中所有字段间的协方差" class="headerlink" title="8、数据表中所有字段间的协方差"></a>8、数据表中所有字段间的协方差</h2><p>df_inner.cov()</p><h2 id="9、两个字段的相关性分析"><a href="#9、两个字段的相关性分析" class="headerlink" title="9、两个字段的相关性分析"></a>9、两个字段的相关性分析</h2><p>df_inner[‘price’].corr(df_inner[‘m-point’]) #相关系数在-1到1之间，接近1为正相关，接近-1为负相关，0为不相关</p><h2 id="10、数据表的相关性分析"><a href="#10、数据表的相关性分析" class="headerlink" title="10、数据表的相关性分析"></a>10、数据表的相关性分析</h2><p>df_inner.corr()</p><h1 id="九、数据输出"><a href="#九、数据输出" class="headerlink" title="九、数据输出"></a>九、数据输出</h1><p>分析后的数据可以输出为xlsx格式和csv格式</p><h2 id="1、写入Excel"><a href="#1、写入Excel" class="headerlink" title="1、写入Excel"></a>1、写入Excel</h2><p>df_inner.to_excel(‘excel_to_python.xlsx’, sheet_name=’bluewhale_cc’)</p><h2 id="2、写入到CSV"><a href="#2、写入到CSV" class="headerlink" title="2、写入到CSV"></a>2、写入到CSV</h2><p>df_inner.to_csv(‘excel_to_python.csv’)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Numpy详解</title>
      <link href="/posts/blog-python04.html"/>
      <url>/posts/blog-python04.html</url>
      
        <content type="html"><![CDATA[<h3 id="NumPy-Ndarray-对象"><a href="#NumPy-Ndarray-对象" class="headerlink" title="NumPy Ndarray 对象"></a>NumPy Ndarray 对象</h3><p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。</p><p>ndarray 对象是用于存放同类型元素的多维数组。</p><p>ndarray 中的每个元素在内存中都有相同存储大小的区域。</p><p>ndarray 内部由以下内容组成：</p><ul><li><p>一个指向数据（内存或内存映射文件中的一块数据）的指针。</p></li><li><p>数据类型或 dtype，描述在数组中的固定大小值的格子。</p></li><li><p>一个表示数组形状（shape）的元组，表示各维度大小的元组。</p></li><li><p>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要”跨过”的字节数。</p></li></ul><p>ndarray 的内部结构:<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-ed8acce11bbcd6bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>跨度可以是负数，这样会使数组在内存中后向移动，切片中 obj[::-1] 或 obj[:,::-1] 就是如此。</p><p>创建一个 ndarray 只需调用 NumPy 的 array 函数即可：</p><pre><code>numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-548ea678b56011aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-数据类型"><a href="#NumPy-数据类型" class="headerlink" title="NumPy 数据类型"></a>NumPy 数据类型</h3><p>numpy 支持的数据类型比 Python 内置的类型要多很多，基本上可以和 C 语言的数据类型对应上，其中部分类型对应为 Python 内置的类型。下表列举了常用 NumPy 基本类型。</p><ul><li>bool_    布尔型数据类型（True 或者 False）</li><li>int_    默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</li><li>intc    与 C 的 int 类型一样，一般是 int32 或 int 64</li><li>intp    用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</li><li>int8    字节（-128 to 127）</li><li>int16    整数（-32768 to 32767）</li><li>int32    整数（-2147483648 to 2147483647）</li><li>int64    整数（-9223372036854775808 to 9223372036854775807）</li><li>uint8    无符号整数（0 to 255）</li><li>uint16    无符号整数（0 to 65535）</li><li>uint32    无符号整数（0 to 4294967295）</li><li>uint64    无符号整数（0 to 18446744073709551615）</li><li>float_    float64 类型的简写</li><li>float16    半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</li><li>float32    单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</li><li>float64    双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</li><li>complex_    complex128 类型的简写，即 128 位复数</li><li>complex64    复数，表示双 32 位浮点数（实数部分和虚数部分）</li><li>complex128    复数，表示双 64 位浮点数（实数部分和虚数部分）</li></ul><p>numpy 的数值类型实际上是 dtype 对象的实例，并对应唯一的字符，包括 np.bool_，np.int32，np.float32，等等。</p><h3 id="数据类型对象-dtype"><a href="#数据类型对象-dtype" class="headerlink" title="数据类型对象 (dtype)"></a>数据类型对象 (dtype)</h3><p>数据类型对象是用来描述与数组对应的内存区域如何使用，这依赖如下几个方面：</p><ul><li>数据的类型（整数，浮点数或者 Python 对象）</li><li>数据的大小（例如， 整数使用多少个字节存储）</li><li>数据的字节顺序（小端法或大端法）</li><li>在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分</li><li>如果数据类型是子数组，它的形状和数据类型<br>字节顺序是通过对数据类型预先设定”&lt;”或”&gt;”来决定的。”&lt;”意味着小端法(最小值存储在最小的地址，即低位组放在最前面)。”&gt;”意味着大端法(最重要的字节存储在最小的地址，即高位组放在最前面)。</li></ul><p>dtype 对象是使用以下语法构造的：</p><pre><code>numpy.dtype(object, align, copy)</code></pre><ul><li>object - 要转换为的数据类型对象</li><li>align - 如果为 true，填充字段使其类似 C 的结构体。</li><li>copy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用</li></ul><p>每个内建类型都有一个唯一定义它的字符代码，如下：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7c1c38e30b7100ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-数组属性"><a href="#NumPy-数组属性" class="headerlink" title="NumPy 数组属性"></a>NumPy 数组属性</h3><p>NumPy 数组的维数称为秩（rank），一维数组的秩为 1，二维数组的秩为 2，以此类推。</p><p>在 NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。</p><p>很多时候可以声明 axis。axis=0，表示沿着第 0 轴进行操作，即对<strong>每一列</strong>进行操作；axis=1，表示沿着第1轴进行操作，即对<strong>每一行</strong>进行操作。</p><p>NumPy 的数组中比较重要 ndarray 对象属性有：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-9c3ef5fd9250e4e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>ndarray.flags 返回 ndarray 对象的内存信息，包含以下属性：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6e4f7c2b8b6bc255.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-创建数组"><a href="#NumPy-创建数组" class="headerlink" title="NumPy 创建数组"></a>NumPy 创建数组</h3><p>ndarray 数组除了可以使用底层 ndarray 构造器来创建外，也可以通过以下几种方式来创建。</p><p><strong>numpy.empty</strong></p><p>numpy.empty 方法用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组：</p><pre><code>numpy.empty(shape, dtype = float, order = 'C')</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-dcada345e558e5a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.zeros</strong><br>创建指定大小的数组，数组元素以 0 来填充：</p><pre><code>numpy.zeros(shape, dtype = float, order = 'C')</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-af5db82b47841510.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.ones</strong><br>创建指定形状的数组，数组元素以 1 来填充：</p><pre><code>numpy.ones(shape, dtype = None, order = 'C')</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-dda70286db2d9ca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-从已有的数组创建数组"><a href="#NumPy-从已有的数组创建数组" class="headerlink" title="NumPy 从已有的数组创建数组"></a>NumPy 从已有的数组创建数组</h3><p><strong>numpy.asarray</strong><br>numpy.asarray 类似 numpy.array，但 numpy.asarray 只有三个，比 numpy.array 少两个。</p><pre><code>numpy.asarray(a, dtype = None, order = None)</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-44811e18ac421b72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.frombuffer</strong><br>numpy.frombuffer 用于实现动态数组。</p><p>numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</p><pre><code>numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)</code></pre><p><em>注意：buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。</em><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-106c550ac6996c34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.fromiter</strong><br>numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。</p><pre><code>numpy.fromiter(iterable, dtype, count=-1)</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-202a56a2011bbe3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-从数值范围创建数组"><a href="#NumPy-从数值范围创建数组" class="headerlink" title="NumPy 从数值范围创建数组"></a>NumPy 从数值范围创建数组</h3><p><strong>numpy.arange</strong><br>numpy 包中的使用 arange 函数创建数值范围并返回 ndarray 对象，函数格式如下：</p><pre><code>numpy.arange(start, stop, step, dtype)</code></pre><p>根据 start 与 stop 指定的范围以及 step 设定的步长，生成一个 ndarray。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-bbd5489c746a4048.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.linspace</strong><br>numpy.linspace 函数用于创建一个一维数组，数组是一个等差数列构成的，格式如下：</p><pre><code>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7313240ab629e03e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.logspace</strong><br>numpy.logspace 函数用于创建一个于等比数列。格式如下：</p><pre><code>np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></pre><p>base 参数意思是取对数的时候 log 的下标。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-1d29c671ae48f329.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-切片和索引"><a href="#NumPy-切片和索引" class="headerlink" title="NumPy 切片和索引"></a>NumPy 切片和索引</h3><p>ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样。</p><p>ndarray 数组可以基于 0 - n 的下标进行索引，切片对象可以通过内置的 slice 函数，并设置 start, stop 及 step 参数进行，从原数组中切割出一个新数组。</p><p>实例</p><pre><code>import numpy as npa = np.arange(10)s = slice(2,7,2)   # 从索引 2 开始到索引 7 停止，间隔为2print (a[s])</code></pre><p>输出结果为：</p><pre><code>[2  4  6]</code></pre><p>以上实例中，我们首先通过 arange() 函数创建 ndarray 对象。 然后，分别设置起始，终止和步长的参数为 2，7 和 2。</p><p>我们也可以通过冒号分隔切片参数 start:stop:step 来进行切片操作：</p><p>实例</p><pre><code>import numpy as npa = np.arange(10)  b = a[2:7:2]   # 从索引 2 开始到索引 7 停止，间隔为 2print(b)</code></pre><p>输出结果为：</p><pre><code>[2  4  6]</code></pre><p>冒号 : 的解释：如果只放置一个参数，如 [2]，将返回与该索引相对应的单个元素。如果为 [2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 [2:7]，那么则提取两个索引(不包括停止索引)之间的项。</p><p>实例</p><pre><code>import numpy as npa = np.arange(10)  # [0 1 2 3 4 5 6 7 8 9]b = a[5] print(b)</code></pre><p>输出结果为：</p><pre><code>5</code></pre><p>实例</p><pre><code>import numpy as npa = np.arange(10)print(a[2:])</code></pre><p>输出结果为：</p><pre><code>[2  3  4  5  6  7  8  9]</code></pre><p>实例</p><pre><code>import numpy as npa = np.arange(10)  # [0 1 2 3 4 5 6 7 8 9]print(a[2:5])</code></pre><p>输出结果为：</p><pre><code>[2  3  4]</code></pre><p>多维数组同样适用上述索引提取方法：</p><p>实例</p><pre><code>import numpy as npa = np.array([[1,2,3],[3,4,5],[4,5,6]])print(a)# 从某个索引处开始切割print('从数组索引 a[1:] 处开始切割')print(a[1:])</code></pre><p>输出结果为：</p><pre><code>[[1 2 3] [3 4 5] [4 5 6]]</code></pre><p>从数组索引 a[1:] 处开始切割</p><pre><code>[[3 4 5] [4 5 6]]</code></pre><p>切片还可以包括省略号 …，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p><p>实例</p><pre><code>import numpy as npa = np.array([[1,2,3],[3,4,5],[4,5,6]])  print (a[...,1])   # 第2列元素print (a[1,...])   # 第2行元素print (a[...,1:])  # 第2列及剩下的所有元素</code></pre><p>输出结果为：</p><pre><code>[2 4 5][3 4 5][[2 3] [4 5] [5 6]]</code></pre><h3 id="NumPy-高级索引"><a href="#NumPy-高级索引" class="headerlink" title="NumPy 高级索引"></a>NumPy 高级索引</h3><ul><li>整数数组索引</li><li>布尔索引</li><li>花式索引</li></ul><h3 id="NumPy-广播-Broadcast"><a href="#NumPy-广播-Broadcast" class="headerlink" title="NumPy 广播(Broadcast)"></a>NumPy 广播(Broadcast)</h3><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p><p>如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p><pre><code>import numpy as np a = np.array([1,2,3,4]) b = np.array([10,20,30,40]) c = a * b print (c)</code></pre><p>输出结果为：</p><pre><code>[ 10  40  90 160]</code></pre><p>当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。如：</p><pre><code>import numpy as np a = np.array([[ 0, 0, 0],           [10,10,10],           [20,20,20],           [30,30,30]])b = np.array([1,2,3])print(a + b)</code></pre><p>输出结果为：</p><pre><code>[[ 1  2  3] [11 12 13] [21 22 23] [31 32 33]]</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-de5bcc31bbecc9fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>广播的规则:</p><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。</li><li>输出数组的形状是输入数组形状的各个维度上的最大值。</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。</li><li>当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。</li></ul><p>简单理解：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：</p><ul><li>数组拥有相同形状。</li><li>当前维度的值相等。</li><li>当前维度的值有一个是 1。</li></ul><p>若条件不满足，抛出 “ValueError: frames are not aligned” 异常。</p><h3 id="NumPy-迭代数组"><a href="#NumPy-迭代数组" class="headerlink" title="NumPy 迭代数组"></a>NumPy 迭代数组</h3><p>NumPy 迭代器对象 numpy.nditer 提供了一种灵活访问一个或者多个数组元素的方式。</p><p>迭代器最基本的任务的可以完成对数组元素的访问。</p><p>接下来我们使用 arange() 函数创建一个 2X3 数组，并使用 nditer 对它进行迭代。</p><pre><code>import numpy as npa = np.arange(6).reshape(2,3)print ('原始数组是：')print (a)print ('\n')print ('迭代输出元素：')for x in np.nditer(a):    print (x, end=", " )print ('\n')</code></pre><p>输出结果为：</p><pre><code>原始数组是：[[0 1 2] [3 4 5]]迭代输出元素：0, 1, 2, 3, 4, 5, </code></pre><p>以上实例不是使用标准 C 或者 Fortran 顺序，选择的顺序是和数组内存布局一致的，这样做是为了提升访问的效率，默认是行序优先（row-major order，或者说是 C-order）。</p><p>这反映了默认情况下只需访问每个元素，而无需考虑其特定顺序。我们可以通过迭代上述数组的转置来看到这一点，并与以 C 顺序访问数组转置的 copy 方式做对比，如下实例：</p><pre><code>import numpy as npa = np.arange(6).reshape(2,3)for x in np.nditer(a.T):    print (x, end=", " )print ('\n')for x in np.nditer(a.T.copy(order='C')):    print (x, end=", " )print ('\n')</code></pre><p>输出结果为：</p><pre><code>0, 1, 2, 3, 4, 5, 0, 3, 1, 4, 2, 5, </code></pre><p>从上述例子可以看出，a 和 a.T 的遍历顺序是一样的，也就是他们在内存中的存储顺序也是一样的，但是 a.T.copy(order = ‘C’) 的遍历结果是不同的，那是因为它和前两种的存储方式是不一样的，默认是按行访问。</p><p><strong>控制遍历顺序</strong><br>for x in np.nditer(a, order=’F’):Fortran order，即是列序优先；<br>for x in np.nditer(a.T, order=’C’):C order，即是行序优先；</p><p><strong>修改数组中元素的值</strong><br>nditer 对象有另一个可选参数 op_flags。 默认情况下，nditer 将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定 read-write 或者 write-only 的模式。</p><p><strong>使用外部循环</strong><br>nditer类的构造器拥有flags参数，它可以接受下列值：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7d2b0669e6bb65de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>广播迭代</strong><br>如果两个数组是可广播的，nditer 组合对象能够同时迭代它们。 假设数组 a 的维度为 3X4，数组 b 的维度为 1X4 ，则使用以下迭代器（数组 b 被广播到 a 的大小）。</p><h3 id="Numpy-数组操作"><a href="#Numpy-数组操作" class="headerlink" title="Numpy 数组操作"></a>Numpy 数组操作</h3><p><strong>修改数组形状</strong><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f2d06e9db8323294.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.reshape</strong><br>numpy.reshape 函数可以在不改变数据的条件下修改形状，格式如下： numpy.reshape(arr, newshape, order=’C’)</p><ul><li>arr：要修改形状的数组</li><li>newshape：整数或者整数数组，新的形状应当兼容原有形状</li><li>order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’k’ – 元素在内存中的出现顺序。</li></ul><p><strong>numpy.ndarray.flat</strong><br>numpy.ndarray.flat 是一个数组元素迭代器</p><p><strong>numpy.ndarray.flatten</strong><br>numpy.ndarray.flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组，格式如下：</p><pre><code>ndarray.flatten(order='C')</code></pre><p>参数说明：</p><ul><li>order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。</li></ul><p><strong>numpy.ravel</strong><br>numpy.ravel() 展平的数组元素，顺序通常是”C风格”，返回的是数组视图（view，有点类似 C/C++引用reference的意味），修改会影响原始数组。</p><p>该函数接收两个参数：</p><pre><code>numpy.ravel(a, order='C')</code></pre><p>参数说明：</p><ul><li>order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。</li></ul><p><strong>翻转数组</strong><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-e7cc83b5e6dee2ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.transpose</strong><br>numpy.transpose 函数用于对换数组的维度，格式如下：</p><pre><code>numpy.transpose(arr, axes)</code></pre><p>参数说明:</p><ul><li>arr：要操作的数组</li><li>axes：整数列表，对应维度，通常所有维度都会对换。</li></ul><p><strong>numpy.rollaxis</strong><br>numpy.rollaxis 函数向后滚动特定的轴到一个特定位置，格式如下：</p><pre><code>numpy.rollaxis(arr, axis, start)</code></pre><p>参数说明：</p><ul><li>arr：数组</li><li>axis：要向后滚动的轴，其它轴的相对位置不会改变</li><li>start：默认为零，表示完整的滚动。会滚动到特定位置。</li></ul><p><strong>numpy.swapaxes</strong><br>numpy.swapaxes 函数用于交换数组的两个轴，格式如下：</p><pre><code>numpy.swapaxes(arr, axis1, axis2)</code></pre><ul><li>arr：输入的数组</li><li>axis1：对应第一个轴的整数</li><li>axis2：对应第二个轴的整数</li></ul><p><strong>修改数组维度</strong><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-932b54f20b2f213b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.broadcast</strong><br>numpy.broadcast 用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。</p><p><strong>numpy.broadcast_to</strong><br>numpy.broadcast_to 函数将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。</p><pre><code>numpy.broadcast_to(array, shape, subok)</code></pre><p><strong>numpy.expand_dims</strong><br>numpy.expand_dims 函数通过在指定位置插入新的轴来扩展数组形状，函数格式如下:</p><pre><code> numpy.expand_dims(arr, axis)</code></pre><p>参数说明：</p><ul><li>arr：输入数组</li><li>axis：新轴插入的位置</li></ul><p><strong>numpy.squeeze</strong><br>numpy.squeeze 函数从给定数组的形状中删除一维的条目，函数格式如下：</p><pre><code>numpy.squeeze(arr, axis)</code></pre><p>参数说明：</p><ul><li>arr：输入数组</li><li>axis：整数或整数元组，用于选择形状中一维条目的子集</li></ul><h3 id="连接数组"><a href="#连接数组" class="headerlink" title="连接数组"></a>连接数组</h3><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-2c328fe33d5e182f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.concatenate</strong><br>numpy.concatenate 函数用于沿指定轴连接相同形状的两个或多个数组，格式如下：</p><pre><code>numpy.concatenate((a1, a2, ...), axis)</code></pre><p>参数说明：</p><ul><li>a1, a2, …：相同类型的数组</li><li>axis：沿着它连接数组的轴，默认为 0</li></ul><p><strong>numpy.stack</strong><br>numpy.stack 函数用于沿新轴连接数组序列，格式如下：</p><pre><code>numpy.stack(arrays, axis)</code></pre><p>参数说明：</p><ul><li>arrays相同形状的数组序列</li><li>axis：返回数组中的轴，输入数组沿着它来堆叠</li></ul><p><strong>numpy.hstack</strong><br>numpy.hstack 是 numpy.stack 函数的变体，它通过水平堆叠来生成数组。</p><p><strong>numpy.vstack</strong><br>numpy.vstack 是 numpy.stack 函数的变体，它通过垂直堆叠来生成数组。</p><p><strong>分割数组</strong><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-b90db31e02fc9ce9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.split</strong><br>numpy.split 函数沿特定的轴将数组分割为子数组，格式如下：</p><pre><code>numpy.split(ary, indices_or_sections, axis)</code></pre><p>参数说明：</p><ul><li>ary：被分割的数组</li><li>indices_or_sections：果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭）</li><li>axis：沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分</li></ul><p><strong>numpy.hsplit</strong><br>numpy.hsplit 函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组。</p><p><strong>numpy.vsplit</strong><br>numpy.vsplit 沿着垂直轴分割，其分割方式与hsplit用法相同。</p><h3 id="数组元素的添加与删除"><a href="#数组元素的添加与删除" class="headerlink" title="数组元素的添加与删除"></a>数组元素的添加与删除</h3><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-8fae55a7e4ce8c85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.resize</strong><br>numpy.resize 函数返回指定大小的新数组。</p><p>如果新数组大小大于原始大小，则包含原始数组中的元素的副本。</p><pre><code>numpy.resize(arr, shape)</code></pre><p>参数说明：</p><ul><li>arr：要修改大小的数组</li><li>shape：返回数组的新形状</li></ul><p><strong>numpy.append</strong><br>numpy.append 函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的维度必须匹配否则将生成ValueError。</p><p>append 函数返回的始终是一个一维数组。</p><pre><code>numpy.append(arr, values, axis=None)</code></pre><p>参数说明：</p><ul><li>arr：输入数组</li><li>values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）</li><li>axis：默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。</li></ul><p><strong>numpy.insert</strong><br>numpy.insert 函数在给定索引之前，沿给定轴在输入数组中插入值。</p><p>如果值的类型转换为要插入，则它与输入数组不同。 插入没有原地的，函数会返回一个新数组。 此外，如果未提供轴，则输入数组会被展开。</p><pre><code>numpy.insert(arr, obj, values, axis)</code></pre><p>参数说明：</p><ul><li>arr：输入数组</li><li>obj：在其之前插入值的索引</li><li>values：要插入的值</li><li>axis：沿着它插入的轴，如果未提供，则输入数组会被展开</li></ul><p><strong>numpy.delete</strong><br>numpy.delete 函数返回从输入数组中删除指定子数组的新数组。 与 insert() 函数的情况一样，如果未提供轴参数，则输入数组将展开。</p><pre><code>Numpy.delete(arr, obj, axis)</code></pre><p>参数说明：</p><ul><li>arr：输入数组</li><li>obj：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</li><li>axis：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</li></ul><p><strong>numpy.unique</strong><br>numpy.unique 函数用于去除数组中的重复元素。</p><pre><code>numpy.unique(arr, return_index, return_inverse, return_counts)</code></pre><ul><li>arr：输入数组，如果不是一维数组则会展开</li><li>return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储</li><li>return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储</li><li>return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数</li></ul><h3 id="NumPy-位运算"><a href="#NumPy-位运算" class="headerlink" title="NumPy 位运算"></a>NumPy 位运算</h3><p>NumPy “bitwise_” 开头的函数是位运算函数。</p><p>NumPy 位运算包括以下几个函数：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-d2002e3200dea632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-字符串函数"><a href="#NumPy-字符串函数" class="headerlink" title="NumPy 字符串函数"></a>NumPy 字符串函数</h3><p>以下函数用于对 dtype 为 numpy.string_ 或 numpy.unicode_ 的数组执行向量化字符串操作。 它们基于 Python 内置库中的标准字符串函数。</p><p>这些函数在字符数组类（numpy.char）中定义。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7b14ae371864668b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-数学函数"><a href="#NumPy-数学函数" class="headerlink" title="NumPy 数学函数"></a>NumPy 数学函数</h3><p><strong>三角函数</strong><br>NumPy 提供了标准的三角函数：sin()、cos()、tan()。</p><p><strong>舍入函数</strong><br>numpy.around() 函数返回指定数字的四舍五入值。</p><pre><code>numpy.around(a,decimals)</code></pre><p>参数说明：</p><ul><li>a: 数组</li><li>decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置</li></ul><p><strong>numpy.floor()</strong><br>numpy.floor() 返回数字的下舍整数。</p><p><strong>numpy.ceil()</strong><br>numpy.ceil() 返回数字的上入整数。</p><h3 id="NumPy-算术函数"><a href="#NumPy-算术函数" class="headerlink" title="NumPy 算术函数"></a>NumPy 算术函数</h3><p>NumPy 算术函数包含简单的加减乘除: add()，subtract()，multiply() 和 divide()。</p><p>需要注意的是数组必须具有相同的形状或符合数组广播规则。</p><p>此外 Numpy 也包含了其他重要的算术函数。</p><p><strong>numpy.reciprocal()</strong><br>numpy.reciprocal() 函数返回参数逐元素的倒数。如 1/4 倒数为 4/1。</p><p><strong>numpy.power()</strong><br>numpy.power() 函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。</p><p><strong>numpy.mod()</strong><br>numpy.mod() 计算输入数组中相应元素的相除后的余数。 函数 numpy.remainder() 也产生相同的结果。</p><h3 id="NumPy-统计函数"><a href="#NumPy-统计函数" class="headerlink" title="NumPy 统计函数"></a>NumPy 统计函数</h3><p><strong>numpy.amin() 和 numpy.amax()</strong><br>numpy.amin() 用于计算数组中的元素沿指定轴的最小值。</p><p>numpy.amax() 用于计算数组中的元素沿指定轴的最大值。</p><p><strong>numpy.ptp()</strong><br>numpy.ptp()函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p><p><strong>numpy.percentile()</strong><br>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 函数numpy.percentile()接受以下参数。</p><pre><code>numpy.percentile(a, q, axis)</code></pre><p>参数说明：</p><ul><li>a: 输入数组</li><li>q: 要计算的百分位数，在 0 ~ 100 之间</li><li>axis: 沿着它计算百分位数的轴<br>首先明确百分位数：</li></ul><p>第 p 个百分位数是这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有 (100-p)% 的数据项大于或等于这个值。</p><p>举个例子：高等院校的入学考试成绩经常以百分位数的形式报告。比如，假设某个考生在入学考试中的语文部分的原始分数为 54 分。相对于参加同一考试的其他学生来说，他的成绩如何并不容易知道。但是如果原始分数54分恰好对应的是第70百分位数，我们就能知道大约70%的学生的考分比他低，而约30%的学生考分比他高。</p><p>这里的 p = 70。</p><p><strong>numpy.median()</strong><br>numpy.median() 函数用于计算数组 a 中元素的中位数（中值）</p><p><strong>numpy.mean()</strong><br>numpy.mean() 函数返回数组中元素的算术平均值。 如果提供了轴，则沿其计算。</p><p>算术平均值是沿轴的元素的总和除以元素的数量。</p><p><strong>numpy.average()</strong><br>numpy.average() 函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。</p><p>该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。</p><p>加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。</p><p>考虑数组[1,2,3,4]和相应的权重[4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。</p><p><strong>标准差</strong><br>标准差是一组数据平均值分散程度的一种度量。</p><p>标准差是方差的算术平方根。</p><p>标准差公式如下：</p><pre><code>std = sqrt(mean((x - x.mean())**2))</code></pre><p>如果数组是 [1，2，3，4]，则其平均值为 2.5。 因此，差的平方是 [2.25,0.25,0.25,2.25]，并且其平均值的平方根除以 4，即 sqrt(5/4) ，结果为 1.1180339887498949。</p><p><strong>方差</strong><br>统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即 mean((x - x.mean())** 2)。</p><p>换句话说，标准差是方差的平方根。</p><h3 id="NumPy-排序、条件刷选函数"><a href="#NumPy-排序、条件刷选函数" class="headerlink" title="NumPy 排序、条件刷选函数"></a>NumPy 排序、条件刷选函数</h3><p>NumPy 提供了多种排序的方法。 这些排序函数实现不同的排序算法，每个排序算法的特征在于执行速度，最坏情况性能，所需的工作空间和算法的稳定性。 下表显示了三种排序算法的比较。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-253e8d77eb1b7539.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.sort()</strong><br>numpy.sort() 函数返回输入数组的排序副本。函数格式如下：</p><pre><code>numpy.sort(a, axis, kind, order)</code></pre><p><strong>numpy.argsort()</strong><br>numpy.argsort() 函数返回的是数组值从小到大的索引值。</p><p><strong>numpy.lexsort()</strong><br>numpy.lexsort() 用于对多个序列进行排序。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p><p>这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。</p><p><strong>msort、sort_complex、partition、argpartition</strong></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7b94c231e2b3a965.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.argmax() 和 numpy.argmin()</strong><br>numpy.argmax() 和 numpy.argmin()函数分别沿给定轴返回最大和最小元素的索引。</p><p><strong>numpy.nonzero()</strong><br>numpy.nonzero() 函数返回输入数组中非零元素的索引。</p><p><strong>numpy.where()</strong><br>numpy.where() 函数返回输入数组中满足给定条件的元素的索引。</p><p><strong>numpy.extract()</strong><br>numpy.extract() 函数根据某个条件从数组中抽取元素，返回满条件的元素。</p><h3 id="NumPy-字节交换"><a href="#NumPy-字节交换" class="headerlink" title="NumPy 字节交换"></a>NumPy 字节交换</h3><p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。字节顺序，是跨越多字节的程序对象的存储规则。</p><ul><li><p>大端模式：指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</p></li><li><p>小端模式：指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</p></li></ul><p>例如在 C 语言中，一个类型为 int 的变量 x 地址为 0x100，那么其对应地址表达式&amp;x的值为 0x100。且x的四个字节将被存储在存储器的 0x100, 0x101, 0x102, 0x103位置。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cfb1dc912601047a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.ndarray.byteswap()</strong><br>numpy.ndarray.byteswap() 函数将 ndarray 中每个元素中的字节进行大小端转换。</p><h3 id="NumPy-矩阵库-Matrix"><a href="#NumPy-矩阵库-Matrix" class="headerlink" title="NumPy 矩阵库(Matrix)"></a>NumPy 矩阵库(Matrix)</h3><p>NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。</p><p><strong>matlib.empty()</strong><br>matlib.empty() 函数返回一个新的矩阵，语法格式为：</p><pre><code>numpy.matlib.empty(shape, dtype, order)</code></pre><p>参数说明：</p><pre><code>shape: 定义新矩阵形状的整数或整数元组Dtype: 可选，数据类型order: C（行序优先） 或者 F（列序优先）</code></pre><p><strong>numpy.matlib.zeros()</strong><br>numpy.matlib.zeros() 函数创建一个以 0 填充的矩阵。</p><p><strong>numpy.matlib.ones()</strong><br>numpy.matlib.ones()函数创建一个以 1 填充的矩阵。</p><p><strong>numpy.matlib.eye()</strong><br>numpy.matlib.eye() 函数返回一个矩阵，对角线元素为 1，其他位置为零。</p><pre><code>numpy.matlib.eye(n, M,k, dtype)</code></pre><p>参数说明：</p><pre><code>n: 返回矩阵的行数M: 返回矩阵的列数，默认为 nk: 对角线的索引dtype: 数据类型</code></pre><p><strong>numpy.matlib.identity()</strong><br>numpy.matlib.identity() 函数返回给定大小的单位矩阵。</p><p>单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-270c1beafc8a5565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.matlib.rand()</strong><br>numpy.matlib.rand() 函数创建一个给定大小的矩阵，数据是随机填充的。</p><h3 id="NumPy-线性代数"><a href="#NumPy-线性代数" class="headerlink" title="NumPy 线性代数"></a>NumPy 线性代数</h3><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-3d0280b2e9ab232a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.dot()</strong><br>numpy.dot() 对于两个一维的数组，计算的是这两个数组对应下标元素的乘积和(数学上称之为内积)；对于二维数组，计算的是两个数组的矩阵乘积；对于多维数组，它的通用计算公式如下，即结果数组中的每个元素都是：数组a的最后一维上的所有元素与数组b的倒数第二位上的所有元素的乘积和： dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])。</p><pre><code>numpy.dot(a, b, out=None) </code></pre><p>参数说明：</p><pre><code>a : ndarray 数组b : ndarray 数组out : ndarray, 可选，用来保存dot()的计算结果</code></pre><p><strong>numpy.vdot()</strong><br>numpy.vdot() 函数是两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数是多维数组，它会被展开。</p><p><strong>numpy.inner()</strong><br>numpy.inner() 函数返回一维数组的向量内积。对于更高的维度，它返回最后一个轴上的和的乘积。</p><p><strong>numpy.matmul</strong><br>numpy.matmul 函数返回两个数组的矩阵乘积。 虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。</p><p>另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。</p><p><strong>numpy.linalg.det()</strong><br>numpy.linalg.det() 函数计算输入矩阵的行列式。</p><p>行列式在线性代数中是非常有用的值。 它从方阵的对角元素计算。 对于 2×2 矩阵，它是左上和右下元素的乘积与其他两个的乘积的差。</p><p>换句话说，对于矩阵[[a，b]，[c，d]]，行列式计算为 ad-bc。 较大的方阵被认为是 2×2 矩阵的组合。</p><p><strong>numpy.linalg.solve()</strong><br>numpy.linalg.solve() 函数给出了矩阵形式的线性方程的解。</p><p>考虑以下线性方程：</p><p>x + y + z = 6</p><p>2y + 5z = -4</p><p>2x + 5y - z = 27<br>可以使用矩阵表示为：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6a10ed854cec035f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>如果矩阵成为A、X和B，方程变为：</p><p>AX = B</p><p>或</p><p>X = A^(-1)B</p><p><strong>numpy.linalg.inv()</strong><br>numpy.linalg.inv() 函数计算矩阵的乘法逆矩阵。</p><p>逆矩阵（inverse matrix）：设A是数域上的一个n阶矩阵，若在相同数域上存在另一个n阶矩阵B，使得： AB=BA=E ，则我们称B是A的逆矩阵，而A则被称为可逆矩阵。注：E为单位矩阵。</p><h3 id="NumPy-IO"><a href="#NumPy-IO" class="headerlink" title="NumPy IO"></a>NumPy IO</h3><p>Numpy 可以读写磁盘上的文本数据或二进制数据。</p><p>NumPy 为 ndarray 对象引入了一个简单的文件格式：npy。</p><p>npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。</p><p>常用的 IO 函数有：</p><ul><li>load() 和 save() 函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npy 的文件中。</li><li>savze() 函数用于将多个数组写入文件，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npz 的文件中。</li><li>loadtxt() 和 savetxt() 函数处理正常的文本文件(.txt 等)</li></ul><p><strong>numpy.save()</strong><br>numpy.save() 函数将数组保存到以 .npy 为扩展名的文件中。</p><pre><code>numpy.save(file, arr, allow_pickle=True, fix_imports=True)</code></pre><p>参数说明：</p><pre><code>file：要保存的文件，扩展名为 .npy，如果文件路径末尾没有扩展名 .npy，该扩展名会被自动加上。arr: 要保存的数组allow_pickle: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python 中的 pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。fix_imports: 可选，为了方便 Pyhton2 中读取 Python3 保存的数据。</code></pre><p><strong>np.savez</strong><br>numpy.savez() 函数将多个数组保存到以 npz 为扩展名的文件中。</p><pre><code>numpy.savez(file, *args, **kwds)</code></pre><p>参数说明：</p><pre><code>file：要保存的文件，扩展名为 .npz，如果文件路径末尾没有扩展名 .npz，该扩展名会被自动加上。args: 要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为 arr_0, arr_1, …　。kwds: 要保存的数组使用关键字名称。</code></pre><p><strong>savetxt()</strong><br>savetxt() 函数是以简单的文本文件格式存储数据，对应的使用 loadtxt() 函数来获取数据。</p><pre><code>np.loadtxt(FILENAME, dtype=int, delimiter=' ')np.savetxt(FILENAME, a, fmt="%d", delimiter=",")</code></pre><p>参数 delimiter 可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python画一只会眨眼睛的皮卡丘</title>
      <link href="/posts/blog-python03.html"/>
      <url>/posts/blog-python03.html</url>
      
        <content type="html"><![CDATA[<h1 id="Pikaqiu-用turtle绘画的皮卡丘"><a href="#Pikaqiu-用turtle绘画的皮卡丘" class="headerlink" title="Pikaqiu 用turtle绘画的皮卡丘"></a>Pikaqiu 用turtle绘画的皮卡丘</h1><ol><li>首先我们导入turtle库和time库（用来做动画使用）:<pre><code>import turtle as timport time</code></pre></li><li>由于turtle没有画曲线的函数，因此我们自定义画曲线函数,函数有4个参数，ang偏转角度，dis移动步长，step步长增幅，n遍历次数，说白了就是将曲线转化为很多条短长的直线：<pre><code>#画左偏曲线函数def radian_left(ang,dis,step,n): for i in range(n):     dis+=step #dis增大step     t.lt(ang) #向左转ang度     t.fd(dis) #向前走dis的步长    def radian_right(ang,dis,step,n): for i in range(n):     dis+=step     t.rt(ang) #向左转ang度     t.fd(dis) #向前走dis的步长</code></pre></li><li>定义画耳朵，眼睛，嘴，轮廓，脚画尾巴的函数，具体见python文件</li><li>初始化皮卡丘：<pre><code>#初始化def Init(): InitEars() InitTail() InitFoots() InitBody() InitFace() InitHands() InitEyes()</code></pre></li><li>定义Upgrade函数和Upgarde_init函数制作眨眼动画：<pre><code>#眨眼睛def Upgarde(): InitEars() InitTail() InitFoots() InitBody() InitFace() InitHands() CloseEyes()def Upgarde_Init(): InitEars() InitTail() InitFoots() InitBody() InitFace() InitHands() InitEyes()</code></pre><ol start="6"><li>Main函数定义：<pre><code>def main():Init()  t.tracer(False)   #眨眼睛动画for i in range(30):  if i%2==0:      t.reset()      t.hideturtle()      Upgarde()      t.update()      time.sleep(0.3)  else:      t.reset()      t.hideturtle()      Upgarde_Init()      t.update()      time.sleep(1)        </code></pre><h1 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h1><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-b70381c6d5e08b89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pikaqiu.png"></li></ol></li></ol><p>视频动画可以打包下载该文件，点击pikaqiu.mp4观看<br><a href="https://github.com/JackHCC/Pikaqiu" target="_blank" rel="noopener">Github源码下载地址</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | Turtle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Turtle详解</title>
      <link href="/posts/blog-python02.html"/>
      <url>/posts/blog-python02.html</url>
      
        <content type="html"><![CDATA[<p>#turtle绘图的基础知识：<br>####1.画布</p><pre><code>turtle.screensize(canvwidth=None, canvheight=None, bg=None)</code></pre><p>参数分别为画布的宽(单位像素), 高, 背景颜色。如：turtle.screensize(800,600, “green”)</p><pre><code>turtle.screensize() #返回默认大小(400, 300)turtle.setup(width=0.5, height=0.75, startx=None, starty=None)</code></pre><p>参数：width, height: 输入宽和高为整数时, 表示像素; 为小数时, 表示占据电脑屏幕的比例，(startx, starty): 这一坐标表示矩形窗口左上角顶点的位置, 如果为空,则窗口位于屏幕中心。</p><p>####2.画笔<br>####2.1 画笔的状态<br>在画布上，默认有一个坐标原点为画布中心的坐标轴，坐标原点上有一只面朝x轴正方向小乌龟。这里我们描述小乌龟时使用了两个词语：坐标原点(位置)，面朝x轴正方向(方向)， turtle绘图中，就是使用位置方向描述小乌龟(画笔)的状态。</p><p>####2.2 画笔的属性<br>画笔(画笔的属性，颜色、画线的宽度等)</p><pre><code>    1) turtle.pensize()：设置画笔的宽度；    2) turtle.pencolor()：没有参数传入，返回当前画笔颜色，传入参数设置画笔颜色，可以是字符串如"green", "red",也可以是RGB 3元组。    3) turtle.speed(speed)：设置画笔移动速度，画笔绘制的速度范围[0,10]整数，数字越大越快。</code></pre><p>####2.3 绘图命令</p><p>操纵海龟绘图有着许多的命令，这些命令可以划分为3种：一种为运动命令，一种为画笔控制命令，还有一种是全局控制命令。<br>######(1)    画笔运动命令</p><ul><li>turtle.forward(distance)</li></ul><p>向当前画笔方向移动distance像素长度</p><ul><li>turtle.backward(distance)</li></ul><p>向当前画笔相反方向移动distance像素长度</p><ul><li>turtle.right(degree)</li></ul><p>顺时针移动degree°</p><ul><li>turtle.left(degree)</li></ul><p>逆时针移动degree°</p><ul><li>turtle.pendown()</li></ul><p>移动时绘制图形，缺省时也为绘制</p><ul><li>turtle.goto(x,y)</li></ul><p>将画笔移动到坐标为x,y的位置</p><ul><li>turtle.penup()</li></ul><p>提起笔移动，不绘制图形，用于另起一个地方绘制</p><ul><li>turtle.circle()</li></ul><p>画圆，半径为正(负)，表示圆心在画笔的左边(右边)画圆</p><ul><li>setx( )</li></ul><p>将当前x轴移动到指定位置</p><ul><li>sety( )</li></ul><p>将当前y轴移动到指定位置</p><ul><li>setheading(angle)</li></ul><p>设置当前朝向为angle角度</p><ul><li>home()</li></ul><p>设置当前画笔位置为原点，朝向东。</p><ul><li><p>dot(r)<br>######(2)     画笔控制命令</p></li><li><p>turtle.fillcolor(colorstring)</p></li></ul><p>绘制图形的填充颜色</p><ul><li>turtle.color(color1, color2)</li></ul><p>同时设置pencolor=color1, fillcolor=color2</p><ul><li>turtle.filling()</li></ul><p>返回当前是否在填充状态</p><ul><li>turtle.begin_fill()</li></ul><p>准备开始填充图形</p><ul><li>turtle.end_fill()</li></ul><p>填充完成</p><ul><li>turtle.hideturtle()</li></ul><p>隐藏画笔的turtle形状</p><ul><li>turtle.showturtle()</li></ul><p>显示画笔的turtle形状<br>######(3)    全局控制命令</p><ul><li>turtle.clear()</li></ul><p>清空turtle窗口，但是turtle的位置和状态不会改变</p><ul><li>turtle.reset()</li></ul><p>清空窗口，重置turtle状态为起始状态</p><ul><li>turtle.undo()</li></ul><p>撤销上一个turtle动作</p><ul><li>turtle.isvisible()</li></ul><p>返回当前turtle是否可见</p><ul><li>stamp()</li></ul><p>复制当前图形</p><ul><li>turtle.write(s [,font=(“font-name”,font_size,”font_type”)])</li></ul><p>写文本，s为文本内容，font是字体的参数，分别为字体名称，大小和类型；font为可选项，font参数也是可选项<br>######(4)    其他命令</p><ul><li>turtle.mainloop()或turtle.done()</li></ul><p>启动事件循环 -调用Tkinter的mainloop函数。</p><p>必须是乌龟图形程序中的最后一个语句。</p><ul><li>turtle.mode(mode=None)</li></ul><p>设置乌龟模式（“standard”，“logo”或“world”）并执行重置。如果没有给出模式，则返回当前模式。</p><ul><li>turtle.delay(delay=None)</li></ul><p>设置或返回以毫秒为单位的绘图延迟。</p><ul><li>turtle.begin_poly()</li></ul><p>开始记录多边形的顶点。当前的乌龟位置是多边形的第一个顶点。</p><ul><li>turtle.end_poly()</li></ul><p>停止记录多边形的顶点。当前的乌龟位置是多边形的最后一个顶点。将与第一个顶点相连。</p><ul><li>turtle.get_poly()</li></ul><p>返回最后记录的多边形。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | Turtle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识</title>
      <link href="/posts/blog-python01.html"/>
      <url>/posts/blog-python01.html</url>
      
        <content type="html"><![CDATA[<h1 id="课程笔记"><a href="#课程笔记" class="headerlink" title="$课程笔记"></a>$课程笔记</h1><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-c7908d67f53948e5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><a href="https://www.w3cschool.cn/python/dict" target="_blank" rel="noopener">python相关函数查询</a></p><p><a href="https://docs.python.org/zh-cn/3/tutorial/index.html" target="_blank" rel="noopener">官方API文档</a></p><p><a href="https://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">菜鸟教程python</a></p><p><a href="https://www.w3cschool.cn/python/" target="_blank" rel="noopener">w3school教程python</a></p><h3 id="一-基本元素"><a href="#一-基本元素" class="headerlink" title="一.基本元素"></a>一.基本元素</h3><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul><li>变量赋值：<pre><code>a="hello world"</code></pre></li><li>变量命名：<br>• 字母：a-z, A-Z, 其他语言的字母符号<br>• 数字：0-9 (不可以出现在首字符)<br>• 下划线：_ （可以单用）</li><li>注意事项<br>• 在赋值时，变量即被创建，变量的值和类<br>型在赋值的时候被确定。<br>• 不需要声明（declaration）<br>• 变量名大小写敏感：A, a是不同的变量<br>• 变量可以被重新赋值<h5 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h5></li><li>数值类型<br>• 整数 Integers: 12 0 -12987 0123 0X1A2 10294L<br>   大致相当于C语言的 ‘int’ 或 ‘long’<br>   范围可以非常大（大致无限）<br>   八进制数以“0” 开始 (0981 是非法的!)<br>   十六进制以0X开始<br>• 浮点数Floating point: 12.03 1E1 -1.54E-21<br>   相当于C语言的double<br>• 复数Complex numbers: 1+3J<pre><code>语言原生支持</code></pre></li></ul><p><strong>运算注意事项：</strong><br>• 操作符和C语言类似，例如 +, -, /, <em>, %<br>• 幂操作：**</em><br>• 优先级和括号的作用相似</p><ul><li>逻辑类型<br>• 预定义值：True False<br>• 数值 0 认为是假，其他值认为是真<br>• 操作符：not, and, or</li></ul><p><strong>运算注意事项：</strong><br>• 比较运算获得逻辑值，运算符: &lt;, &lt;=, &gt;, &gt;=,<br>==, !=</p><ul><li><p>字符串类型<br>• 使用函数str, int, float等类型名进行转换</p><pre><code>b=int(a)c=flaot(a)d=str(a)</code></pre><p>• 字符串的拼接和整数乘法</p><pre><code>a="hello"+"world"b="hello"*2</code></pre><h5 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h5></li><li><p>代码缩进<br>• Python语 语 言 的 行 前 空 白 是 有 语 法 意 义 的<br>• 在源文件中，应该统一采取一种缩进格式<br>缩进进4个空格 （ 推 荐 标 准 ）<br>缩进2个空格<br>缩进1制表符（tab）<br>上述缩进不可以混用<br>• 连续处于相同缩进层次的语句构成一个语句块（Block）</p></li><li><p>条件语句</p><pre><code>if 条件：elif 条件：else:</code></pre></li><li><p>循环语句(for)<br>• 循环语句for<br>• range(n)表明从0开始，到n-1（含）。</p><pre><code>s = 0for i in range(10): # 0,1,...9  s += iprint(s)</code></pre></li><li><p>循环语句(while)</p><pre><code>s = 0i = 0while s&lt;10:  s += i  i += 1print(s)</code></pre></li><li><p>导入语句<br>三种写法：</p><pre><code>from math import *# use pi, cos, sin, ...from math import cos, sin# only use cos, sinimport math# use math.cos, math.sin, ...</code></pre></li><li><p>定义函数<br>• 用def定义函数，可以有参数和返回值</p><pre><code>def double(x):  return x * 2</code></pre><h5 id="turtle库详解"><a href="#turtle库详解" class="headerlink" title="turtle库详解"></a>turtle库详解</h5><p><a href="https://www.jianshu.com/p/29f5c970fa80" target="_blank" rel="noopener">python：turtle库详解</a></p><h3 id="python类型"><a href="#python类型" class="headerlink" title="python类型"></a>python类型</h3><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>• 标量类型<br>—— 逻辑类型(bool)<br>—— 整数(int)、浮点数(float)、复数(complex)<br>—— 空 类型 型(None)<br>• 集合类型<br>—— 字符串(str)<br>—— 列表(list)<br>—— 字典(dict)<br>—— 元组(tuple)<br>—— 集合(set)<br>• 自定义类型<br>—— 类 class</p><h5 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h5><p>• 除法有两种：/, // 后者是整除<br>—— 7/3 = 2.3333333333333335<br>—— 7//3 = 2<br>—— 7.0 // 3.0 = 2.0<br>• 幂运算允许实数<br>—— 7 ** 2 = 49<br>—— 7 ** 0.5 = 2.6457513110645907<br>• 不同类型的数值运算就高不就低<br>—— int —— float —— complex</p><h5 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h5><p>• 表达式</p><pre><code>x if c else y </code></pre><p>相当于</p><pre><code>c? x : y</code></pre><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>• 字符串的进阶操作</p><pre><code>'p' in s </code></pre><p>• 下标以0为开始</p><pre><code>s[0] # index: offset 0s[2:6] # slice: part of strings[:6] s[6:]</code></pre><p>• 逆序的下标</p><pre><code>s[-1]s[-3:-1]s[1:-1]s[-3:]</code></pre><p>• 步长：begin:end:step</p><pre><code>s[::2]s[1::3]s[5:1::-1]"live"[::-1]</code></pre><h5 id="不可修改类型-Immutable"><a href="#不可修改类型-Immutable" class="headerlink" title="不可修改类型 Immutable"></a>不可修改类型 Immutable</h5><p>• 数值类型、字符串类型是不可修改类型<br>—— 后续讲解的元组（tuple）类型也是不可修改类型<br>• 它们的值是常数，不可以修改<br>—— 我们并不能把“1”修改为“2”，把“abc”改为“def”；<br>—— 作为值，它的含义是确定的、不变的。<br>• 赋值语句（Assignment）是给这些常数的值赋予不同的名称</p><h5 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h5><pre><code>s = 'I love Python's.count('on') # 查找子串出现次数s.find('ove') # 查找子串首见位置s.replace('Python', 'C++') # 替换three = '3'three.isdigit() # 是否为数字字符?</code></pre><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5></li><li><p>相关事项<br>• 表（或称为列表，广义表）是python最重要<br>和常用的容器类<br>• 由一系列有序排列的对象构成（Ordered<br>collection of objects）~ C语言的数组<br>• 异构（Heterogenous），一个列表可以包含<br>多种类型的对象。</p><pre><code>r = [1, 2.0, 3, 5] # list的字面构造r[1] # 正数下标自首部计数，首部为0r[-1] # 负数下标自尾部计数，尾部为-1r[1:3] # 前闭后开区间w = r + [10, 19] # 连接t = [0.0] * 10 # 重复len(r)</code></pre></li><li><p>列表操作</p><pre><code>r = [[9, 8], 2.0, 3, 'word']r[0:3] = [1, 2, 5, 6] # 修改片段r[1:3] = [] # 删除元素r[1:1] = [ 'new' ] # 赋值语句左右侧都是片段；等价于插入[1, 'new', 6, 'word']r[len(r):] = [ 'last' ] # 在尾部插入[1, 'new', 6, 'word', 'last']</code></pre></li><li><p>列表的方法</p><pre><code>r.insert(0, 'f') # 在0位置增加新元素'f'del r[0]r.append(9) # 尾部增加元素r.sort() # in-place 排序r.reverse() # 逆序</code></pre></li><li><p>判断两个变量是否指向同一对象<br>• 利用id函数，返回对象的唯一标志<br>• id(x) == id(y) 表明x和y实际上是同一对象<br>• x is y</p></li><li><p>列表推导</p><pre><code>[i for i in range(9)][i*2 for i in range(9)][i for i in range(100) if '4' not in str(i)]</code></pre><p>• 补充<br>—— Python 一行语句过长，可以用 \ 续行<br>—— 若在括号（花方圆均可）内可以自由换行</p><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5></li><li><p>基本事项<br>• 字典是一种数据组织方式，它根据 key获得对应的value<br>• key称为键，key是无序的，或者说不关注其顺序。<br>• value称为值，可以是任意的对象。<br>• 字典也称为映射(mapping)、哈希(hash)表、查找表(lookup table)等。</p></li><li><p>字典操作</p><pre><code>g = {'Tom': 'boy', 'Mary': 'girl'}g['Tom'] # 以key为索引g.has_key('Mary')g['Jack'] = 'boy' # 增加键值对del g['Tom'] # 删除键，删除键到值的绑定h = {'Tom': 12, 'Mary': 'good'}'Per' in h # 在键的集合中检测h.get('Per', 'unknown') # 如果查找失败则返回缺省值h.keys() # 由键组成的列表，顺序不确定h.values() # 由值组成的列表，顺序不确定h.items() # 顺序同上len(h) # 键的数量</code></pre><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5></li><li><p>注意事项<br>• 与list相同，但不可改变（immutable）<br>• 一旦创建，不可修改。（Once created, can’t be changed.）</p><pre><code>t = (1, 3, 2)t[1] # 3(a, b, c) = t # 元组赋值a, b, c # (1, 3, 2)</code></pre><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5></li><li><p>注意事项<br>• 数学中的集合，无序，不重复（set）<br>• 去重的时候很有用</p><pre><code>s = set()s = {1, 2, 3}s.add(4) # {1,2,3,4}s.add(1) # {1,2,3,4}t = {1,2}# &amp;交集，|并集 - 差集s - t # {3,4}</code></pre><h5 id="容器间转换"><a href="#容器间转换" class="headerlink" title="容器间转换"></a>容器间转换</h5><p>• list, set, dict 作为类型名可以实现转换<br>—— list(“abc”)    = [“a”, “b”, “c”]<br>—— set([1,2,2])     = {1,2}</p><h3 id="Python语句"><a href="#Python语句" class="headerlink" title="Python语句"></a>Python语句</h3><h5 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h5><p>• pass是一个（占位）空语句，不做任何事情<br>• 动因<br>—— python利用缩进表达语句块，如果语句块是空的，不写会有错；<br>—— 这种情况下，可以写上pass</p><h5 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h5><p>• for可以遍历任意的容器<br>—— 对词典遍历的是keys()<br>• range(n)是一个内置函数，返回0~n-1的列表<br>• range(start, stop, step)</p><h5 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h5><p>• 跳出最内层的循环<br>• python没有直接跳出外层循环的语法手段<br>—— 通常会借助额外的flag变量<br>—— 异常处理</p><h5 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h5><p>• 它结束当前迭代，并跳到下一次迭代开头。即跳过循环体中余下的语句，但不结束循环。<br>• 可以用等价的if语句描述</p><h5 id="for-while-else语句"><a href="#for-while-else语句" class="headerlink" title="for/while-else语句"></a>for/while-else语句</h5><p>• 只要不是break跳出循环，就执行else语句<br>• 相比C语言减少一个flag变量</p><pre><code>r = [1, 3, 10, 98, -2, 48]for i in r:  if i &lt; 0:      print('input contains negative value!')      breakelse:  print('input is OK')</code></pre><h5 id="exec和eval"><a href="#exec和eval" class="headerlink" title="exec和eval"></a>exec和eval</h5><p>• 动态地编写Python代码，并将其作为语句进<br>行执行或作为表达式进行计算<br>• 函数exec将字符串作为代码执行<br>• eval计算用字符串表示的Python表达式的值，<br>并返回结果。<br>• 如下代码来创建一个Python计算器</p><h5 id="assert断言语句"><a href="#assert断言语句" class="headerlink" title="assert断言语句"></a>assert断言语句</h5><p>• 要求某些条件得到满足，否则将引发异常<br>• 确保程序的参数合理<br>• 对于不合理的情况，明确引发异常</p><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5></li><li><p>完整的异常处理</p><pre><code>try:  1 / 0except NameError:  print("Unknown variable")         出现异常时执行。。。else:  print("That went well!")             没有出现异常时执行finally:  print("Cleaning up.")             任何情况下都会执行</code></pre><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>• 函数名：规则与变量名相同<br>• 参数列表：调用函数时传递给它的值<br>—— 可以由零个，一个或者多个参数组成<br>—— 当有多个参数时，各个参数用逗号分隔<br>• 函数体：函数被调用时执行的代码<br>—— 由一个或多个语句组成<br>—— 在执行到末尾或return语句时退出函数<br>—— 返回结果<br>• 函数调用的形式<br>—— 函数名( 参数列表 )<br>• 形式参数（名）：定义函数时，函数名后面圆括号中的变量。形参只在函数内部有效。<br>• 实际参数（值）：调用函数时，函数名后面圆括号中的变量。</p><h5 id="参数能否修改：总结"><a href="#参数能否修改：总结" class="headerlink" title="参数能否修改：总结"></a>参数能否修改：总结</h5><p>• 凡是Immutable类型的参数，传入的对象值不可能修改<br>• 对于Mutable类型的参数：<br>—— 若对形参进行赋值，并不能改变传入对象的值<br>—— 若对形参进行in-place的修改，则该修改也反应在传入的对象上</p><h5 id="关键字参数的缺省值"><a href="#关键字参数的缺省值" class="headerlink" title="关键字参数的缺省值"></a>关键字参数的缺省值</h5><p>• 可以设定一些参数的缺省值（默认值）<br>• 如果调用者没有提供，则使用缺失值</p><pre><code>def hello(name, greeting="Hello"):</code></pre><p>• 允许用户提供任意数量的参数</p><pre><code>def sum_of_all(*values):</code></pre><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5></li><li><p>注意事项<br>• 如果没有局部变量和全局变量同名，可以直接读取全局变量。<br>• 如果有一个局部变量与待访问的全局变量同名，则无法直接访问全局变量，因为它被局部变量遮住了。<br>• 可以使用关键字 global（nonlocal）修饰变量名，表明和全局（外层）变量关联。<br>• Python的函数可以作为返回值</p><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>• lambda可以用来定义函数</p><pre><code>pow2_a = lambda x: x*xdef pow2_b(x):    return x*x</code></pre><p>两者功能相同</p><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>• 对于稍微大型的程序，代码量较大，不宜<br>放在一个文件中<br>• 模块可以将代码分散在不同的文件</p><h5 id="主模块"><a href="#主模块" class="headerlink" title="主模块"></a>主模块</h5><pre><code>if __name__ == "__main__":    do_something()</code></pre><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><h5 id="字符的分类"><a href="#字符的分类" class="headerlink" title="字符的分类"></a>字符的分类</h5><p>• 数字 digits 01234567890<br>• 字母 letter<br>大写ABCDEFGHIJKLMNOPQRSTUVWXYZ<br>小写 abcdefghijklmnopqrstuvwxyz<br>• 空白字符：空格，\t\n\r\v<br>• 对应Unicode，上述概念有一定拓展。</p><h5 id="字符串对象方法"><a href="#字符串对象方法" class="headerlink" title="字符串对象方法"></a>字符串对象方法</h5></li><li><p><strong>capitalize()</strong> 字符串首字母大写</p></li><li><p><strong>lower()</strong> 转为小写</p></li><li><p><strong>upper()</strong> 转为大写</p></li><li><p><strong>find(s)/rfind(s)</strong>  正向/逆向查找子串s的出现位置</p></li><li><p><strong>count(s)</strong>  查找s出现的次数</p></li><li><p><strong>strip()</strong>  移除开始和结束的空白</p></li><li><p><strong>lstrip()/rstrip()</strong>移除开始/结束的空白</p></li><li><p><strong>replace(s, r)</strong> 将子串s替换为r（缺省为全替换，可以仅替换指定次数）</p></li><li><p><strong>isalpha()/isdigit()</strong> 是否是字母、数字等……</p></li><li><p><strong>isupper()/Islower()</strong> 是否大写小写等….</p></li><li><p><strong>startswith(s)/endswith(s)</strong> 是否以s作为字符串的开始或结尾</p></li><li><p><strong>s.split(sep)</strong> 将字符串sep作为分隔符，对字符串s进行分解，返回列表</p></li><li><p><strong>sep.join(parts)</strong>  将各部分用分隔符sep连接在一起</p></li></ul><h5 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h5><p>• 字符串的格式化有三种方法<br>• %, format, f-string</p><ul><li>% 操作符</li></ul><p><strong>用法:</strong> str % parameter_tuple</p><pre><code>"the number is %d" % 30</code></pre><ul><li>%-format</li></ul><p><strong>%c</strong> character<br><strong>%s</strong> string conversion via str() prior to formatting<br><strong>%i</strong>  signed decimal integer<br><strong>%d</strong> signed decimal integer<br><strong>%u</strong> unsigned decimal integer<br><strong>%o</strong> octal integer<br><strong>%x</strong> hexadecimal integer (lowercase letters)<br><strong>%X</strong> hexadecimal integer (UPPERcase letters)<br><strong>%e</strong> exponential notation (with lowercase ‘e’)<br><strong>%E</strong> exponential notation (with UPPERcase ‘E’)<br><strong>%f</strong> floating point real number<br><strong>%g</strong> the shorter of %f and %e<br><strong>%G</strong> the shorter of %f and %E<br><strong>*</strong> argument specifies width or precision<br><strong>-</strong>  left justification<br><strong>+</strong> display the sign<br><strong><sp></sp></strong> leave a blank space before a positive number<br><strong>#</strong> add the octal leading zero ( ‘0’ ) or hexadecimal leading ‘0x’or ‘0X’, depending on whether ‘x’ or ‘X’ were used.<br><strong>0</strong> pad from left with zeros (instead of spaces)<br><strong>%</strong> ‘%%’ leaves you with a single literal ‘%’<br><strong>(var)</strong> mapping variable (dictionary arguments)<br><strong>m.n.</strong> m is the minimum total width and n is the number of digitsto display after the decimal point (if appl.)</p><pre><code>name = "John"age = 23print("%s is %d years old." % (name, age))</code></pre><ul><li>str.format方法<br>• 原先的用法：’%s %s’ % (‘one’, ‘two’)<br>• 目前的用法：’{} {}’.format(‘one’, ‘two’)<pre><code>"{0} {1}, you may have won ${2}" .format("Mr.", "Smith",10000)'int, {0:5}, in a field of width 5'.format(7)' {0:10.5f}, fixed at 5 decimal places.'.format(3.1415926)</code></pre></li><li>f-string<pre><code>name = "Eric"age = 24f"Hello, {name}. You are {age}."</code></pre>f-string是python3版本的新语法，是一种表达式。</li><li>split-join<br>• split用于将长字符串进行分解<br>• join用于合并短字符串<br>• 常见的分隔符号有：\t , ; . - /<pre><code>"www.ustb.edu.cn".split(".")[ int(i) for i in "166.111.4.80".split(".") ]".".join([ f"{i}" for i in [166, 111, 4, 80] ])</code></pre><h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5></li><li>通配符：匹配任意字符</li><li>字符组（类）<br>• 字符类 [] 用于匹配一组字符<br>• 可以用 [^] 表达不匹配组里面的任意字符<br>• Ranges 可以表示一个范围的字符<br>—— [1-9] 即 [123456789]<br>—— [abcde] 即 [a-e]<br>—— [abcde123456789] 即 [a-e1-9]</li><li>预定义的字符组</li></ul><p><strong>\d</strong>  数字 [0-9]<br><strong>\D</strong> 非数字 [^0-9]<br><strong>\s</strong> 空白字符 [ \f\n\r\t\v]<br><strong>\S</strong> 非空白字符 [^ \f\n\r\t\v]<br><strong>\w</strong> 字母数字下划线 [A-Za-z0-9_]<br><strong>\W</strong> 非字母数字下划线 [^A-Za-z0-9_]</p><ul><li>锚 Anchors<br>• ^ 即行首 beginning of the line，在多行模式下匹配每行的开始位置<br>• $ 即行尾 means end of the line，在多行模式下匹配每行的结束位置<br>• \A 仅行首<br>• \Z 仅行尾<br>• \b 匹配单词的边界<br>—— 从字母数字到非字母数字的过渡边界，\w\W 或 \W\w</li><li>重复指示Repetions<br>• 三种 * + ?<br>• * 指示其前置内容0<del>+inf次出现，也就是<br>任意多次<br>• + 1</del>+inf<br>• ? 0~1</li><li>重复数量的范围指示<br>• 可以用 {n,m} 指示范围<br>—— {n,m} 表示n~m次<br>—— {n} 表示恰好n次 exactly n occurrences<br>—— {n,} 表示至少n次 at least n occurrences<br>• 示例:<br>—— .{0,} 等价于 .*<br>—— a{2,} 等价于 aaa*</li><li>子表达式<br>• 重复指示仅修饰其前面的一个符号，如果<br>想表示多个符号，需要对正则表达式进行<br>分组，用 （）进行划分，称为子表达式<br>• 子表达式作为一个整体被修饰<br>—— a* 匹配a的0次货多次出现<br>—— abc* 匹配 ab, abc, abcc, abccc, …<br>—— (abc)* 匹配 abc, abcabc, abcabcabc, …<br>—— (abc){2,3} 匹配 abcabc or abcabcabc</li><li>或<br>• 符号 | 表示匹配该符号前面的或后面的子表达式<br>—— (T|Fl)an 匹配 Tan or Flan<br>—— ^(From|Subject): 匹配邮件头部<br>• 优先级最低，可以用 （） 改变<br>•  示例：<br>—— At(ten|nine)tion 匹配Attention or Atninetion<br>—— 不能匹配Atten or ninetion 除非未加括号即Atten|ninetion</li><li>转义<br>• 很多字符（如“.”）在正则表达式中有特殊含义，如果只代表它原本的字面意义就需要转义，例如“.”仅匹配句点本身。<br>—— 目标仅匹配单个句点： .<br>—— 在正则表达式层面需要看到： .<br>—— 在字符串书写时需要写： “\.”<br>• 匹配反斜线<br>—— 目标仅匹配单个反斜线： <br>—— 在正则表达式层面需要看到： \<br>—— 在字符串书写时需要写： “\\“<br>• 匹配数字\d<br>—— 在正则表达式层面需要看到： \d<br>—— 在字符串书写时需要写： “\d”</li></ul><p>• 匹配国内电话号码：\d{3}‐\d{8}|\d{4}‐\d{7}<br>—— 如 0511-4405222 或 021-87888822<br>• 腾讯QQ号：[1‐9][0‐9]{4,}<br>—— 腾讯QQ号从10000开始<br>• 中国邮政编码：[1‐9]\d{5}(?!\d)<br>—— 中国邮政编码为6位数字<br>• 匹配身份证：\d{15}|\d{18}<br>—— 中国的身份证为15位或18位<br>• 匹配ip地址：\d+.\d+.\d+.\d+<br>—— 提取ip地址时有用</p><ul><li><p>子表达式的引用<br>• \n  此处n是一个数字，表示第n个子表达式的值。子表达式的序号按左括号计数。<br>• 例如：<br>—— (.+) \1 匹配 55 55，或者the the<br>• 可以给子表达式予以命名<br>• (?P<name>…)<br>• (?P=name)</name></p><h5 id="Python的正则表达式模块"><a href="#Python的正则表达式模块" class="headerlink" title="Python的正则表达式模块"></a>Python的正则表达式模块</h5><p>• 模块导入 <strong>import re</strong><br>• 匹配：re.match() 查找字符串的开始部分是否匹配，不向后查找（类似字符串startswith）<br>• 查找：re.search() 查找是否存在匹配（类似字符串find）<br>• 替换：re.sub() 替换正则表达式（类似字符串replace）</p></li><li><p>match的用例</p><pre><code>s = "2019‐03‐20 is a rainy day"pat = "\\d‐\\d‐\\d"m = re.match(pat, s)m.start()m.end()m.group()  #返回匹配对象(Match)，有start, end, group方法</code></pre></li><li><p>search的用例</p><pre><code>s = "It is reported that 2019‐03‐20 is a rainyday."pat = "\\d‐\\d‐\\d"m = re.search(pat, s)m.start()m.end()m.group() </code></pre></li><li><p>多次查找findall/finditer</p><pre><code>s = """You smiled and talked to me of nothing and I felt that for this I had been waiting long."re.findall("\\b(\\w+ed)\\b", s)re.finditer(...) # 类似，但返回一个个Match对象</code></pre></li><li><p>替换sub<br>• 04/30/2018 转换为 2018-04-30<br>• 利用re.sub</p><pre><code>import reprint re.sub("([0‐9]{2})/([0‐9]{2})/([0‐9]{4})","\\3‐\\1‐\\2","This is a test 01/30/2019.")</code></pre><h5 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h5></li><li><p>基础概念<br>• 文件包括两种类型：文本文件和二进制文件<br>• 二进制文件：直接由比特0和比特1组成，没有统一字符编码，文件内部数据的组织格式与文件用途有关。<br>• 文本文件：以ASCII码方式存储的文件。<br>• 二进制文件和文本文件区别：仅编码（人为的理解）存在差异。<br>• 文件包括两种类型：文本文件和二进制文件<br>• 二进制文件：直接由比特0和比特1组成，没有统一字符编码，文件内部数据的组织格式与文件用途有关。<br>• 文本文件：以ASCII码方式存储的文件。<br>• 二进制文件和文本文件区别：仅编码（人为的理解）存在差异。</p></li><li><p>文件操作<br>• 打开文件 open<br>—— 建立磁盘上的文件与程序中的对象相关联<br>—— 通过相关的文件对象获得<br>• 文件操作<br>—— 读取<br>—— 写入<br>—— 定位<br>—— 其它：追加、计算等<br>• 关闭文件 close<br>—— 切断文件与程序的联系<br>—— 写入磁盘，并释放文件缓冲区</p></li><li><p>文件打开操作<br>• 打开文件<br>—— Python使用open()函数打开文件并返回文件对象：</p><pre><code>&lt;变量名&gt;=open(file, mode = 'r')</code></pre><p>—— open函数有两个参数：文件名和打开模式。文件名可以是包含完整路径的名字，或当前路径下的文件名。<br>—— 第二个参数制定文件打开模式。<br>• open()函数提供7种基本的打开模式</p></li></ul><p><strong>‘r’</strong>  以只读方式打开文件（默认）如果文件不存在，返回异常FileNotFoundError。<br><strong>‘w’</strong> 以写入的方式打开文件，文件不存在则创建，会覆盖已<br>存在的文件。<br><strong>‘x’</strong> 打开一个新文件来写数据。文件不存在则创建，如果数<br>据已经存在则返回异常FileExistsError。<br><strong>‘a’</strong> 以写入模式打开，文件不存在则创建，如果文件存在，<br>则在末尾追加写入。<br><strong>‘b’</strong> 以 二进制模式打开文件。<br><strong>‘t’</strong> 以 文本模式打开 （默认）。<br><strong>‘+’</strong> 可读写模式（可添加到其它模式中使用）。<br>• 模式的组合使用<br>—— ‘r’,’w’,’x’,’a’可以和’b’,’t’,’+’组合使用，形成既表达读写又表达文件模式的方式。<br><strong>例如：</strong><br>——‘wb’表示“写二进制数据”<br>——‘x+b’表示读写一个新的二进制文件</p><ul><li>文件的读写操作<br>• 文件的读写：根据打开方式不同可以对文件进行相应的读写操作，Python提供4个常用的文件内容读取方法。</li></ul><p><strong><file>.readall()</file></strong> 读入整个文件内容，返回一个字符串或字节流。<br><strong><file>.read(size=‐1)</file></strong> 从文件读取size个字符，当未给定size或给定负值的时候，读取剩余的所有字符，文件指针指向文件末尾。<br><strong><file>.readline(size=‐1)</file></strong> 从文件中读入一行内容，如果给出参数，读入该行前size长度的字符串或字节流。<br><strong><file>.readline(hint=‐1)</file></strong>从文件中读入所有行，以每行为元素形成一个列表，如果给出参数，读入hint行。<br>• Python提供3个与文件内容写入有关的方法。<br><strong><file>.write(str)</file></strong> 将字符串str写入文件。<br><strong><file>.writelines(lines)</file></strong>将一个元素为字符串的列表写入文件。<br><strong><file>.seek(offset,from)</file></strong>改变当前文件操作指针的位置，从from(0代表文件起始位置，1代表当前位置，2代表文件末尾）偏移offset个字节。</p><ul><li>文件操作示例<br>• 文本文件逐行打印输出<pre><code>fo = open(fname ,"rt")for line in fo.readlines():  print(line)fo.close()</code></pre></li><li>文件操作示例<pre><code>f1 = open(f1name, "rt")f2 = open(f1name, "wt")f2.write(f1.read().upper())f1.close()f2.close()</code></pre></li><li>with语句<br>• 容易忘记关闭(close)文件<pre><code>f = open('todos.txt')for chore in f  print(chore, end='')tasks.close()#使用with语句重写这个代码with open('todos.txt') as f:for chore in f:  print(chore, end='')</code></pre>• with确保即使发生异常，也可以正确的关闭文件</li><li>编码的文件<br>• 若打开有编码的文件，需要用codecs模块<br>• import codecs<pre><code>f1 = codecs.open(fname, "r", "utf‐8")f2 = codecs.open(fname, "w", "gb2312")</code></pre></li><li>词频统计<pre><code>f = open("alice.txt", "rt")all = f.read()f.close()count_word = {}for w in all.split():  w_lowercase = w.lower()  count_word[w_lowercase] = \                                      count_word.get(w_lowercase, 0) + 1result = [(v, k) for k, v in count_word.items()]result.sort()top10 = result[‐10:]for v,k in top10[::‐1]:  print(f"Word {k}, occurs {v} times")</code></pre><h5 id="汉字的处理"><a href="#汉字的处理" class="headerlink" title="汉字的处理"></a>汉字的处理</h5></li><li>导入库<br>• pip install regex<br>• import regex as re<br>• \p{han} 匹配汉字</li><li>汉字分词<br>• jieba是Python中一个重要的第三方中文分词函数库。<br>• 第三方库，需要安装</li></ul><p><strong>jieba.cut(s)</strong> 精确模式，返回一个可迭代的数据类型<br><strong>jieba.cut(s,cut all=True)</strong> 全模式，输出文本s中所有可能单词<br><strong>jieba.cut_for_search(s)</strong> 搜索引擎模式，适合搜索引擎建立索引的分词结果<br><strong>jieba.lcut(s)</strong> 精确模式，返回一个列表类型，建议使用<br><strong>jieba.lcut(s,cut all=True)</strong> 全模式，返回一个列表类型，建议使用<br><strong>jieba.lcut_for_search(s)</strong> 搜索引擎模式，返回一个列表类型，建议使用<br><strong>jieba.add_word(w)</strong> 向分词词典中增加新词w</p><h3 id="OOP编程"><a href="#OOP编程" class="headerlink" title="OOP编程"></a>OOP编程</h3><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>• 类是类型概念的发展。<br>—— 对象是广义的“数据值”。<br>—— 对象所属的数据类型就是“类”。<br>—— 用于描述复杂数据的静态和动态行为。<br>• 类（class）：描述相似对象的共性。包括<br>—— 数据<br>—— 操作：方法（method）<br>• 对象是类的实例（instance）<br>—— 创建对象<br>• 类的封装:数据和操作结合成一个程序单元,对外部隐藏内部实现细节。<br>—— 不允许用户直接操作类中被隐藏的信息。<br>—— 用户也无需了解隐藏的信息就能使用该类。<br>• 类对外公开方法名称和调用格式,即界面。<br>—— 外界向对象发消息。(方法名及参数)<br>—— 对象响应消息,执行相应方法。<br>—— 外界只能按对象允许的方式来处理对象数据。<br>• 封装的好处<br>—— 安全:对象自己的方法处理自己的数据<br>—— 易用:使用者无需了解内部实现细节<br>—— 易维护:实现者修改内部实现不会影响使用者<br>—— 标准化:同类甚至不同类的对象对使用者都呈现同样的操作界面<br>• 方法定义同函数定义</p><pre><code>def &lt;methodname&gt;(self, other params):</code></pre><p>—— 方法是依附于类的函数,普通函数则是独立的。<br>—— 方法的第一个参数是专用的，习惯用名字self。<br>—— 大体上等价于C++的this<br>—— 只能通过向对象发消息来调用方法。<br>• 对象是数据和操作的结合。<br>—— 方法对应于操作<br>—— 对象的数据以实例变量形式定义。<br>—— 实例变量：self.varname<br>—— 对象变量和所指向的数据本质上是一个词典<br>—— self.varname  即 self[“varname”]<br>—— 实例变量的赋值主要出现在<strong>init</strong>()方法中。</p><ul><li>类的定义实例<pre><code>class Circle:""" Class definition for a circle """def __init__(self, radius):  self.radius = radiusdef getRadius(self):  return self.radiusdef getArea(self):" Obtain the area of a circle"  return math.pi*self.radius**2</code></pre></li><li>创建实例<br>• 实例创建<br>&lt; 变量&gt; = &lt; 类名&gt; （&lt; 实参&gt; ）<br>这里&lt;类名&gt;相当于一个函数，称为构造器，用来构造实例。<br>• 成员访问<br>• 方法调用<br>—— 类似函数调用,但需指明实例(对象)<br>—— &lt; 实例&gt;.&lt; 方法名&gt;(&lt; 实参&gt;)<br>—— &lt;实例&gt;就是与形参self对应的实参<br>• 数据成员访问<br>—— &lt; 实例&gt;.&lt; 数据成员名&gt;<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5>• 在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class） 。<br>• 继承是面向对象的重要特征之一，继承是两个类或者多个类之间的父子关系，子类继承了父类的所有实例变量和方法。<br>• 继承实现了代码的重用。重用已经存在的数据和行为，减少代码的重新编写。<br>• Python在类名后用一对圆括号表示继承关系，括号中的类表示父类。<pre><code>class 类名（被继承的类）：</code></pre></li><li>实例和类的关系判定<br>• isinstance(s, t)函数判定s是否t类型（及其子类型）<br>—— isinstance(c, Circle)<br>—— isinstance(c, DrawableCircle)<br>• 继承关系：is-a  （注：相当于c++的公有继承）<br>• DrawableCircle is a Circle<br>• 一个实例属于某个子类，则也属于父类，反之则不行。<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5>• 当对一个对象调用draw()函数时，它会根据自己的对象类型执行不同的draw方法<br>—— FilledDrawableCircle.draw()<br>—— DrawableCircle.draw()<br>• 对于相同的方法，会有不同的实现版本，这就是多态（Polymorphism）<h3 id="科学计算与可视化"><a href="#科学计算与可视化" class="headerlink" title="科学计算与可视化"></a>科学计算与可视化</h3><h5 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h5>• NumPy（Numeric Python）是Python语言的一个扩展包。<br>• 由多维数组对象和数组计算函数共同组成的库，支持多维数组、矩阵运算以及大量数值计算功能。</li><li>Numpy产生动机<br>• 标准的Python中用列表(list)保存一组值，可以作为数组使用。<br>• Python列表的元素可以是任何对象，因此对象需要额外的信息保存其类型等信息，Python本身是解释型语言。因此，对数值运算来说，效率较低。<br>—— 1000*1000的矩阵乘法，基于python实现三层循环超过10分钟。<br>—— Numpy 大约0.03秒。<br>• 计算效率直接影响了科学计算、机器学习的可用性。<br>• Python的列表不支持数值计算语义<br>• 能否实现矢量、矩阵的加法？乘法？逆？<br>• 因此，需要原生支持数值计算语义的，高效率的Python库<br>• NumPy的诞生弥补了这些不足<br>• NumPy提供了两种基本的对象<br>—— ndarray（ndimensional array object ）<br>—— ufunc（ universal function object）<br>• ndarray(数组)是存储单一数据类型的多维数组。<br>• ufunc 是对数组进行处理的函数。<pre><code>• 安装：pip install numpy• 导入：import numpy as np</code></pre></li><li>Numpy的优势<br>• NumPy 通 常 与 SciPy(Scientific Python)和Matplotlib(绘图库)一起使用，这种组合广泛用于替代Matlab，已成为流行的技术方案。<br>• Python：通用语言<br>• Matlab：专用语言<br>• NumPy是开源的（Open-Source）</li><li>Numpy做什么<br>• 矢量、矩阵和高维数组（张量）的数值运<br>算和逻辑运算<br>• 线性代数相关的操作<br>• 随机数生成<br>• 傅立叶变换<br>• 图形操作<br>• 其他功能</li><li>量<br>• 矢量 Vectors<br>• 矩阵 Matrices<br>• 图像 Images<br>• 张量 Tensors</li><li>Ndarray<br>• ndarray：N维数组类型<br>• 描述相同类型的元素集合<br>• 使用基于零的索引访集合中的项目<br>• ndarray中的每个元素类型（dtype）相同，占用的内存大小也相同。</li><li>Ndarray的创建<br>• numpy.array(object, dtype = None, order =None)<br>• object通常是一个容器或迭代器，根据其内容生成一个ndarray对象实例<br>• dtype如果不指定，自动从实际数据中推断<br>• order和内存中数据排列有关</li><li>dtype<br>• int8, int16, int32, int64<br>• uint8, uint16, uint32, uint64<br>• float16, float32, float64<br>• complex64, complex128</li><li>数组属性<br>• 数组的维度：ndim<br>• 数组的形状：shape<pre><code>import numpy as npx = np.array([1, 2, 3])y = np.array([4.0, 5, 6])print(x.dtype, x.shape, x.ndim)print(y.dtype, y.shape, y.ndim)z = x + yprint(z)</code></pre></li><li>数组创建<br>• 数组创建的其他方法<br>—— numpy.empty：空，不初始化值，值可能任意<br>—— numpy.zeros：0<br>—— numpy.ones：1<br>—— numpy.arange：start, stop, step 可以为浮点数，但是不推荐用在浮点数场合。<br>—— numpy.linspace：start, stop, number 实现均匀划分（默认含右侧端点），推荐在浮点数场合使用。<pre><code>array = np.array([[0,1,2],[2,3,4]])# [[0 1 2]#  [2 3 4]]array = np.zeros((2,3))# [[0. 0. 0.]# [0. 0. 0.]]array = np.ones((2,3))# [[1. 1. 1.]# [1. 1. 1.]]</code></pre>• eye 单位矩阵<br>• 浮点数优先用linspace，避免累计误差<br>• np.random 类似于random<pre><code>array = np.eye(3)# [[1. 0. 0.]# [0. 1. 0.]# [0. 0. 1.]]array = np.arange(0, 10, 2)# [0, 2, 4, 6, 8]array = np.linspace(0, 1, 11)# [0. , 0.1, 0.2, 0.3,…, 0.7, 0.8, 0.9, 1. ]array = np.random.randint(0, 10, (3,3))# [[6 4 3]# [1 5 6]# [9 8 5]])</code></pre></li><li>索引和切片(slice)<br>• 一维数组的索引和切片大体与list相同<pre><code>a = np.arange(9)a[0]# 0a[3:7]# array([3, 4, 5, 6])a[:7:2]# array([0, 2, 4, 6])a[::‐1]#array([8, 7, 6, 5, 4, 3, 2, 1, 0])</code></pre>• 多维数组：每一个维度都可以进行索引或切片，<br>返回一个标量或多维的子数组（view）。<br>• 对此子数组的修改可能会反应在原数据上！<pre><code>b = np.array([[0,1,2],[3,4,5]])#[[0 1 2]#  [2 3 4]]b[0,1]# 1b[1,:]#[3,4,5]b[:,2]#[2,5]</code></pre></li><li>数组的运算<br>• shape相同的多维数组，支持+ ‐ * / % &lt; &gt; == &gt;= &lt;= 等运算，对应的元素逐个进行运算，返回具有相同shape的多维数组<br>• 单目运算作用在数组上，对每个元素逐个实施，包括负号 ‐ 以及单自变量函数 sin,cos 等<br>• 上述运算是element-wise意义上的<pre><code>arr = np.array([[1., 2., 3.], [4., 5., 6.]])print(arr)[[1. 2. 3.][4. 5. 6.]]print(arr * arr)[[ 1. 4. 9.][16. 25. 36.]]print(arr ‐ arr)[[0. 0. 0.][0. 0. 0.]]</code></pre></li><li>数组的运算：广播<br>• shape不相同的数组如何运算？<br>• 一般意义的逐元素的运算不可实现。<br>• 但可以通过广播实现，小的数组被广播为大的数组，从而使得两个数组兼容。<br>• 在下列规则满足时可以广播：<br>—— 维数小的数组，在它的shape前面补“1”<br>—— 在某个维度两个数组大小或者相同或者有一个是“1”<br>—— 如果在某个维度是“1”，则需要任何下标[*]时，用[0]元素代替（相当于复制为很多份）<br>• 等价地说，广播运算在下列情况之一成立时可以执行<br>—— 具有相同的shape<br>—— 具有相同的维度，shape每一维的值或者相同或者有一方为1<br>—— 具有不同的维度，但是维数少的在前面补齐“1”后符合上述条件</li><li>逻辑型数组索引<br>• 逻辑型数组可以作为索引<br>—— 如比较运算的结果为一个逻辑型数组<br>• 掩码（Mask），表示仅取索引True的元素，构成一个子数组。<pre><code>x = np.arange(10)mod5 = x % 1 == 1x [ mod5 ] # [1, 6]x [ x &gt; 5 ] ?</code></pre>• 整数型数组（或list）可以作为索引<br>• 逐个取出每个整数对应下标的元素，得到ndarray数组的子集<pre><code>x = np.arange(10)*10# array([ 0, 10, 20, 30, 40,50, 60, 70, 80, 90])x[[1,3]]# array([ 10, 30])x[[5,3,7]]# array([ 50, 30, 70])</code></pre></li><li>view和copy<br>• 为了提高效率、节约空间，有些numpy操作返回的是view，对view的修改可以改动原始数组中的数据改动原始数组中的数据。<br>• 具体返回view或copy需要查看函数说明。<br>• 显式的复制可以用copy函数。<br>—— a.copy()<br>—— np.copy(a)</li><li>数组的拼接<br>• np.concatenate([a1, a2, …],axis=0, out=None)<br>• 参数说明：<br>—— a1, a2, … : 一系列的ndarray，必需是相同的shape，除非在第axis维可以存在差异。<br>—— axis : int, 缺省为0<br>• 按照第axis维把上述数组拼接在一起<pre><code>A = np.ones((4,1))array([[1.],[1.],[1.],[1.]]B = np.zeros((4,2))array([[0., 0.],[0., 0.],[0., 0.],[0., 0.]])C = np.concatenate([A, B], axis=1)array([[1., 0., 0.],[1., 0., 0.],[1., 0., 0.],[1., 0., 0.]])</code></pre></li><li>数组的创建<br>• np.zeros_like<br>• np.ones_like<br>• np.empty_like<br>• 参数是另一个数组，按照其形状创建一个0/1/空的数组</li><li>reshape<br>• 在保持总元素的数目不变的条件下，数组的形状可以更改<br>• 默认的order是row-major<pre><code>a = np.array([1,2,3,4,5,6])a = a.reshape(3,2)"""array([[1, 2],[3, 4],[5, 6]])"""a = a.reshape(2,‐1)</code></pre></li><li>平坦化<br>• .ravel()<br>• .flat<pre><code>x = np.array([[1, 2, 3], [4, 5, 6]])print(np.ravel(x))[1 2 3 4 5 6]for i in x.flat: #属性，不需要加()，返回iterator  print(i)</code></pre></li><li>转置<br>• .transpose 交换两个轴 axes<br>• .T 相当于transposes前两个轴<pre><code>x = np.arange(4).reshape((2,2))"""array([[0, 1],[2, 3]])"""np.transpose(x) # x.transpose((1,0)), or x.T"""array([[0, 2],[1, 3]])"""</code></pre></li><li>数组的IO<br>• 可以存储为NPY/NPZ文件<br>• 可以同时存储多个数组<br>• save存储为非压缩格式<br>• savez存储压缩格式<pre><code>np.savez('data.npz', a=a)data = np.load('data.npz')a = data['a'] # data是一个词典</code></pre>• 读入文本文件<br>• 可以指定注释、分隔符、编码等<pre><code>from io import StringIO# 用字符串模拟一个file对象c = StringIO("0 1\n2 3")np.loadtxt(c)array([[ 0., 1.],[ 2., 3.]])</code></pre>• 读入图像文件<pre><code>from scipy.misc import imreadim = imread("lenna.png")print(im.shape, im.dtype)# (330, 330, 3) uint8im_grey = im[:,:,0]*0.299 + im[:,:,1]*0.587 + im[:,:,2]*0.114import matplotlib.pyplot as pltplt.imshow(im_grey, cmap='gray')plt.show()</code></pre></li><li>ufunc<br>• 除了四则运算，常见的数学函数也作为ufunc提供，可以在数组上操作.<br>• 单次numpy.sin的速度只有math.sin的1/4，但大数组的numpy.sin比math.sin快20多倍。这是因为numpy.sin在C语言级别进行循环计算。</li><li>聚集运算<br>• np.sum(a) 对数组a求和<br>• 其他参数：<br>—— axis=None 在特定的维度上求和，默认为全部<br>求和<br>—— out=None 输出直接存入该参数<br>—— initial=初始值<pre><code>np.sum([[0, 1], [0, 5]])#6np.sum([[0, 1], [0, 5]], axis=0)#array([0, 6])np.sum([[0, 1], [0, 5]], axis=1)#array([1, 5])np.sum([])#0.0</code></pre></li><li>其他聚集操作<br>• all 布尔型：与<br>• any 布尔型：或<br>• max 最大值<br>• min 最小值<br>• mean 均值<br>• std 标准差</li><li>类型转换<br>.astype(T) 转为T类型<pre><code>x = array([[0, 1],[2, 3]])x.astype(np.float32)"""array([[0., 1.],[2., 3.]], dtype=float32)"""</code></pre></li><li>矩阵运算<br>• NumPy对于多维数组的运 算，缺省情况下并不使用矩阵运算（特指 乘除法）。<br>• numpy库提供了matrix类，使用matrix类创建矩阵对象，它们的加减乘除运算缺省采用矩阵方式计算<br>• NumPy中同时存在ndarray和matrix对象，容易混淆，需要注意。</li><li>矩阵运算<br>• 矩阵的乘积可以使用dot函数进行计算。<br>• dot<br>—— 对于两个一维的数组，计算的是这两个数组对<br>应下标元素的乘积和（内积）。<br>—— 对于二维数组，计算的是两个数组的矩阵乘积。<br>—— 对于多维数组，通用计算公式为数组a的最后一维上的所有元素与数组b的倒数第二维上的所有元素的乘积和：<br>• dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])<pre><code>a = np.array([[2, 0], [0, 1]])b = np.array([[4, 1], [2, 2]])c = np.dot(a, b)  """array([[8, 2],[2, 2]])"""</code></pre></li><li>排序<br>• .sort() 对数组进行排序，将改变数组的内容。<br>• .argsort() 返冋数组的排序下标<pre><code>a = np.array([5,3,2,4,1])a.argsort()array([4, 2, 1, 3, 0], dtype=int64)</code></pre></li><li>NumPy模块<br>• numpy.linalg模块<br>—— 包含线性代数的函数。可以计算逆矩阵、求特征值、奇异值分解、解线性方程组以及求解行列式、秩等<br>• numpy.fft模块<br>—— 提供了快速傅里叶变换及其逆变换。<br>• numpy.random 模块<br>—— 支持二项分布、超几何分布、正态分布等</li><li>numpy.linalg<br>• 解方程<br>3 * x0 +  x1 = 9<br>x0 + 2 * x1 = 8<pre><code>a = np.array([[3,1], [1,2]])b = np.array([9,8])x = np.linalg.solve(a, b)xarray([ 2., 3.])np.allclose(np.dot(a, x), b)</code></pre><h5 id="MATPLOTLIB"><a href="#MATPLOTLIB" class="headerlink" title="MATPLOTLIB"></a>MATPLOTLIB</h5>• Python绘图库。<br>• 由 John Hunter (1968-2012) 创建。<br>• 拥有一套和Matlab几乎相同语法的绘图库。<br>• 也拥有另一套面向对象的绘图库。<br>• <a href="http://matplotlib.org/" target="_blank" rel="noopener">http://matplotlib.org/</a> 参考 Example 和 Gallery。</li><li>导入<br>• import matplotlib.pyplot as plt<br>• from matplotlib.pyplot import *<br>• pyplot模块模拟了matlab接口</li><li>入门示例<pre><code>import numpy as npfrom matplotlib.pyplot import *#or: from matplotlib.pylab import * # pylab = pyplot + numpyx = np.linspace(0, 5, 10)y = x ** 2figure()plot(x, y, 'r‐o')xlabel('x')ylabel('y')title('title')show()</code></pre></li><li>Plot<br>• x:如果缺少x则按照(0,1,2,3…)<br>• y<br>• “r‐o”: red, 实线, 圆点<br>—— 类似有 “g‐‐x”  绿色虚线X<br>• plot改为semilogx, semilogy, loglog<br>可以变为对数坐标尺度</li><li>颜色<br>• 单词，如’red’<br>• 字母，如’r’<br>• 6位16进制数，如’#FF0000’或’#ff0000’<br>• 三(RGB)或四(RGBA)元组，如(1, 0, 0)或(1,0,0,1)<br>• 灰度字符串，如’0.8’<pre><code>import numpy as npimport matplotlib.pyplot as plta = b = np.linspace(0, 3, 50)c = np.exp(a)d = c[::‐1]plt.plot(a, c, 'r‐‐', label='Model length')plt.plot(a, d, 'b:', label='Data length')plt.plot(a, c+d, 'k', label='Total message length')legend = plt.legend(loc='upper center', shadow=True)legend.get_frame().set_facecolor('#00FFCC')plt.show()</code></pre></li><li>保存绘图<br>• plt.savefig()<br>—— 文件名是必需参数。<br>—— 示例：plt.savefig(“abc.png”, bbox_inches=’tight’)<br>—— bboxinches=’tight’ 去掉不需要的白边。<br>• plt.show()<br>—— 只在屏幕上显示。</li><li>多个绘图<pre><code>x = np.linspace(0.0, 6.28, 100)y1 = np.cos(x)y2 = np.sin(x)plt.subplot(2, 1, 1)plt.plot(x, y1, 'yo‐')plt.grid(True)plt.subplot(2, 1, 2)plt.plot(x, y2, 'r.‐')plt.xlabel('time (s)')plt.show()</code></pre></li><li>直方图<pre><code>mu, sigma = 100, 15x = mu + sigma * np.random.randn(10000)n, bins, patches = plt.hist(x, 50,normed=1,facecolor='g',alpha=0.75)plt.xlabel('Smarts')plt.ylabel('Probability')plt.title('Histogram of IQ')plt.text(60, .025,r'$\mu=100,\ \sigma=15$')plt.axis([40, 160, 0, 0.03])plt.grid(True)plt.show()</code></pre></li><li>散点图<pre><code>x = np.random.random(50)y = np.random.random(50)c = np.random.random(50)  # color of pointss = 500 * np.random.random(50)  # size of pointsfig, ax = plt.subplots()im = ax.scatter(x, y, c=c, s=s, cmap=plt.cm.jet)# Add a colorbarfig.colorbar(im, ax=ax)# set the color limitsim.set_clim(0.0, 1.0)</code></pre><h3 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h3><h5 id="检查网站地图"><a href="#检查网站地图" class="headerlink" title="检查网站地图"></a>检查网站地图</h5>• Sitemap（网站地图）<br>• 网站提供的Sitemap文件可以帮助爬虫定位网站所有网页的链接；<br>• Sitemap文件提供了爬取网站的有效方式，但该文件经常存在缺失、过期或不完整。<h5 id="检测网站构建技术"><a href="#检测网站构建技术" class="headerlink" title="检测网站构建技术"></a>检测网站构建技术</h5>• 构建网站的技术类型会对爬取产生影响。<br>—— 例如网页是动态生成的还是静态页面。<br>• 安装 builtwith 库，将URL作为参数，该库<br>返回网站使用的技术特征。<br>• pip install builtwith<h5 id="调研网站的所有者"><a href="#调研网站的所有者" class="headerlink" title="调研网站的所有者"></a>调研网站的所有者</h5>• 根据网站的所有者，判定爬虫的下载速度等；<br>• 为了找到网站的所有者，可以使用WHOIS协议查询域名的注册者。<br>• 安装：pip install python-whois<h5 id="下载单个网页"><a href="#下载单个网页" class="headerlink" title="下载单个网页"></a>下载单个网页</h5>• python提供了urllib2, requests等库<pre><code>import requestsurl = 'http://www.weather.com.cn/weather/101010100.shtml' # URL地址header = {'User‐Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36(KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36Core/1.53.3226.400 QQBrowser/9.6.11681.400'}req = requests.get(url, headers=header, timeout=60)req.encoding = 'utf‐8' # 设置文本编码code = req.status_code # 返回状态，200代表OKprint(code)</code></pre>• 遇到错误怎么办？(code!=200)<br>• 下载时遇到的错误经常是临时性的：<br>_ 如服务器过载时返回的503 Service Unavailable错误；<br>_ 对于此类错误，可以尝试重新下载。<br>• 非临时性错误<br>_ 如果服务器返回的是404 Not Found错误，说明该网页目前并不存在，再次尝试同样的请求也通常会再次出错。<br>• 400+错误发生在客户端，500+错误则发生在服务端。<br>• 在code为500+时可以重试下载，但通常应该等待一段时间。<h5 id="分析网页的三类技术"><a href="#分析网页的三类技术" class="headerlink" title="分析网页的三类技术"></a>分析网页的三类技术</h5>• 正则表达式<br>_ 无视HTML语言，直接利用正则表达式筛选出所需的部分，包括天气和URL；<br>• BeatifulSoup<br>_ 将HTML进行解析，利用树结构进行分析；<br>• lxml<br>_ 将HTML进行解析，基于XPATH查询语言进行分析。</li><li>BeatifulSoup<br>• Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库；<br>• 支持惯用的文档导航、查找、修改文档的方式；<br>• 提高效率，通常较正则表达式可以节省数小时甚至数天的工作时间。<br>• pip install beautifulsoup4<pre><code>from bs4 import BeautifulSouphtml_doc = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class="story"&gt;Once upon a time there were three little sisters;and their names were&lt;a href="http://example.com/elsie" class="sister"id="link1"&gt;Elsie&lt;/a&gt;,&lt;a href="http://example.com/lacie" class="sister"id="link2"&gt;Lacie&lt;/a&gt; and&lt;a href="http://example.com/tillie" class="sister"id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class="story"&gt;...&lt;/p&gt;"""soup = BeautifulSoup(html_doc)print(soup.prettify()) # 排版soup.title# &lt;title&gt;The Dormouse's story&lt;/title&gt;soup.title.name# 'title'soup.title.string# 'The Dormouse's story'soup.title.parent.name# 'head'soup.p# &lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;soup.p['class']# 'title'soup.a# &lt;a class="sister" href="http://example.com/elsie"id="link1"&gt;Elsie&lt;/a&gt;soup.find_all('a')# [&lt;a class="sister" href="http://example.com/elsie"id="link1"&gt;Elsie&lt;/a&gt;,#  &lt;a class="sister" href="http://example.com/lacie"id="link2"&gt;Lacie&lt;/a&gt;,#  &lt;a class="sister" href="http://example.com/tillie"id="link3"&gt;Tillie&lt;/a&gt;]soup.find(id="link3")# &lt;a class="sister" href="http://example.com/tillie"id="link3"&gt;Tillie&lt;/a&gt;</code></pre>• 从文档中找到所有a标签的链接<pre><code>for link in soup.find_all('a'):    print(link.get('href'))# http://example.com/elsie# http://example.com/lacie# http://example.com/tillie</code></pre>• 从文档中获取所有文字内容<pre><code>print(soup.get_text())# The Dormouse's story## The Dormouse's story## Once upon a time there were three little sisters; and their\names were# Elsie, Lacie and ...</code></pre></li><li>如何遍历网页内容<br>• BS4提供了children, parents, next_element等<br>一系列方法，可以对元素的子元素、父元<br>素、兄弟元素等进行导航，从而遍历整个<br>网页。<br>• BS4也提供了正则表达式等方法。<br>• BS4的介绍可以参考：<br><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a></li><li>链接爬虫<br>• 链接爬虫表现得更像普通用户，它跟踪链接，访问感兴趣的内容。<br>• 通过跟踪所有链接的方式，可以下载整个网站的页面。<br>• 这种方法会下载大量并不需要的网页，通常应该利用正则表达式匹配/过滤需要爬取的网页。<br>• 避免链接爬虫陷阱<br>• 某些网站会动态生成页面内容，有可能造成理论上无限多的页面。<br>——例如：日历网站，链接指向“下个月”<br>• 通常应该定义爬虫最大深度，避免爬虫陷阱。<h3 id="图形界面开发GUI"><a href="#图形界面开发GUI" class="headerlink" title="图形界面开发GUI"></a>图形界面开发GUI</h3><a href="https://www.jianshu.com/p/db0af187ab26" target="_blank" rel="noopener">python图形化GUI：pyQt5详解</a><br><a href="https://www.jianshu.com/p/8ce24bd03978" target="_blank" rel="noopener">python图形化GUI：pyQt5-tools详解</a><h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5>• Model（模型）是应用程序中用于处理应用程序数据逻辑的部<br>分，通常模型对象负责在数据库中存取数据。<br>• View（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。<br>• Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。<br>• MVC 分层有助于管理复杂的应用程序，因为您可以在一个时间内专门关注一个方面。例如，您可以在不依赖业务逻辑的情况下专注于视图设计。同时也让应用程序的测试更加容易。<br>• MVC 分层同时也简化了分组开发。不同的开发人员可同时开发视图、控制器逻辑和业务逻辑。</li></ul><p><a href="https://www.jianshu.com/p/38167906095e" target="_blank" rel="noopener">python：PIL图像处理</a></p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><h5 id="EXCEL自动化"><a href="#EXCEL自动化" class="headerlink" title="EXCEL自动化"></a>EXCEL自动化</h5><p>• Excel 是 Windows 环境下流行的、强大的电子表格应用。<br>—— 包括LibreOffice Calc，OpenOffice Calc，WPS等软件也可以读写xlsx格式。<br>• openpyxl 模块让 Python 程序能读取和修改Excel 电子表格文件。最新版本2.6.2。<br>• <a href="https://openpyxl.readthedocs.io" target="_blank" rel="noopener">https://openpyxl.readthedocs.io</a><br>• 安装：pip install openpyxl</p><ul><li>取得工作簿及工作表<pre><code>import openpyxlwb = openpyxl.load_workbook('example.xlsx')wb.sheetnamessheet = wb['Sheet3']sheet.titleanotherSheet = wb.activeanotherSheet</code></pre></li><li>取得单元格<pre><code>sheet = wb['Sheet1']sheet['A1']sheet['A1'].valuec = sheet['B1']c.valuefor i in range(1, 5):  print(i, sheet.cell(row=i, column=2).value)</code></pre></li><li>取得矩形区域<pre><code>for rowOfCellObjects in sheet['A1':'C3']:    for cellObj in rowOfCellObjects:          print(cellObj.coordinate, cellObj.value)    print('‐‐‐ END OF ROW ‐‐‐')</code></pre></li><li>取得行或者列：支持循环迭代<pre><code>for i in sheet.rows:    print(i)for i in sheet.columns:    print(i)</code></pre></li><li>数据结果的保存<br>• 保存在txt文件中<br>• 保存在csv文件中<br>• 保存在py文件中<pre><code>import pprintresultFile = open('result.py', 'w')resultFile.write('pay_sum = ' + pprint.pformat(pay_sum))resultFile.close()</code></pre></li><li>创建空白工作簿和表<pre><code>import openpyxlwb = openpyxl.Workbook()print(wb.sheetnames)sh = wb.activesh.title = "My Data"wb.save("mydata.xlsx")</code></pre></li><li>创建和删除工作表<pre><code>import openpyxl&gt;&gt;&gt; wb = openpyxl.Workbook()&gt;&gt;&gt; wb.get_sheet_names()['Sheet']&gt;&gt;&gt; sh1 = wb.create_sheet()&lt;Worksheet "Sheet1"&gt;&gt;&gt;&gt; wb.get_sheet_names()['Sheet', 'Sheet1']&gt;&gt;&gt; wb.create_sheet(index=0, title='First Sheet')&lt;Worksheet "First Sheet"&gt;&gt;&gt;&gt; wb.get_sheet_names()['First Sheet', 'Sheet', 'Sheet1']&gt;&gt;&gt; wb.remove_sheet(sh1)   #删除表&gt;&gt;&gt; wb.get_sheet_names()['First Sheet', 'Sheet']</code></pre></li><li>将值写入单元格<pre><code>import openpyxlwb = openpyxl.Workbook()sheet = wb.activesheet['A1'].value = 'Hello world!'wb.save("hello.xlsx")</code></pre></li><li>其他功能<br>• 改变字体<br>• 使用公式<br>• 设置行高和列宽<br>• 单元格拆分<br>• 绘制图表<br>例子：乘法表<pre><code>import openpyxlwb = openpyxl.Workbook()sheet = wb.activefor i in range(1, 10):sheet.cell(row=i+1, column=1).value = isheet.cell(row=1, column=i+1).value = ifor i in range(1, 10):for j in range(1, 10):sheet.cell(row=i+1, column=j+1).value=i*jwb.save("99.xlsx")</code></pre><h5 id="WORD自动化"><a href="#WORD自动化" class="headerlink" title="WORD自动化"></a>WORD自动化</h5>• Microsoft公司的Word是一套功能丰富的办公软件，所提供的docx格式可以存储文本以及字体、颜色等丰富的信息。<br>• docx的读写比txt文件要复杂，需要第三方库的支持。<br>• pip install python‐docx<br>• 注意：导入的时候用 import docx</li><li>docx文件结构<br>• docx 文件有很多结构。<br>• 这些结构在 python-docx 中用 3 种不同的类型来表示。<br>• Document 对象表示整个文档。<br>• Document 对象包含一个 Paragraph 对象的列表，Paragraph即文档中的段落。<br>• 每个 Paragraph 对象都包含一个 Run 对象的列表。</li><li>读取文档<pre><code>import docxdoc = docx.Document('libai.docx')print(len(doc.paragraphs)# 8print(doc.paragraphs[0].text)# '铁杵成针'print(doc.paragraphs[2].text)# '李白是唐代的大诗人，但是小时候读书并不用功。...'print(doc.paragraphs[2].runs)#[&lt;docx.text.run.Run at 0x1e0e56a3c50&gt;,...]print(doc.paragraphs[2].runs[0].text)#'李白是唐代的大诗人，'print(doc.paragraphs[2].runs[1].text)#'但是小时候读书并不用功'</code></pre></li><li>获取Word中的纯文本<br>• 如果不关注样式，只希望获得所有的文本<br>• 参考代码实现：<pre><code>import docxdef getText(filename):    doc = docx.Document(filename)    fullText = []    for para in doc.paragraphs:          fullText.append(para.text)    return '\n'.join(fullText)</code></pre></li><li>Word中的样式<br>• Word有很多样式，可以通过段落或run对象的style属性获得。<br>• 可以通过设置下列属性产生不同的样式<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cdf1dbbe2c7c7ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>修改样式<pre><code>import docxdoc = docx.Document('libai.docx')doc.paragraphs[2].runs[0].underline = Truedoc.save('restyled‐libai.docx')</code></pre></li><li>生成Word文档<br>• doc.add_paragraph(text) 新建一个段落，返回段落对象。<br>• para.add_run(text) 新建一个run，返回run对象。<br>• doc.add_heading(text, level) 新建一个标题，层级为level<br>• doc.add_picture(filename) 新建一个图片<pre><code>import docxdoc = docx.Document()doc.add_heading('静夜思', 0)doc.add_heading('李白', 1)for s in ["床前明月光", "疑是地上霜", "举头望明月","低头思故乡"]:para = doc.add_paragraph(s)para.add_run("/")doc.add_picture("green.jpg")doc.save('mydoc.docx')</code></pre><h5 id="PDF自动化"><a href="#PDF自动化" class="headerlink" title="PDF自动化"></a>PDF自动化</h5>• PDF 表示 Portable Document Format 便携式文件格式，由Adobe Systems在1993年用于文件交换所发展出的文件格式。<br>• 本部分专注两件事：<br>—— 从 PDF 读取文本内容<br>—— 从已有的文档页面生成新的 PDF。<br>• pip install pyPDF2</li><li>PDF读取文字<pre><code>import PyPDF2with open('04067093.pdf', 'rb') as pdfFile:pdfReader = PyPDF2.PdfFileReader(pdfFile)print("Total pages: ", pdfReader.numPages)page0 = pdfReader.getPage(0)print(page0.extractText())</code></pre></li><li>合并PDF<pre><code>import PyPDF2pdf1File = open('00294849.pdf', 'rb')pdf2File = open('04067093.pdf', 'rb')pdf1Reader = PyPDF2.PdfFileReader(pdf1File)pdf2Reader = PyPDF2.PdfFileReader(pdf2File)pdfWriter = PyPDF2.PdfFileWriter()for pageNum in range(pdf1Reader.numPages):    pageObj = pdf1Reader.getPage(pageNum)    pdfWriter.addPage(pageObj)for pageNum in range(pdf2Reader.numPages):    pageObj = pdf2Reader.getPage(pageNum)    pdfWriter.addPage(pageObj)pdfOutputFile = open('combined.pdf', 'wb')pdfWriter.write(pdfOutputFile)pdfOutputFile.close(); pdf1File.close(); pdf2File.close()</code></pre></li><li>页面旋转和叠加<br>• rotateClockwise(0, 90, 180, 270)<br>• rotateCounterClockwise(…)<br>_ 可以将页面对象旋转<br>• mergePage(anotherPage)<br>_ 可以将页面叠加（水印）<br>• 综合上述功能，可以实现pdf文件的合并、页面抽取、旋转、叠印等功能。</li><li>PDF中文编码问题<br>• pyPDF2不能读取中文编码的文字；<br>• 可以使用pdfminer库或其他类似的库。<pre><code>import iofrom pdfminer.converter import TextConverterfrom pdfminer.pdfinterp import PDFPageInterpreterfrom pdfminer.pdfinterp import PDFResourceManagerfrom pdfminer.pdfpage import PDFPagedef extract_text_from_pdf(pdf_path):  resource_manager = PDFResourceManager()  fake_file_handle = io.StringIO()  converter = TextConverter(resource_manager, fake_file_handle)  page_interpreter = PDFPageInterpreter(resource_manager, converter)  with open(pdf_path, 'rb') as fh:      for page in PDFPage.get_pages(fh, caching=True):          page_interpreter.process_page(page)      text = fake_file_handle.getvalue()  converter.close()  fake_file_handle.close()  if text:      return textif __name__ == '__main__':print(extract_text_from_pdf('CH9‐图形界面开发A.pdf'))</code></pre><h5 id="图像处理自动化"><a href="#图像处理自动化" class="headerlink" title="图像处理自动化"></a>图像处理自动化</h5>• 图像处理已经是深入日常生活，Photoshop的缩写已经成为图像处理的代名词。<br>• 如果需要编辑大量的图像，手工编辑可能是漫长、枯燥的工作。<br>• Pillow 是一个第三方 Python 模块，用于处理图像文件。该模块包含一些函数，可以很容易地裁剪图像、调整图像大小，以及编辑图像的内容，从而轻松地自动编辑成千上万的图像。</li><li>颜色和 RGBA 值<br>• 计算机程序通常将图像中的颜色表示为RGBA 值。RGBA 值是一组数字，指定顔色中的红、绿、蓝和 alpha（透明度）的值。<br>• 这些值是从 0到 255（最高）的整数。<br>• 这些 RGBA 值分配给单个像素，像素是计算机屏幕上能显示一种颜色的最小点。<br>• 像素的 RGB 设置准确地告诉它应该显示哪种颜色的色彩。</li><li>Alpha通道<br>• 图像也有一个 alpha 值，用于生成 RGBA 值。如果图像显示在屏幕上，遮住了背景图像或桌面墙纸，alpha 值决定了“透过”颜色可以看到多少程度的背景。<br>• 如果alpha 值为 0，表示完全透明。<br>• 如果alpha 值为 255，表示完全不透明。</li><li>获取颜色<pre><code>&gt;&gt;&gt; from PIL import ImageColor&gt;&gt;&gt; ImageColor.getcolor('red', 'RGBA')(255, 0, 0, 255)&gt;&gt;&gt; ImageColor.getcolor('RED', 'RGBA')(255, 0, 0, 255)&gt;&gt;&gt; ImageColor.getcolor('Black', 'RGBA')(0, 0, 0, 255)&gt;&gt;&gt; ImageColor.getcolor('chocolate', 'RGBA')(210, 105, 30, 255)&gt;&gt;&gt; ImageColor.getcolor('CornflowerBlue', 'RGBA')(100, 149, 237, 255)</code></pre></li><li>图像坐标系<br>• 左上角坐标为(0,0)<br>• y正方向向下<br>• x正方向向右</li><li>Box<br>• 一个矩形元组参数，表示图像中的一个矩形区域。四个整数按顺序分别是：<br>_左：该矩形的最左边的 x 坐标。<br>_顶：该矩形的顶边的 y 坐标。<br>_右：该矩形的最右边右面一个像素的 x 坐标。<br>_底：该矩形的底边下面一个像素的 y 坐标。<br>• 矩形元组（3, 1, 9, 6）</li><li>图像的打开和存储<pre><code>&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; img = Image.open('horse.jpg')&gt;&gt;&gt; img.size　 (1674, 1116)&gt;&gt;&gt; width, height = img.size&gt;&gt;&gt; img.format'JPG'&gt;&gt;&gt; img.save('horse.png')</code></pre></li><li>生成新图像<pre><code>from PIL import Imageim = Image.new('RGBA', (100, 200), 'purple')im.save('purpleImage.png')im2 = Image.new('RGBA', (20, 20))im2.save('transparentImage.png')</code></pre></li><li>裁剪图片<pre><code>croppedIm = img.crop((600, 200, 1000, 800))croppedIm.save('cropped‐horse.png')</code></pre></li><li>复制和粘贴<pre><code>from PIL import Imageimg = Image.open('horse.jpg')croppedIm = img.crop((600, 200, 1000, 800))horsehead = croppedIm.copy()img.paste(horsehead, (1200, 200))img.save('horse2.jpg')</code></pre></li><li>调整图像大小及旋转图像<pre><code>from PIL import Imageimg = Image.open('horse.jpg')width, height = img.sizeimg44 = img.resize((width//4, height//4), Image.NEAREST)img42 = img.resize((width//4, height//2), Image.NEAREST)imgr30 = img.rotate(30)img44.save('horse44.jpg')img42.save('horse42.jpg')imgr30.save('horse_r30.jpg')</code></pre></li><li>更改单个像素<br>• 单个像素的颜色通过 getpixel()和putpixel()方法取得和设置。它们都接受一个元组，表示像素的 x 和 y坐标。<br>• putpixel()方法还接受一个元组，作为该像素的颜色。这个顔色参数是四整数 RGBA 元组或三整数 RGB 元组。<br>• 注：1. 能改一个像素就能进行任意的图像编辑；</li></ul><ol start="2"><li>图片像素很多时，本方法很慢。<pre><code>img = Image.new('RGB', (200, 100), 'black')print(img.getpixel((0, 0)))for x in range(100):for y in range(50):img.putpixel((x, y), (210, 210, 210))img.save('putPixel.png')</code></pre></li></ol><ul><li>绘制形状<br>• ImageDraw 方法在图像上绘制各种形状。<br>• 点：point(xy, fill)方法绘制单个像素。xy 参数表示要画的点的列表。该列表可以是 x和 y 坐标的元组的列表，例如[(x, y), (x, y), …]，或是没有元组的 x和 y 坐标的列表，例如[x1, y1, x2, y2, …]。<br>• 线：line(xy, fill, width)方法绘制一条线或一系列的线。xy 是一个元组的列表，例如[(x, y), (x,y), …]，或整数列表，例如[x1, y1, x2, y2, …]。每个点都是正在绘制的线上的一个连接点。<br>• 矩形、椭圆、多边形、文字等。<pre><code>from PIL import Image, ImageDrawim = Image.new('RGBA', (200, 200), 'white')draw = ImageDraw.Draw(im)draw.line([(0, 0), (199, 0), (199, 199), (0, 199), (0,0)], fill='black')draw.rectangle((20, 30, 60, 60), fill='blue')draw.ellipse((120, 30, 160, 60), fill='red')draw.polygon(((57, 87), (79, 62), (94, 85), (120, 90),(103, 113)), fill='brown')for i in range(100, 200, 10):draw.line([(i, 0), (200, i ‐ 100)], fill='green')im.save('drawing.png')</code></pre><h5 id="键盘鼠标自动化"><a href="#键盘鼠标自动化" class="headerlink" title="键盘鼠标自动化"></a>键盘鼠标自动化</h5>• 白盒：完成了解docx/xlsx格式细节，通过python直接生成符合格式的文档。<br>• 灰色：Word/Excel提供某种控制接口（如COM接口），通过COM接口操作Word/Excel软件达到预期目标。<br>• 黑色：缺乏控制接口，仅能通过模拟键盘和鼠标事件驱动GUI软件。</li><li>pyautogui<br>• pyautogui模块可以模拟鼠标移动、按键和滚动鼠标滚轮等。<br>• 本节仅介绍pyautogui的部分功能。<br>• <a href="http://pyautogui.readthedocs.org/" target="_blank" rel="noopener">http://pyautogui.readthedocs.org/</a><br>• 安装：<br>_ pip install PyGetWindow==0.0.1<br>_ pip install pyautogui</li><li>注意事项<br>• Python 能以想象不到的高速移动鼠标并击键。它可能太快，导致被控程序跟不上。<br>• 如果出了问题，而程序仍然继续到处移动鼠标，计算机就会失去控制（因为你的键盘和鼠标被人控制了）。<br>—— 如果程序自己在移动鼠标，停止它可能很难。你可能无法点击“关闭”按钮<br>• Windows 和 Linux  上，注销的热键是 Ctrl-Alt-Del ，有可能会失去目前没有保存的文档。</li><li>预防措施<br>• 设置脚本在每次函数调用后暂停一段时间，让用户有很短的时间窗口来控制鼠标和键盘。<br>—— 将pyautogui.PAUSE 变量设置为要暂停的秒数。如设置：pyautogui.PAUSE = 1.5。<br>• 开启pyautogui 自动防故障功能。<br>—— 将鼠标移到屏幕的左上角，将导致pyautogui.FailSafeException 异常。<br>—— 故障时应尽可能快地向左上移动鼠标，以触发异常。<br>—— 该异常可以用try语句捕获。</li><li>屏幕坐标系<br>• 左上角为原点<br>• x向右为正方向<br>• y向下为正方向<pre><code>import pyautogui as agwidth, height = ag.size()print(width, height)#1366, 768</code></pre></li><li>移动鼠标<pre><code>import pyautoguifor i in range(10):ag.moveTo(100, 100, duration=0.25)ag.moveTo(200, 100, duration=0.25)ag.moveTo(200, 200, duration=0.25)ag.moveTo(100, 200, duration=0.25)</code></pre></li><li>获取鼠标位置<br>• position()函数获得鼠标当前的位置。<br>• 为了持续跟踪获得鼠标位置，可以采用下述代码：<pre><code>print('Press Ctrl‐C to quit.')try:  while True:      x, y = pyautogui.position()      print(f"mouse at {x:4d}, {y:4d}")except KeyboardInterrupt:  print('\nDone.')</code></pre></li><li>点击鼠标<br>• 当前位置点击 click() 方法。<br>• 若在位置(x,y) 点击，采用click(x,y)方法。<br>• 默认情况下点击左键。若指定鼠标按键，则需要button关键字参数，取值为 ‘left’、’middle’或’right’。<br>• 例：<br>_ click(100, 150, button=’left’)<br>_ click(200, 250, button=’right’)<br>• 模拟鼠标按下：mouseDown()<br>• 释放鼠标按键：mouseUp()<br>• 函数参数与 click()<br>_ click = mouseDown + mouseUp<br>• 鼠标双击：doubleClick()</li><li>拖动鼠标<br>• Drag即按住一个按键不放同时移动鼠标。<br>_ 通过拖动文件图标，在文件夹之间移动文件；<br>_ 可以拖动绘图。<br>• dragTo() 和 dragRel() 函数将鼠标拖动到一个新的位置，或相对当前的位置。<br>_ 函数的参数与moveTo() 和 moveRel() 相似。<pre><code>import pyautogui as agimport timetime.sleep(5)ag.click()distance = 200while distance &gt; 0:  ag.dragRel(distance, 0, duration=0.2) # move right  distance = distance ‐ 5  ag.dragRel(0, distance, duration=0.2) # move down  ag.dragRel(‐distance, 0, duration=0.2) # move left  distance = distance ‐ 5  ag.dragRel(0, ‐distance, duration=0.2) # move up</code></pre></li><li>获取屏幕内容<pre><code>import pyautoguiim = pyautogui.screenshot()im.save("capture.png")</code></pre>• 做GUI自动测试时，可以利用截图分析按钮是否正常或者变灰（利用Pillow库的getpixel方法）。<br>• 可以做一个软件，随着鼠标移动，自动取得不同位置的颜色。</li><li>屏幕图像识别<br>• 提前准备一幅（截图后取出）的局部图像：<br>• locateOnScreen(‘want.png’)<br>• 找到屏幕上完全匹配的图像所在的box，然后可在box的中心（或其他位置）进行点击。</li><li>键盘<br>• typewrite()方法模拟发送按键<br>_ typewrite(‘Hello world!’)<br>_ typewrite([‘a’, ‘b’, ‘left’, ‘left’,’X’, ‘Y’])<br>_ 前者均为正常按键<br>_ 后者的’left’表示“左方向键”</li><li>键盘：特殊键<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f6e85cea98792463.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>键盘模拟<br>• keyDown()和keyUp()将向计算发送虚拟的按键和释放。<br>• press() 函数模拟完整的击键。<pre><code>keyDown('shift');press('1');keyUp('shift')</code></pre>相当于 Shift-1 ，即“ ! ”键<br>• hotkey() 按参数自左向右依次模拟按键倒序模拟释放。<br>_ hotkey(‘ctrl’, ‘alt’, ‘shift’, ‘s’)</li><li>可能完成的任务<br>• 模拟键盘及鼠标，实现自动填表；<br>• 填写Excel表格；<br>• 编写Word文件。<br>• 自动玩游戏；<br>• 网络爬虫：<br>• 模拟键盘输入关键字，发送“回车”键，获得页面；<br>• 利用键盘另存当前页面；<br>• 点击“下一页”，继续另存当前页面<br>• 聊天机器人<br>• 模拟键盘输入微信、QQ等<br>• 在AI时代，视觉、听觉和模拟发声、模拟形象都可以实现。<h3 id="数据存储与程序调试"><a href="#数据存储与程序调试" class="headerlink" title="数据存储与程序调试"></a>数据存储与程序调试</h3><h5 id="数据转换存储"><a href="#数据转换存储" class="headerlink" title="数据转换存储"></a>数据转换存储</h5>• 数据的存储交换发生在：<br>_ 在同一程序的不同片段之间；<br>_ 在不同的程序之间；<br>_ 在不同主机之间。<br>• 这些数据可能存储一些简单的文本和数值，也可能是非常复杂具有结构的一组数据。<br>• 为了实现数据的存储和交换，有多种相对流行的数据存储交换方式：<br>_ 文件或数据库。</li><li>INI文件<br>• INI用来表示简单的、分层次的配置文件，其内涵类似于Python的词典。<br>• 本质是纯文本文件，但有一些简单的格式。</li><li>INI文件的读写<br>• 由于格式非常简单，可以基于一般文件的read/write进行存取。<br>• Python提供了内置库：<pre><code>import configparserconfig = configparser.ConfigParser()config.add_section('Init')config.set('Init', 'Server', '127.0.0.1')config.set('Init', 'Port', '12000')with open('my.ini', 'wt') as configfile:  config.write(configfile)</code></pre></li><li>pickle<br>• Pickle库可以实现任意python对象的存储。<pre><code>import pickletodo = ['write a blog post','reply an email','read a book']pickle_file = open('todo.pickle', 'wb')pickle.dump(todo, pickle_file)</code></pre></li><li>Pickle &amp; cPickle<br>• Pickle<pre><code>pickle_file = open('todo.pickle', "rb")todo = pickle.load(pickle_file)pickle_file.close()print(todo)</code></pre></li><li>JSON<br>• Pickle仅限于Python程序使用，如何和其他语言交互？<br>• JSON (JavaScript Object Notation) 是跨语言的轻量级数据交换格式。<br>• 易于被人工读取、修改，也容易被机器读取和写入。<br>• 符合 ECMA-262 3rd Edition标准。<br>• JSON语言无关，它可以方便的被 C, C++, C#,Java, JavaScript, Perl, Python等语言读取和生成。<br>• 结论：JSON是理想的数据交换格式，可以实<br>现跨语言的、跨计算机的复杂数据传输。<pre><code>import jsondatastore = { "room‐number": 100,"use": "reception","sq‐ft": 50,"price": [100, 200, 300]}with open("ds.json", 'w') as f:  json.dump(datastore, f)with open("ds.json", 'r') as f:  data = json.load(f)print(data)</code></pre></li><li>数据库<br>• 文件存储不适用于大项目，此时需要使用数据库。<br>• 数据管理系统 Database Management System= DBMS<br>_ 一系列存储数据的文件；<br>_ 一系列程序用于访问和更新其中的数据。<br>• 目前最流行的数据库是关系型数据库。</li><li>SQLite<br>• SQlite 是开源的数据库，可以嵌入在其他程序中，不需要安装。<br>• 单机版本，不能并发、不能网络访问、不需要用户名密码鉴权（但可以加密）。<br>• Portable – 仅使用了ANSI-standard C语言，因此可在各种平台编译；<br>• Reliable – 良好的测试，开源代码；<br>• Small – 300 kb 的库，只需要16kb的stack和100kb的heap，甚至可以运行在单片机上。</li><li>建库<pre><code>import sqlite3conn = sqlite3.connect('example.db')c = conn.cursor()c.execute('''CREATE TABLE money(日期, 姓名, 支出)''')for d, n, m in [("2019‐4‐1", "Li Lei", 52),("2019‐4‐2", "Han Meimei", 300),("2019‐4‐5", "Li Lei", 230),("2019‐4‐8", "Li Lei", 170),("2019‐4‐10", "Han Meimei", 96)]:  c.execute("INSERT INTO money VALUES (?,?,?)",(d,n,m))conn.commit()conn.close()</code></pre></li><li>用库<pre><code>import sqlite3conn = sqlite3.connect('example.db')c = conn.cursor()result = c.execute('''select 姓名, 支出    from money where 支出&gt;100;''')for row in result:  name = row[0]  pay = row[1]  print(f"{name} pay {pay}&gt;100")conn.close()</code></pre></li><li>其他格式<br>• MAT：Matlab数据存储格式<br>• Python可以直接读取MAT文件，Python也可以调用Matlab完成特定任务。<h5 id="目录处理"><a href="#目录处理" class="headerlink" title="目录处理"></a>目录处理</h5>• 查找目录下的子目录和文件<br>_ glob库<br>• 遍历目录<br>_ os.walk方法</li><li>实例<pre><code>import osfrom os.path import join, getsizefor root, dirs, files in os.walk('.'):print("root=", root)print(sum(getsize(join(root, name)) for name in files), end="")print("bytes in", len(files),"non‐directory files")</code></pre><h5 id="测试和调试"><a href="#测试和调试" class="headerlink" title="测试和调试"></a>测试和调试</h5></li><li>测试驱动Test-driven开发<br>• pytest是一个强大的Python测试工具。<br>• pytest是软件测试框架，它会自动找到用户写的测试用例，运行测试并报告结果。<br>• 支持插件或第三方扩展<br>• 容易与其他工具对接。<br>• pip install pytest</li><li>规则<br>• pytest 测试样例的规则：<br>_ 测试文件以 test_ 开头（以 <em>test 结尾也可以）<br>_ 测试类以 Test 开头，并且不能带有 <strong>init</strong> 方法<br>_ 测试函数以 test</em> 开头<br>_ 断言使用基本的 assert 即可<br>• pytest自动执行所有的测试，并报告通过和失败的测试用例数量。</li><li>print-调试</li><li>使用日志文件<br>• 对大规模程序长期运行而言，故障的机会是很少的，难以通过print获得；<br>• 日志是一种非常好的手段，可以用于记录程序运行过程中的各种信息。<br>• 理想的日志可以用来恢复和重现程序的运行过程。<br>• 内置的logging库。</li><li>日志等级<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-1a0cf572c74b3490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>利用IPython.embed调试<br>• from IPython import embed<br>• 在需要调试的位置加入embed()函数<br>• 可以在现场运行python解释器，可以自由执行任何python语句，包括：<br>_ 打印输出任何变量<br>_ 修改和删除任何变量<br>• print/logging应对复杂数据结构的能力不足，embed()是较为理想的选择。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些实用有趣的Web分享</title>
      <link href="/posts/webshare1.html"/>
      <url>/posts/webshare1.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：个人常用的一些实用便捷的以及有趣的网站汇总</p><p>温馨提示：多图预警，流量党注意</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h3 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h3><ul><li><p><a href="https://slidesgo.com/" target="_blank" rel="noopener">PPT优质模板：全免费</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05NzZjMWM1M2MyMDk0NGE1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.officeplus.cn/Template/Home.shtml" target="_blank" rel="noopener">OfficePlus</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227142828441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3></li><li><p><a href="https://www.wondercv.com/" target="_blank" rel="noopener">超级简历</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227122034626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><a href="https://www.wondercv.com/" target="_blank" rel="noopener">五百丁简历</a><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227122149491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul><li><a href="https://smallpdf.com/" target="_blank" rel="noopener">Smallpdf：在线pdf转换</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kM2JmZmU2ZjZjOGQ2YjE5LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h3 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h3><ul><li><p><a href="https://www.xiuzhan365.com/" target="_blank" rel="noopener">秀展网：在线MG动画制作</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01ODlmOGY4NTZkOGY4MDQyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.weiciyun.com/" target="_blank" rel="noopener">微词云：文字云艺术生成器</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zYWRiYzI0NTFjYWEwNGUwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://creativemass.cn/#/" target="_blank" rel="noopener">Creative Mass：创意导航</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kZThiYzc0YWNlMmFlNjM1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.grammarly.com/" target="_blank" rel="noopener">语法：免费写作助手</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02NjgwOWEwMWIxOTEzYTEwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://sorry.xuty.tk/sorry/" target="_blank" rel="noopener">表情锅：在线制作表情包</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1lOGJhNzk4ODlhZmNkZjM1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://zh.wix.com/" target="_blank" rel="noopener">网页制作</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi00Y2JkZTRiM2RkZjA4NDcwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.akuziti.com/yw/" target="_blank" rel="noopener">艺术字在线生成</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03NWZmNWRiNzhiODNmZWQ5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://giphy.com/" target="_blank" rel="noopener">Gif工具</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01YTJjZWU2YzdkMjQ5YWM0LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><ul><li><p><a href="https://www.chuangkit.com/dc.html" target="_blank" rel="noopener">创客贴</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03MzhmZTBkNDQ2ZjE1Y2JiLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.canva.com/" target="_blank" rel="noopener">Canva</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0wNjAyYTllYzYwNTEzNjAzLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.zitijia.com/" target="_blank" rel="noopener">字体家：商用字体下载</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227142459182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><a href="https://h5.bce.baidu.com/store" target="_blank" rel="noopener">H5设计</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/2020022714322343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><p> <a href="https://www.nounplus.net/" target="_blank" rel="noopener">Nounplus：在线查英语语法拼写错误</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0xZThjMjg0MWRlZTkxMWE5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p><ul><li><a href="http://www.gfxcamp.com/" target="_blank" rel="noopener">龋齿一号</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05YTY0MWNmMTdlM2IxMTRlLnBuZw?x-oss-process=image/format,png" alt="image.png"><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3></li><li><a href="http://tools.jb51.net/" target="_blank" rel="noopener">脚本之家在线工具</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227143425667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p><a href="https://www.materialtools.com/?page=1" target="_blank" rel="noopener">云短信：临时验证码</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03OGFkYzMyNDRiNjI0MzUyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://everytimezone.com/" target="_blank" rel="noopener">时差</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01OTlkMjNkZGNiYTg5NzFiLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h3 id="综合学习平台"><a href="#综合学习平台" class="headerlink" title="综合学习平台"></a>综合学习平台</h3><ul><li><p><a href="https://study.163.com/" target="_blank" rel="noopener">网易云课堂</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iY2Q0MDZlZjExZjY2YTU4LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.icourse163.org/" target="_blank" rel="noopener">中国大学mooc</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zNmY0NjBmOGQ0MThiM2ZlLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://ke.qq.com/" target="_blank" rel="noopener">腾讯课堂</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03Mzc5MGE5YzM4YTY1M2EzLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://next.xuetangx.com/" target="_blank" rel="noopener">学堂在线</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03NDk4Njk5ODdjYzNkODQ2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.51zxw.net/" target="_blank" rel="noopener">我要自学网</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iZjllZGE5ODQ4NzUwY2E2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul><li><p><a href="https://www.allhistory.com/" target="_blank" rel="noopener">全历史：世界各国历史记录和联系检索</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03NjYyZmFkYTU2ZWRkMGNlLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.ageeye.cn/" target="_blank" rel="noopener">发现中国：地图分享知识</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jMGY3ODQxMTM3Mzk0MGZiLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="医学"><a href="#医学" class="headerlink" title="医学"></a>医学</h3><ul><li><a href="https://www.mvyxws.com/" target="_blank" rel="noopener">医学微视</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02YjU3NjFjN2EwNDUyOWM1LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="新媒体"><a href="#新媒体" class="headerlink" title="新媒体"></a>新媒体</h1><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><ul><li><p><a href="https://www.kaolamedia.com/" target="_blank" rel="noopener">考拉新媒体导肮</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jNzcyNGJmNzI0NWYyNWVkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://tophub.today/" target="_blank" rel="noopener">今日热榜</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02MGNiNGEwYjgyYWFjMjQ4LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h3><ul><li><a href="https://mj.yuzhua.com/search/3.html" target="_blank" rel="noopener">鱼爪传媒</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0yY2YxMDE2OTQ5MWNiNGE2LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="导航-1"><a href="#导航-1" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="http://guozhivip.com/nav/" target="_blank" rel="noopener">果汁导航</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02ZDVkNzI1MDBmODg3ZDQ5LnBuZw?x-oss-process=image/format,png" alt="image.png"></li><li><a href="https://ailongmiao.com/" target="_blank" rel="noopener">龙喵网</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/2020022714393084.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><a href="https://webjike.com/" target="_blank" rel="noopener">小呆导航</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227144016570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>[北邮人导航](<a href="http://byr.wiki/）" target="_blank" rel="noopener">http://byr.wiki/）</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227144203360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><h3 id="开源平台"><a href="#开源平台" class="headerlink" title="开源平台"></a>开源平台</h3><ul><li><p><a href="https://github.com/" target="_blank" rel="noopener">Github：全球最大的开源平台</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01Mjc0MGYzYjIxMmI5N2Q2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://gitee.com/" target="_blank" rel="noopener">Gitee：国内开源平台</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02ZWJmMzg3Nzk2YzMxNDUwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.gitkraken.com/" target="_blank" rel="noopener">GitKraken：开源工具</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1hYzFkYmM2YzI2ZjM0MjExLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="博客论坛"><a href="#博客论坛" class="headerlink" title="博客论坛"></a>博客论坛</h3><ul><li><p><a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN：博客平台</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kZjk3ZThiM2MyNjY0NTgxLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.cnblogs.com/" target="_blank" rel="noopener">博客园</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kY2NiZmRhNjE1MTNlMzkyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="私人优秀博客推荐"><a href="#私人优秀博客推荐" class="headerlink" title="私人优秀博客推荐"></a>私人优秀博客推荐</h3><ul><li><a href="https://wangyasai.github.io/" target="_blank" rel="noopener">赛亚</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05ZjVkZmZhMWY3ZTU0YzE3LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><ul><li><p><a href="http://data.stats.gov.cn/index.htm" target="_blank" rel="noopener">国家统计局</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kYTFlNTQyMjNiN2M1ZGE2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.chyxx.com/" target="_blank" rel="noopener">中国产业信息网</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jMTg5YWRiNzczMTk3ZTdkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://hao.199it.com/" target="_blank" rel="noopener">大数据导航</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0wNTIxMmM0NjZlMWYyODIwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.visualcapitalist.com/" target="_blank" rel="noopener">数据表</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1lNWQ4ODc3Njg3MzVkYzQ5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="专业"><a href="#专业" class="headerlink" title="专业"></a>专业</h3><ul><li><p><a href="http://moon.bao.ac.cn/mul/index/list" target="_blank" rel="noopener">月球与行星多媒体数据库</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0xOTM3ZTMzMjVhMmRjOTY4LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://everysecond.io/" target="_blank" rel="noopener">Every Second</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iZGUzYTZiZTQ2N2I1YzBiLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h1 id="学术"><a href="#学术" class="headerlink" title="学术"></a>学术</h1><ul><li><p><a href="https://www.cnki.net/" target="_blank" rel="noopener">中国知网</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0yY2RjYzUzMGQ1YTJjOTE2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.wanfangdata.com.cn/" target="_blank" rel="noopener">万方数据知识服务平台</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi00MzZlODQ4ZDc2NGU3MGZhLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.termonline.cn/index.htm" target="_blank" rel="noopener">术语在线：专业术语查询</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01MTYwZTcxNjBmYTUwMmE0LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.oalib.com/" target="_blank" rel="noopener">Open Access Library：开源学术平台</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01MWE3ZWNjNzE0MDQ5NGU3LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.wdl.org/zh/" target="_blank" rel="noopener">世界数字图书馆</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01YjNmNjNkYWM1ZmJlYTM3LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.keoaeic.org/" target="_blank" rel="noopener">AEIC学术会议网</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04ZTMxZmY2OGNlNTMxMGE1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.cn-ki.net/" target="_blank" rel="noopener">iData-知识检索</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zZDk3ZGY4MjU3MjZhNTQ1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h3 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h3><ul><li><p><a href="https://www.pexels.com/" target="_blank" rel="noopener">Pexels</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227143554202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227143637753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><a href="http://bg-patterns.com/" target="_blank" rel="noopener">Bg-patterns：背景图下载</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iMWNjYTRhZTdlNDIzYzRjLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><ul><li><p><a href="https://cover.olook.me/" target="_blank" rel="noopener">网易云封面助手：封面下载</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi00NGU3MjdmNTNjMjdkNGUwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.pngall.com/thug-life-png" target="_blank" rel="noopener">PNG下载</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jY2MwZWVmNjhlYWY3Mzg2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h3><ul><li><p><a href="https://www.ls.graphics/meshgradients" target="_blank" rel="noopener">Free Mesh Gradient Collection：渐变图</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05YjgxZDM4YjYyZWM5OWRiLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://duotone.shapefactory.co/?f=f56468&amp;t=27184f&amp;q=_" target="_blank" rel="noopener">Duotone：双色</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi00NzM3ZmEzYWMyZGE5ZmMyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://photomosh.com/" target="_blank" rel="noopener">Photomosh：在线效果</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01ZTE3NTU1MGNkMzg0NjZkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://petalica-paint.pixiv.dev/index_zh.html" target="_blank" rel="noopener">自动上色</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05YmQyM2EwNjQ1NDEyYWY5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://experiments.withgoogle.com/autodraw" target="_blank" rel="noopener">简笔画</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01MmJiOTYwNzg0OWJkMjg0LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://watereffect.net/" target="_blank" rel="noopener">水效果处理</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iMTlkMjMwNDI0MjJkNmY3LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.remove.bg/zh" target="_blank" rel="noopener">在线抠图</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227142203515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><a href="https://www.yasuotu.com/" target="_blank" rel="noopener">图片在线压缩</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227142956542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="二维码制作"><a href="#二维码制作" class="headerlink" title="二维码制作"></a>二维码制作</h3></li><li><p><a href="https://cli.im/" target="_blank" rel="noopener">草料二维码</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227143036991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><h3 id="视频制作"><a href="#视频制作" class="headerlink" title="视频制作"></a>视频制作</h3><ul><li><a href="https://2zimu.com/#/" target="_blank" rel="noopener">突字幕：在线加字幕</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04ZGQwNWY4MjVkM2QzYjdjLnBuZw?x-oss-process=image/format,png" alt="image.png"></li><li><a href="https://panzoid.com/" target="_blank" rel="noopener">Panzoid：在线片头制作</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/2020022714195340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h1><h3 id="在线音乐制作"><a href="#在线音乐制作" class="headerlink" title="在线音乐制作"></a>在线音乐制作</h3><ul><li><p><a href="https://learningmusic.ableton.com/" target="_blank" rel="noopener">Get started making music</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kMWY3OGZkMDVjMDhlNWU2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://bongo.cat/" target="_blank" rel="noopener">Bongo Cat：音乐猫</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jNjYxYTE2ODJlYjQ5MmM5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.madeon.fr/adventuremachine/?t=1,10,26,35" target="_blank" rel="noopener">Madeon：音乐制作</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zMjQ1YzNhZGVjMjQ4MjY4LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.autopiano.cn/" target="_blank" rel="noopener">自由钢琴</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1mMmE4OGZiNmY5NzhhNjMwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="音频处理"><a href="#音频处理" class="headerlink" title="音频处理"></a>音频处理</h3><ul><li><p><a href="https://melody.ml/" target="_blank" rel="noopener">音乐分轨：AI伴奏人声分离</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1hMzEwMmJlNzEwODdhZWVmLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://asoftmurmur.com/" target="_blank" rel="noopener">背景音合成器</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02YTI2Mjg5MWUzN2U0ZTY2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h3><ul><li><a href="http://listen1.github.io/listen1/" target="_blank" rel="noopener">listen1：多平台集成检索</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0xNThmM2VjOGFlZDA3MGU0LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul><li><a href="https://sonniss.com/" target="_blank" rel="noopener">免费游戏音效下载</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kMmRjMDdkMTA5NjVlODM2LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h1><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><ul><li><p><a href="https://taiko.bui.pm/" target="_blank" rel="noopener">太鼓达人</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zYmRiNmRhMjBkNTRlYmVjLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://nazo.one-story.cn/" target="_blank" rel="noopener">Nazo Game：解谜</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jMGM3ODE0OTZmYjM2ODFhLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://cavalierchallenge.com/" target="_blank" rel="noopener">Cavalier：在线游戏</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0yYjllOTllNjNiNTI1MGMyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://nexus.leagueoflegends.com/en-us/" target="_blank" rel="noopener">Nexus</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04MTI5ZDZiYzU4ODRiODNjLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://pos.biborg.com/fr/" target="_blank" rel="noopener">POS</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi00Njk0YzkxYWMzNDE3OGI5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ul><li><p><a href="http://www.shushubuyue.net/#" target="_blank" rel="noopener">叔叔不约：匿名聊天</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02OGUzOTNiZTYxNWU5ZDViLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://touchpianist.com/" target="_blank" rel="noopener">Touch Pianist</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04Y2RjYTNjMGFhYTJmMWE2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h1 id="参观"><a href="#参观" class="headerlink" title="参观"></a>参观</h1><h3 id="会议"><a href="#会议" class="headerlink" title="会议"></a>会议</h3><ul><li><a href="http://www.eshow365.com/" target="_blank" rel="noopener">E展网：获取各种博览会参观信息</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1lMWQ2YTJhMTc1OTg1NTExLnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h1><h3 id="实体餐品"><a href="#实体餐品" class="headerlink" title="实体餐品"></a>实体餐品</h3><ul><li><p><a href="https://www.dxomark.com/" target="_blank" rel="noopener">Dxomark：摄影产品</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03ZjA5NTEwYzg1ZjNjNzZkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://sf.taobao.com/?spm=a213w.7398504.sfhead2014.2.9vuB5l&amp;current=index" target="_blank" rel="noopener">司法拍卖</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04OGRiNzZhY2UyYWMyZWEyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://auction.jd.com/haiguan.html" target="_blank" rel="noopener">京东拍卖</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0wMmYxMmE5MTNlZWYxZDk1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><ul><li><a href="http://adobe.v404.cn/adobe/" target="_blank" rel="noopener">Adobe全套</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1hZmI5MzAwMGFjZjBjMDg3LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="趣味"><a href="#趣味" class="headerlink" title="趣味"></a>趣味</h1><h3 id="有趣"><a href="#有趣" class="headerlink" title="有趣"></a>有趣</h3><ul><li><p><a href="http://www.bigpixel.cn/index.html" target="_blank" rel="noopener">大像素：千亿像素看中国各地全景图</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0yYWZlZDE2ZTRlYWM4ZjNkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://artbreeder.com/" target="_blank" rel="noopener">AI融合</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05NWI0ODU0OWZkZGI2Zjk2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://humanbenchmark.com/" target="_blank" rel="noopener">人类测试</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kZjMzNDE5Njc2ZTk4MzE2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://userinyerface.com/game.html" target="_blank" rel="noopener">反人类UI</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iYjU0OWY3ZTVkMDQ0M2M5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://neave.com/" target="_blank" rel="noopener">Neave Interactive：在线有趣的应用</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04N2IxM2MyOTVjZjYzNzY0LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://timelineofearth.com/" target="_blank" rel="noopener">地球时间</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02Mzc0M2Y3MzM2YTI5Y2U3LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://zh.forvo.com/user/hikari1/pronounced-words/page-2/" target="_blank" rel="noopener">学说话</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05YWY1NjliMTBkODJhOTg0LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.ro.me/" target="_blank" rel="noopener">RoMe</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03OTA2MTZiNGE4Zjc5MTFkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://burymewithmymoney.com/" target="_blank" rel="noopener">bury me with my money</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03MTM0MmI2MDlhYzBjNDkzLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="神秘"><a href="#神秘" class="headerlink" title="神秘"></a>神秘</h3><ul><li><a href="https://resn.co.nz/#" target="_blank" rel="noopener">Resn：首次加载较慢</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kMzgxZGFiMDY4MzZlM2VhLnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h1><ul><li><a href="https://www.wuxiaworld.com/" target="_blank" rel="noopener">武侠世界</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zZTgxMzUxNDA4NmQ4YmNjLnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Share </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/helloworld.html"/>
      <url>/posts/helloworld.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
