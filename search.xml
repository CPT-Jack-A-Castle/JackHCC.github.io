<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nginx学习笔录</title>
      <link href="/posts/blog-program04.html"/>
      <url>/posts/blog-program04.html</url>
      
        <content type="html"><![CDATA[<p><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">官方文档</a></p><h3 id="Http协议简介"><a href="#Http协议简介" class="headerlink" title="Http协议简介"></a>Http协议简介</h3><ul><li><p>http协议：80/tcp,HyperText Transfer Procotol</p></li><li><p>html:Hypertext Mark Language</p></li><li><p>文本：HTTP/1.0 MIME</p></li><li><p>MIME:Multipurpose Internet Mail Extension</p><ul><li>major/minor<ul><li>text/plain</li><li>image/jpeg</li></ul></li></ul></li><li><p>URL:schem://server[:port]/path/to/source</p></li><li><p>http事务：request &lt;——–&gt; response</p><ul><li><p>request:<br><method><url><version></version></url></method></p><header></header></li><li><p>response:<br><version><status><reason phrase=""></reason></status></version></p><header><ul><li>协议格式：文本，二进制</li></ul></header></li></ul></li><li><p>method：<br>GET，HEAD,POST,PUT,DELETE,TRACE,OPTIONS</p></li><li><p>status:<br>1xx: 信息类<br>2xx: 成功类 200（ok）<br>3xx: 重定向类 301,302,304<br>4xx: 客户端错误类 403,404<br>5xx: 服务器端错误 502</p></li><li><p>HEADER：<br>通用首部<br>请求首部：<br>  IF-Modified-Since   IF-None-Match<br>响应首部<br>实体首部<br>扩展首部</p></li></ul><h3 id="Web页面访问及其页面资源"><a href="#Web页面访问及其页面资源" class="headerlink" title="Web页面访问及其页面资源"></a>Web页面访问及其页面资源</h3><ul><li><p>Web页面：多个资源<br>  入口，资源引用</p></li><li><p>认证：<br>基于IP认证<br>基于用户认证</p></li><li><p>资源映射：<br>Alias<br>DocumentRoot</p></li><li><p>httpd：MPM</p><ul><li><p>prefork，worker，event</p><p>prefork：主进程，生成多个子进程，每个子进程处理一个请求<br>worker：主进程，生成多个子进程，每个子进程生成多个线程，每个线程响应一个请求<br>event：主进程，生成多个子进程，每个子进程响应多个请求</p></li></ul></li></ul><h3 id="I-O类型"><a href="#I-O类型" class="headerlink" title="I/O类型"></a>I/O类型</h3><ul><li><p>同步与异步：synchronous，asynchronous<br>关注的是消息通知机制</p><ul><li>同步：调用发生之后不会立即返回，但一旦返回，就返回最终结果</li><li>异步：调用出发之后，被调用方立即返回消息，但返回并非最终结果；被调用通过状态，通知机制来通知调用者，或通过回调函数来处理结果过</li></ul></li><li><p>阻塞与非阻塞：block，nonblock<br>关注的是调用者等待返回调用结果时的状态</p><ul><li>阻塞：调用返回之前，调用者被挂起，只能得到返回结果过才能继续</li><li>非阻塞：调用在结果返回之前，不会被挂起，即调用不会阻塞调用者</li></ul></li></ul><p>###I/O模型</p><ul><li><p>blocking I/O：阻塞式</p></li><li><p>nonblocking I/O：非阻塞式</p></li><li><p>IO multiplexing：复用型<br>  select（），poll（）</p></li><li><p>signal driven IO：事件驱动</p><ul><li>通知：<br>水平触发：多次通知<br>边缘触发：只通知一次</li></ul></li><li><p>asynchronous IO：异步</p></li></ul><p>例如：一次读操作</p><ol><li>等待数据准备好，磁盘到内核内存</li><li>从内核复制到进程内存</li></ol><p>注：前三个为同步，后两个为异步</p><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><ul><li><p><a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a> , C10k</p></li><li><p>Igor Sysoev,Rambler Media;</p><ul><li>engine X:nginx</li><li>tenglne,OpenResty</li></ul></li><li><p>Nginx特性：</p><ol><li>模块化设计，较好的扩展性</li><li>高可靠性：master/worker</li><li>支持热部署：不停机更新配置值文件，更新日志，更新服务器程序版本</li><li>低内存消耗：10000个keep-alive连接模式的非活动链接仅占2.5M</li><li>event-driven，alo，mmap</li></ol></li><li><p>基本功能</p><ul><li><p>静态资源的web服务器</p></li><li><p>http协议的反向代理</p><ul><li>http代理：指的是使用代理服务器使网络用户访问外部网站。代理服务器是介于浏览器和Web服务器之间的一台服务器，是建立在超文本传输协议上的网络浏览方式，作用是可以防伪部分对协议进行了限制的局域网。</li><li>关于HTTP代理服务器的主要功能包括五个方面：<ol><li>突破自身IP访问限制，访问国外站点；</li><li>访问一些单位或团体内部资源，如某大学的内部网，使用<a href="https://www.baidu.com/s?wd=%E6%95%99%E8%82%B2%E7%BD%91&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">教育网</a>内地址段免费代理服务器可以用于对教育 网开放的各类下载上传以及各类资料查询共享等服务；</li></ol></li></ul><ol start="3"><li>突破<a href="https://www.baidu.com/s?wd=%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A1&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">中国电信</a>的<a href="https://www.baidu.com/s?wd=IP%E5%B0%81%E9%94%81&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">IP封锁</a>：<a href="https://www.baidu.com/s?wd=%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A1&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">中国电信</a>有很多网站限制了用户访问，使用HTTP代理可以突破访问限制；</li><li>提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时将信息保存到缓冲区中，当其他用户再访问相同的信息时， 可直接由缓冲区中取出信息传递给用户，提高访问速度；</li><li>隐藏真实IP：HTTP代理可以隐藏IP地址，避免受到网络攻击。<ul><li>http反向代理：所谓反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。<br>我们常说的代理是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，科学上网工具 Shadowsocks 扮演的就是典型的正向代理角色。在天朝用浏览器访问 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 时会被无情的墙掉，要想翻阅这堵墙，你可以在国外用 Shadowsocks 来搭建一台代理服务器，让代理帮我们去请求 <a href="http://www.google.com，代理再把请求响应结果再返回给我。" target="_blank" rel="noopener">www.google.com，代理再把请求响应结果再返回给我。</a><br>反向代理隐藏了真实的服务端。</li></ul></li></ol></li><li><p>pop3，SMPT，IMap4等邮件协议的反向代理</p></li><li><p>能缓存打开的文件（元数据），支持FastCGI（php-fpm），uWSGI（python web Framwork）等协议</p></li><li><p>模块化，过滤器zip，ssi，ssl</p></li></ul></li><li><p>Web服务相关功能<br>虚拟主机，keepalive，访问日志，url rewrite，路径别名，基于IP及用户的访问控制，支持速率限制及并发数限制；……</p></li><li><p>Nginx基础架构</p><ul><li><p>master/worker<br>一个master进程，可以生成多个worker进程；<br>事件驱动：epoll（Linux），kqueue（FreeBSD），/dev/poll（Solars）</p><ul><li>消息通知：select，poll，rt signals</li></ul><p>支持sendfile，sendfile64<br>支持AIO，mmap</p><p>master：加载配置文件，管理worker进程，平滑升级……<br>worker：http服务，http代理，fastcgl代理……</p></li></ul></li><li><p>模块类型</p><ul><li>核心模块：core module</li><li>Standard HTTP modules</li><li>Optional HTTP modules</li><li>Mail modules</li><li>3rd party modules</li></ul></li><li><p>做什么？<br>静态资源web服务器<br>http服务器反向代理</p></li></ul><h3 id="Nginx安装与配置"><a href="#Nginx安装与配置" class="headerlink" title="Nginx安装与配置"></a>Nginx安装与配置</h3><p><a href="https://www.jianshu.com/p/be46088269ba" target="_blank" rel="noopener">Nginx:Window下安装与配置</a><br> <a href="https://www.jianshu.com/p/8d3e1689b884" target="_blank" rel="noopener">Nginx:Ubuntu下安装与配置</a></p><p><strong>配置文件</strong></p><ul><li>主配置文件：nginx.conf</li><li>mime.types</li><li>fastcgi配置文件：fastcgi_params     uwsgl_params</li><li>proxy.conf</li><li>sites.conf</li></ul><p><strong>配置指令</strong>(必须以分号结尾)</p><pre><code>Directive value1[value2……];</code></pre><p>支持使用变量：</p><ul><li>内置变量：又模块引入</li><li>自定义变量：<pre><code>set variable value</code></pre></li><li>引用变量:$variable</li></ul><p><strong>nginx.conf配置文件组织结构</strong></p><pre><code>main blockevent{...}http{...  upstream{  ...  }  //至少一个server  server{    ...    server_name    root    alias    location /url/{    ...    }  }  server{    ...  }} </code></pre><p><strong>main block配置</strong><br>  类别：</p><ul><li>正常运行必备的配置</li></ul><pre><code>1. user USERNAME [GROUPNAME];  指定用于运行work进程的用户和组.user nginx nginx2. pid /PATH/TO/PID_FILE;  指定nginx进程的pid文路径pid /var/run/nginx.pid3. worker_rlimit_nofile #;  一个work进程所能打开的最大文件描述符数量4. worker_rlimit_slgpending #; 每个用户能够发给worker进程的信号数量</code></pre><ul><li>优化性能相关的配置</li></ul><pre><code>1. work_processes # ;  worker进程的个数，通常为该物理CPU核心数量-1，可以设置为‘auto’2. worker_cpu_affinity CPUMASK CPUMASK ……    CUPMASK:0001    0010    0100    1000worker_cpu_affinity 00000001 00000010 000001003. worker_priority nice;[-20,19]</code></pre><ul><li>用于调试，定位问题的配置</li></ul><pre><code>1. daemon off|on;   是否以守护进程方式启动nginx2. master_process on|off;   是否以master/worker模型运行nginx3. error_log  /PATH/TO/ERROR_LOG level;   错误日志文件及其级别；用于调试需要，可以设为debug，但debug仅在编译时使用‘--with-debug’选项时才生效</code></pre><p><strong>event配置</strong></p><pre><code>1. worker_connections # ; 每个worker进程能够响应最大的并发请求数量worker_proceses * worker_connections2. use [epoll|rgsig|select|poll];定义使用的事件模型，建议让nginx自动选择3. accept_mutex [on|off];  各worker接受用户请求的负载均衡锁；启用时，表示用于让多个worker轮流的，序列的响应新请求4. lock_file /PATH/TO/LOCK_FILE;</code></pre><p><strong>http配置</strong></p><ul><li>套接字或主机相关指令</li></ul><ol><li><p>server{}：//定义虚拟主机</p><pre><code>server{listen PORT；server_name NAME;  root /PATH/TO/DOCUMENTROOT;}</code></pre><p>注：（1）基于port：listen监听不同的端口；<br>（2）基于hostname：server_name指令指向不同主机</p></li><li><p>listen</p><pre><code>listen address[:port][default_server][ssl][http2|spdy]listen port[default_server][ssl][http2|spdy]//default_server:设置默认虚拟主机，用于基于IP地址，或使用任意不能对应任何一个server的name时所返回的站点；//ssl:用于限制只能通过ssl连接提供服务//spdy:SPDY protocol(speedy),在编译时spdy模块情况下，用于支持SPDY协议//http2:http version 2;</code></pre></li><li><p>server_name NAME [……];<br>可跟一个或多个主机名，名称还可以使用通配符和正则表达式（~）；<br>```</p></li><li><p>首先做精准匹配：<a href="http://www.magedu.com" target="_blank" rel="noopener">www.magedu.com</a></p></li><li><p>左侧通配符：*.magedu.com</p></li><li><p>右侧通配符：<a href="http://www.magedu" target="_blank" rel="noopener">www.magedu</a>.*</p></li><li><p>正则表达式：~^.*\magedu.com$</p></li><li><p>default server</p><pre><code></code></pre></li><li><p>tcp_nodelay on|off<br>在keepalive模式下的连接是否使用TCP_NODELAY选项；</p></li><li><p>tcp_nopush on|off<br>是否启用TCP_NOPUSH(FREEBSE)或TCP_CORK(LINUX)选项；仅在sendfile为on时有用</p></li><li><p>sendfile on|off<br>是否启用sendfile功能</p></li></ol><ul><li>路径相关指令</li></ul><ol start="7"><li>root<br>设置web资源的路径映射，用于指明请求的URL所对应的文档目录的路径:<pre><code>server{...root /data/www/vhost1;}// 访问http://www.a.com/image/logo.jpg  --&gt;/data/www/vhost1/image/logo.ipgserver{...server_name www.a.comlocation /image/ { root /data/imgs/; ...}// 访问http://www.a.com/image/logo.jpg  --&gt;/data/imgs/image/logo.ipg</code></pre></li><li>location [= | ~ | <del>* | ^</del>] url{……}<br>location @name {……}</li></ol><p>功能：允许根据用户请求的url来匹配定义的各location，匹配到时，此请求将被相应的location块中的配置所处理，简言之，即用于需要的专用配置的URL提供特定配置。</p><ul><li>=：url的精确匹配</li><li>~：做正则表达式匹配，区分字符大小写</li><li>~*：做正则表达式匹配，不区分字符大小写</li><li>^~：url左半部分匹配，不区分字符大小写</li></ul><p><strong>匹配优先级</strong>：=，^<del>,</del>或~*，不带符号的url；</p><ol start="9"><li><p>alias<br>只能用于location匹配段，定义路径别名</p><pre><code>location /image/{root /data/imgs/;}location /image/{alias /data/imgs/;}</code></pre><p>注：<br>root：给定的路径对应location的“/”这个url<br>/image/test.jpg–&gt;/data/imgs/image/test.jpg<br>alias：给定的路径对应于location的“/url”这个url<br>/image/test.jpg–&gt;/data/imgs/test.jpg</p></li><li><p>index</p><pre><code>index file ……;</code></pre><p>默认主页面</p></li><li><p>error_page code … [=[response]] url<br>根据http的状态码重定向错误页面；</p><pre><code>error_page 404 /404.htmlerror_page 404=200 /404.html   //以指定状态码响应</code></pre></li><li><p>try_files file…… url；<br>try_files file……=code；<br>尝试查找第一个至第N-1个文件，第一个返回给请求者的资源，若N-1文件都不存在，则跳转至最后一个url（必须不能匹配至当前location，而应该匹配至其他location，否则会导致死循环）；</p></li></ol><p><strong>用户请求相关配置</strong><br>13. keepalive_timeout timeout [header_timeout]<br>设定keepalive连接的超时时长；0表示禁止长连接</p><ol start="14"><li><p>keepalive_requests number;<br>在keepalive链接上所允许请求的最大资源数量；默认100</p></li><li><p>keepalive_disable none|browser …;<br>指明禁止为何种浏览器使用keepalive功能；</p></li><li><p>send_timeout #;<br>发送响应报文超时时长，默认60s</p></li><li><p>client_body_buffer_size size;<br>接受客户端请求报文body的缓冲区大小，默认16k；超出此值时，将被移存于磁盘上</p></li><li><p>client_body_temp_path path [level1 [level2 [level3]]];<br>设定用于存储客户端请求body的临时储存路径及子目录结构和数量；</p><pre><code>client_body_temp_path /var/tmp/client_body 2 2</code></pre></li></ol><p><strong>对客户端请求进行限制</strong></p><ol start="19"><li><p>limit_except METHOD{…}<br>对指定范围外的其他方法进行访问控制；</p><pre><code>limit_except GET{allow 172.16.0.0/16;deny all;}</code></pre></li><li><p>limit_rate speed;<br>限制客户端每秒钟所能够传输的字节数，默认为0表示无限制。</p></li></ol><p><strong>文件操作优化相关配置</strong></p><ol start="21"><li><p>aio on|off</p></li><li><p>directio size|off;</p></li><li><p>open_file_cache off;<br>open_file_cache  max=N [inactive=time]</p><p>nginx可以缓存以下三种信息：</p><ol><li>文件描述符，文件大小和最近一次的修改时间</li><li>打开的目录的结构</li><li>没有找到的或者没有权限操作的文件的相关信息</li></ol></li></ol><p>max=N 表示可缓存的最大条目上限，则会使用LUR算法中删除最近最少使用的缓存项；</p><p>inactive=time:在此处指定的时长内没有被访问的缓存项视为非活动缓存项，因此直接删除；</p><ol start="24"><li><p>open_file_cache_errors on|off;<br>是否缓存找不到路径的文件，或没有权限访问的文件相关信息；</p></li><li><p>open_file_cache_valid time;<br>没隔多久检查一次缓存中缓存项的有效性，默认60s；</p></li><li><p>open_file_cache_min_uses number;<br>缓存项在非活动期限内最少应该被访问的次数；</p></li></ol><p><strong>ngx_http_access_module模块(基于IP的访问控制)</strong><br>27. allow address|CIDR|unix|all;</p><ol start="28"><li><p>deny address|CIDR|unix|all;</p><p>  应用上下文：http,server,location,limit_except</p></li></ol><p><strong>ngx_http_auth_basic_module模块(basic认证)</strong></p><ol start="29"><li><p>auth_basic string|off;<br>使用http basic认证协议对用户进行认证</p></li><li><p>auth_basic_user_file file;<br>实现用户认证的账号文件；</p></li></ol><ul><li><p>文件格式：<br>name1:password1<br>name2:password2;commit</p></li><li><p>密码格式：</p></li></ul><p>1.encrypted with the crypt（） function；<br>2.md5加密；</p><pre><code>location /admin/ {auth_basic "admin"auth_basic_user_file /etc/nginx/.ngxhtpasswd;}</code></pre><p><strong>ngx_http_log_module模块(访问日志)</strong><br>31. log_format name string …;<br>定义日志格式及其名称，日志格式一般通过调用内置函数变量来定义</p><ol start="32"><li>access_log path [format[buffer=size[flush=time]]];<br>access_log off;</li></ol><p>访问日志路径，格式名称以及缓存大小的刷写时间间隔；建议定义缓冲以提升性能。</p><ol start="33"><li>open_log_file_cache max=N[inactive=time][min_user=N][valid=time];<br>open_log_file_cache off;</li></ol><p><strong>ngx_http_stub_status_module模块</strong><br>34. stub_status;<br>通过指定的url的stub_status</p><p>Active connections: 291<br>server accepts handled requests<br> 16630948 16630948 31070465<br>Reading: 6 Writing: 179 Waiting: 106 </p><ul><li>Active connections:当前活动客户端连接数，包括<code>Waiting</code>连接数。</li><li>accepts:已接受的客户端连接总数。</li><li>handled:已处理连接的总数。通常，参数值与<code>accepts</code> 除非已达到某些资源限制（例如， <a href="http://nginx.org/en/docs/ngx_core_module.html#worker_connections" target="_blank" rel="noopener">worker_connections</a>限制）相同。</li><li>requests:客户端请求的总数。</li><li>Reading:nginx正在读取请求标头的当前连接数。</li><li>Writing:nginx将响应写回客户端的当前连接数。</li><li>Waiting:当前等待请求的空闲客户端连接数。</li></ul><p><strong>ngx_http_referer_module模块</strong><br>35. valid_referers none | blocked | server_names | string …;</p><ul><li>none 请求标头中不存在“Referer”字段;</li><li>blocked：“Referer”字段出现在请求标头中，但其值已被防火墙或代理服务器删除; 这些值是不以“ http://”或“ https://” 开头的字符串;</li><li>server_names：“Referer”请求头字段包含一个服务器名称;</li><li>arbitrary string:直接字符串，可以使用通配符</li><li>regular expression：以~起始的正则表达式</li></ul><p><strong>内置变量：$invalid_referer(所有不能符合valid_referer指令定义的引用请求均为不合法引用)</strong></p><p>实例：</p><pre><code>valid_referers none blocked server_names               *.example.com example.* www.example.org/galleries/               ~\.google\.;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构与基本命令</title>
      <link href="/posts/blog-program03.html"/>
      <url>/posts/blog-program03.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://redis.io/documentation" target="_blank" rel="noopener">官网文档</a></p><h1 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h1><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><ul><li><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p></li><li><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p></li><li><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p></li></ul><p>实例</p><pre><code>redis 127.0.0.1:6379&gt; SET name "runoob"OKredis 127.0.0.1:6379&gt; GET name"runoob"</code></pre><p>在以上实例中我们使用了 Redis 的 SET 和 GET 命令。键为 name，对应的值为 runoob。<br>注意：一个键最大能存储512MB。</p><h1 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h1><ul><li><p>Redis hash 是一个键值(key=&gt;value)对集合。</p></li><li><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p></li></ul><p>实例<br>DEL runoob 用于删除前面测试用过的 key，不然会报错：(error) WRONGTYPE Operation against a key holding the wrong kind of value</p><pre><code>redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; HMSET myhash field1 "Hello" field2 "World""OK"redis 127.0.0.1:6379&gt; HGET myhash field1"Hello"redis 127.0.0.1:6379&gt; HGET myhash field2"World"</code></pre><p>实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field=&gt;value 对, HGET 获取对应 field 对应的 value。</p><p>每个 hash 可以存储 232 -1 键值对（40多亿）。</p><h1 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h1><ul><li>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</li></ul><p>实例</p><pre><code>redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; lpush runoob redis(integer) 1redis 127.0.0.1:6379&gt; lpush runoob mongodb(integer) 2redis 127.0.0.1:6379&gt; lpush runoob rabitmq(integer) 3redis 127.0.0.1:6379&gt; lrange runoob 0 101) "rabitmq"2) "mongodb"3) "redis"redis 127.0.0.1:6379&gt;</code></pre><p>列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p><h1 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h1><ul><li><p>Redis的Set是string类型的无序集合。</p></li><li><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p></li></ul><p><strong>sadd 命令</strong><br>添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。</p><pre><code>sadd key member</code></pre><p>实例</p><pre><code>redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; sadd runoob redis(integer) 1redis 127.0.0.1:6379&gt; sadd runoob mongodb(integer) 1redis 127.0.0.1:6379&gt; sadd runoob rabitmq(integer) 1redis 127.0.0.1:6379&gt; sadd runoob rabitmq(integer) 0redis 127.0.0.1:6379&gt; smembers runoob1) "redis"2) "rabitmq"3) "mongodb"</code></pre><p>注意：以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。</p><p>集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。</p><h1 id="zset-sorted-set：有序集合"><a href="#zset-sorted-set：有序集合" class="headerlink" title="zset(sorted set：有序集合)"></a>zset(sorted set：有序集合)</h1><ul><li><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p></li><li><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p></li><li><p>zset的成员是唯一的,但分数(score)却可以重复。</p></li></ul><p><strong>zadd 命令</strong><br>添加元素到集合，元素在集合中存在则更新对应score</p><pre><code>zadd key score member </code></pre><p>实例</p><pre><code>redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; zadd runoob 0 redis(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 mongodb(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq(integer) 0redis 127.0.0.1:6379&gt; &gt; ZRANGEBYSCORE runoob 0 10001) "mongodb"2) "rabitmq"3) "redis"</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-99872bc3efe32f95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h1><p><a href="https://redis.io/commands" target="_blank" rel="noopener">官网命令大全</a></p><h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h1><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务。</li><li>命令入队。</li><li>执行事务。</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>以下是一个事务的例子， 它先以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <strong>EXEC</strong> 命令触发事务， 一并执行事务中的所有命令：</p><pre><code> MULTIOKredis 127.0.0.1:6379&gt; SET book-name "Mastering C++ in 21 days" QUEUEDredis 127.0.0.1:6379&gt; GET book-nameQUEUEDredis 127.0.0.1:6379&gt; SADD tag "C++"  "Programming"  "Mastering Series" QUEUEDredis 127.0.0.1:6379&gt; SMEMBERS tagQUEUEDredis 127.0.0.1:6379&gt; EXEC 1) OK 2)  "Mastering C++ in 21 days"  3)  (integer)  3  4)  1)  "Mastering Series"  2)  "C++"  3)  "Programming"</code></pre><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p><pre><code>&gt; **这是官网上的说明 From redis docs on [transactions](http://redis.io/topics/transactions):**&gt; &gt; It's important to note that even when a command fails, all the other commands in the queue are processed – Redis will not stop the processing of commands.</code></pre><p>比如：</p><pre><code>multiOKredis 127.0.0.1:7000&gt;  set a aaaQUEUEDredis 127.0.0.1:7000&gt;  set b bbbQUEUEDredis 127.0.0.1:7000&gt;  set c cccQUEUEDredis 127.0.0.1:7000&gt;  exec  1) OK 2) OK 3) OK</code></pre><p>如果在 set b bbb 处失败，set a 已成功不会回滚，set c 还会继续执行。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-8e69d7921e545c59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Redis总结"><a href="#Redis总结" class="headerlink" title="Redis总结"></a>Redis总结</h1><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-2bcace8f72ef86b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6ea16e5fef72a235.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cd603aac9dbd0165.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据库基础知识</title>
      <link href="/posts/blog-program02.html"/>
      <url>/posts/blog-program02.html</url>
      
        <content type="html"><![CDATA[<p>###【redis是什么】</p><p>redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持久化的Key-Value数据库。</p><p>redis的官网地址，非常好记，是redis.io。</p><p>目前，Vmware在资助着redis项目的开发和维护。</p><h3 id="【谁在使用redis】"><a href="#【谁在使用redis】" class="headerlink" title="【谁在使用redis】"></a>【谁在使用redis】</h3><p>Blizzard、digg、stackoverflow、github、flickr …</p><h3 id="【学会安装redis】"><a href="#【学会安装redis】" class="headerlink" title="【学会安装redis】"></a>【学会安装redis】</h3><p>从redis.io下载最新版redis-X.Y.Z.tar.gz后解压，然后进入redis-X.Y.Z文件夹后直接make即可，安装非常简单。</p><p>make成功后会在src文件夹下产生一些二进制可执行文件，包括redis-server、redis-cli等等：</p><pre><code>$ find . -type f -executable./redis-benchmark //用于进行redis性能测试的工具./redis-check-dump //用于修复出问题的dump.rdb文件./redis-cli //redis的客户端./redis-server //redis的服务端./redis-check-aof //用于修复出问题的AOF文件./redis-sentinel //用于集群管理</code></pre><h3 id="【学会启动redis】"><a href="#【学会启动redis】" class="headerlink" title="【学会启动redis】"></a><strong>【学会启动redis】</strong></h3><p>启动redis非常简单，直接./redis-server就可以启动服务端了，还可以用下面的方法指定要加载的配置文件：</p><p>复制代码代码如下:</p><pre><code>./redis-server ../redis.conf</code></pre><p>默认情况下，redis-server会以非daemon的方式来运行，且默认服务端口为6379。</p><h3 id="【使用redis客户端】"><a href="#【使用redis客户端】" class="headerlink" title="【使用redis客户端】"></a><strong>【使用redis客户端】</strong></h3><p>我们直接看一个例子：</p><p>复制代码代码如下:</p><pre><code>//这样来启动redis客户端了$ ./redis-cli//用set指令来设置key、value127.0.0.1:6379&gt; set name "roc" OK//来获取name的值127.0.0.1:6379&gt; get name "roc"//通过客户端来关闭redis服务端127.0.0.1:6379&gt; shutdown 127.0.0.1:6379&gt;</code></pre><h3 id="【redis数据结构-–-简介】"><a href="#【redis数据结构-–-简介】" class="headerlink" title="【redis数据结构 – 简介】"></a>【redis数据结构 – 简介】</h3><p>redis是一种高级的key:value存储系统，其中value支持五种数据类型：</p><p>1.字符串（strings）<br>2.字符串列表（lists）<br>3.字符串集合（sets）<br>4.有序字符串集合（sorted sets）<br>5.哈希（hashes）</p><p>而关于key，有几个点要提醒大家：</p><p>1.key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率；<br>2.key也不要太短，太短的话，key的可读性会降低；<br>3.在一个项目中，key最好使用统一的命名模式，例如user:10000:passwd。</p><h3 id="【redis数据结构-–-strings】"><a href="#【redis数据结构-–-strings】" class="headerlink" title="【redis数据结构 – strings】"></a><strong>【redis数据结构 – strings】</strong></h3><p>有人说，如果只使用redis中的字符串类型，且不使用redis的持久化功能，那么，redis就和memcache非常非常的像了。这说明strings类型是一个很基础的数据类型，也是任何存储系统都必备的数据类型。</p><p>我们来看一个最简单的例子：</p><p>复制代码代码如下:</p><pre><code>set mystr "hello world!" //设置字符串类型get mystr //读取字符串类型</code></pre><p>字符串类型的用法就是这么简单，因为是二进制安全的，所以你完全可以把一个图片文件的内容作为字符串来存储。</p><p>另外，我们还可以通过字符串类型进行数值操作：</p><p>复制代码代码如下:</p><pre><code>127.0.0.1:6379&gt; set mynum "2"OK127.0.0.1:6379&gt; get mynum"2"127.0.0.1:6379&gt; incr mynum(integer) 3127.0.0.1:6379&gt; get mynum"3"</code></pre><p>看，在遇到数值操作时，redis会将字符串类型转换成数值。</p><p>由于INCR等指令本身就具有原子操作的特性，所以我们完全可以利用redis的INCR、INCRBY、DECR、DECRBY等指令来实现原子计数的效果，假如，在某种场景下有3个客户端同时读取了mynum的值（值为2），然后对其同时进行了加1的操作，那么，最后mynum的值一定是5。不少网站都利用redis的这个特性来实现业务上的统计计数需求。</p><h3 id="【redis数据结构-–-lists】"><a href="#【redis数据结构-–-lists】" class="headerlink" title="【redis数据结构 – lists】"></a><strong>【redis数据结构 – lists】</strong></h3><p>redis的另一个重要的数据结构叫做lists，翻译成中文叫做“列表”。</p><p>首先要明确一点，redis中的lists在底层实现上并不是数组，而是链表，也就是说对于一个具有上百万个元素的lists来说，在头部和尾部插入一个新元素，其时间复杂度是常数级别的，比如用LPUSH在10个元素的lists头部插入新元素，和在上千万元素的lists头部插入新元素的速度应该是相同的。</p><p>虽然lists有这样的优势，但同样有其弊端，那就是，链表型lists的元素定位会比较慢，而数组型lists的元素定位就会快得多。</p><p>lists的常用操作包括LPUSH、RPUSH、LRANGE等。我们可以用LPUSH在lists的左侧插入一个新元素，用RPUSH在lists的右侧插入一个新元素，用LRANGE命令从lists中指定一个范围来提取元素。我们来看几个例子：</p><p>复制代码代码如下:</p><pre><code>//新建一个list叫做mylist，并在列表头部插入元素"1"127.0.0.1:6379&gt; lpush mylist "1" //返回当前mylist中的元素个数(integer) 1 //在mylist右侧插入元素"2"127.0.0.1:6379&gt; rpush mylist "2" (integer) 2//在mylist左侧插入元素"0"127.0.0.1:6379&gt; lpush mylist "0" (integer) 3//列出mylist中从编号0到编号1的元素127.0.0.1:6379&gt; lrange mylist 0 1 1) "0"2) "1"//列出mylist中从编号0到倒数第一个元素127.0.0.1:6379&gt; lrange mylist 0 -1 1) "0"2) "1"3) "2"</code></pre><p>lists的应用相当广泛，随便举几个例子：</p><p>1.我们可以利用lists来实现一个消息队列，而且可以确保先后顺序，不必像MySQL那样还需要通过ORDER BY来进行排序。<br>2.利用LRANGE还可以很方便的实现分页的功能。<br>3.在博客系统中，每片博文的评论也可以存入一个单独的list中。</p><h3 id="【redis数据结构-–-集合】"><a href="#【redis数据结构-–-集合】" class="headerlink" title="【redis数据结构 – 集合】"></a><strong>【redis数据结构 – 集合】</strong></h3><p>redis的集合，是一种无序的集合，集合中的元素没有先后顺序。</p><p>集合相关的操作也很丰富，如添加新元素、删除已有元素、取交集、取并集、取差集等。我们来看例子：</p><p>复制代码代码如下:</p><pre><code>//向集合myset中加入一个新元素"one"127.0.0.1:6379&gt; sadd myset "one" (integer) 1127.0.0.1:6379&gt; sadd myset "two"(integer) 1//列出集合myset中的所有元素127.0.0.1:6379&gt; smembers myset 1) "one"2) "two"//判断元素1是否在集合myset中，返回1表示存在127.0.0.1:6379&gt; sismember myset "one" (integer) 1//判断元素3是否在集合myset中，返回0表示不存在127.0.0.1:6379&gt; sismember myset "three" (integer) 0//新建一个新的集合yourset127.0.0.1:6379&gt; sadd yourset "1" (integer) 1127.0.0.1:6379&gt; sadd yourset "2"(integer) 1127.0.0.1:6379&gt; smembers yourset1) "1"2) "2"//对两个集合求并集127.0.0.1:6379&gt; sunion myset yourset 1) "1"2) "one"3) "2"4) "two"</code></pre><p>对于集合的使用，也有一些常见的方式，比如，QQ有一个社交功能叫做“好友标签”，大家可以给你的好友贴标签，比如“大美女”、“土豪”、“欧巴”等等，这时就可以使用redis的集合来实现，把每一个用户的标签都存储在一个集合之中。</p><h3 id="【redis数据结构-–-有序集合】"><a href="#【redis数据结构-–-有序集合】" class="headerlink" title="【redis数据结构 – 有序集合】"></a><strong>【redis数据结构 – 有序集合】</strong></h3><p>redis不但提供了无需集合（sets），还很体贴的提供了有序集合（sorted sets）。有序集合中的每个元素都关联一个序号（score），这便是排序的依据。</p><p>很多时候，我们都将redis中的有序集合叫做zsets，这是因为在redis中，有序集合相关的操作指令都是以z开头的，比如zrange、zadd、zrevrange、zrangebyscore等等</p><p>老规矩，我们来看几个生动的例子：<br>//新增一个有序集合myzset，并加入一个元素baidu.com，给它赋予的序号是1：</p><p>复制代码代码如下:</p><pre><code>127.0.0.1:6379&gt; zadd myzset 1 baidu.com (integer) 1//向myzset中新增一个元素360.com，赋予它的序号是3127.0.0.1:6379&gt; zadd myzset 3 360.com (integer) 1//向myzset中新增一个元素google.com，赋予它的序号是2127.0.0.1:6379&gt; zadd myzset 2 google.com (integer) 1//列出myzset的所有元素，同时列出其序号，可以看出myzset已经是有序的了。127.0.0.1:6379&gt; zrange myzset 0 -1 with scores 1) "baidu.com"2) "1"3) "google.com"4) "2"5) "360.com"6) "3"//只列出myzset的元素127.0.0.1:6379&gt; zrange myzset 0 -1 1) "baidu.com"2) "google.com"3) "360.com"</code></pre><h3 id="【redis数据结构-–-哈希】"><a href="#【redis数据结构-–-哈希】" class="headerlink" title="【redis数据结构 – 哈希】"></a><strong>【redis数据结构 – 哈希】</strong></h3><p>最后要给大家介绍的是hashes，即哈希。哈希是从redis-2.0.0版本之后才有的数据结构。</p><p>hashes存的是字符串和字符串值之间的映射，比如一个用户要存储其全名、姓氏、年龄等等，就很适合使用哈希。</p><p>我们来看一个例子：</p><p>复制代码代码如下:</p><pre><code>//建立哈希，并赋值127.0.0.1:6379&gt; HMSET user:001 username antirez password P1pp0 age 34 OK//列出哈希的内容127.0.0.1:6379&gt; HGETALL user:001 1) "username"2) "antirez"3) "password"4) "P1pp0"5) "age"6) "34"//更改哈希中的某一个值127.0.0.1:6379&gt; HSET user:001 password 12345 (integer) 0//再次列出哈希的内容127.0.0.1:6379&gt; HGETALL user:001 1) "username"2) "antirez"3) "password"4) "12345"5) "age"6) "34"</code></pre><p>有关hashes的操作，同样很丰富，需要时，大家可以从这里<a href="http://redis.io/commands#hash" target="_blank" rel="noopener">查询</a>。</p><h3 id="【聊聊redis持久化-–-两种方式】"><a href="#【聊聊redis持久化-–-两种方式】" class="headerlink" title="【聊聊redis持久化 – 两种方式】"></a>【聊聊redis持久化 – 两种方式】</h3><p>redis提供了两种持久化的方式，分别是RDB（Redis DataBase）和AOF（Append Only File）。</p><p>RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上；</p><p>AOF，则是换了一个角度来实现持久化，那就是将redis执行过的所有写指令记录下来，在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。</p><p>其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复，这是因为AOF方式的数据恢复完整度更高。</p><p>如果你没有数据持久化的需求，也完全可以关闭RDB和AOF方式，这样的话，redis将变成一个纯内存数据库，就像memcache一样。</p><h3 id="【聊聊redis持久化-–-RDB】"><a href="#【聊聊redis持久化-–-RDB】" class="headerlink" title="【聊聊redis持久化 – RDB】"></a>【聊聊redis持久化 – RDB】</h3><p>RDB方式，是将redis某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。</p><p>redis在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。</p><p>对于RDB方式，redis会单独创建（fork）一个子进程来进行持久化，而主进程是不会进行任何IO操作的，这样就确保了redis极高的性能。</p><p>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。</p><p>虽然RDB有不少优点，但它的缺点也是不容忽视的。如果你对数据的完整性非常敏感，那么RDB方式就不太适合你，因为即使你每5分钟都持久化一次，当redis故障时，仍然会有近5分钟的数据丢失。所以，redis还提供了另一种持久化方式，那就是AOF。</p><h3 id="【聊聊redis持久化-–-AOF】"><a href="#【聊聊redis持久化-–-AOF】" class="headerlink" title="【聊聊redis持久化 – AOF】"></a>【聊聊redis持久化 – AOF】</h3><p>AOF，英文是Append Only File，即只允许追加不允许改写的文件。</p><p>如前面介绍的，AOF方式是将执行过的写指令记录下来，在数据恢复时按照从前到后的顺序再将指令都执行一遍，就这么简单。</p><p>我们通过配置redis.conf中的appendonly yes就可以打开AOF功能。如果有写操作（如SET等），redis就会被追加到AOF文件的末尾。</p><p>默认的AOF持久化策略是每秒钟fsync一次（fsync是指把缓存中的写指令记录到磁盘中），因为在这种情况下，redis仍然可以保持很好的处理性能，即使redis故障，也只会丢失最近1秒钟的数据。</p><p>如果在追加日志时，恰好遇到磁盘空间满、inode满或断电等情况导致日志写入不完整，也没有关系，redis提供了redis-check-aof工具，可以用来进行日志修复。</p><p>因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。举个例子或许更形象，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。</p><p>在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性，这点大家可以放心。</p><p>AOF方式的另一个好处，我们通过一个“场景再现”来说明。某同学在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，这是很悲剧的事情。不过这也不是世界末日，只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。是不是很神奇，这就是AOF持久化方式的好处之一。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了。</p><p>虽然优点多多，但AOF方式也同样存在缺陷，比如在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。</p><p>如果你直接执行BGREWRITEAOF命令，那么redis会生成一个全新的AOF文件，其中便包括了可以恢复现有数据的最少的命令集。</p><p>如果运气比较差，AOF文件出现了被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：</p><p>1.备份被写坏的AOF文件<br>2.运行redis-check-aof –fix进行修复<br>3.用diff -u来看下两个文件的差异，确认问题点<br>4.重启redis，加载修复后的AOF文件</p><h3 id="【聊聊redis持久化-–-AOF重写】"><a href="#【聊聊redis持久化-–-AOF重写】" class="headerlink" title="【聊聊redis持久化 – AOF重写】"></a>【聊聊redis持久化 – AOF重写】</h3><p>AOF重写的内部运行原理，我们有必要了解一下。</p><p>在重写即将开始之际，redis会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的AOF文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</p><p>与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的AOF文件中，这样做是保证原有的AOF文件的可用性，避免在重写过程中出现意外。</p><p>当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新AOF文件中。</p><p>当追加结束后，redis就会用新AOF文件来代替旧AOF文件，之后再有新的写指令，就都会追加到新的AOF文件中了。</p><h3 id="【聊聊主从-–-用法】"><a href="#【聊聊主从-–-用法】" class="headerlink" title="【聊聊主从 – 用法】"></a>【聊聊主从 – 用法】</h3><p>像MySQL一样，redis是支持主从同步的，而且也支持一主多从以及多级从结构。</p><p>主从结构，一是为了纯粹的冗余备份，二是为了提升读性能，比如很消耗性能的SORT就可以由从服务器来承担。</p><p>redis的主从同步是异步进行的，这意味着主从同步不会影响主逻辑，也不会降低redis的处理性能。</p><p>主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行持久化，这样可以提高主服务器的处理性能。</p><p>在主从架构中，从服务器通常被设置为只读模式，这样可以避免从服务器的数据被误修改。但是从服务器仍然可以接受CONFIG等指令，所以还是不应该将从服务器直接暴露到不安全的网络环境中。如果必须如此，那可以考虑给重要指令进行重命名，来避免命令被外人误执行。</p><h3 id="【聊聊主从-–-同步原理】"><a href="#【聊聊主从-–-同步原理】" class="headerlink" title="【聊聊主从 – 同步原理】"></a>【聊聊主从 – 同步原理】</h3><p>从服务器会向主服务器发出SYNC指令，当主服务器接到此命令后，就会调用BGSAVE指令来创建一个子进程专门进行数据持久化工作，也就是将主服务器的数据写入RDB文件中。在数据持久化期间，主服务器将执行的写指令都缓存在内存中。</p><p>在BGSAVE指令执行完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器接到此文件后会将其存储到磁盘上，然后再将其读取到内存中。这个动作完成后，主服务器会将这段时间缓存的写指令再以redis协议的格式发送给从服务器。</p><p>另外，要说的一点是，即使有多个从服务器同时发来SYNC指令，主服务器也只会执行一次BGSAVE，然后把持久化好的RDB文件发给多个下游。在redis2.8版本之前，如果从服务器与主服务器因某些原因断开连接的话，都会进行一次主从之间的全量的数据同步；而在2.8版本之后，redis支持了效率更高的增量同步策略，这大大降低了连接断开的恢复成本。</p><p>主服务器会在内存中维护一个缓冲区，缓冲区中存储着将要发给从服务器的内容。从服务器在与主服务器出现网络瞬断之后，从服务器会尝试再次与主服务器连接，一旦连接成功，从服务器就会把“希望同步的主服务器ID”和“希望请求的数据的偏移位置（replication offset）”发送出去。主服务器接收到这样的同步请求后，首先会验证主服务器ID是否和自己的ID匹配，其次会检查“请求的偏移位置”是否存在于自己的缓冲区中，如果两者都满足的话，主服务器就会向从服务器发送增量内容。</p><p>增量同步功能，需要服务器端支持全新的PSYNC指令。这个指令，只有在redis-2.8之后才具有。</p><h3 id="【聊聊redis的事务处理】"><a href="#【聊聊redis的事务处理】" class="headerlink" title="【聊聊redis的事务处理】"></a><strong>【聊聊redis的事务处理】</strong></h3><p>众所周知，事务是指“一个完整的动作，要么全部执行，要么什么也没有做”。</p><p>在聊redis事务处理之前，要先和大家介绍四个redis指令，即MULTI、EXEC、DISCARD、WATCH。这四个指令构成了redis事务处理的基础。</p><p>1.MULTI用来组装一个事务；<br>2.EXEC用来执行一个事务；<br>3.DISCARD用来取消一个事务；<br>4.WATCH用来监视一些key，一旦这些key在事务执行之前被改变，则取消事务的执行。</p><p>纸上得来终觉浅，我们来看一个MULTI和EXEC的例子：</p><p>复制代码代码如下:</p><pre><code>redis&gt; MULTI //标记事务开始OKredis&gt; INCR user_id //多条命令按顺序入队QUEUEDredis&gt; INCR user_idQUEUEDredis&gt; INCR user_idQUEUEDredis&gt; PINGQUEUEDredis&gt; EXEC //执行1) (integer) 12) (integer) 23) (integer) 34) PONG</code></pre><p>在上面的例子中，我们看到了QUEUED的字样，这表示我们在用MULTI组装事务时，每一个命令都会进入到内存队列中缓存起来，如果出现QUEUED则表示我们这个命令成功插入了缓存队列，在将来执行EXEC时，这些被QUEUED的命令都会被组装成一个事务来执行。</p><p>对于事务的执行来说，如果redis开启了AOF持久化的话，那么一旦事务被成功执行，事务中的命令就会通过write命令一次性写到磁盘中去，如果在向磁盘中写的过程中恰好出现断电、硬件故障等问题，那么就可能出现只有部分命令进行了AOF持久化，这时AOF文件就会出现不完整的情况，这时，我们可以使用redis-check-aof工具来修复这一问题，这个工具会将AOF文件中不完整的信息移除，确保AOF文件完整可用。</p><p>有关事务，大家经常会遇到的是两类错误：</p><p>1.调用EXEC之前的错误<br>2.调用EXEC之后的错误</p><p>“调用EXEC之前的错误”，有可能是由于语法有误导致的，也可能时由于内存不足导致的。只要出现某个命令无法成功写入缓冲队列的情况，redis都会进行记录，在客户端调用EXEC时，redis会拒绝执行这一事务。（这时2.6.5版本之后的策略。在2.6.5之前的版本中，redis会忽略那些入队失败的命令，只执行那些入队成功的命令）。我们来看一个这样的例子：</p><p>复制代码代码如下:</p><pre><code>127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; haha //一个明显错误的指令(error) ERR unknown command 'haha'127.0.0.1:6379&gt; pingQUEUED127.0.0.1:6379&gt; exec//redis无情的拒绝了事务的执行，原因是“之前出现了错误”(error) EXECABORT Transaction discarded because of previous errors.</code></pre><p>而对于“调用EXEC之后的错误”，redis则采取了完全不同的策略，即redis不会理睬这些错误，而是继续向下执行事务中的其他命令。这是因为，对于应用层面的错误，并不是redis自身需要考虑和处理的问题，所以一个事务中如果某一条命令执行失败，并不会影响接下来的其他命令的执行。我们也来看一个例子：</p><p>复制代码代码如下:</p><pre><code>127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set age 23QUEUED//age不是集合，所以如下是一条明显错误的指令127.0.0.1:6379&gt; sadd age 15 QUEUED127.0.0.1:6379&gt; set age 29QUEUED127.0.0.1:6379&gt; exec //执行事务时，redis不会理睬第2条指令执行错误1) OK2) (error) WRONGTYPE Operation against a key holding the wrong kind of value3) OK127.0.0.1:6379&gt; get age"29" //可以看出第3条指令被成功执行了</code></pre><p>好了，我们来说说最后一个指令“WATCH”，这是一个很好用的指令，它可以帮我们实现类似于“乐观锁”的效果，即CAS（check and set）。</p><p>WATCH本身的作用是“监视key是否被改动过”，而且支持同时监视多个key，只要还没真正触发事务，WATCH都会尽职尽责的监视，一旦发现某个key被修改了，在执行EXEC时就会返回nil，表示事务无法触发。</p><p>复制代码代码如下:</p><pre><code>127.0.0.1:6379&gt; set age 23OK127.0.0.1:6379&gt; watch age //开始监视ageOK127.0.0.1:6379&gt; set age 24 //在EXEC之前，age的值被修改了OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set age 25QUEUED127.0.0.1:6379&gt; get ageQUEUED127.0.0.1:6379&gt; exec //触发EXEC(nil) //事务无法被执行</code></pre><h3 id="【看懂redis配置-–-简介】"><a href="#【看懂redis配置-–-简介】" class="headerlink" title="【看懂redis配置 – 简介】"></a><strong>【看懂redis配置 – 简介】</strong></h3><p>我们可以在启动redis-server时指定应该加载的配置文件，方法如下：</p><p>复制代码代码如下:</p><pre><code>$ ./redis-server /path/to/redis.conf</code></pre><p>接下来，我们就来讲解下redis配置文件的各个配置项的含义，注意，本文是基于redis-2.8.4版本进行讲解的。</p><p>redis官方提供的redis.conf文件，足有700+行，其中100多行为有效配置行，另外的600多行为注释说明。</p><p>在配置文件的开头部分，首先明确了一些度量单位：</p><p>复制代码代码如下:</p><pre><code># 1k =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes</code></pre><p>可以看出，redis配置中对单位的大小写不敏感，1GB、1Gb和1gB都是相同的。由此也说明，redis只支持bytes，不支持bit单位。</p><p>redis支持“主配置文件中引入外部配置文件”，很像C/C++中的include指令，比如：</p><p>复制代码代码如下:</p><pre><code>include /path/to/other.conf</code></pre><p>如果你看过redis的配置文件，会发现还是很有条理的。redis配置文件被分成了几大块区域，它们分别是：</p><p>1.通用（general）<br>2.快照（snapshotting）<br>3.复制（replication）<br>4.安全（security）<br>5.限制（limits)<br>6.追加模式（append only mode)<br>7.LUA脚本（lua scripting)<br>8.慢日志（slow log)<br>9.事件通知（event notification）</p><p>下面我们就来逐一讲解。</p><h3 id="【看懂redis配置-通用】"><a href="#【看懂redis配置-通用】" class="headerlink" title="【看懂redis配置 -通用】"></a><strong>【看懂redis配置 -通用】</strong></h3><p>默认情况下，redis并不是以daemon形式来运行的。通过daemonize配置项可以控制redis的运行形式，如果改为yes，那么redis就会以daemon形式运行：</p><p>复制代码代码如下:</p><pre><code>daemonize no</code></pre><p>当以daemon形式运行时，redis会生成一个pid文件，默认会生成在/var/run/redis.pid。当然，你可以通过pidfile来指定pid文件生成的位置，比如：</p><p>复制代码代码如下:</p><pre><code>pidfile /path/to/redis.pid</code></pre><p>默认情况下，redis会响应本机所有可用网卡的连接请求。当然，redis允许你通过bind配置项来指定要绑定的IP，比如：</p><p>复制代码代码如下:</p><pre><code>bind 192.168.1.2 10.8.4.2</code></pre><p>redis的默认服务端口是6379，你可以通过port配置项来修改。如果端口设置为0的话，redis便不会监听端口了。</p><p>复制代码代码如下:</p><pre><code>port 6379</code></pre><p>有些同学会问“如果redis不监听端口，还怎么与外界通信呢”，其实redis还支持通过unix socket方式来接收请求。可以通过unixsocket配置项来指定unix socket文件的路径，并通过unixsocketperm来指定文件的权限。</p><p>复制代码代码如下:</p><pre><code>unixsocket /tmp/redis.sockunixsocketperm 755</code></pre><p>当一个redis-client一直没有请求发向server端，那么server端有权主动关闭这个连接，可以通过timeout来设置“空闲超时时限”，0表示永不关闭。</p><p>复制代码代码如下:</p><pre><code>timeout 0</code></pre><p>TCP连接保活策略，可以通过tcp-keepalive配置项来进行设置，单位为秒，假如设置为60秒，则server端会每60秒向连接空闲的客户端发起一次ACK请求，以检查客户端是否已经挂掉，对于无响应的客户端则会关闭其连接。所以关闭一个连接最长需要120秒的时间。如果设置为0，则不会进行保活检测。</p><p>复制代码代码如下:</p><pre><code>tcp-keepalive 0</code></pre><p>redis支持通过loglevel配置项设置日志等级，共分四级，即debug、verbose、notice、warning。</p><p>复制代码代码如下:</p><pre><code>loglevel notice</code></pre><p>redis也支持通过logfile配置项来设置日志文件的生成位置。如果设置为空字符串，则redis会将日志输出到标准输出。假如你在daemon情况下将日志设置为输出到标准输出，则日志会被写到/dev/null中。</p><p>复制代码代码如下:</p><pre><code>logfile ""</code></pre><p>如果希望日志打印到syslog中，也很容易，通过syslog-enabled来控制。另外，syslog-ident还可以让你指定syslog里的日志标志，比如：</p><p>复制代码代码如下:</p><pre><code>syslog-ident redis</code></pre><p>而且还支持指定syslog设备，值可以是USER或LOCAL0-LOCAL7。具体可以参考syslog服务本身的用法。</p><p>复制代码代码如下:</p><pre><code>syslog-facility local0</code></pre><p>对于redis来说，可以设置其数据库的总数量，假如你希望一个redis包含16个数据库，那么设置如下：</p><p>复制代码代码如下:</p><pre><code>databases 16</code></pre><p>这16个数据库的编号将是0到15。默认的数据库是编号为0的数据库。用户可以使用select <dbid>来选择相应的数据库。</dbid></p><h3 id="【看懂redis配置-–-快照】"><a href="#【看懂redis配置-–-快照】" class="headerlink" title="【看懂redis配置 – 快照】"></a><strong>【看懂redis配置 – 快照】</strong></h3><p>快照，主要涉及的是redis的RDB持久化相关的配置，我们来一起看一看。</p><p>我们可以用如下的指令来让数据保存到磁盘上，即控制RDB快照功能：</p><p>复制代码代码如下:</p><pre><code>save &lt;seconds&gt; &lt;changes&gt;</code></pre><p>举例来说：</p><p>复制代码代码如下:</p><pre><code>save 900 1 //表示每15分钟且至少有1个key改变，就触发一次持久化save 300 10 //表示每5分钟且至少有10个key改变，就触发一次持久化save 60 10000 //表示每60秒至少有10000个key改变，就触发一次持久化</code></pre><p>如果你想禁用RDB持久化的策略，只要不设置任何save指令就可以，或者给save传入一个空字符串参数也可以达到相同效果，就像这样：</p><p>复制代码代码如下:</p><pre><code>save ""</code></pre><p>如果用户开启了RDB快照功能，那么在redis持久化数据到磁盘时如果出现失败，默认情况下，redis会停止接受所有的写请求。这样做的好处在于可以让用户很明确的知道内存中的数据和磁盘上的数据已经存在不一致了。如果redis不顾这种不一致，一意孤行的继续接收写请求，就可能会引起一些灾难性的后果。</p><p>如果下一次RDB持久化成功，redis会自动恢复接受写请求。</p><p>当然，如果你不在乎这种数据不一致或者有其他的手段发现和控制这种不一致的话，你完全可以关闭这个功能，以便在快照写入失败时，也能确保redis继续接受新的写请求。配置项如下：</p><p>复制代码代码如下:</p><pre><code>stop-writes-on-bgsave-error yes</code></pre><p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</p><p>复制代码代码如下:</p><pre><code>rdbcompression yes</code></pre><p>在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果你希望获取到最大的性能提升，可以关闭此功能。</p><p>复制代码代码如下:</p><pre><code>rdbchecksum yes</code></pre><p>我们还可以设置快照文件的名称，默认是这样配置的：</p><p>复制代码代码如下:</p><pre><code>dbfilename dump.rdb</code></pre><p>最后，你还可以设置这个快照文件存放的路径。比如默认设置就是当前文件夹：</p><p>复制代码代码如下:</p><pre><code>dir ./</code></pre><h3 id="【看懂redis配置-–-复制】"><a href="#【看懂redis配置-–-复制】" class="headerlink" title="【看懂redis配置 – 复制】"></a><strong>【看懂redis配置 – 复制】</strong></h3><p>redis提供了主从同步功能。</p><p>通过slaveof配置项可以控制某一个redis作为另一个redis的从服务器，通过指定IP和端口来定位到主redis的位置。一般情况下，我们会建议用户为从redis设置一个不同频率的快照持久化的周期，或者为从redis配置一个不同的服务端口等等。</p><p>复制代码代码如下:</p><pre><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></pre><p>如果主redis设置了验证密码的话（使用requirepass来设置），则在从redis的配置中要使用masterauth来设置校验密码，否则的话，主redis会拒绝从redis的访问请求。</p><p>复制代码代码如下:</p><pre><code>masterauth &lt;master-password&gt;</code></pre><p>当从redis失去了与主redis的连接，或者主从同步正在进行中时，redis该如何处理外部发来的访问请求呢？这里，从redis可以有两种选择：</p><p>第一种选择：如果slave-serve-stale-data设置为yes（默认），则从redis仍会继续响应客户端的读写请求。</p><p>第二种选择：如果slave-serve-stale-data设置为no，则从redis会对客户端的请求返回“SYNC with master in progress”，当然也有例外，当客户端发来INFO请求和SLAVEOF请求，从redis还是会进行处理。</p><p>你可以控制一个从redis是否可以接受写请求。将数据直接写入从redis，一般只适用于那些生命周期非常短的数据，因为在主从同步时，这些临时数据就会被清理掉。自从redis2.6版本之后，默认从redis为只读。</p><p>复制代码代码如下:</p><pre><code>slave-read-only yes</code></pre><p>只读的从redis并不适合直接暴露给不可信的客户端。为了尽量降低风险，可以使用rename-command指令来将一些可能有破坏力的命令重命名，避免外部直接调用。比如：</p><p>复制代码代码如下:</p><pre><code>rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</code></pre><p>从redis会周期性的向主redis发出PING包。你可以通过repl_ping_slave_period指令来控制其周期。默认是10秒。</p><p>复制代码代码如下:</p><pre><code>repl-ping-slave-period 10</code></pre><p>在主从同步时，可能在这些情况下会有超时发生：</p><p>1.以从redis的角度来看，当有大规模IO传输时。<br>2.以从redis的角度来看，当数据传输或PING时，主redis超时<br>3.以主redis的角度来看，在回复从redis的PING时，从redis超时</p><p>用户可以设置上述超时的时限，不过要确保这个时限比repl-ping-slave-period的值要大，否则每次主redis都会认为从redis超时。</p><p>复制代码代码如下:</p><pre><code>repl-timeout 60</code></pre><p>我们可以控制在主从同步时是否禁用TCP_NODELAY。如果开启TCP_NODELAY，那么主redis会使用更少的TCP包和更少的带宽来向从redis传输数据。但是这可能会增加一些同步的延迟，大概会达到40毫秒左右。如果你关闭了TCP_NODELAY，那么数据同步的延迟时间会降低，但是会消耗更多的带宽。（如果你不了解TCP_NODELAY，可以到这里来科普一下）。</p><p>复制代码代码如下:</p><pre><code>repl-disable-tcp-nodelay no</code></pre><p>我们还可以设置同步队列长度。队列长度（backlog)是主redis中的一个缓冲区，在与从redis断开连接期间，主redis会用这个缓冲区来缓存应该发给从redis的数据。这样的话，当从redis重新连接上之后，就不必重新全量同步数据，只需要同步这部分增量数据即可。</p><p>复制代码代码如下:</p><pre><code>repl-backlog-size 1mb</code></pre><p>如果主redis等了一段时间之后，还是无法连接到从redis，那么缓冲队列中的数据将被清理掉。我们可以设置主redis要等待的时间长度。如果设置为0，则表示永远不清理。默认是1个小时。</p><p>复制代码代码如下:</p><pre><code>repl-backlog-ttl 3600</code></pre><p>我们可以给众多的从redis设置优先级，在主redis持续工作不正常的情况，优先级高的从redis将会升级为主redis。而编号越小，优先级越高。比如一个主redis有三个从redis，优先级编号分别为10、100、25，那么编号为10的从redis将会被首先选中升级为主redis。当优先级被设置为0时，这个从redis将永远也不会被选中。默认的优先级为100。</p><p>复制代码代码如下:</p><pre><code>slave-priority 100</code></pre><p>假如主redis发现有超过M个从redis的连接延时大于N秒，那么主redis就停止接受外来的写请求。这是因为从redis一般会每秒钟都向主redis发出PING，而主redis会记录每一个从redis最近一次发来PING的时间点，所以主redis能够了解每一个从redis的运行情况。</p><p>复制代码代码如下:</p><pre><code>min-slaves-to-write 3min-slaves-max-lag 10</code></pre><p>上面这个例子表示，假如有大于等于3个从redis的连接延迟大于10秒，那么主redis就不再接受外部的写请求。上述两个配置中有一个被置为0，则这个特性将被关闭。默认情况下min-slaves-to-write为0，而min-slaves-max-lag为10。</p><h3 id="【看懂redis配置-–-安全】"><a href="#【看懂redis配置-–-安全】" class="headerlink" title="【看懂redis配置 – 安全】"></a><strong>【看懂redis配置 – 安全】</strong></h3><p>我们可以要求redis客户端在向redis-server发送请求之前，先进行密码验证。当你的redis-server处于一个不太可信的网络环境中时，相信你会用上这个功能。由于redis性能非常高，所以每秒钟可以完成多达15万次的密码尝试，所以你最好设置一个足够复杂的密码，否则很容易被黑客破解。</p><p>复制代码代码如下:</p><pre><code>requirepass zhimakaimen</code></pre><p>这里我们通过requirepass将密码设置成“芝麻开门”。</p><p>redis允许我们对redis指令进行更名，比如将一些比较危险的命令改个名字，避免被误执行。比如可以把CONFIG命令改成一个很复杂的名字，这样可以避免外部的调用，同时还可以满足内部调用的需要：</p><p>复制代码代码如下:</p><pre><code>rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c89</code></pre><p>我们甚至可以禁用掉CONFIG命令，那就是把CONFIG的名字改成一个空字符串：</p><p>复制代码代码如下:</p><pre><code>rename-command CONFIG ""</code></pre><p>但需要注意的是，如果你使用AOF方式进行数据持久化，或者需要与从redis进行通信，那么更改指令的名字可能会引起一些问题。</p><h3 id="【看懂redis配置-限制】"><a href="#【看懂redis配置-限制】" class="headerlink" title="【看懂redis配置 -限制】"></a><strong>【看懂redis配置 -限制】</strong></h3><p>我们可以设置redis同时可以与多少个客户端进行连接。默认情况下为10000个客户端。当你无法设置进程文件句柄限制时，redis会设置为当前的文件句柄限制值减去32，因为redis会为自身内部处理逻辑留一些句柄出来。</p><p>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p><p>复制代码代码如下:</p><pre><code>maxclients 10000</code></pre><p>我们甚至可以设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。</p><p>如果redis无法根据移除规则来移除内存中的数据，或者我们设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。但是对于无内存申请的指令，仍然会正常响应，比如GET等。</p><p>复制代码代码如下:</p><pre><code>maxmemory &lt;bytes&gt;</code></pre><p>需要注意的一点是，如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</p><p>对于内存移除规则来说，redis提供了多达6种的移除规则。他们是：</p><pre><code>1.volatile-lru：使用LRU算法移除过期集合中的key2.allkeys-lru：使用LRU算法移除key3.volatile-random：在过期集合中移除随机的key4.allkeys-random：移除随机的key5.volatile-ttl：移除那些TTL值最小的key，即那些最近才过期的key。6.noeviction：不进行移除。针对写操作，只是返回错误信息。</code></pre><p>无论使用上述哪一种移除规则，如果没有合适的key可以移除的话，redis都会针对写请求返回错误信息。</p><p>复制代码代码如下:</p><pre><code>maxmemory-policy volatile-lru</code></pre><p>LRU算法和最小TTL算法都并非是精确的算法，而是估算值。所以你可以设置样本的大小。假如redis默认会检查三个key并选择其中LRU的那个，那么你可以改变这个key样本的数量。</p><p>复制代码代码如下:</p><pre><code>maxmemory-samples 3</code></pre><p>最后，我们补充一个信息，那就是到目前版本（2.8.4）为止，redis支持的写指令包括了如下这些：</p><p>复制代码代码如下:</p><pre><code>set setnx setex appendincr decr rpush lpush rpushx lpushx linsert lset rpoplpush saddsinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrbyzunionstore zinterstore hset hsetnx hmset hincrby incrby decrbygetset mset msetnx exec sort</code></pre><h3 id="【看懂redis配置-–-追加模式】"><a href="#【看懂redis配置-–-追加模式】" class="headerlink" title="【看懂redis配置 – 追加模式】"></a><strong>【看懂redis配置 – 追加模式】</strong></h3><p>默认情况下，redis会异步的将数据持久化到磁盘。这种模式在大部分应用程序中已被验证是很有效的，但是在一些问题发生时，比如断电，则这种机制可能会导致数分钟的写请求丢失。</p><p>如博文上半部分中介绍的，追加文件（Append Only File）是一种更好的保持数据一致性的方式。即使当服务器断电时，也仅会有1秒钟的写请求丢失，当redis进程出现问题且操作系统运行正常时，甚至只会丢失一条写请求。</p><p>我们建议大家，AOF机制和RDB机制可以同时使用，不会有任何冲突。对于如何保持数据一致性的讨论，请参见<a href="http://redis.io/topics/persistence" target="_blank" rel="noopener">本文</a>。</p><p>复制代码代码如下:</p><pre><code>appendonly no</code></pre><p>我们还可以设置aof文件的名称：</p><p>复制代码代码如下:</p><pre><code>appendfilename "appendonly.aof"</code></pre><p>fsync()调用，用来告诉操作系统立即将缓存的指令写入磁盘。一些操作系统会“立即”进行，而另外一些操作系统则会“尽快”进行。</p><p>redis支持三种不同的模式：</p><p>1.no：不调用fsync()。而是让操作系统自行决定sync的时间。这种模式下，redis的性能会最快。<br>2.always：在每次写请求后都调用fsync()。这种模式下，redis会相对较慢，但数据最安全。<br>3.everysec：每秒钟调用一次fsync()。这是性能和安全的折衷。</p><p>默认情况下为everysec。有关数据一致性的揭秘，可以参考<a href="http://antirez.com/post/redis-persistence-demystified.html" target="_blank" rel="noopener">本文</a>。</p><p>复制代码代码如下:</p><pre><code>appendfsync everysec</code></pre><p>当fsync方式设置为always或everysec时，如果后台持久化进程需要执行一个很大的磁盘IO操作，那么redis可能会在fsync()调用时卡住。目前尚未修复这个问题，这是因为即使我们在另一个新的线程中去执行fsync()，也会阻塞住同步写调用。</p><p>为了缓解这个问题，我们可以使用下面的配置项，这样的话，当BGSAVE或BGWRITEAOF运行时，fsync()在主进程中的调用会被阻止。这意味着当另一路进程正在对AOF文件进行重构时，redis的持久化功能就失效了，就好像我们设置了“appendsync none”一样。如果你的redis有时延问题，那么请将下面的选项设置为yes。否则请保持no，因为这是保证数据完整性的最安全的选择。</p><p>复制代码代码如下:</p><pre><code>no-appendfsync-on-rewrite no</code></pre><p>我们允许redis自动重写aof。当aof增长到一定规模时，redis会隐式调用BGREWRITEAOF来重写log文件，以缩减文件体积。</p><p>redis是这样工作的：redis会记录上次重写时的aof大小。假如redis自启动至今还没有进行过重写，那么启动时aof文件的大小会被作为基准值。这个基准值会和当前的aof大小进行比较。如果当前aof大小超出所设置的增长比例，则会触发重写。另外，你还需要设置一个最小大小，是为了防止在aof很小时就触发重写。</p><p>复制代码代码如下:</p><pre><code>auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb</code></pre><p>如果设置auto-aof-rewrite-percentage为0，则会关闭此重写功能。</p><h3 id="【看懂redis配置-–-LUA脚本】"><a href="#【看懂redis配置-–-LUA脚本】" class="headerlink" title="【看懂redis配置 – LUA脚本】"></a><strong>【看懂redis配置 – LUA脚本】</strong></h3><p>lua脚本的最大运行时间是需要被严格限制的，要注意单位是毫秒：</p><p>复制代码代码如下:</p><pre><code>lua-time-limit 5000</code></pre><p>如果此值设置为0或负数，则既不会有报错也不会有时间限制。</p><h3 id="【看懂redis配置-–-慢日志】"><a href="#【看懂redis配置-–-慢日志】" class="headerlink" title="【看懂redis配置 – 慢日志】"></a><strong>【看懂redis配置 – 慢日志】</strong></h3><p>redis慢日志是指一个系统进行日志查询超过了指定的时长。这个时长不包括IO操作，比如与客户端的交互、发送响应内容等，而仅包括实际执行查询命令的时间。</p><p>针对慢日志，你可以设置两个参数，一个是执行时长，单位是微秒，另一个是慢日志的长度。当一个新的命令被写入日志时，最老的一条会从命令日志队列中被移除。</p><p>单位是微秒，即1000000表示一秒。负数则会禁用慢日志功能，而0则表示强制记录每一个命令。</p><p>复制代码代码如下:</p><pre><code>slowlog-log-slower-than 10000</code></pre><p>慢日志最大长度，可以随便填写数值，没有上限，但要注意它会消耗内存。你可以使用SLOWLOG RESET来重设这个值。</p><p>复制代码代码如下:</p><pre><code>slowlog-max-len 128</code></pre><h3 id="【教你看懂redis配置-–-事件通知】"><a href="#【教你看懂redis配置-–-事件通知】" class="headerlink" title="【教你看懂redis配置 – 事件通知】"></a><strong>【教你看懂redis配置 – 事件通知】</strong></h3><p>redis可以向客户端通知某些事件的发生。这个特性的具体解释可以参见<a href="http://redis.io/topics/keyspace-events" target="_blank" rel="noopener">本文</a>。</p><h3 id="【教你看懂redis配置-–-高级配置】"><a href="#【教你看懂redis配置-–-高级配置】" class="headerlink" title="【教你看懂redis配置 – 高级配置】"></a><strong>【教你看懂redis配置 – 高级配置】</strong></h3><p>有关哈希数据结构的一些配置项：</p><p>复制代码代码如下:</p><pre><code>hash-max-ziplist-entries 512hash-max-ziplist-value 64</code></pre><p>有关列表数据结构的一些配置项：</p><p>复制代码代码如下:</p><pre><code>list-max-ziplist-entries 512list-max-ziplist-value 64</code></pre><p>有关集合数据结构的配置项：</p><p>复制代码代码如下:</p><pre><code>set-max-intset-entries 512</code></pre><p>有关有序集合数据结构的配置项：</p><p>复制代码代码如下:</p><pre><code>zset-max-ziplist-entries 128zset-max-ziplist-value 64</code></pre><p>关于是否需要再哈希的配置项：</p><p>复制代码代码如下:</p><pre><code>activerehashing yes</code></pre><p>关于客户端输出缓冲的控制项：</p><p>复制代码代码如下:</p><pre><code>client-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60</code></pre><p>有关频率的配置项：</p><p>复制代码代码如下:</p><pre><code>hz 10</code></pre><p>有关重写aof的配置项</p><p>复制代码代码如下:</p><pre><code>aof-rewrite-incremental-fsync yes</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis安装与配置</title>
      <link href="/posts/blog-program01.html"/>
      <url>/posts/blog-program01.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h1><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h1 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h1><ul><li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><p><strong>Redis与其他key-value存储有什么不同？</strong><br>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。</p><p>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。</p><h1 id="Redis的安装和部署"><a href="#Redis的安装和部署" class="headerlink" title="Redis的安装和部署"></a>Redis的安装和部署</h1><h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p>1、Redis的数据类型：</p><p>　　字符串、列表（lists）、集合（sets）、有序集合（sorts sets）、哈希表（hashs）</p><p>2、Redis和memcache相比的独特之处：</p><p>　　（1）redis可以用来做存储（storge）、而memcache是来做缓存（cache）。这个特点主要是因为其有“持久化”功能</p><p>　　（2）存储的数据有“结构”，对于memcache来说，存储的数据，只有一种类型——“字符串”，而redis则可以存储字符串、链表、集合、有序集合、哈序结构</p><p>3、持久化的两种方式：</p><p>　　Redis将数据存储于内存中，或被配置为使用虚拟内存。</p><p>　　实现数据持久化的两种方式：（1）使用截图的方式，将内存中的数据不断写入磁盘（性能高，但可能会引起一定程度的数据丢失）</p><p>　　　　　　　　　　　　　　　（2）使用类似mysql的方式，记录每次更新的日志</p><p>4、Redis的主从同步：对提高读取性能非常有益</p><p>5、Redis服务端的默认端口是6379</p><h3 id="Linux下安装Redis"><a href="#Linux下安装Redis" class="headerlink" title="Linux下安装Redis"></a>Linux下安装Redis</h3><p>1、先到Redis官网(redis.io)下载redis安装包 </p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-2ecb3feb9e901ed2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>2、将其下载到我的/lamp目录下</p><p>3、解压并进入其目录</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-4ca5b66a7f66c982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>4、编译源程序</p><p>　　make </p><p>　　cd src</p><p>　　make install PREFIX=/usr/local/redis</p><p>5、将配置文件移动到redis目录 </p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-29e9773b382d4062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>6、启动redis服务</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-74252ac88aec7fb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>7、默认情况，Redis不是在后台运行，我们需要把redis放在后台运行</p><p>vim /usr/local/redis/etc/redis.conf </p><p>　　将daemonize的值改为yes</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-454aa911b9af288a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>8、客户端连接</p><p>　　/usr/local/redis/bin/redis-cli </p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-71e41c5b55a58858.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><p>9、停止redis实例</p><p>　　/usr/local/redis/bin/redis-cli shutdown</p><p>　　或者</p><p>　　pkill redis-server</p><p>10、让redis开机自启</p><p>　　vim /etc/rc.local</p><p>　　加入</p><p>　　/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis-conf</p><p>11、接下来我们看看/usr/local/redis/bin目录下的几个文件时什么</p><p>　　redis-benchmark：redis性能测试工具</p><p>　　redis-check-aof：检查aof日志的工具</p><p>　　redis-check-dump：检查rdb日志的工具</p><p>　　redis-cli：连接用的客户端</p><p>　　redis-server：redis服务进程</p><h3 id="Ubuntu下安装"><a href="#Ubuntu下安装" class="headerlink" title="Ubuntu下安装"></a>Ubuntu下安装</h3><pre><code> sudo apt-get install redis-server</code></pre><h3 id="Redis的配置"><a href="#Redis的配置" class="headerlink" title="Redis的配置"></a>Redis的配置</h3><p>daemonize：如需要在后台运行，把该项的值改为yes</p><p>　　pdifile：把pid文件放在/var/run/redis.pid，可以配置到其他地址</p><p>　　bind：指定redis只接收来自该IP的请求，如果不设置，那么将处理所有请求，在生产环节中最好设置该项</p><p>　　port：监听端口，默认为6379</p><p>　　timeout：设置客户端连接时的超时时间，单位为秒</p><p>　　loglevel：等级分为4级，debug，revbose，notice和warning。生产环境下一般开启notice</p><p>　　logfile：配置log文件地址，默认使用标准输出，即打印在命令行终端的端口上</p><p>　　database：设置数据库的个数，默认使用的数据库是0</p><p>　　save：设置redis进行数据库镜像的频率</p><p>　　rdbcompression：在进行镜像备份时，是否进行压缩</p><p>　　dbfilename：镜像备份文件的文件名</p><p>　　dir：数据库镜像备份的文件放置的路径</p><p>　　slaveof：设置该数据库为其他数据库的从数据库</p><p>　　masterauth：当主数据库连接需要密码验证时，在这里设定</p><p>　　requirepass：设置客户端连接后进行任何其他指定前需要使用的密码</p><p>　　maxclients：限制同时连接的客户端数量</p><p>　　maxmemory：设置redis能够使用的最大内存</p><p>　　appendonly：开启appendonly模式后，redis会把每一次所接收到的写操作都追加到appendonly.aof文件中，当redis重新启动时，会从该文件恢复出之前的状态</p><p>　　appendfsync：设置appendonly.aof文件进行同步的频率</p><p>　　vm_enabled：是否开启虚拟内存支持</p><p>　　vm_swap_file：设置虚拟内存的交换文件的路径</p><p>　　vm_max_momery：设置开启虚拟内存后，redis将使用的最大物理内存的大小，默认为0</p><p>　　vm_page_size：设置虚拟内存页的大小</p><p>　　vm_pages：设置交换文件的总的page数量</p><p>　　vm_max_thrrads：设置vm IO同时使用的线程数量</p><h3 id="安装目录内容详解"><a href="#安装目录内容详解" class="headerlink" title="安装目录内容详解"></a>安装目录内容详解</h3><p>查看redis安装目录(Yum安装)：</p><pre><code>rpm -ql redis</code></pre><p>之后系统打印输出下面28个文件记录：</p><pre><code>/etc/logrotate.d/redis /etc/redis-sentinel.conf /etc/redis.conf /etc/systemd/system/redis-sentinel.service.d /etc/systemd/system/redis-sentinel.service.d/limit.conf /etc/systemd/system/redis.service.d /etc/systemd/system/redis.service.d/limit.conf /usr/bin/redis-benchmark /usr/bin/redis-check-aof /usr/bin/redis-check-rdb /usr/bin/redis-cli /usr/bin/redis-sentinel /usr/bin/redis-server /usr/bin/redis-shutdown /usr/lib/systemd/system/redis-sentinel.service /usr/lib/systemd/system/redis.service /usr/lib/tmpfiles.d/redis.conf /usr/share/doc/redis-3.2.3 /usr/share/doc/redis-3.2.3/00-RELEASENOTES /usr/share/doc/redis-3.2.3/BUGS /usr/share/doc/redis-3.2.3/CONTRIBUTING /usr/share/doc/redis-3.2.3/MANIFESTO /usr/share/doc/redis-3.2.3/README.md /usr/share/licenses/redis-3.2.3 /usr/share/licenses/redis-3.2.3/COPYING /var/lib/redis /var/log/redis /var/run/redis</code></pre><p>文件记录含义解析：</p><pre><code>/etc/logrotate.d/redis</code></pre><blockquote><p>/etc/logrotate.d/ ： 用来存储文件日志文件的轮循(切割转储)设置，（logrotate 程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件，我们把它叫做“转储”。我们可以根据日志文件的大小，也可以根据其天数来转储，这个过程一般通过 cron 程序来执行。<br>logrotate 程序还可以用于压缩日志文件，以及发送日志到指定的E-mail 。）<br>/etc/logrotate.d/文件夹下的redis文件，也就是设置了redis的日志文件的轮循参数配置文件。</p></blockquote><pre><code>[root@aidev02 logrotate.d]# cat redis /var/log/redis/*.log { weekly rotate 10 copytruncate delaycompress compress notifempty missingok } 解析 : weekly : 指定所有的日志文件每周转储一次。 rotate 10 : 指定转储文件保存10份 copytruncate ：用于还在打开中的日志文件，把当前日志备份并截断. delaycompress：和 compress 一起使用时，转储的日志文件到下一次转储时才压缩。 compress：指定压缩转储文件,通过gzip 压缩转储以后的日志，如果不需要压缩，添加注释就可以了 #compress。 notifempty：如果是空文件的话，不转储 missingok：如果日志文件不存在,继续处理下一个文件而不产生报错信息.</code></pre><pre><code>/etc/redis-sentinel.conf</code></pre><blockquote><p>Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务.</p><blockquote><p>监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。<br>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。<br>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。<br>Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。</p></blockquote></blockquote><pre><code>/etc/redis.conf</code></pre><blockquote><p>redis的配置信息文件，里面包含redis的host/ip设置、集群设置、日志设置、数据持久化配置等信息。<br>可以通过命令redis-server redis.conf 指定redis配置来启动redis。</p></blockquote><pre><code>/etc/systemd/system/redis-sentinel.service.d</code></pre><blockquote><p>redis-sentinel.service.d是用来存储redis-sentinel在系统服务中相关设置的文件夹。<br>Systemd 是 Linux 系统中最新的初始化系统（init），它主要的设计目标是克服 sysvinit 固有的缺点，提高系统的启动速度Systemd 的很多概念来源于苹果 Mac OS 操作系统上的 launchd。<br>systemd单元文件可以从两个地方加载，优先级从低到高分别是：/usr/lib/systemd/system/: 软件包安装的单元，/etc/systemd/system/ 系统管理员安装的单元。<br>当systemd运行在用户模式下时，使用的加载路径是完全不同的。</p></blockquote><pre><code>/etc/systemd/system/redis-sentinel.service.d/limit.conf</code></pre><blockquote><p>limit.conf 文件是 Linux PAM（插入式认证模块，Pluggable Authentication Modules）中 pam_limits.so 的配置文件，而且只针对于单个会话。<br>cat lomit.conf<br>—– #If you need to change max open file limit. for example, when you change maxclient in configuration, you can change the LimitNOFILE value below, see “man systemd.exec” for information<br>[Service]<br>LimitNOFILE=10240<br>Group=groupName </p></blockquote><pre><code>/etc/systemd/system/redis.service.d</code></pre><blockquote><p>redis.service.d是用来存储redis在系统服务中相关设置的文件夹。</p></blockquote><pre><code>/etc/systemd/system/redis.service.d/limit.conf</code></pre><blockquote><p>和上面/etc/systemd/system/redis-sentinel.service.d/limit.conf配置一样。</p></blockquote><pre><code>/usr/bin/redis-benchmark</code></pre><blockquote><p>redis-benchmark为Redis性能测试工具。 </p><blockquote><p>/usr/bin存放的是一些用户命令， 是你在后期安装的一些软件的运行脚本。<br>/usr/sbin 放置一些用户安装的系统管理的必备程式.<br>/bin,/sbin目录是在系统启动后挂载到根文件系统中的。<br>系统级的组件放在/bin、/lib；<br>根用户才能访问的放在/sbin；<br>系统repository提供的应用程序放在/usr/bin、/usr/lib；<br>用户自己编译的放在/usr/local/XXX。</p></blockquote></blockquote><pre><code>/usr/bin/redis-check-aof</code></pre><p>数据持久化时，用于修复出问题的AOF文件</p><pre><code>/usr/bin/redis-check-rdb</code></pre><p>用于修复出问题的dump.rdb文件</p><pre><code>/usr/bin/redis-cli</code></pre><p>redis的客户端</p><pre><code>/usr/bin/redis-sentinel</code></pre><p>用于集群管理</p><pre><code>/usr/bin/redis-server</code></pre><p>redis的服务端</p><pre><code>/usr/bin/redis-shutdown</code></pre><p>停止所有客户端，进行保存，清空所有追加仅文件(如果AOF启用)，并退出服务器。<br>错误时答复简单字符串。成功时不返回任何结果，因为服务器退出并关闭连接。</p><pre><code>/usr/lib/systemd/system/redis-sentinel.service</code></pre><blockquote><p>/usr/lib/ 程序或子系统的不变的数据文件，包括一些site-wide配置文件.名字lib来源于库(library); 编程的原始库存在/usr/lib 里.<br>/usr/lib/systemd/system/ 文件夹存储 创建单位用的系统配置文件。<br>redis-sentinel.service系统服务配置文件。<br>如下：<br>[Unit]<br>Description=Redis Sentinel<br>After=network.target<br>[Service]<br>ExecStart=/usr/bin/redis-sentinel /etc/redis-sentinel.conf –daemonize no<br>ExecStop=/usr/bin/redis-shutdown redis-sentinel<br>User=redis<br>Group=redis<br>[Install]<br>WantedBy=multi-user.target</p></blockquote><pre><code>/usr/lib/systemd/system/redis.service</code></pre><blockquote><p>同上：<br>[Unit]<br>Description=Redis persistent key-value database<br>After=network.target<br>[Service]<br>ExecStart=/usr/bin/redis-server /etc/redis.conf –daemonize no<br>ExecStop=/usr/bin/redis-shutdown<br>User=redis<br>Group=redis<br>[Install]<br>WantedBy=multi-user.target</p></blockquote><pre><code>/usr/lib/tmpfiles.d/redis.conf </code></pre><blockquote><p>/etc/tmpfiles.d/<em>.conf<br>/run/tmpfiles.d/</em>.conf<br>/usr/lib/tmpfiles.d/*.conf<br>systemd-tmpfiles 使用上述三个目录中的配置文件 来决定如何创建、删除、清理 易变文件与临时文件以及易变目录与临时目录。<br>这些文件与目录通常位于 /run, /var/run(指向 /run 的软连接), /tmp, /var/tmp, /sys, /proc, /var 目录中。<br>系统的守护进程经常需要在 /run 目录下拥有专属的运行时目录，以存放套接字或管道之类的文件<br>.#redis runtime directory<br>d /run/redis 0755 redis redis - </p></blockquote><blockquote><blockquote><p>配置文件的格式是每行对应一个路径，包含下面字段：具体可参考[ <a href="http://www.jinbuguo.com/systemd/tmpfiles.d.html" target="_blank" rel="noopener">http://www.jinbuguo.com/systemd/tmpfiles.d.html</a> ]<br>| 类型 | 路径 | 权限 | 属主 | 属组 | 寿命 | 参数|<br>|Type | Path | Mode | UID | GID | Age | Argument|<br>d /run/user 0755 root root 10d -<br>L /tmp/foobar - - - - /dev/null</p></blockquote></blockquote><pre><code>/usr/share/doc/redis-3.2.3</code></pre><p>/usr/share/放置共享文件的地方</p><pre><code>/usr/share/doc/redis-3.2.3/00-RELEASENOTES</code></pre><p>版本说明</p><pre><code>/usr/share/doc/redis-3.2.3/BUGS</code></pre><p>bugs</p><pre><code>/usr/share/doc/redis-3.2.3/CONTRIBUTING</code></pre><p>github上code捐献信息</p><pre><code>/usr/share/doc/redis-3.2.3/MANIFESTO</code></pre><p>声明</p><pre><code>/usr/share/doc/redis-3.2.3/README.md</code></pre><p>readme文件</p><pre><code>/usr/share/licenses/redis-3.2.3</code></pre><p>存放redis的许可文件</p><pre><code>/usr/share/licenses/redis-3.2.3/COPYING</code></pre><p>redis的许可文件COPYING</p><pre><code>/var/lib/redis</code></pre><p>/var/lib文件夹 存储 系统正常运行时要改变的文件</p><pre><code>指定redis本地数据库存放目录</code></pre><p>[root@aidev02 redis-3.2.3]# cd /var/lib/redis<br>[root@aidev02 redis]# ls<br>dump.rdb</p><pre><code>/var/log/redis</code></pre><p>/var/log 文件夹 ：各种程序的Log文件，特别是login (/var/log/wtmp log所有到系统的登录和注销) 和syslog (/var/log/messages 里存储所有核心和系统程序信息. /var/log 里的文件经常不确定地增长，应该定期清除.</p><p>指定redis本地日志存放目录</p><pre><code>/var/run/redis</code></pre><p>/var/run/文件夹 ： 保存到下次引导前有效的关于系统的信息文件.例如， /var/run/utmp 包含当前登录的用户的信息.</p><p>指定redis引导信息的存放目录</p><h1 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h1><pre><code># redis 配置文件示例# 当你需要为某个配置项指定内存大小的时候，必须要带上单位，# 通常的格式就是 1k 5gb 4m 等酱紫：## 1k  =&gt; 1000 bytes# 1kb =&gt; 1024 bytes# 1m  =&gt; 1000000 bytes# 1mb =&gt; 1024*1024 bytes# 1g  =&gt; 1000000000 bytes# 1gb =&gt; 1024*1024*1024 bytes## 单位是不区分大小写的，你写 1K 5GB 4M 也行################################## INCLUDES #################################### 假如说你有一个可用于所有的 redis server 的标准配置模板，# 但针对某些 server 又需要一些个性化的设置，# 你可以使用 include 来包含一些其他的配置文件，这对你来说是非常有用的。## 但是要注意哦，include 是不能被 config rewrite 命令改写的# 由于 redis 总是以最后的加工线作为一个配置指令值，所以你最好是把 include 放在这个文件的最前面，# 以避免在运行时覆盖配置的改变，相反，你就把它放在后面（外国人真啰嗦）。## include /path/to/local.conf# include /path/to/other.conf################################ 常用 ###################################### 默认情况下 redis 不是作为守护进程运行的，如果你想让它在后台运行，你就把它改成 yes。# 当redis作为守护进程运行的时候，它会写一个 pid 到 /var/run/redis.pid 文件里面。daemonize no# 当redis作为守护进程运行的时候，它会把 pid 默认写到 /var/run/redis.pid 文件里面，# 但是你可以在这里自己制定它的文件位置。pidfile /var/run/redis.pid# 监听端口号，默认为 6379，如果你设为 0 ，redis 将不在 socket 上监听任何客户端连接。port 6379# TCP 监听的最大容纳数量## 在高并发的环境下，你需要把这个值调高以避免客户端连接缓慢的问题。# Linux 内核会一声不响的把这个值缩小成 /proc/sys/net/core/somaxconn 对应的值，# 所以你要修改这两个值才能达到你的预期。tcp-backlog 511# 默认情况下，redis 在 server 上所有有效的网络接口上监听客户端连接。# 你如果只想让它在一个网络接口上监听，那你就绑定一个IP或者多个IP。## 示例，多个IP用空格隔开:## bind 192.168.1.100 10.0.0.1# bind 127.0.0.1# 指定 unix socket 的路径。## unixsocket /tmp/redis.sock# unixsocketperm 755# 指定在一个 client 空闲多少秒之后关闭连接（0 就是不管它）timeout 0# tcp 心跳包。## 如果设置为非零，则在与客户端缺乏通讯的时候使用 SO_KEEPALIVE 发送 tcp acks 给客户端。# 这个之所有有用，主要由两个原因：## 1) 防止死的 peers# 2) Take the connection alive from the point of view of network#    equipment in the middle.## On Linux, the specified value (in seconds) is the period used to send ACKs.# Note that to close the connection the double of the time is needed.# On other kernels the period depends on the kernel configuration.## A reasonable value for this option is 60 seconds.# 推荐一个合理的值就是60秒tcp-keepalive 0# 定义日志级别。# 可以是下面的这些值：# debug (适用于开发或测试阶段)# verbose (many rarely useful info, but not a mess like the debug level)# notice (适用于生产环境)# warning (仅仅一些重要的消息被记录)loglevel notice# 指定日志文件的位置logfile ""# 要想把日志记录到系统日志，就把它改成 yes，# 也可以可选择性的更新其他的syslog 参数以达到你的要求# syslog-enabled no# 设置 syslog 的 identity。# syslog-ident redis# 设置 syslog 的 facility，必须是 USER 或者是 LOCAL0-LOCAL7 之间的值。# syslog-facility local0# 设置数据库的数目。# 默认数据库是 DB 0，你可以在每个连接上使用 select &lt;dbid&gt; 命令选择一个不同的数据库，# 但是 dbid 必须是一个介于 0 到 databasees - 1 之间的值databases 16################################ 快照 ################################## 存 DB 到磁盘：##   格式：save &lt;间隔时间（秒）&gt; &lt;写入次数&gt;##   根据给定的时间间隔和写入次数将数据保存到磁盘##   下面的例子的意思是：#   900 秒内如果至少有 1 个 key 的值变化，则保存#   300 秒内如果至少有 10 个 key 的值变化，则保存#   60 秒内如果至少有 10000 个 key 的值变化，则保存#　　#   注意：你可以注释掉所有的 save 行来停用保存功能。#   也可以直接一个空字符串来实现停用：#   save ""save 900 1save 300 10save 60 10000# 默认情况下，如果 redis 最后一次的后台保存失败，redis 将停止接受写操作，# 这样以一种强硬的方式让用户知道数据不能正确的持久化到磁盘，# 否则就会没人注意到灾难的发生。## 如果后台保存进程重新启动工作了，redis 也将自动的允许写操作。## 然而你要是安装了靠谱的监控，你可能不希望 redis 这样做，那你就改成 no 好了。stop-writes-on-bgsave-error yes# 是否在 dump .rdb 数据库的时候使用 LZF 压缩字符串# 默认都设为 yes# 如果你希望保存子进程节省点 cpu ，你就设置它为 no ，# 不过这个数据集可能就会比较大rdbcompression yes# 是否校验rdb文件rdbchecksum yes# 设置 dump 的文件位置dbfilename dump.rdb# 工作目录# 例如上面的 dbfilename 只指定了文件名，# 但是它会写入到这个目录下。这个配置项一定是个目录，而不能是文件名。dir ./################################# 主从复制 ################################## 主从复制。使用 slaveof 来让一个 redis 实例成为另一个reids 实例的副本。# 注意这个只需要在 slave 上配置。## slaveof &lt;masterip&gt; &lt;masterport&gt;# 如果 master 需要密码认证，就在这里设置# masterauth &lt;master-password&gt;# 当一个 slave 与 master 失去联系，或者复制正在进行的时候，# slave 可能会有两种表现：## 1) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，#    或者数据可能是空的在第一次同步的时候## 2) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，#    slave 都将返回一个 "SYNC with master in progress" 的错误，#slave-serve-stale-data yes# 你可以配置一个 slave 实体是否接受写入操作。# 通过写入操作来存储一些短暂的数据对于一个 slave 实例来说可能是有用的，# 因为相对从 master 重新同步数而言，据数据写入到 slave 会更容易被删除。# 但是如果客户端因为一个错误的配置写入，也可能会导致一些问题。## 从 redis 2.6 版起，默认 slaves 都是只读的。## Note: read only slaves are not designed to be exposed to untrusted clients# on the internet. It's just a protection layer against misuse of the instance.# Still a read only slave exports by default all the administrative commands# such as CONFIG, DEBUG, and so forth. To a limited extent you can improve# security of read only slaves using 'rename-command' to shadow all the# administrative / dangerous commands.# 注意：只读的 slaves 没有被设计成在 internet 上暴露给不受信任的客户端。# 它仅仅是一个针对误用实例的一个保护层。slave-read-only yes# Slaves 在一个预定义的时间间隔内发送 ping 命令到 server 。# 你可以改变这个时间间隔。默认为 10 秒。## repl-ping-slave-period 10# The following option sets the replication timeout for:# 设置主从复制过期时间## 1) Bulk transfer I/O during SYNC, from the point of view of slave.# 2) Master timeout from the point of view of slaves (data, pings).# 3) Slave timeout from the point of view of masters (REPLCONF ACK pings).## It is important to make sure that this value is greater than the value# specified for repl-ping-slave-period otherwise a timeout will be detected# every time there is low traffic between the master and the slave.# 这个值一定要比 repl-ping-slave-period 大## repl-timeout 60# Disable TCP_NODELAY on the slave socket after SYNC?## If you select "yes" Redis will use a smaller number of TCP packets and# less bandwidth to send data to slaves. But this can add a delay for# the data to appear on the slave side, up to 40 milliseconds with# Linux kernels using a default configuration.## If you select "no" the delay for data to appear on the slave side will# be reduced but more bandwidth will be used for replication.## By default we optimize for low latency, but in very high traffic conditions# or when the master and slaves are many hops away, turning this to "yes" may# be a good idea.repl-disable-tcp-nodelay no# 设置主从复制容量大小。这个 backlog 是一个用来在 slaves 被断开连接时# 存放 slave 数据的 buffer，所以当一个 slave 想要重新连接，通常不希望全部重新同步，# 只是部分同步就够了，仅仅传递 slave 在断开连接时丢失的这部分数据。## The biggest the replication backlog, the longer the time the slave can be# disconnected and later be able to perform a partial resynchronization.# 这个值越大，salve 可以断开连接的时间就越长。## The backlog is only allocated once there is at least a slave connected.## repl-backlog-size 1mb# After a master has no longer connected slaves for some time, the backlog# will be freed. The following option configures the amount of seconds that# need to elapse, starting from the time the last slave disconnected, for# the backlog buffer to be freed.# 在某些时候，master 不再连接 slaves，backlog 将被释放。## A value of 0 means to never release the backlog.# 如果设置为 0 ，意味着绝不释放 backlog 。## repl-backlog-ttl 3600# 当 master 不能正常工作的时候，Redis Sentinel 会从 slaves 中选出一个新的 master，# 这个值越小，就越会被优先选中，但是如果是 0 ， 那是意味着这个 slave 不可能被选中。## 默认优先级为 100。slave-priority 100# It is possible for a master to stop accepting writes if there are less than# N slaves connected, having a lag less or equal than M seconds.## The N slaves need to be in "online" state.## The lag in seconds, that must be &lt;= the specified value, is calculated from# the last ping received from the slave, that is usually sent every second.## This option does not GUARANTEES that N replicas will accept the write, but# will limit the window of exposure for lost writes in case not enough slaves# are available, to the specified number of seconds.## For example to require at least 3 slaves with a lag &lt;= 10 seconds use:## min-slaves-to-write 3# min-slaves-max-lag 10## Setting one or the other to 0 disables the feature.## By default min-slaves-to-write is set to 0 (feature disabled) and# min-slaves-max-lag is set to 10.################################## 安全 #################################### Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other# commands.  This might be useful in environments in which you do not trust# others with access to the host running redis-server.## This should stay commented out for backward compatibility and because most# people do not need auth (e.g. they run their own servers).# # Warning: since Redis is pretty fast an outside user can try up to# 150k passwords per second against a good box. This means that you should# use a very strong password otherwise it will be very easy to break.# # 设置认证密码# requirepass foobared# Command renaming.## It is possible to change the name of dangerous commands in a shared# environment. For instance the CONFIG command may be renamed into something# hard to guess so that it will still be available for internal-use tools# but not available for general clients.## Example:## rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52## It is also possible to completely kill a command by renaming it into# an empty string:## rename-command CONFIG ""## Please note that changing the name of commands that are logged into the# AOF file or transmitted to slaves may cause problems.################################### 限制 ##################################### Set the max number of connected clients at the same time. By default# this limit is set to 10000 clients, however if the Redis server is not# able to configure the process file limit to allow for the specified limit# the max number of allowed clients is set to the current file limit# minus 32 (as Redis reserves a few file descriptors for internal uses).## 一旦达到最大限制，redis 将关闭所有的新连接# 并发送一个‘max number of clients reached’的错误。## maxclients 10000# 如果你设置了这个值，当缓存的数据容量达到这个值， redis 将根据你选择的# eviction 策略来移除一些 keys。## 如果 redis 不能根据策略移除 keys ，或者是策略被设置为 ‘noeviction’，# redis 将开始响应错误给命令，如 set，lpush 等等，# 并继续响应只读的命令，如 get## This option is usually useful when using Redis as an LRU cache, or to set# a hard memory limit for an instance (using the 'noeviction' policy).## WARNING: If you have slaves attached to an instance with maxmemory on,# the size of the output buffers needed to feed the slaves are subtracted# from the used memory count, so that network problems / resyncs will# not trigger a loop where keys are evicted, and in turn the output# buffer of slaves is full with DELs of keys evicted triggering the deletion# of more keys, and so forth until the database is completely emptied.## In short... if you have slaves attached it is suggested that you set a lower# limit for maxmemory so that there is some free RAM on the system for slave# output buffers (but this is not needed if the policy is 'noeviction').## 最大使用内存# maxmemory &lt;bytes&gt;# 最大内存策略，你有 5 个选择。# # volatile-lru -&gt; remove the key with an expire set using an LRU algorithm# volatile-lru -&gt; 使用 LRU 算法移除包含过期设置的 key 。# allkeys-lru -&gt; remove any key accordingly to the LRU algorithm# allkeys-lru -&gt; 根据 LRU 算法移除所有的 key 。# volatile-random -&gt; remove a random key with an expire set# allkeys-random -&gt; remove a random key, any key# volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)# noeviction -&gt; don't expire at all, just return an error on write operations# noeviction -&gt; 不让任何 key 过期，只是给写入操作返回一个错误# # Note: with any of the above policies, Redis will return an error on write#       operations, when there are not suitable keys for eviction.##       At the date of writing this commands are: set setnx setex append#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby#       getset mset msetnx exec sort## The default is:## maxmemory-policy noeviction# LRU and minimal TTL algorithms are not precise algorithms but approximated# algorithms (in order to save memory), so you can tune it for speed or# accuracy. For default Redis will check five keys and pick the one that was# used less recently, you can change the sample size using the following# configuration directive.## The default of 5 produces good enough results. 10 Approximates very closely# true LRU but costs a bit more CPU. 3 is very fast but not very accurate.## maxmemory-samples 5############################## APPEND ONLY MODE ################################ By default Redis asynchronously dumps the dataset on disk. This mode is# good enough in many applications, but an issue with the Redis process or# a power outage may result into a few minutes of writes lost (depending on# the configured save points).## The Append Only File is an alternative persistence mode that provides# much better durability. For instance using the default data fsync policy# (see later in the config file) Redis can lose just one second of writes in a# dramatic event like a server power outage, or a single write if something# wrong with the Redis process itself happens, but the operating system is# still running correctly.## AOF and RDB persistence can be enabled at the same time without problems.# If the AOF is enabled on startup Redis will load the AOF, that is the file# with the better durability guarantees.## Please check http://redis.io/topics/persistence for more information.appendonly no# The name of the append only file (default: "appendonly.aof")appendfilename "appendonly.aof"# The fsync() call tells the Operating System to actually write data on disk# instead to wait for more data in the output buffer. Some OS will really flush # data on disk, some other OS will just try to do it ASAP.## Redis supports three different modes:## no: don't fsync, just let the OS flush the data when it wants. Faster.# always: fsync after every write to the append only log . Slow, Safest.# everysec: fsync only one time every second. Compromise.## The default is "everysec", as that's usually the right compromise between# speed and data safety. It's up to you to understand if you can relax this to# "no" that will let the operating system flush the output buffer when# it wants, for better performances (but if you can live with the idea of# some data loss consider the default persistence mode that's snapshotting),# or on the contrary, use "always" that's very slow but a bit safer than# everysec.## More details please check the following article:# http://antirez.com/post/redis-persistence-demystified.html## If unsure, use "everysec".# appendfsync alwaysappendfsync everysec# appendfsync no# When the AOF fsync policy is set to always or everysec, and a background# saving process (a background save or AOF log background rewriting) is# performing a lot of I/O against the disk, in some Linux configurations# Redis may block too long on the fsync() call. Note that there is no fix for# this currently, as even performing fsync in a different thread will block# our synchronous write(2) call.## In order to mitigate this problem it's possible to use the following option# that will prevent fsync() from being called in the main process while a# BGSAVE or BGREWRITEAOF is in progress.## This means that while another child is saving, the durability of Redis is# the same as "appendfsync none". In practical terms, this means that it is# possible to lose up to 30 seconds of log in the worst scenario (with the# default Linux settings).# # If you have latency problems turn this to "yes". Otherwise leave it as# "no" that is the safest pick from the point of view of durability.no-appendfsync-on-rewrite no# Automatic rewrite of the append only file.# Redis is able to automatically rewrite the log file implicitly calling# BGREWRITEAOF when the AOF log size grows by the specified percentage.# # This is how it works: Redis remembers the size of the AOF file after the# latest rewrite (if no rewrite has happened since the restart, the size of# the AOF at startup is used).## This base size is compared to the current size. If the current size is# bigger than the specified percentage, the rewrite is triggered. Also# you need to specify a minimal size for the AOF file to be rewritten, this# is useful to avoid rewriting the AOF file even if the percentage increase# is reached but it is still pretty small.## Specify a percentage of zero in order to disable the automatic AOF# rewrite feature.auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb################################ LUA SCRIPTING  ################################ Max execution time of a Lua script in milliseconds.## If the maximum execution time is reached Redis will log that a script is# still in execution after the maximum allowed time and will start to# reply to queries with an error.## When a long running script exceed the maximum execution time only the# SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be# used to stop a script that did not yet called write commands. The second# is the only way to shut down the server in the case a write commands was# already issue by the script but the user don't want to wait for the natural# termination of the script.## Set it to 0 or a negative value for unlimited execution without warnings.lua-time-limit 5000################################ REDIS 集群  ################################# 启用或停用集群# cluster-enabled yes# Every cluster node has a cluster configuration file. This file is not# intended to be edited by hand. It is created and updated by Redis nodes.# Every Redis Cluster node requires a different cluster configuration file.# Make sure that instances running in the same system does not have# overlapping cluster configuration file names.## cluster-config-file nodes-6379.conf# Cluster node timeout is the amount of milliseconds a node must be unreachable # for it to be considered in failure state.# Most other internal time limits are multiple of the node timeout.## cluster-node-timeout 15000# A slave of a failing master will avoid to start a failover if its data# looks too old.## There is no simple way for a slave to actually have a exact measure of# its "data age", so the following two checks are performed:## 1) If there are multiple slaves able to failover, they exchange messages#    in order to try to give an advantage to the slave with the best#    replication offset (more data from the master processed).#    Slaves will try to get their rank by offset, and apply to the start#    of the failover a delay proportional to their rank.## 2) Every single slave computes the time of the last interaction with#    its master. This can be the last ping or command received (if the master#    is still in the "connected" state), or the time that elapsed since the#    disconnection with the master (if the replication link is currently down).#    If the last interaction is too old, the slave will not try to failover#    at all.## The point "2" can be tuned by user. Specifically a slave will not perform# the failover if, since the last interaction with the master, the time# elapsed is greater than:##   (node-timeout * slave-validity-factor) + repl-ping-slave-period## So for example if node-timeout is 30 seconds, and the slave-validity-factor# is 10, and assuming a default repl-ping-slave-period of 10 seconds, the# slave will not try to failover if it was not able to talk with the master# for longer than 310 seconds.## A large slave-validity-factor may allow slaves with too old data to failover# a master, while a too small value may prevent the cluster from being able to# elect a slave at all.## For maximum availability, it is possible to set the slave-validity-factor# to a value of 0, which means, that slaves will always try to failover the# master regardless of the last time they interacted with the master.# (However they'll always try to apply a delay proportional to their# offset rank).## Zero is the only value able to guarantee that when all the partitions heal# the cluster will always be able to continue.## cluster-slave-validity-factor 10# Cluster slaves are able to migrate to orphaned masters, that are masters# that are left without working slaves. This improves the cluster ability# to resist to failures as otherwise an orphaned master can't be failed over# in case of failure if it has no working slaves.## Slaves migrate to orphaned masters only if there are still at least a# given number of other working slaves for their old master. This number# is the "migration barrier". A migration barrier of 1 means that a slave# will migrate only if there is at least 1 other working slave for its master# and so forth. It usually reflects the number of slaves you want for every# master in your cluster.## Default is 1 (slaves migrate only if their masters remain with at least# one slave). To disable migration just set it to a very large value.# A value of 0 can be set but is useful only for debugging and dangerous# in production.## cluster-migration-barrier 1# In order to setup your cluster make sure to read the documentation# available at http://redis.io web site.################################## SLOW LOG #################################### The Redis Slow Log is a system to log queries that exceeded a specified# execution time. The execution time does not include the I/O operations# like talking with the client, sending the reply and so forth,# but just the time needed to actually execute the command (this is the only# stage of command execution where the thread is blocked and can not serve# other requests in the meantime).# # You can configure the slow log with two parameters: one tells Redis# what is the execution time, in microseconds, to exceed in order for the# command to get logged, and the other parameter is the length of the# slow log. When a new command is logged the oldest one is removed from the# queue of logged commands.# The following time is expressed in microseconds, so 1000000 is equivalent# to one second. Note that a negative number disables the slow log, while# a value of zero forces the logging of every command.slowlog-log-slower-than 10000# There is no limit to this length. Just be aware that it will consume memory.# You can reclaim memory used by the slow log with SLOWLOG RESET.slowlog-max-len 128############################# Event notification ############################### Redis can notify Pub/Sub clients about events happening in the key space.# This feature is documented at http://redis.io/topics/keyspace-events# # For instance if keyspace events notification is enabled, and a client# performs a DEL operation on key "foo" stored in the Database 0, two# messages will be published via Pub/Sub:## PUBLISH __keyspace@0__:foo del# PUBLISH __keyevent@0__:del foo## It is possible to select the events that Redis will notify among a set# of classes. Every class is identified by a single character:##  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...#  $     String commands#  l     List commands#  s     Set commands#  h     Hash commands#  z     Sorted set commands#  x     Expired events (events generated every time a key expires)#  e     Evicted events (events generated when a key is evicted for maxmemory)#  A     Alias for g$lshzxe, so that the "AKE" string means all the events.##  The "notify-keyspace-events" takes as argument a string that is composed#  by zero or multiple characters. The empty string means that notifications#  are disabled at all.##  Example: to enable list and generic events, from the point of view of the#           event name, use:##  notify-keyspace-events Elg##  Example 2: to get the stream of the expired keys subscribing to channel#             name __keyevent@0__:expired use:##  notify-keyspace-events Ex##  By default all notifications are disabled because most users don't need#  this feature and the feature has some overhead. Note that if you don't#  specify at least one of K or E, no events will be delivered.notify-keyspace-events ""############################### ADVANCED CONFIG ################################ Hashes are encoded using a memory efficient data structure when they have a# small number of entries, and the biggest entry does not exceed a given# threshold. These thresholds can be configured using the following directives.hash-max-ziplist-entries 512hash-max-ziplist-value 64# Similarly to hashes, small lists are also encoded in a special way in order# to save a lot of space. The special representation is only used when# you are under the following limits:list-max-ziplist-entries 512list-max-ziplist-value 64# Sets have a special encoding in just one case: when a set is composed# of just strings that happens to be integers in radix 10 in the range# of 64 bit signed integers.# The following configuration setting sets the limit in the size of the# set in order to use this special memory saving encoding.set-max-intset-entries 512# Similarly to hashes and lists, sorted sets are also specially encoded in# order to save a lot of space. This encoding is only used when the length and# elements of a sorted set are below the following limits:zset-max-ziplist-entries 128zset-max-ziplist-value 64# HyperLogLog sparse representation bytes limit. The limit includes the# 16 bytes header. When an HyperLogLog using the sparse representation crosses# this limit, it is converted into the dense representation.## A value greater than 16000 is totally useless, since at that point the# dense representation is more memory efficient.# # The suggested value is ~ 3000 in order to have the benefits of# the space efficient encoding without slowing down too much PFADD,# which is O(N) with the sparse encoding. The value can be raised to# ~ 10000 when CPU is not a concern, but space is, and the data set is# composed of many HyperLogLogs with cardinality in the 0 - 15000 range.hll-sparse-max-bytes 3000# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in# order to help rehashing the main Redis hash table (the one mapping top-level# keys to values). The hash table implementation Redis uses (see dict.c)# performs a lazy rehashing: the more operation you run into a hash table# that is rehashing, the more rehashing "steps" are performed, so if the# server is idle the rehashing is never complete and some more memory is used# by the hash table.# # The default is to use this millisecond 10 times every second in order to# active rehashing the main dictionaries, freeing memory when possible.## If unsure:# use "activerehashing no" if you have hard latency requirements and it is# not a good thing in your environment that Redis can reply form time to time# to queries with 2 milliseconds delay.## use "activerehashing yes" if you don't have such hard requirements but# want to free memory asap when possible.activerehashing yes# The client output buffer limits can be used to force disconnection of clients# that are not reading data from the server fast enough for some reason (a# common reason is that a Pub/Sub client can't consume messages as fast as the# publisher can produce them).## The limit can be set differently for the three different classes of clients:## normal -&gt; normal clients# slave  -&gt; slave clients and MONITOR clients# pubsub -&gt; clients subscribed to at least one pubsub channel or pattern## The syntax of every client-output-buffer-limit directive is the following:## client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;## A client is immediately disconnected once the hard limit is reached, or if# the soft limit is reached and remains reached for the specified number of# seconds (continuously).# So for instance if the hard limit is 32 megabytes and the soft limit is# 16 megabytes / 10 seconds, the client will get disconnected immediately# if the size of the output buffers reach 32 megabytes, but will also get# disconnected if the client reaches 16 megabytes and continuously overcomes# the limit for 10 seconds.## By default normal clients are not limited because they don't receive data# without asking (in a push way), but just after a request, so only# asynchronous clients may create a scenario where data is requested faster# than it can read.## Instead there is a default limit for pubsub and slave clients, since# subscribers and slaves receive data in a push fashion.## Both the hard or the soft limit can be disabled by setting them to zero.client-output-buffer-limit normal 0 0 0client-output-buffer-limit slave 256mb 64mb 60client-output-buffer-limit pubsub 32mb 8mb 60# Redis calls an internal function to perform many background tasks, like# closing connections of clients in timeout, purging expired keys that are# never requested, and so forth.## Not all tasks are performed with the same frequency, but Redis checks for# tasks to perform accordingly to the specified "hz" value.## By default "hz" is set to 10. Raising the value will use more CPU when# Redis is idle, but at the same time will make Redis more responsive when# there are many keys expiring at the same time, and timeouts may be# handled with more precision.## The range is between 1 and 500, however a value over 100 is usually not# a good idea. Most users should use the default of 10 and raise this up to# 100 only in environments where very low latency is required.hz 10# When a child rewrites the AOF file, if the following option is enabled# the file will be fsync-ed every 32 MB of data generated. This is useful# in order to commit the file to the disk more incrementally and avoid# big latency spikes.aof-rewrite-incremental-fsync yes</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>R语言</title>
      <link href="/posts/blog-model03.html"/>
      <url>/posts/blog-model03.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h1 id="一-R环境设置"><a href="#一-R环境设置" class="headerlink" title="一.R环境设置"></a>一.R环境设置</h1><h3 id="尝试在线环境"><a href="#尝试在线环境" class="headerlink" title="尝试在线环境"></a>尝试在线环境</h3><p>你真的不需要设置自己的环境来开始学习R编程语言。 原因很简单，我们已经在线设置了R编程环境，以便您可以在进行理论工作的同时在线编译和执行所有可用的示例。 这给你对你正在阅读的信心，并用不同的选项检查结果。 随意修改任何示例并在线执行。<br>实例：</p><pre><code># Print Hello World. print("Hello World") # Add two numbers. print(23.9 + 11.6)</code></pre><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><p>您可以从<a href="https://cran.r-project.org/bin/windows/base/" target="_blank" rel="noopener">R-3.2.2 for Windows（32/64位）</a>下载R的Windows安装程序版本，并将其保存在本地目录中。</p><p>因为它是一个名为“R-version-win.exe”的Windows安装程序（.exe）。 您只需双击并运行安装程序接受默认设置即可。 如果您的Windows是32位版本，它将安装32位版本。 但是如果你的窗口是64位，那么它安装32位和64位版本。</p><p>安装后，您可以找到该图标，以在Windows程序文件下的目录结构“R \ R3.2.2 \ bin \ i386 \ Rgui.exe”中运行程序。 单击此图标会打开R-GUI，它是R控制台来执行R编程。</p><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h3><p><a href="https://cran.r-project.org/bin/linux/" target="_blank" rel="noopener">R</a>语言适用于多版本的Linux系统。</p><p>各版本Linux的各有不同。具体的安装步骤在上述资源中有对应的教程。但是，如果你是在赶时间，那么你可以用<strong>yum</strong>命令，如下所示的安装指令<br>安装R</p><pre><code>$ yum install R</code></pre><p>以上命令将安装R编程的核心功能与标准包，额外的包需要另外安装，而后你可以按如下提示启动R。</p><pre><code>$ RR version 3.2.0 (2015-04-16) -- "Full of  Ingredients"          Copyright (C) 2015 The R Foundation for Statistical ComputingPlatform: x86_64-redhat-linux-gnu (64-bit)R is free software and comes with ABSOLUTELY NO WARRANTY.You are welcome to redistribute it under certain conditions.Type 'license()' or 'licence()' for distribution details.R is a collaborative project with many  contributors.                    Type 'contributors()' for more information and'citation()' on how to cite R or R packages in publications.Type 'demo()' for some demos, 'help()' for on-line help, or'help.start()' for an HTML browser interface to help.Type 'q()' to quit R.&gt;  </code></pre><p>现在，您可以在R语言提示符下使用install命令安装所需的软件包。 例如，以下命令将安装为3D图表所需的plotrix软件包。</p><pre><code>&gt; install.packages("plotrix")</code></pre><h1 id="二-R语言-基本语法"><a href="#二-R语言-基本语法" class="headerlink" title="二.R语言 基本语法"></a>二.R语言 基本语法</h1><h3 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h3><p>如果你已经配置好R语言环境，那么你只需要按一下的命令便可轻易开启命令提示符</p><pre><code>$ R</code></pre><p>这将启动R语言解释器，你会得到一个提示 &gt; 在那里你可以开始输入你的程序，具体如下。</p><pre><code>&gt; myString &lt;- "Hello, World!"&gt; print ( myString)[1] "Hello, World!"</code></pre><p>在这里，第一个语句先定义一个字符串变量myString，并将“Hello，World！”赋值其中，第二句则使用print()语句将变量myString的内容进行打印。</p><h3 id="脚本文件"><a href="#脚本文件" class="headerlink" title="脚本文件"></a>脚本文件</h3><p>通常，您将通过在脚本文件中编写程序来执行编程，然后在命令提示符下使用R解释器（称为Rscript）来执行这些脚本。 所以让我们开始在一个命名为test.R的文本文件中编写下面的代码</p><pre><code># My first program in R ProgrammingmyString &lt;- "Hello, World!"print ( myString)</code></pre><p>将上述代码保存在test.R文件中，并在Linux命令提示符下执行，如下所示。 即使您使用的是Windows或其他系统，语法也将保持不变。</p><pre><code>$ Rscript test.R </code></pre><p>当我们运行上面的程序，它产生以下结果。</p><pre><code>[1] "Hello, World!"</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释能帮助您解释R语言程序中的脚本，它们在实际执行程序时会被解释器忽略。 单个注释使用＃在语句的开头写入，如下所示</p><pre><code># My first program in R Programming</code></pre><p>R语言不支持多行注释，但你可以使用一个小技巧，如下</p><pre><code>if(FALSE) {   "This is a demo for multi-line comments and it should be put inside either a single      OR double quote"}myString &lt;- "Hello, World!"print ( myString)</code></pre><p>虽然上面的注释将由R解释器执行，但它们不会干扰您的实际程序。 但是你必须为内容加上单引号或双引号。</p><h1 id="三-数据结构"><a href="#三-数据结构" class="headerlink" title="三.数据结构"></a>三.数据结构</h1><p>通常，在使用任何编程语言进行编程时，您需要使用各种变量来存储各种信息。 变量只是保留值的存储位置。 这意味着，当你创建一个变量，你必须在内存中保留一些空间来存储它们。</p><p>您可能想存储各种数据类型的信息，如字符，宽字符，整数，浮点，双浮点，布尔等。基于变量的数据类型，操作系统分配内存并决定什么可以存储在保留内存中。</p><p>与其他编程语言（如C中的C和java）相反，变量不会声明为某种数据类型。 变量分配有R对象，R对象的数据类型变为变量的数据类型。尽管有很多类型的R对象，但经常使用的是：</p><ul><li><p>矢量</p></li><li><p>列表</p></li><li><p>矩阵</p></li><li><p>数组</p></li><li><p>因子</p></li><li><p>数据帧<br>这些对象中最简单的是向量对象，并且这些原子向量有六种数据类型，也称为六类向量。 其他R对象建立在原子向量之上。</p></li><li><p>Logical（逻辑型）：TRUE, FALSE </p></li><li><p>Numeric（数字）    12.3，5，999</p></li><li><p>Integer（整型）    2L，34L，0L</p></li><li><p>Complex（复合型）    3 + 2i</p></li><li><p>Character（字符）    ‘a’ , ‘“good”, “TRUE”, ‘23.4’</p></li><li><p>Raw（原型）    “Hello” 被存储为 48 65 6c 6c 6f<br>在R编程中，非常基本的数据类型是称为向量的R对象，其保存如上所示的不同类的元素。 请注意，在R中，类的数量不仅限于上述六种类型。 例如，我们可以使用许多原子向量并创建一个数组，其类将成为数组。</p><h3 id="Vectors-向量"><a href="#Vectors-向量" class="headerlink" title="Vectors 向量"></a>Vectors 向量</h3><p>当你想用多个元素创建向量时，你应该使用c()函数，这意味着将元素组合成一个向量。</p><pre><code># Create a vector.apple &lt;- c('red','green',"yellow")print(apple)# Get the class of the vector.print(class(apple))</code></pre><p>当我们执行上面的代码，它产生以下结果</p><pre><code>[1] "red"    "green"  "yellow"[1] "character"</code></pre><h3 id="Lists-列表"><a href="#Lists-列表" class="headerlink" title="Lists 列表"></a>Lists 列表</h3><p>列表是一个R对象，它可以在其中包含许多不同类型的元素，如向量，函数甚至其中的另一个列表。</p><pre><code># Create a list.list1 &lt;- list(c(2,5,3),21.3,sin)# Print the list.print(list1)</code></pre><p>当我们执行上面的代码，它产生以下结果</p><pre><code>[[1]][1] 2 5 3[[2]][1] 21.3[[3]]function (x)  .Primitive("sin")### Matrices 矩阵</code></pre><p>矩阵是二维矩形数据集。 它可以使用矩阵函数的向量输入创建。</p><pre><code># Create a matrix.M = matrix( c('a','a','b','c','b','a'), nrow = 2, ncol = 3, byrow = TRUE)print(M)</code></pre><p>当我们执行上面的代码，它产生以下结果</p><pre><code>   [,1] [,2] [,3][1,] "a"  "a"  "b" [2,] "c"  "b"  "a"</code></pre><h3 id="Arrays-数组"><a href="#Arrays-数组" class="headerlink" title="Arrays 数组"></a>Arrays 数组</h3><p>虽然矩阵被限制为二维，但阵列可以具有任何数量的维度。 数组函数使用一个dim属性创建所需的维数。 在下面的例子中，我们创建了一个包含两个元素的数组，每个元素为3x3个矩阵。</p><pre><code># Create an array.a &lt;- array(c('green','yellow'),dim = c(3,3,2))print(a)</code></pre><p>当我们执行上面的代码，它产生以下结果</p><pre><code>, , 1   [,1]     [,2]     [,3]    [1,] "green"  "yellow" "green" [2,] "yellow" "green"  "yellow"[3,] "green"  "yellow" "green" , , 2   [,1]     [,2]     [,3]    [1,] "yellow" "green"  "yellow"[2,] "green"  "yellow" "green" [3,] "yellow" "green"  "yellow"  </code></pre><h3 id="Factors-因子"><a href="#Factors-因子" class="headerlink" title="Factors 因子"></a>Factors 因子</h3><p>因子是使用向量创建的r对象。 它将向量与向量中元素的不同值一起存储为标签。 标签总是字符，不管它在输入向量中是数字还是字符或布尔等。 它们在统计建模中非常有用。<br>使用factor()函数创建因子。nlevels函数给出级别计数。</p><pre><code># Create a vector.apple_colors &lt;- c('green','green','yellow','red','red','red','green')# Create a factor object.factor_apple &lt;- factor(apple_colors)# Print the factor.print(factor_apple)print(nlevels(factor_apple))</code></pre><p>当我们执行上面的代码，它产生以下结果</p><pre><code>[1] green  green  yellow red    red    red    yellow green Levels: green red yellow# applying the nlevels function we can know the number of distinct values[1] 3</code></pre><h3 id="Data-Frames-数据帧"><a href="#Data-Frames-数据帧" class="headerlink" title="Data Frames 数据帧"></a>Data Frames 数据帧</h3><p>数据帧是表格数据对象。 与数据帧中的矩阵不同，每列可以包含不同的数据模式。 第一列可以是数字，而第二列可以是字符，第三列可以是逻辑的。 它是等长度的向量的列表。<br>使用data.frame()函数创建数据帧。</p><pre><code># Create the data frame.BMI &lt;-     data.frame( gender = c("Male", "Male","Female"),  height = c(152, 171.5, 165),  weight = c(81,93, 78), Age = c(42,38,26))print(BMI)</code></pre><p>当我们执行上面的代码，它产生以下结果</p><pre><code>gender height weight Age1   Male  152.0     81  422   Male  171.5     93  383 Female  165.0     78  26  </code></pre><h1 id="四-变量"><a href="#四-变量" class="headerlink" title="四.变量"></a>四.变量</h1><p>变量为我们提供了我们的程序可以操作的命名存储。 R语言中的变量可以存储原子向量，原子向量组或许多Robject的组合。 有效的变量名称由字母，数字和点或下划线字符组成。 变量名以字母或不以数字后跟的点开头。<br>注：有字母，数字，点和下划线，其中只能字母开头</p><h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>可以使用向左，向右和等于运算符来为变量分配值。 可以使用print()或cat()函数打印变量的值。 cat()函数将多个项目组合成连续打印输出。</p><pre><code># Assignment using equal operator.var.1 = c(0,1,2,3)           # Assignment using leftward operator.var.2 &lt;- c("learn","R")   # Assignment using rightward operator.   c(TRUE,1) -&gt; var.3           print(var.1)cat ("var.1 is ", var.1 ,"")cat ("var.2 is ", var.2 ,"")cat ("var.3 is ", var.3 ,"")</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 0 1 2 3var.1 is  0 1 2 3 var.2 is  learn R var.3 is  1 1 </code></pre><p>注 - 向量c（TRUE，1）具有逻辑和数值类的混合。 因此，逻辑类强制转换为数字类，使TRUE为1。</p><h3 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h3><p>在R语言中，变量本身没有声明任何数据类型，而是获取分配给它的R - 对象的数据类型。 所以R称为动态类型语言，这意味着我们可以在程序中使用同一个变量时，一次又一次地更改变量的数据类型。</p><pre><code>var_x &lt;- "Hello"cat("The class of var_x is ",class(var_x),"")var_x &lt;- 34.5cat("  Now the class of var_x is ",class(var_x),"")var_x &lt;- 27Lcat("   Next the class of var_x becomes ",class(var_x),"")</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>The class of var_x is  character  Now the class of var_x is  numeric     Next the class of var_x becomes  integer</code></pre><h3 id="查找变量"><a href="#查找变量" class="headerlink" title="查找变量"></a>查找变量</h3><p>要知道工作空间中当前可用的所有变量，我们使用ls()函数。 ls()函数也可以使用模式来匹配变量名。</p><pre><code>print(ls())</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "my var"     "my_new_var" "my_var"     "var.1"      [5] "var.2"      "var.3"      "var.name"   "var_name2."[9] "var_x"      "varname" </code></pre><p>注意 - 它是一个示例输出，取决于在您的环境中声明的变量。<br>ls()函数可以使用模式来匹配变量名。<br>ls()函数可以使用模式来匹配变量名。</p><pre><code># List the variables starting with the pattern "var".print(ls(pattern = "var"))   </code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "my var"     "my_new_var" "my_var"     "var.1"      [5] "var.2"      "var.3"      "var.name"   "var_name2."[9] "var_x"      "varname"    </code></pre><p>以点(.)开头的变量被隐藏，它们可以使用ls()函数的“all.names = TRUE”参数列出。</p><pre><code>print(ls(all.name = TRUE))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] ".cars"        ".Random.seed" ".var_name"    ".varname"     ".varname2"   [6] "my var"       "my_new_var"   "my_var"       "var.1"        "var.2"        [11]"var.3"        "var.name"     "var_name2."   "var_x"  </code></pre><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>可以使用rm()函数删除变量。 下面我们删除变量var.3。 打印时，抛出变量错误的值。</p><pre><code>rm(var.3)print(var.3)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "var.3"Error in print(var.3) : object 'var.3' not found</code></pre><p>所有的变量可以通过使用rm()和ls()函数一起删除。</p><pre><code>rm(list = ls())print(ls())</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>character(0)</code></pre><h1 id="五-运算符"><a href="#五-运算符" class="headerlink" title="五.运算符"></a>五.运算符</h1><p>运算符是一个符号，通知编译器执行特定的数学或逻辑操作。 R语言具有丰富的内置运算符，并提供以下类型的运算符。</p></li></ul><h3 id="运算符的类型"><a href="#运算符的类型" class="headerlink" title="运算符的类型"></a>运算符的类型</h3><p>R语言中拥有如下几种运算符类型：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>赋值运算符</li><li>其他运算符</li><li>算术运算符<br>下表显示了R语言支持的算术运算符。 操作符对向量的每个元素起作用。<br>除了加减乘除</li><li>%%    两个向量求余</li><li>％/％    两个向量相除求商</li><li>^    将第二向量作为第一向量的指数<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3>即大于小于等于以及不等于<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3>下表显示了R语言支持的逻辑运算符。 它只适用于逻辑，数字或复杂类型的向量。 所有大于1的数字被认为是逻辑值TRUE。<br>将第一向量的每个元素与第二向量的相应元素进行比较。 比较的结果是布尔值。</li><li>&amp;    它被称为元素逻辑AND运算符。 它将第一向量的每个元素与第二向量的相应元素组合，并且如果两个元素都为TRUE，则给出输出TRUE。</li><li>|    它被称为元素逻辑或运算符。 它将第一向量的每个元素与第二向量的相应元素组合，并且如果元素为真，则给出输出TRUE。</li><li>!    它被称为逻辑非运算符。 取得向量的每个元素，并给出相反的逻辑值。<br>逻辑运算符&amp;&amp;和|| 只考虑向量的第一个元素，给出单个元素的向量作为输出。</li><li>&amp;&amp;    称为逻辑AND运算符。 取两个向量的第一个元素，并且只有两个都为TRUE时才给出TRUE。</li><li>||    称为逻辑OR运算符。 取两个向量的第一个元素，如果其中一个为TRUE，则给出TRUE。<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3>这些运算符用于向向量赋值。</li><li>&lt;− or = or &lt;&lt;−  称为左分配</li><li>-&gt; or -&gt;&gt;    称为右分配<h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3>这些运算符用于特定目的，而不是一般的数学或逻辑计算。</li><li>:    冒号运算符。 它为向量按顺序创建一系列数字。</li><li>%in%    此运算符用于标识元素是否属于向量。</li><li>%*%    此运算符用于将矩阵与其转置相乘。<h1 id="六-决策"><a href="#六-决策" class="headerlink" title="六.决策"></a>六.决策</h1>决策结构要求程序员指定要由程序评估或测试的一个或多个条件，以及如果条件被确定为真则要执行的一个或多个语句，如果条件为假则执行其他语句。</li></ul><p>以下是在大多数编程语言中的典型决策结构的一般形式</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-295f26be3cad36cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="做决定"></p><p>R提供以下类型的决策语句。 单击以下链接以检查其详细信息。</p><ul><li><a href="https://www.w3cschool.cn/r/r_if_statement.html" target="_blank" rel="noopener">if语句</a></li></ul><p>if语句由一个布尔表达式后跟一个或多个语句组成。</p><ul><li><a href="https://www.w3cschool.cn/r/r_if_else_statement.html" target="_blank" rel="noopener">if … else语句</a></li></ul><p>if语句后面可以有一个可选的else语句，当布尔表达式为false时执行。</p><ul><li><a href="https://www.w3cschool.cn/r/r_switch_statement.html" target="_blank" rel="noopener">switch语句</a></li></ul><p>switch语句允许根据值列表测试变量的相等性。</p><h1 id="七-包"><a href="#七-包" class="headerlink" title="七.包"></a>七.包</h1><p>R语言的包是R函数，编译代码和样本数据的集合。 它们存储在R语言环境中名为“library”的目录下。 默认情况下，R语言在安装期间安装一组软件包。 随后添加更多包，当它们用于某些特定目的时。 当我们启动R语言控制台时，默认情况下只有默认包可用。 已经安装的其他软件包必须显式加载以供将要使用它们的R语言程序使用。</p><p>所有可用的R语言包都列在<a href="https://cran.r-project.org/web/packages/available_packages_by_name.html" target="_blank" rel="noopener">R语言的包</a>。<br>下面是用于检查，验证和使用R包的命令列表。</p><h3 id="检查可用R语言的包"><a href="#检查可用R语言的包" class="headerlink" title="检查可用R语言的包"></a>检查可用R语言的包</h3><p>获取包含R包的库位置</p><pre><code>.libPaths()</code></pre><p>当我们执行上面的代码，它产生以下结果。 它可能会根据您的电脑的本地设置而有所不同。</p><pre><code>[2] "C:/Program Files/R/R-3.2.2/library"</code></pre><p>获取已安装的所有软件包列表</p><pre><code>library()</code></pre><p>当我们执行上面的代码，它产生以下结果。 它可能会根据您的电脑的本地设置而有所不同。</p><pre><code>Packages in library ‘C:/Program Files/R/R-3.2.2/library’:base                    The R Base Packageboot                    Bootstrap Functions (Originally by Angelo Canty                        for S)class                   Functions for Classificationcluster                 "Finding Groups in Data": Cluster Analysis                        Extended Rousseeuw et al.codetools               Code Analysis Tools for Rcompiler                The R Compiler Package</code></pre><p>获取当前在R环境中加载的所有包</p><pre><code>search()</code></pre><p>当我们执行上述代码时，它产生了以下结果。它会根据你的个人电脑的本地设置而异。</p><pre><code>[1] ".GlobalEnv"        "package:stats"     "package:graphics" [4] "package:grDevices" "package:utils"     "package:datasets" [7] "package:methods"   "Autoloads"         "package:base" </code></pre><h3 id="安装一个新的软件包"><a href="#安装一个新的软件包" class="headerlink" title="安装一个新的软件包"></a>安装一个新的软件包</h3><p>有两种方法来添加新的R包。 一个是直接从CRAN目录安装，另一个是将软件包下载到本地系统并手动安装它。</p><h5 id="直接从CRAN安装"><a href="#直接从CRAN安装" class="headerlink" title="直接从CRAN安装"></a>直接从CRAN安装</h5><p>以下命令直接从CRAN网页获取软件包，并将软件包安装在R环境中。 可能会提示您选择最近的镜像。 根据您的位置选择一个。</p><pre><code># Install the package named "XML". install.packages("XML")</code></pre><h5 id="手动安装包"><a href="#手动安装包" class="headerlink" title="手动安装包"></a>手动安装包</h5><p>转到链接<a href="https://cran.r-project.org/web/packages/available_packages_by_name.html" target="_blank" rel="noopener">R Packages</a>下载所需的包。 将包作为.zip文件保存在本地系统中的适当位置。<br>现在您可以运行以下命令在R环境中安装此软件包。</p><pre><code># Install the package named "XML"install.packages("E:/XML_3.98-1.3.zip", repos = NULL, type = "source")</code></pre><h3 id="装载包到库中"><a href="#装载包到库中" class="headerlink" title="装载包到库中"></a>装载包到库中</h3><p>在包可以在代码中使用之前，必须将其加载到当前R环境中。 您还需要加载先前已安装但在当前环境中不可用的软件包。</p><p>使用以下命令加载包：</p><pre><code>library("package Name", lib.loc = "path to library")# Load the package named "XML"install.packages("E:/XML_3.98-1.3.zip", repos = NULL, type = "source")</code></pre><p>#九.循环<br>可能有一种情况，当你需要执行一段代码几次。 通常，顺序执行语句。 首先执行函数中的第一个语句，然后执行第二个语句，依此类推。</p><p>编程语言提供允许更复杂的执行路径的各种控制结构。</p><p>循环语句允许我们多次执行一个语句或一组语句，以下是大多数编程语言中循环语句的一般形式 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-1a49a2a37e122a97.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="环路结构"><br>R编程语言提供以下种类的循环来处理循环需求。 单击以下链接以检查其详细信息。</p><ul><li><a href="https://www.w3cschool.cn/r/r_repeat_loop.html" target="_blank" rel="noopener">repeat循环</a></li></ul><p>多次执行一系列语句，并简化管理循环变量的代码。</p><ul><li><a href="https://www.w3cschool.cn/r/r_while_loop.html" target="_blank" rel="noopener">while循环</a></li></ul><p>在给定条件为真时，重复语句或语句组。 它在执行循环体之前测试条件。</p><ul><li><a href="https://www.w3cschool.cn/r/r_for_loop.html" target="_blank" rel="noopener">for循环</a></li></ul><p>像while语句，不同之处在于它测试在循环体的端部的条件。</p><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><p>循环控制语句从其正常序列改变执行。 当执行离开作用域时，在该作用域中创建的所有自动对象都将被销毁。<br>R语言支持以下控制语句。 单击以下链接以检查其详细信息。</p><ul><li><a href="https://www.w3cschool.cn/r/r_break_statement.html" target="_blank" rel="noopener">break语句</a></li></ul><p>终止循环语句，并将执行转移到循环后立即执行的语句。</p><ul><li><a href="https://www.w3cschool.cn/r/r_next_statement.html" target="_blank" rel="noopener">next语句</a></li></ul><p>next语句模拟R语言switch语句的行为。</p><h1 id="十-数据重塑"><a href="#十-数据重塑" class="headerlink" title="十.数据重塑"></a>十.数据重塑</h1><p>R语言中的数据重塑是关于改变数据被组织成行和列的方式。 大多数时间R语言中的数据处理是通过将输入数据作为数据帧来完成的。 很容易从数据帧的行和列中提取数据，但是在某些情况下，我们需要的数据帧格式与我们接收数据帧的格式不同。 R语言具有许多功能，在数据帧中拆分，合并和将行更改为列，反之亦然。</p><h3 id="于数据帧中加入列和行"><a href="#于数据帧中加入列和行" class="headerlink" title="于数据帧中加入列和行"></a>于数据帧中加入列和行</h3><p>我们可以使用cbind()函数连接多个向量来创建数据帧。 此外，我们可以使用rbind()函数合并两个数据帧。</p><pre><code># Create vector objects.city &lt;- c("Tampa","Seattle","Hartford","Denver")state &lt;- c("FL","WA","CT","CO")zipcode &lt;- c(33602,98104,06161,80294)# Combine above three vectors into one data frame.addresses &lt;- cbind(city,state,zipcode)# Print a header.cat("# # # # The First data frame") # Print the data frame.print(addresses)# Create another data frame with similar columnsnew.address &lt;- data.frame(   city = c("Lowry","Charlotte"),   state = c("CO","FL"),   zipcode = c("80230","33949"),   stringsAsFactors = FALSE)# Print a header.cat("# # # The Second data frame") # Print the data frame.print(new.address)# Combine rows form both the data frames.all.addresses &lt;- rbind(addresses,new.address)# Print a header.cat("# # # The combined data frame") # Print the result.print(all.addresses)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code># # # # The First data frame     city       state zipcode[1,] "Tampa"    "FL"  "33602"[2,] "Seattle"  "WA"  "98104"[3,] "Hartford" "CT"   "6161" [4,] "Denver"   "CO"  "80294"# # # The Second data frame       city       state   zipcode1      Lowry      CO      802302      Charlotte  FL      33949# # # The combined data frame       city      state zipcode1      Tampa     FL    336022      Seattle   WA    981043      Hartford  CT     61614      Denver    CO    802945      Lowry     CO    802306     Charlotte  FL    33949</code></pre><h3 id="合并数据帧"><a href="#合并数据帧" class="headerlink" title="合并数据帧"></a>合并数据帧</h3><p>我们可以使用merge()函数合并两个数据帧。 数据帧必须具有相同的列名称，在其上进行合并。</p><p>在下面的例子中，我们考虑图书馆名称“MASS”中有关Pima Indian Women的糖尿病的数据集。 我们基于血压（“bp”）和体重指数（“bmi”）的值合并两个数据集。 在选择这两列用于合并时，其中这两个变量的值在两个数据集中匹配的记录被组合在一起以形成单个数据帧。</p><pre><code>library(MASS)merged.Pima &lt;- merge(x = Pima.te, y = Pima.tr,   by.x = c("bp", "bmi"),   by.y = c("bp", "bmi"))print(merged.Pima)nrow(merged.Pima)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>   bp  bmi npreg.x glu.x skin.x ped.x age.x type.x npreg.y glu.y skin.y ped.y1  60 33.8       1   117     23 0.466    27     No       2   125     20 0.0882  64 29.7       2    75     24 0.370    33     No       2   100     23 0.3683  64 31.2       5   189     33 0.583    29    Yes       3   158     13 0.2954  64 33.2       4   117     27 0.230    24     No       1    96     27 0.2895  66 38.1       3   115     39 0.150    28     No       1   114     36 0.2896  68 38.5       2   100     25 0.324    26     No       7   129     49 0.4397  70 27.4       1   116     28 0.204    21     No       0   124     20 0.2548  70 33.1       4    91     32 0.446    22     No       9   123     44 0.3749  70 35.4       9   124     33 0.282    34     No       6   134     23 0.54210 72 25.6       1   157     21 0.123    24     No       4    99     17 0.29411 72 37.7       5    95     33 0.370    27     No       6   103     32 0.32412 74 25.9       9   134     33 0.460    81     No       8   126     38 0.16213 74 25.9       1    95     21 0.673    36     No       8   126     38 0.16214 78 27.6       5    88     30 0.258    37     No       6   125     31 0.56515 78 27.6      10   122     31 0.512    45     No       6   125     31 0.56516 78 39.4       2   112     50 0.175    24     No       4   112     40 0.23617 88 34.5       1   117     24 0.403    40    Yes       4   127     11 0.598   age.y type.y1     31     No2     21     No3     24     No4     21     No5     21     No6     43    Yes7     36    Yes8     40     No9     29    Yes10    28     No11    55     No12    39     No13    39     No14    49    Yes15    49    Yes16    38     No17    28     No[1] 17</code></pre><h3 id="melt-拆分数据和cast-数据重构"><a href="#melt-拆分数据和cast-数据重构" class="headerlink" title="melt()拆分数据和cast()数据重构"></a>melt()拆分数据和cast()数据重构</h3><p>R语言编程的一个最有趣的方面是关于在多个步骤中改变数据的形状以获得期望的形状。 用于执行此操作的函数称为melt()和cast()。</p><p>我们考虑称为船舶的数据集称为“MASS”。</p><pre><code>library(MASS)print(ships)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>     type year   period   service   incidents1     A   60     60        127         02     A   60     75         63         03     A   65     60       1095         34     A   65     75       1095         45     A   70     60       1512         6..........................8     A   75     75       2244         119     B   60     60      44882         3910    B   60     75      17176         2911    B   65     60      28609         58........................17    C   60     60      1179          118    C   60     75       552          119    C   65     60       781          0........................</code></pre><h3 id="melt-拆分数据"><a href="#melt-拆分数据" class="headerlink" title="melt()拆分数据"></a>melt()拆分数据</h3><p>现在我们拆分数据进行重组，将除类型和年份以外的所有列转换为多行展示。</p><pre><code>molten.ships &lt;- melt(ships, id = c("type","year"))print(molten.ships)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      type year  variable  value1      A   60    period      602      A   60    period      753      A   65    period      604      A   65    period      75........................9      B   60    period      6010     B   60    period      7511     B   65    period      6012     B   65    period      7513     B   70    period      60......................41     A   60    service    12742     A   60    service     6343     A   65    service   1095......................70     D   70    service   120871     D   75    service      072     D   75    service   205173     E   60    service     4574     E   60    service      075     E   65    service    789......................101    C   70    incidents    6102    C   70    incidents    2103    C   75    incidents    0104    C   75    incidents    1105    D   60    incidents    0106    D   60    incidents    0......................</code></pre><h3 id="cast-重构数据"><a href="#cast-重构数据" class="headerlink" title="cast()重构数据"></a>cast()重构数据</h3><p>我们可以将被拆分的数据转换为一种新形式，使用cast()函数创建每年每种类型的船的总和。</p><pre><code>recasted.ship &lt;- cast(molten.ships, type+year~variable,sum)print(recasted.ship)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>     type year  period  service  incidents1     A   60    135       190      02     A   65    135      2190      73     A   70    135      4865     244     A   75    135      2244     115     B   60    135     62058     686     B   65    135     48979    1117     B   70    135     20163     568     B   75    135      7117     189     C   60    135      1731      210    C   65    135      1457      111    C   70    135      2731      812    C   75    135       274      113    D   60    135       356      014    D   65    135       480      015    D   70    135      1557     1316    D   75    135      2051      417    E   60    135        45      018    E   65    135      1226     1419    E   70    135      3318     1720    E   75    135       542      1</code></pre><h1 id="十一-函数"><a href="#十一-函数" class="headerlink" title="十一.函数"></a>十一.函数</h1><p>函数是一组组合在一起以执行特定任务的语句。 R语言具有大量内置函数，用户可以创建自己的函数。</p><p>在R语言中，函数是一个对象，因此R语言解释器能够将控制传递给函数，以及函数完成动作所需的参数。</p><p>该函数依次执行其任务并将控制返回到解释器以及可以存储在其他对象中的任何结果。</p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>使用关键字函数创建R语言的函数。 R语言的函数定义的基本语法如下</p><pre><code>function_name &lt;- function(arg_1, arg_2, ...) {   Function body }</code></pre><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>函数的不同部分 -</p><ul><li><p>函数名称 -这是函数的实际名称。 它作为具有此名称的对象存储在R环境中。</p></li><li><p>参数 -参数是一个占位符。 当函数被调用时，你传递一个值到参数。 参数是可选的; 也就是说，一个函数可能不包含参数。 参数也可以有默认值。</p></li><li><p>函数体 -函数体包含定义函数的功能的语句集合。</p></li><li><p>返回值 -函数的返回值是要评估的函数体中的最后一个表达式。<br>R语言有许多内置函数，可以在程序中直接调用而无需先定义它们。我们还可以创建和使用我们自己的函数，称为用户定义的函数。</p></li></ul><h3 id="内置功能"><a href="#内置功能" class="headerlink" title="内置功能"></a>内置功能</h3><p>内置函数的简单示例是seq()，mean()，max()，sum(x)和paste(…)等。它们由用户编写的程序直接调用。 您可以参考最广泛使用的R函数。</p><pre><code># Create a sequence of numbers from 32 to 44.print(seq(32,44))# Find mean of numbers from 25 to 82.print(mean(25:82))# Find sum of numbers frm 41 to 68.print(sum(41:68))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 32 33 34 35 36 37 38 39 40 41 42 43 44[1] 53.5[1] 1526</code></pre><h3 id="用户定义的函数"><a href="#用户定义的函数" class="headerlink" title="用户定义的函数"></a>用户定义的函数</h3><p>我们可以在R语言中创建用户定义的函数。它们特定于用户想要的，一旦创建，它们就可以像内置函数一样使用。 下面是一个创建和使用函数的例子。</p><pre><code># Create a function to print squares of numbers in sequence.new.function &lt;- function(a) {   for(i in 1:a) {      b &lt;- i^2      print(b)   }}    </code></pre><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><pre><code># Create a function to print squares of numbers in sequence.new.function &lt;- function(a) {   for(i in 1:a) {      b &lt;- i^2      print(b)   }}# Call the function new.function supplying 6 as an argument.new.function(6)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 1[1] 4[1] 9[1] 16[1] 25[1] 36</code></pre><p>调用没有参数的函数</p><pre><code># Create a function without an argument.new.function &lt;- function() {   for(i in 1:5) {      print(i^2)   }}    # Call the function without supplying an argument.new.function()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 1[1] 4[1] 9[1] 16[1] 25</code></pre><p>使用参数值调用函数（按位置和名称）<br>函数调用的参数可以按照函数中定义的顺序提供，也可以以不同的顺序提供，但分配给参数的名称。</p><pre><code># Create a function with arguments.new.function &lt;- function(a,b,c) {   result &lt;- a * b + c   print(result)}# Call the function by position of arguments.new.function(5,3,11)# Call the function by names of the arguments.new.function(a = 11, b = 5, c = 3)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 26[1] 58</code></pre><p>使用默认参数调用函数<br>我们可以在函数定义中定义参数的值，并调用函数而不提供任何参数以获取默认结果。 但是我们也可以通过提供参数的新值来获得非默认结果来调用这样的函数。</p><pre><code># Create a function with arguments.new.function &lt;- function(a = 3, b = 6) {   result &lt;- a * b   print(result)}# Call the function without giving any argument.new.function()# Call the function with giving new values of the argument.new.function(9,5)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 18[1] 45</code></pre><p>功能的延迟计算<br>对函数的参数进行延迟评估，这意味着它们只有在函数体需要时才进行评估。</p><pre><code># Create a function with arguments.new.function &lt;- function(a, b) {   print(a^2)   print(a)   print(b)}# Evaluate the function without supplying one of the arguments.new.function(6)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 36[1] 6Error in print(b) : argument "b" is missing, with no default</code></pre><h1 id="十二-字符串"><a href="#十二-字符串" class="headerlink" title="十二.字符串"></a>十二.字符串</h1><p>在R语言中的单引号或双引号对中写入的任何值都被视为字符串.R语言存储的每个字符串都在双引号内，即使是使用单引号创建的依旧如此。</p><h3 id="在字符串构造中应用的规则"><a href="#在字符串构造中应用的规则" class="headerlink" title="在字符串构造中应用的规则"></a>在字符串构造中应用的规则</h3><p>在字符串的开头和结尾的引号应该是两个双引号或两个单引号。它们不能被混合。</p><ul><li><p>双引号可以插入到以单引号开头和结尾的字符串中。</p></li><li><p>单引号可以插入以双引号开头和结尾的字符串。</p></li><li><p>双引号不能插入以双引号开头和结尾的字符串。</p></li><li><p>单引号不能插入以单引号开头和结尾的字符串。</p></li></ul><h5 id="有效字符串的示例"><a href="#有效字符串的示例" class="headerlink" title="有效字符串的示例"></a>有效字符串的示例</h5><p>以下示例阐明了在ř 语言中创建³³字符串的规则。</p><pre><code>a &lt;- 'Start and end with single quote'print(a)b &lt;- "Start and end with double quotes"print(b)c &lt;- "single quote ' in between double quotes"print(c)d &lt;- 'Double quotes " in between single quote'print(d)</code></pre><p>当运行上面的代码，我们得到以下输出 -</p><pre><code>[1] "Start and end with single quote"[1] "Start and end with double quotes"[1] "single quote ' in between double quote"[1] "Double quote " in between single quote"</code></pre><h5 id="无效字符串的示例"><a href="#无效字符串的示例" class="headerlink" title="无效字符串的示例"></a>无效字符串的示例</h5><pre><code>e &lt;- 'Mixed quotes" print(e)f &lt;- 'Single quote ' inside single quote'print(f)g &lt;- "Double quotes " inside double quotes"print(g)</code></pre><p>当我们运行脚本失败给下面的结果。</p><pre><code>...: unexpected INCOMPLETE_STRING.... unexpected symbol 1: f &lt;- 'Single quote ' insideunexpected symbol1: g &lt;- "Double quotes " inside</code></pre><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><h5 id="连接字符串-paste（）函数"><a href="#连接字符串-paste（）函数" class="headerlink" title="连接字符串 - paste（）函数"></a>连接字符串 - paste（）函数</h5><p>R 语言中的许多字符串使用paste（）函数组合。它可以采取任何数量的参数组合在一起。</p><p>#####语法<br>对于粘贴功能的基本语法是 -</p><pre><code>paste(..., sep = " ", collapse = NULL)</code></pre><p>以下是所使用的参数的说明 -</p><ul><li><p>…表示要组合的任意数量的自变量。</p></li><li><p>九月表示参数之间的任何分隔符。它是可选的。</p></li><li><p>collapse用于消除两个字符串之间的空格。但不是一个字符串的两个字内的空间。</p></li></ul><p>例</p><pre><code>a &lt;- "Hello"b &lt;- 'How'c &lt;- "are you? "print(paste(a,b,c))print(paste(a,b,c, sep = "-"))print(paste(a,b,c, sep = "", collapse = ""))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "Hello How are you? "[1] "Hello-How-are you? "[1] "HelloHoware you? "</code></pre><h5 id="格式化数字和字符串-format（）函数"><a href="#格式化数字和字符串-format（）函数" class="headerlink" title="格式化数字和字符串 - format（）函数"></a>格式化数字和字符串 - format（）函数</h5><p>可以使用格式（）函数将数字和字符串格式化为特定样式。</p><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>格式化函数的基本语法是 -</p><pre><code>format(x, digits, nsmall, scientific, width, justify = c("left", "right", "centre", "none")) </code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>X是向量输入。</p></li><li><p>数字是显示的总位数。</p></li><li><p>nsmall是小数点右边的最小位数。</p></li><li><p>科学设置为TRUE以显示科学记数法。</p></li><li><p>宽度指示通过在开始处填充空白来显示的最小宽度。</p></li><li><p>理由是字符串向左，右或中心的显示。</p></li></ul><p>例</p><pre><code># Total number of digits displayed. Last digit rounded off.result &lt;- format(23.123456789, digits = 9)print(result)# Display numbers in scientific notation.result &lt;- format(c(6, 13.14521), scientific = TRUE)print(result)# The minimum number of digits to the right of the decimal point.result &lt;- format(23.47, nsmall = 5)print(result)# Format treats everything as a string.result &lt;- format(6)print(result)# Numbers are padded with blank in the beginning for width.result &lt;- format(13.7, width = 6)print(result)# Left justify strings.result &lt;- format("Hello", width = 8, justify = "l")print(result)# Justfy string with center.result &lt;- format("Hello", width = 8, justify = "c")print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "23.1234568"[1] "6.000000e+00" "1.314521e+01"[1] "23.47000"[1] "6"[1] "  13.7"[1] "Hello   "[1] " Hello  "</code></pre><h5 id="计算字符串中的字符数-nchar（）函数"><a href="#计算字符串中的字符数-nchar（）函数" class="headerlink" title="计算字符串中的字符数 - nchar（）函数"></a>计算字符串中的字符数 - nchar（）函数</h5><p>此函数计算字符串中包含空格的字符数。</p><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><p>nchar（）函数的基本语法是 -</p><p>nchar(x)<br>以下是所使用的参数的描述 - </p><ul><li>X是向量输入。</li></ul><p>例</p><pre><code>result &lt;- nchar("Count the number of characters")print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 30</code></pre><h5 id="更改案例-toupper（）和tolower（）函数"><a href="#更改案例-toupper（）和tolower（）函数" class="headerlink" title="更改案例 - toupper（）和tolower（）函数"></a>更改案例 - toupper（）和tolower（）函数</h5><p>这些函数改变字符串的字符的大小写。</p><h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><p>toupper（）和tolower（）函数的基本语法是 -</p><pre><code>toupper(x)tolower(x)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li>X是向量输入。</li></ul><p>例</p><pre><code># Changing to Upper case.result &lt;- toupper("Changing To Upper")print(result)# Changing to lower case.result &lt;- tolower("Changing To Lower")print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "CHANGING TO UPPER"[1] "changing to lower"</code></pre><h5 id="提取字符串的一部分-substring（）函数"><a href="#提取字符串的一部分-substring（）函数" class="headerlink" title="提取字符串的一部分 - substring（）函数"></a>提取字符串的一部分 - substring（）函数</h5><p>此函数提取字符串的部分。</p><h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h5><p>substring（）函数的基本语法是 -</p><pre><code>substring(x,first,last)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>X是字符向量输入。</p></li><li><p>首先是要提取的第一个字符的位置。</p></li><li><p>最后是要提取的最后一个字符的位置。</p></li></ul><p>例</p><pre><code># Extract characters from 5th to 7th position.result &lt;- substring("Extract", 5, 7)print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "act"</code></pre><h1 id="十三-向量"><a href="#十三-向量" class="headerlink" title="十三.向量"></a>十三.向量</h1><p>向量是最基本的R语言数据对象，有六种类型的原子向量。 它们是逻辑，整数，双精度，复杂，字符和原始。</p><h3 id="创建向量"><a href="#创建向量" class="headerlink" title="创建向量"></a>创建向量</h3><h5 id="单元素向量"><a href="#单元素向量" class="headerlink" title="单元素向量"></a>单元素向量</h5><p>即使在R语言中只写入一个值，它也将成为长度为1的向量，并且属于上述向量类型之一。</p><pre><code># Atomic vector of type character.print("abc");# Atomic vector of type double.print(12.5)# Atomic vector of type integer.print(63L)# Atomic vector of type logical.print(TRUE)# Atomic vector of type complex.print(2+3i)# Atomic vector of type raw.print(charToRaw('hello'))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "abc"[1] 12.5[1] 63[1] TRUE[1] 2+3i[1] 68 65 6c 6c 6f</code></pre><h5 id="多元素向量"><a href="#多元素向量" class="headerlink" title="多元素向量"></a>多元素向量</h5><p>对数值数据使用冒号运算符</p><pre><code># Creating a sequence from 5 to 13.v &lt;- 5:13print(v)# Creating a sequence from 6.6 to 12.6.v &lt;- 6.6:12.6print(v)# If the final element specified does not belong to the sequence then it is discarded.v &lt;- 3.8:11.4print(v)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1]  5  6  7  8  9 10 11 12 13[1]  6.6  7.6  8.6  9.6 10.6 11.6 12.6[1]  3.8  4.8  5.8  6.8  7.8  8.8  9.8 10.8</code></pre><h5 id="使用sequence-Seq-序列运算符"><a href="#使用sequence-Seq-序列运算符" class="headerlink" title="使用sequence (Seq.)序列运算符"></a>使用sequence (Seq.)序列运算符</h5><pre><code># Create vector with elements from 5 to 9 incrementing by 0.4.print(seq(5, 9, by = 0.4))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 5.0 5.4 5.8 6.2 6.6 7.0 7.4 7.8 8.2 8.6 9.0</code></pre><h5 id="使用C-函数"><a href="#使用C-函数" class="headerlink" title="使用C()函数"></a>使用C()函数</h5><p>如果其中一个元素是字符，则非字符值被强制转换为字符类型。</p><pre><code># The logical and numeric values are converted to characters.s &lt;- c('apple','red',5,TRUE)print(s)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "apple" "red"   "5"     "TRUE" </code></pre><h3 id="访问向量元素"><a href="#访问向量元素" class="headerlink" title="访问向量元素"></a>访问向量元素</h3><p>使用索引访问向量的元素。 []括号用于建立索引。 索引从位置1开始。在索引中给出负值会丢弃来自result.TRUE，FALSE或0和1的元素，也可用于索引。</p><pre><code># Accessing vector elements using position.t &lt;- c("Sun","Mon","Tue","Wed","Thurs","Fri","Sat")u &lt;- t[c(2,3,6)]print(u)# Accessing vector elements using logical indexing.v &lt;- t[c(TRUE,FALSE,FALSE,FALSE,FALSE,TRUE,FALSE)]print(v)# Accessing vector elements using negative indexing.x &lt;- t[c(-2,-5)]print(x)# Accessing vector elements using 0/1 indexing.y &lt;- t[c(0,0,0,0,0,0,1)]print(y)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "Mon" "Tue" "Fri"[1] "Sun" "Fri"[1] "Sun" "Tue" "Wed" "Fri" "Sat"[1] "Sun"</code></pre><h3 id="向量操作"><a href="#向量操作" class="headerlink" title="向量操作"></a>向量操作</h3><h5 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h5><p>可以添加，减去，相乘或相除两个相同长度的向量，将结果作为向量输出。</p><pre><code># Create two vectors.v1 &lt;- c(3,8,4,5,0,11)v2 &lt;- c(4,11,0,8,1,2)# Vector addition.add.result &lt;- v1+v2print(add.result)# Vector substraction.sub.result &lt;- v1-v2print(sub.result)# Vector multiplication.multi.result &lt;- v1*v2print(multi.result)# Vector division.divi.result &lt;- v1/v2print(divi.result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1]  7 19  4 13  1 13[1] -1 -3  4 -3 -1  9[1] 12 88  0 40  0 22[1] 0.7500000 0.7272727       Inf 0.6250000 0.0000000 5.5000000</code></pre><h5 id="向量元素回收"><a href="#向量元素回收" class="headerlink" title="向量元素回收"></a>向量元素回收</h5><p>如果我们对不等长的两个向量应用算术运算，则较短向量的元素被循环以完成操作。</p><pre><code>v1 &lt;- c(3,8,4,5,0,11)v2 &lt;- c(4,11)# V2 becomes c(4,11,4,11,4,11)add.result &lt;- v1+v2print(add.result)sub.result &lt;- v1-v2print(sub.result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1]  7 19  8 16  4 22[1] -1 -3  0 -6 -4  0</code></pre><h3 id="向量元素排序"><a href="#向量元素排序" class="headerlink" title="向量元素排序"></a>向量元素排序</h3><p>向量中的元素可以使用sort()函数排序。</p><pre><code>v &lt;- c(3,8,4,5,0,11, -9, 304)# Sort the elements of the vector.sort.result &lt;- sort(v)print(sort.result)# Sort the elements in the reverse order.revsort.result &lt;- sort(v, decreasing = TRUE)print(revsort.result)# Sorting character vectors.v &lt;- c("Red","Blue","yellow","violet")sort.result &lt;- sort(v)print(sort.result)# Sorting character vectors in reverse order.revsort.result &lt;- sort(v, decreasing = TRUE)print(revsort.result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1]  -9   0   3   4   5   8  11 304[1] 304  11   8   5   4   3   0  -9[1] "Blue"   "Red"    "violet" "yellow"[1] "yellow" "violet" "Red"    "Blue" </code></pre><p>#十四.列表<br>列表是R语言对象，它包含不同类型的元素，如数字，字符串，向量和其中的另一个列表。列表还可以包含矩阵或函数作为其元素。列表是使用list（）函数创建的。</p><h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><p>以下是创建包含字符串，数字，向量和逻辑值的列表的示例</p><pre><code># Create a list containing strings, numbers, vectors and a logical values.list_data &lt;- list("Red", "Green", c(21,32,11), TRUE, 51.23, 119.1)print(list_data)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[[1]][1] "Red"[[2]][1] "Green"[[3]][1] 21 32 11[[4]][1] TRUE[[5]][1] 51.23[[6]][1] 119.1</code></pre><h3 id="命名列表元素"><a href="#命名列表元素" class="headerlink" title="命名列表元素"></a>命名列表元素</h3><p>列表元素可以给出名称，并且可以使用这些名称访问它们。</p><pre><code># Create a list containing a vector, a matrix and a list.list_data &lt;- list(c("Jan","Feb","Mar"), matrix(c(3,9,5,1,-2,8), nrow = 2),   list("green",12.3))# Give names to the elements in the list.names(list_data) &lt;- c("1st Quarter", "A_Matrix", "A Inner list")# Show the list.print(list_data)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>$`1st_Quarter`[1] "Jan" "Feb" "Mar"$A_Matrix     [,1] [,2] [,3][1,]    3    5   -2[2,]    9    1    8$A_Inner_list$A_Inner_list[[1]][1] "green"$A_Inner_list[[2]][1] 12.3</code></pre><h3 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h3><p>列表的元素可以通过列表中元素的索引访问。在命名列表的情况下，它也可以使用名称来访问。</p><p>我们继续使用在上面的例子列表 -</p><pre><code># Create a list containing a vector, a matrix and a list.list_data &lt;- list(c("Jan","Feb","Mar"), matrix(c(3,9,5,1,-2,8), nrow = 2),   list("green",12.3))# Give names to the elements in the list.names(list_data) &lt;- c("1st Quarter", "A_Matrix", "A Inner list")# Access the first element of the list.print(list_data[1])# Access the thrid element. As it is also a list, all its elements will be printed.print(list_data[3])# Access the list element using the name of the element.print(list_data$A_Matrix)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>$`1st_Quarter`[1] "Jan" "Feb" "Mar"$A_Inner_list$A_Inner_list[[1]][1] "green"$A_Inner_list[[2]][1] 12.3     [,1] [,2] [,3][1,]    3    5   -2[2,]    9    1    8</code></pre><h3 id="操控列表元素"><a href="#操控列表元素" class="headerlink" title="操控列表元素"></a>操控列表元素</h3><p>我们可以添加，删除和更新列表元素，如下所示。我们只能在列表的末尾添加和删除元素。但我们可以更新任何元素。</p><pre><code># Create a list containing a vector, a matrix and a list.list_data &lt;- list(c("Jan","Feb","Mar"), matrix(c(3,9,5,1,-2,8), nrow = 2),   list("green",12.3))# Give names to the elements in the list.names(list_data) &lt;- c("1st Quarter", "A_Matrix", "A Inner list")# Add element at the end of the list.list_data[4] &lt;- "New element"print(list_data[4])# Remove the last element.list_data[4] &lt;- NULL# Print the 4th Element.print(list_data[4])# Update the 3rd Element.list_data[3] &lt;- "updated element"print(list_data[3])</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[[1]][1] "New element"$NULL$`A Inner list`[1] "updated element"</code></pre><h3 id="合并列表"><a href="#合并列表" class="headerlink" title="合并列表"></a>合并列表</h3><p>通过将所有列表放在一个列表（）函数中，您可以将许多列表合并到一个列表中。</p><pre><code># Create two lists.list1 &lt;- list(1,2,3)list2 &lt;- list("Sun","Mon","Tue")# Merge the two lists.merged.list &lt;- c(list1,list2)# Print the merged list.print(merged.list)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[[1]][1] 1[[2]][1] 2[[3]][1] 3[[4]][1] "Sun"[[5]][1] "Mon"[[6]][1] "Tue"</code></pre><h3 id="将列表转换为向量"><a href="#将列表转换为向量" class="headerlink" title="将列表转换为向量"></a>将列表转换为向量</h3><p>列表可以转换为向量，使得向量的元素可以用于进一步的操作。可以在将列表转换为向量之后应用对向量的所有算术运算。要做这个转换，我们使用unlist（）函数。它将列表作为输入并生成向量。</p><pre><code># Create lists.list1 &lt;- list(1:5)print(list1)list2 &lt;-list(10:14)print(list2)# Convert the lists to vectors.v1 &lt;- unlist(list1)v2 &lt;- unlist(list2)print(v1)print(v2)# Now add the vectorsresult &lt;- v1+v2print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[[1]][1] 1 2 3 4 5[[1]][1] 10 11 12 13 14[1] 1 2 3 4 5[1] 10 11 12 13 14[1] 11 13 15 17 19</code></pre><h1 id="十五-矩阵"><a href="#十五-矩阵" class="headerlink" title="十五.矩阵"></a>十五.矩阵</h1><p>矩阵是其中元素以二维矩形布局布置的R对象。 它们包含相同原子类型的元素。 虽然我们可以创建一个只包含字符或只包含逻辑值的矩阵，但它们没有太多用处。 我们使用包含数字元素的矩阵用于数学计算。</p><p>使用matrix()函数创建一个矩阵。</p><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>在R语言中创建矩阵的基本语法是 -</p><pre><code>matrix(data, nrow, ncol, byrow, dimnames)</code></pre><p>以下是所使用的参数的说明 -</p><ul><li><p>数据是成为矩阵的数据元素的输入向量。</p></li><li><p>nrow是要创建的行数。</p></li><li><p>ncol是要创建的列数。</p></li><li><p>byrow是一个逻辑线索。 如果为TRUE，则输入向量元素按行排列。</p></li><li><p>dimname是分配给行和列的名称。</p></li></ul><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>创建一个以数字向量作为输入的矩阵</p><pre><code># Elements are arranged sequentially by row.M &lt;- matrix(c(3:14), nrow = 4, byrow = TRUE)print(M)# Elements are arranged sequentially by column.N &lt;- matrix(c(3:14), nrow = 4, byrow = FALSE)print(N)# Define the column and row names.rownames = c("row1", "row2", "row3", "row4")colnames = c("col1", "col2", "col3")P &lt;- matrix(c(3:14), nrow = 4, byrow = TRUE, dimnames = list(rownames, colnames))print(P)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>     [,1] [,2] [,3][1,]    3    4    5[2,]    6    7    8[3,]    9   10   11[4,]   12   13   14     [,1] [,2] [,3][1,]    3    7   11[2,]    4    8   12[3,]    5    9   13[4,]    6   10   14     col1 col2 col3row1    3    4    5row2    6    7    8row3    9   10   11row4   12   13   14</code></pre><h3 id="访问矩阵的元素"><a href="#访问矩阵的元素" class="headerlink" title="访问矩阵的元素"></a>访问矩阵的元素</h3><p>可以通过使用元素的列和行索引来访问矩阵的元素。 我们考虑上面的矩阵P找到下面的具体元素。</p><pre><code># Define the column and row names.rownames = c("row1", "row2", "row3", "row4")colnames = c("col1", "col2", "col3")# Create the matrix.P &lt;- matrix(c(3:14), nrow = 4, byrow = TRUE, dimnames = list(rownames, colnames))# Access the element at 3rd column and 1st row.print(P[1,3])# Access the element at 2nd column and 4th row.print(P[4,2])# Access only the  2nd row.print(P[2,])# Access only the 3rd column.print(P[,3])</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 5[1] 13col1 col2 col3    6    7    8 row1 row2 row3 row4    5    8   11   14 </code></pre><h3 id="矩阵计算"><a href="#矩阵计算" class="headerlink" title="矩阵计算"></a>矩阵计算</h3><p>使用R运算符对矩阵执行各种数学运算。 操作的结果也是一个矩阵。<br>对于操作中涉及的矩阵，维度（行数和列数）应该相同。</p><h5 id="矩阵加法和减法"><a href="#矩阵加法和减法" class="headerlink" title="矩阵加法和减法"></a>矩阵加法和减法</h5><pre><code># Create two 2x3 matrices.matrix1 &lt;- matrix(c(3, 9, -1, 4, 2, 6), nrow = 2)print(matrix1)matrix2 &lt;- matrix(c(5, 2, 0, 9, 3, 4), nrow = 2)print(matrix2)# Add the matrices.result &lt;- matrix1 + matrix2cat("Result of addition","")print(result)# Subtract the matricesresult &lt;- matrix1 - matrix2cat("Result of subtraction","")print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>     [,1] [,2] [,3][1,]    3   -1    2[2,]    9    4    6     [,1] [,2] [,3][1,]    5    0    3[2,]    2    9    4Result of addition      [,1] [,2] [,3][1,]    8   -1    5[2,]   11   13   10Result of subtraction      [,1] [,2] [,3][1,]   -2   -1   -1[2,]    7   -5    2</code></pre><h5 id="矩阵乘法和除法"><a href="#矩阵乘法和除法" class="headerlink" title="矩阵乘法和除法"></a>矩阵乘法和除法</h5><pre><code># Create two 2x3 matrices.matrix1 &lt;- matrix(c(3, 9, -1, 4, 2, 6), nrow = 2)print(matrix1)matrix2 &lt;- matrix(c(5, 2, 0, 9, 3, 4), nrow = 2)print(matrix2)# Multiply the matrices.result &lt;- matrix1 * matrix2cat("Result of multiplication","")print(result)# Divide the matricesresult &lt;- matrix1 / matrix2cat("Result of division","")print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>     [,1] [,2] [,3][1,]    3   -1    2[2,]    9    4    6     [,1] [,2] [,3][1,]    5    0    3[2,]    2    9    4Result of multiplication      [,1] [,2] [,3][1,]   15    0    6[2,]   18   36   24Result of division      [,1]      [,2]      [,3][1,]  0.6      -Inf 0.6666667[2,]  4.5 0.4444444 1.5000000</code></pre><h1 id="十六-数组"><a href="#十六-数组" class="headerlink" title="十六.数组"></a>十六.数组</h1><p>数组对可以在两个以上维度中存储数据的R数据对象。例如 - 如果我们创建一个维度（2,3,4）的数组，则它创造4个矩形矩阵，每个矩阵具有2行和3列数组只能存储数据类型。<br>使用array（）函数创建数组。它使用向量作为输入，并使用dim参数中的值创建数组。</p><h3 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h3><p>以下示例创建一个由两个3x3的矩阵组成的数组，每个矩阵具有3行和3列。</p><pre><code># Create two vectors of different lengths.vector1 &lt;- c(5,9,3)vector2 &lt;- c(10,11,12,13,14,15)# Take these vectors as input to the array.result &lt;- array(c(vector1,vector2),dim = c(3,3,2))print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>, , 1     [,1] [,2] [,3][1,]    5   10   13[2,]    9   11   14[3,]    3   12   15, , 2     [,1] [,2] [,3][1,]    5   10   13[2,]    9   11   14[3,]    3   12   15</code></pre><h3 id="命名列和行"><a href="#命名列和行" class="headerlink" title="命名列和行"></a>命名列和行</h3><p>我们可以使用dimnames参数给数组中的行，列和矩阵命名。</p><pre><code># Create two vectors of different lengths.vector1 &lt;- c(5,9,3)vector2 &lt;- c(10,11,12,13,14,15)column.names &lt;- c("COL1","COL2","COL3")row.names &lt;- c("ROW1","ROW2","ROW3")matrix.names &lt;- c("Matrix1","Matrix2")# Take these vectors as input to the array.result &lt;- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,column.names,   matrix.names))print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>, , Matrix1     COL1 COL2 COL3ROW1    5   10   13ROW2    9   11   14ROW3    3   12   15, , Matrix2     COL1 COL2 COL3ROW1    5   10   13ROW2    9   11   14ROW3    3   12   15</code></pre><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><pre><code># Create two vectors of different lengths.vector1 &lt;- c(5,9,3)vector2 &lt;- c(10,11,12,13,14,15)column.names &lt;- c("COL1","COL2","COL3")row.names &lt;- c("ROW1","ROW2","ROW3")matrix.names &lt;- c("Matrix1","Matrix2")# Take these vectors as input to the array.result &lt;- array(c(vector1,vector2),dim = c(3,3,2),dimnames = list(row.names,   column.names, matrix.names))# Print the third row of the second matrix of the array.print(result[3,,2])# Print the element in the 1st row and 3rd column of the 1st matrix.print(result[1,3,1])# Print the 2nd Matrix.print(result[,,2])</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>COL1 COL2 COL3    3   12   15 [1] 13     COL1 COL2 COL3ROW1    5   10   13ROW2    9   11   14ROW3    3   12   15</code></pre><h3 id="操作数组元素"><a href="#操作数组元素" class="headerlink" title="操作数组元素"></a>操作数组元素</h3><p>由于数组由多维构成矩阵，所以对数组元素的操作通过访问矩阵的元素来执行。</p><pre><code># Create two vectors of different lengths.vector1 &lt;- c(5,9,3)vector2 &lt;- c(10,11,12,13,14,15)# Take these vectors as input to the array.array1 &lt;- array(c(vector1,vector2),dim = c(3,3,2))# Create two vectors of different lengths.vector3 &lt;- c(9,1,0)vector4 &lt;- c(6,0,11,3,14,1,2,6,9)array2 &lt;- array(c(vector1,vector2),dim = c(3,3,2))# create matrices from these arrays.matrix1 &lt;- array1[,,2]matrix2 &lt;- array2[,,2]# Add the matrices.result &lt;- matrix1+matrix2print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>     [,1] [,2] [,3][1,]   10   20   26[2,]   18   22   28[3,]    6   24   30</code></pre><h3 id="跨数组元素的计算"><a href="#跨数组元素的计算" class="headerlink" title="跨数组元素的计算"></a>跨数组元素的计算</h3><p>我们可以使用适用（）函数在数组中的元素上进行计算。</p><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><pre><code>apply(x, margin, fun)</code></pre><p>以下是所使用的参数的说明 -</p><ul><li><p>X是一个数组。</p></li><li><p>保证金是所使用的数据集的名称。</p></li><li><p>有趣的是要应用于数组元素的函数。</p></li></ul><p>例<br>我们使用下面的适用（）函数计算所有矩阵中数组行中元素的总和。</p><pre><code># Create two vectors of different lengths.vector1 &lt;- c(5,9,3)vector2 &lt;- c(10,11,12,13,14,15)# Take these vectors as input to the array.new.array &lt;- array(c(vector1,vector2),dim = c(3,3,2))print(new.array)# Use apply to calculate the sum of the rows across all the matrices.result &lt;- apply(new.array, c(1), sum)print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>, , 1     [,1] [,2] [,3][1,]    5   10   13[2,]    9   11   14[3,]    3   12   15, , 2     [,1] [,2] [,3][1,]    5   10   13[2,]    9   11   14[3,]    3   12   15[1] 56 68 60</code></pre><p>#十七.因子<br>因子是用于对数据进行分类并将其存储为级别的数据对象。 它们可以存储字符串和整数。 它们在具有有限数量的唯一值的列中很有用。 像“男性”，“女性”和True，False等。它们在统计建模的数据分析中很有用。<br>使用factor()函数通过将向量作为输入创建因子。<br>例</p><pre><code># Create a vector as input.data &lt;- c("East","West","East","North","North","East","West","West","West","East","North")print(data)print(is.factor(data))# Apply the factor function.factor_data &lt;- factor(data)print(factor_data)print(is.factor(factor_data))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code> [1] "East"  "West"  "East"  "North" "North" "East"  "West"  "West"  "West"  "East" "North"[1] FALSE [1] East  West  East  North North East  West  West  West  East  NorthLevels: East North West[1] TRUE</code></pre><h3 id="数据帧的因子"><a href="#数据帧的因子" class="headerlink" title="数据帧的因子"></a>数据帧的因子</h3><p>在创建具有文本数据列的任何数据框时，R语言将文本列视为分类数据并在其上创建因子。</p><pre><code># Create the vectors for data frame.height &lt;- c(132,151,162,139,166,147,122)weight &lt;- c(48,49,66,53,67,52,40)gender &lt;- c("male","male","female","female","male","female","male")# Create the data frame.input_data &lt;- data.frame(height,weight,gender)print(input_data)# Test if the gender column is a factor.print(is.factor(input_data$gender))# Print the gender column so see the levels.print(input_data$gender)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>  height weight gender1    132     48   male2    151     49   male3    162     66 female4    139     53 female5    166     67   male6    147     52 female7    122     40   male[1] TRUE[1] male   male   female female male   female male  Levels: female male</code></pre><h3 id="更改级别顺序"><a href="#更改级别顺序" class="headerlink" title="更改级别顺序"></a>更改级别顺序</h3><p>可以通过使用新的等级次序再次应用因子函数来改变因子中的等级的顺序。</p><pre><code>data &lt;- c("East","West","East","North","North","East","West","West","West","East","North")# Create the factorsfactor_data &lt;- factor(data)print(factor_data)# Apply the factor function with required order of the level.new_order_data &lt;- factor(factor_data,levels = c("East","West","North"))print(new_order_data)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code> [1] East  West  East  North North East  West  West  West  East  NorthLevels: East North West [1] East  West  East  North North East  West  West  West  East  NorthLevels: East West North</code></pre><h3 id="生成因子级别"><a href="#生成因子级别" class="headerlink" title="生成因子级别"></a>生成因子级别</h3><p>我们可以使用gl()函数生成因子级别。 它需要两个整数作为输入，指示每个级别有多少级别和多少次。</p><p>语法</p><pre><code>gl(n, k, labels)</code></pre><p>以下是所使用的参数的说明 -</p><ul><li><p>n是给出级数的整数。</p></li><li><p>k是给出复制数目的整数。</p></li><li><p>labels是所得因子水平的标签向量。</p></li></ul><p>例</p><pre><code>v &lt;- gl(3, 4, labels = c("Tampa", "Seattle","Boston"))print(v)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Tampa   Tampa   Tampa   Tampa   Seattle Seattle Seattle Seattle Boston [10] Boston  Boston  Boston Levels: Tampa Seattle Boston</code></pre><p>#十八.数据帧<br>数据帧是表或二维阵列状结构，其中每一列包含一个变量的值，并且每一行包含来自每一列的一组值。<br>以下是数据帧的特性。</p><ul><li><p>列名称应为非空。</p></li><li><p>行名称应该是唯一的。</p></li><li><p>存储在数据帧中的数据可以是数字，因子或字符类型。</p></li><li><p>每个列应包含相同数量的数据项。</p><h3 id="创建数据帧"><a href="#创建数据帧" class="headerlink" title="创建数据帧"></a>创建数据帧</h3><pre><code># Create the data frame.emp.data &lt;- data.frame( emp_id = c (1:5),  emp_name = c("Rick","Dan","Michelle","Ryan","Gary"), salary = c(623.3,515.2,611.0,729.0,843.25),  start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11",    "2015-03-27")), stringsAsFactors = FALSE)# Print the data frame.            print(emp.data) </code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>emp_id    emp_name     salary     start_date1     1     Rick        623.30     2012-01-012     2     Dan         515.20     2013-09-233     3     Michelle    611.00     2014-11-154     4     Ryan        729.00     2014-05-115     5     Gary        843.25     2015-03-27</code></pre><h3 id="获取数据帧的结构"><a href="#获取数据帧的结构" class="headerlink" title="获取数据帧的结构"></a>获取数据帧的结构</h3><p>通过使用str()函数可以看到数据帧的结构。</p><pre><code># Create the data frame.emp.data &lt;- data.frame( emp_id = c (1:5),  emp_name = c("Rick","Dan","Michelle","Ryan","Gary"), salary = c(623.3,515.2,611.0,729.0,843.25),  start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11",    "2015-03-27")), stringsAsFactors = FALSE)# Get the structure of the data frame.str(emp.data)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>'data.frame':   5 obs. of  4 variables:$ emp_id    : int  1 2 3 4 5$ emp_name  : chr  "Rick" "Dan" "Michelle" "Ryan" ...$ salary    : num  623 515 611 729 843$ start_date: Date, format: "2012-01-01" "2013-09-23" "2014-11-15" "2014-05-11" ...</code></pre><h3 id="数据框中的数据摘要"><a href="#数据框中的数据摘要" class="headerlink" title="数据框中的数据摘要"></a>数据框中的数据摘要</h3><p>可以通过应用summary()函数获取数据的统计摘要和性质。</p><pre><code># Create the data frame.emp.data &lt;- data.frame( emp_id = c (1:5),  emp_name = c("Rick","Dan","Michelle","Ryan","Gary"), salary = c(623.3,515.2,611.0,729.0,843.25),  start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11",    "2015-03-27")), stringsAsFactors = FALSE)# Print the summary.print(summary(emp.data))  </code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>   emp_id    emp_name             salary        start_date        Min.   :1   Length:5           Min.   :515.2   Min.   :2012-01-01  1st Qu.:2   Class :character   1st Qu.:611.0   1st Qu.:2013-09-23  Median :3   Mode  :character   Median :623.3   Median :2014-05-11  Mean   :3                      Mean   :664.4   Mean   :2014-01-14  3rd Qu.:4                      3rd Qu.:729.0   3rd Qu.:2014-11-15  Max.   :5                      Max.   :843.2   Max.   :2015-03-27 </code></pre><h3 id="从数据帧提取数据"><a href="#从数据帧提取数据" class="headerlink" title="从数据帧提取数据"></a>从数据帧提取数据</h3><p>使用列名称从数据框中提取特定列。</p><pre><code># Create the data frame.emp.data &lt;- data.frame( emp_id = c (1:5), emp_name = c("Rick","Dan","Michelle","Ryan","Gary"), salary = c(623.3,515.2,611.0,729.0,843.25), start_date = as.Date(c("2012-01-01","2013-09-23","2014-11-15","2014-05-11",    "2015-03-27")), stringsAsFactors = FALSE)# Extract Specific columns.result &lt;- data.frame(emp.data$emp_name,emp.data$salary)print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>emp.data.emp_name emp.data.salary1              Rick          623.302               Dan          515.203          Michelle          611.004              Ryan          729.005              Gary          843.25</code></pre><p>先提取前两行，然后提取所有列</p><pre><code># Create the data frame.emp.data &lt;- data.frame( emp_id = c (1:5), emp_name = c("Rick","Dan","Michelle","Ryan","Gary"), salary = c(623.3,515.2,611.0,729.0,843.25), start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11",    "2015-03-27")), stringsAsFactors = FALSE)# Extract first two rows.result &lt;- emp.data[1:2,]print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>emp_id    emp_name   salary    start_date1      1     Rick      623.3     2012-01-012      2     Dan       515.2     2013-09-23</code></pre><p>用第2和第4列提取第3和第5行</p><pre><code># Create the data frame.emp.data &lt;- data.frame( emp_id = c (1:5),  emp_name = c("Rick","Dan","Michelle","Ryan","Gary"), salary = c(623.3,515.2,611.0,729.0,843.25),   start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11",    "2015-03-27")), stringsAsFactors = FALSE)# Extract 3rd and 5th row with 2nd and 4th column.result &lt;- emp.data[c(3,5),c(2,4)]print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>emp_name start_date3 Michelle 2014-11-155     Gary 2015-03-27</code></pre><h3 id="扩展数据帧"><a href="#扩展数据帧" class="headerlink" title="扩展数据帧"></a>扩展数据帧</h3><p>可以通过添加列和行来扩展数据帧。</p></li></ul><h3 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h3><p>只需使用新的列名称添加列向量。</p><pre><code># Create the data frame.emp.data &lt;- data.frame(   emp_id = c (1:5),    emp_name = c("Rick","Dan","Michelle","Ryan","Gary"),   salary = c(623.3,515.2,611.0,729.0,843.25),    start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11",      "2015-03-27")),   stringsAsFactors = FALSE)# Add the "dept" coulmn.emp.data$dept &lt;- c("IT","Operations","IT","HR","Finance")v &lt;- emp.dataprint(v)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>  emp_id   emp_name    salary    start_date       dept1     1    Rick        623.30    2012-01-01       IT2     2    Dan         515.20    2013-09-23       Operations3     3    Michelle    611.00    2014-11-15       IT4     4    Ryan        729.00    2014-05-11       HR5     5    Gary        843.25    2015-03-27       Finance</code></pre><h3 id="添加行"><a href="#添加行" class="headerlink" title="添加行"></a>添加行</h3><p>要将更多行永久添加到现有数据帧，我们需要引入与现有数据帧相同结构的新行，并使用rbind()函数。<br>在下面的示例中，我们创建一个包含新行的数据帧，并将其与现有数据帧合并以创建最终数据帧。</p><pre><code># Create the first data frame.emp.data &lt;- data.frame(   emp_id = c (1:5),    emp_name = c("Rick","Dan","Michelle","Ryan","Gary"),   salary = c(623.3,515.2,611.0,729.0,843.25),    start_date = as.Date(c("2012-01-01", "2013-09-23", "2014-11-15", "2014-05-11",      "2015-03-27")),   dept = c("IT","Operations","IT","HR","Finance"),   stringsAsFactors = FALSE)# Create the second data frameemp.newdata &lt;-     data.frame(   emp_id = c (6:8),    emp_name = c("Rasmi","Pranab","Tusar"),   salary = c(578.0,722.5,632.8),    start_date = as.Date(c("2013-05-21","2013-07-30","2014-06-17")),   dept = c("IT","Operations","Fianance"),   stringsAsFactors = FALSE)# Bind the two data frames.emp.finaldata &lt;- rbind(emp.data,emp.newdata)print(emp.finaldata)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>  emp_id     emp_name    salary     start_date       dept1      1     Rick        623.30     2012-01-01       IT2      2     Dan         515.20     2013-09-23       Operations3      3     Michelle    611.00     2014-11-15       IT4      4     Ryan        729.00     2014-05-11       HR5      5     Gary        843.25     2015-03-27       Finance6      6     Rasmi       578.00     2013-05-21       IT7      7     Pranab      722.50     2013-07-30       Operations8      8     Tusar       632.80     2014-06-17       Fianance</code></pre><h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h3 id="1-条形图"><a href="#1-条形图" class="headerlink" title="1.条形图"></a>1.条形图</h3><p>条形图表示矩形条中的数据，条的长度与变量的值成比例。 R语言使用函数barplot()创建条形图。 R语言可以在条形图中绘制垂直和水平条。 在条形图中，每个条可以给予不同的颜色。</p><h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><p>在R语言中创建条形图的基本语法是 -</p><pre><code>barplot(H, xlab, ylab, main, names.arg, col)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>H是包含在条形图中使用的数值的向量或矩阵。</p></li><li><p>xlab是x轴的标签。</p></li><li><p>ylab是y轴的标签。</p></li><li><p>main是条形图的标题。</p></li><li><p>names.arg是在每个条下出现的名称的向量。</p></li><li><p>col用于向图中的条形提供颜色。</p></li></ul><h3 id="例-2"><a href="#例-2" class="headerlink" title="例"></a>例</h3><p>使用输入向量和每个条的名称创建一个简单的条形图。<br>以下脚本将创建并保存当前R语言工作目录中的条形图。</p><pre><code># Give the chart file a name.png(file = "barchart.png")# Plot the bar chart.barplot(H)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-af941155a8438fb8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="，使用R条形图"></p><h3 id="条形图标签，标题和颜色"><a href="#条形图标签，标题和颜色" class="headerlink" title="条形图标签，标题和颜色"></a>条形图标签，标题和颜色</h3><p>可以通过添加更多参数来扩展条形图的功能。 主要参数用于添加标题。 col参数用于向条形添加颜色。 args.name是具有与输入向量相同数量的值的向量，以描述每个条的含义。</p><h3 id="例-3"><a href="#例-3" class="headerlink" title="例"></a>例</h3><p>以下脚本将在当前R语言工作目录中创建并保存条形图。</p><pre><code># Create the data for the chart.H &lt;- c(7,12,28,3,41)M &lt;- c("Mar","Apr","May","Jun","Jul")# Give the chart file a name.png(file = "barchart_months_revenue.png")# Plot the bar chart.barplot(H,names.arg = M,xlab = "Month",ylab = "Revenue",col = "blue",main = "Revenue chart",border = "red")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a3dc0f0b8e0d50aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="条形图使用R型"></p><h3 id="组合条形图和堆积条形图"><a href="#组合条形图和堆积条形图" class="headerlink" title="组合条形图和堆积条形图"></a>组合条形图和堆积条形图</h3><p>我们可以使用矩阵作为输入值，在每个条中创建条形图和堆叠组的条形图。<br>超过两个变量表示为用于创建组合条形图和堆叠条形图的矩阵。</p><pre><code># Create the input vectors.colors &lt;- c("green","orange","brown")months &lt;- c("Mar","Apr","May","Jun","Jul")regions &lt;- c("East","West","North")# Create the matrix of the values.Values &lt;- matrix(c(2,9,3,11,9,4,8,7,3,12,5,2,8,10,11),nrow = 3,ncol = 5,byrow = TRUE)# Give the chart file a name.png(file = "barchart_stacked.png")# Create the bar chart.barplot(Values,main = "total revenue",names.arg = months,xlab = "month",ylab = "revenue",   col = colors)# Add the legend to the chart.legend("topleft", regions, cex = 1.3, fill = colors)# Save the file.dev.off()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-3ef47da5f49d5985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="，使用R堆叠条形图"></p><h1 id="2-箱线图"><a href="#2-箱线图" class="headerlink" title="2.箱线图"></a>2.箱线图</h1><p>箱线图是数据集中的数据分布良好的度量。 它将数据集分成三个四分位数。 此图表表示数据集中的最小值，最大值，中值，第一四分位数和第三四分位数。 它还可用于通过绘制每个数据集的箱线图来比较数据集之间的数据分布。</p><p>R语言中使用boxplot()函数来创建箱线图。</p><h3 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h3><p>在R语言中创建箱线图的基本语法是 -</p><pre><code>boxplot(x, data, notch, varwidth, names, main)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>x是向量或公式。</p></li><li><p>数据是数据帧。</p></li><li><p>notch是逻辑值。 设置为TRUE以绘制凹口。</p></li><li><p>varwidth是一个逻辑值。 设置为true以绘制与样本大小成比例的框的宽度。</p></li><li><p>names是将打印在每个箱线图下的组标签。</p></li><li><p>main用于给图表标题。</p></li></ul><h3 id="例-4"><a href="#例-4" class="headerlink" title="例"></a>例</h3><p>我们使用R语言环境中可用的数据集“mtcars”来创建基本箱线图。 让我们看看mtcars中的列“mpg”和“cyl”。</p><pre><code>input &lt;- mtcars[,c('mpg','cyl')]print(head(input))</code></pre><p>当我们执行上面的代码，它会产生以下结果 -</p><pre><code>                  mpg  cylMazda RX4         21.0   6Mazda RX4 Wag     21.0   6Datsun 710        22.8   4Hornet 4 Drive    21.4   6Hornet Sportabout 18.7   8Valiant           18.1   6</code></pre><h3 id="创建箱线图"><a href="#创建箱线图" class="headerlink" title="创建箱线图"></a>创建箱线图</h3><p>以下脚本将为mpg（英里/加仑）和cyl（气缸数）之间的关系创建箱线图。</p><pre><code># Give the chart file a name.png(file = "boxplot.png")# Plot the chart.boxplot(mpg ~ cyl, data = mtcars, xlab = "Number of Cylinders",   ylab = "Miles Per Gallon", main = "Mileage Data")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-7cc9e4b9fd59b64c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="#"></p><h3 id="带槽的箱线图"><a href="#带槽的箱线图" class="headerlink" title="带槽的箱线图"></a>带槽的箱线图</h3><p>我们可以绘制带槽的箱线图，以了解不同数据组的中值如何相互匹配。<br>以下脚本将为每个数据组创建一个带缺口的箱线图。</p><pre><code># Give the chart file a name.png(file = "boxplot_with_notch.png")# Plot the chart.boxplot(mpg ~ cyl, data = mtcars,    xlab = "Number of Cylinders",   ylab = "Miles Per Gallon",    main = "Mileage Data",   notch = TRUE,    varwidth = TRUE,    col = c("green","yellow","purple"),   names = c("High","Medium","Low"))# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p>[图片上传中…(image-9f3e39-1552623568628-0)]</p><h1 id="3-直方图"><a href="#3-直方图" class="headerlink" title="3.直方图"></a>3.直方图</h1><p>直方图表示被存储到范围中的变量的值的频率。 直方图类似于条形图，但不同之处在于将值分组为连续范围。 直方图中的每个柱表示该范围中存在的值的数量的高度。</p><p>R语言使用hist()函数创建直方图。 此函数使用向量作为输入，并使用一些更多的参数来绘制直方图。</p><h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><p>使用R语言创建直方图的基本语法是 -</p><pre><code>hist(v,main,xlab,xlim,ylim,breaks,col,border)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>v是包含直方图中使用的数值的向量。</p></li><li><p>main表示图表的标题。</p></li><li><p>col用于设置条的颜色。</p></li><li><p>border用于设置每个条的边框颜色。</p></li><li><p>xlab用于给出x轴的描述。</p></li><li><p>xlim用于指定x轴上的值的范围。</p></li><li><p>ylim用于指定y轴上的值的范围。</p></li><li><p>break用于提及每个条的宽度。</p></li></ul><h3 id="例-5"><a href="#例-5" class="headerlink" title="例"></a>例</h3><p>使用输入vector，label，col和边界参数创建一个简单的直方图。<br>下面给出的脚本将创建并保存当前R语言工作目录中的直方图。</p><pre><code># Create data for the graph.v &lt;-  c(9,13,21,8,36,22,12,41,31,33,19)# Give the chart file a name.png(file = "histogram.png")# Create the histogram.hist(v,xlab = "Weight",col = "yellow",border = "blue")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-454ddc512d1ede06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="直方图诉"></p><h3 id="X和Y值的范围"><a href="#X和Y值的范围" class="headerlink" title="X和Y值的范围"></a>X和Y值的范围</h3><p>要指定X轴和Y轴允许的值的范围，我们可以使用<strong>xlim</strong>和<strong>ylim</strong>参数。<br>每个条的宽度可以通过使用间隔来确定。</p><pre><code># Create data for the graph.v &lt;- c(9,13,21,8,36,22,12,41,31,33,19)# Give the chart file a name.png(file = "histogram_lim_breaks.png")# Create the histogram.hist(v,xlab = "Weight",col = "green",border = "red", xlim = c(0,40), ylim = c(0,5),   breaks = 5)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p>[图片上传中…(image-d6f09b-1552623852107-0)]</p><h1 id="4-折线图"><a href="#4-折线图" class="headerlink" title="4.折线图"></a>4.折线图</h1><p>折线图是通过在它们之间绘制线段来连接一系列点的图。这些点在它们的坐标（通常是x坐标）值之一中排序。折线图通常用于识别数据中的趋势。</p><p>R语言中的情节（）函数用于创建折线图。</p><p>###语法<br>在R语言中创建折线图的基本语法是 -</p><pre><code>plot(v,type,col,xlab,ylab)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>是包含数值的向量。</p></li><li><p>类型采用值“P”仅绘制点，“升”仅绘制线和“o”的绘制点和线。</p></li><li><p>xlab是X轴的标签。</p></li><li><p>ylab是Ÿ轴的标签。</p></li><li><p>主要是图表的标题。</p></li><li><p>山坳用于给点和线的颜色。</p><h3 id="例-6"><a href="#例-6" class="headerlink" title="例"></a>例</h3></li></ul><p>使用输入向量和类型参数“O”创建简单的折线图。以下脚本将在当前R工作目录中创建并保存折线图。</p><pre><code># Create the data for the chart.v &lt;- c(7,12,28,3,41)# Give the chart file a name.png(file = "line_chart.jpg")# Plot the bar chart. plot(v,type = "o")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p>[图片上传中…(image-469771-1552624000469-2)]</p><h3 id="折线图标题，颜色和标签"><a href="#折线图标题，颜色和标签" class="headerlink" title="折线图标题，颜色和标签"></a>折线图标题，颜色和标签</h3><p>线图的特征可以通过使用附加参数来扩展。我们向点和线添加颜色，为图表添加标题，并向轴添加标签。</p><h3 id="例-7"><a href="#例-7" class="headerlink" title="例"></a>例</h3><pre><code># Create the data for the chart.v &lt;- c(7,12,28,3,41)# Give the chart file a name.png(file = "line_chart_label_colored.jpg")# Plot the bar chart.plot(v,type = "o", col = "red", xlab = "Month", ylab = "Rain fall",   main = "Rain fall chart")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-72f5dbe282491b3f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="折线图标记在ř型"></p><h3 id="多线型折线图"><a href="#多线型折线图" class="headerlink" title="多线型折线图"></a>多线型折线图</h3><p>通过使用lines（）函数，可以在同一个图表上绘制多条线。<br>在绘制第一行之后，lines （）函数可以使用一个额外的向量作为输入来绘制图表中的第二行。</p><pre><code># Create the data for the chart.v &lt;- c(7,12,28,3,41)t &lt;- c(14,7,6,19,3)# Give the chart file a name.png(file = "line_chart_2_lines.jpg")# Plot the bar chart.plot(v,type = "o",col = "red", xlab = "Month", ylab = "Rain fall",    main = "Rain fall chart")lines(t, type = "o", col = "blue")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-d6bf122981e16411.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="折线图与ř中多行"></p><h1 id="5-散点图"><a href="#5-散点图" class="headerlink" title="5.散点图"></a>5.散点图</h1><p>散点图显示在笛卡尔平面中绘制的许多点。 每个点表示两个变量的值。 在水平轴上选择一个变量，在垂直轴上选择另一个变量。<br>使用plot()函数创建简单散点图。</p><h3 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h3><p>在R语言中创建散点图的基本语法是 -</p><pre><code>plot(x, y, main, xlab, ylab, xlim, ylim, axes)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>x是其值为水平坐标的数据集。</p></li><li><p>y是其值是垂直坐标的数据集。</p></li><li><p>main要是图形的图块。</p></li><li><p>xlab是水平轴上的标签。</p></li><li><p>ylab是垂直轴上的标签。</p></li><li><p>xlim是用于绘图的x的值的极限。</p></li><li><p>ylim是用于绘图的y的值的极限。</p></li><li><p>axes指示是否应在绘图上绘制两个轴。</p></li></ul><h3 id="例-8"><a href="#例-8" class="headerlink" title="例"></a>例</h3><p>我们使用R语言环境中可用的数据集“mtcars”来创建基本散点图。 让我们使用mtcars中的“wt”和“mpg”列。</p><pre><code>input &lt;- mtcars[,c('wt','mpg')]print(head(input))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>              wt      mpgMazda RX4           2.620   21.0Mazda RX4 Wag       2.875   21.0Datsun 710          2.320   22.8Hornet 4 Drive      3.215   21.4Hornet Sportabout   3.440   18.7Valiant             3.460   18.1</code></pre><h3 id="创建散点图"><a href="#创建散点图" class="headerlink" title="创建散点图"></a>创建散点图</h3><p>以下脚本将为wt（重量）和mpg（英里/加仑）之间的关系创建一个散点图。</p><pre><code># Get the input values.input &lt;- mtcars[,c('wt','mpg')]# Give the chart file a name.png(file = "scatterplot.png")# Plot the chart for cars with weight between 2.5 to 5 and mileage between 15 and 30.plot(x = input$wt,y = input$mpg,   xlab = "Weight",   ylab = "Milage",   xlim = c(2.5,5),   ylim = c(15,30),            main = "Weight vs Milage")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a7bdc1378f986796.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="，使用R散点图"></p><h3 id="散点图矩阵"><a href="#散点图矩阵" class="headerlink" title="散点图矩阵"></a>散点图矩阵</h3><p>当我们有两个以上的变量，我们想找到一个变量和其余变量之间的相关性，我们使用散点图矩阵。 我们使用<strong>pairs()</strong>函数创建散点图的矩阵。</p><h3 id="语法-10"><a href="#语法-10" class="headerlink" title="语法"></a>语法</h3><p>在R中创建散点图矩阵的基本语法是 -</p><pre><code>pairs(formula, data)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>formula</strong>表示成对使用的一系列变量。</p></li><li><p><strong>data</strong>表示将从其获取变量的数据集。</p></li></ul><h3 id="例-9"><a href="#例-9" class="headerlink" title="例"></a>例</h3><p>每个变量与每个剩余变量配对。 为每对绘制散点图。</p><pre><code># Give the chart file a name.png(file = "scatterplot_matrices.png")# Plot the matrices between 4 variables giving 12 plots.# One variable with 3 others and total 4 variables.pairs(~wt+mpg+disp+cyl,data = mtcars,   main = "Scatterplot Matrix")# Save the file.dev.off()</code></pre><p>当执行上面的代码中，我们得到以下输出。</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-ee1ea88d0af3338a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="散点图矩阵，使用R"></p><h1 id="6-饼状图"><a href="#6-饼状图" class="headerlink" title="6.饼状图"></a>6.饼状图</h1><p>R编程语言有许多库来创建图表和图表。 饼图是将值表示为具有不同颜色的圆的切片。 切片被标记，并且对应于每个片的数字也在图表中表示。<br>在R语言中，饼图是使用pie()函数创建的，它使用正数作为向量输入。 附加参数用于控制标签，颜色，标题等。</p><h3 id="语法-11"><a href="#语法-11" class="headerlink" title="语法"></a>语法</h3><p>使用R语言创建饼图的基本语法是 -</p><pre><code>pie(x, labels, radius, main, col, clockwise)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>x是包含饼图中使用的数值的向量。</p></li><li><p>labels用于给出切片的描述。</p></li><li><p>radius表示饼图圆的半径（值-1和+1之间）。</p></li><li><p>main表示图表的标题。</p></li><li><p>col表示调色板。</p></li><li><p>clockwise是指示片段是顺时针还是逆时针绘制的逻辑值。</p><h3 id="例-10"><a href="#例-10" class="headerlink" title="例"></a>例</h3></li></ul><p>使用输入向量和标签创建一个非常简单的饼图。 以下脚本将创建并保存当前R语言工作目录中的饼图。</p><pre><code># Create data for the graph.x &lt;- c(21, 62, 10, 53)labels &lt;- c("London", "New York", "Singapore", "Mumbai")# Give the chart file a name.png(file = "city.jpg")# Plot the chart.pie(x,labels)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-4755d4a765c7629f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="#"></p><h3 id="饼图标题和颜色"><a href="#饼图标题和颜色" class="headerlink" title="饼图标题和颜色"></a>饼图标题和颜色</h3><p>我们可以通过向函数中添加更多参数来扩展图表的功能。 我们将使用参数+ + <strong>main</strong>向图表添加标题，另一个参数是<strong>col</strong>，它将在绘制图表时使用彩虹色板。 托盘的长度应与图表中的值的数量相同。 因此，我们使用<strong>length(x)</strong>。</p><h3 id="例-11"><a href="#例-11" class="headerlink" title="例"></a>例</h3><p>以下脚本将创建并保存当前R语言工作目录中的饼图。</p><pre><code># Create data for the graph.x &lt;- c(21, 62, 10, 53)labels &lt;- c("London", "New York", "Singapore", "Mumbai")# Give the chart file a name.png(file = "city_title_colours.jpg")# Plot the chart with title and rainbow color pallet.pie(x, labels, main = "City pie chart", col = rainbow(length(x)))# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-04c9f73085247abe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="饼图以标题和颜色"></p><h3 id="切片百分比和图表图例"><a href="#切片百分比和图表图例" class="headerlink" title="切片百分比和图表图例"></a>切片百分比和图表图例</h3><p>我们可以通过创建其他图表变量来添加切片百分比和图表图例。</p><pre><code># Create data for the graph.x &lt;-  c(21, 62, 10,53)labels &lt;-  c("London","New York","Singapore","Mumbai")piepercent&lt;- round(100*x/sum(x), 1)# Give the chart file a name.png(file = "city_percentage_legends.jpg")# Plot the chart.pie(x, labels = piepercent, main = "City pie chart",col = rainbow(length(x)))legend("topright", c("London","New York","Singapore","Mumbai"), cex = 0.8,   fill = rainbow(length(x)))# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p>[图片上传中…(image-f4714e-1552624406629-1)]</p><h3 id="3D饼图"><a href="#3D饼图" class="headerlink" title="3D饼图"></a>3D饼图</h3><p>可以使用其他软件包绘制具有3个维度的饼图。 软件包plotrix有一个名为pie3D（）的函数，用于此。</p><pre><code># Get the library.library(plotrix)# Create data for the graph.x &lt;-  c(21, 62, 10,53)lbl &lt;-  c("London","New York","Singapore","Mumbai")# Give the chart file a name.png(file = "3d_pie_chart.jpg")# Plot the chart.pie3D(x,labels = lbl,explode = 0.1, main = "Pie Chart of Countries ")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-1463f87a12242a45.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3D饼图"></p><h1 id="7-CSV文件"><a href="#7-CSV文件" class="headerlink" title="7.CSV文件"></a>7.CSV文件</h1><p>在R语言中，我们可以从存储在R语言环境外的文件中读取数据。我们还可以将数据写入将被操作系统存储和访问的文件.R语言可以读取和写入各种文件格式，如CSV，EXCEL，XML等。</p><p>在本章中，我们将学习从csv文件读取数据，然后将数据写入csv文件。该文件应该存在于当前工作目录中，以便R语言可以读取它。当然我们也可以设置我们自己的目录并从那里读取文件。</p><h3 id="获取和设置工作目录"><a href="#获取和设置工作目录" class="headerlink" title="获取和设置工作目录"></a>获取和设置工作目录</h3><p>您可以使用getwd（）函数检查R语言工作区指向的目录。您还可以使用setwd（）函数设置新的工作目录。</p><pre><code># Get and print current working directory.print(getwd())# Set current working directory.setwd("/web/com")# Get and print current working directory.print(getwd())</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] "/web/com/1441086124_2016"[1] "/web/com"</code></pre><p>此结果取决于您的操作系统和您当前工作的目录。</p><h3 id="输入为CSV文件"><a href="#输入为CSV文件" class="headerlink" title="输入为CSV文件"></a>输入为CSV文件</h3><p>CSV文件是一个文本文件，其中列中的值由逗号分隔。让我们考虑名为input.csv的文件中出现的以下数据。<br>您可以通过复制和粘贴此数据使用的Windows记事本创建此文件。使用记事本中的保存为所有文件（<em>。</em>）选项将文件保存为input.csv。</p><pre><code>id,name,salary,start_date,dept1,Rick,623.3,2012-01-01,IT2,Dan,515.2,2013-09-23,Operations3,Michelle,611,2014-11-15,IT4,Ryan,729,2014-05-11,HR ,Gary,843.25,2015-03-27,Finance6,Nina,578,2013-05-21,IT7,Simon,632.8,2013-07-30,Operations8,Guru,722.5,2014-06-17,Finance</code></pre><h3 id="读取CSV文件"><a href="#读取CSV文件" class="headerlink" title="读取CSV文件"></a>读取CSV文件</h3><p>以下是read.csv（）函数的一个简单示例，用于读取当前工作目录中可用的CSV文件 -</p><p>data &lt;- read.csv(“input.csv”)<br>print(data)<br>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      id,   name,    salary,   start_date,     dept1      1    Rick     623.30    2012-01-01      IT2      2    Dan      515.20    2013-09-23      Operations3      3    Michelle 611.00    2014-11-15      IT4      4    Ryan     729.00    2014-05-11      HR5     NA    Gary     843.25    2015-03-27      Finance6      6    Nina     578.00    2013-05-21      IT7      7    Simon    632.80    2013-07-30      Operations8      8    Guru     722.50    2014-06-17      Finance</code></pre><h3 id="分析CSV文件"><a href="#分析CSV文件" class="headerlink" title="分析CSV文件"></a>分析CSV文件</h3><p>默认情况下，read.csv（）函数将输出作为数据帧。这可以容易地如下检查。此外，我们可以检查列和行的数量。</p><pre><code>data &lt;- read.csv("input.csv")print(is.data.frame(data))print(ncol(data))print(nrow(data))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] TRUE[1] 5[1] 8</code></pre><p>一旦我们读取数据帧中的数据，我们可以应用所有适用于数据帧的函数，如下一节所述。</p><p>获得最高工资</p><pre><code># Create a data frame.data &lt;- read.csv("input.csv")# Get the max salary from data frame.sal &lt;- max(data$salary)print(sal)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 843.25</code></pre><p>获取具有最高工资的人的详细信息<br>我们可以获取满足特定过滤条件的行，类似于SQL where子句。</p><pre><code># Create a data frame.data &lt;- read.csv("input.csv")# Get the max salary from data frame.sal &lt;- max(data$salary)# Get the person detail having max salary.retval &lt;- subset(data, salary == max(salary))print(retval)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      id    name  salary  start_date    dept5     NA    Gary  843.25  2015-03-27    Finance</code></pre><p>获取所有的IT部门员工的信息</p><pre><code># Create a data frame.data &lt;- read.csv("input.csv")retval &lt;- subset( data, dept == "IT")print(retval)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>       id   name      salary   start_date   dept1      1    Rick      623.3    2012-01-01   IT3      3    Michelle  611.0    2014-11-15   IT6      6    Nina      578.0    2013-05-21   IT</code></pre><p>获得工资大于600的IT部门的人员</p><pre><code># Create a data frame.data &lt;- read.csv("input.csv")info &lt;- subset(data, salary &gt; 600 &amp; dept == "IT")print(info)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>       id   name      salary   start_date   dept1      1    Rick      623.3    2012-01-01   IT3      3    Michelle  611.0    2014-11-15   IT</code></pre><p>获得2014年或之后加入的人</p><pre><code># Create a data frame.data &lt;- read.csv("input.csv")retval &lt;- subset(data, as.Date(start_date) &gt; as.Date("2014-01-01"))print(retval)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>       id   name     salary   start_date    dept3      3    Michelle 611.00   2014-11-15    IT4      4    Ryan     729.00   2014-05-11    HR5     NA    Gary     843.25   2015-03-27    Finance8      8    Guru     722.50   2014-06-17    Finance</code></pre><h3 id="写入CSV文件"><a href="#写入CSV文件" class="headerlink" title="写入CSV文件"></a>写入CSV文件</h3><p>R语言可以创建csv文件形式的现有数据帧.write.csv（）函数用于创建csv文件。此文件在工作目录中创建。</p><pre><code># Create a data frame.data &lt;- read.csv("input.csv")retval &lt;- subset(data, as.Date(start_date) &gt; as.Date("2014-01-01"))# Write filtered data into a new file.write.csv(retval,"output.csv")newdata &lt;- read.csv("output.csv")print(newdata)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>  X      id   name      salary   start_date    dept1 3      3    Michelle  611.00   2014-11-15    IT2 4      4    Ryan      729.00   2014-05-11    HR3 5     NA    Gary      843.25   2015-03-27    Finance4 8      8    Guru      722.50   2014-06-17    Finance</code></pre><p>这里列X来自数据集newper。这可以在写入文件时使用附加参数删除。</p><pre><code># Create a data frame.data &lt;- read.csv("input.csv")retval &lt;- subset(data, as.Date(start_date) &gt; as.Date("2014-01-01"))# Write filtered data into a new file.write.csv(retval,"output.csv", row.names = FALSE)newdata &lt;- read.csv("output.csv")print(newdata)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      id    name      salary   start_date    dept1      3    Michelle  611.00   2014-11-15    IT2      4    Ryan      729.00   2014-05-11    HR3     NA    Gary      843.25   2015-03-27    Finance4      8    Guru      722.50   2014-06-17    Finance</code></pre><h1 id="8-Excel文件"><a href="#8-Excel文件" class="headerlink" title="8.Excel文件"></a>8.Excel文件</h1><p>Microsoft Excel是最广泛使用的电子表格程序，以.xls或.xlsx格式存储数据。 R语言可以直接从这些文件使用一些excel特定的包。 很少这样的包是 - XLConnect，xlsx，gdata等。我们将使用xlsx包。 R语言也可以使用这个包写入excel文件。</p><h3 id="安装xlsx软件包"><a href="#安装xlsx软件包" class="headerlink" title="安装xlsx软件包"></a>安装xlsx软件包</h3><p>您可以在R控制台中使用以下命令来安装“xlsx”软件包。 它可能会要求安装一些额外的软件包这个软件包依赖。 按照具有所需软件包名称的同一命令安装其他软件包。</p><pre><code>install.packages("xlsx")</code></pre><h3 id="验证并加载“xlsx”软件包"><a href="#验证并加载“xlsx”软件包" class="headerlink" title="验证并加载“xlsx”软件包"></a>验证并加载“xlsx”软件包</h3><p>使用以下命令验证并加载“xlsx”软件包。</p><pre><code># Verify the package is installed.any(grepl("xlsx",installed.packages()))# Load the library into R workspace.library("xlsx")</code></pre><p>当脚本运行，我们得到以下输出。</p><pre><code>[1] TRUELoading required package: rJavaLoading required package: methodsLoading required package: xlsxjars</code></pre><h3 id="输入为xlsx文件"><a href="#输入为xlsx文件" class="headerlink" title="输入为xlsx文件"></a>输入为xlsx文件</h3><p>打开Microsoft Excel。 将以下数据复制并粘贴到名为sheet1的工作表中。</p><pre><code>id    name      salary    start_date    dept1    Rick      623.3        1/1/2012    IT2    Dan       515.2     9/23/2013   Operations3    Michelle  611        11/15/2014    IT4    Ryan      729        5/11/2014    HR5    Gary      843.25    3/27/2015    Finance6    Nina      578       5/21/2013    IT7    Simon      632.8        7/30/2013    Operations8    Guru      722.5        6/17/2014    Finance</code></pre><p>还要将以下数据复制并粘贴到另一个工作表，并将此工作表重命名为“city”。</p><pre><code>name     cityRick     SeattleDan      TampaMichelle ChicagoRyan     SeattleGary     HoustonNina     BostonSimon     MumbaiGuru     Dallas</code></pre><p>将Excel文件另存为“input.xlsx”。 应将其保存在R工作区的当前工作目录中。</p><h3 id="读取Excel文件"><a href="#读取Excel文件" class="headerlink" title="读取Excel文件"></a>读取Excel文件</h3><p>通过使用read.xlsx()函数读取input.xlsx，如下所示。 结果作为数据帧存储在R语言环境中。</p><pre><code># Read the first worksheet in the file input.xlsx.data &lt;- read.xlsx("input.xlsx", sheetIndex = 1)print(data)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      id,   name,    salary,   start_date,     dept1      1    Rick     623.30    2012-01-01      IT2      2    Dan      515.20    2013-09-23      Operations3      3    Michelle 611.00    2014-11-15      IT4      4    Ryan     729.00    2014-05-11      HR5     NA    Gary     843.25    2015-03-27      Finance6      6    Nina     578.00    2013-05-21      IT7      7    Simon    632.80    2013-07-30      Operations8      8    Guru     722.50    2014-06-17      Finance</code></pre><h1 id="9-二进制文件"><a href="#9-二进制文件" class="headerlink" title="9.二进制文件"></a>9.二进制文件</h1><p>二进制文件是包含仅以位和字节（0和1）的形式存储的信息的文件。它们不是人类可读的，因为它中的字节转换为包含许多其他不可打印字符的字符和符号。尝试使用任何文本编辑器读取二进制文件将显示如Ø和d的字符。</p><p>二进制文件必须由特定程序读取才能使用。例如，Microsoft Word程序的二进制文件只能通过Word程序读取到人类可读的形式。这表示，除了人类可读的文本之外，还有更多的信息，例如字符和页码等的格式化，它们也与字母数字字符一起存储。最后一个二进制文件是一个连续的字节序列。我们在文本文件中看到的换行符是连接第一行到下一行的字符。</p><p>有时，由其他程序生成的数据需要由ř作为二进制文件处理。另外，R语言是创建可以与其他程序共享的二进制文件所必需的。</p><p>ř语言有两个函数WriteBin（）和readBin（）来创建和读取二进制文件。</p><h3 id="语法-12"><a href="#语法-12" class="headerlink" title="语法"></a>语法</h3><pre><code>writeBin(object, con)readBin(con, what, n )</code></pre><p>以下是所使用的参数的描述 -</p><ul><li><p>CON是读取或写入二进制文件的连接对象。</p></li><li><p>对象是要写入的二进制文件。</p></li><li><p>什么是模式，如字符，整数等表示要读取的字节。</p></li><li><p>ñ是从二进制文件读取的字节数。</p></li></ul><h3 id="例-12"><a href="#例-12" class="headerlink" title="例"></a>例</h3><p>我们考虑R语言内置数据“mtcars”。首先，我们从它创建一个csv文件，并将其转换为二进制文件，并将其存储为操作系统文件。接下来我们读取这个创建的二进制文件。</p><h3 id="写入二进制文件"><a href="#写入二进制文件" class="headerlink" title="写入二进制文件"></a>写入二进制文件</h3><p>我们将数据帧“mtcars”读取为CSV文件，然后将其作为二进制文件写入操作系统。</p><pre><code># Read the "mtcars" data frame as a csv file and store only the columns    "cyl", "am" and "gear".write.table(mtcars, file = "mtcars.csv",row.names = FALSE, na = "",    col.names = TRUE, sep = ",")# Store 5 records from the csv file as a new data frame.new.mtcars &lt;- read.table("mtcars.csv",sep = ",",header = TRUE,nrows = 5)# Create a connection object to write the binary file using mode "wb".write.filename = file("/web/com/binmtcars.dat", "wb")# Write the column names of the data frame to the connection object.writeBin(colnames(new.mtcars), write.filename)# Write the records in each of the column to the file.writeBin(c(new.mtcars$cyl,new.mtcars$am,new.mtcars$gear), write.filename)# Close the file for writing so that it can be read by other program.close(write.filename)</code></pre><h3 id="读取二进制文件"><a href="#读取二进制文件" class="headerlink" title="读取二进制文件"></a>读取二进制文件</h3><p>上面创建的二进制文件将所有数据存储为连续字节。因此，我们将通过选择适当的列名称值和列值来读取它。</p><pre><code># Create a connection object to read the file in binary mode using "rb".read.filename &lt;- file("/web/com/binmtcars.dat", "rb")# First read the column names. n = 3 as we have 3 columns.column.names &lt;- readBin(read.filename, character(),  n = 3)# Next read the column values. n = 18 as we have 3 column names and 15 values.read.filename &lt;- file("/web/com/binmtcars.dat", "rb")bindata &lt;- readBin(read.filename, integer(),  n = 18)# Print the data.print(bindata)# Read the values from 4th byte to 8th byte which represents "cyl".cyldata = bindata[4:8]print(cyldata)# Read the values form 9th byte to 13th byte which represents "am".amdata = bindata[9:13]print(amdata)# Read the values form 9th byte to 13th byte which represents "gear".geardata = bindata[14:18]print(geardata)# Combine all the read values to a dat frame.finaldata = cbind(cyldata, amdata, geardata)colnames(finaldata) = column.namesprint(finaldata)</code></pre><p>当我们执行上面的代码，它产生以下结果和图表 -</p><pre><code> [1]    7108963 1728081249    7496037          6          6          4 [7]          6          8          1          1          1          0[13]          0          4          4          4          3          3[1] 6 6 4 6 8[1] 1 1 1 0 0[1] 4 4 4 3 3     cyl am gear[1,]   6  1    4[2,]   6  1    4[3,]   4  1    4[4,]   6  0    3[5,]   8  0    3</code></pre><p>正如我们所看到的，我们通过读取 - [R中的二进制文件得到原始数据。</p><h1 id="10-XML文件"><a href="#10-XML文件" class="headerlink" title="10.XML文件"></a>10.XML文件</h1><p>XML是一种文件格式，它使用标准ASCII文本共享万维网，内部网和其他地方的文件格式和数据。它代表可扩展标记语言（XML）。类似于HTML它包含标记标签。但是与HTML中的标记标记描述页面的结构不同，在XML中，标记标记描述了包含在文件中的数据的含义。</p><p>您可以使用“XML”包读取R语言中的xml文件。此软件包可以使用以下命令安装。</p><pre><code>install.packages("XML")</code></pre><h3 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h3><p>通过将以下数据复制到文本编辑器（如记事本）中来创建XMl文件。使用.xml扩展名保存文件，并将文件类型选择为所有文件（<em>。</em>）。</p><pre><code>&lt;RECORDS&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;1&lt;/ID&gt;      &lt;NAME&gt;Rick&lt;/NAME&gt;      &lt;SALARY&gt;623.3&lt;/SALARY&gt;      &lt;STARTDATE&gt;1/1/2012&lt;/STARTDATE&gt;      &lt;DEPT&gt;IT&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;2&lt;/ID&gt;      &lt;NAME&gt;Dan&lt;/NAME&gt;      &lt;SALARY&gt;515.2&lt;/SALARY&gt;      &lt;STARTDATE&gt;9/23/2013&lt;/STARTDATE&gt;      &lt;DEPT&gt;Operations&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;3&lt;/ID&gt;      &lt;NAME&gt;Michelle&lt;/NAME&gt;      &lt;SALARY&gt;611&lt;/SALARY&gt;      &lt;STARTDATE&gt;11/15/2014&lt;/STARTDATE&gt;      &lt;DEPT&gt;IT&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;4&lt;/ID&gt;      &lt;NAME&gt;Ryan&lt;/NAME&gt;      &lt;SALARY&gt;729&lt;/SALARY&gt;      &lt;STARTDATE&gt;5/11/2014&lt;/STARTDATE&gt;      &lt;DEPT&gt;HR&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;5&lt;/ID&gt;      &lt;NAME&gt;Gary&lt;/NAME&gt;      &lt;SALARY&gt;843.25&lt;/SALARY&gt;      &lt;STARTDATE&gt;3/27/2015&lt;/STARTDATE&gt;      &lt;DEPT&gt;Finance&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;6&lt;/ID&gt;      &lt;NAME&gt;Nina&lt;/NAME&gt;      &lt;SALARY&gt;578&lt;/SALARY&gt;      &lt;STARTDATE&gt;5/21/2013&lt;/STARTDATE&gt;      &lt;DEPT&gt;IT&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;7&lt;/ID&gt;      &lt;NAME&gt;Simon&lt;/NAME&gt;      &lt;SALARY&gt;632.8&lt;/SALARY&gt;      &lt;STARTDATE&gt;7/30/2013&lt;/STARTDATE&gt;      &lt;DEPT&gt;Operations&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;   &lt;EMPLOYEE&gt;      &lt;ID&gt;8&lt;/ID&gt;      &lt;NAME&gt;Guru&lt;/NAME&gt;      &lt;SALARY&gt;722.5&lt;/SALARY&gt;      &lt;STARTDATE&gt;6/17/2014&lt;/STARTDATE&gt;      &lt;DEPT&gt;Finance&lt;/DEPT&gt;   &lt;/EMPLOYEE&gt;&lt;/RECORDS&gt;</code></pre><h3 id="读取XML文件"><a href="#读取XML文件" class="headerlink" title="读取XML文件"></a>读取XML文件</h3><p>xml文件由R语言使用函数xmlParse（）读取。它作为列表存储在R语言中。</p><pre><code># Load the package required to read XML files.library("XML")# Also load the other required package.library("methods")# Give the input file name to the function.result &lt;- xmlParse(file = "input.xml")# Print the result.print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>1    Rick    623.3    1/1/2012    IT    2    Dan    515.2    9/23/2013    Operations    3    Michelle    611    11/15/2014    IT    4    Ryan    729    5/11/2014    HR    5    Gary    843.25    3/27/2015    Finance    6    Nina    578    5/21/2013    IT    7    Simon    632.8    7/30/2013    Operations    8    Guru    722.5    6/17/2014    Finance</code></pre><h3 id="获取XML文件中存在的节点数"><a href="#获取XML文件中存在的节点数" class="headerlink" title="获取XML文件中存在的节点数"></a>获取XML文件中存在的节点数</h3><pre><code># Load the packages required to read XML files.library("XML")library("methods")# Give the input file name to the function.result &lt;- xmlParse(file = "input.xml")# Exract the root node form the xml file.rootnode &lt;- xmlRoot(result)# Find number of nodes in the root.rootsize &lt;- xmlSize(rootnode)# Print the result.print(rootsize)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>output[1] 8</code></pre><h3 id="第一个节点的详细信息"><a href="#第一个节点的详细信息" class="headerlink" title="第一个节点的详细信息"></a>第一个节点的详细信息</h3><p>让我们看看解析文件的第一条记录。它将给我们一个关于存在于顶层节点中的各种元素的想法。</p><pre><code># Load the packages required to read XML files.library("XML")library("methods")# Give the input file name to the function.result &lt;- xmlParse(file = "input.xml")# Exract the root node form the xml file.rootnode &lt;- xmlRoot(result)# Print the result.print(rootnode[1])</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>$EMPLOYEE  1  Rick  623.3  1/1/2012  ITattr(,"class")[1] "XMLInternalNodeList" "XMLNodeList" </code></pre><p>获取节点的不同元素</p><pre><code># Load the packages required to read XML files.library("XML")library("methods")# Give the input file name to the function.result &lt;- xmlParse(file = "input.xml")# Exract the root node form the xml file.rootnode &lt;- xmlRoot(result)# Get the first element of the first node.print(rootnode[[1]][[1]])# Get the fifth element of the first node.print(rootnode[[1]][[5]])# Get the second element of the third node.print(rootnode[[3]][[2]])</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>1 IT Michelle </code></pre><h3 id="XML到数据帧"><a href="#XML到数据帧" class="headerlink" title="XML到数据帧"></a>XML到数据帧</h3><p>为了在大文件中有效地处理数据，我们将xml文件中的数据作为数据框读取。然后处理数据帧以进行数据分析。</p><pre><code># Load the packages required to read XML files.library("XML")library("methods")# Convert the input xml file to a data frame.xmldataframe &lt;- xmlToDataFrame("input.xml")print(xmldataframe)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      ID    NAME     SALARY    STARTDATE       DEPT 1      1    Rick     623.30    2012-01-01      IT2      2    Dan      515.20    2013-09-23      Operations3      3    Michelle 611.00    2014-11-15      IT4      4    Ryan     729.00    2014-05-11      HR5     NA    Gary     843.25    2015-03-27      Finance6      6    Nina     578.00    2013-05-21      IT7      7    Simon    632.80    2013-07-30      Operations8      8    Guru     722.50    2014-06-17      Finance</code></pre><p>由于数据现在可以作为数据帧，我们可以使用数据帧相关函数来读取和操作文件。</p><h1 id="11-JSON文件"><a href="#11-JSON文件" class="headerlink" title="11.JSON文件"></a>11.JSON文件</h1><p>JSON文件以人类可读格式将数据存储为文本.Json代表JavaScript Object Notation.R可以使用rjson包读取JSON文件。</p><h3 id="安装rjson包"><a href="#安装rjson包" class="headerlink" title="安装rjson包"></a>安装rjson包</h3><p>在ř语言控制台中，您可以发出以下命令来安装rjson包。</p><pre><code>install.packages("rjson")</code></pre><h3 id="输入数据-1"><a href="#输入数据-1" class="headerlink" title="输入数据"></a>输入数据</h3><p>通过将以下数据复制到文本编辑器（如记事本）中来创建JSON文件。使用.json扩展名保存文件，并将文件类型选择为所有文件（<em>。</em>）。</p><pre><code>{    "ID":["1","2","3","4","5","6","7","8" ],   "Name":["Rick","Dan","Michelle","Ryan","Gary","Nina","Simon","Guru" ],   "Salary":["623.3","515.2","611","729","843.25","578","632.8","722.5" ],   "StartDate":[ "1/1/2012","9/23/2013","11/15/2014","5/11/2014","3/27/2015","5/21/2013",      "7/30/2013","6/17/2014"],   "Dept":[ "IT","Operations","IT","HR","Finance","IT","Operations","Finance"]}</code></pre><h3 id="读取JSON文件"><a href="#读取JSON文件" class="headerlink" title="读取JSON文件"></a>读取JSON文件</h3><p>JSON文件由R使用来自JSON（）的函数读取。它作为列表存储在R中。</p><pre><code># Load the package required to read JSON files.library("rjson")# Give the input file name to the function.result &lt;- fromJSON(file = "input.json")# Print the result.print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>$ID[1] "1"   "2"   "3"   "4"   "5"   "6"   "7"   "8"$Name[1] "Rick"     "Dan"      "Michelle" "Ryan"     "Gary"     "Nina"     "Simon"    "Guru"$Salary[1] "623.3"  "515.2"  "611"    "729"    "843.25" "578"    "632.8"  "722.5"$StartDate[1] "1/1/2012"   "9/23/2013"  "11/15/2014" "5/11/2014"  "3/27/2015"  "5/21/2013"   "7/30/2013"  "6/17/2014"$Dept[1] "IT"         "Operations" "IT"         "HR"         "Finance"    "IT"   "Operations" "Finance"</code></pre><h3 id="将JSON转换为数据帧"><a href="#将JSON转换为数据帧" class="headerlink" title="将JSON转换为数据帧"></a>将JSON转换为数据帧</h3><p>我们可以使用as.data.frame（）函数将上面提取的数据转换为ř语言数据帧以进行进一步分析。</p><pre><code># Load the package required to read JSON files.library("rjson")# Give the input file name to the function.result &lt;- fromJSON(file = "input.json")# Convert JSON file to a data frame.json_data_frame &lt;- as.data.frame(result)print(json_data_frame)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      id,   name,    salary,   start_date,     dept1      1    Rick     623.30    2012-01-01      IT2      2    Dan      515.20    2013-09-23      Operations3      3    Michelle 611.00    2014-11-15      IT4      4    Ryan     729.00    2014-05-11      HR5     NA    Gary     843.25    2015-03-27      Finance6      6    Nina     578.00    2013-05-21      IT7      7    Simon    632.80    2013-07-30      Operations8      8    Guru     722.50    2014-06-17      Finance</code></pre><h1 id="13-Web数据"><a href="#13-Web数据" class="headerlink" title="13.Web数据"></a>13.Web数据</h1><p>许多网站提供数据供其用户使用。例如，世界卫生组织（WHO）以CSV，txt和XML文件的形式提供健康和医疗信息的报告。使用R语言程序，我们可以从这些网站以编程方式提取特定数据R语言中用于从网站中提取数据的一些包是“RCurl”，XML“和”stringr“，它们用于连接到URL，识别文件所需的链接并将它们下载到本地环境。</p><h3 id="安装-R语言的包"><a href="#安装-R语言的包" class="headerlink" title="安装 - [R语言的包"></a>安装 - [R语言的包</h3><p>处理URL和链接到文件需要以下的包。如果它们在R语言环境中不可用，您可以使用以下命令安装它们。</p><pre><code>install.packages("RCurl")install.packages("XML")install.packages("stringr")install.packages("plyr")</code></pre><h3 id="输入数据-2"><a href="#输入数据-2" class="headerlink" title="输入数据"></a>输入数据</h3><p>我们将访问URL <a href="http://www.geos.ed.ac.uk/~weather/jcmb_ws/" target="_blank" rel="noopener">天气数据</a>，并使用[R在2015年下载CSV文件。</p><h3 id="例-13"><a href="#例-13" class="headerlink" title="例"></a>例</h3><p>我们将使用函数getHTMLLinks（）来收集文件的URL。然后我们将使用函数downlaod.file（）将文件保存到本地系统。由于我们将对多个文件一次又一次地应用相同的代码，因此我们将创建一个被多次调用的函数。文件名作为参数以R列表对象的形式传递到此函数。</p><pre><code># Read the URL.url &lt;- "http://www.geos.ed.ac.uk/~weather/jcmb_ws/"# Gather the html links present in the webpage.links &lt;- getHTMLLinks(url)# Identify only the links which point to the JCMB 2015 files. filenames &lt;- links[str_detect(links, "JCMB_2015")]# Store the file names as a list.filenames_list &lt;- as.list(filenames)# Create a function to download the files by passing the URL and filename list.downloadcsv &lt;- function (mainurl,filename) {   filedetails &lt;- str_c(mainurl,filename)   download.file(filedetails,filename)}# Now apply the l_ply function and save the files into the current R working directory.l_ply(filenames,downloadcsv,mainurl = "http://www.geos.ed.ac.uk/~weather/jcmb_ws/")</code></pre><h3 id="验证文件下载"><a href="#验证文件下载" class="headerlink" title="验证文件下载"></a>验证文件下载</h3><p>运行上述代码后，您可以在当前ř语言工作目录中找到以下文件。</p><pre><code>"JCMB_2015.csv" "JCMB_2015_Apr.csv" "JCMB_2015_Feb.csv" "JCMB_2015_Jan.csv"   "JCMB_2015_Mar.csv"</code></pre><h1 id="14-数据库"><a href="#14-数据库" class="headerlink" title="14.数据库"></a>14.数据库</h1><p>Sql查询。但R语言可以轻松地连接到许多关系数据库，如MySql，Oracle，Sql服务器等，并数据是从它们获取记录作为数据框。一旦数据在R语言环境中可用，它就变成正常的R语言数据集，并且可以使用所有强大的包和函数来操作或分析。<br>在本教程中，我们将使用MySQL的作为连接到- [R语言的参考数据库。</p><h3 id="RMySQL包"><a href="#RMySQL包" class="headerlink" title="RMySQL包"></a>RMySQL包</h3><p>R语言有一个名为“RMySQL”的内置包，它提供与MySql数据库之间的本地连接。您可以使用以下命令在R语言环境中安装此软件包。</p><pre><code>install.packages("RMySQL")</code></pre><h3 id="将r连接到MySQL的"><a href="#将r连接到MySQL的" class="headerlink" title="将ř连接到MySQL的"></a>将ř连接到MySQL的</h3><p>一旦安装了包，我们在R中创建一个连接对象以连接到数据库。它使用用户名，密码，数据库名称和主机名作为输入。</p><pre><code># Create a connection Object to MySQL database.# We will connect to the sampel database named "sakila" that comes with MySql installation.mysqlconnection = dbConnect(MySQL(), user = 'root', password = '', dbname = 'sakila',   host = 'localhost')# List the tables available in this database. dbListTables(mysqlconnection)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code> [1] "actor"                      "actor_info"                 [3] "address"                    "category"                   [5] "city"                       "country"                    [7] "customer"                   "customer_list"              [9] "film"                       "film_actor"                [11] "film_category"              "film_list"                 [13] "film_text"                  "inventory"                 [15] "language"                   "nicer_but_slower_film_list"[17] "payment"                    "rental"                    [19] "sales_by_film_category"     "sales_by_store"            [21] "staff"                      "staff_list"                [23] "store"     </code></pre><h3 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a>查询表</h3><p>我们可以使用函数dbSendQuery（）查询MySql中的数据库表。查询在MySql中执行，并使用R语言fetch（）函数返回结果集。最后，它被存储为R语言中的数据帧。</p><pre><code># Query the "actor" tables to get all the rows.result = dbSendQuery(mysqlconnection, "select * from actor")# Store the result in a R data frame object. n = 5 is used to fetch first 5 rows.data.frame = fetch(result, n = 5)print(data.frame)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>        actor_id   first_name    last_name         last_update1        1         PENELOPE      GUINESS           2006-02-15 04:34:332        2         NICK          WAHLBERG          2006-02-15 04:34:333        3         ED            CHASE             2006-02-15 04:34:334        4         JENNIFER      DAVIS             2006-02-15 04:34:335        5         JOHNNY        LOLLOBRIGIDA      2006-02-15 04:34:33</code></pre><h3 id="带过滤条件的查询"><a href="#带过滤条件的查询" class="headerlink" title="带过滤条件的查询"></a>带过滤条件的查询</h3><p>我们可以传递任何有效的选择查询来获取结果。</p><pre><code>result = dbSendQuery(mysqlconnection, "select * from actor where last_name = 'TORN'")# Fetch all the records(with n = -1) and store it as a data frame.data.frame = fetch(result, n = -1)print(data)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>        actor_id    first_name     last_name         last_update1        18         DAN            TORN              2006-02-15 04:34:332        94         KENNETH        TORN              2006-02-15 04:34:333       102         WALTER         TORN              2006-02-15 04:34:33</code></pre><h3 id="更新表中的行"><a href="#更新表中的行" class="headerlink" title="更新表中的行"></a>更新表中的行</h3><p>我们可以通过将更新查询传递给dbSendQuery（）函数来更新Mysql的表中的行。</p><pre><code>dbSendQuery(mysqlconnection, "update mtcars set disp = 168.5 where hp = 110")</code></pre><p>在执行上面的代码后，我们可以看到在MySQL的环境中更新的表。<br>将数据插入表中</p><pre><code>dbSendQuery(mysqlconnection,   "insert into mtcars(row_names, mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb)   values('New Mazda RX4 Wag', 21, 6, 168.5, 110, 3.9, 2.875, 17.02, 0, 1, 4, 4)")</code></pre><p>在执行上面的代码后，我们可以看到插入到MySQL的环境中的表中的行。</p><h3 id="在MySQL的中创建表"><a href="#在MySQL的中创建表" class="headerlink" title="在MySQL的中创建表"></a>在MySQL的中创建表</h3><p>我们可以在MySql中使用函数dbWriteTable（）创建表。如果表已经存在，它将覆盖该表，并将数据帧用作输入。</p><pre><code># Create the connection object to the database where we want to create the table.mysqlconnection = dbConnect(MySQL(), user = 'root', password = '', dbname = 'sakila',    host = 'localhost')# Use the R data frame "mtcars" to create the table in MySql.# All the rows of mtcars are taken inot MySql.dbWriteTable(mysqlconnection, "mtcars", mtcars[, ], overwrite = TRUE)</code></pre><p>执行上面的代码后，我们可以看到在MySQL的环境中创建的表。</p><h3 id="删除的MySQL中的表"><a href="#删除的MySQL中的表" class="headerlink" title="删除的MySQL中的表"></a>删除的MySQL中的表</h3><p>我们可以删除MySql数据库中的表，将drop table语句传递到dbSendQuery（）中，就像我们使用它查询表中的数据一样。</p><pre><code>dbSendQuery(mysqlconnection, 'drop table if exists mtcars')</code></pre><p>执行上面的代码后，我们可以看到表在MySQL的环境中被删除。</p><h1 id="15-外部资源"><a href="#15-外部资源" class="headerlink" title="15.外部资源"></a>15.外部资源</h1><p>以下资源包含有关R语言编程的其他信息。 请使用它们获得有关此主题的更深入的知识。</p><h3 id="R语言编程的相关链接"><a href="#R语言编程的相关链接" class="headerlink" title="R语言编程的相关链接"></a>R语言编程的相关链接</h3><ul><li><p><a href="https://www.r-project.org/" target="_blank" rel="noopener">R项目</a> - 官方R软件和文档。</p></li><li><p><a href="https://en.wikipedia.org/wiki/R_(programming_language)" target="_blank" rel="noopener">R编程语言</a> - 维基百科解释R编程语言。</p></li><li><p><a href="https://www.rstudio.com/" target="_blank" rel="noopener">R Studio</a> - 强大的R编程IDE。</p></li></ul><h3 id="R上的编程有用的书籍"><a href="#R上的编程有用的书籍" class="headerlink" title="R上的编程有用的书籍"></a>R上的编程有用的书籍</h3><ul><li>[<img src="/images/loading.gif" data-original="http://www.amazon.com/exec/obidos/ASIN/1593273843/httpwwwtuto0a-20" alt=" -  [R编程的艺术](http://upload-images.jianshu.io/upload_images/14093662-65265032b61c772f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"> </li><li><a href="http://www.amazon.com/exec/obidos/ASIN/1449357105/httpwwwtuto0a-20" target="_blank" rel="noopener"><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-3c35398cdd7d47d5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="学习ř"></a> </li><li><a href="http://www.amazon.com/exec/obidos/ASIN/1617291382/httpwwwtuto0a-20" target="_blank" rel="noopener"><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-3bd16a1f1ffae949.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="中的R行动"></a> </li><li><a href="http://www.amazon.com/exec/obidos/ASIN/1617291560/httpwwwtuto0a-20" target="_blank" rel="noopener"><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-70a071fbcd01af9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="有R实用的数据科学"></a> </li><li><a href="http://www.amazon.com/exec/obidos/ASIN/111816430X/httpwwwtuto0a-20" target="_blank" rel="noopener"><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-da63af7c2a617b81.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="有R实用的数据科学"></a> </li><li><a href="http://www.amazon.com/exec/obidos/ASIN/111816430X/httpwwwtuto0a-20" target="_blank" rel="noopener"><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-053f2b8cf827ec94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="有R实用的数据科学"></a><h1 id="16-常见面试题"><a href="#16-常见面试题" class="headerlink" title="16.常见面试题"></a>16.常见面试题</h1><h3 id="什么是R语言编程？"><a href="#什么是R语言编程？" class="headerlink" title="什么是R语言编程？"></a>什么是R语言编程？</h3></li></ul><p>R语言是一种用于统计分析和为此目的创建图形的编程语言。不是数据类型，它具有用于计算的数据对象。它用于数据挖掘，回归分析，概率估计等领域，使用其中可用的许多软件包。</p><h3 id="R语言中的不同数据对象是什么？"><a href="#R语言中的不同数据对象是什么？" class="headerlink" title="R语言中的不同数据对象是什么？"></a>R语言中的不同数据对象是什么？</h3><p>它们是R语言中的6个数据对象。它们是向量，列表，数组，矩阵，数据框和表。</p><h3 id="什么使R语言中的有效变量名？"><a href="#什么使R语言中的有效变量名？" class="headerlink" title="什么使R语言中的有效变量名？"></a>什么使R语言中的有效变量名？</h3><p>有效的变量名称由字母，数字和点或下划线字符组成。变量名以字母或不以数字后跟的点开头。</p><h3 id="数组和矩阵之间的主要区别是什么？"><a href="#数组和矩阵之间的主要区别是什么？" class="headerlink" title="数组和矩阵之间的主要区别是什么？"></a>数组和矩阵之间的主要区别是什么？</h3><p>矩阵总是二维的，因为它只有行和列。但是阵列可以具有任何数量的维度，并且每个维度是矩阵。例如，3x3x2阵列表示维度为3x3的2个矩阵。</p><h3 id="R语言中的哪个数据对象用于存储和处理分类数据？"><a href="#R语言中的哪个数据对象用于存储和处理分类数据？" class="headerlink" title="R语言中的哪个数据对象用于存储和处理分类数据？"></a>R语言中的哪个数据对象用于存储和处理分类数据？</h3><p>R语言中的因子数据对象用于存储和处理R语言中的分类数据。</p><h3 id="如何在R语言中加载和使用csv文件？"><a href="#如何在R语言中加载和使用csv文件？" class="headerlink" title="如何在R语言中加载和使用csv文件？"></a>如何在R语言中加载和使用csv文件？</h3><p>可以使用R语言ead.csv函数加载csv文件。 R语言在使用此函数读取csv文件时创建数据框。</p><h3 id="如何获取R语言中当前工作目录的名称？"><a href="#如何获取R语言中当前工作目录的名称？" class="headerlink" title="如何获取R语言中当前工作目录的名称？"></a>如何获取R语言中当前工作目录的名称？</h3><p>命令getwd()给出了R语言环境中的当前工作目录。</p><h3 id="什么是R语言-Base包？"><a href="#什么是R语言-Base包？" class="headerlink" title="什么是R语言 Base包？"></a>什么是R语言 Base包？</h3><p>这是在R语言环境设置时默认加载的包。它提供了R语言环境中的基本功能，如输入/输出，算术计算等。</p><h3 id="在逻辑回归中如何使用R语言？"><a href="#在逻辑回归中如何使用R语言？" class="headerlink" title="在逻辑回归中如何使用R语言？"></a>在逻辑回归中如何使用R语言？</h3><p>逻辑回归处理测量二元响应变量的概率。在R语言中，函数glm()用于创建逻辑回归。</p><h3 id="如何访问名为M的矩阵的第2列和第4行中的元素？"><a href="#如何访问名为M的矩阵的第2列和第4行中的元素？" class="headerlink" title="如何访问名为M的矩阵的第2列和第4行中的元素？"></a>如何访问名为M的矩阵的第2列和第4行中的元素？</h3><p>表达式M [4,2]给出了第4行和第2列的元素。</p><h3 id="什么是向量中元素的回收？举个例子。"><a href="#什么是向量中元素的回收？举个例子。" class="headerlink" title="什么是向量中元素的回收？举个例子。"></a>什么是向量中元素的回收？举个例子。</h3><p>当在操作中涉及不同长度的两个向量时，较短向量的元素被重用以完成操作。这被称为元素循环。示例-v1 &lt;-c（4,1,0,6）和V2 &lt;-c（2,4），则v1 * v2给出（8,4,0,24）。重复元件2和4。</p><h3 id="在R语言中调用函数有什么不同的方法？"><a href="#在R语言中调用函数有什么不同的方法？" class="headerlink" title="在R语言中调用函数有什么不同的方法？"></a>在R语言中调用函数有什么不同的方法？</h3><p>我们可以用3种方式在R语言中调用一个函数。第一种方法是通过使用参数的位置来调用。第二个方法id通过使用参数的名称来调用，第三个方法是通过默认参数调用。</p><h3 id="什么是R语言中的延迟函数评估？"><a href="#什么是R语言中的延迟函数评估？" class="headerlink" title="什么是R语言中的延迟函数评估？"></a>什么是R语言中的延迟函数评估？</h3><p>函数的延迟评估意味着，只有当它在函数体内部使用时，才会评估参数。如果没有对函数体中的参数的引用，则它被简单地忽略。</p><h3 id="如何在R语言中安装软件包？"><a href="#如何在R语言中安装软件包？" class="headerlink" title="如何在R语言中安装软件包？"></a>如何在R语言中安装软件包？</h3><p>要在R语言中安装一个包，我们使用下面的命令。</p><pre><code>install.packages（"package Name"）</code></pre><p>命名用于读取XML文件的R语言包。<br>名为“XML”的包用于读取和处理XML文件。</p><h3 id="我们可以更新和删除列表中的任何元素吗？"><a href="#我们可以更新和删除列表中的任何元素吗？" class="headerlink" title="我们可以更新和删除列表中的任何元素吗？"></a>我们可以更新和删除列表中的任何元素吗？</h3><p>我们可以更新任何元素，但我们只能删除列表末尾的元素。</p><p>给一般表达式在R语言中创建一个矩阵。<br>在R语言中创建矩阵的一般表达式是 - matrix（data，nrow，ncol，byrow，dimnames）</p><h3 id="该函数用于在R语言中创建boxplot图形？"><a href="#该函数用于在R语言中创建boxplot图形？" class="headerlink" title="该函数用于在R语言中创建boxplot图形？"></a>该函数用于在R语言中创建boxplot图形？</h3><p>boxplot()函数用于在R语言中创建箱线图。它使用公式和数据框作为输入创建箱线图。</p><h3 id="在做时间序列分析时，在ts-函数中fR语言equency-6是什么意思？"><a href="#在做时间序列分析时，在ts-函数中fR语言equency-6是什么意思？" class="headerlink" title="在做时间序列分析时，在ts()函数中fR语言equency = 6是什么意思？"></a>在做时间序列分析时，在ts()函数中fR语言equency = 6是什么意思？</h3><p>频率6表示时间序列数据的时间间隔是每10分钟一小时。</p><h3 id="什么是R语言中的数据重塑？"><a href="#什么是R语言中的数据重塑？" class="headerlink" title="什么是R语言中的数据重塑？"></a>什么是R语言中的数据重塑？</h3><p>在R语言中，数据对象可以从一种形式转换为另一种形式。例如，我们可以通过合并许多列表来创建数据框。这涉及一系列R语言命令，以将数据带入新格式。这被称为数据整形。</p><h3 id="R语言unif（4）的输出是什么？"><a href="#R语言unif（4）的输出是什么？" class="headerlink" title="R语言unif（4）的输出是什么？"></a>R语言unif（4）的输出是什么？</h3><p>它生成0和1之间的4个随机数。</p><h3 id="如何获得R语言中安装的所有软件包的列表？"><a href="#如何获得R语言中安装的所有软件包的列表？" class="headerlink" title="如何获得R语言中安装的所有软件包的列表？"></a>如何获得R语言中安装的所有软件包的列表？</h3><p>使用命令</p><pre><code>installed.packages()</code></pre><h3 id="运行命令-strsplit（x，“e”）是什么意思？"><a href="#运行命令-strsplit（x，“e”）是什么意思？" class="headerlink" title="运行命令 - strsplit（x，“e”）是什么意思？"></a>运行命令 - strsplit（x，“e”）是什么意思？</h3><p>它将向量x中的字符串拆分为字母e位置处的子字符串。</p><p>给一个R脚本从字符串中提取大写的所有唯一字 - “快速的棕色狐狸跳过懒惰的狗”。</p><pre><code>x &lt;- “快速的棕色狐狸跳过懒惰的狗”split.string &lt;- strsplit(x，"")extract.words &lt;- split.string [[1]]result &lt;- unique(tolower(extract.words))print(result)</code></pre><h3 id="向量v是c（1-2-3-4），列表x是列表（5：8），v-x-1-的输出是什么？"><a href="#向量v是c（1-2-3-4），列表x是列表（5：8），v-x-1-的输出是什么？" class="headerlink" title="向量v是c（1,2,3,4），列表x是列表（5：8），v * x [1]的输出是什么？"></a>向量v是c（1,2,3,4），列表x是列表（5：8），v * x [1]的输出是什么？</h3><p>v * x [1]中的错误：二进制运算符的非数值参数</p><h3 id="向量v是c（1-2-3-4），列表x是列表（5：8），v-x-1-的输出是什么？-1"><a href="#向量v是c（1-2-3-4），列表x是列表（5：8），v-x-1-的输出是什么？-1" class="headerlink" title="向量v是c（1,2,3,4），列表x是列表（5：8），v * x [[1]]的输出是什么？"></a>向量v是c（1,2,3,4），列表x是列表（5：8），v * x [[1]]的输出是什么？</h3><pre><code>[1] 5 12 21 32s</code></pre><h3 id="unlist-是什么？"><a href="#unlist-是什么？" class="headerlink" title="unlist()是什么？"></a>unlist()是什么？</h3><p>它将列表转换为向量。</p><p>给予R语言表达式，从使用pbinom的硬币51个硬币中得到26个或更少的头。</p><pre><code>x &lt;- pbinom(26,51,0.5)print(x)</code></pre><h3 id="X是向量c-5-9-2-3-8-51，NA-，mean-x-的输出是什么？"><a href="#X是向量c-5-9-2-3-8-51，NA-，mean-x-的输出是什么？" class="headerlink" title="X是向量c(5,9.2,3,8.51，NA)，mean(x)的输出是什么？"></a>X是向量c(5,9.2,3,8.51，NA)，mean(x)的输出是什么？</h3><p>NA</p><p>###如何将JSON文件中的数据转换为数据框？<br>使用函数as.data.frame()</p><p>###在R语言中给出一个函数，用向量的元素的和代替向量x的所有缺失值？</p><pre><code>function(x){x [is.na(x)] &lt;sum(x,na.rm = TRUE); x }</code></pre><h3 id="apply-在R语言中的用途是什么？"><a href="#apply-在R语言中的用途是什么？" class="headerlink" title="apply()在R语言中的用途是什么？"></a>apply()在R语言中的用途是什么？</h3><p>它用于对数组中的每个元素应用相同的函数。例如，查找每行中行的平均值。</p><h3 id="是数组称为矩阵还是矩阵称为数组？"><a href="#是数组称为矩阵还是矩阵称为数组？" class="headerlink" title="是数组称为矩阵还是矩阵称为数组？"></a>是数组称为矩阵还是矩阵称为数组？</h3><p>每个矩阵可以称为数组，但不能相反。矩阵总是二维的，但数组可以是任何维度。</p><h3 id="如何找到缺失值的帮助页面？"><a href="#如何找到缺失值的帮助页面？" class="headerlink" title="如何找到缺失值的帮助页面？"></a>如何找到缺失值的帮助页面？</h3><p>?NA</p><h3 id="如何获得向量x的标准偏差？"><a href="#如何获得向量x的标准偏差？" class="headerlink" title="如何获得向量x的标准偏差？"></a>如何获得向量x的标准偏差？</h3><pre><code>sd(x,na.rm = TRUE)</code></pre><h3 id="如何在R语言中设置当前工作目录的路径？"><a href="#如何在R语言中设置当前工作目录的路径？" class="headerlink" title="如何在R语言中设置当前工作目录的路径？"></a>如何在R语言中设置当前工作目录的路径？</h3><pre><code>setwd("Path")</code></pre><h3 id="“-”和”-”之间有什么区别？"><a href="#“-”和”-”之间有什么区别？" class="headerlink" title="“%%”和”%/%”之间有什么区别？"></a>“%%”和”%/%”之间有什么区别？</h3><p>“%%”给出第一向量与第二向量的除法的余数，而”%/%”给出第一向量与第二向量的除法的商。</p><h3 id="col-max-x-是什么？"><a href="#col-max-x-是什么？" class="headerlink" title="col.max(x)是什么？"></a>col.max(x)是什么？</h3><p>查找该列具有每行的最大值。</p><p>###给出创建直方图的命令。</p><pre><code>hist()</code></pre><h3 id="如何从R语言工作区中删除向量？"><a href="#如何从R语言工作区中删除向量？" class="headerlink" title="如何从R语言工作区中删除向量？"></a>如何从R语言工作区中删除向量？</h3><pre><code>rm(x)</code></pre><h3 id="列出包”MASS”中可用的数据集"><a href="#列出包”MASS”中可用的数据集" class="headerlink" title="列出包”MASS”中可用的数据集"></a>列出包”MASS”中可用的数据集</h3><pre><code>data(package ="MASS")</code></pre><p>###列出所有可用软件包中可用的数据集。</p><pre><code>data(package = .packages(all.available = TRUE))</code></pre><h3 id="什么是命令的使用-install-packages-file-choose-repos-NULL-？"><a href="#什么是命令的使用-install-packages-file-choose-repos-NULL-？" class="headerlink" title="什么是命令的使用 - install.packages(file.choose(),repos = NULL)？"></a>什么是命令的使用 - install.packages(file.choose(),repos = NULL)？</h3><p>它用于通过浏览和选择文件从本地目录安装R语言包。</p><h3 id="给出命令以检查元素15是否存在于向量x中。"><a href="#给出命令以检查元素15是否存在于向量x中。" class="headerlink" title="给出命令以检查元素15是否存在于向量x中。"></a>给出命令以检查元素15是否存在于向量x中。</h3><pre><code>15%在%x</code></pre><h3 id="给出创建散点图矩阵的语法。"><a href="#给出创建散点图矩阵的语法。" class="headerlink" title="给出创建散点图矩阵的语法。"></a>给出创建散点图矩阵的语法。</h3><pre><code>pairs(formula, data)</code></pre><p>其中公式表示成对使用的变量系列，数据表示从中获取变量的数据集。</p><h3 id="R语言中的subset-函数和sample-函数有什么区别？"><a href="#R语言中的subset-函数和sample-函数有什么区别？" class="headerlink" title="R语言中的subset()函数和sample()函数有什么区别？"></a>R语言中的subset()函数和sample()函数有什么区别？</h3><p>subset()函数用于选择变量和观察值。 sample()函数用于从数据集中选择大小为n的随机样本。</p><h3 id="如何检查”m”是R语言中的矩阵数据对象？"><a href="#如何检查”m”是R语言中的矩阵数据对象？" class="headerlink" title="如何检查”m”是R语言中的矩阵数据对象？"></a>如何检查”m”是R语言中的矩阵数据对象？</h3><p>is.matrix(m)应该重新运行TRUE。</p><h3 id="下面的表达式all-NA-NA-的输出是什么？"><a href="#下面的表达式all-NA-NA-的输出是什么？" class="headerlink" title="下面的表达式all(NA == NA)的输出是什么？"></a>下面的表达式all(NA == NA)的输出是什么？</h3><p>[1] NA</p><h3 id="如何获得矩阵在R语言中的转置？"><a href="#如何获得矩阵在R语言中的转置？" class="headerlink" title="如何获得矩阵在R语言中的转置？"></a>如何获得矩阵在R语言中的转置？</h3><p>函数t()用于转置矩阵。示例-t(m)，其中m是矩阵。</p><h3 id="在R语言中使用”next”语句是什么？"><a href="#在R语言中使用”next”语句是什么？" class="headerlink" title="在R语言中使用”next”语句是什么？"></a>在R语言中使用”next”语句是什么？</h3><p>当我们想要跳过循环的当前迭代而不终止它时，R编程语言中的”next”语句是有用的。</p><h1 id="统计篇"><a href="#统计篇" class="headerlink" title="统计篇"></a>统计篇</h1><h1 id="1-平均值，中位数和模式"><a href="#1-平均值，中位数和模式" class="headerlink" title="1.平均值，中位数和模式"></a>1.平均值，中位数和模式</h1><p>R中的统计分析通过使用许多内置函数来执行。 这些函数大多数是R基础包的一部分。 这些函数将R向量作为输入和参数，并给出结果。</p><p>我们在本章中讨论的功能是平均值，中位数和模式。</p><h3 id="Mean平均值"><a href="#Mean平均值" class="headerlink" title="Mean平均值"></a>Mean平均值</h3><p>通过求出数据集的和再除以求和数的总量得到平均值</p><p>函数mean()用于在R语言中计算平均值。</p><h3 id="语法-13"><a href="#语法-13" class="headerlink" title="语法"></a>语法</h3><p>用于计算R中的平均值的基本语法是 -</p><pre><code>mean(x, trim = 0, na.rm = FALSE, ...)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>x是输入向量。</p></li><li><p>trim用于从排序向量的两端丢弃一些观察结果。</p></li><li><p>na.rm用于从输入向量中删除缺失值。</p></li></ul><h3 id="例-14"><a href="#例-14" class="headerlink" title="例"></a>例</h3><pre><code># Create a vector. x &lt;- c(12,7,3,4.2,18,2,54,-21,8,-5)# Find Mean.result.mean &lt;- mean(x)print(result.mean)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 8.22</code></pre><h3 id="应用修剪选项"><a href="#应用修剪选项" class="headerlink" title="应用修剪选项"></a>应用修剪选项</h3><p>当提供trim参数时，向量中的值被排序，然后从计算平均值中减去所需的观察值。 </p><p>当trim = 0.3时，来自每端的3个值将从计算中减去以找到均值。</p><p>在这种情况下，排序的向量是（-21，-5,2,3,4.2,7,8,12,18,54），并且从用于计算平均值的向量中移除的值是（-21，-5,2） 从左边和（12,18,54）从右边。</p><pre><code># Create a vector.x &lt;- c(12,7,3,4.2,18,2,54,-21,8,-5)# Find Mean.result.mean &lt;-  mean(x,trim = 0.3)print(result.mean)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 5.55</code></pre><h3 id="应用NA选项"><a href="#应用NA选项" class="headerlink" title="应用NA选项"></a>应用NA选项</h3><p>如果有缺失值，则平均函数返回NA。</p><p>要从计算中删除缺少的值，请使用na.rm = TRUE。 这意味着去除NA值。</p><pre><code># Create a vector. x &lt;- c(12,7,3,4.2,18,2,54,-21,8,-5,NA)# Find mean.result.mean &lt;-  mean(x)print(result.mean)# Find mean dropping NA values.result.mean &lt;-  mean(x,na.rm = TRUE)print(result.mean)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] NA[1] 8.22</code></pre><h3 id="Median中位数"><a href="#Median中位数" class="headerlink" title="Median中位数"></a>Median中位数</h3><p>数据系列中的最中间值称为中值。 在R语言中使用median()函数来计算此值。</p><h3 id="语法-14"><a href="#语法-14" class="headerlink" title="语法"></a>语法</h3><p>计算R语言中位数的基本语法是 -</p><pre><code>median(x, na.rm = FALSE)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>x是输入向量。</p></li><li><p>na.rm用于从输入向量中删除缺失值。</p></li></ul><h3 id="例-15"><a href="#例-15" class="headerlink" title="例"></a>例</h3><pre><code># Create the vector.x &lt;- c(12,7,3,4.2,18,2,54,-21,8,-5)# Find the median.median.result &lt;- median(x)print(median.result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 5.6</code></pre><h3 id="Mode模式"><a href="#Mode模式" class="headerlink" title="Mode模式"></a>Mode模式</h3><p>模式是一组数据中出现次数最多的值。 Unike平均值和中位数，模式可以同时包含数字和字符数据。</p><p>R语言没有标准的内置函数来计算模式。 因此，我们创建一个用户函数来计算R语言中的数据集的模式。该函数将向量作为输入，并将模式值作为输出。</p><h3 id="例-16"><a href="#例-16" class="headerlink" title="例"></a>例</h3><pre><code># Create the function.getmode &lt;- function(v) {   uniqv &lt;- unique(v)   uniqv[which.max(tabulate(match(v, uniqv)))]}# Create the vector with numbers.v &lt;- c(2,1,2,3,1,2,3,4,1,5,5,3,2,3)# Calculate the mode using the user function.result &lt;- getmode(v)print(result)# Create the vector with characters.charv &lt;- c("o","it","the","it","it")# Calculate the mode using the user function.result &lt;- getmode(charv)print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 2[1] "it"</code></pre><h1 id="2-线性回归"><a href="#2-线性回归" class="headerlink" title="2.线性回归"></a>2.线性回归</h1><p>回归分析是一种非常广泛使用的统计工具，用于建立两个变量之间的关系模型。 这些变量之一称为预测变量，其值通过实验收集。 另一个变量称为响应变量，其值从预测变量派生。</p><p>在线性回归中，这两个变量通过方程相关，其中这两个变量的指数（幂）为1.数学上，线性关系表示当绘制为曲线图时的直线。 任何变量的指数不等于1的非线性关系将创建一条曲线。</p><p>线性回归的一般数学方程为 -</p><pre><code>y = ax + b</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>y</strong>是响应变量。</p></li><li><p><strong>x</strong>是预测变量。</p></li><li><p><strong>a</strong>和<strong>b</strong>被称为系数常数。</p></li></ul><h3 id="建立回归的步骤"><a href="#建立回归的步骤" class="headerlink" title="建立回归的步骤"></a>建立回归的步骤</h3><p>回归的简单例子是当人的身高已知时预测人的体重。 为了做到这一点，我们需要有一个人的身高和体重之间的关系。</p><p>创建关系的步骤是 - </p><ul><li><p>进行收集高度和相应重量的观测值的样本的实验。</p></li><li><p>使用R语言中的<strong>lm()</strong>函数创建关系模型。</p></li><li><p>从创建的模型中找到系数，并使用这些创建数学方程</p></li><li><p>获得关系模型的摘要以了解预测中的平均误差。 也称为残差。</p></li><li><p>为了预测新人的体重，使用R中的<strong>predict()</strong>函数。</p></li></ul><h3 id="输入数据-3"><a href="#输入数据-3" class="headerlink" title="输入数据"></a>输入数据</h3><p>下面是代表观察的样本数据 -</p><pre><code># Values of height151, 174, 138, 186, 128, 136, 179, 163, 152, 131# Values of weight.63, 81, 56, 91, 47, 57, 76, 72, 62, 48</code></pre><h3 id="LM-函数"><a href="#LM-函数" class="headerlink" title="LM()函数"></a>LM()函数</h3><p>此函数创建预测变量和响应变量之间的关系模型。</p><h3 id="语法-15"><a href="#语法-15" class="headerlink" title="语法"></a>语法</h3><p>线性回归中<strong>lm()</strong>函数的基本语法是 -</p><pre><code>lm(formula,data)</code></pre><p>以下是所使用的参数的说明 -</p><ul><li><p>公式是表示<strong>x</strong>和<strong>y</strong>之间的关系的符号。</p></li><li><p>数据是应用公式的向量。</p></li></ul><h3 id="创建关系模型并获取系数"><a href="#创建关系模型并获取系数" class="headerlink" title="创建关系模型并获取系数"></a>创建关系模型并获取系数</h3><pre><code>x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)# Apply the lm() function.relation &lt;- lm(y~x)print(relation)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Call:lm(formula = y ~ x)Coefficients:(Intercept)            x     -38.4551          0.6746 </code></pre><h3 id="获取相关的摘要"><a href="#获取相关的摘要" class="headerlink" title="获取相关的摘要"></a>获取相关的摘要</h3><pre><code>x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)# Apply the lm() function.relation &lt;- lm(y~x)print(summary(relation))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Call:lm(formula = y ~ x)Residuals:    Min      1Q     Median      3Q     Max -6.3002    -1.6629  0.0412    1.8944  3.9775 Coefficients:             Estimate Std. Error t value Pr(&gt;|t|)    (Intercept) -38.45509    8.04901  -4.778  0.00139 ** x             0.67461    0.05191  12.997 1.16e-06 ***---Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1Residual standard error: 3.253 on 8 degrees of freedomMultiple R-squared:  0.9548,    Adjusted R-squared:  0.9491 F-statistic: 168.9 on 1 and 8 DF,  p-value: 1.164e-06</code></pre><h3 id="predict-函数"><a href="#predict-函数" class="headerlink" title="predict()函数"></a>predict()函数</h3><h3 id="语法-16"><a href="#语法-16" class="headerlink" title="语法"></a>语法</h3><p>线性回归中的predict（）的基本语法是 -</p><pre><code>predict(object, newdata)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>object</strong>是已使用<strong>lm()</strong>函数创建的公式。</p></li><li><p><strong>newdata</strong>是包含预测变量的新值的向量。</p></li></ul><h3 id="预测新人的体重"><a href="#预测新人的体重" class="headerlink" title="预测新人的体重"></a>预测新人的体重</h3><pre><code># The predictor vector.x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)# The resposne vector.y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)# Apply the lm() function.relation &lt;- lm(y~x)# Find weight of a person with height 170.a &lt;- data.frame(x = 170)result &lt;-  predict(relation,a)print(result)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      1 76.22869 </code></pre><h3 id="以图形方式可视化回归"><a href="#以图形方式可视化回归" class="headerlink" title="以图形方式可视化回归"></a>以图形方式可视化回归</h3><pre><code># Create the predictor and response variable.x &lt;- c(151, 174, 138, 186, 128, 136, 179, 163, 152, 131)y &lt;- c(63, 81, 56, 91, 47, 57, 76, 72, 62, 48)relation &lt;- lm(y~x)# Give the chart file a name.png(file = "linearregression.png")# Plot the chart.plot(y,x,col = "blue",main = "Height &amp; Weight Regression",abline(lm(x~y)),cex = 1.3,pch = 16,xlab = "Weight in Kg",ylab = "Height in cm")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-4fefe7ec44266e7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="R中线性回归"></p><h1 id="3-多重回归"><a href="#3-多重回归" class="headerlink" title="3.多重回归"></a>3.多重回归</h1><p>多元回归是线性回归到两个以上变量之间的关系的延伸。 在简单线性关系中，我们有一个预测变量和一个响应变量，但在多元回归中，我们有多个预测变量和一个响应变量。</p><p>多元回归的一般数学方程为 -</p><pre><code>y = a + b1x1 + b2x2 +...bnxn</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>y是响应变量。</p></li><li><p>a，b1，b2 … bn是系数。</p></li><li><p>x1，x2，… xn是预测变量。</p></li></ul><p>我们使用R语言中的lm()函数创建回归模型。模型使用输入数据确定系数的值。 接下来，我们可以使用这些系数来预测给定的一组预测变量的响应变量的值。</p><h3 id="lm-函数"><a href="#lm-函数" class="headerlink" title="lm()函数"></a>lm()函数</h3><p>此函数创建预测变量和响应变量之间的关系模型。</p><h3 id="语法-17"><a href="#语法-17" class="headerlink" title="语法"></a>语法</h3><p>lm()函数在多元回归中的基本语法是 -</p><pre><code>lm(y ~ x1+x2+x3...,data)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>公式是表示响应变量和预测变量之间的关系的符号。</p></li><li><p>数据是应用公式的向量。</p></li></ul><h3 id="例-17"><a href="#例-17" class="headerlink" title="例"></a>例</h3><p>输入数据<br>考虑在R语言环境中可用的数据集“mtcars”。 它给出了每加仑里程（mpg），气缸排量（“disp”），马力（“hp”），汽车重量（“wt”）和一些其他参数的不同汽车模型之间的比较。</p><p>模型的目标是建立“mpg”作为响应变量与“disp”，“hp”和“wt”作为预测变量之间的关系。 为此，我们从mtcars数据集中创建这些变量的子集。</p><pre><code>input &lt;- mtcars[,c("mpg","disp","hp","wt")]print(head(input))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>                   mpg   disp   hp    wtMazda RX4          21.0  160    110   2.620Mazda RX4 Wag      21.0  160    110   2.875Datsun 710         22.8  108     93   2.320Hornet 4 Drive     21.4  258    110   3.215Hornet Sportabout  18.7  360    175   3.440Valiant            18.1  225    105   3.460</code></pre><p>创建关系模型并获取系数</p><pre><code>input &lt;- mtcars[,c("mpg","disp","hp","wt")]# Create the relationship model.model &lt;- lm(mpg~disp+hp+wt, data = input)# Show the model.print(model)# Get the Intercept and coefficients as vector elements.cat("# # # # The Coefficient Values # # # ","")a &lt;- coef(model)[1]print(a)Xdisp &lt;- coef(model)[2]Xhp &lt;- coef(model)[3]Xwt &lt;- coef(model)[4]print(Xdisp)print(Xhp)print(Xwt)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Call:lm(formula = mpg ~ disp + hp + wt, data = input)Coefficients:(Intercept)         disp           hp           wt    37.105505      -0.000937        -0.031157    -3.800891  # # # # The Coefficient Values # # # (Intercept)    37.10551          disp -0.0009370091          hp -0.03115655        wt -3.800891 </code></pre><h3 id="创建回归模型的方程"><a href="#创建回归模型的方程" class="headerlink" title="创建回归模型的方程"></a>创建回归模型的方程</h3><p>基于上述截距和系数值，我们创建了数学方程。</p><pre><code>Y = a+Xdisp.x1+Xhp.x2+Xwt.x3orY = 37.15+(-0.000937)*x1+(-0.0311)*x2+(-3.8008)*x3</code></pre><h3 id="应用方程预测新值"><a href="#应用方程预测新值" class="headerlink" title="应用方程预测新值"></a>应用方程预测新值</h3><p>当提供一组新的位移，马力和重量值时，我们可以使用上面创建的回归方程来预测里程数。<br>对于disp = 221，hp = 102和wt = 2.91的汽车，预测里程为 -</p><pre><code>Y = 37.15+(-0.000937)*221+(-0.0311)*102+(-3.8008)*2.91 = 22.7104</code></pre><h1 id="4-逻辑回归"><a href="#4-逻辑回归" class="headerlink" title="4.逻辑回归"></a>4.逻辑回归</h1><p>逻辑回归是回归模型，其中响应变量（因变量）具有诸如True / False或0/1的分类值。它实际上基于将其与预测变量相关的数学方程测量二元响应的概率作为响应变量的值。</p><p>逻辑回归的一般数学方程为 -</p><pre><code>y = 1/(1+e^-(a+b1x1+b2x2+b3x3+...))</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>Ÿ是响应变量。</p></li><li><p>X是预测变量。</p></li><li><p>一和b是作为数字常数的系数。</p></li></ul><h3 id="用于创建回归模型的函数是GLM（）函数。"><a href="#用于创建回归模型的函数是GLM（）函数。" class="headerlink" title="用于创建回归模型的函数是GLM（）函数。"></a>用于创建回归模型的函数是GLM（）函数。</h3><p>###语法<br>逻辑回归中glm（）函数的基本语法是 -</p><pre><code>glm(formula,data,family)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>式是表示变量之间的关系的符号。</p></li><li><p>数据是给出这些变量的值的数据集。</p></li><li><p>family是R语言对象来指定模型的细节。它的值是二项逻辑回归。</p></li></ul><h3 id="例-18"><a href="#例-18" class="headerlink" title="例"></a>例</h3><p>内置数据集“mtcars”描述具有各种发动机规格的汽车的不同型号。在“mtcars”数据集中，传输模式（自动或手动）由am列描述，它是一个二进制值（0或1）。我们可以在列“是”和其他3列（马力，重量和CYL）之间创建逻辑回归模型。</p><pre><code># Select some columns form mtcars.input &lt;- mtcars[,c("am","cyl","hp","wt")]print(head(input))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>                  am   cyl  hp    wtMazda RX4          1   6    110   2.620Mazda RX4 Wag      1   6    110   2.875Datsun 710         1   4     93   2.320Hornet 4 Drive     0   6    110   3.215Hornet Sportabout  0   8    175   3.440Valiant            0   6    105   3.460</code></pre><h3 id="创建回归模型"><a href="#创建回归模型" class="headerlink" title="创建回归模型"></a>创建回归模型</h3><p>我们使用GLM（）函数创建回归模型，并得到其摘要进行分析。</p><pre><code>input &lt;- mtcars[,c("am","cyl","hp","wt")]am.data = glm(formula = am ~ cyl + hp + wt, data = input, family = binomial)print(summary(am.data))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Call:glm(formula = am ~ cyl + hp + wt, family = binomial, data = input)Deviance Residuals:      Min        1Q      Median        3Q       Max  -2.17272     -0.14907  -0.01464     0.14116   1.27641  Coefficients:            Estimate Std. Error z value Pr(&gt;|z|)  (Intercept) 19.70288    8.11637   2.428   0.0152 *cyl          0.48760    1.07162   0.455   0.6491  hp           0.03259    0.01886   1.728   0.0840 .wt          -9.14947    4.15332  -2.203   0.0276 *---Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1(Dispersion parameter for binomial family taken to be 1)    Null deviance: 43.2297  on 31  degrees of freedomResidual deviance:  9.8415  on 28  degrees of freedomAIC: 17.841Number of Fisher Scoring iterations: 8</code></pre><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在总结中，对于变量“cyl”和“hp”，最后一列中的p值大于0.05，我们认为它们对变量“am”的值有贡献是无关紧要的。只有重量（wt）影响该回归模型中的“是”值。</p><h1 id="5-标准分布"><a href="#5-标准分布" class="headerlink" title="5.标准分布"></a>5.标准分布</h1><p>在来自独立源的数据的随机集合中，通常观察到数据的分布是正常的。这意味着，在绘制水平轴上的变量值和垂直轴上的值的计数的图形时，我们得到钟形曲线。曲线的中心表示数据集的平均值。在图中，50％的值位于平均值的左侧，另外50％位于图表的右侧。这在统计学中被称为正态分布。</p><p>R语言有四个内置函数来产生正态分布。它们描述如下。</p><pre><code>dnorm(x, mean, sd)pnorm(x, mean, sd)qnorm(p, mean, sd)rnorm(n, mean, sd)</code></pre><p>以下是在上述功能中使用的参数的描述 - </p><ul><li><p><strong>X</strong>是数字的向量。</p></li><li><p><strong>p</strong>是概率的向量。</p></li><li><p><strong>Ñ</strong>是观察的数量（样本大小）。</p></li><li><p><strong>mean</strong>是样本数据的平均值。它的默认值为零。</p></li><li><p><strong>sd</strong>是标准偏差。它的默认值为1。</p></li></ul><h3 id="dnorm（）"><a href="#dnorm（）" class="headerlink" title="dnorm（）"></a>dnorm（）</h3><p>该函数给出给定平均值和标准偏差在每个点的概率分布的高度。</p><pre><code># Create a sequence of numbers between -10 and 10 incrementing by 0.1.x &lt;- seq(-10, 10, by = .1)# Choose the mean as 2.5 and standard deviation as 0.5.y &lt;- dnorm(x, mean = 2.5, sd = 0.5)# Give the chart file a name.png(file = "dnorm.png")plot(x,y)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0d46ed17cdbd4403.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dnorm（）图"></p><h3 id="pnorm（）"><a href="#pnorm（）" class="headerlink" title="pnorm（）"></a>pnorm（）</h3><p>该函数给出正态分布随机数的概率小于给定数的值。它也被称为“累积分布函数”。</p><pre><code># Create a sequence of numbers between -10 and 10 incrementing by 0.2.x &lt;- seq(-10,10,by = .2)# Choose the mean as 2.5 and standard deviation as 2\. y &lt;- pnorm(x, mean = 2.5, sd = 2)# Give the chart file a name.png(file = "pnorm.png")# Plot the graph.plot(x,y)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-9de1d7c995b83620.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pnorm（）图"></p><h3 id="qnorm（）"><a href="#qnorm（）" class="headerlink" title="qnorm（）"></a>qnorm（）</h3><p>该函数采用概率值，并给出累积值与概率值匹配的数字。</p><pre><code># Create a sequence of probability values incrementing by 0.02.x &lt;- seq(0, 1, by = 0.02)# Choose the mean as 2 and standard deviation as 3.y &lt;- qnorm(x, mean = 2, sd = 1)# Give the chart file a name.png(file = "qnorm.png")# Plot the graph.plot(x,y)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-89ef8e62a5568e24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="qnorm（）图"></p><h3 id="RNORM（）"><a href="#RNORM（）" class="headerlink" title="RNORM（）"></a>RNORM（）</h3><p>此函数用于生成分布正常的随机数。它将样本大小作为输入，并生成许多随机数。我们绘制一个直方图来显示生成的数字的分布。</p><pre><code># Create a sample of 50 numbers which are normally distributed.y &lt;- rnorm(50)# Give the chart file a name.png(file = "rnorm.png")# Plot the histogram for this sample.hist(y, main = "Normal DIstribution")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-8dee5625b739e0e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RNORM（）图"></p><h1 id="6-二项分布"><a href="#6-二项分布" class="headerlink" title="6.二项分布"></a>6.二项分布</h1><p>二项分布模型处理在一系列实验中仅发现两个可能结果的事件的成功概率。 例如，掷硬币总是给出头或尾。 在二项分布期间估计在10次重复抛掷硬币中精确找到3个头的概率。</p><p>R语言有四个内置函数来生成二项分布。 它们描述如下。</p><pre><code>dbinom(x, size, prob)pbinom(x, size, prob)qbinom(p, size, prob)rbinom(n, size, prob)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>x</strong>是数字的向量。</p></li><li><p><strong>p</strong>是概率向量。</p></li><li><p><strong>n</strong>是观察的数量。</p></li><li><p><strong>size</strong>是试验的数量。</p></li><li><p><strong>prob</strong>是每个试验成功的概率。</p></li></ul><h3 id="dbinom（）"><a href="#dbinom（）" class="headerlink" title="dbinom（）"></a>dbinom（）</h3><p>该函数给出每个点的概率密度分布。</p><pre><code># Create a sample of 50 numbers which are incremented by 1.x &lt;- seq(0,50,by = 1)# Create the binomial distribution.y &lt;- dbinom(x,50,0.5)# Give the chart file a name.png(file = "dbinom.png")# Plot the graph for this sample.plot(x,y)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-b294a38ff32aebfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dbinom（）图"></p><h3 id="pbinom（）"><a href="#pbinom（）" class="headerlink" title="pbinom（）"></a>pbinom（）</h3><p>此函数给出事件的累积概率。 它是表示概率的单个值。</p><pre><code># Probability of getting 26 or less heads from a 51 tosses of a coin.x &lt;- pbinom(26,51,0.5)print(x)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 0.610116</code></pre><h3 id="qbinom（）"><a href="#qbinom（）" class="headerlink" title="qbinom（）"></a>qbinom（）</h3><p>该函数采用概率值，并给出累积值与概率值匹配的数字。</p><pre><code># How many heads will have a probability of 0.25 will come out when a coin is tossed 51 times.x &lt;- qbinom(0.25,51,1/2)print(x)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 23</code></pre><h3 id="rbinom（）"><a href="#rbinom（）" class="headerlink" title="rbinom（）"></a>rbinom（）</h3><p>该函数从给定样本产生给定概率的所需数量的随机值。</p><pre><code># Find 8 random values from a sample of 150 with probability of 0.4.x &lt;- rbinom(8,150,.4)print(x)</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 58 61 59 66 55 60 61 67</code></pre><h1 id="7-泊松回归"><a href="#7-泊松回归" class="headerlink" title="7.泊松回归"></a>7.泊松回归</h1><p>泊松回归包括回归模型，其中响应变量是计数而不是分数的形式。 例如，足球比赛系列中的出生次数或胜利次数。 此外，响应变量的值遵循泊松分布。</p><p>泊松回归的一般数学方程为 -</p><pre><code>log(y) = a + b1x1 + b2x2 + bnxn.....</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>y是响应变量。</p></li><li><p>a和b是数字系数。</p></li><li><p>x是预测变量。</p></li></ul><p>###用于创建泊松回归模型的函数是glm()函数。</p><h3 id="语法-18"><a href="#语法-18" class="headerlink" title="语法"></a>语法</h3><p>在泊松回归中glm()函数的基本语法是 -</p><pre><code>glm(formula,data,family)</code></pre><p>以下是在上述功能中使用的参数的描述 - </p><ul><li><p>formula是表示变量之间的关系的符号。</p></li><li><p>data是给出这些变量的值的数据集。</p></li><li><p>family是R语言对象来指定模型的细节。 它的值是“泊松”的逻辑回归。</p></li></ul><h3 id="例-19"><a href="#例-19" class="headerlink" title="例"></a>例</h3><p>我们有内置的数据集“warpbreaks”，其描述了羊毛类型（A或B）和张力（低，中或高）对每个织机的经纱断裂数量的影响。 让我们考虑“休息”作为响应变量，它是休息次数的计数。 羊毛“类型”和“张力”作为预测变量。</p><p>输入数据</p><pre><code>input &lt;- warpbreaksprint(head(input))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>      breaks   wool  tension1     26       A     L2     30       A     L3     54       A     L4     25       A     L5     70       A     L6     52       A     L</code></pre><p>创建回归模型</p><pre><code>output &lt;-glm(formula = breaks ~ wool+tension,                    data = warpbreaks,                  family = poisson)print(summary(output))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Call:glm(formula = breaks ~ wool + tension, family = poisson, data = warpbreaks)Deviance Residuals:     Min       1Q     Median       3Q      Max    -3.6871  -1.6503  -0.4269     1.1902   4.2616  Coefficients:            Estimate Std. Error z value Pr(&gt;|z|)    (Intercept)  3.69196    0.04541  81.302  &lt; 2e-16 ***woolB       -0.20599    0.05157  -3.994 6.49e-05 ***tensionM    -0.32132    0.06027  -5.332 9.73e-08 ***tensionH    -0.51849    0.06396  -8.107 5.21e-16 ***---Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1(Dispersion parameter for poisson family taken to be 1)    Null deviance: 297.37  on 53  degrees of freedomResidual deviance: 210.39  on 50  degrees of freedomAIC: 493.06Number of Fisher Scoring iterations: 4</code></pre><p>在摘要中，我们查找最后一列中的p值小于0.05，以考虑预测变量对响应变量的影响。 如图所示，具有张力类型M和H的羊毛类型B对断裂计数有影响。</p><h1 id="8-协方差分析"><a href="#8-协方差分析" class="headerlink" title="8.协方差分析"></a>8.协方差分析</h1><p>我们使用回归分析创建模型，描述变量在预测变量对响应变量的影响。 有时，如果我们有一个类别变量，如Yes / No或Male / Female等。简单的回归分析为分类变量的每个值提供多个结果。 在这种情况下，我们可以通过将分类变量与预测变量一起使用并比较分类变量的每个级别的回归线来研究分类变量的效果。 这样的分析被称为协方差分析，也称为ANCOVA。</p><h3 id="例-20"><a href="#例-20" class="headerlink" title="例"></a>例</h3><p>考虑在数据集mtcars中内置的R语言。 在其中我们观察到字段“am”表示传输的类型（自动或手动）。 它是值为0和1的分类变量。汽车的每加仑英里数（mpg）也可以取决于马力（“hp”）的值。</p><p>我们研究“am”的值对“mpg”和“hp”之间回归的影响。 它是通过使用aov()函数，然后使用anova()函数来比较多个回归来完成的。</p><h3 id="输入数据-4"><a href="#输入数据-4" class="headerlink" title="输入数据"></a>输入数据</h3><p>从数据集mtcars创建一个包含字段“mpg”，“hp”和“am”的数据框。 这里我们取“mpg”作为响应变量，“hp”作为预测变量，“am”作为分类变量。</p><pre><code>input &lt;- mtcars[,c("am","mpg","hp")]print(head(input))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>                   am   mpg   hpMazda RX4          1    21.0  110Mazda RX4 Wag      1    21.0  110Datsun 710         1    22.8   93Hornet 4 Drive     0    21.4  110Hornet Sportabout  0    18.7  175Valiant            0    18.1  105</code></pre><h3 id="协方差分析"><a href="#协方差分析" class="headerlink" title="协方差分析"></a>协方差分析</h3><p>我们创建一个回归模型，以“hp”作为预测变量，“mpg”作为响应变量，考虑“am”和“hp”之间的相互作用。</p><p>模型与分类变量和预测变量之间的相互作用</p><pre><code># Get the dataset.input &lt;- mtcars# Create the regression model.result &lt;- aov(mpg~hp*am,data = input)print(summary(result))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>            Df Sum Sq Mean Sq F value   Pr(&gt;F)    hp           1  678.4   678.4  77.391 1.50e-09 ***am           1  202.2   202.2  23.072 4.75e-05 ***hp:am        1    0.0     0.0   0.001    0.981    Residuals   28  245.4     8.8                     ---Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</code></pre><p>这个结果表明，马力和传输类型对每加仑的英里有显着的影响，因为两种情况下的p值都小于0.05。 但是这两个变量之间的相互作用不显着，因为p值大于0.05。</p><p>没有分类变量和预测变量之间相互作用的模型</p><pre><code># Get the dataset.input &lt;- mtcars# Create the regression model.result &lt;- aov(mpg~hp+am,data = input)print(summary(result))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>            Df  Sum Sq  Mean Sq   F value   Pr(&gt;F)    hp           1  678.4   678.4   80.15 7.63e-10 ***am           1  202.2   202.2   23.89 3.46e-05 ***Residuals   29  245.4     8.5                     ---Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1</code></pre><p>这个结果表明，马力和传输类型对每加仑的英里有显着的影响，因为两种情况下的p值都小于0.05。</p><h3 id="比较两个模型"><a href="#比较两个模型" class="headerlink" title="比较两个模型"></a>比较两个模型</h3><p>现在我们可以比较两个模型来得出结论，变量的相互作用是否真正重要。 为此，我们使用anova()函数。</p><pre><code># Get the dataset.input &lt;- mtcars# Create the regression models.result1 &lt;- aov(mpg~hp*am,data = input)result2 &lt;- aov(mpg~hp+am,data = input)# Compare the two models.print(anova(result1,result2))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Model 1: mpg ~ hp * amModel 2: mpg ~ hp + am  Res.Df    RSS Df  Sum of Sq     F Pr(&gt;F)1     28 245.43                           2     29 245.44 -1 -0.0052515 6e-04 0.9806</code></pre><p>由于p值大于0.05，我们得出结论，马力和传播类型之间的相互作用不显着。 因此，在汽车和手动变速器模式下，每加仑的里程将以类似的方式取决于汽车的马力。</p><h1 id="9-时间序列分析"><a href="#9-时间序列分析" class="headerlink" title="9.时间序列分析"></a>9.时间序列分析</h1><p>时间序列是一系列数据点，其中每个数据点与时间戳相关联。 一个简单的例子是股票在某一天的不同时间点的股票价格。 另一个例子是一个地区在一年中不同月份的降雨量。 R语言使用许多函数来创建，操作和绘制时间序列数据。 时间序列的数据存储在称为时间序列对象的R对象中。 它也是一个R语言数据对象，如矢量或数据帧。</p><p>使用ts()函数创建时间序列对象。</p><h2 id="语法-19"><a href="#语法-19" class="headerlink" title="语法"></a>语法</h2><p>时间序列分析中<strong>ts()</strong>函数的基本语法是 -</p><pre><code>timeseries.object.name &lt;-  ts(data, start, end, frequency)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>data</strong>是包含在时间序列中使用的值的向量或矩阵。</p></li><li><p><strong>start</strong>以时间序列指定第一次观察的开始时间。</p></li><li><p><strong>end</strong>指定时间序列中最后一次观测的结束时间。</p></li><li><p><strong>frequency</strong>指定每单位时间的观测数。</p></li></ul><p>除了参数“data”，所有其他参数是可选的。</p><h2 id="例-21"><a href="#例-21" class="headerlink" title="例"></a>例</h2><p>考虑从2012年1月开始的一个地方的年降雨量细节。我们创建一个R时间序列对象为期12个月并绘制它。</p><pre><code># Get the data points in form of a R vector.rainfall &lt;- c(799,1174.8,865.1,1334.6,635.4,918.5,685.5,998.6,784.2,985,882.8,1071)# Convert it to a time series object.rainfall.timeseries &lt;- ts(rainfall,start = c(2012,1),frequency = 12)# Print the timeseries data.print(rainfall.timeseries)# Give the chart file a name.png(file = "rainfall.png")# Plot a graph of the time series.plot(rainfall.timeseries)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果及图表 -</p><pre><code>Jan    Feb    Mar    Apr    May     Jun    Jul    Aug    Sep2012  799.0  1174.8  865.1  1334.6  635.4  918.5  685.5  998.6  784.2        Oct    Nov    Dec2012  985.0  882.8 1071.0</code></pre><p>时间序列图 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-cb2f3ea239650e3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="时间序列，使用R"></p><h2 id="不同的时间间隔"><a href="#不同的时间间隔" class="headerlink" title="不同的时间间隔"></a>不同的时间间隔</h2><p><strong>ts()</strong>函数中的频率参数值决定了测量数据点的时间间隔。 值为12表示时间序列为12个月。 其他值及其含义如下 - </p><ul><li><p>频率= 12指定一年中每个月的数据点。</p></li><li><p>频率= 4每年的每个季度的数据点。</p></li><li><p>频率= 6每小时的10分钟的数据点。</p></li><li><p>频率= 24 * 6将一天的每10分钟的数据点固定。</p></li></ul><h2 id="多时间序列"><a href="#多时间序列" class="headerlink" title="多时间序列"></a>多时间序列</h2><p>我们可以通过将两个系列组合成一个矩阵，在一个图表中绘制多个时间序列。</p><pre><code># Get the data points in form of a R vector.rainfall1 &lt;- c(799,1174.8,865.1,1334.6,635.4,918.5,685.5,998.6,784.2,985,882.8,1071)rainfall2 &lt;-            c(655,1306.9,1323.4,1172.2,562.2,824,822.4,1265.5,799.6,1105.6,1106.7,1337.8)# Convert them to a matrix.combined.rainfall &lt;-  matrix(c(rainfall1,rainfall2),nrow = 12)# Convert it to a time series object.rainfall.timeseries &lt;- ts(combined.rainfall,start = c(2012,1),frequency = 12)# Print the timeseries data.print(rainfall.timeseries)# Give the chart file a name.png(file = "rainfall_combined.png")# Plot a graph of the time series.plot(rainfall.timeseries, main = "Multiple Time Series")# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果及图表 -</p><pre><code>          Series 1  Series 2Jan 2012    799.0    655.0Feb 2012   1174.8   1306.9Mar 2012    865.1   1323.4Apr 2012   1334.6   1172.2May 2012    635.4    562.2Jun 2012    918.5    824.0Jul 2012    685.5    822.4Aug 2012    998.6   1265.5Sep 2012    784.2    799.6Oct 2012    985.0   1105.6Nov 2012    882.8   1106.7Dec 2012   1071.0   1337.8</code></pre><p>多时间序列图 -</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-5bfab3dbfb998f01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结合时间序列，使用R"></p><h1 id="10-非线性最小二乘"><a href="#10-非线性最小二乘" class="headerlink" title="10.非线性最小二乘"></a>10.非线性最小二乘</h1><p>当模拟真实世界数据用于回归分析时，我们观察到，很少情况下，模型的方程是给出线性图的线性方程。大多数时候，真实世界数据模型的方程涉及更高程度的数学函数，如3的指数或sin函数。在这种情况下，模型的图给出了曲线而不是线。线性和非线性回归的目的是调整模型参数的值，以找到最接近您的数据的线或曲线。在找到这些值时，我们将能够以良好的精确度估计响应变量。</p><p>在最小二乘回归中，我们建立了一个回归模型，其中来自回归曲线的不同点的垂直距离的平方和被最小化。我们通常从定义的模型开始，并假设系数的一些值。然后我们应用R语言的<strong>nls()</strong>函数获得更准确的值以及置信区间。</p><h2 id="语法-20"><a href="#语法-20" class="headerlink" title="语法"></a>语法</h2><p>在R语言中创建非线性最小二乘测试的基本语法是 -</p><pre><code>nls(formula, data, start)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>formula</strong>是包括变量和参数的非线性模型公式。</p></li><li><p><strong>data</strong>是用于计算公式中变量的数据框。</p></li><li><p><strong>start</strong>是起始估计的命名列表或命名数字向量。</p></li></ul><h2 id="例-22"><a href="#例-22" class="headerlink" title="例"></a>例</h2><p>我们将考虑一个假设其系数的初始值的非线性模型。 接下来，我们将看到这些假设值的置信区间是什么，以便我们可以判断这些值在模型中有多好。</p><p>所以让我们考虑下面的方程为这个目的 -</p><pre><code>a = b1*x^2+b2</code></pre><p>让我们假设初始系数为1和3，并将这些值拟合到<strong>nls()</strong>函数中。</p><pre><code>xvalues &lt;- c(1.6,2.1,2,2.23,3.71,3.25,3.4,3.86,1.19,2.21)yvalues &lt;- c(5.19,7.43,6.94,8.11,18.75,14.88,16.06,19.12,3.21,7.58)# Give the chart file a name.png(file = "nls.png")# Plot these values.plot(xvalues,yvalues)# Take the assumed values and fit into the model.model &lt;- nls(yvalues ~ b1*xvalues^2+b2,start = list(b1 = 1,b2 = 3))# Plot the chart with new data by fitting it to a prediction from 100 data points.new.data &lt;- data.frame(xvalues = seq(min(xvalues),max(xvalues),len = 100))lines(new.data$xvalues,predict(model,newdata = new.data))# Save the file.dev.off()# Get the sum of the squared residuals.print(sum(resid(model)^2))# Get the confidence intervals on the chosen values of the coefficients.print(confint(model))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>[1] 1.081935Waiting for profiling to be done...       2.5%    97.5%b1 1.137708 1.253135b2 1.497364 2.496484</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-064077d964aabf50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="非线性至少方块R"></p><p>我们可以得出结论，b1的值更接近1，而b2的值更接近2而不是3。</p><h1 id="11-决策树"><a href="#11-决策树" class="headerlink" title="11.决策树"></a>11.决策树</h1><p>决策树是以树的形式表示选择及其结果的图。图中的节点表示事件或选择，并且图的边缘表示决策规则或条件。它主要用于使用R的机器学习和数据挖掘应用程序。</p><p>决策树的使用的例子是 - 预测电子邮件是垃圾邮件或非垃圾邮件，预测肿瘤癌变，或者基于这些因素预测贷款的信用风险。通常，使用观测数据（也称为训练数据）来创建模型。然后使用一组验证数据来验证和改进模型。 R具有用于创建和可视化决策树的包。对于新的预测变量集合，我们使用此模型来确定R包“party”用于创建决策树。</p><h2 id="安装R语言包"><a href="#安装R语言包" class="headerlink" title="安装R语言包"></a>安装R语言包</h2><p>在R语言控制台中使用以下命令安装软件包。您还必须安装相关软件包（如果有）。</p><pre><code>install.packages("party")</code></pre><p>“party”包具有用于创建和分析决策树的函数<strong>ctree()</strong>。</p><h2 id="语法-21"><a href="#语法-21" class="headerlink" title="语法"></a>语法</h2><p>在R中创建决策树的基本语法是 -</p><pre><code>ctree(formula, data)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>formula</strong>是描述预测变量和响应变量的公式。</p></li><li><p><strong>data</strong>是所使用的数据集的名称。</p></li></ul><h2 id="输入数据-5"><a href="#输入数据-5" class="headerlink" title="输入数据"></a>输入数据</h2><p>我们将使用名为readingSkills的R内置数据集来创建决策树。 它描述了某人的readingSkills的分数，如果我们知道变量“年龄”，“shoesize”，“分数”，以及该人是否为母语者。</p><p>这里是示例数据。</p><pre><code># Load the party package. It will automatically load other dependent packages.library(party)# Print some records from data set readingSkills.print(head(readingSkills))</code></pre><p>当我们执行上面的代码，它产生以下结果及图表 -</p><pre><code>  nativeSpeaker   age   shoeSize      score1           yes     5   24.83189   32.293852           yes     6   25.95238   36.631053            no    11   30.42170   49.605934           yes     7   28.66450   40.284565           yes    11   31.88207   55.460856           yes    10   30.07843   52.83124Loading required package: methodsLoading required package: grid..............................................................</code></pre><h2 id="例-23"><a href="#例-23" class="headerlink" title="例"></a>例</h2><p>我们将使用<strong>ctree()</strong>函数创建决策树并查看其图形。</p><pre><code># Load the party package. It will automatically load other dependent packages.library(party)# Create the input data frame.input.dat &lt;- readingSkills[c(1:105),]# Give the chart file a name.png(file = "decision_tree.png")# Create the tree.  output.tree &lt;- ctree(  nativeSpeaker ~ age + shoeSize + score,   data = input.dat)# Plot the tree.plot(output.tree)# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>null device           1 Loading required package: methodsLoading required package: gridLoading required package: mvtnormLoading required package: modeltoolsLoading required package: stats4Loading required package: strucchangeLoading required package: zooAttaching package: ‘zoo’The following objects are masked from ‘package:base’:    as.Date, as.Date.numericLoading required package: sandwich</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-7bb24598b2a6db61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="决策树，使用R"></p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>从上面显示的决策树，我们可以得出结论，其readingSkills分数低于38.3和年龄超过6的人不是一个母语者。</p><h1 id="12-随机森林算法"><a href="#12-随机森林算法" class="headerlink" title="12.随机森林算法"></a>12.随机森林算法</h1><p>在随机森林方法中，创建大量的决策树。每个观察被馈入每个决策树。每个观察的最常见的结果被用作最终输出。新的观察结果被馈入所有的树并且对 - 个分类模型取多数投票。</p><p>对构建树时未使用的情况进行错误估计。这称为OOB（袋外）误差估计，其被提及为百分比。</p><p>[R语言包“随机森林”用于创建随机森林。</p><p>安装 - [R包<br>在R语言控制台中使用以下命令安装软件包。您还必须安装相关软件包（如果有）。</p><pre><code>install.packages("randomForest)</code></pre><p>包“随机森林”具有函数随机森林（），用于创建和分析随机森林。</p><h3 id="语法-22"><a href="#语法-22" class="headerlink" title="语法"></a>语法</h3><p>在R语言中创建随机森林的基本语法是 -</p><pre><code>randomForest(formula, data)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p>式是描述预测变量和响应变量的公式。</p></li><li><p>数据是所使用的数据集的名称。</p></li></ul><h3 id="输入数据-6"><a href="#输入数据-6" class="headerlink" title="输入数据"></a>输入数据</h3><p>我们将使用名为readingSkills的R语言内置数据集来创建决策树。它描述了某人的阅读技能的分数，如果我们知道变量“age”，“shoesize”，“score”，以及该人是否是母语。</p><p>以下是示例数据。</p><pre><code># Load the party package. It will automatically load other required packages.library(party)# Print some records from data set readingSkills.print(head(readingSkills))</code></pre><p>当我们执行上面的代码，它产生以下结果及图表 -</p><pre><code>  nativeSpeaker   age   shoeSize      score1           yes     5   24.83189   32.293852           yes     6   25.95238   36.631053            no    11   30.42170   49.605934           yes     7   28.66450   40.284565           yes    11   31.88207   55.460856           yes    10   30.07843   52.83124Loading required package: methodsLoading required package: grid..............................................................</code></pre><h3 id="例-24"><a href="#例-24" class="headerlink" title="例"></a>例</h3><p>我们将使用随机森林（）函数来创建决策树并查看它的图。</p><pre><code># Load the party package. It will automatically load other required packages.library(party)library(randomForest)# Create the forest.output.forest &lt;- randomForest(nativeSpeaker ~ age + shoeSize + score,            data = readingSkills)# View the forest results.print(output.forest) # Importance of each predictor.print(importance(fit,type = 2)) </code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>Call: randomForest(formula = nativeSpeaker ~ age + shoeSize + score,                      data = readingSkills)               Type of random forest: classification                     Number of trees: 500No. of variables tried at each split: 1        OOB estimate of  error rate: 1%Confusion matrix:    no yes class.errorno  99   1        0.01yes  1  99        0.01         MeanDecreaseGiniage              13.95406shoeSize         18.91006score            56.73051</code></pre><h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>从上面显示的随机森林，我们可以得出结论，鞋码和成绩是决定如果某人是母语者或不是母语的重要因素。此外，该模型只有1％的误差，这意味着我们可以预测精度为99％。</p><h1 id="13-生存分析"><a href="#13-生存分析" class="headerlink" title="13.生存分析"></a>13.生存分析</h1><p>生存分析处理预测特定事件将要发生的时间。 它也被称为故障时间分析或分析死亡时间。 例如，预测患有癌症的人将存活的天数或预测机械系统将失败的时间。</p><p>命名为<strong>survival</strong>的R语言包用于进行生存分析。 此包包含函数Surv（），它将输入数据作为R语言公式，并在选择的变量中创建一个生存对象用于分析。 然后我们使用函数<strong>survfit()</strong>创建一个分析图。</p><h2 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h2><pre><code>install.packages("survival")</code></pre><h3 id="语法-23"><a href="#语法-23" class="headerlink" title="语法"></a>语法</h3><p>在R语言中创建生存分析的基本语法是 -</p><pre><code>Surv(time,event)survfit(formula)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li><p><strong>time</strong>是直到事件发生的跟踪时间。</p></li><li><p><strong>event</strong>指示预期事件的发生的状态。</p></li><li><p><strong>formula</strong>是预测变量之间的关系。</p></li></ul><h3 id="例-25"><a href="#例-25" class="headerlink" title="例"></a>例</h3><p>我们将考虑在上面安装的生存包中存在的名为“pbc”的数据集。 它描述了关于受肝原发性胆汁性肝硬化（PBC）影响的人的生存数据点。 在数据集中存在的许多列中，我们主要关注字段“time”和“status”。 时间表示在接受肝移植或患者死亡的患者的登记和事件的较早之间的天数。</p><pre><code># Load the library.library("survival")# Print first few rows.print(head(pbc))</code></pre><p>当我们执行上面的代码，它产生以下结果及图表 -</p><pre><code>  id time status trt      age sex ascites hepato spiders edema bili chol1  1  400      2   1 58.76523   f       1      1       1   1.0 14.5  2612  2 4500      0   1 56.44627   f       0      1       1   0.0  1.1  3023  3 1012      2   1 70.07255   m       0      0       0   0.5  1.4  1764  4 1925      2   1 54.74059   f       0      1       1   0.5  1.8  2445  5 1504      1   2 38.10541   f       0      1       1   0.0  3.4  2796  6 2503      2   2 66.25873   f       0      1       0   0.0  0.8  248  albumin copper alk.phos    ast trig platelet protime stage1    2.60    156   1718.0 137.95  172      190    12.2     42    4.14     54   7394.8 113.52   88      221    10.6     33    3.48    210    516.0  96.10   55      151    12.0     44    2.54     64   6121.8  60.63   92      183    10.3     45    3.53    143    671.0 113.15   72      136    10.9     36    3.98     50    944.0  93.00   63       NA    11.0     3</code></pre><p>从上述数据，我们正在考虑分析的时间和状态。</p><h3 id="应用Surv（）和survfit（）函数"><a href="#应用Surv（）和survfit（）函数" class="headerlink" title="应用Surv（）和survfit（）函数"></a>应用Surv（）和survfit（）函数</h3><p>现在我们继续应用<strong>Surv()</strong>函数到上面的数据集，并创建一个将显示趋势图。</p><pre><code># Load the library.library("survival")# Create the survival object. survfit(Surv(pbc$time,pbc$status == 2)~1)# Give the chart file a name.png(file = "survival.png")# Plot the graph. plot(survfit(Surv(pbc$time,pbc$status == 2)~1))# Save the file.dev.off()</code></pre><p>当我们执行上面的代码，它产生以下结果及图表 -</p><pre><code>Call: survfit(formula = Surv(pbc$time, pbc$status == 2) ~ 1)      n  events  median 0.95LCL 0.95UCL     418     161    3395    3090    3853 </code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-302e42c422d00625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="，使用R生存分析"></p><p>上图中的趋势有助于我们预测在特定天数结束时的生存概率。</p><h1 id="14-卡方检验"><a href="#14-卡方检验" class="headerlink" title="14.卡方检验"></a>14.卡方检验</h1><p>卡方检验是一种确定两个分类变量之间是否存在显着相关性的统计方法。这两个变量应该来自相同的人口，他们应该是类似 - 是/否，男/女，红/绿等。</p><p>例如，我们可以建立一个观察人们的冰淇淋购买模式的数据集，并尝试将一个人的性别与他们喜欢的冰淇淋的味道相关联。如果发现相关性，我们可以通过了解访问的人的性别的数量来计划适当的味道库存。</p><h3 id="语法-24"><a href="#语法-24" class="headerlink" title="语法"></a>语法</h3><p>用于执行卡方检验的函数是chisq.test（）。<br>在R语言中创建卡方检验的基本语法是 -</p><pre><code>chisq.test(data)</code></pre><p>以下是所使用的参数的描述 - </p><ul><li>数据是以包含观察中变量的计数值的表的形式的数据。</li></ul><h3 id="例-26"><a href="#例-26" class="headerlink" title="例"></a>例</h3><p>我们将在“大众”图书馆中获取Cars93数据，该图书馆代表1993年年不同型号汽车的销售额。</p><pre><code>library("MASS")print(str(Cars93))</code></pre><p>当我们执行上面的代码，它产生以下结果 -</p><pre><code>'data.frame':   93 obs. of  27 variables:  $ Manufacturer      : Factor w/ 32 levels "Acura","Audi",..: 1 1 2 2 3 4 4 4 4 5 ...  $ Model             : Factor w/ 93 levels "100","190E","240",..: 49 56 9 1 6 24 54 74 73 35 ...  $ Type              : Factor w/ 6 levels "Compact","Large",..: 4 3 1 3 3 3 2 2 3 2 ...  $ Min.Price         : num  12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ...  $ Price             : num  15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ...  $ Max.Price         : num  18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ...  $ MPG.city          : int  25 18 20 19 22 22 19 16 19 16 ...  $ MPG.highway       : int  31 25 26 26 30 31 28 25 27 25 ...  $ AirBags           : Factor w/ 3 levels "Driver &amp; Passenger",..: 3 1 2 1 2 2 2 2 2 2 ...  $ DriveTrain        : Factor w/ 3 levels "4WD","Front",..: 2 2 2 2 3 2 2 3 2 2 ...  $ Cylinders         : Factor w/ 6 levels "3","4","5","6",..: 2 4 4 4 2 2 4 4 4 5 ...  $ EngineSize        : num  1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ...  $ Horsepower        : int  140 200 172 172 208 110 170 180 170 200 ...  $ RPM               : int  6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ...  $ Rev.per.mile      : int  2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ...  $ Man.trans.avail   : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 1 1 1 1 1 ...  $ Fuel.tank.capacity: num  13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ...  $ Passengers        : int  5 5 5 6 4 6 6 6 5 6 ...  $ Length            : int  177 195 180 193 186 189 200 216 198 206 ...  $ Wheelbase         : int  102 115 102 106 109 105 111 116 108 114 ...  $ Width             : int  68 71 67 70 69 69 74 78 73 73 ...  $ Turn.circle       : int  37 38 37 37 39 41 42 45 41 43 ...  $ Rear.seat.room    : num  26.5 30 28 31 27 28 30.5 30.5 26.5 35 ...  $ Luggage.room      : int  11 15 14 17 13 16 17 21 14 18 ...  $ Weight            : int  2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ...  $ Origin            : Factor w/ 2 levels "USA","non-USA": 2 2 2 2 2 1 1 1 1 1 ...  $ Make              : Factor w/ 93 levels "Acura Integra",..: 1 2 4 3 5 6 7 9 8 10 ... </code></pre><p>上述结果表明数据集有很多因素变量，可以被认为是分类变量。对于我们的模型，我们将考虑变量“AirBags”和“Type”。在这里，我们的目标是找出所售的汽车类型和安全如果观察到相关性，我们可以估计哪种类型的汽车可以更好地卖什么类型的气囊。</p><pre><code># Load the library.library("MASS")# Create a data frame from the main data set.car.data &lt;- data.frame(Cars93$AirBags, Cars93$Type)# Create a table with the needed variables.car.data = table(Cars93$AirBags, Cars93$Type) print(car.data)# Perform the Chi-Square test.print(chisq.test(car.data))当我们执行上面的代码，它产生以下结果 -                     Compact Large Midsize Small Sporty Van  Driver &amp; Passenger       2     4       7     0      3   0  Driver only              9     7      11     5      8   3  None                     5     0       4    16      3   6        Pearson's Chi-squared testdata:  car.dataX-squared = 33.001, df = 10, p-value = 0.0002723Warning message:In chisq.test(car.data) : Chi-squared approximation may be incorrect</code></pre><h3 id="结论-3"><a href="#结论-3" class="headerlink" title="结论"></a>结论</h3><p>结果显示p值小于0.05，这表明字符串相关。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL Server：数据库基础</title>
      <link href="/posts/blog-model02.html"/>
      <url>/posts/blog-model02.html</url>
      
        <content type="html"><![CDATA[<h3 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h3><h5 id="1-1-数据、信息与数据处理"><a href="#1-1-数据、信息与数据处理" class="headerlink" title="1.1 数据、信息与数据处理"></a>1.1 数据、信息与数据处理</h5><p><strong>(1) 数据(Data)</strong>：是数据库中存储的基本对象；</p><ul><li>定义：描述事物的符号记录，是信息的符号表示，或称载体；</li><li>种类：数字、文本、图形、图像、声音、视频，学生的档案记录(40951001, 王二小，男，1988，内蒙，tx1201)等。</li></ul><p><strong>(2) 信息</strong>：数据的内涵，是数据的语义解释。</p><p><strong>(3)数据处理</strong>：将数据转换成信息的过程;<strong>数据管理</strong>： 是数据处理的核心。</p><h6 id="1-2-数据管理技术的产生与发展"><a href="#1-2-数据管理技术的产生与发展" class="headerlink" title="1.2  数据管理技术的产生与发展"></a>1.2  数据管理技术的产生与发展</h6><ol><li>人工管理阶段（20世纪50年代中期前）</li></ol><ul><li>数据不保存</li><li>应用程序管理数据</li><li>数据不具有独立性和共享性</li></ul><ol start="2"><li>文件系统阶段（20世纪50年代后期到60年代中期）</li></ol><ul><li>数据以文件形式可以长期保存在外存储设备上</li><li>由文件系统管理数据（ “按名访问，按记录存取 ” ）</li><li>数据共享性差，冗余度大（ 面向应用 ）</li><li>数据独立性差</li></ul><ol start="3"><li>数据库系统阶段（20世纪60年代后期至今）</li></ol><ul><li>数据结构化, 并与程序分离</li><li>数据的共享性高，冗余度低，易扩充（集中存储）</li><li>数据独立性高</li><li>数据由数据库管理系统统一控制<h6 id="数据库系统阶段——数据独立性高"><a href="#数据库系统阶段——数据独立性高" class="headerlink" title="数据库系统阶段——数据独立性高"></a><strong>数据库系统阶段——数据独立性高</strong></h6><ul><li>物理独立性<br>用户的应用程序与数据库中数据相互独立。当数据的存储格式和组织方法改变时，不影响数据库的逻辑结构，从而不影响应用程序。</li></ul></li><li>逻辑独立性<br>指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序不用改变。</li><li>数据独立性由DBMS的二级映像功能来保证。<h6 id="数据库系统阶段——DBMS提供数据控制功能"><a href="#数据库系统阶段——DBMS提供数据控制功能" class="headerlink" title="数据库系统阶段——DBMS提供数据控制功能"></a>数据库系统阶段——DBMS提供数据控制功能</h6>(1) 数据的安全性（ （Security） ） 控制<br>保护数据 ， 以防止不合法的使用造成的数据的泄密和破坏 。<br>(2) 数据的完整性（ （Integrity） ） 控制<br>将数据控制在有效范围内 ， 或保证数据间满足一定的关系 。<br>(3) 并发（ （Concurrency） ） 控制<br>对多用户的并发操作加以控制和协调 ， 防止相互干扰 。<br>(4) 数据恢复（ （Recovery） ）<br>将数据库从错误状态恢复到某一已知的正确状态 。<h6 id="数据库系统的发展"><a href="#数据库系统的发展" class="headerlink" title="数据库系统的发展"></a>数据库系统的发展</h6></li><li>初级阶段——第一代数据库<br>出现了层次模型、网状模型的数据库</li><li>中级阶段——第二代数据库<br>关系型数据库和结构化查询语言</li><li>高级阶段——新一代数据库<br>“面向对象”型数据库<h5 id="1-3-数据库系统的组成"><a href="#1-3-数据库系统的组成" class="headerlink" title="1.3 数据库系统的组成"></a>1.3 数据库系统的组成</h5>数据库系统（Database System，DBS）包括以下5部分:</li><li>数据库</li><li>数据库管理系统</li><li>硬件系统</li><li>软件系统</li><li>人员(管理员、分析员、设计员、程序员和用户)<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-fe9f7b337ec796e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><ol><li><strong>数据库</strong>(Database,简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。<br><strong>数据库的基本特征</strong></li></ol><ul><li>数据按一定的数据模型组织、描述和储存</li><li>可为各种用户共享</li><li>冗余度较小</li><li>数据独立性较高</li><li>易扩展</li></ul><ol start="2"><li><strong>数据库管理系统</strong>（Database ManagementSystem ，简称DBMS）</li></ol><ul><li>管理数据库的系统软件 ，是 数据库系统的<strong>核心</strong> 。</li><li>位于用户与操作系统之间的一层数据管理软件。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-399946837f6ca08e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p><strong>DBMS的主要功能</strong></p><ul><li>数据定义功能（DDL） </li><li>数据操纵功能（DML） </li><li>数据库的事务管理和运行管理</li><li>数据库的建立和维护功能</li><li>数据通信</li></ul><ol start="3"><li><strong>硬件系统</strong><br>硬件系统要有足够的内存用来存放操作系统、DBMS的核心模块、数据缓存、应用程序及数据备份等。</li><li><strong>软件系统</strong><br>包括DBMS、支持DBMS运行的操作系统和具有数据访问接口的高级语言及其编程环境。<h5 id="1-4数据模型"><a href="#1-4数据模型" class="headerlink" title="1.4数据模型"></a>1.4数据模型</h5><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-47b70c171a5ba1bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><p><strong>根据应用目的，模型分为两个层次：</strong></p><ol><li>概念模型( 信息模型)</li></ol><ul><li>按用户的观点 ，独立于计算机实现的，只用来描述和组织 所关心的信息 结构的概念数据模型， 强调语义</li><li>数据库设计人员和用户之间进行交流的语言</li><li>对应于信息世界</li></ul><ol start="2"><li>数据模型</li></ol><ul><li>按计算机系统的观点，直接面向计算机系统的，描述数据库中数据的逻辑结构的基本数据模型</li><li>对应于数据世界（机器世界）</li><li>包括<strong>逻辑模型</strong>和<strong>物理模型</strong><h6 id="概念模型（信息世界中）的基本概念"><a href="#概念模型（信息世界中）的基本概念" class="headerlink" title="概念模型（信息世界中）的基本概念"></a>概念模型（信息世界中）的基本概念</h6></li><li>实体Entity ：客观存在并相互区别的事物。具体的人、事、物，抽象的概念（订货）</li><li>属性Attribute ：实体或联系的特征。学生（学号，姓名，性别）</li><li>码，键Key ：唯一标识实体的属性或属性组</li><li>域Domain ：属性的取值范围。性别（男，女）</li><li>实体型Entity Type ：实体名＋属性名集合</li><li>实体集Entity Set ：同型实体的集合</li><li>联系Relationship: 实体与实体之间的联系<h6 id="实体间的联系"><a href="#实体间的联系" class="headerlink" title="实体间的联系"></a>实体间的联系</h6>实体之间的对应关系称为联系，它反映了现实世界事物之间的相互关联。<br>联系的类型：</li><li>一对一联系  记为1  ：1。</li><li>一对多联系  记为 １：n。</li><li>多对多联系  记为m  ：n。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-3bdcdf53d623fc1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="概念模型的表示方法"><a href="#概念模型的表示方法" class="headerlink" title="概念模型的表示方法"></a>概念模型的表示方法</h6>E-R图：提供了表示实体、属性和实体间联系的方法<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6a97096c79a17a91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="建立E-R图的步骤"><a href="#建立E-R图的步骤" class="headerlink" title="建立E-R图的步骤"></a>建立E-R图的步骤</h6></li></ul><ol><li>确定实体和实体的属性</li><li>确定实体和实体之间的联系及联系的类型</li><li>给联系和实体加上属性。<h6 id="E-R模型实例"><a href="#E-R模型实例" class="headerlink" title="E-R模型实例"></a>E-R模型实例</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-9514470fa22b9388.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><h6 id="数据模型定义"><a href="#数据模型定义" class="headerlink" title="数据模型定义"></a>数据模型定义</h6><ul><li>数据模型是表示实体类型和实体间联系的模型，是机器世界对现实世界中的数据和信息 抽象、表示和处理 。</li><li>包括逻辑模型和物理模型。<h6 id="数据模型的组成要素-三要素"><a href="#数据模型的组成要素-三要素" class="headerlink" title="数据模型的组成要素(三要素)"></a>数据模型的组成要素(三要素)</h6>数据结构、 数据操作和 数据完整性约束<h6 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h6></li></ul><ol><li>数据结构的概念</li></ol><ul><li>实体及实体间联系的 表示方法，描述了系统的 静态特性.</li></ul><ol start="2"><li>数据结构描述的内容</li></ol><ul><li>对象的数据类型、内容、性质有关的对象；</li><li>与数据之间联系有关的对象；<h6 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h6><ol><li>概念</li></ol></li><li>对数据库中各种对象(型)的实例(值)允许执行的操作及有关的操作规则，是对系统 动态特性的描述。</li></ul><ol start="2"><li>数据操作的类型（2大类）</li></ol><ul><li>数据检索（查询）</li><li>数据更新(包括插入、删除、修改)<h6 id="数据完整性约束"><a href="#数据完整性约束" class="headerlink" title="数据完整性约束"></a>数据完整性约束</h6></li></ul><ol><li>概念：完整性规则是给定的数据模型中数据及其联系所具有的 制约和依存规则。</li><li>作用：限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。</li><li>四种类型：实体完整性约束、域完整性约束、参照完整性约束和用户自定义完整性约束。<h6 id="最常用的数据模型"><a href="#最常用的数据模型" class="headerlink" title="最常用的数据模型"></a>最常用的数据模型</h6>非关系模型</li></ol><ul><li><p>层次模型(Hierarchical Model)<br>层次模型是数据库系统中最早出现的数据模型;<br>层次数据库系统的典型代表是IBM 公司1968年 年推出的IMS(Information Management System);<br>层次模型用 树形结构(“ 有向树”) 来表示各类实体以及实体间的联系.<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-05ff0f08c6ff3309.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>网状模型(Network Model)<br>典型代表是DBTG;<br>通过 有向图结构 表示实体及联系。“网”中每个结点表示一个实体( 型) ，结点之间箭头表示实体( 型);<br>网状数据模型可能有多个根结点，某些非根结点可能有多个父结点，适合表示实体的多对多联系。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cc1bd2bdbff23958.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>关系模型(Relational Model)</p></li><li><p>1970年美国IBM公司San Jose研究室的研究员E.F.Codd首次提出了数据库系统的关系模型</p></li><li><p>关系数据结构：规范化的<strong>二维表</strong>（关系）<br>一个关系就是没有重复行和重复列的二维表，二维表的每一行在关系中称为元组，每一列在关系中称为属性。学生关系的每一行代表一个学生的记录，每一列代表学生记录的一个字段。属性个数（n）称为关系的元。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-399f462d3ee8d12a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h6 id="三种模型比较"><a href="#三种模型比较" class="headerlink" title="三种模型比较"></a>三种模型比较</h6><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-bd7aa6765cb17898.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="1-5数据库系统结构"><a href="#1-5数据库系统结构" class="headerlink" title="1.5数据库系统结构"></a>1.5数据库系统结构</h5></li><li><p>数据库系统内部的体系结构<br>从数据库管理系统角度看，数据库系统通常采用三级模式结构，是数据库系统内部的系统结构。</p></li><li><p>数据库系统外部的体系结构<br>从数据库最终用户角度看，数据库系统的结构分为:集中式结构；客户/服务器结构；浏览器／应用服务器／数据库服务器多层结构等。</p></li><li><p>为了有效地组织、管理数据，提高数据库的逻辑独立性和物理独立性，数据库设计的标准体系结构是3 级模式结构，即<strong>外模式</strong> ,<strong>模式</strong>和<strong>内模式</strong> </p></li><li><p>对应于体系结构，用户或程序员看到或使用的数据库内容被称为视图，可把视图相应分为：</p></li></ul><ol><li>对应于用户的外部视图（ 用户视图）</li><li>对应于应用程序员的 (概念视图)</li><li>对应于系统程序员的内部视图（ 存储视图）<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-ef6509f0c60dc3ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><ul><li>模式（Schema，也称逻辑模式，概念视图）</li></ul><p>– 数据库中 全体数据的逻辑结构和特征 的描述。<br>– 一个数据库只有一个模式<br>– 模式的地位：是数据库系统模式结构的中间层</p><ul><li>外模式（External Schema）</li></ul><p>– 也称 子模式或用户模式；<br>–  数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。<br>– 外模式的地位：介于模式与应用之间<br>–  外模式通常是模式的子集<br>– 一个数据库可以有多个外模式。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求</p><ul><li>内模式（Internal Schema）</li></ul><p>–  是 数据物理结构 和 存储方式<br>– 是数据在数据库内部的表示方式<br><strong>3级模式是对数据的三个抽象级别</strong><br> 2级映象在DBMS 内部实现这三个抽象层次的联系和转换 ；</p><ul><li>外模式\ 模式映像<br>– 保证数据的<strong>逻辑独立性</strong><br>– 同一个模式可以有任意多个外模式，外模式／模式映象定义外模式与模式之间的对应关系；<br>– 当模式改变时，外模式／模式映象使外模式保持不变；<br>– 应用程序是依据数据的外模式编写的，从而不必修改应用程序，保证了数据与程序的逻辑独立性<ul><li>模式\内模式映像</li></ul>– 保证数据的<strong>物理独立性</strong>。<br>– 模式／内模式映象定义了数据 全局逻辑结构与 存储结构之间的对应关系。<br>– 当数据库的存储结构改变了，模式／内模式映象使模式保持不变。<br>– 应用程序不受影响。保证了数据与程序的物理独立性。</li></ul><p>从数据库最终用户角度看（数据库系统外部的体系结构） ，数据库系统的结构分为:</p><ul><li>集中式数据库系统</li><li>客户/服务器（C/S）系统结构</li><li>分布式数据库系统结构</li><li>浏览器／服务器（B/S）系统结构</li></ul><h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3><h5 id="2-1关系数据模型的基本概念"><a href="#2-1关系数据模型的基本概念" class="headerlink" title="2.1关系数据模型的基本概念"></a>2.1关系数据模型的基本概念</h5><p>关系模型的组成（三要素）</p><ul><li>关系数据结构（静态特性）<br>现实世界的实体以及实体间的各种联系均用关系来表示;<br>数据的逻辑结构—-二维表</li><li>关系操作集合（动态特性）<br>插入、删除、修改、查询（选择、投影、连接、除、并、交、差）</li><li>关系完整性约束<br>实体完整性、参照完整性、域完整性、用户定义完整性</li></ul><p>1） 关系: 通常将一个无重复行、重复列的二维表看成一个关系，每个关系都有一个关系名。<br> 2） 元组: 二维表的每一行在关系中称为元组。描述了现实世界中的一个实体或不同实体间的一种联系。<br> 3） 属性: 二维表的每一列在关系中称为属性，每个属性都有一个属性名，各个属性的取值称为属性值。每个属性有一定的取值范围，称为值域。<br> 4）域 （Domain): 关系中每个属性所对应的变化范围叫做属性的变域或简称域，关系中所有属性的实际取值必须来自它对应的域。<br> 5）分量: 一个元组在一个属性域上的取值称为该元组在此属性上的分量。<br>6）关系模式: 二维表的表头那一行称为关系模式，即一个关系的关系名及其全部属性名的集合。关系模式是概念模型中实体型及实体型之间联系的数据模型表示。 一般表示为：<br>关系名（属性名1，属性名2 ， ……，属性名n）<br> 关系模式指出了一个关系的结构；而关系则是由满足关系模式结构的元组构成的集合。关系模式是稳定的、静态的，而关系则是随时间变化的、动态的。<br> 7） 候选码（Candidate key）: 若关系中的某一属性或属性组合的值能唯一地标识一个元组，则称该属性组为候选码<br> 在最简单的情况下，候选码只包含一个属性。<br> 在最极端的情况下，关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）<br>8） 主码: 若一个关系有多个候选码，则选定其中一个为主<br>码（Primary key）<br> 9）主属性和非主属性<br>– 主码的各个属性称为主属性（Prime attribute）。<br>– 不包含在任何候选码中的属性称为非主属性Non-key attribute）<br>10）外码: 如果关系中某个属性或属性组合并非码，但却是另一个关系的主码，则称此属性或属性组合为本关系的外码或外键(ForeignKey)。在关系数据库中，用外码表示两个表间的联系。</p><h5 id="2-2关系数据模型的集合论定义"><a href="#2-2关系数据模型的集合论定义" class="headerlink" title="2.2关系数据模型的集合论定义"></a>2.2关系数据模型的集合论定义</h5><h6 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h6><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-35b3920ae7c425db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>笛卡尔积可表示为一个二维表。表中的每行对应一个元组，表中的每列对应一个域。</li><li>基数（Cardinal number）<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-e72b5c4eb4172ed2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h6></li><li>笛卡尔积中的任意子集叫作在域 上的n元 关系，简称关系。</li><li>n元关系就会有n个属性。一个关系中的每一个属性的属性名都不同，对应参与笛卡儿积运算的每个集合的名称。</li><li>一个属性的取值范围Di 称为该属性的域（Domain）。<h6 id="基本关系的性质"><a href="#基本关系的性质" class="headerlink" title="基本关系的性质"></a>基本关系的性质</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-debda60472f76fbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-45ee559f7f0dda04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h5 id="2-3-关系模型的完整性约束"><a href="#2-3-关系模型的完整性约束" class="headerlink" title="2.3 关系模型的完整性约束"></a>2.3 关系模型的完整性约束</h5>数据库系统提供的监测机制，确保存储数据的规范，称为完整性约束。<ul><li>实体完整性<br>实体完整性通过定义 主码 来实现的。若属性A A 是关系R R 的主属性，则A A 不能取空值且取值唯一 ；<br>一个关系模型中的所有 元组都是惟一 的，没有两个完全相同的元组，也就是一个二维表中没有两个完全相同行，也称为<strong>行完整性</strong>。</li></ul></li><li>域完整性<br>对关系R R 中属性（列）数据的规范，也称<strong>列完整性</strong>，限制属性的 数据类型、格式、取值范围、是否允许空值 等。</li><li>参照完整性<br>参照完整性是通过定义 外 键 FK （ 存在或为空） 来建立实体间联系的。<br>如外键取空，则 FK 中的每个属性的分量都是空值。</li><li>用户定义完整性<br>针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。<h5 id="2-4关系代数"><a href="#2-4关系代数" class="headerlink" title="2.4关系代数"></a>2.4关系代数</h5><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-ea7ed5cbbc5c6656.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="笛卡尔积-1"><a href="#笛卡尔积-1" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-5357bd667e805062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="选择（限制）"><a href="#选择（限制）" class="headerlink" title="选择（限制）"></a>选择（限制）</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f2be1caa785865c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="投影（Projection）"><a href="#投影（Projection）" class="headerlink" title="投影（Projection）"></a>投影（Projection）</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-101949584da22ebc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="连接（Join-）"><a href="#连接（Join-）" class="headerlink" title="连接（Join ）"></a>连接（Join ）</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-35e9d9de19d368dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7d1d6e58891ec025.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-01b05c7400e325d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><h6 id="除（Division-）"><a href="#除（Division-）" class="headerlink" title="除（Division ）"></a>除（Division ）</h6><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-be0e4bcd638b5800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><h3 id="SQL-Server-2008-数据库基础"><a href="#SQL-Server-2008-数据库基础" class="headerlink" title="SQL Server 2008 数据库基础"></a>SQL Server 2008 数据库基础</h3><h5 id="SQL-Server-简介"><a href="#SQL-Server-简介" class="headerlink" title="SQL Server  简介"></a>SQL Server  简介</h5><ul><li>常见数据库产品包括甲骨文公司的Oracle系统，IBM 公司的DB2 系统和Informix 系统，赛贝斯公司的Sybase ASE 系统，微软公司的Microsoft SQL Server 系统和Access 系统，以及MySQL</li><li>2008 年8 月，微软发布Microsoft SQL Server 2008 系统，其代码是Katmai 。该系统在 安全性、可用性、易管理性、可扩展性、商业智能 等方面有了更多的改进和提高，支持 更强大 的数据存储和应用需求。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-60fd472b70d4ded7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-8164b6115ac57a00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-677d8c29fac82083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="SQL-Server-2008登录"><a href="#SQL-Server-2008登录" class="headerlink" title="SQL Server 2008登录"></a>SQL Server 2008登录</h5><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-fa20d7cd219167ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="SQL-Server-Management-Studio-简介"><a href="#SQL-Server-Management-Studio-简介" class="headerlink" title="SQL Server Management Studio 简介"></a>SQL Server Management Studio 简介</h5><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-5d81798645335bce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-a610b30296329114.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6f9ecf6f88f08272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="SQL-Server-2008-数据库的创建与维护"><a href="#SQL-Server-2008-数据库的创建与维护" class="headerlink" title="SQL Server 2008 数据库的创建与维护"></a>SQL Server 2008 数据库的创建与维护</h5><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-5883c454c6f7a6ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-e6d897155dd42e76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>SQL Server 2008 数据存储结构<br>（1 ）数据库文件<ul><li>主数据文件.mdf</li><li>次要数据文件  .ndf</li><li>日志文件 .ldf</li><li>数据文件结构组成</li><li>页<br>_ SQL Server最小存储数据单位<br>_ 一个页大小是8K</li><li>区<br>_ 管理空间的基本单位<br>_ 8个物理上连续的页（64 KB）<br>_ 表被存储在区</li></ul></li></ul><p>（2)数据库文件组</p><p>   (3)数据库创建<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-1dda20b927c861fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-91fe4f34a3024f2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-0e525d5bef964169.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（4）数据库修改<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-ed3ad2d39c3ee70d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>（5）数据库删除<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-20761a3678583d98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="Transact-SQL-程序设计基础"><a href="#Transact-SQL-程序设计基础" class="headerlink" title="Transact-SQL 程序设计基础"></a>Transact-SQL 程序设计基础</h5><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-80514da0fd443c28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f670b1769ebef9fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p> （1 ）标识符分类<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-bf864b95cce9e8fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>（2）数据类型<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-12e48ff37e968ca5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>（3）全局变量<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-33ccaabeb7cc1d4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>（4）运算符<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-64ced3ebc711c21e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>（5）批处理<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-d7a6907c4f80d3ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>（6）函数<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f0c631e6054b93ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-499317578ee5382d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-15bf357ae64f9596.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-27ddaea8d1404fa7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-c831b45529b4d02e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-c62055abc13acd9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-092b47701f26afdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>（7）流程控制<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cb8591968e265754.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="关系数据库标准语言SQL"><a href="#关系数据库标准语言SQL" class="headerlink" title="关系数据库标准语言SQL"></a>关系数据库标准语言SQL</h3><h5 id="SQL-的三级模式结构"><a href="#SQL-的三级模式结构" class="headerlink" title="SQL 的三级模式结构"></a>SQL 的三级模式结构</h5><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-adf8c173d8cb82a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h5 id="SQL-的数据定义"><a href="#SQL-的数据定义" class="headerlink" title="SQL 的数据定义"></a>SQL 的数据定义</h5><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-78f2cfea179fdc0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-eafd189c9bcc48cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-b8c403c084b124ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>基本表定义<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-a427874f6b8bf74c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>基本表的修改与删除<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cf6f5f472950c7ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-87b5c1382852441a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>索引的建立和删除<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-485dfefc9bc92188.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-4b090d4cd4c308a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-66084115e6f0e91c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-e68483f5777f3b90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-d85e38c2be78d419.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>查询语句</li></ul><p>查询的基本结构包括了三个子句： SELECT、 FROM 、 WHERE。</p><p> 从表中（From子句）,选择满足记录选择条件（Where子句）的记录，并对他们进行分组（Group子句, Having子句表达组选择条件）、统计(统计函数）、排序（Order by 子句）和投影（Select子句） ，形成查询结果集。</p><ol><li>单表无条件查询<br>DISTINCT 保留字的使用：可以使查询的结果中重复列值只保留一个。<br>查询列中含有运算的表达式。<br>查询列中含有字符串常量。<br>查询列中含有聚合函数。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-4269cf6900924f85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>单表有条件查询<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-de218e073d682650.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6e1d17b7fd1686d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-ef18dc9879307b63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-9246eb55e2ff1fbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-aa5687129ee936e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f251334d0273ca72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol start="3"><li>分组查询和排序查询<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-9d684cdddb748dec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f47f13e912d00a61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7ad8d00c7760ed96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol start="4"><li>多表查询</li></ol><ul><li>SQL通过连接查询、笛卡尔积、并操作、交操作、差操作5种关系代数中的运算功能来实现多个数据表的查询。SQL通过连接查询、笛卡尔积、并操作、交操作、差操作5种关系代数中的运算功能来实现多个数据表的查询。</li><li>SQL  提供在子句中列出每个关系 然后在SELECT子句和WHERE子句中引用FROM子句中的关系属性，而WHERE子句中用来连接两个关系的条件。在SELECT子句和WHERE子句中引用FROM子句中的关系属性，而WHERE子句中用来连接两个关系的条件。</li><li>连接查询包括等值连接、非等值连接、自身连接、内连接和外连接等值连接、非等值连接、自身连接、内连接和外连接等。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-613643b8abd2eac2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-0b49b0c1e63fad45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-2210533ddf510600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-17cf467c7e2ffe2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-c2ab3b2e10701077.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>5. 嵌套查询<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7f3ff4167da21bf5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>SQL 的数据操纵</li></ul><ol><li>插入数据<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-e13879ce99f31716.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>修改数据<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-b2bf14419f69c096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>删除数据<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-8c604762cc491273.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-ac07719ed45b7981.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><ul><li>视图<ul><li>视图是 外模式的基本单位，实际上视图是从若干个基本表或视图导出来的虚表。</li><li>当基本表的数据发生变化时，相应的视图数据也会随之改变。</li><li>视图定义后，可以被用户查询、更新，但通过视图来更新基本表中的数据要有一定的限制。</li></ul></li></ul><ol><li>定义视图<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-39ab5bc2a15ff835.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-9b81c14c878915b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>2. 删除视图<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-05fd835292b32c8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>3. 查询视图<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-09aaebc6645eb617.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>4. 更新视图<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7f9b79f85735e4b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol start="5"><li>视图的作用<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-50bd3300fa23944e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><ul><li>存储过程<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-716ab4c40c76b8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-84f68facfdc8522a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><ol><li>创建执行<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-9be1ef35f2a34908.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-0d5ec5c3e796e622.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>修改删除<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-09d98763060572d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>查看储存<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-1949b6e387c3af91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><ul><li>触发器<ul><li>触发器是一种特殊的存储过程，在对表或视图执行，触发器是一种特殊的存储过程，在对表或视图执行 UPDATE 、 INSERT 或 DELETE 操作时自动触发执行操作时自动触发执行。<ul><li>触发器技术是保证数据完整性的高级技术，触发器还可以用于对系统的高级监测，用于实施完整性和强制执行业务规则。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-ab4ae5ede4a56a4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-5bf52f7c4445adc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-fadc22d3bcb224ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul></li></ul></li></ul><h2 id="关系数据库规范化理论"><a href="#关系数据库规范化理论" class="headerlink" title="关系数据库规范化理论"></a>关系数据库规范化理论</h2><h4 id="关系模式的形式化定义"><a href="#关系模式的形式化定义" class="headerlink" title="关系模式的形式化定义"></a>关系模式的形式化定义</h4><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-e5f0c7cebec49b56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="函数依赖的基本概念"><a href="#函数依赖的基本概念" class="headerlink" title="函数依赖的基本概念"></a>函数依赖的基本概念</h4><ul><li>函数依赖<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-94b8e0cbe088b538.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-26de88d0f64c48b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f214117ed707487a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-b027c589734a6da5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>码的函数依赖<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-61635ad1e416e1be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ul><h4 id="关系模式的规范化"><a href="#关系模式的规范化" class="headerlink" title="关系模式的规范化"></a>关系模式的规范化</h4><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-b089a70ae3c6ec87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ol><li>第 1 范式 1NF<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-2e2899d8ae270523.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>第 2 范式 2NF<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-a67970f2bd29db0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>第 3 范式 3NF<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cbf667c69059ef8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>BCNF 范式<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-175efc68db852a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li><li>多值依赖与第 4 范式<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6036188b83ab363c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f874267376e88bd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li></ol><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f683d0adf226bdad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-0d3b954ed895f4fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h4><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-fab819be603f3833.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h4><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-8fc150ea215d96f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h4><h4 id="数据库实施"><a href="#数据库实施" class="headerlink" title="数据库实施"></a>数据库实施</h4><h4 id="数据库运行与维护"><a href="#数据库运行与维护" class="headerlink" title="数据库运行与维护"></a>数据库运行与维护</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模算法学习</title>
      <link href="/posts/blog-model01.html"/>
      <url>/posts/blog-model01.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://blog.csdn.net/qwl755/article/details/73558416" target="_blank" rel="noopener">相关模型解决的问题</a><br><a href="https://blog.csdn.net/anxixiaomu/article/details/69075286" target="_blank" rel="noopener">数据分析类算法一览</a><br><a href="https://blog.csdn.net/w_t_y_y/article/details/68952519" target="_blank" rel="noopener">100个经典动态规划方程</a></p></blockquote><h3 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h3><ul><li>线性规划</li></ul><ol><li><strong>简介</strong>：线性规划的目标函数可以是求最大值，也可以是求最小值，约束条件的不等号可以是小于号也可以是大于号。为了避免这种形式多样性带来的不便，Matlab 中规定线性规划的标准形式为<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-9044bd07c3f2399a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性规划"><br>其中 c 和 x 为 n 维列向量， A 、 Aeq 为适当维数的矩阵， b 、 beq 为适当维数的列向量。</li><li><strong>代码实现</strong></li></ol><p><strong>MATLAB实现</strong>：MATLAB中求解线性规划的命令为：<br>[ x，fval ]=linprog（f，A，b）<br>[ x，fval ]=linprog（f，A，b，Aeq，beq）<br>[ x，fval ]=linprog（f，A，b，Aeq，beq，lb，ub）<br>其中：返回的x为决策向量的取值； 返回的fval是目标函数的最大值；f为价值向量；A和b对应的是线性不等式约束；Aeq和beq对应的是线性等式约束；lb和ub分别对应的是决策向量的下界向量和上界向量。<br>eg1:<img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-34d792f1f57ef43f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性规划"><br>(1)化为Matlab标准型，即<img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6c2b7cc03d8c2e8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性规划"><br>(2)求解的Matlab程序如下：</p><pre><code>f=[-2,-3,5]'A=[-2,5,-1;1,3,1];  b=[-10;12];Aeq=[1,1,1];    beq=7;[x,fval]=linprog(f,A,b,Aeq,beq,zeros(3,1));xfval=-fval</code></pre><p>这里的zeros(3,1)是为了产生3行1列的全0矩阵，对应着x1,x2,x3均大于等于0的约束条件。<br> eg2:可以转化为线性规划的问题<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-1e8c867f5afe3a4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性规划"><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-c9708cba53ff0815.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性规划"><br>可进一步把模型改写为：<img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-e64ab0f6f9e2c5a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性规划"><br><a href="https://blog.csdn.net/u013414501/article/details/50473855" target="_blank" rel="noopener">参考链接</a><br><strong>应用</strong>：运输问题(产销平衡)、指派问题（匈牙利算法）、对偶理论与灵敏度分析、投资的收益和风险</p><ul><li>非线性规划</li></ul><ol><li><strong>简介</strong>：如果线性规划的最优解存在，其最优解只能在其可行域的边界上达到（特别是可行域的顶点上达到）；而非线性规划的最优解（如果最优解存在）则可能在其可行域的任意一点达到。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-c27cae1fa529323f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="非线性规划"><br>其中f(x)是标量函数， Beq,Aeq,B,A 是相应维数的矩阵和向量， Ceq(x),C(x) 是非线性向量函数。</li><li><strong>代码实现</strong>：<br>MATLAB代码实现：<pre><code>x = fmincon(fun,x0,A,b,Aeq,beq,lb,ub,nonlcon,options)</code></pre></li></ol><blockquote><p>1.fun为目标函数<br>2.x0为初始值<br>3.A是不等式约束AX&lt;=b的系数矩阵<br>4.b是不等式约束AX&lt;=b的常数项<br>5.Aeq是等式约束AeqX=beq的系数矩阵，<br>6.beq是等式约束AeqX=beq的常数项，<br>7.lb是X的下限，<br>8.ub是X的上限，<br>9.nonlcon为非线性不等式约束<br>10.option为设置fmincon的参数<br>eg：<img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-eba3d23d7bd5ebf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="非线性规划"><br>形如上述这样的就是非线性规划：</p></blockquote><pre><code>function f=fun1(x)f=x(1)^2+x(2)^2+8;function [g,h]=fun2(x)g=-x(1)^2+x(2);h=-x(1)-x(2)^2+2;%约束等式options=optimset;[x,y]=fmincon('fun1',rand(2,1),[],[],[],[],zeros(2,1),[],'fun2',options)x =    1.0000    1.0000y =   10.0000</code></pre><blockquote><p><a href="https://blog.csdn.net/starmoth/article/details/88412527" target="_blank" rel="noopener">参考链接</a></p></blockquote><ul><li>整数规划</li></ul><ol><li><strong>简介</strong>：规划中的变量（部分或全部）限制为整数时，称为整数规划。若在线性规划模型中，变量限制为整数，则称为整数线性规划。目前所流行的求解整数规划的方法，往往只适用于整数线性规划。目前还没有一种方法能有效地求解一切整数规划。如不加特殊说明，一般指整数线性规划。对于整数线性规划模型大致可分为两类：<br>1   变量全限制为整数时，称纯（完全）整数规划。<br>2   变量部分限制为整数的，称混合整数规划。</li><li><strong>代码实现</strong><blockquote><p> <a href="https://zhuanlan.zhihu.com/p/38042197" target="_blank" rel="noopener">参考链接</a><br><a href="https://baike.baidu.com/item/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E8%BF%87%E7%A8%8B/2952385?fr=aladdin" target="_blank" rel="noopener">马尔可夫过程</a></p></blockquote></li></ol><ul><li>动态规划</li></ul><ol><li><strong>简介</strong>：动态规划（dynamic programming）是运筹学的一个分支，是求解决策过程（decisionprocess）最优化的数学方法。例如最短路线、库存管理、资源分配、设备更新、排序、装载等问题，用动态规划方法比用其它方法求解更为方便。</li><li><strong>代码实现</strong>：<blockquote><p><a href="https://blog.csdn.net/zw6161080123/article/details/80639932" target="_blank" rel="noopener">参考链接</a><br>具体问题具体分析</p></blockquote></li></ol><h3 id="排队论"><a href="#排队论" class="headerlink" title="排队论"></a>排队论</h3><blockquote><p><a href="https://wenku.baidu.com/view/aac30b9fc8d376eeafaa315c.html" target="_blank" rel="noopener">PPT参考</a><br><a href="https://blog.csdn.net/sunyueqinghit/article/details/81562138" target="_blank" rel="noopener">参考资料</a><br><a href="https://blog.csdn.net/weixin_40725491/article/details/82190598" target="_blank" rel="noopener">案例与代码</a><br><a href="https://blog.csdn.net/qq_29831163/article/details/89735320" target="_blank" rel="noopener">排队论详解及Lingo实现</a></p></blockquote><ol><li><strong>简介</strong>：排队论（Queuing Theory）也称随机服务系统理论，就是为解决上述问题而发展 的一门学科。它研究的内容有下列三部分：<br>（i）性态问题，即研究各种排队系统的概率规律性，主要是研究队长分布、等待时间分布和忙期分布等，包括了瞬态和稳态两种情形。<br>（ii）优化问题，又分静态优和动态优，前者指优设计。后者指现有排队系统的优运营。<br>（iii）排队系统的统计推断，即判断一个给定的排队系统符合于哪种模型，以便根据排队理论进行分析研究。</li><li><strong>符号说明</strong>：<br>排队模型用六个符号表示，在符号之间用斜线隔开，即 X/Y/Z/A/B/C 。<blockquote><p>第一 个符号 X 表示顾客到达流或顾客到达间隔时间的分布；<br>第二个符号Y 表示服务时间的 分布；<br>第三个符号Z 表示服务台数目；<br>第四个符号 A是系统容量限制；<br>第五个符号B 是 顾客源数目；<br>第六个符号C 是服务规则，如先到先服务 FCFS，后到先服务 LCFS 等。<br>并约定，如略去后三项，即指X/Y/Z/∞/∞/FCFS的情形。我们只讨论先到先服务 FCFS 的情形，所以略去第六项。</p></blockquote></li></ol><p>表示顾客到达间隔时间和服务时间的分布的约定符号为：</p><blockquote><p>M —指数分布（M 是 Markov 的字头，因为指数分布具有无记忆性，即 Markov 性）；<br>D—确定型（Deterministic）；<br>Ek —k 阶爱尔朗(Erlang)分布；<br>G —一般（general）服务时间的分布；<br>GI —一般相互独立（General Independent）的时间间隔的分布。<br>例如，M/M/1表示相继到达间隔时间为指数分布、服务时间为指数分布、单服务台、等待制系统。<br>D/M/c/表示确定的到达时间、服务时间为指数分布、c个平行服务台（但顾客是一队）的模型。</p></blockquote><ol start="3"><li><strong>参数指标</strong>：为了研究排队系统运行的效率，估计其服务质量，确定系统的优参数，评价系统 的结构是否合理并研究其改进的措施，必须确定用以判断系统运行优劣的基本数量指标，这些数量指标通常是：<blockquote><p>(i)平均队长：指系统内顾客数（包括正被服务的顾客与排队等待服务的顾客）的数学期望，记作Ls 。<br>(ii)平均排队长:指系统内等待服务的顾客数的数学期望，记作 Lq 。<br>(iii)平均逗留时间：顾客在系统内逗留时间（包括排队等待的时间和接受服务的时间）的数学期望，记作Ws 。<br>(iv）平均等待时间：指一个顾客在排队系统中排队等待时间的数学期望，记作Wq 。<br>(v）平均忙期：指服务机构连续繁忙时间（顾客到达空闲服务机构起，到服务机构再次空闲止的时间）长度的数学期望，记为 Tb</p></blockquote></li></ol><h3 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h3><blockquote><p><a href="https://wenku.baidu.com/view/7906bbcd89eb172ded63b732.html" target="_blank" rel="noopener">PPT参考</a><br><a href="https://zhuanlan.zhihu.com/p/38207837" target="_blank" rel="noopener">详细实现</a><br><a href="https://blog.csdn.net/qq_38173003/article/details/81741263" target="_blank" rel="noopener">代码实现</a></p></blockquote><ol><li><strong>简介</strong>：层次分析法（Analytic Hierarchy Process，简称 AHP）是对一些较为复杂、较为模糊的问题作出决策的简易方法，它特别适用于那些难于完全定量分析的问题。</li><li><strong>步骤</strong>：<blockquote><p>（i）建立递阶层次结构模型；<br>（ii）构造出各层次中的所有判断矩阵；<br>（iii）层次单排序及一致性检验；<br>（iv）层次总排序及一致性检验。</p></blockquote></li><li><strong>概念</strong>：应用 AHP 分析决策问题时，首先要把问题条理化、层次化，构造出一个有层次的结构模型。在这个模型下，复杂问题被分解为元素的组成部分。这些元素又按其属性及关系形成若干层次。上一层次的元素作为准则对下一层次有关元素起支配作用。<br>这些层次可以分为三类：<blockquote><p>（i）最高层：这一层次中只有一个元素，一般它是分析问题的预定目标或理想结果，因此也称为目标层。<br>（ii）中间层：这一层次中包含了为实现目标所涉及的中间环节，它可以由若干个层次组成，包括所需考虑的准则、子准则，因此也称为准则层。<br>（iii）最底层：这一层次包括了为实现目标可供选择的各种措施、决策方案等，因此也称为措施层或方案层。</p></blockquote></li></ol><p>递阶层次结构中的层次数与问题的复杂程度及需要分析的详尽程度有关，一般地层次数不受限制。每一层次中各元素所支配的元素一般不要超过 9 个。这是因为支配的元素过多会给两两比较判断带来困难。</p><h3 id="多属性决策"><a href="#多属性决策" class="headerlink" title="多属性决策"></a>多属性决策</h3><blockquote><p><a href="https://wenku.baidu.com/view/c6091c5cae45b307e87101f69e3143323968f58e.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://www.cnblogs.com/Qling/p/9295414.html" target="_blank" rel="noopener">参考资料</a></p></blockquote><p><strong>简介</strong>：多属性决策是现代决策科学的一个重要组成部分，它的理论和方法在工程设计、经济、管理和军事等诸多领域中有着广泛的应用，如：投资决策、项目评估、维修服务、武器系统性能评定、工厂选址、投标 招标、产业 部门发展排序和经济效益综合评价等．多属性决策的实质是利用已有的决策信息通过一定的方式对一组( ( 有限个) ) 备选方案进行排序或择优．它主要由两部分组成：</p><blockquote><p>(l) 获取决策信息．决策信息一般包括两个方面的内容：属性权重和属性值( ( 属性值主要有三种形式：实数、区间数和语言) ) ．其中，属性权重的确定是多属性决策中的一个重要研究内容；<br>(2)通过一定的方式对决策信息进行集结并对方案进行排序和择优．</p></blockquote><p>###主成分分析法</p><blockquote><p><a href="https://wenku.baidu.com/view/d797eda7112de2bd960590c69ec3d5bbfd0adabf.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://blog.csdn.net/Murray_/article/details/79945148" target="_blank" rel="noopener">参考资料</a><br><a href="https://my.oschina.net/u/3888421/blog/2249132" target="_blank" rel="noopener">Python实现</a></p></blockquote><p><strong>简介</strong>：主成分分析（Principal Component Analysis，PCA）， 是一种统计方法。通过正交变换将一组可能存在相关性的变量转换为一组线性不相关的变量，转换后的这组变量叫主成分。</p><h3 id="商权法"><a href="#商权法" class="headerlink" title="商权法"></a>商权法</h3><blockquote><p><a href="https://blog.csdn.net/qq_32942549/article/details/80019005" target="_blank" rel="noopener">参考资料</a><br><a href="https://www.jianshu.com/p/477d4b22de6d" target="_blank" rel="noopener">基本步骤</a></p></blockquote><p><strong>简介</strong>：按照信息论基本原理的解释，信息是系统有序程度的一个度量，熵是系统无序程度的一个度量；如果指标的信息熵越小，该指标提供的信息量越大，在综合评价中所起作用理当越大，权重就应该越高。因此，可利用信息熵这个工具，计算出各个指标的权重，为多指标综合评价提供依据。</p><h3 id="插值与拟合"><a href="#插值与拟合" class="headerlink" title="插值与拟合"></a>插值与拟合</h3><ol><li><strong>简介</strong>：插值：求过已知有限个数据点的近似函数。<br>拟合：已知有限个数据点，求近似函数，不要求过已知数据点，只要求在某种意义下它在这些点上的总偏差最小。<br>插值和拟合都是要根据一组数据构造一个函数作为近似，由于近似的要求不同，二者的数学方法上是完全不同的。而面对一个实际问题，究竟应该用插值还是拟合，有时容易确定，有时则并不明显。</li></ol><ul><li><p>插值方法：<br>几种基本的、常用的插值：拉格朗日多项式插值、牛顿插值、分段线性插值、Hermite 插值和三次样条插值。</p></li><li><p>曲线拟合的线性最小二乘法（线性最小二乘法）：<br>最小二乘优化（lsqlin 函数、lsqcurvefit 函数、lsqnonlin 函数、lsqnonneg 函数）</p></li></ul><ol start="2"><li><strong>代码实现</strong>：<blockquote><p><a href="https://www.cnblogs.com/henuliulei/p/9473260.html" target="_blank" rel="noopener">参考链接</a></p></blockquote></li></ol><h3 id="方差分析"><a href="#方差分析" class="headerlink" title="方差分析"></a>方差分析</h3><blockquote><p><a href="https://wenku.baidu.com/view/01e7060f0975f46526d3e153.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://www.jianshu.com/p/f5f54a39cb19" target="_blank" rel="noopener">案例分析</a><br><a href="https://blog.csdn.net/Moxiaoaijing/article/details/81079990" target="_blank" rel="noopener">SPSS实现</a></p></blockquote><ol><li><strong>简介</strong>：为了使生产过程稳定，达到优质、高产，需要对影响产品质量的因素进行分析，找出有显著影响的那些因素，除了从机理方面进行研究外，常常要作许多试验，对结果作分析、比较，寻求规律。用数理统计分析试验结果、鉴别各因素对结果影响程度的方法称为方差分析（Analysis Of Variance），记作 ANOVA。</li><li><strong>分类</strong>:<br>§1 单因素方差分析<br>只考虑一个因素 A 对所关心的指标的影响， A 取几个水平，在每个水平上作若干个试验，试验过程中除 A 外其它影响指标的因素都保持不变（只有随机因素存在），我们的任务是从试验结果推断，因素 A 对指标有无显著影响，即当 A 取不同水平时指标有无显著差别。A 取某个水平下的指标视为随机变量，判断 A 取不同水平时指标有无显著差别，相当于检验若干总体的均值是否相等。<br>§2 双因素方差分析<br>如果要考虑两个因素 B A, 对指标的影响， B A, 各划分几个水平，对每一个水平组合作若干次试验，对所得数据进行方差分析，检验两因素是否分别对指标有显著影响，或者还要进一步检验两因素是否对指标有显著的交互影响。<br>§3 正交试验设计与方差分析<br>由于因素较少时，我们可以对不同因素的所有可能的水平组合做试验，这叫做全面试验。当因素较多时，虽然理论上仍可采用前面的方法进行全面试验后再做相应的方差分析，但是在实际中有时会遇到试验次数太多的问题。如果考虑更多的因素及水平，则全面试验的次数可能会大得惊人。因此在实际应用中，对于多因素做全面试验是不现实的。于是我们考虑是否可以选择其中一部分组合进行试验，这就要用到试验设计方法选择合理的试验方案，使得试验次数不多，但也能得到比较满意的结果。</li></ol><h3 id="回归分析"><a href="#回归分析" class="headerlink" title="回归分析"></a>回归分析</h3><blockquote><p><a href="https://www.jianshu.com/p/bbe0c702b5ad" target="_blank" rel="noopener">概念理解</a><br><a href="https://wenku.baidu.com/view/d7a2b92b58fb770bf78a55fe.html" target="_blank" rel="noopener">PPT参考</a><br><a href="https://blog.csdn.net/red_stone1/article/details/81122926" target="_blank" rel="noopener">参考资料</a><br><a href="https://blog.csdn.net/weixin_41893675/article/details/83047162" target="_blank" rel="noopener">代码实现</a><br><a href="https://zhuanlan.zhihu.com/p/42300484" target="_blank" rel="noopener">多元回归分析代码</a><br><a href="https://wenku.baidu.com/view/a8979f02cd1755270722192e453610661ed95a3e.html" target="_blank" rel="noopener">SPSS分析</a></p></blockquote><ol><li><strong>简介</strong>：曲线拟合问题的特点是，根据得到的若干有关变量的一组数据，寻找因变量与（一个或几个）自变量之间的一个函数，使这个函数对那组数据拟合得最好。通常，函数的形式可以由经验、先验知识或对数据的直观观察决定，要作的工作是由数据用最小二乘法计算函数中的待定系数。从计算的角度看，问题似乎已经完全解决了，还有进一步研究的必要吗?从数理统计的观点看，这里涉及的都是随机变量，我们根据一个样本计算出的那些系数，只是它们的一个（点）估计，应该对它们作区间估计或假设检验，如果置信区间太大，甚至包含了零点，那么系数的估计值是没有多大意义的。另外也可以用方差分析方法对模型的误差进行分析，对拟合的优劣给出评价。简单地说，回归分析就是对拟合问题作的统计分析。</li><li><strong>研究的问题</strong>：<blockquote><p>（i）建立因变量 y 与自变量 x1,x2,……，xm之间的回归模型（经验公式）；<br>（ii）对回归模型的可信度进行检验；<br>（iii）判断每个自变量xi=(i=1,2,……，m)对 y 的影响是否显著；<br>（iv）诊断回归模型是否适合这组数据；<br>（v）利用回归模型对 y 进行预报或控制。</p></blockquote></li></ol><h3 id="微分方程建模"><a href="#微分方程建模" class="headerlink" title="微分方程建模"></a>微分方程建模</h3><blockquote><p><a href="https://wenku.baidu.com/view/285699a06394dd88d0d233d4b14e852458fb3981.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://blog.csdn.net/hesays/article/details/39899047" target="_blank" rel="noopener">微分方程求解代码</a></p></blockquote><ol><li><strong>简介</strong>：微分方程建模是数学建模的重要方法，因为许多实际问题的数学描述将导致求解微分方程的定解问题。把形形色色的实际问题化成微分方程的定解问题，大体上可以按以下几步：<blockquote><ul><li>根据实际要求确定要研究的量(自变量、未知函数、必要的参数等)并确定坐标系。</li><li>找出这些量所满足的基本规律(物理的、几何的、化学的或生物学的等等)。</li><li>运用这些规律列出方程和定解条件。</li></ul></blockquote></li><li><strong>方法</strong>：列方程常见的方法有：<blockquote><p>（i）按规律直接列方程<br>在数学、力学、物理、化学等学科中许多自然现象所满足的规律已为人们所熟悉，并直接由微分方程所描述。如牛顿第二定律、放射性物质的放射性规律等。我们常利用这些规律对某些实际问题列出微分方程。<br>（ii）微元分析法与任意区域上取积分的方法<br>自然界中也有许多现象所满足的规律是通过变量的微元之间的关系式来表达的。对于这类问题，我们不能直接列出自变量和未知函数及其变化率之间的关系式，而是通过微元分析法，利用已知的规律建立一些变量（自变量与未知函数）的微元之间的关系式，然后再通过取极限的方法得到微分方程，或等价地通过任意区域上取积分的方法来建立微分方程。<br>（iii）模拟近似法<br>在生物、经济等学科中，许多现象所满足的规律并不很清楚而且相当复杂，因而需要根据实际资料或大量的实验数据，提出各种假设。在一定的假设下，给出实际现象所满足的规律，然后利用适当的数学方法列出微分方程。在实际的微分方程建模过程中，也往往是上述方法的综合应用。不论应用哪种方法，通常要根据实际情况，作出一定的假设与简化，并要把模型的理论或计算结果与实际情况进行对照验证，以修改模型使之更准确地描述实际问题并进而达到预测预报的目的。</p></blockquote></li></ol><h3 id="马氏链模型"><a href="#马氏链模型" class="headerlink" title="马氏链模型"></a>马氏链模型</h3><blockquote><p><a href="https://wenku.baidu.com/view/174a64f19e31433239689346.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://www.zhihu.com/question/26665048" target="_blank" rel="noopener">通俗解释</a><br><a href="https://blog.csdn.net/asd20172016/article/details/81392938" target="_blank" rel="noopener">Python代码实现</a></p></blockquote><p> <strong>简介</strong>：马尔可夫链的定义<br>现实世界中有很多这样的现象：某一系统在已知现在情况的条件下，系统未来时刻的情况只与现在有关，而与过去的历史无直接关系。比如，研究一个商店的累计销售额，如果现在时刻的累计销售额已知，则未来某一时刻的累计销售额与现在时刻以前的任一时刻累计销售额无关。上节中的几个例子也均属此类。描述这类随机现象的数学模型称为马氏模型。</p><h3 id="时间序列模型"><a href="#时间序列模型" class="headerlink" title="时间序列模型"></a>时间序列模型</h3><blockquote><p><a href="https://blog.csdn.net/mengjizhiyou/article/details/82683448" target="_blank" rel="noopener">概念理解</a><br><a href="https://www.jianshu.com/p/c7cb0de104f4" target="_blank" rel="noopener">参考资料</a></p></blockquote><p><strong>简介</strong>：时间序列是按时间顺序排列的、随时间变化且相互关联的数据序列。分析时间序列的方法构成数据分析的一个重要领域，即时间序列分析。<br>时间序列根据所研究的依据不同，可有不同的分类。</p><blockquote><p>1．按所研究的对象的多少分，有一元时间序列和多元时间序列。<br>2．按时间的连续性可将时间序列分为离散时间序列和连续时间序列两种。<br>3．按序列的统计特性分，有平稳时间序列和非平稳时间序列。如果一个时间序列的概率分布与时间 t 无关，则称该序列为严格的（狭义的）平稳时间序列。如果序列的一、二阶矩存在，而且对任意时刻 t 满足：<br>（1）均值为常数<br>（2）协方差为时间间隔 τ 的函数。<br>则称该序列为宽平稳时间序列，也叫广义平稳时间序列。我们以后所研究的时间序列主要是宽平稳时间序列。<br>4．按时间序列的分布规律来分，有高斯型时间序列和非高斯型时间序列。</p></blockquote><h3 id="模糊数学模型"><a href="#模糊数学模型" class="headerlink" title="模糊数学模型"></a>模糊数学模型</h3><blockquote><p><a href="https://wenku.baidu.com/view/891d403cabea998fcc22bcd126fff705cc175c8e.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://wenku.baidu.com/view/543cbf9cf8c75fbfc77db296.html" target="_blank" rel="noopener">参考资料</a></p></blockquote><p> <strong>简介</strong>：模糊是指客观事物差异的中间过渡中的“不分明性”或“亦此亦彼性”。如高个子与矮个子、年轻人与老年人、热水与凉水、环境污染严重与不严重等。在决策中，也有这种模糊的现象，如选举一个好干部，但怎样才算一个好干部？好干部与不好干部之间没有绝对分明和固定不变的界限。这些现象很难用经典的数学来描述。</p><h3 id="灰色系统理论及其应用"><a href="#灰色系统理论及其应用" class="headerlink" title="灰色系统理论及其应用"></a>灰色系统理论及其应用</h3><blockquote><p><a href="https://blog.csdn.net/qq547276542/article/details/77865341/" target="_blank" rel="noopener">灰色预测</a><br><a href="https://wenku.baidu.com/view/6fc36073657d27284b73f242336c1eb91a3733f2.html" target="_blank" rel="noopener">PPT资料l</a><br><a href="https://blog.csdn.net/wys7541/article/details/82354152" target="_blank" rel="noopener">代码实现</a></p></blockquote><p><strong>简介</strong>：客观世界的很多实际问题，其内部的结构、参数以及特征并未全部被人们了解，人们不可能象研究白箱问题那样将其内部机理研究清楚，只能依据某种思维逻辑与推断来构造模型。对这类部分信息已知而部分信息未知的系统，我们称之为灰色系统。</p><h3 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h3><blockquote><p><a href="https://wenku.baidu.com/view/28c079ae0c22590103029d2b.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://blog.csdn.net/wsp_1138886114/article/details/80475981" target="_blank" rel="noopener">K-means算法实现及详解</a><br><a href="https://blog.csdn.net/LuYi_WeiLin/article/details/91129037" target="_blank" rel="noopener">SPSS聚类分析</a></p></blockquote><p><strong>简介</strong>：将认识对象进行分类是人类认识世界的一种重要方法，比如有关世界的时间进程的研究，就形成了历史学，也有关世界空间地域的研究，则形成了地理学。又如在生物学中，为了研究生物的演变，需要对生物进行分类，生物学家根据各种生物的特征，将它们归属于不同的界、门、纲、目、科、属、种之中。事实上，分门别类地对事物进行研究，要远比在一个混杂多变的集合中更清晰、明了和细致，这是因为同一类事物会具有更多的近似特性。在企业的经营管理中，为了确定其目标市场，首先要进行市场细分。因为无论一个企业多么庞大和成功，它也无法满足整个市场的各种需求。而市场细分，可以帮助企业找到适合自己特色，并使企业具有竞争力的分市场，将其作为自己的重点开发目标。通常，人们可以凭经验和专业知识来实现分类。而聚类分析（cluster analyses）作为一种定量方法，将从数据分析的角度，给出一个更准确、细致的分类工具。</p><h3 id="存贮论"><a href="#存贮论" class="headerlink" title="存贮论"></a>存贮论</h3><blockquote><p><a href="https://wenku.baidu.com/view/7ab4704b366baf1ffc4ffe4733687e21af45ffbd.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://blog.csdn.net/qq_29831163/article/details/89891256" target="_blank" rel="noopener">参考资料及Lingo实现</a></p></blockquote><p><strong>简介</strong>：存贮论（或称为库存论）是定量方法和技术最早的领域之一，是研究存贮系统的性质、运行规律以及如何寻找最优存贮策略的一门学科，是运筹学的重要分支。存贮论的数学模型一般分成两类：一类是确定性模型，它不包含任何随机因素，另一类是带有随机因素的随机存贮模型。</p><h3 id="现代优化算法"><a href="#现代优化算法" class="headerlink" title="现代优化算法"></a>现代优化算法</h3><ul><li><p>模拟退火</p><blockquote><p><a href="https://baike.baidu.com/item/%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/355508?fr=aladdin" target="_blank" rel="noopener">概念理解</a><br><a href="https://wenku.baidu.com/view/0ec00e6fef06eff9aef8941ea76e58fafab0450f.html" target="_blank" rel="noopener">PPT资料啊</a><br><a href="https://zhuanlan.zhihu.com/p/33184423" target="_blank" rel="noopener">参考资料</a><br><a href="https://www.cnblogs.com/sench/p/9427193.html" target="_blank" rel="noopener">模拟退火TSP问题</a><br><a href="https://www.jianshu.com/p/0ef29fcfe7b1" target="_blank" rel="noopener">代码实现</a></p></blockquote></li><li><p>遗传算法</p><blockquote><p><a href="https://baike.baidu.com/item/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/838140?fr=aladdin" target="_blank" rel="noopener">概念理解</a><br><a href="https://www.jianshu.com/p/ae5157c26af9" target="_blank" rel="noopener">参考资料</a><br><a href="https://blog.csdn.net/yy2050645/article/details/80724857" target="_blank" rel="noopener">Python实现</a><br><a href="https://blog.csdn.net/qq_35109096/article/details/81105522" target="_blank" rel="noopener">代码实现</a></p></blockquote></li></ul><p><strong>简介</strong>：遗传算法（Genetic Algorithm, GA）是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。其主要特点是直接对结构对象进行操作，不存在求导和函数连续性的限定；具有内在的隐并行性和更好的全局寻优能力；采用概率化的寻优方法，不需要确定的规则就能自动获取和指导优化的搜索空间，自适应地调整搜索方向。遗传算法以一种群体中的所有个体为对象，并利用随机化技术指导对一个被编码的参数空间进行高效搜索。其中，选择、交叉和变异构成了遗传算法的遗传操作；参数编码、初始群体的设定、适应度函数的设计、遗传操作设计、控制参数设定五个要素组成了遗传算法的核心内容。</p><ul><li>禁忌搜索<blockquote><p><a href="https://baike.baidu.com/item/%E7%A6%81%E5%BF%8C%E6%90%9C%E7%B4%A2/6987733?fr=aladdin" target="_blank" rel="noopener">概念理解</a><br><a href="https://wenku.baidu.com/view/2a32329977eeaeaad1f34693daef5ef7bb0d124b.html" target="_blank" rel="noopener">PPT资料</a></p></blockquote></li></ul><p><strong>简介</strong>：禁忌搜索（Tabu Search，TS）是一种现代启发式算法，由美国科罗拉多大学教授Fred Glover在1986年左右提出的，是一个用来跳脱局部最优解的搜索方法。算法基于局部搜索算法改进而来，通过引入禁忌表来克服局部搜索算法容易陷入局部最优的缺点，具有全局寻优能力。</p><ul><li>蚁群算法<blockquote><p><a href="https://wenku.baidu.com/view/025b2aa887c24028905fc374.html" target="_blank" rel="noopener">参考过程</a><br><a href="https://blog.csdn.net/lyxleft/article/details/82980760" target="_blank" rel="noopener">算法详解及代码</a><br><a href="https://www.jb51.net/article/128117.htm" target="_blank" rel="noopener">Python实现</a></p></blockquote></li></ul><h3 id="神经网络模型"><a href="#神经网络模型" class="headerlink" title="神经网络模型"></a>神经网络模型</h3><blockquote><p><a href="https://wenku.baidu.com/view/0814339d988fcc22bcd126fff705cc1755275ffc.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://blog.csdn.net/qq_24690701/article/details/81868048" target="_blank" rel="noopener">概念理解</a><br><a href="https://blog.csdn.net/dujiahei/article/details/80965661" target="_blank" rel="noopener">模型一览</a><br><a href="https://blog.csdn.net/qq_29831163/article/details/89509279" target="_blank" rel="noopener">案例及代码实现</a><br><a href="https://blog.csdn.net/ximingren/article/details/79981620" target="_blank" rel="noopener">Python实现</a></p></blockquote><p><strong>简介</strong>：人工神经网络（artificial neural network，以下简称 NN）有三个基本要素：</p><blockquote><p>（i）一组连接（对应于生物神经元的突触），连接强度由各连接上的权值表示，权值为正表示激活，为负表示抑制。<br>（ii）一个求和单元，用于求取各输入信号的加权和（线性组合）。<br>（iii）一个非线性激活函数，起非线性映射作用并将神经元输出幅度限制在一定范围内（一般限制在 （0,1） 或（-1,1） 之间）。</p></blockquote><h3 id="粒子群优化算法"><a href="#粒子群优化算法" class="headerlink" title="粒子群优化算法"></a>粒子群优化算法</h3><blockquote><p><a href="https://wenku.baidu.com/view/e920ac483968011ca3009189.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://www.cnblogs.com/GraceSkyer/p/8448348.html" target="_blank" rel="noopener">代码实现</a></p></blockquote><h3 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h3><blockquote><p><a href="https://blog.csdn.net/u011815404/article/details/80313879" target="_blank" rel="noopener">算法汇总</a></p></blockquote><ul><li>迪杰斯特拉算法<blockquote><p><a href="https://www.jianshu.com/p/ff6db00ad866" target="_blank" rel="noopener">算法理解及实现</a></p></blockquote></li></ul><p><strong>简介</strong>：Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。</p><ul><li>弗洛伊德Floyd算法<blockquote><p><a href="https://wenku.baidu.com/view/8bb2ea6ca31614791711cc7931b765ce04087a5a.html" target="_blank" rel="noopener">PPT资料</a><br><a href="https://blog.csdn.net/weixin_38361153/article/details/88415181" target="_blank" rel="noopener">Python实现</a></p></blockquote></li></ul><p><strong>简介</strong>：Floyd算法又称为插点法，是一种利用<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408" target="_blank" rel="noopener">动态规划</a>的思想寻找给定的<a href="https://baike.baidu.com/item/%E5%8A%A0%E6%9D%83%E5%9B%BE/10579361" target="_blank" rel="noopener">加权图</a>中多源点之间<a href="https://baike.baidu.com/item/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/6334920" target="_blank" rel="noopener">最短路径</a>的算法，与Dijkstra算法类似。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实战：小道具小功能实现</title>
      <link href="/posts/blog-python12.html"/>
      <url>/posts/blog-python12.html</url>
      
        <content type="html"><![CDATA[<h5 id="文末有所有项目的源码地址，可供参考："><a href="#文末有所有项目的源码地址，可供参考：" class="headerlink" title="文末有所有项目的源码地址，可供参考："></a>文末有所有项目的源码地址，可供参考：</h5><h3 id="Image-Edit"><a href="#Image-Edit" class="headerlink" title="Image-Edit"></a>Image-Edit</h3><h5 id="几个基本的图片编辑工具，包括一下功能："><a href="#几个基本的图片编辑工具，包括一下功能：" class="headerlink" title="几个基本的图片编辑工具，包括一下功能："></a>几个基本的图片编辑工具，包括一下功能：</h5><ul><li>文件：打开，保存，退出</li><li>编辑：放大，缩小，灰度，亮度，旋转，截图</li><li>变换：傅里叶变换，离散余弦变换，Radon变换</li><li>噪声：高斯，椒盐，斑点，泊松</li><li>滤波：高通，低通，平滑，锐化</li><li>直方图统计：R直方图，G直方图，B直方图</li><li>图像增强：伪彩色，真彩色，直方图均衡，NTSC颜色模型，YCbCr颜色模型，HSV颜色模型</li><li>阈值分割</li><li>生态学处理</li><li>特征提取</li><li>图像分类与识别</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-dd904df9db6b4a24?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库文件需要"><a href="#库文件需要" class="headerlink" title="库文件需要"></a>库文件需要</h5><pre><code> 1. PyQt5 2. sys 3. os 4. opencv2 5. numpy 6. scipy 7. matplotlib</code></pre><h3 id="Beautify-Camera"><a href="#Beautify-Camera" class="headerlink" title="Beautify-Camera"></a>Beautify-Camera</h3><h5 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>文件：打开，保存，打开摄像头</li><li>操作：还原，人脸识别</li><li>滤镜：怀旧，木刻，灰色，彩色，风格化，增强细节</li><li>调节：亮度，饱和度，伽马变换，边缘保持</li><li>磨皮美白：美白度，磨皮程度，磨皮精度</li><li>灰度直方图</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-08e784fc5ae40737?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库文件需要-1"><a href="#库文件需要-1" class="headerlink" title="库文件需要"></a>库文件需要</h5><pre><code> 1. PyQt5 2. sys 3. opencv2 4. numpy 5. matplotlib</code></pre><h5 id="相关代码说明"><a href="#相关代码说明" class="headerlink" title="相关代码说明"></a>相关代码说明</h5><ul><li><p>人脸识别</p><pre><code># 人脸识别  def detect_face(self):      img = self.raw_image      face_cascade = cv2.CascadeClassifier('./haarcascade_frontalface_default.xml')      gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)      faces = face_cascade.detectMultiScale(gray, 1.3, 5)      return faces</code></pre></li><li><p>皮肤识别</p><pre><code># 皮肤识别  def detect_skin(self):      img = self.raw_image      rows, cols, channals = img.shape      for r in range(rows):          for c in range(cols):              B = img.item(r, c, 0)              G = img.item(r, c, 1)              R = img.item(r, c, 2)              if (abs(R - G) &gt; 15) and (R &gt; G) and (R &gt; B):                  if (R &gt; 95) and (G &gt; 40) and (B &gt; 20) and (max(R, G, B) - min(R, G, B) &gt; 15):                      self.imgskin[r, c] = (1, 1, 1)                  elif (R &gt; 220) and (G &gt; 210) and (B &gt; 170):                      self.imgskin[r, c] = (1, 1, 1)</code></pre></li><li><p>其他不做详解</p></li></ul><h3 id="Calculator"><a href="#Calculator" class="headerlink" title="Calculator"></a>Calculator</h3><h5 id="主要功能-1"><a href="#主要功能-1" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>基本的加减乘除和开根号等运算</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f9b852ac6c40ef25?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库文件需求"><a href="#库文件需求" class="headerlink" title="库文件需求"></a>库文件需求</h5><pre><code>1.math2.tkinter</code></pre><h3 id="pyQt5-Calculator"><a href="#pyQt5-Calculator" class="headerlink" title="pyQt5-Calculator"></a>pyQt5-Calculator</h3><h5 id="主要功能-2"><a href="#主要功能-2" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>基本的加减乘除和开根号等运算</li></ul><p>1.calculator.py</p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-08132a3099f58ccd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><p>2.Calculator_.py</p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-3b052cc5951cb1f3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库文件需求-1"><a href="#库文件需求-1" class="headerlink" title="库文件需求"></a>库文件需求</h5><pre><code>1.PyQt52.sys3.math</code></pre><h3 id="Painting绘画"><a href="#Painting绘画" class="headerlink" title="Painting绘画"></a>Painting绘画</h3><h5 id="主要功能-3"><a href="#主要功能-3" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>File：新建画板，打开图片，保存图片</li><li>Edit：复制，清空画板</li><li>Image：翻转</li><li>工具：基本画笔，橡皮擦，图形创建工具等</li><li>编辑区，色彩调节区，字体调节区等</li></ul><h5 id="库文件需求-2"><a href="#库文件需求-2" class="headerlink" title="库文件需求"></a>库文件需求</h5><pre><code>1.PyQt52.random3.type4.os</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-94153ceb969517fd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h3 id="NotePad"><a href="#NotePad" class="headerlink" title="NotePad"></a>NotePad</h3><h5 id="主要功能-4"><a href="#主要功能-4" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>基本文本编辑，类似于记事本</li></ul><h5 id="库文件需求-3"><a href="#库文件需求-3" class="headerlink" title="库文件需求"></a>库文件需求</h5><pre><code>1.pyQt52.sys3.os</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-054412aceafbc63f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h3 id="RandomPassWord"><a href="#RandomPassWord" class="headerlink" title="RandomPassWord"></a>RandomPassWord</h3><h5 id="主要功能-5"><a href="#主要功能-5" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>随机生成一串密码，包括大小写字母，数字，符号，可指定长度</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f815c1dd28390162.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库文件引入"><a href="#库文件引入" class="headerlink" title="库文件引入"></a>库文件引入</h5><pre><code>1.secrets2.pyQt53.sys</code></pre><h3 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h3><h5 id="主要功能-6"><a href="#主要功能-6" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>基本浏览器功能</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-c4addcf72cd0bbd3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库函数需求"><a href="#库函数需求" class="headerlink" title="库函数需求"></a>库函数需求</h5><pre><code>1.pyQt52.os3.sys</code></pre><h3 id="MusicPlayer"><a href="#MusicPlayer" class="headerlink" title="MusicPlayer"></a>MusicPlayer</h3><h5 id="主要功能-7"><a href="#主要功能-7" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>音乐播放器</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-630c03ab25054cbb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库函数引用"><a href="#库函数引用" class="headerlink" title="库函数引用"></a>库函数引用</h5><pre><code>1.os2.sys3.time4.pyQt5</code></pre><h3 id="PyTunes"><a href="#PyTunes" class="headerlink" title="PyTunes"></a>PyTunes</h3><h5 id="主要功能-8"><a href="#主要功能-8" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>轻量级音乐播放器</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-33d57b3fd6ebd253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库函数引用-1"><a href="#库函数引用-1" class="headerlink" title="库函数引用"></a>库函数引用</h5><pre><code>1.sys2.pyQt5</code></pre><p><strong>源码地址：</strong><a href="https://github.com/JackHCC/Mini-Tools" target="_blank" rel="noopener">https://github.com/JackHCC/Mini-Tools</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-机器学习模块PyTorch</title>
      <link href="/posts/blog-python11.html"/>
      <url>/posts/blog-python11.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/JackHCC/API-for-PyTorch" target="_blank" rel="noopener">点击访问：PyTorch中文API应用具体代码地址</a></p><h1 id="自动求导机制"><a href="#自动求导机制" class="headerlink" title="自动求导机制"></a>自动求导机制</h1><p>本说明将概述Autograd如何工作并记录操作。了解这些并不是绝对必要的，但我们建议您熟悉它，因为它将帮助您编写更高效，更简洁的程序，并可帮助您进行调试。</p><h2 id="从后向中排除子图"><a href="#从后向中排除子图" class="headerlink" title="从后向中排除子图"></a>从后向中排除子图</h2><p>每个变量都有两个标志：<code>requires_grad</code>和<code>volatile</code>。它们都允许从梯度计算中精细地排除子图，并可以提高效率。</p><h3 id="requires-grad"><a href="#requires-grad" class="headerlink" title="requires_grad"></a><code>requires_grad</code></h3><p>如果有一个单一的输入操作需要梯度，它的输出也需要梯度。相反，只有所有输入都不需要梯度，输出才不需要。如果其中所有的变量都不需要梯度进行，后向计算不会在子图中执行。</p><pre><code>&gt;&gt;&gt; x = Variable(torch.randn(5, 5))&gt;&gt;&gt; y = Variable(torch.randn(5, 5))&gt;&gt;&gt; z = Variable(torch.randn(5, 5), requires_grad=True)&gt;&gt;&gt; a = x + y&gt;&gt;&gt; a.requires_gradFalse&gt;&gt;&gt; b = a + z&gt;&gt;&gt; b.requires_gradTrue</code></pre><p>这个标志特别有用，当您想要冻结部分模型时，或者您事先知道不会使用某些参数的梯度。例如，如果要对预先训练的CNN进行优化，只要切换冻结模型中的<code>requires_grad</code>标志就足够了，直到计算到最后一层才会保存中间缓冲区，其中的仿射变换将使用需要梯度的权重并且网络的输出也将需要它们。</p><pre><code>model = torchvision.models.resnet18(pretrained=True)for param in model.parameters():    param.requires_grad = False# Replace the last fully-connected layer# Parameters of newly constructed modules have requires_grad=True by defaultmodel.fc = nn.Linear(512, 100)# Optimize only the classifieroptimizer = optim.SGD(model.fc.parameters(), lr=1e-2, momentum=0.9)</code></pre><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h3><p>纯粹的inference模式下推荐使用<code>volatile</code>，当你确定你甚至不会调用<code>.backward()</code>时。它比任何其他自动求导的设置更有效——它将使用绝对最小的内存来评估模型。<code>volatile</code>也决定了<code>require_grad is False</code>。</p><p><code>volatile</code>不同于<code>require_grad</code>的传递。如果一个操作甚至只有有一个<code>volatile</code>的输入，它的输出也将是<code>volatile</code>。<code>Volatility</code>比“不需要梯度”更容易传递——只需要一个<code>volatile</code>的输入即可得到一个<code>volatile</code>的输出，相对的，需要所有的输入“不需要梯度”才能得到不需要梯度的输出。使用volatile标志，您不需要更改模型参数的任何设置来用于inference。创建一个<code>volatile</code>的输入就够了，这将保证不会保存中间状态。</p><pre><code>&gt;&gt;&gt; regular_input = Variable(torch.randn(5, 5))&gt;&gt;&gt; volatile_input = Variable(torch.randn(5, 5), volatile=True)&gt;&gt;&gt; model = torchvision.models.resnet18(pretrained=True)&gt;&gt;&gt; model(regular_input).requires_gradTrue&gt;&gt;&gt; model(volatile_input).requires_gradFalse&gt;&gt;&gt; model(volatile_input).volatileTrue&gt;&gt;&gt; model(volatile_input).creator is NoneTrue</code></pre><h2 id="自动求导如何编码历史信息"><a href="#自动求导如何编码历史信息" class="headerlink" title="自动求导如何编码历史信息"></a>自动求导如何编码历史信息</h2><p>每个变量都有一个<code>.creator</code>属性，它指向把它作为输出的函数。这是一个由<code>Function</code>对象作为节点组成的有向无环图（DAG）的入口点，它们之间的引用就是图的边。每次执行一个操作时，一个表示它的新<code>Function</code>就被实例化，它的<code>forward()</code>方法被调用，并且它输出的<code>Variable</code>的创建者被设置为这个<code>Function</code>。然后，通过跟踪从任何变量到叶节点的路径，可以重建创建数据的操作序列，并自动计算梯度。</p><p>需要注意的一点是，整个图在每次迭代时都是从头开始重新创建的，这就允许使用任意的Python控制流语句，这样可以在每次迭代时改变图的整体形状和大小。在启动训练之前不必对所有可能的路径进行编码—— what you run is what you differentiate.</p><h2 id="Variable上的In-place操作"><a href="#Variable上的In-place操作" class="headerlink" title="Variable上的In-place操作"></a>Variable上的In-place操作</h2><p>在自动求导中支持in-place操作是一件很困难的事情，我们在大多数情况下都不鼓励使用它们。Autograd的缓冲区释放和重用非常高效，并且很少场合下in-place操作能实际上明显降低内存的使用量。除非您在内存压力很大的情况下，否则您可能永远不需要使用它们。</p><p>限制in-place操作适用性主要有两个原因：</p><p>１．覆盖梯度计算所需的值。这就是为什么变量不支持<code>log_</code>。它的梯度公式需要原始输入，而虽然通过计算反向操作可以重新创建它，但在数值上是不稳定的，并且需要额外的工作，这往往会与使用这些功能的目的相悖。</p><p>２．每个in-place操作实际上需要实现重写计算图。不合适的版本只需分配新对象并保留对旧图的引用，而in-place操作则需要将所有输入的<code>creator</code>更改为表示此操作的<code>Function</code>。这就比较棘手，特别是如果有许多变量引用相同的存储（例如通过索引或转置创建的），并且如果被修改输入的存储被任何其他<code>Variable</code>引用，则in-place函数实际上会抛出错误。</p><h2 id="In-place正确性检查"><a href="#In-place正确性检查" class="headerlink" title="In-place正确性检查"></a>In-place正确性检查</h2><p>每个变量保留有version counter，它每次都会递增，当在任何操作中被使用时。当<code>Function</code>保存任何用于后向的tensor时，还会保存其包含变量的version counter。一旦访问<code>self.saved_tensors</code>，它将被检查，如果它大于保存的值，则会引起错误。</p><h1 id="CUDA语义"><a href="#CUDA语义" class="headerlink" title="CUDA语义"></a>CUDA语义</h1><p><code>torch.cuda</code>会记录当前选择的GPU，并且分配的所有CUDA张量将在上面创建。可以使用<code>torch.cuda.device</code>上下文管理器更改所选设备。</p><p>但是，一旦张量被分配，您可以直接对其进行操作，而不考虑所选择的设备，结果将始终放在与张量相同的设备上。</p><p>默认情况下，不支持跨GPU操作，唯一的例外是<code>copy_()</code>。 除非启用对等存储器访问，否则对分布不同设备上的张量任何启动操作的尝试都将会引发错误。</p><p>下面你可以找到一个展示如下的小例子：</p><pre><code>x = torch.cuda.FloatTensor(1)# x.get_device() == 0y = torch.FloatTensor(1).cuda()# y.get_device() == 0with torch.cuda.device(1):    # allocates a tensor on GPU 1    a = torch.cuda.FloatTensor(1)    # transfers a tensor from CPU to GPU 1    b = torch.FloatTensor(1).cuda()    # a.get_device() == b.get_device() == 1    c = a + b    # c.get_device() == 1    z = x + y    # z.get_device() == 0    # even within a context, you can give a GPU id to the .cuda call    d = torch.randn(2).cuda(2)    # d.get_device() == 2</code></pre><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="使用固定的内存缓冲区"><a href="#使用固定的内存缓冲区" class="headerlink" title="使用固定的内存缓冲区"></a>使用固定的内存缓冲区</h3><p>当副本来自固定（页锁）内存时，主机到GPU的复制速度要快很多。CPU张量和存储开放了一个<code>pin_memory()</code>方法，它返回该对象的副本，而它的数据放在固定区域中。</p><p>另外，一旦固定了张量或存储，就可以使用异步的GPU副本。只需传递一个额外的<code>async=True</code>参数到<code>cuda()</code>的调用。这可以用于将数据传输与计算重叠。</p><p>通过将<code>pin_memory=True</code>传递给其构造函数，可以使<code>DataLoader</code>将batch返回到固定内存中。</p><h3 id="使用-nn-DataParallel-替代-multiprocessing"><a href="#使用-nn-DataParallel-替代-multiprocessing" class="headerlink" title="使用 nn.DataParallel 替代 multiprocessing"></a>使用 nn.DataParallel 替代 multiprocessing</h3><p>大多数涉及批量输入和多个GPU的情况应默认使用<code>DataParallel</code>来使用多个GPU。尽管有GIL的存在，单个python进程也可能使多个GPU饱和。</p><p>从0.1.9版本开始，大量的GPU(8+)可能未被充分利用。然而，这是一个已知的问题，也正在积极开发。和往常一样，测试你的用例吧。</p><p>调用<code>multiprocessing</code>来利用CUDA模型存在重要的注意事项；使用具有多处理功能的CUDA模型有重要的注意事项; 除非就是需要谨慎地满足数据处理需求，否则您的程序很可能会出现错误或未定义的行为。</p><h1 id="扩展PyTorch"><a href="#扩展PyTorch" class="headerlink" title="扩展PyTorch"></a>扩展PyTorch</h1><h2 id="扩展-torch-autograd"><a href="#扩展-torch-autograd" class="headerlink" title="扩展 torch.autograd"></a>扩展 torch.autograd</h2><p>如果你想要添加一个新的 <code>Operation</code> 到<code>autograd</code>的话，你的<code>Operation</code>需要继承 <code>class Function</code>。<code>autograd</code>使用<code>Function</code>计算结果和梯度，同时编码 <code>operation</code>的历史。每个新的 <code>operation(function)</code> 都需要实现三个方法：</p><ul><li><p><code>__init__ (optional)</code> - 如果你的<code>operation</code>包含非<code>Variable</code>参数，那么就将其作为<code>__init__</code>的参数传入到<code>operation</code>中。例如：<code>AddConstant Function</code>加一个常数，<code>Transpose Function</code>需要指定哪两个维度需要交换。如果你的<code>operation</code>不需要额外的参数，你可以忽略<code>__init__</code>。</p></li><li><p><code>forward()</code> - 在里面写执行此<code>operation</code>的代码。可以有任意数量的参数。如果你对某些参数指定了默认值，则这些参数是可传可不传的。记住：<code>forward()</code>的参数只能是<code>Variable</code>。函数的返回值既可以是 <code>Variable</code>也可以是<code>Variables</code>的<code>tuple</code>。同时，请参考 <code>Function</code>[function]的 <code>doc</code>，查阅有哪些 方法是只能在<code>forward</code>中调用的。</p></li><li><p><code>backward()</code> - 梯度计算公式。 参数的个数和<code>forward</code>返回值的个数一样，每个参数代表传回到此<code>operation</code>的梯度. <code>backward()</code>的返回值的个数应该和此<code>operation</code>输入的个数一样，每个返回值对应了输入值的梯度。如果<code>operation</code>的输入不需要梯度，或者不可导，你可以返回<code>None</code>。 如果<code>forward()</code>存在可选参数，你可以返回比输入更多的梯度，只是返回的是<code>None</code>。</p></li></ul><p>下面是 <code>Linear</code> 的实现代码：</p><pre><code># Inherit from Functionclass Linear(Function):    # bias is an optional argument    def forward(self, input, weight, bias=None):        self.save_for_backward(input, weight, bias)        output = input.mm(weight.t())        if bias is not None:            output += bias.unsqueeze(0).expand_as(output)        return output    # This function has only a single output, so it gets only one gradient    def backward(self, grad_output):        # This is a pattern that is very convenient - at the top of backward        # unpack saved_tensors and initialize all gradients w.r.t. inputs to        # None. Thanks to the fact that additional trailing Nones are        # ignored, the return statement is simple even when the function has        # optional inputs.        input, weight, bias = self.saved_tensors        grad_input = grad_weight = grad_bias = None        # These needs_input_grad checks are optional and there only to        # improve efficiency. If you want to make your code simpler, you can        # skip them. Returning gradients for inputs that don't require it is        # not an error.        if self.needs_input_grad[0]:            grad_input = grad_output.mm(weight)        if self.needs_input_grad[1]:            grad_weight = grad_output.t().mm(input)        if bias is not None and self.needs_input_grad[2]:            grad_bias = grad_output.sum(0).squeeze(0)        return grad_input, grad_weight, grad_bias</code></pre><p>现在，为了可以更简单的使用自定义的<code>operation</code>，我们建议将其用一个简单的 <code>helper function</code> 包装起来。 functions:</p><pre><code>def linear(input, weight, bias=None):    # First braces create a Function object. Any arguments given here    # will be passed to __init__. Second braces will invoke the __call__    # operator, that will then use forward() to compute the result and    # return it.    return Linear()(input, weight, bias)</code></pre><p>你可能想知道你刚刚实现的 <code>backward</code>方法是否正确的计算了梯度。你可以使用 小的有限的差分进行数值估计。</p><pre><code>from torch.autograd import gradcheck# gradchek takes a tuple of tensor as input, check if your gradient# evaluated with these tensors are close enough to numerical# approximations and returns True if they all verify this condition.input = (Variable(torch.randn(20,20).double(), requires_grad=True),)test = gradcheck.gradcheck(Linear(), input, eps=1e-6, atol=1e-4)print(test)</code></pre><h2 id="扩展-torch-nn"><a href="#扩展-torch-nn" class="headerlink" title="扩展 torch.nn"></a>扩展 torch.nn</h2><p><code>nn</code> 包含两种接口 - <code>modules</code>和他们的<code>functional</code>版本。通过这两个接口，你都可以扩展<code>nn</code>。但是我们建议，在扩展<code>layer</code>的时候，使用<code>modules</code>， 因为<code>modules</code>保存着参数和<code>buffer</code>。如果不需要参数的话，那么建议使用<code>functional</code>(激活函数，pooling，这些都不需要参数)。</p><p>增加一个<code>operation</code>的 <code>functional</code>版本已经在上面一节介绍完毕。</p><p>增加一个模块(<code>module</code>)。 由于<code>nn</code>重度使用<code>autograd</code>。所以，添加一个新<code>module</code>需要实现一个 用来执行 计算 和 计算梯度 的<code>Function</code>。从现在开始，假定我们想要实现一个<code>Linear module</code>，记得之前我们已经实现了一个<code>Linear Funciton</code>。 只需要很少的代码就可以完成这个工作。 现在，我们需要实现两个方法：</p><ul><li><p><code>__init__ (optional)</code> - 输入参数，例如<code>kernel sizes</code>, <code>numbers of features</code>, 等等。同时初始化 <code>parameters</code>和<code>buffers</code>。</p></li><li><p><code>forward()</code> - 实例化一个执行<code>operation</code>的<code>Function</code>，使用它执行<code>operation</code>。和<code>functional wrapper(上面实现的那个简单的wrapper)</code>十分类似。</p></li></ul><p><code>Linear module</code>实现代码:</p><pre><code>class Linear(nn.Module):    def __init__(self, input_features, output_features, bias=True):        self.input_features = input_features        self.output_features = output_features        # nn.Parameter is a special kind of Variable, that will get        # automatically registered as Module's parameter once it's assigned        # as an attribute. Parameters and buffers need to be registered, or        # they won't appear in .parameters() (doesn't apply to buffers), and        # won't be converted when e.g. .cuda() is called. You can use        # .register_buffer() to register buffers.        # nn.Parameters can never be volatile and, different than Variables,        # they require gradients by default.        self.weight = nn.Parameter(torch.Tensor(input_features, output_features))        if bias:            self.bias = nn.Parameter(torch.Tensor(output_features))        else:            # You should always register all possible parameters, but the            # optional ones can be None if you want.            self.register_parameter('bias', None)        # Not a very smart way to initialize weights        self.weight.data.uniform_(-0.1, 0.1)        if bias is not None:            self.bias.data.uniform_(-0.1, 0.1)    def forward(self, input):        # See the autograd section for explanation of what happens here.        return Linear()(input, self.weight, self.bias)        #注意这个Linear是之前实现过的Linear</code></pre><h2 id="编写自定义C扩展"><a href="#编写自定义C扩展" class="headerlink" title="编写自定义C扩展"></a>编写自定义<code>C</code>扩展</h2><p>Coming soon. For now you can find an example at <a href="https://github.com/pytorch/extension-ffi" target="_blank" rel="noopener">GitHub</a>.</p><h1 id="多进程最佳实践"><a href="#多进程最佳实践" class="headerlink" title="多进程最佳实践"></a>多进程最佳实践</h1><p><code>torch.multiprocessing</code>是Python<code>multiprocessing</code>的替代品。它支持完全相同的操作，但扩展了它以便通过<code>multiprocessing.Queue</code>发送的所有张量将其数据移动到共享内存中，并且只会向其他进程发送一个句柄。</p><blockquote><p><strong>Note</strong></p><p>当<code>Variable</code>发送到另一个进程时，<code>Variable.data</code>和<code>Variable.grad.data</code>都将被共享。</p></blockquote><p>这允许实现各种训练方法，如Hogwild，A3C或需要异步操作的任何其他方法。</p><h2 id="共享CUDA张量"><a href="#共享CUDA张量" class="headerlink" title="共享CUDA张量"></a>共享CUDA张量</h2><p>仅在Python 3中使用<code>spawn</code>或<code>forkserver</code>启动方法才支持在进程之间共享CUDA张量。Python 2中的<code>multiprocessing</code>只能使用<code>fork</code>创建子进程，并且不被CUDA运行时所支持。</p><blockquote><p><strong>Warning</strong></p><p>CUDA API要求导出到其他进程的分配，只要它们被使用就要一直保持有效。您应该小心，确保您共享的CUDA张量只要有必要就不要超出范围。这不是共享模型参数的问题，但传递其他类型的数据应该小心。注意，此限制不适用于共享CPU内存。</p></blockquote><h2 id="最佳实践和提示"><a href="#最佳实践和提示" class="headerlink" title="最佳实践和提示"></a>最佳实践和提示</h2><h3 id="避免和抵制死锁"><a href="#避免和抵制死锁" class="headerlink" title="避免和抵制死锁"></a>避免和抵制死锁</h3><p>当一个新进程被产生时，有很多事情可能会出错，最常见的死锁原因是后台线程。如果有任何线程持有锁或导入模块，并且<code>fork</code>被调用，则子进程很可能处于损坏的状态，并以不同的方式死锁或失败。注意，即使您没有，Python内置的库也可能会这样做 —— 不需要看得比<code>multiprocessing</code>更远。<code>multiprocessing.Queue</code>实际上是一个非常复杂的类，它产生用于序列化，发送和接收对象的多个线程，它们也可能引起上述问题。如果您发现自己处于这种情况，请尝试使用<code>multiprocessing.queues.SimpleQueue</code>，这不会使用任何其他线程。</p><p>我们正在竭尽全力把它设计得更简单，并确保这些死锁不会发生，但有些事情无法控制。如果有任何问题您无法一时无法解决，请尝试在论坛上提出，我们将看看是否可以解决问题。</p><h3 id="重用经过队列的缓冲区"><a href="#重用经过队列的缓冲区" class="headerlink" title="重用经过队列的缓冲区"></a>重用经过队列的缓冲区</h3><p>记住每次将<code>Tensor</code>放入<code>multiprocessing.Queue</code>时，必须将其移动到共享内存中。如果它已经被共享，它是一个无效的操作，否则会产生一个额外的内存副本，这会减缓整个进程。即使你有一个进程池来发送数据到一个进程，使它返回缓冲区 —— 这几乎是免费的，并且允许你在发送下一个batch时避免产生副本。</p><h3 id="异步多进程训练（例如Hogwild）"><a href="#异步多进程训练（例如Hogwild）" class="headerlink" title="异步多进程训练（例如Hogwild）"></a>异步多进程训练（例如Hogwild）</h3><p>使用<code>torch.multiprocessing</code>，可以异步地训练模型，参数可以一直共享，也可以定期同步。在第一种情况下，我们建议发送整个模型对象，而在后者中，我们建议只发送<code>state_dict()</code>。</p><p>我们建议使用<code>multiprocessing.Queue</code>来在进程之间传递各种PyTorch对象。例如， 当使用fork启动方法时，可能会继承共享内存中的张量和存储器，但这是非常容易出错的，应谨慎使用，而且只能由高级用户使用。队列虽然有时是一个较不优雅的解决方案，但基本上能在所有情况下正常工作。</p><blockquote><p><strong>Warning</strong> 你应该注意有关全局语句，它们没有被<code>if __name__ == '__main__'</code>保护。如果使用与<code>fork</code>不同的启动方法，则它们将在所有子进程中执行。</p></blockquote><h4 id="Hogwild"><a href="#Hogwild" class="headerlink" title="Hogwild"></a>Hogwild</h4><p>在<a href="https://github.com/pytorch/examples/tree/master/mnist_hogwild" target="_blank" rel="noopener">examples repository</a>中可以找到具体的Hogwild实现，可以展示代码的整体结构。下面也有一个小例子：</p><pre><code>import torch.multiprocessing as mpfrom model import MyModeldef train(model):    # Construct data_loader, optimizer, etc.    for data, labels in data_loader:        optimizer.zero_grad()        loss_fn(model(data), labels).backward()        optimizer.step()  # This will update the shared parametersif __name__ == '__main__':    num_processes = 4    model = MyModel()    # NOTE: this is required for the ``fork`` method to work    model.share_memory()    processes = []    for rank in range(num_processes):        p = mp.Process(target=train, args=(model,))        p.start()        processes.append(p)    for p in processes:      p.join()</code></pre><h1 id="序列化语义"><a href="#序列化语义" class="headerlink" title="序列化语义"></a>序列化语义</h1><h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="保存模型的推荐方法"><a href="#保存模型的推荐方法" class="headerlink" title="保存模型的推荐方法"></a>保存模型的推荐方法</h3><p>这主要有两种方法序列化和恢复模型。</p><p>第一种（推荐）只保存和加载模型参数：</p><pre><code>torch.save(the_model.state_dict(), PATH)</code></pre><p>然后：</p><pre><code>the_model = TheModelClass(*args, **kwargs)the_model.load_state_dict(torch.load(PATH))</code></pre><p>第二种保存和加载整个模型：</p><pre><code>torch.save(the_model, PATH)</code></pre><p>然后：</p><pre><code>the_model = torch.load(PATH)</code></pre><p>然而，在这种情况下，序列化的数据被绑定到特定的类和固定的目录结构，所以当在其他项目中使用时，或者在一些严重的重构器之后它可能会以各种方式break。</p><h1 id="torch"><a href="#torch" class="headerlink" title="torch"></a>torch</h1><p>包 <code>torch</code> 包含了多维张量的数据结构以及基于其上的多种数学操作。另外，它也提供了多种工具，其中一些可以更有效地对张量和任意类型进行序列化。</p><p>它有CUDA 的对应实现，可以在NVIDIA GPU上进行张量运算(计算能力&gt;=2.0)。</p><h1 id="张量-Tensors"><a href="#张量-Tensors" class="headerlink" title="张量 Tensors"></a>张量 Tensors</h1><p><strong>torch.is_tensor</strong><a href="http://pytorch.org/docs/_modules/torch.html#is_tensor" target="_blank" rel="noopener">[source]</a></p><pre><code>torch.is_tensor(obj)</code></pre><p>如果<em>obj</em> 是一个pytorch张量，则返回True</p><ul><li>参数： obj (Object) – 判断对象</li></ul><hr><p><strong>torch.is_storage</strong> <a href="http://pytorch.org/docs/_modules/torch.html#is_storage" target="_blank" rel="noopener">[source]</a></p><pre><code>torch.is_storage(obj)</code></pre><p>如何<em>obj</em> 是一个pytorch storage对象，则返回True</p><ul><li>参数： input (Object) – 判断对象</li></ul><hr><p><strong>torch.</strong>set_default_tensor_type****<a href="http://pytorch.org/docs/_modules/torch.html#set_default_tensor_type" target="_blank" rel="noopener">[source]</a></p><pre><code>torch.set_default_tensor_type(t)</code></pre><hr><p><strong>torch.numel</strong></p><pre><code>torch.numel(input)-&gt;int</code></pre><p>返回<code>input</code> 张量中的元素个数</p><ul><li>参数: input (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener"><em>Tensor</em></a>) – 输入张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; a = torch.randn(1,2,3,4,5)&gt;&gt;&gt; torch.numel(a)120&gt;&gt;&gt; a = torch.zeros(4,4)&gt;&gt;&gt; torch.numel(a)16</code></pre><hr><p><strong>torch.set_printoptions</strong><a href="http://pytorch.org/docs/_modules/torch/_tensor_str.html#set_printoptions" target="_blank" rel="noopener">[source]</a></p><pre><code>torch.set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, profile=None)</code></pre><p>设置打印选项。 完全参考自<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.set_printoptions.html" target="_blank" rel="noopener"> Numpy</a>。</p><p>参数:</p><ul><li>precision – 浮点数输出的精度位数 (默认为8 )</li><li>threshold – 阈值，触发汇总显示而不是完全显示(repr)的数组元素的总数 （默认为1000）</li><li>edgeitems – 汇总显示中，每维（轴）两端显示的项数（默认值为3）</li><li>linewidth – 用于插入行间隔的每行字符数（默认为80）。Thresholded matricies will ignore this parameter.</li><li>profile – pretty打印的完全默认值。 可以覆盖上述所有选项 (默认为short, full)</li></ul><h2 id="创建操作-Creation-Ops"><a href="#创建操作-Creation-Ops" class="headerlink" title="创建操作 Creation Ops"></a>创建操作 Creation Ops</h2><p><strong>torch.eye</strong></p><pre><code>torch.eye(n, m=None, out=None)</code></pre><p>返回一个2维张量，对角线位置全1，其它位置全0</p><p>参数:</p><ul><li>n (<a href="https://docs.python.org/2/library/functions.html#int" target="_blank" rel="noopener">int</a> ) – 行数</li><li>m (<a href="https://docs.python.org/2/library/functions.html#int" target="_blank" rel="noopener">int</a>, <em>optional</em>) – 列数.如果为None,则默认为<em>n</em></li><li>out (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener"><em>Tensor</em></a>, <em>optinal</em>) - Output tensor</li></ul><p>返回值: 对角线位置全1，其它位置全0的2维张量</p><p>返回值类型: <a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener">Tensor</a></p><p>例子:</p><pre><code>&gt;&gt;&gt; torch.eye(3) 1  0  0 0  1  0 0  0  1[torch.FloatTensor of size 3x3]</code></pre><hr><p><strong>from_numpy</strong></p><pre><code>torch.from_numpy(ndarray) → Tensor</code></pre><p>Numpy桥，将<code>numpy.ndarray</code> 转换为pytorch的 <code>Tensor</code>。 返回的张量tensor和numpy的ndarray共享同一内存空间。修改一个会导致另外一个也被修改。返回的张量不能改变大小。</p><p>例子:</p><pre><code>&gt;&gt;&gt; a = numpy.array([1, 2, 3])&gt;&gt;&gt; t = torch.from_numpy(a)&gt;&gt;&gt; ttorch.LongTensor([1, 2, 3])&gt;&gt;&gt; t[0] = -1&gt;&gt;&gt; aarray([-1,  2,  3])</code></pre><p><strong>torch.linspace</strong></p><pre><code>torch.linspace(start, end, steps=100, out=None) → Tensor</code></pre><p>返回一个1维张量，包含在区间<code>start</code> 和 <code>end</code> 上均匀间隔的<code>steps</code>个点。 输出1维张量的长度为<code>steps</code>。</p><p>参数:</p><ul><li>start (float) – 序列的起始点</li><li>end (float) – 序列的最终值</li><li>steps (int) – 在<code>start</code> 和 <code>end</code>间生成的样本数</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; torch.linspace(3, 10, steps=5)  3.0000  4.7500  6.5000  8.2500 10.0000[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.linspace(-10, 10, steps=5)-10 -5  0  5 10[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.linspace(start=-10, end=10, steps=5)-10 -5  0  5 10[torch.FloatTensor of size 5]</code></pre><hr><p><strong>torch.logspace</strong></p><pre><code>torch.logspace(start, end, steps=100, out=None) → Tensor</code></pre><p>返回一个1维张量，包含在区间 10的start次方到10的end次方上以对数刻度均匀间隔的<code>steps</code>个点。 输出1维张量的长度为<code>steps</code>。</p><p>参数:</p><ul><li>start (float) – 序列的起始点</li><li>end (float) – 序列的最终值</li><li>steps (int) – 在<code>start</code> 和 <code>end</code>间生成的样本数</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; torch.logspace(start=-10, end=10, steps=5) 1.0000e-10 1.0000e-05 1.0000e+00 1.0000e+05 1.0000e+10[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.logspace(start=0.1, end=1.0, steps=5)  1.2589  2.1135  3.5481  5.9566 10.0000[torch.FloatTensor of size 5]</code></pre><p><strong>torch.ones</strong></p><pre><code>torch.ones(*sizes, out=None) → Tensor</code></pre><p>返回一个全为1 的张量，形状由可变参数<code>sizes</code>定义。</p><p>参数:</p><ul><li>sizes (int…) – 整数序列，定义了输出形状</li><li>out (Tensor, optional) – 结果张量 例子:</li></ul><pre><code>&gt;&gt;&gt; torch.ones(2, 3) 1  1  1 1  1  1[torch.FloatTensor of size 2x3]&gt;&gt;&gt; torch.ones(5) 1 1 1 1 1[torch.FloatTensor of size 5]</code></pre><hr><p><strong>torch.rand</strong></p><pre><code>torch.rand(*sizes, out=None) → Tensor</code></pre><p>返回一个张量，包含了从区间[0,1)的均匀分布中抽取的一组随机数，形状由可变参数<code>sizes</code> 定义。</p><p>参数:</p><ul><li>sizes (int…) – 整数序列，定义了输出形状</li><li>out (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener"><em>Tensor</em></a>, <em>optinal</em>) - 结果张量 例子：</li></ul><pre><code>&gt;&gt;&gt; torch.rand(4) 0.9193 0.3347 0.3232 0.7715[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.rand(2, 3) 0.5010  0.5140  0.0719 0.1435  0.5636  0.0538[torch.FloatTensor of size 2x3]</code></pre><hr><p><strong>torch.randn</strong></p><pre><code>torch.randn(*sizes, out=None) → Tensor</code></pre><p>返回一个张量，包含了从标准正态分布(均值为0，方差为 1，即高斯白噪声)中抽取一组随机数，形状由可变参数<code>sizes</code>定义。 参数:</p><ul><li>sizes (int…) – 整数序列，定义了输出形状</li><li>out (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener"><em>Tensor</em></a>, <em>optinal</em>) - 结果张量</li></ul><p>例子：:</p><pre><code>&gt;&gt;&gt; torch.randn(4)-0.1145 0.0094-1.1717 0.9846[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.randn(2, 3) 1.4339  0.3351 -1.0999 1.5458 -0.9643 -0.3558[torch.FloatTensor of size 2x3]</code></pre><hr><p><strong>torch.randperm</strong></p><pre><code>torch.randperm(n, out=None) → LongTensor</code></pre><p>给定参数<code>n</code>，返回一个从<code>0</code> 到<code>n -1</code> 的随机整数排列。</p><p>参数:</p><ul><li>n (int) – 上边界(不包含)</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.randperm(4) 2 1 3 0[torch.LongTensor of size 4]</code></pre><hr><p><strong>torch.arange</strong></p><pre><code>torch.arange(start, end, step=1, out=None) → Tensor</code></pre><p>参数:</p><ul><li>start (float) – 序列的起始点</li><li>end (float) – 序列的终止点</li><li>step (float) – 相邻点的间隔大小</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.arange(1, 4) 1 2 3[torch.FloatTensor of size 3]&gt;&gt;&gt; torch.arange(1, 2.5, 0.5) 1.0000 1.5000 2.0000[torch.FloatTensor of size 3]</code></pre><hr><p><strong>torch.range</strong></p><pre><code>torch.range(start, end, step=1, out=None) → Tensor</code></pre><p><strong>警告</strong>：建议使用函数 <code>torch.arange()</code></p><p>参数:</p><ul><li>start (float) – 序列的起始点</li><li>end (float) – 序列的最终值</li><li>step (int) – 相邻点的间隔大小</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.range(1, 4) 1 2 3 4[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.range(1, 4, 0.5) 1.0000 1.5000 2.0000 2.5000 3.0000 3.5000 4.0000[torch.FloatTensor of size 7]</code></pre><hr><p><strong>torch.zeros</strong></p><pre><code>torch.zeros(*sizes, out=None) → Tensor</code></pre><p>返回一个全为标量 0 的张量，形状由可变参数<code>sizes</code> 定义。</p><p>参数:</p><ul><li>sizes (int…) – 整数序列，定义了输出形状</li><li>out (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener">Tensor</a>, <em>optional</em>) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.zeros(2, 3) 0  0  0 0  0  0[torch.FloatTensor of size 2x3]&gt;&gt;&gt; torch.zeros(5) 0 0 0 0 0[torch.FloatTensor of size 5]</code></pre><hr><h2 id="索引-切片-连接-换位Indexing-Slicing-Joining-Mutating-Ops"><a href="#索引-切片-连接-换位Indexing-Slicing-Joining-Mutating-Ops" class="headerlink" title="索引,切片,连接,换位Indexing, Slicing, Joining, Mutating Ops"></a>索引,切片,连接,换位Indexing, Slicing, Joining, Mutating Ops</h2><h3 id="torch-cat"><a href="#torch-cat" class="headerlink" title="torch.cat"></a>torch.cat</h3><pre><code>torch.cat(inputs, dimension=0) → Tensor</code></pre><p>在给定维度上对输入的张量序列<code>seq</code> 进行连接操作。</p><p><code>torch.cat()</code>可以看做 <code>torch.split()</code> 和 <code>torch.chunk()</code>的反操作。 <code>cat()</code> 函数可以通过下面例子更好的理解。</p><p>参数:</p><ul><li>inputs (<em>sequence of Tensors</em>) – 可以是任意相同Tensor 类型的python 序列</li><li>dimension (<em>int</em>, <em>optional</em>) – 沿着此维连接张量序列。</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.randn(2, 3)&gt;&gt;&gt; x 0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735[torch.FloatTensor of size 2x3]&gt;&gt;&gt; torch.cat((x, x, x), 0) 0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735 0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735 0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735[torch.FloatTensor of size 6x3]&gt;&gt;&gt; torch.cat((x, x, x), 1) 0.5983 -0.0341  2.4918  0.5983 -0.0341  2.4918  0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735  1.5981 -0.5265 -0.8735  1.5981 -0.5265 -0.8735[torch.FloatTensor of size 2x9]</code></pre><h3 id="torch-chunk"><a href="#torch-chunk" class="headerlink" title="torch.chunk"></a>torch.chunk</h3><pre><code>torch.chunk(tensor, chunks, dim=0)</code></pre><p>在给定维度(轴)上将输入张量进行分块儿。</p><p>参数:</p><ul><li>tensor (Tensor) – 待分块的输入张量</li><li>chunks (int) – 分块的个数</li><li>dim (int) – 沿着此维度进行分块</li></ul><h3 id="torch-gather"><a href="#torch-gather" class="headerlink" title="torch.gather"></a>torch.gather</h3><pre><code>torch.gather(input, dim, index, out=None) → Tensor</code></pre><p>沿给定轴<code>dim</code>，将输入索引张量<code>index</code>指定位置的值进行聚合。</p><p>对一个3维张量，输出可以定义为：</p><pre><code>out[i][j][k] = tensor[index[i][j][k]][j][k]  # dim=0out[i][j][k] = tensor[i][index[i][j][k]][k]  # dim=1out[i][j][k] = tensor[i][j][index[i][j][k]]  # dim=3</code></pre><p>例子：</p><pre><code>&gt;&gt;&gt; t = torch.Tensor([[1,2],[3,4]])&gt;&gt;&gt; torch.gather(t, 1, torch.LongTensor([[0,0],[1,0]])) 1  1 4  3[torch.FloatTensor of size 2x2]</code></pre><p>参数:</p><ul><li>input (Tensor) – 源张量</li><li>dim (int) – 索引的轴</li><li>index (LongTensor) – 聚合元素的下标</li><li>out (Tensor, optional) – 目标张量</li></ul><h3 id="torch-index-select"><a href="#torch-index-select" class="headerlink" title="torch.index_select"></a>torch.index_select</h3><pre><code>torch.index_select(input, dim, index, out=None) → Tensor</code></pre><p>沿着指定维度对输入进行切片，取<code>index</code>中指定的相应项(<code>index</code>为一个LongTensor)，然后返回到一个新的张量， 返回的张量与原始张量_Tensor_有相同的维度(在指定轴上)。</p><p>注意： 返回的张量不与原始张量共享内存空间。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 索引的轴</li><li>index (LongTensor) – 包含索引下标的一维张量</li><li>out (Tensor, optional) – 目标张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.randn(3, 4)&gt;&gt;&gt; x 1.2045  2.4084  0.4001  1.1372 0.5596  1.5677  0.6219 -0.7954 1.3635 -1.2313 -0.5414 -1.8478[torch.FloatTensor of size 3x4]&gt;&gt;&gt; indices = torch.LongTensor([0, 2])&gt;&gt;&gt; torch.index_select(x, 0, indices) 1.2045  2.4084  0.4001  1.1372 1.3635 -1.2313 -0.5414 -1.8478[torch.FloatTensor of size 2x4]&gt;&gt;&gt; torch.index_select(x, 1, indices) 1.2045  0.4001 0.5596  0.6219 1.3635 -0.5414[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-masked-select"><a href="#torch-masked-select" class="headerlink" title="torch.masked_select"></a>torch.masked_select</h3><pre><code>torch.masked_select(input, mask, out=None) → Tensor</code></pre><p>根据掩码张量<code>mask</code>中的二元值，取输入张量中的指定项( <code>mask</code>为一个 <em>ByteTensor</em>)，将取值返回到一个新的1D张量，</p><p>张量 <code>mask</code>须跟<code>input</code>张量有相同数量的元素数目，但形状或维度不需要相同。 注意： 返回的张量不与原始张量共享内存空间。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>mask (ByteTensor) – 掩码张量，包含了二元索引值</li><li>out (Tensor, optional) – 目标张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.randn(3, 4)&gt;&gt;&gt; x 1.2045  2.4084  0.4001  1.1372 0.5596  1.5677  0.6219 -0.7954 1.3635 -1.2313 -0.5414 -1.8478[torch.FloatTensor of size 3x4]&gt;&gt;&gt; indices = torch.LongTensor([0, 2])&gt;&gt;&gt; torch.index_select(x, 0, indices) 1.2045  2.4084  0.4001  1.1372 1.3635 -1.2313 -0.5414 -1.8478[torch.FloatTensor of size 2x4]&gt;&gt;&gt; torch.index_select(x, 1, indices) 1.2045  0.4001 0.5596  0.6219 1.3635 -0.5414[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-nonzero"><a href="#torch-nonzero" class="headerlink" title="torch.nonzero"></a>torch.nonzero</h3><pre><code>torch.nonzero(input, out=None) → LongTensor</code></pre><p>返回一个包含输入<code>input</code>中非零元素索引的张量。输出张量中的每行包含输入中非零元素的索引。</p><p>如果输入<code>input</code>有<code>n</code>维，则输出的索引张量<code>output</code>的形状为 z x n, 这里 z 是输入张量<code>input</code>中所有非零元素的个数。</p><p>参数:</p><ul><li>input (Tensor) – 源张量</li><li>out (LongTensor, optional) – 包含索引值的结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.nonzero(torch.Tensor([1, 1, 1, 0, 1])) 0 1 2 4[torch.LongTensor of size 4x1]&gt;&gt;&gt; torch.nonzero(torch.Tensor([[0.6, 0.0, 0.0, 0.0],...                             [0.0, 0.4, 0.0, 0.0],...                             [0.0, 0.0, 1.2, 0.0],...                             [0.0, 0.0, 0.0,-0.4]])) 0  0 1  1 2  2 3  3[torch.LongTensor of size 4x2]</code></pre><h3 id="torch-split"><a href="#torch-split" class="headerlink" title="torch.split"></a>torch.split</h3><pre><code>torch.split(tensor, split_size, dim=0)</code></pre><p>将输入张量分割成相等形状的chunks（如果可分）。 如果沿指定维的张量形状大小不能被<code>split_size</code> 整分， 则最后一个分块会小于其它分块。</p><p>参数:</p><ul><li>tensor (Tensor) – 待分割张量</li><li>split_size (int) – 单个分块的形状大小</li><li>dim (int) – 沿着此维进行分割</li></ul><h3 id="torch-squeeze"><a href="#torch-squeeze" class="headerlink" title="torch.squeeze"></a>torch.squeeze</h3><pre><code>torch.squeeze(input, dim=None, out=None)</code></pre><p>注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int, optional) – 如果给定，则<code>input</code>只会在给定维度挤压</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.zeros(2,1,2,1,2)&gt;&gt;&gt; x.size()(2L, 1L, 2L, 1L, 2L)&gt;&gt;&gt; y = torch.squeeze(x)&gt;&gt;&gt; y.size()(2L, 2L, 2L)&gt;&gt;&gt; y = torch.squeeze(x, 0)&gt;&gt;&gt; y.size()(2L, 1L, 2L, 1L, 2L)&gt;&gt;&gt; y = torch.squeeze(x, 1)&gt;&gt;&gt; y.size()(2L, 2L, 1L, 2L)</code></pre><h3 id="torch-stack-source"><a href="#torch-stack-source" class="headerlink" title="torch.stack[source]"></a>torch.stack<a href="http://pytorch.org/docs/_modules/torch/functional.html#stack" target="_blank" rel="noopener">[source]</a></h3><pre><code>torch.stack(sequence, dim=0)</code></pre><p>沿着一个新维度对输入张量序列进行连接。 序列中所有的张量都应该为相同形状。</p><p>参数:</p><ul><li>sqequence (Sequence) – 待连接的张量序列</li><li>dim (int) – 插入的维度。必须介于 0 与 待连接的张量序列数之间。</li></ul><h3 id="torch-t"><a href="#torch-t" class="headerlink" title="torch.t"></a>torch.t</h3><pre><code>torch.t(input, out=None) → Tensor</code></pre><p>输入一个矩阵（2维张量），并转置0, 1维。 可以被视为函数<code>transpose(input, 0, 1)</code>的简写函数。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 结果张量</li></ul><pre><code>&gt;&gt;&gt; x = torch.randn(2, 3)&gt;&gt;&gt; x 0.4834  0.6907  1.3417-0.1300  0.5295  0.2321[torch.FloatTensor of size 2x3]&gt;&gt;&gt; torch.t(x) 0.4834 -0.1300 0.6907  0.5295 1.3417  0.2321[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-transpose"><a href="#torch-transpose" class="headerlink" title="torch.transpose"></a>torch.transpose</h3><pre><code>torch.transpose(input, dim0, dim1, out=None) → Tensor</code></pre><p>返回输入矩阵<code>input</code>的转置。交换维度<code>dim0</code>和<code>dim1</code>。 输出张量与输入张量共享内存，所以改变其中一个会导致另外一个也被修改。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>dim0 (int) – 转置的第一维</li><li>dim1 (int) – 转置的第二维</li></ul><pre><code>&gt;&gt;&gt; x = torch.randn(2, 3)&gt;&gt;&gt; x 0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735[torch.FloatTensor of size 2x3]&gt;&gt;&gt; torch.transpose(x, 0, 1) 0.5983  1.5981-0.0341 -0.5265 2.4918 -0.8735[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-unbind"><a href="#torch-unbind" class="headerlink" title="torch.unbind"></a>torch.unbind</h3><pre><code>torch.unbind(tensor, dim=0)[source]</code></pre><p>移除指定维后，返回一个元组，包含了沿着指定维切片后的各个切片</p><p>参数:</p><ul><li>tensor (Tensor) – 输入张量</li><li>dim (int) – 删除的维度</li></ul><h3 id="torch-unsqueeze"><a href="#torch-unsqueeze" class="headerlink" title="torch.unsqueeze"></a>torch.unsqueeze</h3><pre><code>torch.unsqueeze(input, dim, out=None)</code></pre><p>返回一个新的张量，对输入的制定位置插入维度 1</p><p>注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。</p><p>参数:</p><ul><li>tensor (Tensor) – 输入张量</li><li>dim (int) – 插入维度的索引</li><li>out (Tensor, optional) – 结果张量</li></ul><pre><code>&gt;&gt;&gt; x = torch.Tensor([1, 2, 3, 4])&gt;&gt;&gt; torch.unsqueeze(x, 0) 1  2  3  4[torch.FloatTensor of size 1x4]&gt;&gt;&gt; torch.unsqueeze(x, 1) 1 2 3 4[torch.FloatTensor of size 4x1]</code></pre><hr><h2 id="随机抽样-Random-sampling"><a href="#随机抽样-Random-sampling" class="headerlink" title="随机抽样 Random sampling"></a>随机抽样 Random sampling</h2><h3 id="torch-manual-seed"><a href="#torch-manual-seed" class="headerlink" title="torch.manual_seed"></a>torch.manual_seed</h3><pre><code>torch.manual_seed(seed)</code></pre><p>设定生成随机数的种子，并返回一个 <em>torch._C.Generator</em> 对象.</p><p>参数: seed (int or long) – 种子.</p><h3 id="torch-initial-seed"><a href="#torch-initial-seed" class="headerlink" title="torch.initial_seed"></a>torch.initial_seed</h3><pre><code>torch.initial_seed()</code></pre><p>返回生成随机数的原始种子值（python long）。</p><h3 id="torch-get-rng-state"><a href="#torch-get-rng-state" class="headerlink" title="torch.get_rng_state"></a>torch.get_rng_state</h3><pre><code>torch.get_rng_state()[source]</code></pre><p>返回随机生成器状态(<em>ByteTensor</em>)</p><h3 id="torch-set-rng-state"><a href="#torch-set-rng-state" class="headerlink" title="torch.set_rng_state"></a>torch.set_rng_state</h3><pre><code>torch.set_rng_state(new_state)[source]</code></pre><p>设定随机生成器状态 参数: new_state (torch.ByteTensor) – 期望的状态</p><h3 id="torch-default-generator"><a href="#torch-default-generator" class="headerlink" title="torch.default_generator"></a>torch.default_generator</h3><pre><code>torch.default_generator = &lt;torch._C.Generator object&gt;</code></pre><h3 id="torch-bernoulli"><a href="#torch-bernoulli" class="headerlink" title="torch.bernoulli"></a>torch.bernoulli</h3><pre><code>torch.bernoulli(input, out=None) → Tensor</code></pre><p>从伯努利分布中抽取二元随机数(0 或者 1)。</p><p>输出张量的第<em><code>i</code></em>个元素值， 将会以输入张量的第<em><code>i</code></em>个概率值等于<code>1</code>。</p><p>返回值将会是与输入相同大小的张量，每个值为0或者1 参数:</p><ul><li>input (Tensor) – 输入为伯努利分布的概率值</li><li>out (Tensor, optional) – 输出张量(可选)</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.Tensor(3, 3).uniform_(0, 1) # generate a uniform random matrix with range [0, 1]&gt;&gt;&gt; a 0.7544  0.8140  0.9842 0.5282  0.0595  0.6445 0.1925  0.9553  0.9732[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.bernoulli(a) 1  1  1 0  0  1 0  1  1[torch.FloatTensor of size 3x3]&gt;&gt;&gt; a = torch.ones(3, 3) # probability of drawing "1" is 1&gt;&gt;&gt; torch.bernoulli(a) 1  1  1 1  1  1 1  1  1[torch.FloatTensor of size 3x3]&gt;&gt;&gt; a = torch.zeros(3, 3) # probability of drawing "1" is 0&gt;&gt;&gt; torch.bernoulli(a) 0  0  0 0  0  0 0  0  0[torch.FloatTensor of size 3x3]</code></pre><hr><h3 id="torch-multinomial"><a href="#torch-multinomial" class="headerlink" title="torch.multinomial"></a>torch.multinomial</h3><pre><code>torch.multinomial(input, num_samples,replacement=False, out=None) → LongTensor</code></pre><p>返回一个张量，每行包含从<code>input</code>相应行中定义的多项分布中抽取的<code>num_samples</code>个样本。</p><p><strong>[注意]</strong>:输入<code>input</code>每行的值不需要总和为1 (这里我们用来做权重)，但是必须非负且总和不能为0。</p><p>当抽取样本时，依次从左到右排列(第一个样本对应第一列)。</p><p>如果参数<code>replacement</code> 为 <em>True</em>, 则样本抽取可以重复。否则，一个样本在每行不能被重复抽取。</p><p>参数<code>num_samples</code>必须小于<code>input</code>长度(即，<code>input</code>的列数，如果是<code>input</code>是一个矩阵)。</p><p>参数:</p><ul><li>input (Tensor) – 包含概率值的张量</li><li>num_samples (int) – 抽取的样本数</li><li>replacement (bool, optional) – 布尔值，决定是否能重复抽取</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; weights = torch.Tensor([0, 10, 3, 0]) # create a Tensor of weights&gt;&gt;&gt; torch.multinomial(weights, 4) 1 2 0 0[torch.LongTensor of size 4]&gt;&gt;&gt; torch.multinomial(weights, 4, replacement=True) 1 2 1 2[torch.LongTensor of size 4]</code></pre><h3 id="torch-normal"><a href="#torch-normal" class="headerlink" title="torch.normal()"></a>torch.normal()</h3><pre><code>torch.normal(means, std, out=None)</code></pre><p>返回一个张量，包含从给定参数<code>means</code>,<code>std</code>的离散正态分布中抽取随机数。 均值<code>means</code>是一个张量，包含每个输出元素相关的正态分布的均值。 <code>std</code>是一个张量，包含每个输出元素相关的正态分布的标准差。 均值和标准差的形状不须匹配，但每个张量的元素个数须相同。</p><p>参数:</p><ul><li>means (Tensor) – 均值</li><li>std (Tensor) – 标准差</li><li>out (Tensor) – 可选的输出张量</li></ul><pre><code>torch.normal(means=torch.arange(1, 11), std=torch.arange(1, 0, -0.1)) 1.5104 1.6955 2.4895 4.9185 4.9895 6.9155 7.3683 8.1836 8.7164 9.8916[torch.FloatTensor of size 10]</code></pre><pre><code>torch.normal(mean=0.0, std, out=None)</code></pre><p>与上面函数类似，所有抽取的样本共享均值。</p><p>参数:</p><ul><li>means (Tensor,optional) – 所有分布均值</li><li>std (Tensor) – 每个元素的标准差</li><li>out (Tensor) – 可选的输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; torch.normal(mean=0.5, std=torch.arange(1, 6))  0.5723  0.0871 -0.3783 -2.5689 10.7893[torch.FloatTensor of size 5]</code></pre><pre><code>torch.normal(means, std=1.0, out=None)</code></pre><p>与上面函数类似，所有抽取的样本共享标准差。</p><p>参数:</p><ul><li>means (Tensor) – 每个元素的均值</li><li>std (float, optional) – 所有分布的标准差</li><li>out (Tensor) – 可选的输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; torch.normal(means=torch.arange(1, 6)) 1.1681 2.8884 3.7718 2.5616 4.2500[torch.FloatTensor of size 5]</code></pre><hr><h2 id="序列化-Serialization"><a href="#序列化-Serialization" class="headerlink" title="序列化 Serialization"></a>序列化 Serialization</h2><h3 id="torch-saves-source"><a href="#torch-saves-source" class="headerlink" title="torch.saves[source]"></a>torch.saves<a href="http://pytorch.org/docs/_modules/torch/serialization.html#save" target="_blank" rel="noopener">[source]</a></h3><pre><code>torch.save(obj, f, pickle_module=&lt;module 'pickle' from '/home/jenkins/miniconda/lib/python3.5/pickle.py'&gt;, pickle_protocol=2)</code></pre><p>保存一个对象到一个硬盘文件上 参考: <a href="http://pytorch.org/docs/notes/serialization.html#recommend-saving-models" target="_blank" rel="noopener">Recommended approach for saving a model</a> 参数：</p><ul><li>obj – 保存对象</li><li>f － 类文件对象 (返回文件描述符)或一个保存文件名的字符串</li><li>pickle_module – 用于pickling元数据和对象的模块</li><li>pickle_protocol – 指定pickle protocal 可以覆盖默认参数</li></ul><h3 id="torch-load-source"><a href="#torch-load-source" class="headerlink" title="torch.load[source]"></a>torch.load<a href="http://pytorch.org/docs/_modules/torch/serialization.html#load" target="_blank" rel="noopener">[source]</a></h3><pre><code>torch.load(f, map_location=None, pickle_module=&lt;module 'pickle' from '/home/jenkins/miniconda/lib/python3.5/pickle.py'&gt;)</code></pre><p>从磁盘文件中读取一个通过<code>torch.save()</code>保存的对象。 <code>torch.load()</code> 可通过参数<code>map_location</code> 动态地进行内存重映射，使其能从不动设备中读取文件。一般调用时，需两个参数: storage 和 location tag. 返回不同地址中的storage，或着返回None (此时地址可以通过默认方法进行解析). 如果这个参数是字典的话，意味着其是从文件的地址标记到当前系统的地址标记的映射。 默认情况下， location tags中 “cpu”对应host tensors，‘cuda:device_id’ (e.g. ‘cuda:2’) 对应cuda tensors。 用户可以通过register_package进行扩展，使用自己定义的标记和反序列化方法。</p><p>参数:</p><ul><li>f – 类文件对象 (返回文件描述符)或一个保存文件名的字符串</li><li>map_location – 一个函数或字典规定如何remap存储位置</li><li>pickle_module – 用于unpickling元数据和对象的模块 (必须匹配序列化文件时的pickle_module )</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; torch.load('tensors.pt')# Load all tensors onto the CPU&gt;&gt;&gt; torch.load('tensors.pt', map_location=lambda storage, loc: storage)# Map tensors from GPU 1 to GPU 0&gt;&gt;&gt; torch.load('tensors.pt', map_location={'cuda:1':'cuda:0'})</code></pre><h2 id="并行化-Parallelism"><a href="#并行化-Parallelism" class="headerlink" title="并行化 Parallelism"></a>并行化 Parallelism</h2><h3 id="torch-get-num-threads"><a href="#torch-get-num-threads" class="headerlink" title="torch.get_num_threads"></a>torch.get_num_threads</h3><pre><code>torch.get_num_threads() → int</code></pre><p>获得用于并行化CPU操作的OpenMP线程数</p><hr><h3 id="torch-set-num-threads"><a href="#torch-set-num-threads" class="headerlink" title="torch.set_num_threads"></a>torch.set_num_threads</h3><pre><code>torch.set_num_threads(int)</code></pre><p>设定用于并行化CPU操作的OpenMP线程数</p><h1 id="数学操作Math-operations"><a href="#数学操作Math-operations" class="headerlink" title="数学操作Math operations"></a>数学操作Math operations</h1><h2 id="Pointwise-Ops"><a href="#Pointwise-Ops" class="headerlink" title="Pointwise Ops"></a>Pointwise Ops</h2><h3 id="torch-abs"><a href="#torch-abs" class="headerlink" title="torch.abs"></a>torch.abs</h3><pre><code>torch.abs(input, out=None) → Tensor</code></pre><p>计算输入张量的每个元素绝对值</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.abs(torch.FloatTensor([-1, -2, 3]))FloatTensor([1, 2, 3])</code></pre><h3 id="torch-acos-input-out-None-→-Tensor"><a href="#torch-acos-input-out-None-→-Tensor" class="headerlink" title="torch.acos(input, out=None) → Tensor"></a>torch.acos(input, out=None) → Tensor</h3><pre><code>torch.acos(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入张量每个元素的反余弦。 参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener">Tensor</a>, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.acos(a) 2.2608 1.2956 1.1075    nan[torch.FloatTensor of size 4]</code></pre><h3 id="torch-add"><a href="#torch-add" class="headerlink" title="torch.add()"></a>torch.add()</h3><pre><code>torch.add(input, value, out=None)</code></pre><p>如果输入<code>input</code>是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>value</code>取整数、实数皆可。】</p><ul><li>input (Tensor) – 输入张量</li><li>value (Number) – 添加到输入每个元素的数</li><li>out (Tensor, optional) – 结果张量</li></ul><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 0.4050-1.2227 1.8688-0.4185[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.add(a, 20) 20.4050 18.7773 21.8688 19.5815[torch.FloatTensor of size 4]</code></pre><pre><code>torch.add(input, value=1, other, out=None)</code></pre><p>两个张量 <code>input</code> and <code>other</code>的尺寸不需要匹配，但元素总数必须一样。</p><p><strong>注意</strong> :当两个张量形状不匹配时，输入张量的形状会作为输出张量的尺寸。</p><p>如果<code>other</code>是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>value</code>取整数、实数皆可。】</p><p>参数:</p><ul><li>input (Tensor) – 第一个输入张量</li><li>value (Number) – 用于第二个张量的尺寸因子</li><li>other (Tensor) – 第二个输入张量</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; import torch&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.9310 2.0330 0.0852-0.2941[torch.FloatTensor of size 4]&gt;&gt;&gt; b = torch.randn(2, 2)&gt;&gt;&gt; b 1.0663  0.2544-0.1513  0.0749[torch.FloatTensor of size 2x2]&gt;&gt;&gt; torch.add(a, 10, b) 9.7322 4.5770-1.4279 0.4552[torch.FloatTensor of size 4]</code></pre><h3 id="torch-addcdiv"><a href="#torch-addcdiv" class="headerlink" title="torch.addcdiv"></a>torch.addcdiv</h3><pre><code>torch.addcdiv(tensor, value=1, tensor1, tensor2, out=None) → Tensor</code></pre><p>用<code>tensor2</code>对<code>tensor1</code>逐元素相除，然后乘以标量值<code>value</code> 并加到<code>tensor</code>。</p><p>张量的形状不需要匹配，但元素数量必须一致。</p><p>如果输入是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。</p><p>参数：</p><ul><li>tensor (Tensor) – 张量，对 tensor1 ./ tensor 进行相加</li><li>value (Number, optional) – 标量，对 tensor1 ./ tensor2 进行相乘</li><li>tensor1 (Tensor) – 张量，作为被除数(分子)</li><li>tensor2 (Tensor) –张量，作为除数(分母)</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; t = torch.randn(2, 3)&gt;&gt;&gt; t1 = torch.randn(1, 6)&gt;&gt;&gt; t2 = torch.randn(6, 1)&gt;&gt;&gt; torch.addcdiv(t, 0.1, t1, t2) 0.0122 -0.0188 -0.2354 0.7396 -1.5721  1.2878[torch.FloatTensor of size 2x3]</code></pre><h3 id="torch-addcmul"><a href="#torch-addcmul" class="headerlink" title="torch.addcmul"></a>torch.addcmul</h3><pre><code>torch.addcmul(tensor, value=1, tensor1, tensor2, out=None) → Tensor</code></pre><p>用<code>tensor2</code>对<code>tensor1</code>逐元素相乘，并对结果乘以标量值<code>value</code>然后加到<code>tensor</code>。 张量的形状不需要匹配，但元素数量必须一致。 如果输入是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。</p><p>参数：</p><ul><li>tensor (Tensor) – 张量，对tensor1 ./ tensor 进行相加</li><li>value (Number, optional) – 标量，对 tensor1 . tensor2 进行相乘</li><li>tensor1 (Tensor) – 张量，作为乘子1</li><li>tensor2 (Tensor) –张量，作为乘子2</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; t = torch.randn(2, 3)&gt;&gt;&gt; t1 = torch.randn(1, 6)&gt;&gt;&gt; t2 = torch.randn(6, 1)&gt;&gt;&gt; torch.addcmul(t, 0.1, t1, t2) 0.0122 -0.0188 -0.2354 0.7396 -1.5721  1.2878[torch.FloatTensor of size 2x3]</code></pre><h3 id="torch-asin"><a href="#torch-asin" class="headerlink" title="torch.asin"></a>torch.asin</h3><pre><code>torch.asin(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的反正弦函数</p><p>参数：</p><ul><li>tensor (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.asin(a)-0.6900 0.2752 0.4633    nan[torch.FloatTensor of size 4]</code></pre><h3 id="torch-atan"><a href="#torch-atan" class="headerlink" title="torch.atan"></a>torch.atan</h3><pre><code>torch.atan(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的反正切函数</p><p>参数：</p><ul><li>tensor (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.atan(a)-0.5669 0.2653 0.4203 0.9196[torch.FloatTensor of size 4]</code></pre><h3 id="torch-atan2"><a href="#torch-atan2" class="headerlink" title="torch.atan2"></a>torch.atan2</h3><pre><code>torch.atan2(input1, input2, out=None) → Tensor</code></pre><p>返回一个新张量，包含两个输入张量<code>input1</code>和<code>input2</code>的反正切函数</p><p>参数：</p><ul><li>input1 (Tensor) – 第一个输入张量</li><li>input2 (Tensor) – 第二个输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.atan2(a, torch.randn(4))-2.4167 2.9755 0.9363 1.6613[torch.FloatTensor of size 4]</code></pre><h3 id="torch-ceil"><a href="#torch-ceil" class="headerlink" title="torch.ceil"></a>torch.ceil</h3><pre><code>torch.ceil(input, out=None) → Tensor</code></pre><p>天井函数，对输入<code>input</code>张量每个元素向上取整, 即取不小于每个元素的最小整数，并返回结果到输出。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.ceil(a) 2 1-0-0[torch.FloatTensor of size 4]</code></pre><h3 id="torch-clamp"><a href="#torch-clamp" class="headerlink" title="torch.clamp"></a>torch.clamp</h3><pre><code>torch.clamp(input, min, max, out=None) → Tensor</code></pre><p>操作定义如下：</p><pre><code>      | min, if x_i &lt; miny_i = | x_i, if min &lt;= x_i &lt;= max      | max, if x_i &gt; max</code></pre><p>如果输入是FloatTensor or DoubleTensor类型，则参数<code>min</code> <code>max</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>min</code>， <code>max</code>取整数、实数皆可。】</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>min (Number) – 限制范围下限</li><li>max (Number) – 限制范围上限</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.clamp(a, min=-0.5, max=0.5) 0.5000 0.3912-0.5000-0.5000[torch.FloatTensor of size 4]</code></pre><pre><code>torch.clamp(input, *, min, out=None) → Tensor</code></pre><p>将输入<code>input</code>张量每个元素的限制到不小于<code>min</code> ，并返回结果到一个新张量。</p><p>如果输入是FloatTensor or DoubleTensor类型，则参数 <code>min</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>min</code>取整数、实数皆可。】</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>value (Number) – 限制范围下限</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.clamp(a, min=0.5) 1.3869 0.5000 0.5000 0.5000[torch.FloatTensor of size 4]</code></pre><pre><code>torch.clamp(input, *, max, out=None) → Tensor</code></pre><p>将输入<code>input</code>张量每个元素的限制到不大于<code>max</code> ，并返回结果到一个新张量。</p><p>如果输入是FloatTensor or DoubleTensor类型，则参数 <code>max</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>max</code>取整数、实数皆可。】</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>value (Number) – 限制范围上限</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.clamp(a, max=0.5) 0.5000 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]</code></pre><h3 id="torch-cos"><a href="#torch-cos" class="headerlink" title="torch.cos"></a>torch.cos</h3><pre><code>torch.cos(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的余弦。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.cos(a) 0.8041 0.9633 0.9018 0.2557[torch.FloatTensor of size 4]</code></pre><h3 id="torch-cosh"><a href="#torch-cosh" class="headerlink" title="torch.cosh"></a>torch.cosh</h3><pre><code>torch.cosh(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的双曲余弦。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.cosh(a) 1.2095 1.0372 1.1015 1.9917[torch.FloatTensor of size 4]</code></pre><h3 id="torch-div"><a href="#torch-div" class="headerlink" title="torch.div()"></a>torch.div()</h3><pre><code>torch.div(input, value, out=None)</code></pre><p>如果输入是FloatTensor or DoubleTensor类型，则参数 <code>value</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>value</code>取整数、实数皆可。】</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>value (Number) – 除数</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(5)&gt;&gt;&gt; a-0.6147-1.1237-0.1604-0.6853 0.1063[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.div(a, 0.5)-1.2294-2.2474-0.3208-1.3706 0.2126[torch.FloatTensor of size 5]</code></pre><pre><code>torch.div(input, other, out=None)</code></pre><p>两张量形状不须匹配，但元素数须一致。</p><p>注意：当形状不匹配时，<code>input</code>的形状作为输出张量的形状。</p><p>参数：</p><ul><li>input (Tensor) – 张量(分子)</li><li>other (Tensor) – 张量(分母)</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4,4)&gt;&gt;&gt; a-0.1810  0.4017  0.2863 -0.1013 0.6183  2.0696  0.9012 -1.5933 0.5679  0.4743 -0.0117 -0.1266-0.1213  0.9629  0.2682  1.5968[torch.FloatTensor of size 4x4]&gt;&gt;&gt; b = torch.randn(8, 2)&gt;&gt;&gt; b 0.8774  0.7650 0.8866  1.4805-0.6490  1.1172 1.4259 -0.8146 1.4633 -0.1228 0.4643 -0.6029 0.3492  1.5270 1.6103 -0.6291[torch.FloatTensor of size 8x2]&gt;&gt;&gt; torch.div(a, b)-0.2062  0.5251  0.3229 -0.0684-0.9528  1.8525  0.6320  1.9559 0.3881 -3.8625 -0.0253  0.2099-0.3473  0.6306  0.1666 -2.5381[torch.FloatTensor of size 4x4]</code></pre><h3 id="torch-exp"><a href="#torch-exp" class="headerlink" title="torch.exp"></a>torch.exp</h3><pre><code>torch.exp(tensor, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的指数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><pre><code>&gt;&gt;&gt; torch.exp(torch.Tensor([0, math.log(2)]))torch.FloatTensor([1, 2])</code></pre><h3 id="torch-floor"><a href="#torch-floor" class="headerlink" title="torch.floor"></a>torch.floor</h3><pre><code>torch.floor(input, out=None) → Tensor</code></pre><p>床函数: 返回一个新张量，包含输入<code>input</code>张量每个元素的floor，即不小于元素的最大整数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.floor(a) 1 0-1-1[torch.FloatTensor of size 4]</code></pre><h3 id="torch-fmod"><a href="#torch-fmod" class="headerlink" title="torch.fmod"></a>torch.fmod</h3><pre><code>torch.fmod(input, divisor, out=None) → Tensor</code></pre><p>计算除法余数。 除数与被除数可能同时含有整数和浮点数。此时，余数的正负与被除数相同。</p><p>参数： - input (Tensor) – 被除数 - divisor (Tensor or float) – 除数，一个数或与被除数相同类型的张量 - out (Tensor, optional) – 输出张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.fmod(torch.Tensor([-3, -2, -1, 1, 2, 3]), 2)torch.FloatTensor([-1, -0, -1, 1, 0, 1])&gt;&gt;&gt; torch.fmod(torch.Tensor([1, 2, 3, 4, 5]), 1.5)torch.FloatTensor([1.0, 0.5, 0.0, 1.0, 0.5])</code></pre><p>参考: <a href="http://pytorch.org/docs/torch.html#torch.remainder" target="_blank" rel="noopener"><code>torch.remainder()</code></a>, 计算逐元素余数， 相当于python 中的 % 操作符。</p><h3 id="torch-frac"><a href="#torch-frac" class="headerlink" title="torch.frac"></a>torch.frac</h3><pre><code>torch.frac(tensor, out=None) → Tensor</code></pre><p>返回每个元素的分数部分。</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.frac(torch.Tensor([1, 2.5, -3.2])torch.FloatTensor([0, 0.5, -0.2])</code></pre><h3 id="torch-lerp"><a href="#torch-lerp" class="headerlink" title="torch.lerp"></a>torch.lerp</h3><pre><code>torch.lerp(start, end, weight, out=None)</code></pre><p>参数：</p><ul><li>start (Tensor) – 起始点张量</li><li>end (Tensor) – 终止点张量</li><li>weight (float) – 插值公式的weight</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; start = torch.arange(1, 5)&gt;&gt;&gt; end = torch.Tensor(4).fill_(10)&gt;&gt;&gt; start 1 2 3 4[torch.FloatTensor of size 4]&gt;&gt;&gt; end 10 10 10 10[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.lerp(start, end, 0.5) 5.5000 6.0000 6.5000 7.0000[torch.FloatTensor of size 4]</code></pre><h3 id="torch-log"><a href="#torch-log" class="headerlink" title="torch.log"></a>torch.log</h3><pre><code>torch.log(input, out=None) → Tensor</code></pre><p>计算<code>input</code> 的自然对数</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(5)&gt;&gt;&gt; a-0.4183 0.3722-0.3091 0.4149 0.5857[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.log(a)    nan-0.9883    nan-0.8797-0.5349[torch.FloatTensor of size 5]</code></pre><h3 id="torch-log1p"><a href="#torch-log1p" class="headerlink" title="torch.log1p"></a>torch.log1p</h3><pre><code>torch.log1p(input, out=None) → Tensor</code></pre><p>注意：对值比较小的输入，此函数比<code>torch.log()</code>更准确。</p><p>如果输入是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(5)&gt;&gt;&gt; a-0.4183 0.3722-0.3091 0.4149 0.5857[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.log1p(a)-0.5418 0.3164-0.3697 0.3471 0.4611[torch.FloatTensor of size 5]</code></pre><h3 id="torch-mul"><a href="#torch-mul" class="headerlink" title="torch.mul"></a>torch.mul</h3><pre><code>torch.mul(input, value, out=None)</code></pre><p>如果输入是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>value</code>取整数、实数皆可。】</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>value (Number) – 乘到每个元素的数</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(3)&gt;&gt;&gt; a-0.9374-0.5254-0.6069[torch.FloatTensor of size 3]&gt;&gt;&gt; torch.mul(a, 100)-93.7411-52.5374-60.6908[torch.FloatTensor of size 3]</code></pre><pre><code>torch.mul(input, other, out=None)</code></pre><p>两计算张量形状不须匹配，但总元素数须一致。 <strong>注意</strong>：当形状不匹配时，<code>input</code>的形状作为输入张量的形状。</p><p>参数：</p><ul><li>input (Tensor) – 第一个相乘张量</li><li>other (Tensor) – 第二个相乘张量</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4,4)&gt;&gt;&gt; a-0.7280  0.0598 -1.4327 -0.5825-0.1427 -0.0690  0.0821 -0.3270-0.9241  0.5110  0.4070 -1.1188-0.8308  0.7426 -0.6240 -1.1582[torch.FloatTensor of size 4x4]&gt;&gt;&gt; b = torch.randn(2, 8)&gt;&gt;&gt; b 0.0430 -1.0775  0.6015  1.1647 -0.6549  0.0308 -0.1670  1.0742-1.2593  0.0292 -0.0849  0.4530  1.2404 -0.4659 -0.1840  0.5974[torch.FloatTensor of size 2x8]&gt;&gt;&gt; torch.mul(a, b)-0.0313 -0.0645 -0.8618 -0.6784 0.0934 -0.0021 -0.0137 -0.3513 1.1638  0.0149 -0.0346 -0.5068-1.0304 -0.3460  0.1148 -0.6919[torch.FloatTensor of size 4x4]</code></pre><h3 id="torch-neg"><a href="#torch-neg" class="headerlink" title="torch.neg"></a>torch.neg</h3><pre><code>torch.neg(input, out=None) → Tensor</code></pre><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(5)&gt;&gt;&gt; a-0.4430 1.1690-0.8836-0.4565 0.2968[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.neg(a) 0.4430-1.1690 0.8836 0.4565-0.2968[torch.FloatTensor of size 5]</code></pre><h3 id="torch-pow"><a href="#torch-pow" class="headerlink" title="torch.pow"></a>torch.pow</h3><pre><code>torch.pow(input, exponent, out=None)</code></pre><p>对输入<code>input</code>的按元素求<code>exponent</code>次幂值，并返回结果张量。 幂值<code>exponent</code> 可以为单一 <code>float</code> 数或者与<code>input</code>相同元素数的张量。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>exponent (float or Tensor) – 幂值</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.5274-0.8232-2.1128 1.7558[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.pow(a, 2) 0.2781 0.6776 4.4640 3.0829[torch.FloatTensor of size 4]&gt;&gt;&gt; exp = torch.arange(1, 5)&gt;&gt;&gt; a = torch.arange(1, 5)&gt;&gt;&gt; a 1 2 3 4[torch.FloatTensor of size 4]&gt;&gt;&gt; exp 1 2 3 4[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.pow(a, exp)   1   4  27 256[torch.FloatTensor of size 4]</code></pre><pre><code>torch.pow(base, input, out=None)</code></pre><p><code>base</code> 为标量浮点值,<code>input</code>为张量， 返回的输出张量 <code>out</code> 与输入张量相同形状。</p><p>参数：</p><ul><li>base (float) – 标量值，指数的底</li><li>input ( Tensor) – 幂值</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; exp = torch.arange(1, 5)&gt;&gt;&gt; base = 2&gt;&gt;&gt; torch.pow(base, exp)  2  4  8 16[torch.FloatTensor of size 4]</code></pre><h3 id="torch-reciprocal"><a href="#torch-reciprocal" class="headerlink" title="torch.reciprocal"></a>torch.reciprocal</h3><pre><code>torch.reciprocal(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的倒数，即 1.0/x。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.reciprocal(a) 0.7210 2.5565-1.1583-1.8289[torch.FloatTensor of size 4]</code></pre><h3 id="torch-remainder"><a href="#torch-remainder" class="headerlink" title="torch.remainder"></a>torch.remainder</h3><pre><code>torch.remainder(input, divisor, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的除法余数。 除数与被除数可能同时包含整数或浮点数。余数与除数有相同的符号。</p><p>参数：</p><ul><li>input (Tensor) – 被除数</li><li>divisor (Tensor or float) – 除数，一个数或者与除数相同大小的张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.remainder(torch.Tensor([-3, -2, -1, 1, 2, 3]), 2)torch.FloatTensor([1, 0, 1, 1, 0, 1])&gt;&gt;&gt; torch.remainder(torch.Tensor([1, 2, 3, 4, 5]), 1.5)torch.FloatTensor([1.0, 0.5, 0.0, 1.0, 0.5])</code></pre><p><strong>参考</strong>: 函数<code>torch.fmod()</code> 同样可以计算除法余数，相当于 C 的 库函数<code>fmod()</code></p><h3 id="torch-round"><a href="#torch-round" class="headerlink" title="torch.round"></a>torch.round</h3><pre><code>torch.round(input, out=None) → Tensor</code></pre><p>返回一个新张量，将输入<code>input</code>张量每个元素舍入到最近的整数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.2290 1.3409-0.5662-0.0899[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.round(a) 1 1-1-0[torch.FloatTensor of size 4]</code></pre><h3 id="torch-rsqrt"><a href="#torch-rsqrt" class="headerlink" title="torch.rsqrt"></a>torch.rsqrt</h3><pre><code>torch.rsqrt(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的平方根倒数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.2290 1.3409-0.5662-0.0899[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.rsqrt(a) 0.9020 0.8636    nan    nan[torch.FloatTensor of size 4]</code></pre><h3 id="torch-sigmoid"><a href="#torch-sigmoid" class="headerlink" title="torch.sigmoid"></a>torch.sigmoid</h3><pre><code>torch.sigmoid(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的sigmoid值。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.4972 1.3512 0.1056-0.2650[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.sigmoid(a) 0.3782 0.7943 0.5264 0.4341[torch.FloatTensor of size 4]</code></pre><h3 id="torch-sign"><a href="#torch-sign" class="headerlink" title="torch.sign"></a>torch.sign</h3><pre><code>torch.sign(input, out=None) → Tensor</code></pre><p>符号函数：返回一个新张量，包含输入<code>input</code>张量每个元素的正负。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.sign(a)-1 1 1 1[torch.FloatTensor of size 4]</code></pre><h3 id="torch-sin"><a href="#torch-sin" class="headerlink" title="torch.sin"></a>torch.sin</h3><pre><code>torch.sin(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的正弦。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.sin(a)-0.5944 0.2684 0.4322 0.9667[torch.FloatTensor of size 4]</code></pre><h3 id="torch-sinh"><a href="#torch-sinh" class="headerlink" title="torch.sinh"></a>torch.sinh</h3><pre><code>torch.sinh(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的双曲正弦。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.sinh(a)-0.6804 0.2751 0.4619 1.7225[torch.FloatTensor of size 4]</code></pre><h3 id="torch-sqrt"><a href="#torch-sqrt" class="headerlink" title="torch.sqrt"></a>torch.sqrt</h3><pre><code>torch.sqrt(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的平方根。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.2290 1.3409-0.5662-0.0899[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.sqrt(a) 1.1086 1.1580    nan    nan[torch.FloatTensor of size 4]</code></pre><h3 id="torch-tan"><a href="#torch-tan" class="headerlink" title="torch.tan"></a>torch.tan</h3><pre><code>torch.tan(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的正切。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.tan(a)-0.7392 0.2786 0.4792 3.7801[torch.FloatTensor of size 4]</code></pre><h3 id="torch-tanh"><a href="#torch-tanh" class="headerlink" title="torch.tanh"></a>torch.tanh</h3><pre><code>torch.tanh(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的双曲正切。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.tanh(a)-0.5625 0.2653 0.4193 0.8648[torch.FloatTensor of size 4]</code></pre><h3 id="torch-trunc"><a href="#torch-trunc" class="headerlink" title="torch.trunc"></a>torch.trunc</h3><pre><code>torch.trunc(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的截断值(标量x的截断值是最接近其的整数，其比x更接近零。简而言之，有符号数的小数部分被舍弃)。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.4972 1.3512 0.1056-0.2650[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.trunc(a)-0 1 0-0[torch.FloatTensor of size 4]</code></pre><h2 id="Reduction-Ops"><a href="#Reduction-Ops" class="headerlink" title="Reduction Ops"></a>Reduction Ops</h2><h3 id="torch-cumprod"><a href="#torch-cumprod" class="headerlink" title="torch.cumprod"></a>torch.cumprod</h3><pre><code>torch.cumprod(input, dim, out=None) → Tensor</code></pre><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 累积积操作的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(10)&gt;&gt;&gt; a 1.1148 1.8423 1.4143-0.4403 1.2859-1.2514-0.4748 1.1735-1.6332-0.4272[torch.FloatTensor of size 10]&gt;&gt;&gt; torch.cumprod(a, dim=0) 1.1148 2.0537 2.9045-1.2788-1.6444 2.0578-0.9770-1.1466 1.8726-0.8000[torch.FloatTensor of size 10]&gt;&gt;&gt; a[5] = 0.0&gt;&gt;&gt; torch.cumprod(a, dim=0) 1.1148 2.0537 2.9045-1.2788-1.6444-0.0000 0.0000 0.0000-0.0000 0.0000[torch.FloatTensor of size 10]</code></pre><h3 id="torch-cumsum"><a href="#torch-cumsum" class="headerlink" title="torch.cumsum"></a>torch.cumsum</h3><pre><code>torch.cumsum(input, dim, out=None) → Tensor</code></pre><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 累积和操作的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(10)&gt;&gt;&gt; a-0.6039-0.2214-0.3705-0.0169 1.3415-0.1230 0.9719 0.6081-0.1286 1.0947[torch.FloatTensor of size 10]&gt;&gt;&gt; torch.cumsum(a, dim=0)-0.6039-0.8253-1.1958-1.2127 0.1288 0.0058 0.9777 1.5858 1.4572 2.5519[torch.FloatTensor of size 10]</code></pre><hr><h3 id="torch-dist"><a href="#torch-dist" class="headerlink" title="torch.dist"></a>torch.dist</h3><pre><code>torch.dist(input, other, p=2, out=None) → Tensor</code></pre><p>返回 (<code>input</code> - <code>other</code>) 的 <code>p</code>范数 。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>other (Tensor) – 右侧输入张量</li><li>p (float, optional) – 所计算的范数</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.randn(4)&gt;&gt;&gt; x 0.2505-0.4571-0.3733 0.7807[torch.FloatTensor of size 4]&gt;&gt;&gt; y = torch.randn(4)&gt;&gt;&gt; y 0.7782-0.5185 1.4106-2.4063[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.dist(x, y, 3.5)3.302832063224223&gt;&gt;&gt; torch.dist(x, y, 3)3.3677282206393286&gt;&gt;&gt; torch.dist(x, y, 0)inf&gt;&gt;&gt; torch.dist(x, y, 1)5.560028076171875</code></pre><h3 id="torch-mean"><a href="#torch-mean" class="headerlink" title="torch.mean"></a>torch.mean</h3><pre><code>torch.mean(input) → float</code></pre><p>返回输入张量所有元素的均值。</p><p>参数： input (Tensor) – 输入张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a-0.2946 -0.9143  2.1809[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.mean(a)0.32398951053619385</code></pre><pre><code>torch.mean(input, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维度<code>dim</code>上每行的均值。</p><p>输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – the dimension to reduce</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 4)&gt;&gt;&gt; a-1.2738 -0.3058  0.1230 -1.9615 0.8771 -0.5430 -0.9233  0.9879 1.4107  0.0317 -0.6823  0.2255-1.3854  0.4953 -0.2160  0.2435[torch.FloatTensor of size 4x4]&gt;&gt;&gt; torch.mean(a, 1)-0.8545 0.0997 0.2464-0.2157[torch.FloatTensor of size 4x1]</code></pre><h3 id="torch-median"><a href="#torch-median" class="headerlink" title="torch.median"></a>torch.median</h3><pre><code>torch.median(input, dim=-1, values=None, indices=None) -&gt; (Tensor, LongTensor)</code></pre><p>返回输入张量给定维度每行的中位数，同时返回一个包含中位数的索引的<code>LongTensor</code>。</p><p><code>dim</code>值默认为输入张量的最后一维。 输出形状与输入相同，除了给定维度上为1.</p><p><em>注意</em>: 这个函数还没有在<code>torch.cuda.Tensor</code>中定义</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 缩减的维度</li><li>values (Tensor, optional) – 结果张量</li><li>indices (Tensor, optional) – 返回的索引结果张量</li></ul><pre><code>&gt;&gt;&gt; a -0.6891 -0.6662 0.2697  0.7412 0.5254 -0.7402 0.5528 -0.2399[torch.FloatTensor of size 4x2]&gt;&gt;&gt; a = torch.randn(4, 5)&gt;&gt;&gt; a 0.4056 -0.3372  1.0973 -2.4884  0.4334 2.1336  0.3841  0.1404 -0.1821 -0.7646-0.2403  1.3975 -2.0068  0.1298  0.0212-1.5371 -0.7257 -0.4871 -0.2359 -1.1724[torch.FloatTensor of size 4x5]&gt;&gt;&gt; torch.median(a, 1)( 0.4056 0.1404 0.0212-0.7257[torch.FloatTensor of size 4x1], 0 2 4 1[torch.LongTensor of size 4x1])</code></pre><h3 id="torch-mode"><a href="#torch-mode" class="headerlink" title="torch.mode"></a>torch.mode</h3><pre><code>torch.mode(input, dim=-1, values=None, indices=None) -&gt; (Tensor, LongTensor)</code></pre><p>返回给定维<code>dim</code>上，每行的众数值。 同时返回一个<code>LongTensor</code>，包含众数职的索引。<code>dim</code>值默认为输入张量的最后一维。</p><p>输出形状与输入相同，除了给定维度上为1.</p><p><em>注意</em>: 这个函数还没有在<code>torch.cuda.Tensor</code>中定义</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 缩减的维度</li><li>values (Tensor, optional) – 结果张量</li><li>indices (Tensor, optional) – 返回的索引张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a -0.6891 -0.6662 0.2697  0.7412 0.5254 -0.7402 0.5528 -0.2399[torch.FloatTensor of size 4x2]&gt;&gt;&gt; a = torch.randn(4, 5)&gt;&gt;&gt; a 0.4056 -0.3372  1.0973 -2.4884  0.4334 2.1336  0.3841  0.1404 -0.1821 -0.7646-0.2403  1.3975 -2.0068  0.1298  0.0212-1.5371 -0.7257 -0.4871 -0.2359 -1.1724[torch.FloatTensor of size 4x5]&gt;&gt;&gt; torch.mode(a, 1)(-2.4884-0.7646-2.0068-1.5371[torch.FloatTensor of size 4x1], 3 4 2 0[torch.LongTensor of size 4x1])</code></pre><h3 id="torch-norm"><a href="#torch-norm" class="headerlink" title="torch.norm"></a>torch.norm</h3><pre><code>torch.norm(input, p=2) → float</code></pre><p>返回输入张量<code>input</code> 的p 范数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>p (float,optional) – 范数计算中的幂指数值</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a-0.4376 -0.5328  0.9547[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.norm(a, 3)1.0338925067372466</code></pre><pre><code>torch.norm(input, p, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维<code>dim</code> 上每行的p 范数。 输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>p (float) – 范数计算中的幂指数值</li><li>dim (int) – 缩减的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 2)&gt;&gt;&gt; a-0.6891 -0.6662 0.2697  0.7412 0.5254 -0.7402 0.5528 -0.2399[torch.FloatTensor of size 4x2]&gt;&gt;&gt; torch.norm(a, 2, 1) 0.9585 0.7888 0.9077 0.6026[torch.FloatTensor of size 4x1]&gt;&gt;&gt; torch.norm(a, 0, 1) 2 2 2 2[torch.FloatTensor of size 4x1]</code></pre><h3 id="torch-prod"><a href="#torch-prod" class="headerlink" title="torch.prod"></a>torch.prod</h3><pre><code>torch.prod(input) → float</code></pre><p>返回输入张量<code>input</code> 所有元素的积。</p><p>参数：input (Tensor) – 输入张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a 0.6170  0.3546  0.0253[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.prod(a)0.005537458061418483</code></pre><pre><code>torch.prod(input, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维度上每行的积。 输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 缩减的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 2)&gt;&gt;&gt; a 0.1598 -0.6884-0.1831 -0.4412-0.9925 -0.6244-0.2416 -0.8080[torch.FloatTensor of size 4x2]&gt;&gt;&gt; torch.prod(a, 1)-0.1100 0.0808 0.6197 0.1952[torch.FloatTensor of size 4x1]</code></pre><h3 id="torch-std"><a href="#torch-std" class="headerlink" title="torch.std"></a>torch.std</h3><pre><code>torch.std(input) → float</code></pre><p>返回输入张量<code>input</code> 所有元素的标准差。</p><p>参数：- input (Tensor) – 输入张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a-1.3063  1.4182 -0.3061[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.std(a)1.3782334731508061</code></pre><pre><code>torch.std(input, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维度上每行的标准差。 输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 缩减的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 4)&gt;&gt;&gt; a 0.1889 -2.4856  0.0043  1.8169-0.7701 -0.4682 -2.2410  0.4098 0.1919 -1.1856 -1.0361  0.9085 0.0173  1.0662  0.2143 -0.5576[torch.FloatTensor of size 4x4]&gt;&gt;&gt; torch.std(a, dim=1) 1.7756 1.1025 1.0045 0.6725[torch.FloatTensor of size 4x1]</code></pre><h3 id="torch-sum"><a href="#torch-sum" class="headerlink" title="torch.sum"></a>torch.sum</h3><pre><code>torch.sum(input) → float</code></pre><p>返回输入张量<code>input</code> 所有元素的和。</p><p>输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a 0.6170  0.3546  0.0253[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.sum(a)0.9969287421554327</code></pre><pre><code>torch.sum(input, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维度上每行的和。 输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 缩减的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 4)&gt;&gt;&gt; a-0.4640  0.0609  0.1122  0.4784-1.3063  1.6443  0.4714 -0.7396-1.3561 -0.1959  1.0609 -1.9855 2.6833  0.5746 -0.5709 -0.4430[torch.FloatTensor of size 4x4]&gt;&gt;&gt; torch.sum(a, 1) 0.1874 0.0698-2.4767 2.2440[torch.FloatTensor of size 4x1]</code></pre><h3 id="torch-var"><a href="#torch-var" class="headerlink" title="torch.var"></a>torch.var</h3><pre><code>torch.var(input) → float</code></pre><p>返回输入张量所有元素的方差</p><p>输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a-1.3063  1.4182 -0.3061[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.var(a)1.899527506513334</code></pre><pre><code>torch.var(input, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维度上每行的方差。 输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – the dimension to reduce</li><li>out (Tensor, optional) – 结果张量 例子：</li></ul><pre><code>&gt;&gt;&gt; a = torch.randn(4, 4)&gt;&gt;&gt; a-1.2738 -0.3058  0.1230 -1.9615 0.8771 -0.5430 -0.9233  0.9879 1.4107  0.0317 -0.6823  0.2255-1.3854  0.4953 -0.2160  0.2435[torch.FloatTensor of size 4x4]&gt;&gt;&gt; torch.var(a, 1) 0.8859 0.9509 0.7548 0.6949[torch.FloatTensor of size 4x1]</code></pre><h2 id="比较操作-Comparison-Ops"><a href="#比较操作-Comparison-Ops" class="headerlink" title="比较操作 Comparison Ops"></a>比较操作 Comparison Ops</h2><h3 id="torch-eq"><a href="#torch-eq" class="headerlink" title="torch.eq"></a>torch.eq</h3><pre><code>torch.eq(input, other, out=None) → Tensor</code></pre><p>比较元素相等性。第二个参数可为一个数或与第一个参数同类型形状的张量。</p><p>参数：</p><ul><li>input (Tensor) – 待比较张量</li><li>other (Tensor or float) – 比较张量或数</li><li>out (Tensor, optional) – 输出张量，须为 ByteTensor类型 or 与<code>input</code>同类型</li></ul><p>返回值： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果(相等为1，不等为0 )</p><p>返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.eq(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]]))1  00  1[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-equal"><a href="#torch-equal" class="headerlink" title="torch.equal"></a>torch.equal</h3><pre><code>torch.equal(tensor1, tensor2) → bool</code></pre><p>如果两个张量有相同的形状和元素值，则返回<code>True</code> ，否则 <code>False</code>。</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.equal(torch.Tensor([1, 2]), torch.Tensor([1, 2]))True</code></pre><h3 id="torch-ge"><a href="#torch-ge" class="headerlink" title="torch.ge"></a>torch.ge</h3><pre><code>torch.ge(input, other, out=None) → Tensor</code></pre><p>如果两个张量有相同的形状和元素值，则返回<code>True</code> ，否则 <code>False</code>。 第二个参数可以为一个数或与第一个参数相同形状和类型的张量</p><p>参数:</p><ul><li>input (Tensor) – 待对比的张量</li><li>other (Tensor or float) – 对比的张量或<code>float</code>值</li><li>out (Tensor, optional) – 输出张量。必须为<code>ByteTensor</code>或者与第一个参数<code>tensor</code>相同类型。</li></ul><p>返回值： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果(是否 input &gt;= other )。 返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.ge(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]])) 1  1 0  1[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-gt"><a href="#torch-gt" class="headerlink" title="torch.gt"></a>torch.gt</h3><pre><code>torch.gt(input, other, out=None) → Tensor</code></pre><p>参数:</p><ul><li>input (Tensor) – 要对比的张量</li><li>other (Tensor or float) – 要对比的张量或<code>float</code>值</li><li>out (Tensor, optional) – 输出张量。必须为<code>ByteTensor</code>或者与第一个参数<code>tensor</code>相同类型。</li></ul><p>返回值： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果(是否 input &gt;= other )。 返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.gt(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]])) 0  1 0  0[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-kthvalue"><a href="#torch-kthvalue" class="headerlink" title="torch.kthvalue"></a>torch.kthvalue</h3><pre><code>torch.kthvalue(input, k, dim=None, out=None) -&gt; (Tensor, LongTensor)</code></pre><p>取输入张量<code>input</code>指定维上第k 个最小值。如果不指定<code>dim</code>，则默认为<code>input</code>的最后一维。</p><p>返回一个元组 <em>(values,indices)</em>，其中<code>indices</code>是原始输入张量<code>input</code>中沿<code>dim</code>维的第 <code>k</code> 个最小值下标。</p><p>参数:</p><ul><li>input (Tensor) – 要对比的张量</li><li>k (int) – 第 <code>k</code> 个最小值</li><li>dim (int, optional) – 沿着此维进行排序</li><li>out (tuple, optional) – 输出元组 (Tensor, LongTensor) 可选地给定作为 输出 buffers</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.arange(1, 6)&gt;&gt;&gt; x 1 2 3 4 5[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.kthvalue(x, 4)( 4[torch.FloatTensor of size 1], 3[torch.LongTensor of size 1])</code></pre><h3 id="torch-le"><a href="#torch-le" class="headerlink" title="torch.le"></a>torch.le</h3><pre><code>torch.le(input, other, out=None) → Tensor</code></pre><p>参数:</p><ul><li>input (Tensor) – 要对比的张量</li><li>other (Tensor or float ) – 对比的张量或<code>float</code>值</li><li>out (Tensor, optional) – 输出张量。必须为<code>ByteTensor</code>或者与第一个参数<code>tensor</code>相同类型。</li></ul><p>返回值： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果(是否 input &gt;= other )。 返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.le(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]])) 1  0 1  1[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-lt"><a href="#torch-lt" class="headerlink" title="torch.lt"></a>torch.lt</h3><pre><code>torch.lt(input, other, out=None) → Tensor</code></pre><p>第二个参数可以为一个数或与第一个参数相同形状和类型的张量</p><p>参数:</p><ul><li>input (Tensor) – 要对比的张量</li><li>other (Tensor or float ) – 对比的张量或<code>float</code>值</li><li>out (Tensor, optional) – 输出张量。必须为<code>ByteTensor</code>或者与第一个参数<code>tensor</code>相同类型。</li></ul><p>input： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果(是否 tensor &gt;= other )。 返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.lt(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]])) 0  0 1  0[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-max"><a href="#torch-max" class="headerlink" title="torch.max"></a>torch.max</h3><pre><code>torch.max()</code></pre><p>返回输入张量所有元素的最大值。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a 0.4729 -0.2266 -0.2085[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.max(a)0.4729</code></pre><pre><code>torch.max(input, dim, max=None, max_indices=None) -&gt; (Tensor, LongTensor)</code></pre><p>返回输入张量给定维度上每行的最大值，并同时返回每个最大值的位置索引。</p><p>输出形状中，将<code>dim</code>维设定为1，其它与输入形状保持一致。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 指定的维度</li><li>max (Tensor, optional) – 结果张量，包含给定维度上的最大值</li><li>max_indices (LongTensor, optional) – 结果张量，包含给定维度上每个最大值的位置索引</li></ul><p>例子：</p><pre><code>&gt;&gt; a = torch.randn(4, 4)&gt;&gt; a0.0692  0.3142  1.2513 -0.54280.9288  0.8552 -0.2073  0.64091.0695 -0.0101 -2.4507 -1.22300.7426 -0.7666  0.4862 -0.6628torch.FloatTensor of size 4x4]&gt;&gt;&gt; torch.max(a, 1)( 1.2513 0.9288 1.0695 0.7426[torch.FloatTensor of size 4x1], 2 0 0 0[torch.LongTensor of size 4x1])</code></pre><pre><code>torch.max(input, other, out=None) → Tensor</code></pre><p>输出形状中，将<code>dim</code>维设定为1，其它与输入形状保持一致。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>other (Tensor) – 输出张量</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; b = torch.randn(4)&gt;&gt;&gt; b 1.0067-0.8010 0.6258 0.3627[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.max(a, b) 1.3869 0.3912 0.6258 0.3627[torch.FloatTensor of size 4]</code></pre><h3 id="torch-min"><a href="#torch-min" class="headerlink" title="torch.min"></a>torch.min</h3><pre><code>torch.min(input) → float</code></pre><p>返回输入张量所有元素的最小值。</p><p>参数: input (Tensor) – 输入张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a 0.4729 -0.2266 -0.2085[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.min(a)-0.22663167119026184</code></pre><pre><code>torch.min(input, dim, min=None, min_indices=None) -&gt; (Tensor, LongTensor)</code></pre><p>返回输入张量给定维度上每行的最小值，并同时返回每个最小值的位置索引。</p><p>输出形状中，将<code>dim</code>维设定为1，其它与输入形状保持一致。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 指定的维度</li><li>min (Tensor, optional) – 结果张量，包含给定维度上的最小值</li><li>min_indices (LongTensor, optional) – 结果张量，包含给定维度上每个最小值的位置索引</li></ul><p>例子：</p><pre><code>&gt;&gt; a = torch.randn(4, 4)&gt;&gt; a0.0692  0.3142  1.2513 -0.54280.9288  0.8552 -0.2073  0.64091.0695 -0.0101 -2.4507 -1.22300.7426 -0.7666  0.4862 -0.6628torch.FloatTensor of size 4x4]&gt;&gt; torch.min(a, 1)0.54280.20732.45070.7666torch.FloatTensor of size 4x1]3221torch.LongTensor of size 4x1]</code></pre><pre><code>torch.min(input, other, out=None) → Tensor</code></pre><p>两张量形状不需匹配，但元素数须相同。</p><p>注意：当形状不匹配时，<code>input</code>的形状作为返回张量的形状。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>other (Tensor) – 第二个输入张量</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; b = torch.randn(4)&gt;&gt;&gt; b 1.0067-0.8010 0.6258 0.3627[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.min(a, b) 1.0067-0.8010-0.8634-0.5468[torch.FloatTensor of size 4]</code></pre><h3 id="torch-ne"><a href="#torch-ne" class="headerlink" title="torch.ne"></a>torch.ne</h3><pre><code>torch.ne(input, other, out=None) → Tensor</code></pre><p>参数:</p><ul><li>input (Tensor) – 待对比的张量</li><li>other (Tensor or float) – 对比的张量或<code>float</code>值</li><li>out (Tensor, optional) – 输出张量。必须为<code>ByteTensor</code>或者与<code>input</code>相同类型。</li></ul><p>返回值： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果 (如果 tensor != other 为<code>True</code> ，返回<code>1</code>)。</p><p>返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.ne(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]])) 0  1 1  0[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-sort"><a href="#torch-sort" class="headerlink" title="torch.sort"></a>torch.sort</h3><pre><code>torch.sort(input, dim=None, descending=False, out=None) -&gt; (Tensor, LongTensor)</code></pre><p>对输入张量<code>input</code>沿着指定维按升序排序。如果不给定<code>dim</code>，则默认为输入的最后一维。如果指定参数<code>descending</code>为<code>True</code>，则按降序排序</p><p>返回元组 (sorted_tensor, sorted_indices) ， <code>sorted_indices</code> 为原始输入中的下标。</p><p>参数:</p><ul><li>input (Tensor) – 要对比的张量</li><li>dim (int, optional) – 沿着此维排序</li><li>descending (bool, optional) – 布尔值，控制升降排序</li><li>out (tuple, optional) – 输出张量。必须为<code>ByteTensor</code>或者与第一个参数<code>tensor</code>相同类型。</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.randn(3, 4)&gt;&gt;&gt; sorted, indices = torch.sort(x)&gt;&gt;&gt; sorted-1.6747  0.0610  0.1190  1.4137-1.4782  0.7159  1.0341  1.3678-0.3324 -0.0782  0.3518  0.4763[torch.FloatTensor of size 3x4]&gt;&gt;&gt; indices 0  1  3  2 2  1  0  3 3  1  0  2[torch.LongTensor of size 3x4]&gt;&gt;&gt; sorted, indices = torch.sort(x, 0)&gt;&gt;&gt; sorted-1.6747 -0.0782 -1.4782 -0.3324 0.3518  0.0610  0.4763  0.1190 1.0341  0.7159  1.4137  1.3678[torch.FloatTensor of size 3x4]&gt;&gt;&gt; indices 0  2  1  2 2  0  2  0 1  1  0  1[torch.LongTensor of size 3x4]</code></pre><h3 id="torch-topk"><a href="#torch-topk" class="headerlink" title="torch.topk"></a>torch.topk</h3><pre><code>torch.topk(input, k, dim=None, largest=True, sorted=True, out=None) -&gt; (Tensor, LongTensor)</code></pre><p>沿给定<code>dim</code>维度返回输入张量<code>input</code>中 <code>k</code> 个最大值。 如果不指定<code>dim</code>，则默认为<code>input</code>的最后一维。 如果为<code>largest</code>为 <code>False</code> ，则返回最小的 <code>k</code> 个值。</p><p>返回一个元组 <em>(values,indices)</em>，其中<code>indices</code>是原始输入张量<code>input</code>中测元素下标。 如果设定布尔值<code>sorted</code> 为_True_，将会确保返回的 <code>k</code> 个值被排序。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>k (int) – “top-k”中的<code>k</code></li><li>dim (int, optional) – 排序的维</li><li>largest (bool, optional) – 布尔值，控制返回最大或最小值</li><li>sorted (bool, optional) – 布尔值，控制返回值是否排序</li><li>out (tuple, optional) – 可选输出张量 (Tensor, LongTensor) output buffers</li></ul><pre><code>&gt;&gt;&gt; x = torch.arange(1, 6)&gt;&gt;&gt; x 1 2 3 4 5[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.topk(x, 3)( 5 4 3[torch.FloatTensor of size 3], 4 3 2[torch.LongTensor of size 3])&gt;&gt;&gt; torch.topk(x, 3, 0, largest=False)( 1 2 3[torch.FloatTensor of size 3], 0 1 2[torch.LongTensor of size 3])</code></pre><h2 id="其它操作-Other-Operations"><a href="#其它操作-Other-Operations" class="headerlink" title="其它操作 Other Operations"></a>其它操作 Other Operations</h2><h3 id="torch-cross"><a href="#torch-cross" class="headerlink" title="torch.cross"></a>torch.cross</h3><pre><code>torch.cross(input, other, dim=-1, out=None) → Tensor</code></pre><p>返回沿着维度<code>dim</code>上，两个张量<code>input</code>和<code>other</code>的向量积（叉积）。 <code>input</code>和<code>other</code> 必须有相同的形状，且指定的<code>dim</code>维上size必须为<code>3</code>。</p><p>如果不指定<code>dim</code>，则默认为第一个尺度为<code>3</code>的维。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>other (Tensor) – 第二个输入张量</li><li>dim (int, optional) – 沿着此维进行叉积操作</li><li>out (Tensor,optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 3)&gt;&gt;&gt; a-0.6652 -1.0116 -0.6857 0.2286  0.4446 -0.5272 0.0476  0.2321  1.9991 0.6199  1.1924 -0.9397[torch.FloatTensor of size 4x3]&gt;&gt;&gt; b = torch.randn(4, 3)&gt;&gt;&gt; b-0.1042 -1.1156  0.1947 0.9947  0.1149  0.4701-1.0108  0.8319 -0.0750 0.9045 -1.3754  1.0976[torch.FloatTensor of size 4x3]&gt;&gt;&gt; torch.cross(a, b, dim=1)-0.9619  0.2009  0.6367 0.2696 -0.6318 -0.4160-1.6805 -2.0171  0.2741 0.0163 -1.5304 -1.9311[torch.FloatTensor of size 4x3]&gt;&gt;&gt; torch.cross(a, b)-0.9619  0.2009  0.6367 0.2696 -0.6318 -0.4160-1.6805 -2.0171  0.2741 0.0163 -1.5304 -1.9311[torch.FloatTensor of size 4x3]</code></pre><h3 id="torch-diag"><a href="#torch-diag" class="headerlink" title="torch.diag"></a>torch.diag</h3><pre><code>torch.diag(input, diagonal=0, out=None) → Tensor</code></pre><ul><li>如果输入是一个向量(1D 张量)，则返回一个以<code>input</code>为对角线元素的2D方阵</li><li>如果输入是一个矩阵(2D 张量)，则返回一个包含<code>input</code>对角线元素的1D张量</li></ul><p>参数<code>diagonal</code>指定对角线:</p><ul><li><code>diagonal</code> = 0, 主对角线</li><li><code>diagonal</code> &gt; 0, 主对角线之上</li><li><code>diagonal</code> &lt; 0, 主对角线之下</li></ul><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>diagonal (int, optional) – 指定对角线</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><ul><li>取得以<code>input</code>为对角线的方阵：</li></ul><pre><code>&gt;&gt;&gt; a = torch.randn(3)&gt;&gt;&gt; a 1.0480-2.3405-1.1138[torch.FloatTensor of size 3]&gt;&gt;&gt; torch.diag(a) 1.0480  0.0000  0.0000 0.0000 -2.3405  0.0000 0.0000  0.0000 -1.1138[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.diag(a, 1) 0.0000  1.0480  0.0000  0.0000 0.0000  0.0000 -2.3405  0.0000 0.0000  0.0000  0.0000 -1.1138 0.0000  0.0000  0.0000  0.0000[torch.FloatTensor of size 4x4]</code></pre><ul><li>取得给定矩阵第<code>k</code>个对角线:</li></ul><pre><code>&gt;&gt;&gt; a = torch.randn(3, 3)&gt;&gt;&gt; a-1.5328 -1.3210 -1.5204 0.8596  0.0471 -0.2239-0.6617  0.0146 -1.0817[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.diag(a, 0)-1.5328 0.0471-1.0817[torch.FloatTensor of size 3]&gt;&gt;&gt; torch.diag(a, 1)-1.3210-0.2239[torch.FloatTensor of size 2]</code></pre><h3 id="torch-histc"><a href="#torch-histc" class="headerlink" title="torch.histc"></a>torch.histc</h3><pre><code>torch.histc(input, bins=100, min=0, max=0, out=None) → Tensor</code></pre><p>计算输入张量的直方图。以<code>min</code>和<code>max</code>为range边界，将其均分成<code>bins</code>个直条，然后将排序好的数据划分到各个直条(bins)中。如果<code>min</code>和<code>max</code>都为0, 则利用数据中的最大最小值作为边界。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>bins (int) – 直方图 bins(直条)的个数(默认100个)</li><li>min (int) – range的下边界(包含)</li><li>max (int) – range的上边界(包含)</li><li>out (Tensor, optional) – 结果张量</li></ul><p>返回： 直方图 返回类型：张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.histc(torch.FloatTensor([1, 2, 1]), bins=4, min=0, max=3)FloatTensor([0, 2, 1, 0])</code></pre><h3 id="torch-renorm"><a href="#torch-renorm" class="headerlink" title="torch.renorm"></a>torch.renorm</h3><pre><code>torch.renorm(input, p, dim, maxnorm, out=None) → Tensor</code></pre><p>返回一个张量，包含规范化后的各个子张量，使得沿着<code>dim</code>维划分的各子张量的p范数小于<code>maxnorm</code>。</p><p><strong>注意</strong> 如果p范数的值小于<code>maxnorm</code>，则当前子张量不需要修改。</p><p><strong>注意</strong>: 更详细解释参考<a href="http://torch7.readthedocs.io/en/rtd/maths/" target="_blank" rel="noopener">torch7</a> 以及<a href="https://arxiv.org/pdf/1207.0580.pdf" target="_blank" rel="noopener">Hinton et al. 2012, p. 2</a></p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>p (float) – 范数的p</li><li>dim (int) – 沿着此维切片，得到张量子集</li><li>maxnorm (float) – 每个子张量的范数的最大值</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.ones(3, 3)&gt;&gt;&gt; x[1].fill_(2)&gt;&gt;&gt; x[2].fill_(3)&gt;&gt;&gt; x 1  1  1 2  2  2 3  3  3[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.renorm(x, 1, 0, 5) 1.0000  1.0000  1.0000 1.6667  1.6667  1.6667 1.6667  1.6667  1.6667[torch.FloatTensor of size 3x3]</code></pre><h3 id="torch-trace"><a href="#torch-trace" class="headerlink" title="torch.trace"></a>torch.trace</h3><pre><code>torch.trace(input) → float</code></pre><p>返回输入2维矩阵对角线元素的和(迹)</p><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.arange(1, 10).view(3, 3)&gt;&gt;&gt; x 1  2  3 4  5  6 7  8  9[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.trace(x)15.0</code></pre><h3 id="torch-tril"><a href="#torch-tril" class="headerlink" title="torch.tril"></a>torch.tril</h3><pre><code>torch.tril(input, k=0, out=None) → Tensor</code></pre><p>返回一个张量<code>out</code>，包含输入矩阵(2D张量)的下三角部分，<code>out</code>其余部分被设为<code>0</code>。这里所说的下三角部分为矩阵指定对角线<code>diagonal</code>之上的元素。</p><p>参数<code>k</code>控制对角线: - <code>k</code> = 0, 主对角线 - <code>k</code> &gt; 0, 主对角线之上 - <code>k</code> &lt; 0, 主对角线之下</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>k (int, optional) – 指定对角线</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(3,3)&gt;&gt;&gt; a 1.3225  1.7304  1.4573-0.3052 -0.3111 -0.1809 1.2469  0.0064 -1.6250[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.tril(a) 1.3225  0.0000  0.0000-0.3052 -0.3111  0.0000 1.2469  0.0064 -1.6250[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.tril(a, k=1) 1.3225  1.7304  0.0000-0.3052 -0.3111 -0.1809 1.2469  0.0064 -1.6250[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.tril(a, k=-1) 0.0000  0.0000  0.0000-0.3052  0.0000  0.0000 1.2469  0.0064  0.0000[torch.FloatTensor of size 3x3]</code></pre><h3 id="torch-triu"><a href="#torch-triu" class="headerlink" title="torch.triu"></a>torch.triu</h3><pre><code>torch.triu(input, k=0, out=None) → Tensor</code></pre><p>返回一个张量，包含输入矩阵(2D张量)的上三角部分，其余部分被设为<code>0</code>。这里所说的上三角部分为矩阵指定对角线<code>diagonal</code>之上的元素。</p><p>参数<code>k</code>控制对角线: - <code>k</code> = 0, 主对角线 - <code>k</code> &gt; 0, 主对角线之上 - <code>k</code> &lt; 0, 主对角线之下</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>k (int, optional) – 指定对角线</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(3,3)&gt;&gt;&gt; a 1.3225  1.7304  1.4573-0.3052 -0.3111 -0.1809 1.2469  0.0064 -1.6250[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.triu(a) 1.3225  1.7304  1.4573 0.0000 -0.3111 -0.1809 0.0000  0.0000 -1.6250[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.triu(a, k=1) 0.0000  1.7304  1.4573 0.0000  0.0000 -0.1809 0.0000  0.0000  0.0000[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.triu(a, k=-1) 1.3225  1.7304  1.4573-0.3052 -0.3111 -0.1809 0.0000  0.0064 -1.6250[torch.FloatTensor of size 3x3]</code></pre><h2 id="BLAS-and-LAPACK-Operations"><a href="#BLAS-and-LAPACK-Operations" class="headerlink" title="BLAS and LAPACK Operations"></a>BLAS and LAPACK Operations</h2><h3 id="torch-addbmm"><a href="#torch-addbmm" class="headerlink" title="torch.addbmm"></a>torch.addbmm</h3><pre><code>torch.addbmm(beta=1, mat, alpha=1, batch1, batch2, out=None) → Tensor</code></pre><p>对类型为 <em>FloatTensor</em> 或 <em>DoubleTensor</em> 的输入，<code>alpha</code>and <code>beta</code>必须为实数，否则两个参数须为整数。</p><p>参数：</p><ul><li>beta (Number, optional) – 用于<code>mat</code>的乘子</li><li>mat (Tensor) – 相加矩阵</li><li>batch1 (Tensor) – 第一批相乘矩阵</li><li>batch2 (Tensor) – 第二批相乘矩阵</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; M = torch.randn(3, 5)&gt;&gt;&gt; batch1 = torch.randn(10, 3, 4)&gt;&gt;&gt; batch2 = torch.randn(10, 4, 5)&gt;&gt;&gt; torch.addbmm(M, batch1, batch2) -3.1162  11.0071   7.3102   0.1824  -7.6892  1.8265   6.0739   0.4589  -0.5641  -5.4283 -9.3387  -0.1794  -1.2318  -6.8841  -4.7239[torch.FloatTensor of size 3x5]</code></pre><h3 id="torch-addmm"><a href="#torch-addmm" class="headerlink" title="torch.addmm"></a>torch.addmm</h3><pre><code>torch.addmm(beta=1, mat, alpha=1, mat1, mat2, out=None) → Tensor</code></pre><p>对类型为 <em>FloatTensor</em> 或 <em>DoubleTensor</em> 的输入，<code>beta</code>and <code>alpha</code>必须为实数，否则两个参数须为整数。</p><p>参数 ：</p><ul><li><p>beta (Number, optional) – 用于<code>mat</code>的乘子</p></li><li><p>mat (Tensor) – 相加矩阵</p></li><li><p>mat1 (Tensor) – 第一个相乘矩阵</p></li><li><p>mat2 (Tensor) – 第二个相乘矩阵</p></li><li><p>out (Tensor, optional) – 输出张量</p></li></ul><pre><code>&gt;&gt;&gt; M = torch.randn(2, 3)&gt;&gt;&gt; mat1 = torch.randn(2, 3)&gt;&gt;&gt; mat2 = torch.randn(3, 3)&gt;&gt;&gt; torch.addmm(M, mat1, mat2)-0.4095 -1.9703  1.3561 5.7674 -4.9760  2.7378[torch.FloatTensor of size 2x3]</code></pre><h3 id="torch-addmv"><a href="#torch-addmv" class="headerlink" title="torch.addmv"></a>torch.addmv</h3><pre><code>torch.addmv(beta=1, tensor, alpha=1, mat, vec, out=None) → Tensor</code></pre><p>对类型为_FloatTensor_或_DoubleTensor_的输入，<code>alpha</code>and <code>beta</code>必须为实数，否则两个参数须为整数。</p><p>参数 ：</p><ul><li>beta (Number, optional) – 用于<code>mat</code>的乘子</li><li>mat (Tensor) – 相加矩阵</li><li>mat (Tensor) – 相乘矩阵</li><li>vec (Tensor) – 相乘向量</li><li>out (Tensor, optional) – 输出张量</li></ul><pre><code>&gt;&gt;&gt; M = torch.randn(2)&gt;&gt;&gt; mat = torch.randn(2, 3)&gt;&gt;&gt; vec = torch.randn(3)&gt;&gt;&gt; torch.addmv(M, mat, vec)-2.0939-2.2950[torch.FloatTensor of size 2]</code></pre><h3 id="torch-addr"><a href="#torch-addr" class="headerlink" title="torch.addr"></a>torch.addr</h3><pre><code>torch.addr(beta=1, mat, alpha=1, vec1, vec2, out=None) → Tensor</code></pre><p>对类型为_FloatTensor_或_DoubleTensor_的输入，<code>alpha</code>and <code>beta</code>必须为实数，否则两个参数须为整数。</p><p>参数 ：</p><ul><li>beta (Number, optional) – 用于<code>mat</code>的乘子</li><li>mat (Tensor) – 相加矩阵</li><li>vec1 (Tensor) – 第一个相乘向量</li><li>vec2 (Tensor) – 第二个相乘向量</li><li>out (Tensor, optional) – 输出张量</li></ul><pre><code>&gt;&gt;&gt; vec1 = torch.arange(1, 4)&gt;&gt;&gt; vec2 = torch.arange(1, 3)&gt;&gt;&gt; M = torch.zeros(3, 2)&gt;&gt;&gt; torch.addr(M, vec1, vec2) 1  2 2  4 3  6[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-baddbmm"><a href="#torch-baddbmm" class="headerlink" title="torch.baddbmm"></a>torch.baddbmm</h3><pre><code>torch.baddbmm(beta=1, mat, alpha=1, batch1, batch2, out=None) → Tensor</code></pre><p>对类型为_FloatTensor_或_DoubleTensor_的输入，<code>alpha</code>and <code>beta</code>必须为实数，否则两个参数须为整数。</p><p>参数：</p><ul><li>beta (Number, optional) – 用于<code>mat</code>的乘子</li><li>mat (Tensor) – 相加矩阵</li><li>batch1 (Tensor) – 第一批相乘矩阵</li><li>batch2 (Tensor) – 第二批相乘矩阵</li><li>out (Tensor, optional) – 输出张量</li></ul><pre><code>&gt;&gt;&gt; M = torch.randn(10, 3, 5)&gt;&gt;&gt; batch1 = torch.randn(10, 3, 4)&gt;&gt;&gt; batch2 = torch.randn(10, 4, 5)&gt;&gt;&gt; torch.baddbmm(M, batch1, batch2).size()torch.Size([10, 3, 5])</code></pre><h3 id="torch-bmm"><a href="#torch-bmm" class="headerlink" title="torch.bmm"></a>torch.bmm</h3><pre><code>torch.bmm(batch1, batch2, out=None) → Tensor</code></pre><p>对类型为 <em>FloatTensor</em> 或 <em>DoubleTensor</em> 的输入，<code>alpha</code>and <code>beta</code>必须为实数，否则两个参数须为整数。</p><p>参数：</p><ul><li>batch1 (Tensor) – 第一批相乘矩阵</li><li>batch2 (Tensor) – 第二批相乘矩阵</li><li>out (Tensor, optional) – 输出张量</li></ul><pre><code>&gt;&gt;&gt; batch1 = torch.randn(10, 3, 4)&gt;&gt;&gt; batch2 = torch.randn(10, 4, 5)&gt;&gt;&gt; res = torch.bmm(batch1, batch2)&gt;&gt;&gt; res.size()torch.Size([10, 3, 5])</code></pre><h3 id="torch-btrifact"><a href="#torch-btrifact" class="headerlink" title="torch.btrifact"></a>torch.btrifact</h3><pre><code>torch.btrifact(A, info=None) → Tensor, IntTensor</code></pre><p>返回一个元组，包含LU 分解和<code>pivots</code> 。 可选参数<code>info</code>决定是否对每个minibatch样本进行分解。<code>info</code> are from dgetrf and a non-zero value indicates an error occurred. 如果用CUDA的话，这个值来自于CUBLAS，否则来自LAPACK。</p><p>参数： A (Tensor) – 待分解张量</p><pre><code>&gt;&gt;&gt; A = torch.randn(2, 3, 3)&gt;&gt;&gt; A_LU = A.btrifact()</code></pre><h3 id="torch-btrisolve"><a href="#torch-btrisolve" class="headerlink" title="torch.btrisolve"></a>torch.btrisolve</h3><pre><code>torch.btrisolve(b, LU_data, LU_pivots) → Tensor</code></pre><p>参数：</p><ul><li>b (Tensor) – RHS 张量.</li><li>LU_data (Tensor) – Pivoted LU factorization of A from btrifact.</li><li>LU_pivots (IntTensor) – LU 分解的Pivots.</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; A = torch.randn(2, 3, 3)&gt;&gt;&gt; b = torch.randn(2, 3)&gt;&gt;&gt; A_LU = torch.btrifact(A)&gt;&gt;&gt; x = b.btrisolve(*A_LU)&gt;&gt;&gt; torch.norm(A.bmm(x.unsqueeze(2)) - b)6.664001874625056e-08</code></pre><h3 id="torch-dot"><a href="#torch-dot" class="headerlink" title="torch.dot"></a>torch.dot</h3><pre><code>torch.dot(tensor1, tensor2) → float</code></pre><p>计算两个张量的点乘(内乘),两个张量都为1-D 向量.</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.dot(torch.Tensor([2, 3]), torch.Tensor([2, 1]))7.0</code></pre><h3 id="torch-eig"><a href="#torch-eig" class="headerlink" title="torch.eig"></a>torch.eig</h3><pre><code>torch.eig(a, eigenvectors=False, out=None) -&gt; (Tensor, Tensor)</code></pre><p>计算实方阵<code>a</code> 的特征值和特征向量</p><p>参数：</p><ul><li>a (Tensor) – 方阵，待计算其特征值和特征向量</li><li>eigenvectors (bool) – 布尔值，如果<code>True</code>，则同时计算特征值和特征向量，否则只计算特征值。</li><li>out (tuple, optional) – 输出元组</li></ul><p>返回值： 元组，包括：</p><ul><li>e (Tensor): a 的右特征向量</li><li>v (Tensor): 如果<code>eigenvectors</code>为<code>True</code>，则为包含特征向量的张量; 否则为空张量</li></ul><p>返回值类型： (Tensor, Tensor)</p><h3 id="torch-gels"><a href="#torch-gels" class="headerlink" title="torch.gels"></a>torch.gels</h3><pre><code>torch.gels(B, A, out=None) → Tensor</code></pre><p>注意： 返回矩阵总是被转置，无论输入矩阵的原始布局如何，总会被转置；即，总是有 stride (1, m) 而不是 (m, 1).</p><p>参数：</p><ul><li>B (Tensor) – 矩阵B</li><li>out (tuple, optional) – 输出元组</li></ul><p>返回值： 元组，包括：</p><ul><li>X (Tensor): 最小二乘解</li><li>qr (Tensor): QR 分解的细节</li></ul><p>返回值类型： (Tensor, Tensor)</p><p>例子：</p><pre><code>&gt;&gt;&gt; A = torch.Tensor([[1, 1, 1],...                   [2, 3, 4],...                   [3, 5, 2],...                   [4, 2, 5],...                   [5, 4, 3]])&gt;&gt;&gt; B = torch.Tensor([[-10, -3],                      [ 12, 14],                      [ 14, 12],                      [ 16, 16],                      [ 18, 16]])&gt;&gt;&gt; X, _ = torch.gels(B, A)&gt;&gt;&gt; X2.0000  1.00001.0000  1.00001.0000  2.0000[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-geqrf"><a href="#torch-geqrf" class="headerlink" title="torch.geqrf"></a>torch.geqrf</h3><pre><code>torch.geqrf(input, out=None) -&gt; (Tensor, Tensor)</code></pre><p>这是一个直接调用LAPACK的底层函数。 一般使用<code>torch.qr()</code></p><p>计算输入的QR 分解，但是并不会分别创建Q,R两个矩阵，而是直接调用LAPACK 函数 Rather, this directly calls the underlying LAPACK function ?geqrf which produces a sequence of ‘elementary reflectors’.</p><p>参考 <a href="https://software.intel.com/en-us/node/521004" target="_blank" rel="noopener">LAPACK文档</a>获取更详细信息。</p><p>参数:</p><ul><li>input (Tensor) – 输入矩阵</li><li>out (tuple, optional) – 元组，包含输出张量 (Tensor, Tensor)</li></ul><h3 id="torch-ger"><a href="#torch-ger" class="headerlink" title="torch.ger"></a>torch.ger</h3><pre><code>torch.ger(vec1, vec2, out=None) → Tensor</code></pre><p>计算两向量<code>vec1</code>,<code>vec2</code>的张量积。如果<code>vec1</code>的长度为<code>n</code>,<code>vec2</code>长度为<code>m</code>，则输出<code>out</code>应为形如n x m的矩阵。</p><p>参数:</p><ul><li>vec1 (Tensor) – 1D 输入向量</li><li>vec2 (Tensor) – 1D 输入向量</li><li>out (tuple, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; v1 = torch.arange(1, 5)&gt;&gt;&gt; v2 = torch.arange(1, 4)&gt;&gt;&gt; torch.ger(v1, v2)  1   2   3  2   4   6  3   6   9  4   8  12[torch.FloatTensor of size 4x3]</code></pre><h3 id="torch-gesv"><a href="#torch-gesv" class="headerlink" title="torch.gesv"></a>torch.gesv</h3><pre><code>torch.gesv(B, A, out=None) -&gt; (Tensor, Tensor)</code></pre><p>例子:</p><pre><code>&gt;&gt;&gt; A = torch.Tensor([[6.80, -2.11,  5.66,  5.97,  8.23],...                   [-6.05, -3.30,  5.36, -4.44,  1.08],...                   [-0.45,  2.58, -2.70,  0.27,  9.04],...                   [8.32,  2.71,  4.35,  -7.17,  2.14],...                   [-9.67, -5.14, -7.26,  6.08, -6.87]]).t()&gt;&gt;&gt; B = torch.Tensor([[4.02,  6.19, -8.22, -7.57, -3.03],...                   [-1.56,  4.00, -8.67,  1.75,  2.86],...                   [9.81, -4.09, -4.57, -8.61,  8.99]]).t()&gt;&gt;&gt; X, LU = torch.gesv(B, A)&gt;&gt;&gt; torch.dist(B, torch.mm(A, X))9.250057093890353e-06</code></pre><h3 id="torch-inverse"><a href="#torch-inverse" class="headerlink" title="torch.inverse"></a>torch.inverse</h3><pre><code>torch.inverse(input, out=None) → Tensor</code></pre><p>对方阵输入<code>input</code> 取逆。</p><p><em>注意</em> ： Irrespective of the original strides, the returned matrix will be transposed, i.e. with strides (1, m) instead of (m, 1)</p><p>参数 ：</p><ul><li>input (Tensor) – 输入2维张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; x = torch.rand(10, 10)&gt;&gt;&gt; x 0.7800  0.2267  0.7855  0.9479  0.5914  0.7119  0.4437  0.9131  0.1289  0.1982 0.0045  0.0425  0.2229  0.4626  0.6210  0.0207  0.6338  0.7067  0.6381  0.8196 0.8350  0.7810  0.8526  0.9364  0.7504  0.2737  0.0694  0.5899  0.8516  0.3883 0.6280  0.6016  0.5357  0.2936  0.7827  0.2772  0.0744  0.2627  0.6326  0.9153 0.7897  0.0226  0.3102  0.0198  0.9415  0.9896  0.3528  0.9397  0.2074  0.6980 0.5235  0.6119  0.6522  0.3399  0.3205  0.5555  0.8454  0.3792  0.4927  0.6086 0.1048  0.0328  0.5734  0.6318  0.9802  0.4458  0.0979  0.3320  0.3701  0.0909 0.2616  0.3485  0.4370  0.5620  0.5291  0.8295  0.7693  0.1807  0.0650  0.8497 0.1655  0.2192  0.6913  0.0093  0.0178  0.3064  0.6715  0.5101  0.2561  0.3396 0.4370  0.4695  0.8333  0.1180  0.4266  0.4161  0.0699  0.4263  0.8865  0.2578[torch.FloatTensor of size 10x10]&gt;&gt;&gt; x = torch.rand(10, 10)&gt;&gt;&gt; y = torch.inverse(x)&gt;&gt;&gt; z = torch.mm(x, y)&gt;&gt;&gt; z 1.0000  0.0000  0.0000 -0.0000  0.0000  0.0000  0.0000  0.0000 -0.0000 -0.0000 0.0000  1.0000 -0.0000  0.0000  0.0000  0.0000 -0.0000 -0.0000 -0.0000 -0.0000 0.0000  0.0000  1.0000 -0.0000 -0.0000  0.0000  0.0000  0.0000 -0.0000 -0.0000 0.0000  0.0000  0.0000  1.0000  0.0000  0.0000  0.0000 -0.0000 -0.0000  0.0000 0.0000  0.0000 -0.0000 -0.0000  1.0000  0.0000  0.0000 -0.0000 -0.0000 -0.0000 0.0000  0.0000  0.0000 -0.0000  0.0000  1.0000 -0.0000 -0.0000 -0.0000 -0.0000 0.0000  0.0000  0.0000 -0.0000  0.0000  0.0000  1.0000  0.0000 -0.0000  0.0000 0.0000  0.0000 -0.0000 -0.0000  0.0000  0.0000 -0.0000  1.0000 -0.0000  0.0000-0.0000  0.0000 -0.0000 -0.0000  0.0000  0.0000 -0.0000 -0.0000  1.0000 -0.0000-0.0000  0.0000 -0.0000 -0.0000 -0.0000  0.0000 -0.0000 -0.0000  0.0000  1.0000[torch.FloatTensor of size 10x10]&gt;&gt;&gt; torch.max(torch.abs(z - torch.eye(10))) # Max nonzero5.096662789583206e-07</code></pre><h3 id="torch-mm"><a href="#torch-mm" class="headerlink" title="torch.mm"></a>torch.mm</h3><pre><code>torch.mm(mat1, mat2, out=None) → Tensor</code></pre><p>参数 ：</p><ul><li>mat1 (Tensor) – 第一个相乘矩阵</li><li>mat2 (Tensor) – 第二个相乘矩阵</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; mat1 = torch.randn(2, 3)&gt;&gt;&gt; mat2 = torch.randn(3, 3)&gt;&gt;&gt; torch.mm(mat1, mat2) 0.0519 -0.3304  1.2232 4.3910 -5.1498  2.7571[torch.FloatTensor of size 2x3]</code></pre><h3 id="torch-mv"><a href="#torch-mv" class="headerlink" title="torch.mv"></a>torch.mv</h3><pre><code>torch.mv(mat, vec, out=None) → Tensor</code></pre><p>参数 ：</p><ul><li>mat (Tensor) – 相乘矩阵</li><li>vec (Tensor) – 相乘向量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; mat = torch.randn(2, 3)&gt;&gt;&gt; vec = torch.randn(3)&gt;&gt;&gt; torch.mv(mat, vec)-2.0939-2.2950[torch.FloatTensor of size 2]</code></pre><h3 id="torch-orgqr"><a href="#torch-orgqr" class="headerlink" title="torch.orgqr"></a>torch.orgqr</h3><pre><code>torch.orgqr()</code></pre><h3 id="torch-ormqr"><a href="#torch-ormqr" class="headerlink" title="torch.ormqr"></a>torch.ormqr</h3><pre><code>torch.ormqr()</code></pre><h3 id="torch-potrf"><a href="#torch-potrf" class="headerlink" title="torch.potrf"></a>torch.potrf</h3><pre><code>torch.potrf()</code></pre><h3 id="torch-potri"><a href="#torch-potri" class="headerlink" title="torch.potri"></a>torch.potri</h3><pre><code>torch.potri()</code></pre><h3 id="torch-potrs"><a href="#torch-potrs" class="headerlink" title="torch.potrs"></a>torch.potrs</h3><pre><code>torch.potrs()</code></pre><h3 id="torch-pstrf"><a href="#torch-pstrf" class="headerlink" title="torch.pstrf"></a>torch.pstrf</h3><pre><code>torch.pstrf()</code></pre><h3 id="torch-qr"><a href="#torch-qr" class="headerlink" title="torch.qr"></a>torch.qr</h3><pre><code>torch.qr(input, out=None) -&gt; (Tensor, Tensor)</code></pre><p>本函数返回一个thin(reduced)QR分解。</p><p><strong>注意</strong> 如果输入很大，可能可能会丢失精度。</p><p><strong>注意</strong> 本函数依赖于你的LAPACK实现，虽然总能返回一个合法的分解，但不同平台可能得到不同的结果。</p><p>Irrespective of the original strides, the returned matrix q will be transposed, i.e. with strides (1, m) instead of (m, 1).</p><p>参数：</p><ul><li>input (Tensor) – 输入的2维张量</li><li>out (tuple, optional) – 输出元组<code>tuple</code>，包含Q和R</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; a = torch.Tensor([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])&gt;&gt;&gt; q, r = torch.qr(a)&gt;&gt;&gt; q-0.8571  0.3943  0.3314-0.4286 -0.9029 -0.0343 0.2857 -0.1714  0.9429[torch.FloatTensor of size 3x3]&gt;&gt;&gt; r -14.0000  -21.0000   14.0000   0.0000 -175.0000   70.0000   0.0000    0.0000  -35.0000[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.mm(q, r).round()  12  -51    4   6  167  -68  -4   24  -41[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.mm(q.t(), q).round() 1 -0  0-0  1  0 0  0  1[torch.FloatTensor of size 3x3]</code></pre><h3 id="torch-svd"><a href="#torch-svd" class="headerlink" title="torch.svd"></a>torch.svd</h3><pre><code>torch.svd(input, some=True, out=None) -&gt; (Tensor, Tensor, Tensor)</code></pre><p><code>some</code> 代表了需要计算的奇异值数目。如果 <code>some=True</code>, it computes some and some=False computes all.</p><p>Irrespective of the original strides, the returned matrix U will be transposed, i.e. with strides (1, n) instead of (n, 1).</p><p>参数：</p><ul><li>input (Tensor) – 输入的2维张量</li><li>some (bool, optional) – 布尔值，控制需计算的奇异值数目</li><li>out (tuple, optional) – 结果<code>tuple</code></li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.Tensor([[8.79,  6.11, -9.15,  9.57, -3.49,  9.84],...                   [9.93,  6.91, -7.93,  1.64,  4.02,  0.15],...                   [9.83,  5.04,  4.86,  8.83,  9.80, -8.99],...                   [5.45, -0.27,  4.85,  0.74, 10.00, -6.02],...                   [3.16,  7.98,  3.01,  5.80,  4.27, -5.31]]).t()&gt;&gt;&gt; a  8.7900   9.9300   9.8300   5.4500   3.1600  6.1100   6.9100   5.0400  -0.2700   7.9800 -9.1500  -7.9300   4.8600   4.8500   3.0100  9.5700   1.6400   8.8300   0.7400   5.8000 -3.4900   4.0200   9.8000  10.0000   4.2700  9.8400   0.1500  -8.9900  -6.0200  -5.3100[torch.FloatTensor of size 6x5]&gt;&gt;&gt; u, s, v = torch.svd(a)&gt;&gt;&gt; u-0.5911  0.2632  0.3554  0.3143  0.2299-0.3976  0.2438 -0.2224 -0.7535 -0.3636-0.0335 -0.6003 -0.4508  0.2334 -0.3055-0.4297  0.2362 -0.6859  0.3319  0.1649-0.4697 -0.3509  0.3874  0.1587 -0.5183 0.2934  0.5763 -0.0209  0.3791 -0.6526[torch.FloatTensor of size 6x5]&gt;&gt;&gt; s 27.4687 22.6432  8.5584  5.9857  2.0149[torch.FloatTensor of size 5]&gt;&gt;&gt; v-0.2514  0.8148 -0.2606  0.3967 -0.2180-0.3968  0.3587  0.7008 -0.4507  0.1402-0.6922 -0.2489 -0.2208  0.2513  0.5891-0.3662 -0.3686  0.3859  0.4342 -0.6265-0.4076 -0.0980 -0.4932 -0.6227 -0.4396[torch.FloatTensor of size 5x5]&gt;&gt;&gt; torch.dist(a, torch.mm(torch.mm(u, torch.diag(s)), v.t()))8.934150226306685e-06</code></pre><h3 id="torch-symeig"><a href="#torch-symeig" class="headerlink" title="torch.symeig"></a>torch.symeig</h3><pre><code>torch.symeig(input, eigenvectors=False, upper=True, out=None) -&gt; (Tensor, Tensor)</code></pre><p><strong>注意</strong>: 不管原来Irrespective of the original strides, the returned matrix V will be transposed, i.e. with strides (1, m) instead of (m, 1)</p><p>参数：</p><ul><li>input (Tensor) – 输入对称矩阵</li><li>eigenvectors (boolean, optional) – 布尔值（可选），控制是否计算特征向量</li><li>upper (boolean, optional) – 布尔值（可选），控制是否考虑上三角或下三角区域</li><li>out (tuple, optional) – 输出元组(Tensor, Tensor)</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.Tensor([[ 1.96,  0.00,  0.00,  0.00,  0.00],...                   [-6.49,  3.80,  0.00,  0.00,  0.00],...                   [-0.47, -6.39,  4.17,  0.00,  0.00],...                   [-7.20,  1.50, -1.51,  5.70,  0.00],...                   [-0.65, -6.34,  2.67,  1.80, -7.10]]).t()&gt;&gt;&gt; e, v = torch.symeig(a, eigenvectors=True)&gt;&gt;&gt; e-11.0656 -6.2287  0.8640  8.8655 16.0948[torch.FloatTensor of size 5]&gt;&gt;&gt; v-0.2981 -0.6075  0.4026 -0.3745  0.4896-0.5078 -0.2880 -0.4066 -0.3572 -0.6053-0.0816 -0.3843 -0.6600  0.5008  0.3991-0.0036 -0.4467  0.4553  0.6204 -0.4564-0.8041  0.4480  0.1725  0.3108  0.1622[torch.FloatTensor of size 5x5]</code></pre><h3 id="torch-trtrs"><a href="#torch-trtrs" class="headerlink" title="torch.trtrs"></a>torch.trtrs</h3><pre><code> torch.trtrs()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-关键词动态爬取图片保存于本地</title>
      <link href="/posts/blog-python10.html"/>
      <url>/posts/blog-python10.html</url>
      
        <content type="html"><![CDATA[<h1 id="利用关键词动态爬取想要的图片"><a href="#利用关键词动态爬取想要的图片" class="headerlink" title="利用关键词动态爬取想要的图片"></a>利用关键词动态爬取想要的图片</h1><h3 id="导入相关库"><a href="#导入相关库" class="headerlink" title="导入相关库"></a>导入相关库</h3><p>主要是requests库</p><pre><code>import re  # 导入正则表达式模块import requests  # python HTTP客户端 编写爬虫和测试服务器经常用到的模块import random  # 随机生成一个数，范围[0,1]import os #创建路径</code></pre><h3 id="写爬虫爬取图片函数"><a href="#写爬虫爬取图片函数" class="headerlink" title="写爬虫爬取图片函数"></a>写爬虫爬取图片函数</h3><pre><code>def spiderPic(html, keyword):       #html：网页；keyword：关键词    print('正在查找 ' + keyword + ' 对应的图片,请稍后......')    for addr in re.findall('"objURL":"(.*?)"', html, re.S):  # 动态查找URL        print('正在爬取URL地址：' + str(addr)[0:40] + '...')  # 爬取的地址长度超过40时，用'...'代替后面的内容        try:            pics = requests.get(addr, timeout=10)  # 请求URL时间（最大10秒）        except requests.exceptions.ConnectionError:            print('您当前请求的URL地址出现错误')            continue        fq = open('E:\\img\\' + (keyword + '_' + str(random.randrange(0, 1000, 4)) + '.jpg'), 'wb')  # 下载图片，并保存和命名        fq.write(pics.content)        fq.close()</code></pre><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><pre><code>if __name__ == '__main__':    word = input('请输入你要搜索的图片关键字：')    result = requests.get(        # 通过百度引擎搜索关键词链接        'http://image.baidu.com/search/index?tn=baiduimage&amp;ps=1&amp;ct=201326592&amp;lm=-1&amp;cl=2&amp;nc=1&amp;ie=utf-8&amp;word=' + word)</code></pre><h3 id="存放图片文件夹创建"><a href="#存放图片文件夹创建" class="headerlink" title="存放图片文件夹创建"></a>存放图片文件夹创建</h3><p>加入判断是否存在该文件目录</p><pre><code>path='E:\\img\\';# 判断路径是否存在isExists = os.path.exists(path)### 判断结果if not isExists:    # 如果不存在则创建目录    # 创建目录操作函数    os.makedirs(path)    print    path + '创建成功'else:    # 如果目录存在则不创建，并提示目录已存在    print    path + ' 目录已存在'</code></pre><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><pre><code>spiderPic(result.text, word)</code></pre><h3 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h3><p>我们在输入提示后输入关键词 “风景”并开始爬取图片<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-15547726d83bbca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"><br>爬取的图片在img文件夹中</p><p>源码地址：<a href="https://github.com/JackHCC/KeyWord-Crawler" target="_blank" rel="noopener">https://github.com/JackHCC/KeyWord-Crawler</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-照片墙设计布局爱心形状</title>
      <link href="/posts/blog-python09.html"/>
      <url>/posts/blog-python09.html</url>
      
        <content type="html"><![CDATA[<h1 id="python照片墙设计"><a href="#python照片墙设计" class="headerlink" title="python照片墙设计"></a>python照片墙设计</h1><h3 id="代码规划："><a href="#代码规划：" class="headerlink" title="代码规划："></a>代码规划：</h3><ul><li>将爬虫爬取的图片进行处理，减小尺寸</li><li>将处理好的图片进行照片墙设计<h3 id="图片处理ImageSolve-py-批量处理"><a href="#图片处理ImageSolve-py-批量处理" class="headerlink" title="图片处理ImageSolve.py:批量处理"></a>图片处理ImageSolve.py:批量处理</h3></li><li>导入库：PIL:图像处理；glob<pre><code>from PIL import Imageimport os.pathimport glob</code></pre></li><li>定义ReSize函数：<pre><code>#由于爬虫获取的照片尺寸太大，我们更改爬虫获取的照片尺寸大小def Resize(file, outdir, width, height):  imgFile = Image.open(file)  try:      newImage = imgFile.resize((width, height), Image.BILINEAR)    #更改尺寸      newImage.save(os.path.join(outdir, os.path.basename(file)))     #输出保存图片  except Exception as e:      print(e)</code></pre></li><li>处理后照片的存储<pre><code>for file in glob.glob("res\\*.jpg"):  # 图片所在的目录  Resize(file, "new", 100, 100)  # 新图片存放的目录</code></pre><h3 id="照片墙展示"><a href="#照片墙展示" class="headerlink" title="照片墙展示"></a>照片墙展示</h3></li><li>导入库<pre><code>import sysfrom PyQt5.QtGui import QPixmapfrom PyQt5.QtWidgets import *</code></pre></li><li>Qt窗口基本创建<pre><code>app = QApplication(sys.argv)</code></pre></li></ul><p>win = QWidget()<br>win.resize(760, 540)<br>win.move(0, 0)<br>layout=QGridLayout(win)</p><p>positionSet()<br>win.setWindowTitle(‘GUI’)<br>win.show()</p><pre><code>+ 背景图设置</code></pre><p>b=QLabel(win)<br>b.setPixmap(QPixmap(“bg.jpg”))<br>b.setGeometry(0,0,820,640)</p><pre><code>+ 布局函数</code></pre><p>def positionSet():</p><p>```</p><h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-0d7f2df2852585b1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><p>源码地址：<a href="https://github.com/JackHCC/SlideShow" target="_blank" rel="noopener">https://github.com/JackHCC/SlideShow</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PIL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-机器学习Scikit-learn</title>
      <link href="/posts/blog-python08.html"/>
      <url>/posts/blog-python08.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h1><p><a href="http://sklearn.apachecn.org/#/" target="_blank" rel="noopener">官方中文文档</a></p><h1 id="机器学习方式"><a href="#机器学习方式" class="headerlink" title="机器学习方式"></a>机器学习方式</h1><p>机器学习可以分为以下五个大类：</p><p>(1 )监督学习：从给定的训练数据集中学习出-一个函数，当新的数据到来时，可以根据这个函数预测结果。监督学习的训练集要求是输人和输出，也可以说是特征和目标。训练集中的目标是由人标注的。常见的监督学习算法包括回归与分类。</p><p>(2)无监督学习：无监督学习与监督学习相比，训练集没有人为标注的结果。常见的无监督学习算法有聚类等。</p><p>(3)半监督学习：这是一”种介于监督学习与无监督学习之间的方法。</p><p>(4)迁移学习：将已经训练好的模型参数迁移到新的模型来帮助新模型训练数据集。</p><p>(5)增强学习：通过观察周围环境来学习。每个动作都会对环境有所影响，学习对象根据观察到的周围环境的反馈来做出判断。</p><h1 id="sklearn使用"><a href="#sklearn使用" class="headerlink" title="sklearn使用"></a>sklearn使用</h1><h2 id="1-获取数据"><a href="#1-获取数据" class="headerlink" title="1. 获取数据"></a>1. 获取数据</h2><h3 id="1-1-导入sklearn数据集"><a href="#1-1-导入sklearn数据集" class="headerlink" title="1.1 导入sklearn数据集"></a>1.1 导入sklearn数据集</h3><p>　　sklearn中包含了大量的优质的数据集，在你学习机器学习的过程中，你可以通过使用这些数据集实现出不同的模型，从而提高你的动手实践能力，同时这个过程也可以加深你对理论知识的理解和把握。（这一步我也亟需加强，一起加油！^-^）</p><p>首先呢，要想使用sklearn中的数据集，必须导入datasets模块：</p><pre><code>from sklearn import datasets</code></pre><p> 下图中包含了大部分sklearn中数据集，调用方式也在图中给出，这里我们拿iris的数据来举个例子：</p><p>　　<img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a9d7246ca1e92847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-c6aff0d49c840280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><pre><code>iris = datasets.load_iris() # 导入数据集X = iris.data # 获得其特征向量y = iris.target # 获得样本label</code></pre><h3 id="1-2-创建数据集"><a href="#1-2-创建数据集" class="headerlink" title="1.2 创建数据集"></a>1.2 创建数据集</h3><p>　　你除了可以使用sklearn自带的数据集，还可以自己去创建训练样本，具体用法参见《<a href="http://scikit-learn.org/stable/datasets/" target="_blank" rel="noopener">Dataset loading utilities</a>》，这里我们简单介绍一些，sklearn中的samples generator包含的大量创建样本数据的方法：</p><p>　　 <img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0253a891a44411bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-257e1464a9a2a74d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>下面我们拿分类问题的样本生成器举例子：</p><pre><code>from sklearn.datasets.samples_generator import make_classificationX, y = make_classification(n_samples=6, n_features=5, n_informative=2,     n_redundant=2, n_classes=2, n_clusters_per_class=2, scale=1.0,     random_state=20) # n_samples：指定样本数 # n_features：指定特征数 # n_classes：指定几分类 # random_state：随机种子，使得随机状可重</code></pre><pre><code>&gt;&gt;&gt; for x_,y_ in zip(X,y): print(y_,end=': ') print(x_)0: [-0.6600737  -0.0558978   0.82286793  1.1003977  -0.93493796] 1: [ 0.4113583   0.06249216 -0.90760075 -1.41296696  2.059838 ] 1: [ 1.52452016 -0.01867812  0.20900899  1.34422289 -1.61299022]0: [-1.25725859  0.02347952 -0.28764782 -1.32091378 -0.88549315]0: [-3.28323172  0.03899168 -0.43251277 -2.86249859 -1.10457948] 1: [ 1.68841011  0.06754955 -1.02805579 -0.83132182  0.93286635]</code></pre><h2 id="2-数据预处理"><a href="#2-数据预处理" class="headerlink" title="2. 数据预处理"></a>2. 数据预处理</h2><p>　　数据预处理阶段是机器学习中不可缺少的一环，它会使得数据更加有效的被模型或者评估器识别。下面我们来看一下sklearn中有哪些平时我们常用的函数：</p><pre><code>from sklearn import preprocessing</code></pre><h3 id="2-1-数据归一化"><a href="#2-1-数据归一化" class="headerlink" title="2.1 数据归一化"></a>2.1 数据归一化</h3><p>　　为了使得训练数据的标准化规则与测试数据的标准化规则同步，preprocessing中提供了很多Scaler：</p><pre><code>data = [[0, 0], [0, 0], [1, 1], [1, 1]] # 1\. 基于mean和std的标准化scaler = preprocessing.StandardScaler().fit(train_data)scaler.transform(train_data)scaler.transform(test_data) # 2\. 将每个特征值归一化到一个固定范围scaler = preprocessing.MinMaxScaler(feature_range=(0, 1)).fit(train_data)scaler.transform(train_data)scaler.transform(test_data) #feature_range: 定义归一化范围，注用（）括起来</code></pre><h3 id="2-2-正则化（normalize）"><a href="#2-2-正则化（normalize）" class="headerlink" title="2.2 正则化（normalize）"></a>2.2 正则化（<code>normalize</code>）</h3><p>　　当你想要计算两个样本的相似度时必不可少的一个操作，就是正则化。其思想是：首先求出样本的p-范数，然后该样本的所有元素都要除以该范数，这样最终使得每个样本的范数都为1。</p><pre><code>&gt;&gt;&gt; X = [[ 1., -1.,  2.],...      [ 2.,  0.,  0.],...      [ 0., 1., -1.]] &gt;&gt;&gt; X_normalized = preprocessing.normalize(X, norm='l2') &gt;&gt;&gt; X_normalized                                      array([[ 0.40..., -0.40...,  0.81...],       [ 1.  ...,  0\.  ...,  0\.  ...],       [ 0\.  ..., 0.70..., -0.70...]])</code></pre><h3 id="2-3-one-hot编码"><a href="#2-3-one-hot编码" class="headerlink" title="2.3 one-hot编码"></a>2.3 one-hot编码</h3><p>　　one-hot编码是一种对离散特征值的编码方式，在LR模型中常用到，用于给线性模型增加非线性能力。</p><pre><code>data = [[0, 0, 3], [1, 1, 0], [0, 2, 1], [1, 0, 2]]encoder = preprocessing.OneHotEncoder().fit(data)enc.transform(data).toarray()</code></pre><h2 id="3-数据集拆分"><a href="#3-数据集拆分" class="headerlink" title="3. 数据集拆分"></a>3. 数据集拆分</h2><p>　　在得到训练数据集时，通常我们经常会把训练数据集进一步拆分成训练集和验证集，这样有助于我们模型参数的选取。</p><pre><code># 作用：将数据集划分为 训练集和测试集 # 格式：train_test_split(*arrays, **options)from sklearn.mode_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42) """ 参数           返回---arrays：样本数组，包含特征向量和标签test_size：　　float-获得多大比重的测试样本 （默认：0.25）　　int - 获得多少个测试样本train_size: 同test_sizerandom_state:　　int - 随机种子（种子固定，实验可复现）shuffle - 是否在分割之前对数据进行洗牌（默认True）分割后的列表，长度=2*len(arrays), 　　(train-test split) """</code></pre><h2 id="4-定义模型"><a href="#4-定义模型" class="headerlink" title="4. 定义模型"></a>4. 定义模型</h2><p>　　在这一步我们首先要分析自己数据的类型，搞清出你要用什么模型来做，然后我们就可以在sklearn中定义模型了。sklearn为所有模型提供了非常相似的接口，这样使得我们可以更加快速的熟悉所有模型的用法。在这之前我们先来看看模型的常用属性和功能：</p><pre><code># 拟合模型model.fit(X_train, y_train) # 模型预测model.predict(X_test) # 获得这个模型的参数model.get_params() # 为模型进行打分model.score(data_X, data_y) # 线性回归：R square； 分类问题： acc</code></pre><h3 id="4-1-线性回归"><a href="#4-1-线性回归" class="headerlink" title="4.1 线性回归"></a>4.1 线性回归</h3><pre><code>from sklearn.linear_model import LinearRegression # 定义线性回归模型model = LinearRegression(fit_intercept=True, normalize=False,     copy_X=True, n_jobs=1) """ 参数---    fit_intercept：是否计算截距。False-模型没有截距    normalize： 当fit_intercept设置为False时，该参数将被忽略。 如果为真，则回归前的回归系数X将通过减去平均值并除以l2-范数而归一化。     n_jobs：指定线程数 """</code></pre><p>　　　　　　<img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-fe12917cfabb9875.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="4-2-逻辑回归LR"><a href="#4-2-逻辑回归LR" class="headerlink" title="4.2 逻辑回归LR"></a>4.2 逻辑回归LR</h3><pre><code>from sklearn.linear_model import LogisticRegression # 定义逻辑回归模型model = LogisticRegression(penalty=’l2’, dual=False, tol=0.0001, C=1.0,     fit_intercept=True, intercept_scaling=1, class_weight=None,     random_state=None, solver=’liblinear’, max_iter=100, multi_class=’ovr’,     verbose=0, warm_start=False, n_jobs=1) """参数---    penalty：使用指定正则化项（默认：l2）    dual: n_samples &gt; n_features取False（默认）    C：正则化强度的反，值越小正则化强度越大    n_jobs: 指定线程数    random_state：随机数生成器    fit_intercept: 是否需要常量 """</code></pre><h3 id="4-3-朴素贝叶斯算法NB"><a href="#4-3-朴素贝叶斯算法NB" class="headerlink" title="4.3 朴素贝叶斯算法NB"></a>4.3 朴素贝叶斯算法NB</h3><pre><code>from sklearn import naive_bayesmodel = naive_bayes.GaussianNB() # 高斯贝叶斯model = naive_bayes.MultinomialNB(alpha=1.0, fit_prior=True, class_prior=None)model = naive_bayes.BernoulliNB(alpha=1.0, binarize=0.0, fit_prior=True, class_prior=None) """ 文本分类问题常用MultinomialNB参数---    alpha：平滑参数    fit_prior：是否要学习类的先验概率；false-使用统一的先验概率    class_prior: 是否指定类的先验概率；若指定则不能根据参数调整    binarize: 二值化的阈值，若为None，则假设输入由二进制向量组成 """</code></pre><h3 id="4-4-决策树DT"><a href="#4-4-决策树DT" class="headerlink" title="4.4 决策树DT"></a>4.4 决策树DT</h3><pre><code>from sklearn import tree model = tree.DecisionTreeClassifier(criterion=’gini’, max_depth=None,     min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0,     max_features=None, random_state=None, max_leaf_nodes=None,     min_impurity_decrease=0.0, min_impurity_split=None,     class_weight=None, presort=False) """参数---    criterion ：特征选择准则gini/entropy    max_depth：树的最大深度，None-尽量下分    min_samples_split：分裂内部节点，所需要的最小样本树    min_samples_leaf：叶子节点所需要的最小样本数    max_features: 寻找最优分割点时的最大特征数    max_leaf_nodes：优先增长到最大叶子节点数    min_impurity_decrease：如果这种分离导致杂质的减少大于或等于这个值，则节点将被拆分。 """</code></pre><h3 id="4-5-支持向量机SVM"><a href="#4-5-支持向量机SVM" class="headerlink" title="4.5 支持向量机SVM"></a>4.5 支持向量机SVM</h3><pre><code>from sklearn.svm import SVCmodel = SVC(C=1.0, kernel=’rbf’, gamma=’auto’) """参数---    C：误差项的惩罚参数C    gamma: 核相关系数。浮点数，If gamma is ‘auto’ then 1/n_features will be used instead. """</code></pre><h3 id="4-6-k近邻算法KNN"><a href="#4-6-k近邻算法KNN" class="headerlink" title="4.6 k近邻算法KNN"></a>4.6 k近邻算法KNN</h3><pre><code>from sklearn import neighbors #定义kNN分类模型model = neighbors.KNeighborsClassifier(n_neighbors=5, n_jobs=1) # 分类model = neighbors.KNeighborsRegressor(n_neighbors=5, n_jobs=1) # 回归"""参数---    n_neighbors： 使用邻居的数目    n_jobs：并行任务数 """</code></pre><h3 id="4-7-多层感知机（神经网络）"><a href="#4-7-多层感知机（神经网络）" class="headerlink" title="4.7 多层感知机（神经网络）"></a>4.7 多层感知机（神经网络）</h3><pre><code>from sklearn.neural_network import MLPClassifier # 定义多层感知机分类算法model = MLPClassifier(activation='relu', solver='adam', alpha=0.0001) """参数---    hidden_layer_sizes: 元祖    activation：激活函数    solver ：优化算法{‘lbfgs’, ‘sgd’, ‘adam’}    alpha：L2惩罚(正则化项)参数。 """</code></pre><h2 id="5-模型评估与选择篇"><a href="#5-模型评估与选择篇" class="headerlink" title="5. 模型评估与选择篇"></a>5. 模型评估与选择篇</h2><h3 id="5-1-交叉验证"><a href="#5-1-交叉验证" class="headerlink" title="5.1 交叉验证"></a>5.1 交叉验证</h3><pre><code>from sklearn.model_selection import cross_val_scorecross_val_score(model, X, y=None, scoring=None, cv=None, n_jobs=1) """参数---    model：拟合数据的模型    cv ： k-fold    scoring: 打分参数-‘accuracy’、‘f1’、‘precision’、‘recall’ 、‘roc_auc’、'neg_log_loss'等等 """</code></pre><h3 id="5-2-检验曲线"><a href="#5-2-检验曲线" class="headerlink" title="5.2 检验曲线"></a>5.2 检验曲线</h3><p>　　使用检验曲线，我们可以更加方便的改变模型参数，获取模型表现。</p><pre><code>from sklearn.model_selection import validation_curvetrain_score, test_score = validation_curve(model, X, y, param_name, param_range, cv=None, scoring=None, n_jobs=1) """参数---    model:用于fit和predict的对象    X, y: 训练集的特征和标签    param_name：将被改变的参数的名字    param_range： 参数的改变范围    cv：k-fold返回值---   train_score: 训练集得分（array）    test_score: 验证集得分（array） """</code></pre><p><a href="http://scikit-learn.org/stable/auto_examples/model_selection/plot_validation_curve.html#sphx-glr-auto-examples-model-selection-plot-validation-curve-py" target="_blank" rel="noopener">例子</a></p><h2 id="6-保存模型"><a href="#6-保存模型" class="headerlink" title="6. 保存模型"></a>6. 保存模型</h2><p>　　最后，我们可以将我们训练好的model保存到本地，或者放到线上供用户使用，那么如何保存训练好的model呢？主要有下面两种方式：</p><h3 id="6-1-保存为pickle文件"><a href="#6-1-保存为pickle文件" class="headerlink" title="6.1 保存为pickle文件"></a>6.1 保存为pickle文件</h3><pre><code>import pickle # 保存模型with open('model.pickle', 'wb') as f:    pickle.dump(model, f) # 读取模型with open('model.pickle', 'rb') as f:    model = pickle.load(f)model.predict(X_test)</code></pre><h3 id="6-2-sklearn自带方法joblib"><a href="#6-2-sklearn自带方法joblib" class="headerlink" title="6.2 sklearn自带方法joblib"></a>6.2 sklearn自带方法joblib</h3><pre><code>from sklearn.externals import joblib # 保存模型joblib.dump(model, 'model.pickle') #载入模型model = joblib.load('model.pickle')</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Matplotlib数据可视化</title>
      <link href="/posts/blog-python07.html"/>
      <url>/posts/blog-python07.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://link.jianshu.com/?t=https://www.gitbook.com/book/wizardforcel/matplotlib-intro-tut/details" target="_blank" rel="noopener">在线阅读</a></li><li><a href="https://link.jianshu.com/?t=https://www.gitbook.com/download/pdf/book/wizardforcel/matplotlib-intro-tut" target="_blank" rel="noopener">PDF格式</a></li><li><a href="https://link.jianshu.com/?t=https://www.gitbook.com/download/epub/book/wizardforcel/matplotlib-intro-tut" target="_blank" rel="noopener">EPUB格式</a></li><li><a href="https://link.jianshu.com/?t=https://www.gitbook.com/download/mobi/book/wizardforcel/matplotlib-intro-tut" target="_blank" rel="noopener">MOBI格式</a></li><li><a href="https://link.jianshu.com/?t=https://github.com/wizardforcel/matplotlib-intro-tut-zh" target="_blank" rel="noopener">代码仓库</a><h1 id="第一章-Matplotlib-简介"><a href="#第一章-Matplotlib-简介" class="headerlink" title="第一章 Matplotlib 简介"></a>第一章 Matplotlib 简介</h1></li></ul><p>这里涉及Matplotlib 数据可视化模块的多个方面。 Matplotlib 能够创建多数类型的图表，如条形图，散点图，条形图，饼图，堆叠图，3D 图和地图图表。</p><p>首先，为了实际使用 Matplotlib，我们需要安装它。</p><p>如果你安装了更高版本的 Python，你应该能够打开<code>cmd.exe</code>或终端，然后执行：</p><pre><code>pip install matplotlib</code></pre><p>注意：如果上面的较短命令不工作，你可能需要执行<code>C:/Python34/Scripts/pip install matplotlib</code>。</p><p>如果在导入<code>matplotlib</code>时，你会收到类似『无命名模块』和模块名称的错误，这意味着你还需要安装该模块。 一个常见的问题是缺少名为<code>six</code>的模块。 这意味着你需要使用<code>pip</code>安装<code>six</code>。</p><p>或者，你可以前往 Matplotlib.org 并通过访问下载页面下载适当的版本进行安装。 请记住，因为你的操作系统为 64 位，你不一定需要 64 位版本的 Python。 如果你不打算尝试 64 位，你可以使用 32 位。 打开 IDLE 并阅读顶部。 如果它说你是 64 位，你就是 64 位，如果它说是 32 位，那么你就是 32 位。 一旦你安装了 Python，你就做好了准备，你可以编写任何你想要的逻辑。 我喜欢使用 IDLE 来编程，但你可以随意使用任何你喜欢的东西。</p><pre><code>import matplotlib.pyplot as plt</code></pre><p>这一行导入集成的<code>pyplot</code>，我们将在整个系列中使用它。 我们将<code>pyplot</code>导入为<code>plt</code>，这是使用<code>pylot</code>的 python 程序的传统惯例。</p><pre><code>plt.plot([1,2,3],[5,7,4])</code></pre><p>接下来，我们调用<code>plot</code>的<code>.plot</code>方法绘制一些坐标。 这个<code>.plot</code>需要许多参数，但前两个是<code>'x'</code>和<code>'y'</code>坐标，我们放入列表。 这意味着，根据这些列表我们拥有 3 个坐标：<code>1,5</code> <code>2,7</code>和<code>3,4</code>。</p><p><code>plt.plot</code>在后台『绘制』这个绘图，但绘制了我们想要的一切之后，当我们准备好的时候，我们需要把它带到屏幕上。</p><pre><code>plt.show()</code></pre><p>这样，应该弹出一个图形。 如果没有，有时它可以弹出，或者你可能得到一个错误。 你的图表应如下所示：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-fd9dc5b819eee2af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这个窗口是一个 matplotlib 窗口，它允许我们查看我们的图形，以及与它进行交互和访问。 你可以将鼠标悬停在图表上，并查看通常在右下角的坐标。 你也可以使用按钮。 它们可能在不同的位置，但在上图中，这些按钮在左下角。</p><h2 id="Home（主页）"><a href="#Home（主页）" class="headerlink" title="Home（主页）"></a><code>Home</code>（主页）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-ab1c99dc1ef372d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>一旦你开始浏览你的图表，主页按钮会帮助你。 如果你想要返回原始视图，可以单击它。 在浏览图表之前单击此按钮将不会生效。</p><h2 id="Forward-Back（前进-后退）"><a href="#Forward-Back（前进-后退）" class="headerlink" title="Forward/Back（前进/后退）"></a><code>Forward/Back</code>（前进/后退）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-99b6fdd250908e9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这些按钮可以像浏览器中的前进和后退按钮一样使用。 你可以单击这些来移回到你之前的位置，或再次前进。</p><h2 id="Pan（平移）"><a href="#Pan（平移）" class="headerlink" title="Pan（平移）"></a><code>Pan</code>（平移）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-38a450e6ab426002.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>你可以点击平移按钮，之后点击并拖拽你的图表。</p><h2 id="Zoom（缩放）"><a href="#Zoom（缩放）" class="headerlink" title="Zoom（缩放）"></a><code>Zoom</code>（缩放）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-986d4901b894c101.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>缩放按钮可让你单击它，然后单击并拖动出要放大的方形区域。 放大需要左键单击并拖动。 你也可以右键单击并拖动来缩小。</p><h2 id="Configure-Subplots（配置子图）"><a href="#Configure-Subplots（配置子图）" class="headerlink" title="Configure Subplots（配置子图）"></a><code>Configure Subplots</code>（配置子图）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-cf8ab1dd29554afc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>此按钮允许你对图形和绘图配置各种间距选项。 点击它会弹出：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-97d5ced902265b4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>每个蓝色条形都是一个滑块，它允许你调整内边距。 其中有些现在没有任何效果，因为没有任何其他子图。 前四个值调整图形到窗口边缘的边距。 之后<code>wspace</code>和<code>hspace</code>对应于当你绘制多个子图时，它们的水平或竖直间距。</p><h2 id="Save（保存）"><a href="#Save（保存）" class="headerlink" title="Save（保存）"></a><code>Save</code>（保存）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0e48f4e59778e08a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>此按钮允许你以各种形式保存图形。</p><p>所以这是 matplotlib 的快速介绍，我们之后会涉及更多。</p><h1 id="第二章-图例、标题和标签"><a href="#第二章-图例、标题和标签" class="headerlink" title="第二章 图例、标题和标签"></a>第二章 图例、标题和标签</h1><p>在本教程中，我们将讨论 Matplotlib 中的图例，标题和标签。 很多时候，图形可以不言自明，但是图形带有标题，轴域上的标签和图例，来解释每一行是什么非常必要。</p><blockquote><p>注：轴域（<code>Axes</code>）即两条坐标轴围城的区域。</p></blockquote><p>从这里开始：</p><pre><code>import matplotlib.pyplot as pltx = [1,2,3]y = [5,7,4]x2 = [1,2,3]y2 = [10,14,12]</code></pre><p>这样我们可以画出两个线条，接下来：</p><pre><code>plt.plot(x, y, label='First Line')plt.plot(x2, y2, label='Second Line')</code></pre><p>在这里，我们绘制了我们已经看到的东西，但这次我们添加另一个参数<code>label</code>。 这允许我们为线条指定名称，我们以后可以在图例中显示它。 我们的其余代码为：</p><pre><code>plt.xlabel('Plot Number')plt.ylabel('Important var')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p>使用<code>plt.xlabel</code>和<code>plt.ylabel</code>，我们可以为这些相应的轴创建标签。 接下来，我们可以使用<code>plt.title</code>创建图的标题，然后我们可以使用<code>plt.legend()</code>生成默认图例。 结果图如下：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-74fabfe13552bc2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第三章-条形图和直方图"><a href="#第三章-条形图和直方图" class="headerlink" title="第三章 条形图和直方图"></a>第三章 条形图和直方图</h1><p>这个教程中我们会涉及条形图和直方图。我们先来看条形图：</p><pre><code>import matplotlib.pyplot as pltplt.bar([1,3,5,7,9],[5,2,7,8,2], label="Example one")plt.bar([2,4,6,8,10],[8,6,2,5,6], label="Example two", color='g')plt.legend()plt.xlabel('bar number')plt.ylabel('bar height')plt.title('Epic Graph\nAnother Line! Whoa')plt.show()</code></pre><p><code>plt.bar</code>为我们创建条形图。 如果你没有明确选择一种颜色，那么虽然做了多个图，所有的条看起来会一样。 这让我们有机会使用一个新的 Matplotlib 自定义选项。 你可以在任何类型的绘图中使用颜色，例如<code>g</code>为绿色，<code>b</code>为蓝色，<code>r</code>为红色，等等。 你还可以使用十六进制颜色代码，如<code>#191970</code>。</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-52b8c12da35ac96d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>接下来，我们会讲解直方图。 直方图非常像条形图，倾向于通过将区段组合在一起来显示分布。 这个例子可能是年龄的分组，或测试的分数。 我们并不是显示每一组的年龄，而是按照 20 ~ 25，25 ~ 30… 等等来显示年龄。 这里有一个例子：</p><pre><code>import matplotlib.pyplot as pltpopulation_ages = [22,55,62,45,21,22,34,42,42,4,99,102,110,120,121,122,130,111,115,112,80,75,65,54,44,43,42,48]bins = [0,10,20,30,40,50,60,70,80,90,100,110,120,130]plt.hist(population_ages, bins, histtype='bar', rwidth=0.8)plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p>产生的图表为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-f9bc20699e3270fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>对于<code>plt.hist</code>，你首先需要放入所有的值，然后指定放入哪个桶或容器。 在我们的例子中，我们绘制了一堆年龄，并希望以 10 年的增量来显示它们。 我们将条形的宽度设为 0.8，但是如果你想让条形变宽，或者变窄，你可以选择其他的宽度。</p><h1 id="第四章-散点图"><a href="#第四章-散点图" class="headerlink" title="第四章 散点图"></a>第四章 散点图</h1><p>接下来，我们将介绍散点图。散点图通常用于比较两个变量来寻找相关性或分组，如果你在 3 维绘制则是 3 个。</p><p>散点图的一些示例代码：</p><pre><code>import matplotlib.pyplot as pltx = [1,2,3,4,5,6,7,8]y = [5,2,4,2,1,4,5,2]plt.scatter(x,y, label='skitscat', color='k', s=25, marker="o")plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-65aedb5516804258.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><code>plt.scatter</code>不仅允许我们绘制<code>x</code>和<code>y</code>，而且还可以让我们决定所使用的标记颜色，大小和类型。 有一堆标记选项，请参阅 <a href="https://link.jianshu.com?t=http://matplotlib.org/api/markers_api.html" target="_blank" rel="noopener">Matplotlib 标记文档</a>中的所有选项。</p><h1 id="第五章-堆叠图"><a href="#第五章-堆叠图" class="headerlink" title="第五章 堆叠图"></a>第五章 堆叠图</h1><p>在这篇 Matplotlib 数据可视化教程中，我们要介绍如何创建堆叠图。 堆叠图用于显示『部分对整体』随时间的关系。 堆叠图基本上类似于饼图，只是随时间而变化。</p><p>让我们考虑一个情况，我们一天有 24 小时，我们想看看我们如何花费时间。 我们将我们的活动分为：睡觉，吃饭，工作和玩耍。</p><p>我们假设我们要在 5 天的时间内跟踪它，因此我们的初始数据将如下所示：</p><pre><code>import matplotlib.pyplot as pltdays = [1,2,3,4,5]sleeping = [7,8,6,11,7]eating =   [2,3,4,3,2]working =  [7,8,7,2,2]playing =  [8,5,7,8,13]</code></pre><p>因此，我们的<code>x</code>轴将包括<code>day</code>变量，即 1, 2, 3, 4 和 5。然后，日期的各个成分保存在它们各自的活动中。 像这样绘制它们：</p><pre><code>plt.stackplot(days, sleeping,eating,working,playing, colors=['m','c','r','k'])plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-e840375ace5b8641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>在这里，我们可以至少在颜色上看到，我们如何花费我们的时间。 问题是，如果不回头看代码，我们不知道什么颜色是什么。 下一个问题是，对于多边形来说，我们实际上不能为数据添加『标签』。 因此，在任何不止是线条，带有像这样的填充或堆叠图的地方，我们不能以固有方式标记出特定的部分。 这不应该阻止程序员。 我们可以解决这个问题：</p><pre><code>import matplotlib.pyplot as pltdays = [1,2,3,4,5]sleeping = [7,8,6,11,7]eating =   [2,3,4,3,2]working =  [7,8,7,2,2]playing =  [8,5,7,8,13]plt.plot([],[],color='m', label='Sleeping', linewidth=5)plt.plot([],[],color='c', label='Eating', linewidth=5)plt.plot([],[],color='r', label='Working', linewidth=5)plt.plot([],[],color='k', label='Playing', linewidth=5)plt.stackplot(days, sleeping,eating,working,playing, colors=['m','c','r','k'])plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0e5233d43903c2a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>我们在这里做的是画一些空行，给予它们符合我们的堆叠图的相同颜色，和正确标签。 我们还使它们线宽为 5，使线条在图例中显得较宽。 现在，我们可以很容易地看到，我们如何花费我们的时间。</p><h1 id="第六章-饼图"><a href="#第六章-饼图" class="headerlink" title="第六章 饼图"></a>第六章 饼图</h1><p>饼图很像堆叠图，只是它们位于某个时间点。 通常，饼图用于显示部分对于整体的情况，通常以％为单位。 幸运的是，Matplotlib 会处理切片大小以及一切事情，我们只需要提供数值。</p><pre><code>import matplotlib.pyplot as pltslices = [7,2,2,13]activities = ['sleeping','eating','working','playing']cols = ['c','m','r','b']plt.pie(slices,        labels=activities,        colors=cols,        startangle=90,        shadow= True,        explode=(0,0.1,0,0),        autopct='%1.1f%%')plt.title('Interesting Graph\nCheck it out')plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-f22a951b92ef4824.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>在<code>plt.pie</code>中，我们需要指定『切片』，这是每个部分的相对大小。 然后，我们指定相应切片的颜色列表。 接下来，我们可以选择指定图形的『起始角度』。 这使你可以在任何地方开始绘图。 在我们的例子中，我们为饼图选择了 90 度角，这意味着第一个部分是一个竖直线条。 接下来，我们可以选择给绘图添加一个字符大小的阴影，然后我们甚至可以使用<code>explode</code>拉出一个切片。</p><p>我们总共有四个切片，所以对于<code>explode</code>，如果我们不想拉出任何切片，我们传入<code>0,0,0,0</code>。 如果我们想要拉出第一个切片，我们传入<code>0.1,0,0,0</code>。</p><p>最后，我们使用<code>autopct</code>，选择将百分比放置到图表上面。</p><h1 id="第七章-从文件加载数据"><a href="#第七章-从文件加载数据" class="headerlink" title="第七章 从文件加载数据"></a>第七章 从文件加载数据</h1><p>很多时候，我们想要绘制文件中的数据。 有许多类型的文件，以及许多方法，你可以使用它们从文件中提取数据来图形化。 在这里，我们将展示几种方法。 首先，我们将使用内置的<code>csv</code>模块加载CSV文件，然后我们将展示如何使用 NumPy（第三方模块）加载文件。</p><pre><code>import matplotlib.pyplot as pltimport csvx = []y = []with open('example.txt','r') as csvfile:    plots = csv.reader(csvfile, delimiter=',')    for row in plots:        x.append(int(row[0]))        y.append(int(row[1]))plt.plot(x,y, label='Loaded from file!')plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-5cdf1d5247930ab3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这里，我们打开样例文件，包含以下数据：</p><pre><code>1,52,33,44,75,46,37,58,79,410,4</code></pre><p>接下来，我们使用<code>csv</code>模块读取数据。 <code>csv</code>读取器自动按行分割文件，然后使用我们选择的分隔符分割文件中的数据。 在我们的例子中，这是一个逗号。 注意：<code>csv</code>模块和<code>csv reader</code>不需要文件在字面上是一个.csv文件。 它可以是任何具有分隔数据的简单的文本文件。</p><p>一旦我们这样做了，我们将索引为 0 的元素存储到<code>x</code>列表，将索引为 1 的元素存储到<code>y</code>列表中。 之后，我们都设置好了，准备绘图，然后显示数据。</p><p>虽然使用 CSV 模块是完全正常的，但使用 NumPy 模块来加载我们的文件和数据，可能对我们更有意义。 如果你没有 NumPy，你需要按下面的步骤来获取它。 为了了解安装模块的更多信息，请参阅 <a href="https://link.jianshu.com?t=http://pythonprogramming.net/using-pip-install-for-python-modules/" target="_blank" rel="noopener">pip 教程</a>。 大多数人应该都能打开命令行，并执行<code>pip install numpy</code>。</p><p>如果不能，请参阅链接中的教程。</p><p>一旦你安装了 NumPy，你可以编写如下代码：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npx, y = np.loadtxt('example.txt', delimiter=',', unpack=True)plt.plot(x,y, label='Loaded from file!')plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p>结果应该是相同的图表。 稍后，当我们加载数据时，我们可以利用 NumPy 为我们做一些更多的工作，但这是教程未来的内容。 就像<code>csv</code>模块不需要一个特地的<code>.csv</code>一样，<code>loadtxt</code>函数不要求文件是一个<code>.txt</code>文件，它可以是一个<code>.csv</code>，它甚至可以是一个 python 列表对象。</p><h1 id="第八章-从网络加载数据"><a href="#第八章-从网络加载数据" class="headerlink" title="第八章 从网络加载数据"></a>第八章 从网络加载数据</h1><p>除了从文件加载数据，另一个流行的数据源是互联网。 我们可以用各种各样的方式从互联网加载数据，但对我们来说，我们只是简单地读取网站的源代码，然后通过简单的拆分来分离数据。</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport matplotlib.dates as mdatesdef graph_data(stock):    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line:                stock_data.append(line)</code></pre><p>这里有很多步骤。首先，我们看到<code>import</code>。 <code>pyplot</code>像往常一样导入，然后导入了<code>numpy</code>，然后是用于访问互联网的<code>urllib</code>，然后导入了<code>matplotlib.dates</code>作为<code>mdates</code>，它对于将日期戳转换为 matplotlib 可以理解的日期很有用。</p><p>接下来，我们开始构建我们的<code>graph_data</code>函数。在这里，我们首先定义包含股票数据的网址。之后，我们写一些<code>urllib</code>代码来访问该 URL，然后使用<code>.read</code>读取源代码，之后我们继续解码该数据。如果你使用 Python 2，则不必使用<code>decode</code>。</p><p>然后，我们定义一个空列表，这是我们将要放置股票数据的地方，我们也开始使用<code>split_source</code>变量拆分数据，以换行符拆分。</p><p>现在，如果你去看源代码，用<code>stock</code>替换 URL 中的<code>+stock+</code>，像 AAPL 那样，你可以看到大多数页面数据确实是股票定价信息，但有一些头信息我们需要过滤掉。为此，我们使用一些基本的过滤，检查它们来确保每行有 6 个数据点，然后确保术语<code>values</code>不在行中。</p><p>现在，我们已经解析了数据，并做好了准备。我们将使用 NumPy：</p><pre><code>date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                      delimiter=',',                                                      unpack=True,                                                      # %Y = full year. 2015                                                      # %y = partial year 15                                                      # %m = number month                                                      # %d = number day                                                      # %H = hours                                                      # %M = minutes                                                      # %S = seconds                                                      # 12-06-2014                                                      # %m-%d-%Y                                                      converters={0: bytespdate2num('%Y%m%d')})</code></pre><p>我们在这里所做的是，使用<code>numpy</code>的<code>loadtxt</code>函数，并将这六个元素解构到六个变量。 这里的第一个参数是<code>stock_data</code>，这是我们加载的数据。 然后，我们指定<code>delimiter</code>（这里是逗号），然后我们指定我们确实想要在这里解包变量，不是一个变量，而是我们定义的这组变量。 最后，我们使用可选的<code>converters</code>参数来指定我们要转换的元素（<code>0</code>），以及我们打算要怎么做。 我们传递一个名为<code>bytespdate2num</code>的函数，它还不存在，但我们下面会编写它。</p><h1 id="第九章-时间戳的转换"><a href="#第九章-时间戳的转换" class="headerlink" title="第九章 时间戳的转换"></a>第九章 时间戳的转换</h1><p>本教程的重点是将来自 Yahoo finance API 的日期转换为 Matplotlib 可理解的日期。 为了实现它，我们要写一个新的函数，<code>bytespdate2num</code>。</p><pre><code>def bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverter</code></pre><p>此函数接受数据，基于编码来解码数据，然后返回它。</p><p>将此应用于我们的程序的其余部分：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          # %Y = full year. 2015                                                          # %y = partial year 15                                                          # %m = number month                                                          # %d = number day                                                          # %H = hours                                                          # %M = minutes                                                          # %S = seconds                                                          # 12-06-2014                                                          # %m-%d-%Y                                                          converters={0: bytespdate2num('%Y%m%d')})    plt.plot_date(date, closep,'-', label='Price')    plt.xlabel('Date')    plt.ylabel('Price')    plt.title('Interesting Graph\nCheck it out')    plt.legend()    plt.show()graph_data('TSLA')</code></pre><p>如果你绘制 TSLA，结果图应该看起来像这样：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-4ecbc2e94a4d3abc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第十章-基本的自定义"><a href="#第十章-基本的自定义" class="headerlink" title="第十章 基本的自定义"></a>第十章 基本的自定义</h1><p>在 Matplotlib 教程中，我们将讨论一些可能的图表自定义。 为了开始修改子图，我们必须定义它们。 我们很快会谈论他们，但有两种定义并构造子图的主要方法。 现在，我们只使用其中一个，但我们会很快解释它们。</p><p>现在，修改我们的<code>graph_data</code>函数：</p><pre><code>def graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))</code></pre><p>为了修改图表，我们需要引用它，所以我们将它存储到变量<code>fig</code>。 然后我们将<code>ax1</code>定义为图表上的子图。 我们在这里使用<code>subplot2grid</code>，这是获取子图的两种主要方法之一。 我们将深入讨论这些东西，但现在，你应该看到我们有 2 个元组，它们提供了<code>(1,1)</code>和<code>(0,0)</code>。 <code>1,1</code>表明这是一个 1×1 网格。 然后<code>0,0</code>表明这个子图的『起点』将为<code>0,0</code>。</p><p>接下来，通过我们已经编写的代码来获取和解析数据：</p><pre><code>stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'source_code = urllib.request.urlopen(stock_price_url).read().decode()stock_data = []split_source = source_code.split('\n')for line in split_source:    split_line = line.split(',')    if len(split_line) == 6:        if 'values' not in line and 'labels' not in line:            stock_data.append(line)date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                      delimiter=',',                                                      unpack=True,                                                      converters={0: bytespdate2num('%Y%m%d')})</code></pre><p>下面，我们这样绘制数据：</p><pre><code>ax1.plot_date(date, closep,'-', label='Price')</code></pre><p>现在，由于我们正在绘制日期，我们可能会发现，如果我们放大，日期会在水平方向上移动。但是，我们可以自定义这些刻度标签，像这样：</p><pre><code>for label in ax1.xaxis.get_ticklabels():    label.set_rotation(45)</code></pre><p>这将使标签转动到对角线方向。 接下来，我们可以添加一个网格：</p><pre><code>ax1.grid(True)</code></pre><p>然后，其它东西我们保留默认，但我们也可能需要略微调整绘图，因为日期跑到了图表外面。 记不记得我们在第一篇教程中讨论的<code>configure subplots</code>按钮？ 我们不仅可以以这种方式配置图表，我们还可以在代码中配置它们，以下是我们设置这些参数的方式：</p><pre><code>plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)</code></pre><p>现在，为了防止我们把你遗留在某个地方，这里是完整的代码：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    ax1.plot_date(date, closep,'-', label='Price')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.grid(True)#, color='g', linestyle='-', linewidth=5)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title('Interesting Graph\nCheck it out')    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('TSLA')</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-e13743e9a0142564.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第十一章-Unix-时间"><a href="#第十一章-Unix-时间" class="headerlink" title="第十一章 Unix 时间"></a>第十一章 Unix 时间</h1><p>在这个 Matplotlib 教程中，我们将介绍如何处理 unix 时间戳的转换，然后在图形中绘制日期戳。 使用 Yahoo Finance API，你会注意到，如果你使用较大的时间间隔，如<code>1y</code>（一年），你会得到我们一直在使用的日期戳，但如果你使用<code>10d</code>（10 天），反之你会得到 unix 时间的时间戳。</p><p>Unix 时间是 1970 年 1 月 1 日以后的秒数，它是跨程序的标准化时间表示方法。 也就是说，Matplotlib 并不欢迎 unix 时间戳。 这里是你可以使用 Matplotlib 来处理 unix 时间的方式：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10d/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True)    dateconv = np.vectorize(dt.datetime.fromtimestamp)    date = dateconv(date)##    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,##                                                          delimiter=',',##                                                          unpack=True,##                                                          converters={0: bytespdate2num('%Y%m%d')})    ax1.plot_date(date, closep,'-', label='Price')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.grid(True)#, color='g', linestyle='-', linewidth=5)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title('Interesting Graph\nCheck it out')    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('TSLA')</code></pre><p>所以在这里，我们所做的是 unix 时间的写入处理，并注释掉我们以前的代码，因为我们为之后的使用而保存它。 这里的主要区别是：</p><pre><code>dateconv = np.vectorize(dt.datetime.fromtimestamp)date = dateconv(date)</code></pre><p>这里，我们将时间戳转换为日期戳，然后将其转换为 Matplotlib 想要的时间。</p><p>现在，由于某些原因，我的 unix 时间带有另一行包含 6 个元素的数据，并且它包含了术语<code>label</code>，因此，在我们解析数据的<code>for</code>循环中，我们为你再添加一个需要注意的检查：</p><pre><code>for line in split_source:    split_line = line.split(',')    if len(split_line) == 6:        if 'values' not in line and 'labels' not in line:            stock_data.append(line)</code></pre><p>现在你的图表应该类似：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-4de0a34533b0fca1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这里的所有扁平线条的原因是市场关闭。 有了这个短期数据，我们可以得到日内数据。 所以交易开放时有很多点，然后市场关闭时就没有了，然后又是一堆，然后又是没有。</p><h1 id="第十二章-颜色和填充"><a href="#第十二章-颜色和填充" class="headerlink" title="第十二章 颜色和填充"></a>第十二章 颜色和填充</h1><p>在本教程中，我们将介绍一些更多的自定义，比如颜色和线条填充。</p><p>我们要做的第一个改动是将<code>plt.title</code>更改为<code>stock</code>变量。</p><pre><code>plt.title(stock)</code></pre><p>现在，让我们来介绍一下如何更改标签颜色。 我们可以通过修改我们的轴对象来实现：</p><pre><code>ax1.xaxis.label.set_color('c')ax1.yaxis.label.set_color('r')</code></pre><p>如果我们运行它，我们会看到标签改变了颜色，就像在单词中那样。</p><p>接下来，我们可以为要显示的轴指定具体数字，而不是像这样的自动选择：</p><pre><code>ax1.set_yticks([0,25,50,75])</code></pre><p>接下来，我想介绍填充。 填充所做的事情，是在变量和你选择的一个数值之间填充颜色。 例如，我们可以这样：</p><pre><code>ax1.fill_between(date, 0, closep)</code></pre><p>所以到这里，我们的代码为：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    ax1.fill_between(date, 0, closep)    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.grid(True)#, color='g', linestyle='-', linewidth=5)    ax1.xaxis.label.set_color('c')    ax1.yaxis.label.set_color('r')    ax1.set_yticks([0,25,50,75])    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-f2b03db492944c72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>填充的一个问题是，我们可能最后会把东西都覆盖起来。 我们可以用透明度来解决它：</p><pre><code>ax1.fill_between(date, 0, closep)</code></pre><p>现在，让我们介绍条件填充。 让我们假设图表的起始位置是我们开始买入 eBay 的地方。 这里，如果价格低于这个价格，我们可以向上填充到原来的价格，然后如果它超过了原始价格，我们可以向下填充。 我们可以这样做：</p><pre><code>ax1.fill_between(date, closep[0], closep)</code></pre><p>会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-57b56f07db5bece0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>如果我们想用红色和绿色填充来展示收益/损失，那么与原始价格相比，绿色填充用于上升（注：国外股市的颜色和国内相反），红色填充用于下跌？ 没问题！ 我们可以添加一个<code>where</code>参数，如下所示：</p><pre><code>ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5)</code></pre><p>这里，我们填充当前价格和原始价格之间的区域，其中当前价格高于原始价格。 我们给予它绿色的前景色，因为这是一个上升，而且我们使用微小的透明度。</p><p>我们仍然不能对多边形数据（如填充）应用标签，但我们可以像以前一样实现空线条，因此我们可以：</p><pre><code>ax1.plot([],[],linewidth=5, label='loss', color='r',alpha=0.5)ax1.plot([],[],linewidth=5, label='gain', color='g',alpha=0.5)ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5)ax1.fill_between(date, closep, closep[0],where=(closep &lt; closep[0]), facecolor='r', alpha=0.5)</code></pre><p>这向我们提供了一些填充，以及用于处理标签的空线条，我们打算将其显示在图例中。这里完整的代码是：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    ax1.plot_date(date, closep,'-', label='Price')    ax1.plot([],[],linewidth=5, label='loss', color='r',alpha=0.5)    ax1.plot([],[],linewidth=5, label='gain', color='g',alpha=0.5)    ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5)    ax1.fill_between(date, closep, closep[0],where=(closep &lt; closep[0]), facecolor='r', alpha=0.5)    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.grid(True)#, color='g', linestyle='-', linewidth=5)    ax1.xaxis.label.set_color('c')    ax1.yaxis.label.set_color('r')    ax1.set_yticks([0,25,50,75])    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>现在我们的结果是：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-069af451720b65f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第十三章-边框和水平线条"><a href="#第十三章-边框和水平线条" class="headerlink" title="第十三章 边框和水平线条"></a>第十三章 边框和水平线条</h1><p>欢迎阅读另一个定制教程，在这里我们使用 Matplotlib 讨论边框和水平线条。 有时候你可能想做的事情是改变边框的颜色，或者甚至完全删除它们。</p><p>图形的边框基本上是图形的边界，其中有刻度线等东西。为了改变边框的颜色，你可以做一些类似这样的事情：</p><pre><code>ax1.spines['left'].set_color('c')</code></pre><p>在这里，我们引用了我们的边框字典，表示我们要调整左边框，然后我们使用<code>set_color</code>方法将颜色设置为<code>'c'</code>，它是青色。</p><p>如果我们想删除所有边框怎么办？ 我们可以这样做：</p><pre><code>ax1.spines['right'].set_visible(False)ax1.spines['top'].set_visible(False)</code></pre><p>这是非常类似的代码，删除了右边框和上边框。</p><p>很难看到我们修改了左边框的颜色，所以让我们通过修改线宽来使它变得很明显：</p><pre><code>ax1.spines['left'].set_linewidth(5)</code></pre><p>现在，左边框变成了非常粗也非常显眼的青色。 最后，如果我们想修改刻度参数怎么办？ 假如不想要黑色的日期，我们想要一些橙色的日期？ 没问题！</p><pre><code>ax1.tick_params(axis='x', colors='#f06215')</code></pre><p>现在我们的日期是橙色了！ 接下来，让我们来看看我们如何绘制一条水平线。 你当然可以将你创建的一组新数据绘制成一条水平线，但你不需要这样做。 你可以：</p><pre><code>ax1.axhline(closep[0], color='k', linewidth=5)</code></pre><p>所以在这里，我们的整个代码是：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    ax1.plot_date(date, closep,'-', label='Price')    ax1.plot([],[],linewidth=5, label='loss', color='r',alpha=0.5)    ax1.plot([],[],linewidth=5, label='gain', color='g',alpha=0.5)    ax1.axhline(closep[0], color='k', linewidth=5)    ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5)    ax1.fill_between(date, closep, closep[0],where=(closep &lt; closep[0]), facecolor='r', alpha=0.5)    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.grid(True)    #ax1.xaxis.label.set_color('c')    #ax1.yaxis.label.set_color('r')    ax1.set_yticks([0,25,50,75])    ax1.spines['left'].set_color('c')    ax1.spines['right'].set_visible(False)    ax1.spines['top'].set_visible(False)    ax1.spines['left'].set_linewidth(5)    ax1.tick_params(axis='x', colors='#f06215')    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('ebay')</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-18c832847bc0f71c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第十四章-OHLC-K-线图"><a href="#第十四章-OHLC-K-线图" class="headerlink" title="第十四章 OHLC K 线图"></a>第十四章 OHLC K 线图</h1><p>在 Matplotlib 教程中，我们将介绍如何在 Matplotlib 中创建开，高，低，关（OHLC）的 K 线图。 这些图表用于以精简形式显示时间序列股价信息。 为了实现它，我们首先需要导入一些模块：</p><pre><code>import matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlc</code></pre><p>我们引入了<code>ticker</code>，允许我们修改图表底部的<code>ticker</code>信息。 然后我们从<code>matplotlib.finance</code>模块中引入<code>candlestick_ohlc</code>功能。</p><p>现在，我们需要组织我们的数据来和 matplotlib 协作。 如果你刚刚加入我们，我们得到的数据如下：</p><pre><code>stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv'source_code = urllib.request.urlopen(stock_price_url).read().decode()stock_data = []split_source = source_code.split('\n')for line in split_source:    split_line = line.split(',')    if len(split_line) == 6:        if 'values' not in line and 'labels' not in line:            stock_data.append(line)date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                      delimiter=',',                                                      unpack=True,                                                      converters={0: bytespdate2num('%Y%m%d')})</code></pre><p>现在，我们需要构建一个 Python 列表，其中每个元素都是数据。 我们可以修改我们的<code>loadtxt</code>函数，使其不解构，但随后我们还是希望引用特定的数据点。 我们可以解决这个问题，但是我们最后可能只拥有两个单独的数据集。 为此，我们执行以下操作：</p><pre><code>x = 0y = len(date)ohlc = []while x &lt; y:    append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]    ohlc.append(append_me)    x+=1</code></pre><p>有了这个，我们现在将 OHLC 数据列表存储到我们的变量<code>ohlc</code>。 现在我们可以这样绘制：</p><pre><code>candlestick_ohlc(ax1, ohlc)</code></pre><p>图表应该是这样：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-60ffe36a409afe6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>不幸的是，<code>x</code>轴上的<code>datetime</code>数据不是日期戳的形式。 我们可以处理它：</p><pre><code>ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))</code></pre><p>此外，红/黑着色依我看不是最好的选择。 我们应该使用绿色表示上升和红色表示下降。 为此，我们可以：</p><pre><code>candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')</code></pre><p>最后，我们可以将<code>x</code>标签设置为我们想要的数量，像这样：</p><pre><code>ax1.xaxis.set_major_locator(mticker.MaxNLocator(10))</code></pre><p>现在，完整代码现在是这样：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcimport numpy as npimport urllibimport datetime as dtdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax1.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax1.grid(True)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-4f2d9fb663f851cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>还要注意，我们从前面的教程中删除了大部分<code>ax1</code>的修改。</p><h1 id="第十五章-样式"><a href="#第十五章-样式" class="headerlink" title="第十五章 样式"></a>第十五章 样式</h1><p>在这个 Matplotlib 教程中，我们将讨论样式。 我们用于 Matplotlib 的样式非常相似于用于 HTML 页面的 CSS（层叠样式表）。 正如你在这里可以看到的，我们对图形所做的所有修改都会叠加，而且我们目前只有一个轴域。 我们可以使用<code>for</code>循环，至少使代码量降低，但我们也可以在 Matplotlib 中利用这些样式。</p><p>样式页的想法是将自定义样式写入文件，然后，为了使用这些更改并将其应用于图形，所有你需要做的就是导入样式，然后使用该特定样式。 这样，让我们假设你发现自己总是改变图形的各种元素。 你不必为每个图表编写 25 ~ 200 行自定义代码，只需将其写入一个样式，然后加载该样式，并以两行应用所有这些更改即可！ 让我们开始吧。</p><pre><code>from matplotlib import style</code></pre><p>接下来，我们指定要使用的样式。 Matplotlib 已经有了几种样式。</p><p>我们可以这样来使用样式：</p><pre><code>style.use('ggplot')</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-3ad2c87140de8855.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>除了标题，标签的颜色是灰色的，轴域的背景是浅灰色，我们可以立即分辨字体是不同的。 我们还注意到，网格实际上是一个白色的实线。 我们的 K 线图保持不变，主要是因为我们在事后定制它。 在样式中加载时，更改会生效，但如果在加载样式后编写新的自定义代码，你的更改也会生效。</p><p>因为我们试图展示样式模块，但是让我们继续，简单绘制几行，并暂且注释掉 K 线图：</p><pre><code>#candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')ax1.plot(date,closep)ax1.plot(date,openp)</code></pre><p>会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-8fa5b684a13eb408.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>已经比默认值好多了！</p><p>样式的另一个例子是<code>fivethirtyeight</code>：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-390e540781b5f0de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>你可以这样查看所有的可用样式：</p><pre><code>print(plt.style.available)</code></pre><p>我这里它提供了<code>['bmh', 'dark_background', 'ggplot', 'fivethirtyeight', 'grayscale']</code>。</p><p>让我们尝试<code>dark_background</code>：</p><pre><code>style.use('dark_background')</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-040521aa581616e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>现在，如果你想制作自己的风格呢？ 首先，你需要找到样式目录。 为了实现它，如果你知道它在哪里，你可以前往你的 matplotlib 目录，或者你可以找到该目录。 如果你不知道如何找到该目录，你可以执行以下操作：</p><pre><code>print(plt.__file__)</code></pre><p>这至少会告诉你<code>pyplot</code>模块的位置。</p><p>在 matplotlib 目录中，你需要寻找<code>mpl-data</code>。 然后在那里，你需要寻找<code>stylelib</code>。 在 Windows 上 ，我的完整路径是：<code>C:\Python34\Lib\site-packages\matplotlib\mpl-data\stylelib</code>。</p><p>那里应该显示了所有可用的<code>.mplstyle</code>文件。 你可以编辑、复制或重命名它们，然后在那里修改为你想要的东西。 然后，无论你用什么来命名<code>.mplstyle</code>文件，都要放在<code>style.use</code>中。</p><h1 id="第十六章-实时图表"><a href="#第十六章-实时图表" class="headerlink" title="第十六章 实时图表"></a>第十六章 实时图表</h1><p>在这篇 Matplotlib 教程中，我们将介绍如何创建实时更新图表，可以在数据源更新时更新其图表。 你可能希望将此用于绘制股票实时定价数据，或者可以将传感器连接到计算机，并且显示传感器实时数据。 为此，我们使用 Matplotlib 的动画功能。</p><p>最开始：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.animation as animationfrom matplotlib import style</code></pre><p>这里，唯一的新增导入是<code>matplotlib.animation as animation</code>。 这是一个模块，允许我们在显示之后对图形进行动画处理。</p><p>接下来，我们添加一些你熟悉的代码，如果你一直关注这个系列：</p><pre><code>style.use('fivethirtyeight')fig = plt.figure()ax1 = fig.add_subplot(1,1,1)</code></pre><p>现在我们编写动画函数：</p><pre><code>def animate(i):    graph_data = open('example.txt','r').read()    lines = graph_data.split('\n')    xs = []    ys = []    for line in lines:        if len(line) &gt; 1:            x, y = line.split(',')            xs.append(x)            ys.append(y)    ax1.clear()    ax1.plot(xs, ys)</code></pre><p>我们在这里做的是构建数据，然后绘制它。 注意我们这里不调用<code>plt.show()</code>。 我们从一个示例文件读取数据，其内容如下：</p><pre><code>1,52,33,44,75,46,37,58,79,410,4</code></pre><p>我们打开上面的文件，然后存储每一行，用逗号分割成<code>xs</code>和<code>ys</code>，我们将要绘制它。 然后：</p><pre><code>ani = animation.FuncAnimation(fig, animate, interval=1000)plt.show()</code></pre><p>我们运行动画，将动画放到图表中（<code>fig</code>），运行<code>animate</code>的动画函数，最后我们设置了 1000 的间隔，即 1000 毫秒或 1 秒。</p><p>运行此图表的结果应该像往常一样生成图表。 然后，你应该能够使用新的坐标更新<code>example.txt</code>文件。 这样做会生成一个自动更新的图表，如下：</p><p>[图片上传失败…(image-3aca35-1558443769838)]</p><h1 id="第十七章-注解和文本"><a href="#第十七章-注解和文本" class="headerlink" title="第十七章 注解和文本"></a>第十七章 注解和文本</h1><p>在本教程中，我们将讨论如何向 Matplotlib 图形添加文本。 我们可以通过两种方式来实现。 一种是将文本放置在图表上的某个位置。 另一个是专门注解图表上的绘图，来引起注意。</p><p>这里的起始代码是教程 15，它在这里：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)def bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax1.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax1.grid(True)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('ebay')</code></pre><p>所以这里是 Yahoo Finance API 的 eBay 的 OHLC K 线图。 这里我们要讲解的第一件事是向图形添加文本。</p><pre><code>font_dict = {'family':'serif',             'color':'darkred',             'size':15}ax1.text(date[10], closep[1],'Text Example', fontdict=font_dict)</code></pre><p>在这里，我们需要做一些事情。 首先，我们使用<code>ax1.text</code>添加文本。 我们使用我们的数据，以坐标形式给出此文本的位置。 首先给出文本的坐标，然后给出要放置的实际文本。 接下来，我们使用<code>fontdict</code>参数添加一个数据字典，来使用所用的字体。 在我们的字体字典中，我们将字体更改为<code>serif</code>，颜色为『深红色』，然后将字体大小更改为 15。这将全部应用于我们的图表上的文本，如下所示：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-31586a626a3d1952.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>太棒了，接下来我们可以做的是，注解某个特定的绘图。 我们希望这样做来给出更多的信息。 在 eBay 的例子中，也许我们想解释某个具体绘图，或给出一些关于发生了什么的信息。 在股价的例子中，也许有一些发生的新闻会影响价格。 你可以注解新闻来自哪里，这将有助于解释定价变化。</p><pre><code>ax1.annotate('Bad News!',(date[9],highp[9]),             xytext=(0.8, 0.9), textcoords='axes fraction',             arrowprops = dict(facecolor='grey',color='grey'))</code></pre><p>这里，我们用<code>ax1.annotate</code>来注解。 我们首先传递我们想要注解的文本，然后传递我们让这个注解指向的坐标。 我们这样做，是因为当我们注释时，我们可以绘制线条和指向特定点的箭头。 接下来，我们指定<code>xytext</code>的位置。 它可以是像我们用于文本放置的坐标位置，但是让我们展示另一个例子。 它可以为轴域小数，所以我们使用 0.8 和 0.9。 这意味着文本的位置在<code>x</code>轴的80％和<code>y</code>轴的90％处。 这样，如果我们移动图表，文本将保持在相同位置。</p><p>执行它，会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-2693ab1290c82f96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>根据你学习这个教程的时间，所指向的点可能有所不同，这只是一个注解的例子，其中有一些合理的想法，即为什么我们需要注解一些东西。</p><p>当图表启动时，请尝试单击平移按钮（蓝色十字），然后移动图表。 你会看到文本保持不动，但箭头跟随移动并继续指向我们想要的具体的点。 这很酷吧！</p><p>最后一个图表的完整代码：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)def bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax1.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax1.grid(True)    ax1.annotate('Bad News!',(date[9],highp[9]),                 xytext=(0.8, 0.9), textcoords='axes fraction',                 arrowprops = dict(facecolor='grey',color='grey'))##    # Text placement example:##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    ax1.text(date[10], closep[1],'Text Example', fontdict=font_dict)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    #plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('ebay')</code></pre><p>现在，使用注解，我们可以做一些其他事情，如注解股票图表的最后价格。 这就是我们接下来要做的。</p><h1 id="第十八章-注解股票图表的最后价格"><a href="#第十八章-注解股票图表的最后价格" class="headerlink" title="第十八章 注解股票图表的最后价格"></a>第十八章 注解股票图表的最后价格</h1><p>在这个 Matplotlib 教程中，我们将展示如何跟踪股票的最后价格的示例，通过将其注解到轴域的右侧，就像许多图表应用程序会做的那样。</p><p>虽然人们喜欢在他们的实时图表中看到历史价格，他们也想看到最新的价格。 大多数应用程序做的是，在价格的<code>y</code>轴高度处注释最后价格，然后突出显示它，并在价格变化时，在框中将其略微移动。 使用我们最近学习的注解教程，我们可以添加一个<code>bbox</code>。</p><p>我们的核心代码是：</p><pre><code>bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)ax1.annotate(str(closep[-1]), (date[-1], closep[-1]),             xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)</code></pre><p>我们使用<code>ax1.annotate</code>来放置最后价格的字符串值。 我们不在这里使用它，但我们将要注解的点指定为图上最后一个点。 接下来，我们使用<code>xytext</code>将我们的文本放置到特定位置。 我们将它的<code>y</code>坐标指定为最后一个点的<code>y</code>坐标，<code>x</code>坐标指定为最后一个点的<code>x</code>坐标，再加上几个点。我们这样做是为了将它移出图表。 将文本放在图形外面就足够了，但现在它只是一些浮动文本。</p><p>我们使用<code>bbox</code>参数在文本周围创建一个框。 我们使用<code>bbox_props</code>创建一个属性字典，包含盒子样式，然后是白色（<code>w</code>）前景色，黑色（<code>k</code>）边框颜色并且线宽为 1。 更多框样式请参阅 <a href="https://link.jianshu.com?t=http://matplotlib.org/users/annotations_guide.html" target="_blank" rel="noopener">matplotlib 注解文档</a>。</p><p>最后，这个注解向右移动，需要我们使用<code>subplots_adjust</code>来创建一些新空间：</p><pre><code>plt.subplots_adjust(left=0.11, bottom=0.24, right=0.87, top=0.90, wspace=0.2, hspace=0)</code></pre><p>这里的完整代码如下：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)def bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax1.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax1.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax1.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+3, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax1.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text##    ax1.text(date[10], closep[1],'Text Example', fontdict=font_dict)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    #plt.legend()    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.87, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-80de7ea61e49212b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第十九章-子图"><a href="#第十九章-子图" class="headerlink" title="第十九章 子图"></a>第十九章 子图</h1><p>在这个 Matplotlib 教程中，我们将讨论子图。 有两种处理子图的主要方法，用于在同一图上创建多个图表。 现在，我们将从一个干净的代码开始。 如果你一直关注这个教程，那么请确保保留旧的代码，或者你可以随时重新查看上一个教程的代码。</p><p>首先，让我们使用样式，创建我们的图表，然后创建一个随机创建示例绘图的函数：</p><pre><code>import randomimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use('fivethirtyeight')fig = plt.figure()def create_plots():    xs = []    ys = []    for i in range(10):        x = i        y = random.randrange(10)        xs.append(x)        ys.append(y)    return xs, ys</code></pre><p>现在，我们开始使用<code>add_subplot</code>方法创建子图：</p><pre><code>ax1 = fig.add_subplot(221)ax2 = fig.add_subplot(222)ax3 = fig.add_subplot(212)</code></pre><p>它的工作原理是使用 3 个数字，即：行数（<code>numRows</code>）、列数（<code>numCols</code>）和绘图编号（<code>plotNum</code>）。</p><p>所以，221 表示两行两列的第一个位置。222 是两行两列的第二个位置。最后，212 是两行一列的第二个位置。</p><pre><code>2x2：+-----+-----+|  1  |  2  |+-----+-----+|  3  |  4  |+-----+-----+2x1：+-----------+|     1     |+-----------+|     2     |+-----------+</code></pre><blockquote><p>译者注：原文此处表述有误，译文已更改。</p></blockquote><blockquote><p>译者注：<code>221</code>是缩写形式，仅在行数乘列数小于 10 时有效，否则要写成<code>2,2,1</code>。</p></blockquote><p>此代码结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-c927e9ad943f9c86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这就是<code>add_subplot</code>。 尝试一些你认为可能很有趣的配置，然后尝试使用<code>add_subplot</code>创建它们，直到你感到满意。</p><p>接下来，让我们介绍另一种方法，它是<code>subplot2grid</code>。</p><p>删除或注释掉其他轴域定义，然后添加：</p><pre><code>ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1)ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1)</code></pre><p>所以，<code>add_subplot</code>不能让我们使一个绘图覆盖多个位置。 但是这个新的<code>subplot2grid</code>可以。 所以，<code>subplot2grid</code>的工作方式是首先传递一个元组，它是网格形状。 我们传递了<code>(6,1)</code>，这意味着整个图表分为六行一列。 下一个元组是左上角的起始点。 对于<code>ax1</code>，这是<code>0,0</code>，因此它起始于顶部。 接下来，我们可以选择指定<code>rowspan</code>和<code>colspan</code>。 这是轴域所占的行数和列数。</p><pre><code>6x1：          colspan=1(0,0)   +-----------+        |    ax1    | rowspan=1(1,0)   +-----------+        |           |        |    ax2    | rowspan=4        |           |        |           |(5,0)   +-----------+        |    ax3    | rowspan=1        +-----------+</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-efd554f7f908c9fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>显然，我们在这里有一些重叠的问题，我们可以调整子图来处理它。</p><p>再次，尝试构思各种配置的子图，使用<code>subplot2grid</code>制作出来，直到你感到满意！</p><p>我们将继续使用<code>subplot2grid</code>，将它应用到我们已经逐步建立的代码中，我们将在下一个教程中继续。</p><h1 id="第二十一章-更多指标数据"><a href="#第二十一章-更多指标数据" class="headerlink" title="第二十一章 更多指标数据"></a>第二十一章 更多指标数据</h1><p>在这篇 Matplotlib 教程中，我们介绍了添加一些简单的函数来计算数据，以便我们填充我们的轴域。 一个是简单的移动均值，另一个是简单的价格 HML 计算。</p><p>这些新函数是：</p><pre><code>def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lows</code></pre><p>你不需要太过专注于理解移动均值的工作原理，我们只是对样本数据来计算它，以便可以学习更多自定义 Matplotlib 的东西。</p><p>我们还想在脚本顶部为移动均值定义一些值：</p><pre><code>MA1 = 10MA2 = 30</code></pre><p>下面，在我们的<code>graph_data</code>函数中：</p><pre><code>ma1 = moving_average(closep,MA1)ma2 = moving_average(closep,MA2)start = len(date[MA2-1:])h_l = list(map(high_minus_low, highp, lowp))</code></pre><p>在这里，我们计算两个移动均值和 HML。</p><p>我们还定义了一个『起始』点。 我们这样做是因为我们希望我们的数据排成一行。 例如，20 天的移动均值需要 20 个数据点。 这意味着我们不能在第 5 天真正计算 20 天的移动均值。 因此，当我们计算移动均值时，我们会失去一些数据。 为了处理这种数据的减法，我们使用起始变量来计算应该有多少数据。 这里，我们可以安全地使用<code>[-start:]</code>绘制移动均值，并且如果我们希望的话，对所有绘图进行上述步骤来排列数据。</p><p>接下来，我们可以在<code>ax1</code>上绘制 HML，通过这样：</p><pre><code>ax1.plot_date(date,h_l,'-')</code></pre><p>最后我们可以通过这样向<code>ax3</code>添加移动均值：</p><pre><code>ax3.plot(date[-start:], ma1[-start:])ax3.plot(date[-start:], ma2[-start:])</code></pre><p>我们的完整代码，包括增加我们所用的时间范围：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1)    plt.xlabel('Date')    plt.ylabel('Price')    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1)    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date,h_l,'-')    candlestick_ohlc(ax2, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax2.xaxis.get_ticklabels():        label.set_rotation(45)    ax2.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax2.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax3.plot(date[-start:], ma1[-start:])    ax3.plot(date[-start:], ma2[-start:])    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>代码效果如图：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-d289f6cde6d705de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第二十二章-自定义填充、修剪和清除"><a href="#第二十二章-自定义填充、修剪和清除" class="headerlink" title="第二十二章 自定义填充、修剪和清除"></a>第二十二章 自定义填充、修剪和清除</h1><p>欢迎阅读另一个 Matplotlib 教程！ 在本教程中，我们将清除图表，然后再做一些自定义。</p><p>我们当前的代码是：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1)    plt.xlabel('Date')    plt.ylabel('Price')    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1)    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date,h_l,'-')    candlestick_ohlc(ax2, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax2.xaxis.get_ticklabels():        label.set_rotation(45)    ax2.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax2.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax3.plot(date[-start:], ma1[-start:])    ax3.plot(date[-start:], ma2[-start:])    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>现在我认为向我们的移动均值添加自定义填充是一个很好的主意。 移动均值通常用于说明价格趋势。 这个想法是，你可以计算一个快速和一个慢速的移动均值。 一般来说，移动均值用于使价格变得『平滑』。 他们总是『滞后』于价格，但是我们的想法是计算不同的速度。 移动均值越大就越『慢』。 所以这个想法是，如果『较快』的移动均值超过『较慢』的均值，那么价格就会上升，这是一件好事。 如果较快的 MA 从较慢的 MA 下方穿过，则这是下降趋势并且通常被视为坏事。 我的想法是在快速和慢速 MA 之间填充，『上升』趋势为绿色，然后下降趋势为红色。 方法如下：</p><pre><code>ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                 where=(ma1[-start:] &lt; ma2[-start:]),                 facecolor='r', edgecolor='r', alpha=0.5)ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                 where=(ma1[-start:] &gt; ma2[-start:]),                 facecolor='g', edgecolor='g', alpha=0.5)</code></pre><p>下面，我们会碰到一些我们可解决的问题：</p><pre><code>ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))for label in ax3.xaxis.get_ticklabels():    label.set_rotation(45)plt.setp(ax1.get_xticklabels(), visible=False)plt.setp(ax2.get_xticklabels(), visible=False)</code></pre><p>这里，我们剪切和粘贴<code>ax2</code>日期格式，然后我们将<code>x</code>刻度标签设置为<code>false</code>，去掉它们！</p><p>我们还可以通过在轴域定义中执行以下操作，为每个轴域提供自定义标签：</p><pre><code>fig = plt.figure()ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)plt.title(stock)ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1)plt.xlabel('Date')plt.ylabel('Price')ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1)</code></pre><p>接下来，我们可以看到，我们<code>y</code>刻度有许多数字，经常互相覆盖。 我们也看到轴之间互相重叠。 我们可以这样：</p><pre><code>ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=5, prune='lower'))</code></pre><p>所以，这里发生的是，我们通过首先将<code>nbins</code>设置为 5 来修改我们的<code>y</code>轴对象。这意味着我们显示的标签最多为 5 个。然后我们还可以『修剪』标签，因此，在我们这里， 我们修剪底部标签，这会使它消失，所以现在不会有任何文本重叠。 我们仍然可能打算修剪<code>ax2</code>的顶部标签，但这里是我们目前为止的源代码：</p><p>当前的源码：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    plt.ylabel('H-L')    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1)    plt.ylabel('Price')    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1)    plt.ylabel('MAvgs')    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date,h_l,'-')    ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=5, prune='lower'))    candlestick_ohlc(ax2, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax3.plot(date[-start:], ma1[-start:], linewidth=1)    ax3.plot(date[-start:], ma2[-start:], linewidth=1)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &lt; ma2[-start:]),                     facecolor='r', edgecolor='r', alpha=0.5)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &gt; ma2[-start:]),                     facecolor='g', edgecolor='g', alpha=0.5)    ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))    for label in ax3.xaxis.get_ticklabels():        label.set_rotation(45)    plt.setp(ax1.get_xticklabels(), visible=False)    plt.setp(ax2.get_xticklabels(), visible=False)    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-228d950fb6e2a065.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>看起来好了一些，但是仍然有一些东西需要清除。</p><h1 id="第二十三章-共享-X-轴"><a href="#第二十三章-共享-X-轴" class="headerlink" title="第二十三章 共享 X 轴"></a>第二十三章 共享 X 轴</h1><p>在这个 Matplotlib 数据可视化教程中，我们将讨论<code>sharex</code>选项，它允许我们在图表之间共享<code>x</code>轴。将<code>sharex</code>看做『复制 x』也许更好。</p><p>在我们开始之前，首先我们要做些修剪并在另一个轴上设置最大刻度数，如下所示：</p><pre><code>ax2.yaxis.set_major_locator(mticker.MaxNLocator(nbins=7, prune='upper'))</code></pre><p>以及</p><pre><code>ax3.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='upper'))</code></pre><p>现在，让我们共享所有轴域之间的<code>x</code>轴。 为此，我们需要将其添加到轴域定义中：</p><pre><code>fig = plt.figure()ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)plt.title(stock)plt.ylabel('H-L')ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1, sharex=ax1)plt.ylabel('Price')ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1, sharex=ax1)plt.ylabel('MAvgs')</code></pre><p>上面，对于<code>ax2</code>和<code>ax3</code>，我们添加一个新的参数，称为<code>sharex</code>，然后我们说，我们要与<code>ax1</code>共享<code>x</code>轴。</p><p>使用这种方式，我们可以加载图表，然后我们可以放大到一个特定的点，结果将是这样：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-5edfc228b965924d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>所以这意味着所有轴域沿着它们的<code>x</code>轴一起移动。 这很酷吧！</p><p>接下来，让我们将<code>[-start:]</code>应用到所有数据，所以所有轴域都起始于相同地方。 我们最终的代码为：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    plt.ylabel('H-L')    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1, sharex=ax1)    plt.ylabel('Price')    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1, sharex=ax1)    plt.ylabel('MAvgs')    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date[-start:],h_l[-start:],'-')    ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='lower'))    candlestick_ohlc(ax2, ohlc[-start:], width=0.4, colorup='#77d879', colordown='#db3f3f')    ax2.yaxis.set_major_locator(mticker.MaxNLocator(nbins=7, prune='upper'))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax3.plot(date[-start:], ma1[-start:], linewidth=1)    ax3.plot(date[-start:], ma2[-start:], linewidth=1)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &lt; ma2[-start:]),                     facecolor='r', edgecolor='r', alpha=0.5)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &gt; ma2[-start:]),                     facecolor='g', edgecolor='g', alpha=0.5)    ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax3.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='upper'))    for label in ax3.xaxis.get_ticklabels():        label.set_rotation(45)    plt.setp(ax1.get_xticklabels(), visible=False)    plt.setp(ax2.get_xticklabels(), visible=False)    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>下面我们会讨论如何创建多个<code>y</code>轴。</p><h1 id="第二十四章-多个-Y-轴"><a href="#第二十四章-多个-Y-轴" class="headerlink" title="第二十四章 多个 Y 轴"></a>第二十四章 多个 Y 轴</h1><p>在这篇 Matplotlib 教程中，我们将介绍如何在同一子图上使用多个 Y 轴。 在我们的例子中，我们有兴趣在同一个图表及同一个子图上绘制股票价格和交易量。</p><p>为此，首先我们需要定义一个新的轴域，但是这个轴域是<code>ax2</code>仅带有<code>x</code>轴的『双生子』。</p><p>这足以创建轴域了。我们叫它<code>ax2v</code>，因为这个轴域是<code>ax2</code>加交易量。</p><p>现在，我们在轴域上定义绘图，我们将添加：</p><pre><code>ax2v.fill_between(date[-start:],0, volume[-start:], facecolor='#0079a3', alpha=0.4)</code></pre><p>我们在 0 和当前交易量之间填充，给予它蓝色的前景色，然后给予它一个透明度。 我们想要应用幽冥毒，以防交易量最终覆盖其它东西，所以我们仍然可以看到这两个元素。</p><p>所以，到现在为止，我们的代码为：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    plt.ylabel('H-L')    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1, sharex=ax1)    plt.ylabel('Price')    ax2v = ax2.twinx()    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1, sharex=ax1)    plt.ylabel('MAvgs')    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date[-start:],h_l[-start:],'-')    ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='lower'))    candlestick_ohlc(ax2, ohlc[-start:], width=0.4, colorup='#77d879', colordown='#db3f3f')    ax2.yaxis.set_major_locator(mticker.MaxNLocator(nbins=7, prune='upper'))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax2v.fill_between(date[-start:],0, volume[-start:], facecolor='#0079a3', alpha=0.4)    ax3.plot(date[-start:], ma1[-start:], linewidth=1)    ax3.plot(date[-start:], ma2[-start:], linewidth=1)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &lt; ma2[-start:]),                     facecolor='r', edgecolor='r', alpha=0.5)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &gt; ma2[-start:]),                     facecolor='g', edgecolor='g', alpha=0.5)    ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax3.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='upper'))    for label in ax3.xaxis.get_ticklabels():        label.set_rotation(45)    plt.setp(ax1.get_xticklabels(), visible=False)    plt.setp(ax2.get_xticklabels(), visible=False)    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('GOOG')</code></pre><p>会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0afba1786b413e08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>太棒了，到目前为止还不错。 接下来，我们可能要删除新<code>y</code>轴上的标签，然后我们也可能不想让交易量占用太多空间。 没问题：</p><p>首先：</p><pre><code>ax2v.axes.yaxis.set_ticklabels([])</code></pre><p>上面将<code>y</code>刻度标签设置为一个空列表，所以不会有任何标签了。</p><blockquote><p>译者注：所以将标签删除之后，添加新轴的意义是什么？直接在原轴域上绘图就可以了。</p></blockquote><p>接下来，我们可能要将网格设置为<code>false</code>，使轴域上不会有双网格：</p><pre><code>ax2v.grid(False)</code></pre><p>最后，为了处理交易量占用很多空间，我们可以做以下操作：</p><pre><code>ax2v.set_ylim(0, 3*volume.max())</code></pre><p>所以这设置<code>y</code>轴显示范围从 0 到交易量的最大值的 3 倍。 这意味着，在最高点，交易量最多可占据图形的33％。 所以，增加<code>volume.max</code>的倍数越多，空间就越小/越少。</p><p>现在，我们的图表为：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    plt.ylabel('H-L')    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1, sharex=ax1)    plt.ylabel('Price')    ax2v = ax2.twinx()    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1, sharex=ax1)    plt.ylabel('MAvgs')    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date[-start:],h_l[-start:],'-')    ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='lower'))    candlestick_ohlc(ax2, ohlc[-start:], width=0.4, colorup='#77d879', colordown='#db3f3f')    ax2.yaxis.set_major_locator(mticker.MaxNLocator(nbins=7, prune='upper'))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+5, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax2v.fill_between(date[-start:],0, volume[-start:], facecolor='#0079a3', alpha=0.4)    ax2v.axes.yaxis.set_ticklabels([])    ax2v.grid(False)    ax2v.set_ylim(0, 3*volume.max())    ax3.plot(date[-start:], ma1[-start:], linewidth=1)    ax3.plot(date[-start:], ma2[-start:], linewidth=1)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &lt; ma2[-start:]),                     facecolor='r', edgecolor='r', alpha=0.5)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &gt; ma2[-start:]),                     facecolor='g', edgecolor='g', alpha=0.5)    ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax3.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='upper'))    for label in ax3.xaxis.get_ticklabels():        label.set_rotation(45)    plt.setp(ax1.get_xticklabels(), visible=False)    plt.setp(ax2.get_xticklabels(), visible=False)    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('GOOG')</code></pre><p>到这里，我们差不多完成了。 这里唯一的缺陷是一个好的图例。 一些线条是显而易见的，但人们可能会好奇移动均值的参数是什么，我们这里是 10 和 30。 添加自定义图例是下一个教程中涉及的内容。</p><h1 id="第二十五章-自定义图例"><a href="#第二十五章-自定义图例" class="headerlink" title="第二十五章 自定义图例"></a>第二十五章 自定义图例</h1><p>在这篇 Matplotlib 教程中，我们将讨论自定义图例。 我们已经介绍了<a href="https://link.jianshu.com?t=http://pythonprogramming.net/legends-titles-labels-matplotlib-tutorial/" target="_blank" rel="noopener">添加图例的基础知识</a>。</p><p>图例的主要问题通常是图例阻碍了数据的展示。 这里有几个选项。 一个选项是将图例放在轴域外，但是我们在这里有多个子图，这是非常困难的。 相反，我们将使图例稍微小一点，然后应用一个透明度。</p><p>首先，为了创建一个图例，我们需要向我们的数据添加我们想要显示在图例上的标签。</p><pre><code>ax1.plot_date(date[-start:],h_l[-start:],'-', label='H-L')...ax2v.plot([],[], color='#0079a3', alpha=0.4, label='Volume')...ax3.plot(date[-start:], ma1[-start:], linewidth=1, label=(str(MA1)+'MA'))ax3.plot(date[-start:], ma2[-start:], linewidth=1, label=(str(MA2)+'MA'))</code></pre><p>请注意，我们通过创建空行为交易量添加了标签。 请记住，我们不能对任何填充应用标签，所以这就是我们添加这个空行的原因。</p><p>现在，我们可以在右下角添加图例，通过在<code>plt.show()</code>之前执行以下操作：</p><pre><code>ax1.legend()ax2v.legend()ax3.legend()</code></pre><p>会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-8ed0949ea9e20edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>所以，我们可以看到，图例还是占用了一些位置。 让我们更改位置，大小并添加透明度：</p><pre><code>ax1.legend()leg = ax1.legend(loc=9, ncol=2,prop={'size':11})leg.get_frame().set_alpha(0.4)ax2v.legend()leg = ax2v.legend(loc=9, ncol=2,prop={'size':11})leg.get_frame().set_alpha(0.4)ax3.legend()leg = ax3.legend(loc=9, ncol=2,prop={'size':11})leg.get_frame().set_alpha(0.4)</code></pre><p>所有的图例位于位置 9（上中间）。 有很多地方可放置图例，我们可以为参数传入不同的位置号码，来看看它们都位于哪里。 <code>ncol</code>参数允许我们指定图例中的列数。 这里只有一列，如果图例中有 2 个项目，他们将堆叠在一列中。 最后，我们将尺寸规定为更小。 之后，我们对整个图例应用<code>0.4</code>的透明度。</p><p>现在我们的结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-395f6c13913c7a53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>完整的代码为：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure(facecolor='#f0f0f0')    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    plt.ylabel('H-L')    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1, sharex=ax1)    plt.ylabel('Price')    ax2v = ax2.twinx()    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1, sharex=ax1)    plt.ylabel('MAvgs')    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date[-start:],h_l[-start:],'-', label='H-L')    ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='lower'))    candlestick_ohlc(ax2, ohlc[-start:], width=0.4, colorup='#77d879', colordown='#db3f3f')    ax2.yaxis.set_major_locator(mticker.MaxNLocator(nbins=7, prune='upper'))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax2v.plot([],[], color='#0079a3', alpha=0.4, label='Volume')    ax2v.fill_between(date[-start:],0, volume[-start:], facecolor='#0079a3', alpha=0.4)    ax2v.axes.yaxis.set_ticklabels([])    ax2v.grid(False)    ax2v.set_ylim(0, 3*volume.max())    ax3.plot(date[-start:], ma1[-start:], linewidth=1, label=(str(MA1)+'MA'))    ax3.plot(date[-start:], ma2[-start:], linewidth=1, label=(str(MA2)+'MA'))    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &lt; ma2[-start:]),                     facecolor='r', edgecolor='r', alpha=0.5)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &gt; ma2[-start:]),                     facecolor='g', edgecolor='g', alpha=0.5)    ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax3.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='upper'))    for label in ax3.xaxis.get_ticklabels():        label.set_rotation(45)    plt.setp(ax1.get_xticklabels(), visible=False)    plt.setp(ax2.get_xticklabels(), visible=False)    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    ax1.legend()    leg = ax1.legend(loc=9, ncol=2,prop={'size':11})    leg.get_frame().set_alpha(0.4)    ax2v.legend()    leg = ax2v.legend(loc=9, ncol=2,prop={'size':11})    leg.get_frame().set_alpha(0.4)    ax3.legend()    leg = ax3.legend(loc=9, ncol=2,prop={'size':11})    leg.get_frame().set_alpha(0.4)    plt.show()    fig.savefig('google.png', facecolor=fig.get_facecolor())graph_data('GOOG')</code></pre><p>现在我们可以看到图例，但也看到了图例下的任何信息。 还要注意额外函数<code>fig.savefig</code>。 这是自动保存图形的图像的方式。 我们还可以设置所保存的图形的前景色，使背景不是白色的，如我们的例子所示。</p><p>这就是目前为止，我想要显示的典型 Matplotlib 图表。 接下来，我们将涉及<code>Basemap</code>，它是一个 Matplotlib 扩展，用于绘制地理位置，然后我打算讲解 Matplotlib 中的 3D 图形。</p><h1 id="第二十六章-Basemap-地理绘图"><a href="#第二十六章-Basemap-地理绘图" class="headerlink" title="第二十六章 Basemap 地理绘图"></a>第二十六章 Basemap 地理绘图</h1><p>在这个 Matplotlib 教程中，我们将涉及地理绘图模块<code>Basemap</code>。 <code>Basemap</code>是 Matplotlib 的扩展。</p><p>为了使用<code>Basemap</code>，我们首先需要安装它。 为了获得<code>Basemap</code>，你可以从这里获取：<a href="https://link.jianshu.com?t=http://matplotlib.org/basemap/users/download.html" target="_blank" rel="noopener">http://matplotlib.org/basemap/users/download.html</a>，或者你可以访问<a href="https://link.jianshu.com?t=http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a>。</p><p>如果你在安装<code>Basemap</code>时遇到问题，请查看<a href="https://link.jianshu.com?t=http://pythonprogramming.net/using-pip-install-for-python-modules/" target="_blank" rel="noopener"><code>pip</code>安装教程</a>。</p><p>一旦你安装了<code>Basemap</code>，你就可以创建地图了。 首先，让我们投影一个简单的地图。 为此，我们需要导入<code>Basemap</code>，<code>pyplot</code>，创建投影，至少绘制某种轮廓或数据，然后我们可以显示图形。</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill')m.drawcoastlines()plt.show()</code></pre><p>上面的代码结果如下：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-569ad48f57937c8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这是使用 Miller 投影完成的，这只是许多<a href="https://link.jianshu.com?t=http://matplotlib.org/basemap/users/mapsetup.html" target="_blank" rel="noopener"><code>Basemap</code>投影选项</a>之一。</p><h1 id="第二十七章-Basemap-自定义"><a href="#第二十七章-Basemap-自定义" class="headerlink" title="第二十七章 Basemap 自定义"></a>第二十七章 Basemap 自定义</h1><p>在这篇 Matplotlib 教程中，我们继续使用<code>Basemap</code>地理绘图扩展。 我们将展示一些我们可用的自定义选项。</p><p>首先，从上一个教程中获取我们的起始代码：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill')m.drawcoastlines()plt.show()</code></pre><p>我们可以从放大到特定区域来开始：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill',            llcrnrlat = -40,            llcrnrlon = -40,            urcrnrlat = 50,            urcrnrlon = 75)m.drawcoastlines()plt.show()</code></pre><p>这里的参数是：</p><ul><li><code>llcrnrlat</code> - 左下角的纬度</li><li><code>llcrnrlon</code> - 左下角的经度</li><li><code>urcrnrlat</code> - 右上角的纬度</li><li><code>urcrnrlon</code> - 右上角的经度</li></ul><p>此外，坐标需要转换，其中西经和南纬坐标是负值，北纬和东经坐标是正值。</p><p>使用这些坐标，<code>Basemap</code>会选择它们之间的区域。</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-05da7c940b2df3ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>下面，我们要使用一些东西，类似：</p><pre><code>m.drawcountries(linewidth=2)</code></pre><p>这会画出国家，并使用线宽为 2 的线条生成分界线。</p><p>另一个选项是：</p><pre><code>m.drawstates(color='b')</code></pre><p>这会用蓝色线条画出州。</p><p>你也可以执行：</p><pre><code>m.drawcounties(color='darkred')</code></pre><p>这会画出国家。</p><p>所以，我们的代码是：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill',            llcrnrlat = -90,            llcrnrlon = -180,            urcrnrlat = 90,            urcrnrlon = 180)m.drawcoastlines()m.drawcountries(linewidth=2)m.drawstates(color='b')m.drawcounties(color='darkred')plt.title('Basemap Tutorial')plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0defc2500a817a8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>很难说，但我们定义了美国的区县的线条。 我们可以使用放大镜放大<code>Basemap</code>图形，就像其他图形那样，会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a7a79fe24a963910.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>另一个有用的选项是<code>Basemap</code>调用中的『分辨率』选项。</p><pre><code>m = Basemap(projection='mill',            llcrnrlat = -90,            llcrnrlon = -180,            urcrnrlat = 90,            urcrnrlon = 180,            resolution='l')</code></pre><p>分辨率的选项为：</p><ul><li><code>c</code> - 粗糙</li><li><code>l</code> - 低</li><li><code>h</code> - 高</li><li><code>f</code> - 完整</li></ul><p>对于更高的分辨率，你应该放大到很大，否则这可能只是浪费。</p><p>另一个选项是使用<code>etopo()</code>绘制地形，如：</p><pre><code>m.etopo()</code></pre><p>使用<code>drawcountries</code>方法绘制此图形会生成：</p><p>[图片上传失败…(image-eaca82-1558445064342)]</p><p>最后，有一个蓝色的大理石版本，你可以调用：</p><pre><code>m.bluemarble()</code></pre><p>会生成：</p><p>[图片上传失败…(image-3f9978-1558445064342)]</p><p>目前为止的代码：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill',            llcrnrlat = -90,            llcrnrlon = -180,            urcrnrlat = 90,            urcrnrlon = 180,            resolution='l')m.drawcoastlines()m.drawcountries(linewidth=2)##m.drawstates(color='b')##m.drawcounties(color='darkred')#m.fillcontinents()#m.etopo()m.bluemarble()plt.title('Basemap Tutorial')plt.show()</code></pre><h1 id="第二十八章-在-Basemap-中绘制坐标"><a href="#第二十八章-在-Basemap-中绘制坐标" class="headerlink" title="第二十八章 在 Basemap 中绘制坐标"></a>第二十八章 在 Basemap 中绘制坐标</h1><p>欢迎阅读另一个 Matplotlib Basemap 教程。 在本教程中，我们将介绍如何绘制单个坐标，以及如何在地理区域中连接这些坐标。</p><p>首先，我们将从一些基本的起始数据开始：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill',            llcrnrlat = 25,            llcrnrlon = -130,            urcrnrlat = 50,            urcrnrlon = -60,            resolution='l')m.drawcoastlines()m.drawcountries(linewidth=2)m.drawstates(color='b')</code></pre><p>接下来，我们可以绘制坐标，从获得它们的实际坐标开始。 记住，南纬和西经坐标需要转换为负值。 例如，纽约市是北纬<code>40.7127</code>西经<code>74.0059</code>。 我们可以在我们的程序中定义这些坐标，如：</p><pre><code>NYClat, NYClon = 40.7127, -74.0059</code></pre><p>之后我们将这些转换为要绘制的<code>x</code>和<code>y</code>坐标。</p><pre><code>xpt, ypt = m(NYClon, NYClat)</code></pre><p>注意这里，我们现在已经将坐标顺序翻转为<code>lon, lat</code>（纬度，经度）。 坐标通常以<code>lat, lon</code>顺序给出。 然而，在图形中，<code>lat, long</code>转换为<code>y, x</code>，我们显然不需要。 在某些时候，你必须翻转它们。 不要忘记这部分！</p><p>最后，我们可以绘制如下的坐标：</p><pre><code>m.plot(xpt, ypt, 'c*', markersize=15)</code></pre><p>这个图表上有一个青色的星，大小为 15。更多标记类型请参阅：<a href="https://link.jianshu.com?t=http://matplotlib.org/api/markers_api.html" target="_blank" rel="noopener">Matplotlib 标记文档</a>。</p><p>接下来，让我们再画一个位置，洛杉矶，加利福尼亚：</p><pre><code>LAlat, LAlon = 34.05, -118.25xpt, ypt = m(LAlon, LAlat)m.plot(xpt, ypt, 'g^', markersize=15)</code></pre><p>这次我们画出一个绿色三角，执行代码会生成：</p><p>[图片上传失败…(image-8e5eff-1558445064342)]</p><p>如果我们想连接这些图块怎么办？原来，我们可以像其它 Matplotlib 图表那样实现它。</p><p>首先，我们将那些<code>xpt</code>和<code>ypt</code>坐标保存到列表，类似这样的东西：</p><pre><code>xs = []ys = []NYClat, NYClon = 40.7127, -74.0059xpt, ypt = m(NYClon, NYClat)xs.append(xpt)ys.append(ypt)m.plot(xpt, ypt, 'c*', markersize=15)LAlat, LAlon = 34.05, -118.25xpt, ypt = m(LAlon, LAlat)xs.append(xpt)ys.append(ypt)m.plot(xpt, ypt, 'g^', markersize=15)m.plot(xs, ys, color='r', linewidth=3, label='Flight 98')</code></pre><p>会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-d8819d892b150a41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>太棒了。有时我们需要以圆弧连接图上的两个坐标。如何实现呢？</p><pre><code>m.drawgreatcircle(NYClon, NYClat, LAlon, LAlat, color='c', linewidth=3, label='Arc')</code></pre><p>我们的完整代码为：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill',            llcrnrlat = 25,            llcrnrlon = -130,            urcrnrlat = 50,            urcrnrlon = -60,            resolution='l')m.drawcoastlines()m.drawcountries(linewidth=2)m.drawstates(color='b')#m.drawcounties(color='darkred')#m.fillcontinents()#m.etopo()#m.bluemarble()xs = []ys = []NYClat, NYClon = 40.7127, -74.0059xpt, ypt = m(NYClon, NYClat)xs.append(xpt)ys.append(ypt)m.plot(xpt, ypt, 'c*', markersize=15)LAlat, LAlon = 34.05, -118.25xpt, ypt = m(LAlon, LAlat)xs.append(xpt)ys.append(ypt)m.plot(xpt, ypt, 'g^', markersize=15)m.plot(xs, ys, color='r', linewidth=3, label='Flight 98')m.drawgreatcircle(NYClon, NYClat, LAlon, LAlat, color='c', linewidth=3, label='Arc')plt.legend(loc=4)plt.title('Basemap Tutorial')plt.show()</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-865c2809f199d4c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这就是<code>Basemap</code>的全部了，下一章关于 Matplotlib 的 3D 绘图。</p><h1 id="第二十九章-3D-绘图"><a href="#第二十九章-3D-绘图" class="headerlink" title="第二十九章 3D 绘图"></a>第二十九章 3D 绘图</h1><p>您好，欢迎阅读 Matplotlib 教程中的 3D 绘图。 Matplotlib 已经内置了三维图形，所以我们不需要再下载任何东西。 首先，我们需要引入一些完整的模块：</p><pre><code>from mpl_toolkits.mplot3d import axes3dimport matplotlib.pyplot as plt</code></pre><p>使用<code>axes3d</code>是因为它需要不同种类的轴域，以便在三维中实际绘制一些东西。 下面：</p><pre><code>fig = plt.figure()ax1 = fig.add_subplot(111, projection='3d')</code></pre><p>在这里，我们像通常一样定义图形，然后我们将<code>ax1</code>定义为通常的子图，只是这次使用 3D 投影。 我们需要这样做，以便提醒 Matplotlib 我们要提供三维数据。</p><p>现在让我们创建一些 3D 数据：</p><pre><code>x = [1,2,3,4,5,6,7,8,9,10]y = [5,6,7,8,2,5,6,3,7,2]z = [1,2,6,3,2,7,3,3,7,2]</code></pre><p>接下来，我们绘制它。 首先，让我们展示一个简单的线框示例：</p><pre><code>ax1.plot_wireframe(x,y,z)</code></pre><p>最后：</p><pre><code>ax1.set_xlabel('x axis')ax1.set_ylabel('y axis')ax1.set_zlabel('z axis')plt.show()</code></pre><p>我们完整的代码是：</p><pre><code>from mpl_toolkits.mplot3d import axes3dimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use('fivethirtyeight')fig = plt.figure()ax1 = fig.add_subplot(111, projection='3d')x = [1,2,3,4,5,6,7,8,9,10]y = [5,6,7,8,2,5,6,3,7,2]z = [1,2,6,3,2,7,3,3,7,2]ax1.plot_wireframe(x,y,z)ax1.set_xlabel('x axis')ax1.set_ylabel('y axis')ax1.set_zlabel('z axis')plt.show()</code></pre><p>结果为（包括所用的样式）：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-9d239adc0dcb7a4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这些 3D 图形可以进行交互。 首先，您可以使用鼠标左键单击并拖动来移动图形。 您还可以使用鼠标右键单击并拖动来放大或缩小。</p><h1 id="第三十章-3D-散点图"><a href="#第三十章-3D-散点图" class="headerlink" title="第三十章 3D 散点图"></a>第三十章 3D 散点图</h1><p>欢迎阅读另一个 3D Matplotlib 教程，会涉及如何绘制三维散点图。</p><p>绘制 3D 散点图非常类似于通常的散点图以及 3D 线框图。</p><p>一个简单示例：</p><pre><code>from mpl_toolkits.mplot3d import axes3dimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use('ggplot')fig = plt.figure()ax1 = fig.add_subplot(111, projection='3d')x = [1,2,3,4,5,6,7,8,9,10]y = [5,6,7,8,2,5,6,3,7,2]z = [1,2,6,3,2,7,3,3,7,2]x2 = [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]y2 = [-5,-6,-7,-8,-2,-5,-6,-3,-7,-2]z2 = [1,2,6,3,2,7,3,3,7,2]ax1.scatter(x, y, z, c='g', marker='o')ax1.scatter(x2, y2, z2, c ='r', marker='o')ax1.set_xlabel('x axis')ax1.set_ylabel('y axis')ax1.set_zlabel('z axis')plt.show()</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a225497e6ca29fad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>要记住你可以修改这些绘图的大小和标记，就像通常的散点图那样。</p><h1 id="第三十一章-3D-条形图"><a href="#第三十一章-3D-条形图" class="headerlink" title="第三十一章 3D 条形图"></a>第三十一章 3D 条形图</h1><p>在这个 Matplotlib 教程中，我们要介绍 3D 条形图。 3D 条形图是非常独特的，因为它允许我们绘制多于 3 个维度。 不，你不能超过第三个维度来绘制，但你可以绘制多于 3 个维度。</p><p>对于条形图，你需要拥有条形的起点，条形的高度和宽度。 但对于 3D 条形图，你还有另一个选项，就是条形的深度。 大多数情况下，条形图从轴上的条形平面开始，但是你也可以通过打破此约束来添加另一个维度。 然而，我们会让它非常简单：</p><pre><code>from mpl_toolkits.mplot3d import axes3dimport matplotlib.pyplot as pltimport numpy as npfrom matplotlib import stylestyle.use('ggplot')fig = plt.figure()ax1 = fig.add_subplot(111, projection='3d')x3 = [1,2,3,4,5,6,7,8,9,10]y3 = [5,6,7,8,2,5,6,3,7,2]z3 = np.zeros(10)dx = np.ones(10)dy = np.ones(10)dz = [1,2,3,4,5,6,7,8,9,10]ax1.bar3d(x3, y3, z3, dx, dy, dz)ax1.set_xlabel('x axis')ax1.set_ylabel('y axis')ax1.set_zlabel('z axis')plt.show()</code></pre><p>注意这里，我们必须定义<code>x</code>、<code>y</code>和<code>z</code>，然后是 3 个维度的宽度、高度和深度。 这会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-f56fa917c5a3b201.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第三十二章-总结"><a href="#第三十二章-总结" class="headerlink" title="第三十二章 总结"></a>第三十二章 总结</h1><p>欢迎阅读最后的 Matplotlib 教程。 在这里我们将整理整个系列，并显示一个稍微更复杂的 3D 线框图：</p><pre><code>from mpl_toolkits.mplot3d import axes3dimport matplotlib.pyplot as pltimport numpy as npfrom matplotlib import stylestyle.use('ggplot')fig = plt.figure()ax1 = fig.add_subplot(111, projection='3d')x, y, z = axes3d.get_test_data()print(axes3d.__file__)ax1.plot_wireframe(x,y,z, rstride = 3, cstride = 3)ax1.set_xlabel('x axis')ax1.set_ylabel('y axis')ax1.set_zlabel('z axis')plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-ae3534e87f53f7f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>如果你从一开始就关注这个教程的话，那么你已经学会了 Matplotlib 提供的大部分内容。 你可能不相信，但Matplotlib 仍然可以做很多其他的事情！ 请继续学习，你可以随时访问 Matplotlib.org，并查看示例和图库页面。</p><p>如果你发现自己大量使用 Matplotlib，请考虑捐助给 <a href="https://link.jianshu.com?t=http://numfocus.org/news/2012/08/28/johnhunter/" target="_blank" rel="noopener">John Hunter Memorial 基金</a>。</p><blockquote><p>注：空间曲面的画法</p></blockquote><blockquote><pre><code># 二次抛物面 z = x^2 + y^2x = np.linspace(-10, 10, 101)y = xx, y = np.meshgrid(x, y)z = x ** 2 + y ** 2ax = plot.subplot(111, projection='3d')ax.plot_wireframe(x, y, z)plot.show()</code></pre></blockquote><blockquote><p><img src="/images/loading.gif" data-original="//upload-images.jianshu.io/upload_images/118142-c9f07724a4639d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="image"></p></blockquote><blockquote><pre><code># 半径为 1 的球t = np.linspace(0, np.pi * 2, 100)s = np.linspace(0, np.pi, 100)t, s = np.meshgrid(t, s)x = np.cos(t) * np.sin(s)y = np.sin(t) * np.sin(s)z = np.cos(s)ax = plot.subplot(111, projection='3d')ax.plot_wireframe(x, y, z)plot.show()</code></pre></blockquote><blockquote><p><img src="/images/loading.gif" data-original="//upload-images.jianshu.io/upload_images/118142-de70433e1947688e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="image"></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-GUI图像化开发PyQt5</title>
      <link href="/posts/blog-python06.html"/>
      <url>/posts/blog-python06.html</url>
      
        <content type="html"><![CDATA[<h3 id="创建第一个GUI界面"><a href="#创建第一个GUI界面" class="headerlink" title="创建第一个GUI界面"></a>创建第一个GUI界面</h3><p>首先，我们使用pyqt5的窗口小部件创建一个最基本的GUI：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import *app = QApplication(sys.argv)   #应用程序对象win = QWidget()   #窗口控件对象win.show()sys.exit(app.exec_())    #事件循环发生在应用程序中</code></pre><ol><li>在上面的程序中，我们首先引用了需要的模块：sys和pyqt5的QtWidgets模块：</li></ol><ul><li>sys模块提供了访问由解释器使用或维护的变量和与解释器进行交互的函数；</li><li>QtWidgets模块包含提供一组UI元素以创建经典桌面式用户界面的方法，可以让我们很方便地创建窗口对象。</li></ul><ol start="2"><li>接着，我们实例化了一个应用程序对象QApplication()，在PyQt5中，每个应用程序都必须实例化一个QApplication()：</li><li>然后我们创建了一个QWidget()对象，它是pyqt5中所有的图形用户界面的基类:</li><li>再是使用QWidget对象的show()方法将创建的窗口显示出来:</li><li>最后，我们调用应用程序对象的exec_()方法来运行程序的主循环，并使用sys.exit()方法确保程序能够完美的退出。<h3 id="设置窗口标题、大小和位置"><a href="#设置窗口标题、大小和位置" class="headerlink" title="设置窗口标题、大小和位置"></a>设置窗口标题、大小和位置</h3><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import *app = QApplication(sys.argv)win = QWidget()win.resize(450,150)win.move(0,300)win.setWindowTitle('GUI')win.show()sys.exit(app.exec_())</code></pre>在这个程序中，我们设置了以下三点：</li></ol><ul><li>使用QWidget()对象的resize()方法设置窗口的大小为450*150；</li><li>使用QWidget()对象的move()方法，将窗口移动到显示器上x=0，y=300的位置；</li><li>使用QWidget()对象的setWindowTitle()方法，为我们的窗口设置了一个标题。<h3 id="面向对象化"><a href="#面向对象化" class="headerlink" title="面向对象化"></a>面向对象化</h3>前面的例子中，我们使用的是面向函数的编程方式。Python支持面对函数和面向对象两种编程方式，在PyQt5中，使用面向对象的编程方式更加符合其特点。所以接下来我们使用面对对象的编程方式来创建GUI程序。</li></ul><p>我们先将上一篇的例子，改造为面对对象的形式：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QWidgetclass GUi():    def __init__(self):        self.initUI()    def initUI(self):        self.win = QWidget()        self.win.setWindowTitle('GUI')if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUi()    gui.win.show()    sys.exit(app.exec_())</code></pre><p>在这里，我们创建了一个名为GUi的类，通过initUI()方法来创建窗口，并在初始化方法init()中调用它。</p><h3 id="在类中继承"><a href="#在类中继承" class="headerlink" title="在类中继承"></a>在类中继承</h3><p>除了使用原生的类，我们还能从pyqt5中继承一些模块，以此来获得相关模块的属性。比如，我们创建一个继承于QWidget()的类，那么它就拥有了QWidget()的方法和属性，这样我们就可以不实例化一个QWidget()对象而直接拥有QWidget()的属性：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QWidget# 继承自QWidgetclass GUi(QWidget):    def __init__(self):        # 实例化super类，用来创建窗口        super().__init__()        self.initUI()    def initUI(self):        self.setWindowTitle('GUI')if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUi()    gui.show()    sys.exit(app.exec_())</code></pre><h3 id="添加状态栏"><a href="#添加状态栏" class="headerlink" title="添加状态栏"></a>添加状态栏</h3><p>我们可以通过QMainWindow的statusBar()方法来设置GUI窗口底部的状态消息栏。</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QMainWindow,QApplicationclass GUI(QMainWindow):    def __init__(self):        super().__init__()        self.iniUI()    def iniUI(self):        self.setWindowTitle("州的先生Zmister.com Python GUI教程")        self.resize(400,300)        # 设置状态消息栏文本        self.statusBar().showMessage("文本状态栏")if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUI()    gui.show()    sys.exit(app.exec_())</code></pre><h3 id="添加菜单栏"><a href="#添加菜单栏" class="headerlink" title="添加菜单栏"></a>添加菜单栏</h3><p>同时，我们可以使用QMainWindow的statusBar()方法来在窗口中添加一个菜单栏：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QActionclass GUI(QMainWindow):    def __init__(self):        super().__init__()        self.iniUI()    def iniUI(self):        self.setWindowTitle("州的先生zmister.com PythonGUI教程")        self.statusBar().showMessage("文本状态栏")        self.resize(400, 300)        # 创建一个菜单栏        menu = self.menuBar()        # 创建一个菜单        file_menu = menu.addMenu("文件")        # 创建一个行为        new_action = QAction('新文件',self)        # 添加一个行为到菜单        file_menu.addAction(new_action)        # 更新状态栏文本        new_action.setStatusTip('新的文件')if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUI()    gui.show()    sys.exit(app.exec_())</code></pre><p>接下来，我们添加一个“修改”菜单按钮，再添加一个退出行为，用于后面进行退出关闭窗口：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QActionclass GUI(QMainWindow):    def __init__(self):        super().__init__()        self.iniUI()    def iniUI(self):        self.setWindowTitle("州的先生zmister.com PythonGUI教程")        self.statusBar().showMessage("文本状态栏")        self.resize(400, 300)        # 创建一个菜单栏        menu = self.menuBar()        # 创建两个个菜单        file_menu = menu.addMenu("文件")        file_menu.addSeparator()        edit_menu = menu.addMenu('修改')        # 创建一个行为        new_action = QAction('新的文件',self)        # 更新状态栏文本        new_action.setStatusTip('打开新的文件')        # 添加一个行为到菜单        file_menu.addAction(new_action)        # 创建退出行为        exit_action = QAction('退出',self)        # 退出操作        exit_action.setStatusTip("点击退出应用程序")        # 点击关闭程序        exit_action.triggered.connect(self.close)        # 设置退出快捷键        exit_action.setShortcut('Ctrl+Q')        # 添加退出行为到菜单上        file_menu.addAction(exit_action)if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUI()    gui.show()    sys.exit(app.exec_())</code></pre><p>我们像创建第一个菜单那样创建了第二个菜单“修改”菜单，然后创建了一个“退出”行为，重点看一下它的代码：</p><pre><code># 创建退出行为 exit_action = QAction('退出',self)# 退出操作exit_action.setStatusTip("点击退出应用程序")# 点击关闭程序exit_action.triggered.connect(self.close)# 设置退出快捷键exit_action.setShortcut('Ctrl+Q')# 添加退出行为到菜单上file_menu.addAction(exit_action)</code></pre><p>首先使用QAction()对象创建一个行为，然后使用setStatusTip()方法设置他的状态文本提示，接着使用triggered.connect()方法调用关闭窗口的接口，再使用setShortcut()方法设置了行为的快捷键，最后添加行为到菜单上。</p><h3 id="添加Label标签部件"><a href="#添加Label标签部件" class="headerlink" title="添加Label标签部件"></a>添加Label标签部件</h3><p>我们先在窗口中添加一个标签Label，使用QLabel模块。</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabelclass GUI(QMainWindow):    def __init__(self):        super().__init__()        self.iniUI()    def iniUI(self):        self.setWindowTitle("GUI")        self.resize(400, 300)        self.add_menu_and_statu()        self.add_position_layout()    # 添加菜单栏和状态栏    def add_menu_and_statu(self):        self.statusBar().showMessage("文本状态栏")        # 创建一个菜单栏        menu = self.menuBar()        # 创建两个菜单        file_menu = menu.addMenu("文件")        file_menu.addSeparator()        edit_menu = menu.addMenu('修改')        # 创建一个行为        new_action = QAction('新的文件',self)        # 更新状态栏文本        new_action.setStatusTip('打开新的文件')        # 添加一个行为到菜单        file_menu.addAction(new_action)        # 创建退出行为        exit_action = QAction('退出',self)        # 退出操作        exit_action.setStatusTip("点击退出应用程序")        # 点击关闭程序        exit_action.triggered.connect(self.close)        # 设置退出快捷键        exit_action.setShortcut('Ctrl+Q')        # 添加退出行为到菜单上        file_menu.addAction(exit_action)    # 添加布局部件    def add_position_layout(self):        label = QLabel("第一个标签",self)if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUI()    gui.show()    sys.exit(app.exec_())</code></pre><p>与之前的代码不同的是，我们新增了一个add_position_layout()方法，并在里面实例化了一个QLabel对象。<br>我们在add_position_layout方法中添加:</p><pre><code>label.move(10,20)</code></pre><p>这样一句代码，将label向右移动10个像素，向下移动20个像素<br>手动设置移动的高度很不灵活，我们可以先获取菜单栏的高度，再确定label标签移动的位置。<br>我们可以使用部件的size()方法获取部件的宽和高，使用height()方法获取部件的高度，使用width()方法获取到部件的宽度：</p><pre><code>    # 添加布局部件    def add_position_layout(self):        # 获取菜单栏的高度        mbar_height = self.menuBar().height()        # 第一个标签        label_1 = QLabel("第一个标签",self)        label_1.move(10,mbar_height)        # 第二个标签        label_2 = QLabel('第二个标签',self)        label_2.move(10,mbar_height*2)</code></pre><p>在add_position_layout()方法中，我们首先使用self.menuBar().height()获取到菜单栏的高度，然后新建了两个Label标签，移动的高度分别为菜单栏高度的一倍和两倍</p><h3 id="添加按钮部件"><a href="#添加按钮部件" class="headerlink" title="添加按钮部件"></a>添加按钮部件</h3><p>除了添加Label标签，我们还可以在窗口中使用QPushButton对象来创建按钮部件：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabel,QPushButtonclass GUI(QMainWindow):    def __init__(self):        super().__init__()        self.iniUI()    def iniUI(self):        self.setWindowTitle("Python")        self.resize(400, 300)        self.add_menu_and_statu()        self.add_position_layout()    # 添加菜单栏和状态栏    def add_menu_and_statu(self):        self.statusBar().showMessage("文本状态栏")        # 创建一个菜单栏        menu = self.menuBar()        # 创建两个菜单        file_menu = menu.addMenu("文件")        file_menu.addSeparator()        edit_menu = menu.addMenu('修改')        # 创建一个行为        new_action = QAction('新的文件',self)        # 更新状态栏文本        new_action.setStatusTip('打开新的文件')        # 添加一个行为到菜单        file_menu.addAction(new_action)        # 创建退出行为        exit_action = QAction('退出',self)        # 退出操作        exit_action.setStatusTip("点击退出应用程序")        # 点击关闭程序        exit_action.triggered.connect(self.close)        # 设置退出快捷键        exit_action.setShortcut('Ctrl+Q')        # 添加退出行为到菜单上        file_menu.addAction(exit_action)    # 添加布局部件    def add_position_layout(self):        # 获取菜单栏的高度        mbar_height = self.menuBar().height()        # 第一个标签        label_1 = QLabel("第一个标签",self)        label_1.move(10,mbar_height)        # 第二个标签        label_2 = QLabel('第二个标签',self)        label_2.move(10,mbar_height*2)        # 第一个按钮        button_1 = QPushButton("按钮1",self)        button_1.move(label_1.width(),mbar_height)        # 第二个按钮        button_2 = QPushButton("按钮2",self)        button_2.move(label_2.width(),mbar_height*2)if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUI()    gui.show()    sys.exit(app.exec_())</code></pre><h3 id="使用水平垂直布局"><a href="#使用水平垂直布局" class="headerlink" title="使用水平垂直布局"></a>使用水平垂直布局</h3><p>在前面的程序中，我们使用部件的move()方法来指定部件的位置，虽然很灵活，但是如果部件很多的话，就会很繁琐。<br>PyQt5提供了布局管理模块来支持部件的水平布局和垂直布局：</p><ul><li><p>QHBoxLayout：水平布局；</p></li><li><p>QVBoxLayout ：垂直布局。<br>接下来，我们在程序中使用这两种布局来讲label标签和button按钮放入布局中。</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabel,QPushButton,QVBoxLayout,QHBoxLayout,QWidgetclass GUI(QMainWindow):  def __init__(self):      super().__init__()      self.iniUI()  def iniUI(self):      self.setWindowTitle("PythonGUI")      self.resize(400, 300)      self.add_menu_and_statu()      self.horizontal_vertical_box_layout()  # 添加菜单栏和状态栏  def add_menu_and_statu(self):      self.statusBar().showMessage("文本状态栏")      # 创建一个菜单栏      menu = self.menuBar()      # 创建两个菜单      file_menu = menu.addMenu("文件")      file_menu.addSeparator()      edit_menu = menu.addMenu('修改')      # 创建一个行为      new_action = QAction('新的文件',self)      # 更新状态栏文本      new_action.setStatusTip('打开新的文件')      # 添加一个行为到菜单      file_menu.addAction(new_action)      # 创建退出行为      exit_action = QAction('退出',self)      # 退出操作      exit_action.setStatusTip("点击退出应用程序")      # 点击关闭程序      exit_action.triggered.connect(self.close)      # 设置退出快捷键      exit_action.setShortcut('Ctrl+Q')      # 添加退出行为到菜单上      file_menu.addAction(exit_action)  # 水平垂直布局  def horizontal_vertical_box_layout(self):      # 两个标签      label_1 = QLabel('第一个标签')      label_2 = QLabel('第二个标签')      # 两个按钮      button_1 = QPushButton('第一个按钮')      button_2 = QPushButton('第二个按钮')      # 创建两个水平盒子      hbox_1 = QHBoxLayout()      hbox_2 = QHBoxLayout()      # 在水平盒子1中添加一个标签和一个按钮      hbox_1.addWidget(label_1)      hbox_1.addWidget(button_1)      # 在水平盒子2中添加标签2和按钮2      hbox_2.addWidget(label_2)      hbox_2.addWidget(button_2)      # 创建一个垂直盒子，包含两个水平盒子      vbox = QVBoxLayout()      vbox.addLayout(hbox_1)      vbox.addLayout(hbox_2)      # 创建一个窗口部件，设置布局为垂直盒子      layout_widget = QWidget()      layout_widget.setLayout(vbox)      self.setCentralWidget(layout_widget)if __name__ == '__main__':  app = QApplication(sys.argv)  gui = GUI()  gui.show()  sys.exit(app.exec_())</code></pre><p>我们在horizontal_vertical_box_layout()方法中创建了一个窗口部件、一个垂直盒子、两个水平盒子、两个按钮和两个文本标签，分别进行了嵌套.</p><h3 id="使用网格布局"><a href="#使用网格布局" class="headerlink" title="使用网格布局"></a>使用网格布局</h3><p>在PyQt5中，除了能够使用垂直布局和水平布局，我们还可以使用网格布局来管理窗口部件。<br>网格布局使用QGridLayout模块来创建，然后使用addWidget()方法添加窗口小部件以及它的位置：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabel,QPushButton,QVBoxLayout,QHBoxLayout,QWidget,QGridLayoutclass GUI(QMainWindow):  def __init__(self):      super().__init__()      self.iniUI()  def iniUI(self):      self.setWindowTitle("PythonGUI")      self.resize(400, 300)      self.add_menu_and_statu()      self.grid_layout()  # 添加菜单栏和状态栏  def add_menu_and_statu(self):      self.statusBar().showMessage("文本状态栏")      # 创建一个菜单栏      menu = self.menuBar()      # 创建两个菜单      file_menu = menu.addMenu("文件")      file_menu.addSeparator()      edit_menu = menu.addMenu('修改')      # 创建一个行为      new_action = QAction('新的文件',self)      # 更新状态栏文本      new_action.setStatusTip('打开新的文件')      # 添加一个行为到菜单      file_menu.addAction(new_action)      # 创建退出行为      exit_action = QAction('退出',self)      # 退出操作      exit_action.setStatusTip("点击退出应用程序")      # 点击关闭程序      exit_action.triggered.connect(self.close)      # 设置退出快捷键      exit_action.setShortcut('Ctrl+Q')      # 添加退出行为到菜单上      file_menu.addAction(exit_action)  # 网格布局  def grid_layout(self):      # 两个标签      label_1 = QLabel('第一个标签')      label_2 = QLabel('第二个标签')      # 两个按钮      button_1 = QPushButton('第一个按钮')      button_2 = QPushButton('第二个按钮')      # 创建一个网格布局对象      grid_layout = QGridLayout()      # 在网格中添加窗口部件      grid_layout.addWidget(label_1,0,0) # 放置在0行0列      grid_layout.addWidget(button_1,0,1) # 0行1列      grid_layout.addWidget(label_2,1,0) # 1行0列      grid_layout.addWidget(button_2,1,1) # 1行1列      # 创建一个窗口对象      layout_widget = QWidget()      # 设置窗口的布局层      layout_widget.setLayout(grid_layout)      self.setCentralWidget(layout_widget)if __name__ == '__main__':  app = QApplication(sys.argv)  gui = GUI()  gui.show()  sys.exit(app.exec_())</code></pre><p>在网格布局中，我们可以指定表格的对齐方式，使用网格布局对象的setAlignment()方法：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabel,QPushButton,QVBoxLayout,QHBoxLayout,QWidget,QGridLayoutfrom PyQt5.QtCore import Qtclass GUI(QMainWindow):  def __init__(self):      super().__init__()      self.iniUI()  def iniUI(self):      self.setWindowTitle("PythonGUI")      self.resize(400, 300)      self.add_menu_and_statu()      self.grid_layout()  # 添加菜单栏和状态栏  def add_menu_and_statu(self):      self.statusBar().showMessage("文本状态栏")      # 创建一个菜单栏      menu = self.menuBar()      # 创建两个菜单      file_menu = menu.addMenu("文件")      file_menu.addSeparator()      edit_menu = menu.addMenu('修改')      # 创建一个行为      new_action = QAction('新的文件',self)      # 更新状态栏文本      new_action.setStatusTip('打开新的文件')      # 添加一个行为到菜单      file_menu.addAction(new_action)      # 创建退出行为      exit_action = QAction('退出',self)      # 退出操作      exit_action.setStatusTip("点击退出应用程序")      # 点击关闭程序      exit_action.triggered.connect(self.close)      # 设置退出快捷键      exit_action.setShortcut('Ctrl+Q')      # 添加退出行为到菜单上      file_menu.addAction(exit_action)  # 网格布局  def grid_layout(self):      # 两个标签      label_1 = QLabel('第一个标签')      label_2 = QLabel('第二个标签')      # 两个按钮      button_1 = QPushButton('第一个按钮')      button_2 = QPushButton('第二个按钮')      # 创建一个网格布局对象      grid_layout = QGridLayout()      # 在网格中添加窗口部件      grid_layout.addWidget(label_1,0,0) # 放置在0行0列      grid_layout.addWidget(button_1,0,1) # 0行1列      grid_layout.addWidget(label_2,1,0) # 1行0列      grid_layout.addWidget(button_2,1,1) # 1行1列      grid_layout.setAlignment(Qt.AlignTop)      # 创建一个窗口对象      layout_widget = QWidget()      # 设置窗口的布局层      layout_widget.setLayout(grid_layout)      self.setCentralWidget(layout_widget)if __name__ == '__main__':  app = QApplication(sys.argv)  gui = GUI()  gui.show()  sys.exit(app.exec_())</code></pre><p>我们从PyQt5的QtCore模块中导入了Qt模块，用来指定对齐方式：</p><pre><code>from PyQt5.QtCore import Qt</code></pre><p>然后在创建的网格布局对象下，使用setAlignment来指定这个表格布局的对齐方式，内容为Qt的AlignTop属性，表示顶部对齐：</p><pre><code>grid_layout.setAlignment(Qt.AlignTop)</code></pre><p>除了对网格布局对象设置对齐方式，还能够对窗口小部件单独设置对齐方式，同样使用setAlignment()方法，传递两个参数，一个使部件名，一个使对齐方式：</p><pre><code>grid_layout.setAlignment(label_1,Qt.AlignRight)</code></pre><p>在对窗口部件设置行列的位置的时候，我们除了可以指定其行数和列数，还能够指定其跨越多少行以及跨越多少列，我们新建一个按钮，让其占1行和5列，看看效果：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabel,QPushButton,QVBoxLayout,QHBoxLayout,QWidget,QGridLayoutfrom PyQt5.QtCore import Qtclass GUI(QMainWindow):  def __init__(self):      super().__init__()      self.iniUI()  def iniUI(self):      self.setWindowTitle("PythonGUI")      self.resize(400, 300)      self.add_menu_and_statu()      self.grid_layout()  # 添加菜单栏和状态栏  def add_menu_and_statu(self):      self.statusBar().showMessage("文本状态栏")      # 创建一个菜单栏      menu = self.menuBar()      # 创建两个菜单      file_menu = menu.addMenu("文件")      file_menu.addSeparator()      edit_menu = menu.addMenu('修改')      # 创建一个行为      new_action = QAction('新的文件',self)      # 更新状态栏文本      new_action.setStatusTip('打开新的文件')      # 添加一个行为到菜单      file_menu.addAction(new_action)      # 创建退出行为      exit_action = QAction('退出',self)      # 退出操作      exit_action.setStatusTip("点击退出应用程序")      # 点击关闭程序      exit_action.triggered.connect(self.close)      # 设置退出快捷键      exit_action.setShortcut('Ctrl+Q')      # 添加退出行为到菜单上      file_menu.addAction(exit_action)  # 表格布局  def grid_layout(self):      # 两个标签      label_1 = QLabel('第一个标签')      label_2 = QLabel('第二个标签')      # 两个按钮      button_1 = QPushButton('第一个按钮')      button_2 = QPushButton('第二个按钮')      button_3 = QPushButton('第三个按钮')      # 创建一个表格布局对象      grid_layout = QGridLayout()      # 在表格中添加窗口部件      grid_layout.addWidget(label_1,0,0) # 放置在0行0列      grid_layout.addWidget(button_1,0,1) # 0行1列      grid_layout.addWidget(label_2,1,0) # 1行0列      grid_layout.addWidget(button_2,1,1) # 1行1列      grid_layout.addWidget(button_3,2,0,1,5)      # 对齐方式      grid_layout.setAlignment(Qt.AlignTop)      grid_layout.setAlignment(label_1,Qt.AlignRight)      # 创建一个窗口对象      layout_widget = QWidget()      # 设置窗口的布局层      layout_widget.setLayout(grid_layout)      self.setCentralWidget(layout_widget)if __name__ == '__main__':  app = QApplication(sys.argv)  gui = GUI()  gui.show()  sys.exit(app.exec_())</code></pre><h3 id="安装PyQt5-设计师工具"><a href="#安装PyQt5-设计师工具" class="headerlink" title="安装PyQt5 设计师工具"></a>安装PyQt5 设计师工具</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h5><pre><code>pip install pyqt5-tools</code></pre><h5 id="使用Qt-Designer创建GUI窗口"><a href="#使用Qt-Designer创建GUI窗口" class="headerlink" title="使用Qt Designer创建GUI窗口:"></a>使用Qt Designer创建GUI窗口:</h5><p>打开qt设计师之后，我们可以在“新建窗体”窗口中选择各种窗口的模板来进行窗口的创建:<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-bc7cabd3e6a1c5df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>接下来，我们使用qt设计师创建一个GUI 窗口程序。</p></li><li><p>通过Qt Designer创建第一个GUI窗口<br>我们在“新建窗体”窗口中选择“Main Window”来创建一个空白的主窗口：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-bee59060c47e97ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>qt设计师的主面板出现了一个空白的窗口GUI，我们可以使用快捷键Ctrl+R对窗口进行预览：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-76e68a9e2646ece2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>在右侧的选项栏中，可以对窗口的各种属性进行设置：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-12b41190aa24829b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>如图我们修改了窗口的大小。</p></li><li><p>修改窗口标题<br>新建的窗口使用的是默认的标题，我们可以在右侧的“windowTitle”选项中修改窗口标题：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-ff16218e32bcd75a.gif?imageMogr2/auto-orient/strip" alt="image"></p></li><li><p>在GUI中添加菜单栏和子菜单<br>使用qt设计师也可以很方便地创建菜单和子菜单，直接点击操作，简单迅速：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-ccbca8c01d8c18c8.gif?imageMogr2/auto-orient/strip" alt="image"></p></li><li><p>为菜单选项添加图标<br>菜单创建之后，只有文字很是单调，我们可以在icon选项中为菜单添加图标：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-8842fbf61cd48fda.gif?imageMogr2/auto-orient/strip" alt="image"></p></li><li><p>添加文本到状态栏<br>在上一篇中，我们使用statusBar()方法来设置窗口状态栏的文本，在qt设计师中，通过“statusTip”选项同样可以快速设置：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-ce9e37e9db5074ac.gif?imageMogr2/auto-orient/strip" alt="image"></p></li><li><p>保存UI设计<br>最后，我们保存设计好的qt设计文件，以供日后使用：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-5c18c91ca1a91d94.gif?imageMogr2/auto-orient/strip" alt="image"></p></li></ul><h3 id="通过Qt设计师在GUI中添加窗口部件"><a href="#通过Qt设计师在GUI中添加窗口部件" class="headerlink" title="通过Qt设计师在GUI中添加窗口部件"></a>通过Qt设计师在GUI中添加窗口部件</h3><h5 id="继续添加一个菜单"><a href="#继续添加一个菜单" class="headerlink" title="继续添加一个菜单"></a>继续添加一个菜单</h5><p>使用代码创建了GUI，我们继续在GUI窗口中创建一个“修改”菜单：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-3dbc23ea52c30731.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="为“退出”菜单添加状态栏信息"><a href="#为“退出”菜单添加状态栏信息" class="headerlink" title="为“退出”菜单添加状态栏信息"></a>为“退出”菜单添加状态栏信息</h5><p>目前使用qt设计师创建的GUI中，当鼠标移动到菜单项时，底部的状态栏是不会有变化的：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-d8b0d93f1e465283.gif?imageMogr2/auto-orient/strip" alt="image"><br>我们通过右侧的属性设置列表中的“statusTip”，设置为：当鼠标移动到“退出”按钮时，状态栏提示“点击退出应用程序”：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-99bc57de238dcded.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="为“退出”菜单添加一个关闭信号，来实现点击关闭程序"><a href="#为“退出”菜单添加一个关闭信号，来实现点击关闭程序" class="headerlink" title="为“退出”菜单添加一个关闭信号，来实现点击关闭程序"></a>为“退出”菜单添加一个关闭信号，来实现点击关闭程序</h5><p>在qt设计师面板右侧的“信号/槽编辑器”中，我们可以添加一个信号/槽。<br>在Pyqt中，响应和操作可以通过信号/槽来实现，一个信号槽由发送者、信号、接收者和槽组成，发送者发生信号，然后接收者调用槽。</p><p>我们使用信号槽来为“退出”菜单添加一个关闭窗口的操作：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-6bf581dba81dfd8b.gif?imageMogr2/auto-orient/strip" alt="image"><br>其中：</p><ul><li>发送者为“退出”菜单的name;</li><li>信号为triggerd()，也就是触发的意思；</li><li>接收者为主窗口；</li><li>槽为close()方法，也就是退出操作。<h5 id="为“退出”菜单项添加一个快捷键"><a href="#为“退出”菜单项添加一个快捷键" class="headerlink" title="为“退出”菜单项添加一个快捷键"></a>为“退出”菜单项添加一个快捷键</h5>在实现了“退出”菜单项的功能之后，我们可以为菜单项设置一个快捷键，以进行快捷操作。</li></ul><p>快捷键的设置在“动作编辑器”选项卡中进行编辑设置：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-c92b1d59432250c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>双击快捷键，弹出快捷键的编辑窗口：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-bfe8f55ad08f2edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>我们设置Ctrl+Q作为退出的快捷键：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-fe7e220f47863d06.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="在窗口中添加选项卡"><a href="#在窗口中添加选项卡" class="headerlink" title="在窗口中添加选项卡"></a>在窗口中添加选项卡</h5><p>选项卡在GUI程序中是很常见的小部件，可以分隔不同的内。在qt设计师中，可以直接从左侧的部件列表中拖拽添加到窗口中：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-2a1c6967cf418ac1.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="在选项卡中添加按钮和其他小部件"><a href="#在选项卡中添加按钮和其他小部件" class="headerlink" title="在选项卡中添加按钮和其他小部件"></a>在选项卡中添加按钮和其他小部件</h5><p>在主窗口中添加选项卡部件后，我们可以在选项卡部件中继续添加其他的小部件，我们分别拖拽添加一个按钮部件和一个刻度盘部件（添加部件之后，部件属性可以在右侧的属性列表中进行设置）：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-9529263f1638cf1e.gif?imageMogr2/auto-orient/strip" alt="image"></p><h3 id="使用Qt设计师进行窗口布局"><a href="#使用Qt设计师进行窗口布局" class="headerlink" title="使用Qt设计师进行窗口布局"></a>使用Qt设计师进行窗口布局</h3><h5 id="垂直布局"><a href="#垂直布局" class="headerlink" title="垂直布局"></a>垂直布局</h5><p>从左侧面板的“Layouts”栏中拖拽“Vertical Layout”到GUI窗口中，设置好布局大小，再在“Buttons”栏中拖拽3个“Push Button”到设置好大小的“Vertical Layout”中：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-34b3153b7bf7984e.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="水平布局"><a href="#水平布局" class="headerlink" title="水平布局"></a>水平布局</h5><p>从左侧面板的“Layouts”栏中拖拽“Horizontal Layout”到GUI窗口中，设置好布局大小，再在“Buttons”栏中拖拽3个“Push Button”到设置好大小的“Horizontal Layout”中：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-3d63f8db65137bb8.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="使用水平布局、垂直布局的另一种方式"><a href="#使用水平布局、垂直布局的另一种方式" class="headerlink" title="使用水平布局、垂直布局的另一种方式"></a>使用水平布局、垂直布局的另一种方式</h5><p>上面我们使用的是先设置一个布局部件，再将窗口部件放入布局部件之中布局方式。除此之外，我们还可以先在GUI窗口中放置窗口部件，框选需要进行布局的部件，再使用工具栏中的“水平布局”、“垂直布局”按钮对窗口部件进行布局管理：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-cd216aa5919da58c.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h5><p>与垂直布局和水平布局一样，网格布局也可以使用上述的两种方法来对窗口部件进行布局管理：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-02e34c849829440b.gif?imageMogr2/auto-orient/strip" alt="image"><br>除了对部件进行布局之外，我们还可以在网格中再进行嵌套布局：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-18d6689d1cdfae1f.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="容器布局"><a href="#容器布局" class="headerlink" title="容器布局"></a>容器布局</h5><p>除了使用布局控件之外，我们还能使用容器进行粗略的布局，下面以groupBox容器作为演示：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-a80aa69e355d5d6d.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="使用“Spacer”间隔"><a href="#使用“Spacer”间隔" class="headerlink" title="使用“Spacer”间隔"></a>使用“Spacer”间隔</h5><p>我们在布局部件中放置的窗口部件都是等距离的，如果我们需要对其中某个部件的距离设置远一点呢，可以使用“Spacer”间隔部件。<br>“Spacer”部件分为两种：</p><ul><li>Horizontal Spacer：垂直间隔；</li><li>Vertical Spacer：水平间隔。<br>间隔部件在左侧部件的“Spacer”栏中，下面我们演示一下：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-c812a0136a6addc1.gif?imageMogr2/auto-orient/strip" alt="image"><h5 id="为标签设置“伙伴”"><a href="#为标签设置“伙伴”" class="headerlink" title="为标签设置“伙伴”"></a>为标签设置“伙伴”</h5>Pyqt中有一个好用的基本功能就是“伙伴”部件，当用户键入标签的快捷键时，光标的焦点会出现在标签的伙伴上。例如：我们有一个用户名的标签和一个用户名的输入框，设置用户名标签与用户名输入框为“伙伴”，设置用户名标签的文本为”用户名(&amp;2)”，表示用户名标签的快捷键为Alt+2，如果我们按快捷键Alt+2，那么光标的输入符就会移动到用户名的输入框中。</li></ul><p>qt设计师中，“伙伴”功能，在工具栏的“编辑伙伴”按钮中：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-ac1289af24eee320.gif?imageMogr2/auto-orient/strip" alt="image"></p><h3 id="转换qt设计师的ui代码为Python代码"><a href="#转换qt设计师的ui代码为Python代码" class="headerlink" title="转换qt设计师的ui代码为Python代码"></a>转换qt设计师的ui代码为Python代码</h3><h5 id="查看qt设计师生成的UI文件"><a href="#查看qt设计师生成的UI文件" class="headerlink" title="查看qt设计师生成的UI文件"></a>查看qt设计师生成的UI文件</h5><p>我们在qt设计师中设计好的GUI窗口都会被保存为.ui格式的文件。<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-3bdca8401cdc4b77.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>实质上，.ui文件依然是文本格式文件，我们使用notepad++打开刚刚保存的.ui文件：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-aec4627b7ae4eb76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840" alt="image"><br>可以发现，.ui文件其实是一个xml文件，其通过不同的标签来表示不同的窗口部件或是行为和信号槽的声明和描述。</p><h5 id="通过pyuic5转换UI文件为Python文件"><a href="#通过pyuic5转换UI文件为Python文件" class="headerlink" title="通过pyuic5转换UI文件为Python文件"></a>通过pyuic5转换UI文件为Python文件</h5><p>设计好的UI文件如何需要转换为Python文件，该怎么办？毕竟我们需要使用Python来扩展GUI的功能。</p><p>我们可以使用PyQt自带的pyuic5工具，对Qt设计师保存的.ui文件进行转换。</p><p>pyuic5是一个命令行工具，直接在cmd命令行界面运行即可。下面我们使用pyuic5将刚刚保存的UI文件转换问Python代码：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-01778d3227a1f501.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>运行之后，便会自动生成一个ui2py.py的python文件，我们打开看看：</p><pre><code>from PyQt5 import QtCore, QtGui, QtWidgetsclass Ui_MainWindow(object):    def setupUi(self, MainWindow):        MainWindow.setObjectName("MainWindow")        MainWindow.resize(585, 477)        self.centralwidget = QtWidgets.QWidget(MainWindow)        self.centralwidget.setObjectName("centralwidget")        self.pushButton = QtWidgets.QPushButton(self.centralwidget)        self.pushButton.setGeometry(QtCore.QRect(170, 140, 75, 23))        self.pushButton.setObjectName("pushButton")        MainWindow.setCentralWidget(self.centralwidget)        self.menubar = QtWidgets.QMenuBar(MainWindow)        self.menubar.setGeometry(QtCore.QRect(0, 0, 585, 23))        self.menubar.setObjectName("menubar")        self.menu = QtWidgets.QMenu(self.menubar)        self.menu.setObjectName("menu")        MainWindow.setMenuBar(self.menubar)        self.statusbar = QtWidgets.QStatusBar(MainWindow)        self.statusbar.setObjectName("statusbar")        MainWindow.setStatusBar(self.statusbar)        self.actionMen1 = QtWidgets.QAction(MainWindow)        self.actionMen1.setObjectName("actionMen1")        self.actionMen2 = QtWidgets.QAction(MainWindow)        self.actionMen2.setObjectName("actionMen2")        self.menu.addAction(self.actionMen1)        self.menu.addSeparator()        self.menu.addAction(self.actionMen2)        self.menubar.addAction(self.menu.menuAction())        self.retranslateUi(MainWindow)        QtCore.QMetaObject.connectSlotsByName(MainWindow)    def retranslateUi(self, MainWindow):        _translate = QtCore.QCoreApplication.translate        MainWindow.setWindowTitle(_translate("MainWindow", "州的先生zmister.com PythonGUI教程"))        self.pushButton.setText(_translate("MainWindow", "PushButton"))        self.menu.setTitle(_translate("MainWindow", "文件"))        self.actionMen1.setText(_translate("MainWindow", "men1"))        self.actionMen2.setText(_translate("MainWindow", "men2"))if __name__ == "__main__":    import sys    app = QtWidgets.QApplication(sys.argv)    MainWindow = QtWidgets.QMainWindow()    ui = Ui_MainWindow()    ui.setupUi(MainWindow)    MainWindow.show()    sys.exit(app.exec_())</code></pre><p>生成的是标准的Python代码，运行一下，看看是否和qt设计师中的一致：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-872443049a153b3e.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h5 id="修改信号槽"><a href="#修改信号槽" class="headerlink" title="修改信号槽"></a>修改信号槽</h5><p>除了直接使用UI文件转换而来的PythonGUI代码，我们有时候也需要对部分事件进行修改。<br>我们可以在qt设计师中添加简单的信号槽，复制的信号槽还是得自己在python代码中定义。</p><p>首先，我们在窗口中添加一个label标签，设置一个信号槽为：点击按钮的时候，label标签就清空。<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-740601008cb3ac84.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>然后使用pyuic5将其转换为Python代码，运行正常，按钮的信号槽也正常：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-bdb8602afe300755.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-bdb8602afe300755.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>下面，我们并不想在点击button按钮的时候label标签消失，而是换一个文字。我们该怎么做呢？</p><p>直接在Python代码中进行修改，添加一个方法，并连接到信号槽上：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-563c759f395572c3.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>现在点击按钮之后，label标签会变为“zmister”而不是像之前那样清空。</p><h3 id="在主窗口中调用对话框"><a href="#在主窗口中调用对话框" class="headerlink" title="在主窗口中调用对话框"></a>在主窗口中调用对话框</h3><h5 id="一、创建两个窗口"><a href="#一、创建两个窗口" class="headerlink" title="一、创建两个窗口"></a>一、创建两个窗口</h5><p>根据本篇的最终目标——在主窗口中调用对话窗口，我们先使用qt设计师创建两个窗口，其中一个主窗口MainWindows，一个含有两个按钮的对话窗口Dialog。</p><p>通过qt设计师新建一个MainWindows窗口，并在其中放置一个按钮：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-3fa60dd34af48bb7.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>保存为UI文件，再新建一个对话窗口：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-c22ddf8df0584532.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>同样保存为UI文件。<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-cd8246c55fc7c0ee.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>这样我们本地文件夹有两个可供转换为Python代码的UI文件：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-0b2049c78e7aa45e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h5 id="二、转换UI文件为Python代码文件"><a href="#二、转换UI文件为Python代码文件" class="headerlink" title="二、转换UI文件为Python代码文件"></a>二、转换UI文件为Python代码文件</h5><p>保存好两个窗口的UI文件之后，我们继续使用pyuic5工具，将这两个UI文件转换为Python代码文件。<br>打开命令行输入：</p><pre><code>pyuic5 -x -o mainWindow.py mainWindow.uipyuic5 -x -o dialog.py dialog.ui</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-52f229f250597097.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>运行一下转换出来的Python文件，是否正常：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-1ad78cb14b74c934.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h5 id="三、从主窗口中调用对话框窗口"><a href="#三、从主窗口中调用对话框窗口" class="headerlink" title="三、从主窗口中调用对话框窗口"></a>三、从主窗口中调用对话框窗口</h5><p>在进行下一步之前，我们先在主窗口mainWindow中添加一个文本标签，设置文本为空，字体加大：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-fa3cc63b4314a492.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>有个这个label我们可以将对对话框的操作，反馈在label标签中。</p><p>保存UI文件，使用pyuic5重新转换一次Python代码。</p><p>为了在主窗口代码中调用对话框窗口，我们需要在mainWindow.py文件中引入对话框窗口：</p><pre><code>from GUI import dialog</code></pre><p>然后定义在主窗口的主类中定义一个方法，用来显示对话框窗口：</p><pre><code>def click_button(self):    Dialog = QtWidgets.QDialog()    ui = dialog.Ui_Dialog()    ui.setupUi(Dialog)    Dialog.show()    Dialog.exec_()</code></pre><p>定义好了方法，我们需要对按钮进行点击调用的绑定，这在setupUi()方法中进行设置：</p><pre><code>self.pushButton.clicked.connect(self.click_button)</code></pre><p>这样就实现了按钮点击绑定对话框。<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-85b9c1c0986b3142.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>我们知道，我们的对话框是有两个按钮的，一个“OK”，一个“Cancel”，在我们的GUI程序中，点击任意一个都会关闭对话框，效果似乎是一样的，但在PyQt5的内部机制的，这是两个不同的事件，下面我们就通过之前设置的label标签，展示其不同的机制。</p><p>我们修改一下click_button()方法，修改如下：</p><pre><code>def click_button(self):    Dialog = QtWidgets.QDialog()    ui = dialog.Ui_Dialog()    ui.setupUi(Dialog)    Dialog.show()    # Dialog.exec_()    rsp = Dialog.exec_()    if rsp == QtWidgets.QDialog.Accepted:        self.label.setText("点击了OK")    else:        self.label.setText("点击了Cannel")</code></pre><p>在这里我们将对话框的运行赋值给了一个变量，然后将其与QtWidgets.QDialog.Accepted进行比较，QtWidgets.QDialog.Accepted表示的是对话框的接收事件，也就是“OK”代表的事件，如果为接收时间，设置label标签为“点击了OK”，否则设置label标签为“点击了Cannel”<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-38b164313cdf120b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | PyQt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Pandas详解</title>
      <link href="/posts/blog-python05.html"/>
      <url>/posts/blog-python05.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、生成数据表"><a href="#一、生成数据表" class="headerlink" title="一、生成数据表"></a>一、生成数据表</h1><h2 id="1、首先导入pandas库，一般都会用到numpy库，所以我们先导入备用："><a href="#1、首先导入pandas库，一般都会用到numpy库，所以我们先导入备用：" class="headerlink" title="1、首先导入pandas库，一般都会用到numpy库，所以我们先导入备用："></a>1、首先导入pandas库，一般都会用到numpy库，所以我们先导入备用：</h2><p>import numpy as np<br>import pandas as pd</p><h2 id="2、导入CSV或者xlsx文件："><a href="#2、导入CSV或者xlsx文件：" class="headerlink" title="2、导入CSV或者xlsx文件："></a>2、导入CSV或者xlsx文件：</h2><p>df = pd.DataFrame(pd.read_csv(‘name.csv’,header=1))<br>df = pd.DataFrame(pd.read_excel(‘name.xlsx’))</p><h2 id="3、用pandas创建数据表："><a href="#3、用pandas创建数据表：" class="headerlink" title="3、用pandas创建数据表："></a>3、用pandas创建数据表：</h2><pre><code>df = pd.DataFrame({"id":[1001,1002,1003,1004,1005,1006],  "date":pd.date_range('20130102', periods=6),  "city":['Beijing ', 'SH', ' guangzhou ', 'Shenzhen', 'shanghai', 'BEIJING '], "age":[23,44,54,32,34,32], "category":['100-A','100-B','110-A','110-C','210-A','130-F'],  "price":[1200,np.nan,2133,5433,np.nan,4432]},  columns =['id','date','city','category','age','price'])</code></pre><h1 id="二、数据表信息查看"><a href="#二、数据表信息查看" class="headerlink" title="二、数据表信息查看"></a>二、数据表信息查看</h1><h2 id="1、维度查看："><a href="#1、维度查看：" class="headerlink" title="1、维度查看："></a>1、维度查看：</h2><p>df.shape</p><h2 id="2、数据表基本信息（维度、列名称、数据格式、所占空间等）："><a href="#2、数据表基本信息（维度、列名称、数据格式、所占空间等）：" class="headerlink" title="2、数据表基本信息（维度、列名称、数据格式、所占空间等）："></a>2、数据表基本信息（维度、列名称、数据格式、所占空间等）：</h2><p>df.info()</p><h2 id="3、每一列数据的格式："><a href="#3、每一列数据的格式：" class="headerlink" title="3、每一列数据的格式："></a>3、每一列数据的格式：</h2><p>df.dtypes</p><h2 id="4、某一列格式："><a href="#4、某一列格式：" class="headerlink" title="4、某一列格式："></a>4、某一列格式：</h2><p>df[‘B’].dtype</p><h2 id="5、空值："><a href="#5、空值：" class="headerlink" title="5、空值："></a>5、空值：</h2><p>df.isnull()</p><h2 id="6、查看某一列空值："><a href="#6、查看某一列空值：" class="headerlink" title="6、查看某一列空值："></a>6、查看某一列空值：</h2><p>df.isnull()</p><h2 id="7、查看某一列的唯一值："><a href="#7、查看某一列的唯一值：" class="headerlink" title="7、查看某一列的唯一值："></a>7、查看某一列的唯一值：</h2><p>df[‘B’].unique()</p><h2 id="8、查看数据表的值："><a href="#8、查看数据表的值：" class="headerlink" title="8、查看数据表的值："></a>8、查看数据表的值：</h2><p>df.values</p><h2 id="9、查看列名称："><a href="#9、查看列名称：" class="headerlink" title="9、查看列名称："></a>9、查看列名称：</h2><p>df.columns</p><h2 id="10、查看前10行数据、后10行数据："><a href="#10、查看前10行数据、后10行数据：" class="headerlink" title="10、查看前10行数据、后10行数据："></a>10、查看前10行数据、后10行数据：</h2><p>df.head() #默认前10行数据<br>df.tail() #默认后10 行数据</p><h1 id="三、数据表清洗"><a href="#三、数据表清洗" class="headerlink" title="三、数据表清洗"></a>三、数据表清洗</h1><h2 id="1、用数字0填充空值："><a href="#1、用数字0填充空值：" class="headerlink" title="1、用数字0填充空值："></a>1、用数字0填充空值：</h2><p>df.fillna(value=0)</p><h2 id="2、使用列prince的均值对NA进行填充："><a href="#2、使用列prince的均值对NA进行填充：" class="headerlink" title="2、使用列prince的均值对NA进行填充："></a>2、使用列prince的均值对NA进行填充：</h2><p>df[‘prince’].fillna(df[‘prince’].mean())</p><h2 id="3、清楚city字段的字符空格："><a href="#3、清楚city字段的字符空格：" class="headerlink" title="3、清楚city字段的字符空格："></a>3、清楚city字段的字符空格：</h2><p>df[‘city’]=df[‘city’].map(str.strip)</p><h2 id="4、大小写转换："><a href="#4、大小写转换：" class="headerlink" title="4、大小写转换："></a>4、大小写转换：</h2><p>df[‘city’]=df[‘city’].str.lower()</p><h2 id="5、更改数据格式："><a href="#5、更改数据格式：" class="headerlink" title="5、更改数据格式："></a>5、更改数据格式：</h2><p>df[‘price’].astype(‘int’)</p><h2 id="6、更改列名称："><a href="#6、更改列名称：" class="headerlink" title="6、更改列名称："></a>6、更改列名称：</h2><p>df.rename(columns={‘category’: ‘category-size’})</p><h2 id="7、删除后出现的重复值："><a href="#7、删除后出现的重复值：" class="headerlink" title="7、删除后出现的重复值："></a>7、删除后出现的重复值：</h2><p>df[‘city’].drop_duplicates()</p><h2 id="8、删除先出现的重复值："><a href="#8、删除先出现的重复值：" class="headerlink" title="8、删除先出现的重复值："></a>8、删除先出现的重复值：</h2><p>df[‘city’].drop_duplicates(keep=’last’)</p><h2 id="9、数据替换："><a href="#9、数据替换：" class="headerlink" title="9、数据替换："></a>9、数据替换：</h2><p>df[‘city’].replace(‘sh’, ‘shanghai’)</p><h1 id="四、数据预处理"><a href="#四、数据预处理" class="headerlink" title="四、数据预处理"></a>四、数据预处理</h1><pre><code>df1=pd.DataFrame({"id":[1001,1002,1003,1004,1005,1006,1007,1008], "gender":['male','female','male','female','male','female','male','female'],"pay":['Y','N','Y','Y','N','Y','N','Y',],"m-point":[10,12,20,40,40,40,30,20]})</code></pre><h2 id="1、数据表合并"><a href="#1、数据表合并" class="headerlink" title="1、数据表合并"></a>1、数据表合并</h2><h3 id="1-1-merge"><a href="#1-1-merge" class="headerlink" title="1.1 merge"></a>1.1 merge</h3><pre><code>df_inner=pd.merge(df,df1,how='inner')  # 匹配合并，交集df_left=pd.merge(df,df1,how='left')        #df_right=pd.merge(df,df1,how='right')df_outer=pd.merge(df,df1,how='outer')  #并集</code></pre><h3 id="1-2-append"><a href="#1-2-append" class="headerlink" title="1.2 append"></a>1.2 append</h3><pre><code>result = df1.append(df2)</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-1a90a4c989ad7427?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p><h3 id="1-3-join"><a href="#1-3-join" class="headerlink" title="1.3 join"></a>1.3 join</h3><pre><code>result = left.join(right, on='key')</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-e674e35fb121bf4b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p><h3 id="1-4-concat"><a href="#1-4-concat" class="headerlink" title="1.4 concat"></a>1.4 concat</h3><pre><code>pd.concat(objs, axis=0, join='outer', join_axes=None, ignore_index=False,          keys=None, levels=None, names=None, verify_integrity=False,          copy=True)</code></pre><p>objs︰ 一个序列或系列、 综合或面板对象的映射。如果字典中传递，将作为键参数，使用排序的键，除非它传递，在这种情况下的值将会选择 （见下文）。任何没有任何反对将默默地被丢弃，除非他们都没有在这种情况下将引发 ValueError。<br>axis: {0，1，…}，默认值为 0。要连接沿轴。<br>join: {‘内部’、 ‘外’}，默认 ‘外’。如何处理其他 axis(es) 上的索引。联盟内、 外的交叉口。<br>ignore_index︰ 布尔值、 默认 False。如果为 True，则不要串联轴上使用的索引值。由此产生的轴将标记 0，…，n-1。这是有用的如果你串联串联轴没有有意义的索引信息的对象。请注意在联接中仍然受到尊重的其他轴上的索引值。<br>join_axes︰ 索引对象的列表。具体的指标，用于其他 n-1 轴而不是执行内部/外部设置逻辑。<br>keys︰ 序列，默认为无。构建分层索引使用通过的键作为最外面的级别。如果多个级别获得通过，应包含元组。<br>levels︰ 列表的序列，默认为无。具体水平 （唯一值） 用于构建多重。否则，他们将推断钥匙。<br>names︰ 列表中，默认为无。由此产生的分层索引中的级的名称。<br>verify_integrity︰ 布尔值、 默认 False。检查是否新的串联的轴包含重复项。这可以是相对于实际数据串联非常昂贵。<br>副本︰ 布尔值、 默认 True。如果为 False，请不要，不必要地复制数据。</p><p>例子：1.frames = [df1, df2, df3]<br>2.result = pd.concat(frames)<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a9599d77ce922494?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p><h2 id="2、设置索引列"><a href="#2、设置索引列" class="headerlink" title="2、设置索引列"></a>2、设置索引列</h2><p>df_inner.set_index(‘id’)</p><h2 id="3、按照特定列的值排序："><a href="#3、按照特定列的值排序：" class="headerlink" title="3、按照特定列的值排序："></a>3、按照特定列的值排序：</h2><p>df_inner.sort_values(by=[‘age’])</p><h2 id="4、按照索引列排序："><a href="#4、按照索引列排序：" class="headerlink" title="4、按照索引列排序："></a>4、按照索引列排序：</h2><p>df_inner.sort_index()</p><h2 id="5、如果prince列的值-gt-3000，group列显示high，否则显示low："><a href="#5、如果prince列的值-gt-3000，group列显示high，否则显示low：" class="headerlink" title="5、如果prince列的值>3000，group列显示high，否则显示low："></a>5、如果prince列的值&gt;3000，group列显示high，否则显示low：</h2><p>df_inner[‘group’] = np.where(df_inner[‘price’] &gt; 3000,’high’,’low’)</p><h2 id="6、对复合多个条件的数据进行分组标记"><a href="#6、对复合多个条件的数据进行分组标记" class="headerlink" title="6、对复合多个条件的数据进行分组标记"></a>6、对复合多个条件的数据进行分组标记</h2><p>df_inner.loc[(df_inner[‘city’] == ‘beijing’) &amp; (df_inner[‘price’] &gt;= 4000), ‘sign’]=1</p><h2 id="7、对category字段的值依次进行分列，并创建数据表，索引值为df-inner的索引列，列名称为category和size"><a href="#7、对category字段的值依次进行分列，并创建数据表，索引值为df-inner的索引列，列名称为category和size" class="headerlink" title="7、对category字段的值依次进行分列，并创建数据表，索引值为df_inner的索引列，列名称为category和size"></a>7、对category字段的值依次进行分列，并创建数据表，索引值为df_inner的索引列，列名称为category和size</h2><p>pd.DataFrame((x.split(‘-‘) for x in df_inner[‘category’]),index=df_inner.index,columns=[‘category’,’size’]))</p><h2 id="8、将完成分裂后的数据表和原df-inner数据表进行匹配"><a href="#8、将完成分裂后的数据表和原df-inner数据表进行匹配" class="headerlink" title="8、将完成分裂后的数据表和原df_inner数据表进行匹配"></a>8、将完成分裂后的数据表和原df_inner数据表进行匹配</h2><p>df_inner=pd.merge(df_inner,split,right_index=True, left_index=True)</p><h1 id="五、数据提取"><a href="#五、数据提取" class="headerlink" title="五、数据提取"></a>五、数据提取</h1><p>主要用到的三个函数：loc,iloc和ix，loc函数按标签值进行提取，iloc按位置进行提取，ix可以同时按标签和位置进行提取。</p><h2 id="1、按索引提取单行的数值"><a href="#1、按索引提取单行的数值" class="headerlink" title="1、按索引提取单行的数值"></a>1、按索引提取单行的数值</h2><p>df_inner.loc[3]</p><h2 id="2、按索引提取区域行数值"><a href="#2、按索引提取区域行数值" class="headerlink" title="2、按索引提取区域行数值"></a>2、按索引提取区域行数值</h2><p>df_inner.iloc[0:5]</p><h2 id="3、重设索引"><a href="#3、重设索引" class="headerlink" title="3、重设索引"></a>3、重设索引</h2><p>df_inner.reset_index()</p><h2 id="4、设置日期为索引"><a href="#4、设置日期为索引" class="headerlink" title="4、设置日期为索引"></a>4、设置日期为索引</h2><p>df_inner=df_inner.set_index(‘date’)</p><h2 id="5、提取4日之前的所有数据"><a href="#5、提取4日之前的所有数据" class="headerlink" title="5、提取4日之前的所有数据"></a>5、提取4日之前的所有数据</h2><p>df_inner[:’2013-01-04’]</p><h2 id="6、使用iloc按位置区域提取数据"><a href="#6、使用iloc按位置区域提取数据" class="headerlink" title="6、使用iloc按位置区域提取数据"></a>6、使用iloc按位置区域提取数据</h2><p>df_inner.iloc[:3,:2] #冒号前后的数字不再是索引的标签名称，而是数据所在的位置，从0开始，前三行，前两列。</p><h2 id="7、适应iloc按位置单独提起数据"><a href="#7、适应iloc按位置单独提起数据" class="headerlink" title="7、适应iloc按位置单独提起数据"></a>7、适应iloc按位置单独提起数据</h2><p>df_inner.iloc[[0,2,5],[4,5]] #提取第0、2、5行，4、5列</p><h2 id="8、使用ix按索引标签和位置混合提取数据"><a href="#8、使用ix按索引标签和位置混合提取数据" class="headerlink" title="8、使用ix按索引标签和位置混合提取数据"></a>8、使用ix按索引标签和位置混合提取数据</h2><p>df_inner.ix[:’2013-01-03’,:4] #2013-01-03号之前，前四列数据</p><h2 id="9、判断city列的值是否为北京"><a href="#9、判断city列的值是否为北京" class="headerlink" title="9、判断city列的值是否为北京"></a>9、判断city列的值是否为北京</h2><p>df_inner[‘city’].isin([‘beijing’])</p><h2 id="10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来"><a href="#10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来" class="headerlink" title="10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来"></a>10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来</h2><p>df_inner.loc[df_inner[‘city’].isin([‘beijing’,’shanghai’])]</p><h2 id="11、提取前三个字符，并生成数据表"><a href="#11、提取前三个字符，并生成数据表" class="headerlink" title="11、提取前三个字符，并生成数据表"></a>11、提取前三个字符，并生成数据表</h2><p>pd.DataFrame(category.str[:3])</p><h1 id="六、数据筛选"><a href="#六、数据筛选" class="headerlink" title="六、数据筛选"></a>六、数据筛选</h1><p>使用与、或、非三个条件配合大于、小于、等于对数据进行筛选，并进行计数和求和。</p><h2 id="1、使用“与”进行筛选"><a href="#1、使用“与”进行筛选" class="headerlink" title="1、使用“与”进行筛选"></a>1、使用“与”进行筛选</h2><p>df_inner.loc[(df_inner[‘age’] &gt; 25) &amp; (df_inner[‘city’] == ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]]</p><h2 id="2、使用“或”进行筛选"><a href="#2、使用“或”进行筛选" class="headerlink" title="2、使用“或”进行筛选"></a>2、使用“或”进行筛选</h2><p>df_inner.loc[(df_inner[‘age’] &gt; 25) | (df_inner[‘city’] == ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]].sort([‘age’])</p><h2 id="3、使用“非”条件进行筛选"><a href="#3、使用“非”条件进行筛选" class="headerlink" title="3、使用“非”条件进行筛选"></a>3、使用“非”条件进行筛选</h2><p>df_inner.loc[(df_inner[‘city’] != ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]].sort([‘id’])</p><h2 id="4、对筛选后的数据按city列进行计数"><a href="#4、对筛选后的数据按city列进行计数" class="headerlink" title="4、对筛选后的数据按city列进行计数"></a>4、对筛选后的数据按city列进行计数</h2><p>df_inner.loc[(df_inner[‘city’] != ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]].sort([‘id’]).city.count()</p><h2 id="5、使用query函数进行筛选"><a href="#5、使用query函数进行筛选" class="headerlink" title="5、使用query函数进行筛选"></a>5、使用query函数进行筛选</h2><p>df_inner.query(‘city == [“beijing”, “shanghai”]’)</p><h2 id="6、对筛选后的结果按prince进行求和"><a href="#6、对筛选后的结果按prince进行求和" class="headerlink" title="6、对筛选后的结果按prince进行求和"></a>6、对筛选后的结果按prince进行求和</h2><p>df_inner.query(‘city == [“beijing”, “shanghai”]’).price.sum()</p><h1 id="七、数据汇总"><a href="#七、数据汇总" class="headerlink" title="七、数据汇总"></a>七、数据汇总</h1><p>主要函数是groupby和pivote_table</p><h2 id="1、对所有的列进行计数汇总"><a href="#1、对所有的列进行计数汇总" class="headerlink" title="1、对所有的列进行计数汇总"></a>1、对所有的列进行计数汇总</h2><p>df_inner.groupby(‘city’).count()</p><h2 id="2、按城市对id字段进行计数"><a href="#2、按城市对id字段进行计数" class="headerlink" title="2、按城市对id字段进行计数"></a>2、按城市对id字段进行计数</h2><p>df_inner.groupby(‘city’)[‘id’].count()</p><h2 id="3、对两个字段进行汇总计数"><a href="#3、对两个字段进行汇总计数" class="headerlink" title="3、对两个字段进行汇总计数"></a>3、对两个字段进行汇总计数</h2><p>df_inner.groupby([‘city’,’size’])[‘id’].count()</p><h2 id="4、对city字段进行汇总，并分别计算prince的合计和均值"><a href="#4、对city字段进行汇总，并分别计算prince的合计和均值" class="headerlink" title="4、对city字段进行汇总，并分别计算prince的合计和均值"></a>4、对city字段进行汇总，并分别计算prince的合计和均值</h2><p>df_inner.groupby(‘city’)[‘price’].agg([len,np.sum, np.mean])</p><h1 id="八、数据统计"><a href="#八、数据统计" class="headerlink" title="八、数据统计"></a>八、数据统计</h1><p>数据采样，计算标准差，协方差和相关系数</p><h2 id="1、简单的数据采样"><a href="#1、简单的数据采样" class="headerlink" title="1、简单的数据采样"></a>1、简单的数据采样</h2><p>df_inner.sample(n=3)</p><h2 id="2、手动设置采样权重"><a href="#2、手动设置采样权重" class="headerlink" title="2、手动设置采样权重"></a>2、手动设置采样权重</h2><p>weights = [0, 0, 0, 0, 0.5, 0.5]<br>df_inner.sample(n=2, weights=weights)</p><h2 id="3、采样后不放回"><a href="#3、采样后不放回" class="headerlink" title="3、采样后不放回"></a>3、采样后不放回</h2><p>df_inner.sample(n=6, replace=False)</p><h2 id="4、采样后放回"><a href="#4、采样后放回" class="headerlink" title="4、采样后放回"></a>4、采样后放回</h2><p>df_inner.sample(n=6, replace=True)</p><h2 id="5、-数据表描述性统计"><a href="#5、-数据表描述性统计" class="headerlink" title="5、 数据表描述性统计"></a>5、 数据表描述性统计</h2><p>df_inner.describe().round(2).T #round函数设置显示小数位，T表示转置</p><h2 id="6、计算列的标准差"><a href="#6、计算列的标准差" class="headerlink" title="6、计算列的标准差"></a>6、计算列的标准差</h2><p>df_inner[‘price’].std()</p><h2 id="7、计算两个字段间的协方差"><a href="#7、计算两个字段间的协方差" class="headerlink" title="7、计算两个字段间的协方差"></a>7、计算两个字段间的协方差</h2><p>df_inner[‘price’].cov(df_inner[‘m-point’])</p><h2 id="8、数据表中所有字段间的协方差"><a href="#8、数据表中所有字段间的协方差" class="headerlink" title="8、数据表中所有字段间的协方差"></a>8、数据表中所有字段间的协方差</h2><p>df_inner.cov()</p><h2 id="9、两个字段的相关性分析"><a href="#9、两个字段的相关性分析" class="headerlink" title="9、两个字段的相关性分析"></a>9、两个字段的相关性分析</h2><p>df_inner[‘price’].corr(df_inner[‘m-point’]) #相关系数在-1到1之间，接近1为正相关，接近-1为负相关，0为不相关</p><h2 id="10、数据表的相关性分析"><a href="#10、数据表的相关性分析" class="headerlink" title="10、数据表的相关性分析"></a>10、数据表的相关性分析</h2><p>df_inner.corr()</p><h1 id="九、数据输出"><a href="#九、数据输出" class="headerlink" title="九、数据输出"></a>九、数据输出</h1><p>分析后的数据可以输出为xlsx格式和csv格式</p><h2 id="1、写入Excel"><a href="#1、写入Excel" class="headerlink" title="1、写入Excel"></a>1、写入Excel</h2><p>df_inner.to_excel(‘excel_to_python.xlsx’, sheet_name=’bluewhale_cc’)</p><h2 id="2、写入到CSV"><a href="#2、写入到CSV" class="headerlink" title="2、写入到CSV"></a>2、写入到CSV</h2><p>df_inner.to_csv(‘excel_to_python.csv’)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Numpy详解</title>
      <link href="/posts/blog-python04.html"/>
      <url>/posts/blog-python04.html</url>
      
        <content type="html"><![CDATA[<h3 id="NumPy-Ndarray-对象"><a href="#NumPy-Ndarray-对象" class="headerlink" title="NumPy Ndarray 对象"></a>NumPy Ndarray 对象</h3><p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。</p><p>ndarray 对象是用于存放同类型元素的多维数组。</p><p>ndarray 中的每个元素在内存中都有相同存储大小的区域。</p><p>ndarray 内部由以下内容组成：</p><ul><li><p>一个指向数据（内存或内存映射文件中的一块数据）的指针。</p></li><li><p>数据类型或 dtype，描述在数组中的固定大小值的格子。</p></li><li><p>一个表示数组形状（shape）的元组，表示各维度大小的元组。</p></li><li><p>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要”跨过”的字节数。</p></li></ul><p>ndarray 的内部结构:<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-ed8acce11bbcd6bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>跨度可以是负数，这样会使数组在内存中后向移动，切片中 obj[::-1] 或 obj[:,::-1] 就是如此。</p><p>创建一个 ndarray 只需调用 NumPy 的 array 函数即可：</p><pre><code>numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-548ea678b56011aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-数据类型"><a href="#NumPy-数据类型" class="headerlink" title="NumPy 数据类型"></a>NumPy 数据类型</h3><p>numpy 支持的数据类型比 Python 内置的类型要多很多，基本上可以和 C 语言的数据类型对应上，其中部分类型对应为 Python 内置的类型。下表列举了常用 NumPy 基本类型。</p><ul><li>bool_    布尔型数据类型（True 或者 False）</li><li>int_    默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</li><li>intc    与 C 的 int 类型一样，一般是 int32 或 int 64</li><li>intp    用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</li><li>int8    字节（-128 to 127）</li><li>int16    整数（-32768 to 32767）</li><li>int32    整数（-2147483648 to 2147483647）</li><li>int64    整数（-9223372036854775808 to 9223372036854775807）</li><li>uint8    无符号整数（0 to 255）</li><li>uint16    无符号整数（0 to 65535）</li><li>uint32    无符号整数（0 to 4294967295）</li><li>uint64    无符号整数（0 to 18446744073709551615）</li><li>float_    float64 类型的简写</li><li>float16    半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</li><li>float32    单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</li><li>float64    双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</li><li>complex_    complex128 类型的简写，即 128 位复数</li><li>complex64    复数，表示双 32 位浮点数（实数部分和虚数部分）</li><li>complex128    复数，表示双 64 位浮点数（实数部分和虚数部分）</li></ul><p>numpy 的数值类型实际上是 dtype 对象的实例，并对应唯一的字符，包括 np.bool_，np.int32，np.float32，等等。</p><h3 id="数据类型对象-dtype"><a href="#数据类型对象-dtype" class="headerlink" title="数据类型对象 (dtype)"></a>数据类型对象 (dtype)</h3><p>数据类型对象是用来描述与数组对应的内存区域如何使用，这依赖如下几个方面：</p><ul><li>数据的类型（整数，浮点数或者 Python 对象）</li><li>数据的大小（例如， 整数使用多少个字节存储）</li><li>数据的字节顺序（小端法或大端法）</li><li>在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分</li><li>如果数据类型是子数组，它的形状和数据类型<br>字节顺序是通过对数据类型预先设定”&lt;”或”&gt;”来决定的。”&lt;”意味着小端法(最小值存储在最小的地址，即低位组放在最前面)。”&gt;”意味着大端法(最重要的字节存储在最小的地址，即高位组放在最前面)。</li></ul><p>dtype 对象是使用以下语法构造的：</p><pre><code>numpy.dtype(object, align, copy)</code></pre><ul><li>object - 要转换为的数据类型对象</li><li>align - 如果为 true，填充字段使其类似 C 的结构体。</li><li>copy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用</li></ul><p>每个内建类型都有一个唯一定义它的字符代码，如下：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7c1c38e30b7100ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-数组属性"><a href="#NumPy-数组属性" class="headerlink" title="NumPy 数组属性"></a>NumPy 数组属性</h3><p>NumPy 数组的维数称为秩（rank），一维数组的秩为 1，二维数组的秩为 2，以此类推。</p><p>在 NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。</p><p>很多时候可以声明 axis。axis=0，表示沿着第 0 轴进行操作，即对<strong>每一列</strong>进行操作；axis=1，表示沿着第1轴进行操作，即对<strong>每一行</strong>进行操作。</p><p>NumPy 的数组中比较重要 ndarray 对象属性有：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-9c3ef5fd9250e4e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>ndarray.flags 返回 ndarray 对象的内存信息，包含以下属性：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6e4f7c2b8b6bc255.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-创建数组"><a href="#NumPy-创建数组" class="headerlink" title="NumPy 创建数组"></a>NumPy 创建数组</h3><p>ndarray 数组除了可以使用底层 ndarray 构造器来创建外，也可以通过以下几种方式来创建。</p><p><strong>numpy.empty</strong></p><p>numpy.empty 方法用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组：</p><pre><code>numpy.empty(shape, dtype = float, order = 'C')</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-dcada345e558e5a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.zeros</strong><br>创建指定大小的数组，数组元素以 0 来填充：</p><pre><code>numpy.zeros(shape, dtype = float, order = 'C')</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-af5db82b47841510.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.ones</strong><br>创建指定形状的数组，数组元素以 1 来填充：</p><pre><code>numpy.ones(shape, dtype = None, order = 'C')</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-dda70286db2d9ca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-从已有的数组创建数组"><a href="#NumPy-从已有的数组创建数组" class="headerlink" title="NumPy 从已有的数组创建数组"></a>NumPy 从已有的数组创建数组</h3><p><strong>numpy.asarray</strong><br>numpy.asarray 类似 numpy.array，但 numpy.asarray 只有三个，比 numpy.array 少两个。</p><pre><code>numpy.asarray(a, dtype = None, order = None)</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-44811e18ac421b72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.frombuffer</strong><br>numpy.frombuffer 用于实现动态数组。</p><p>numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</p><pre><code>numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)</code></pre><p><em>注意：buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。</em><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-106c550ac6996c34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.fromiter</strong><br>numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。</p><pre><code>numpy.fromiter(iterable, dtype, count=-1)</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-202a56a2011bbe3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-从数值范围创建数组"><a href="#NumPy-从数值范围创建数组" class="headerlink" title="NumPy 从数值范围创建数组"></a>NumPy 从数值范围创建数组</h3><p><strong>numpy.arange</strong><br>numpy 包中的使用 arange 函数创建数值范围并返回 ndarray 对象，函数格式如下：</p><pre><code>numpy.arange(start, stop, step, dtype)</code></pre><p>根据 start 与 stop 指定的范围以及 step 设定的步长，生成一个 ndarray。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-bbd5489c746a4048.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.linspace</strong><br>numpy.linspace 函数用于创建一个一维数组，数组是一个等差数列构成的，格式如下：</p><pre><code>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7313240ab629e03e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.logspace</strong><br>numpy.logspace 函数用于创建一个于等比数列。格式如下：</p><pre><code>np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></pre><p>base 参数意思是取对数的时候 log 的下标。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-1d29c671ae48f329.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-切片和索引"><a href="#NumPy-切片和索引" class="headerlink" title="NumPy 切片和索引"></a>NumPy 切片和索引</h3><p>ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样。</p><p>ndarray 数组可以基于 0 - n 的下标进行索引，切片对象可以通过内置的 slice 函数，并设置 start, stop 及 step 参数进行，从原数组中切割出一个新数组。</p><p>实例</p><pre><code>import numpy as npa = np.arange(10)s = slice(2,7,2)   # 从索引 2 开始到索引 7 停止，间隔为2print (a[s])</code></pre><p>输出结果为：</p><pre><code>[2  4  6]</code></pre><p>以上实例中，我们首先通过 arange() 函数创建 ndarray 对象。 然后，分别设置起始，终止和步长的参数为 2，7 和 2。</p><p>我们也可以通过冒号分隔切片参数 start:stop:step 来进行切片操作：</p><p>实例</p><pre><code>import numpy as npa = np.arange(10)  b = a[2:7:2]   # 从索引 2 开始到索引 7 停止，间隔为 2print(b)</code></pre><p>输出结果为：</p><pre><code>[2  4  6]</code></pre><p>冒号 : 的解释：如果只放置一个参数，如 [2]，将返回与该索引相对应的单个元素。如果为 [2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 [2:7]，那么则提取两个索引(不包括停止索引)之间的项。</p><p>实例</p><pre><code>import numpy as npa = np.arange(10)  # [0 1 2 3 4 5 6 7 8 9]b = a[5] print(b)</code></pre><p>输出结果为：</p><pre><code>5</code></pre><p>实例</p><pre><code>import numpy as npa = np.arange(10)print(a[2:])</code></pre><p>输出结果为：</p><pre><code>[2  3  4  5  6  7  8  9]</code></pre><p>实例</p><pre><code>import numpy as npa = np.arange(10)  # [0 1 2 3 4 5 6 7 8 9]print(a[2:5])</code></pre><p>输出结果为：</p><pre><code>[2  3  4]</code></pre><p>多维数组同样适用上述索引提取方法：</p><p>实例</p><pre><code>import numpy as npa = np.array([[1,2,3],[3,4,5],[4,5,6]])print(a)# 从某个索引处开始切割print('从数组索引 a[1:] 处开始切割')print(a[1:])</code></pre><p>输出结果为：</p><pre><code>[[1 2 3] [3 4 5] [4 5 6]]</code></pre><p>从数组索引 a[1:] 处开始切割</p><pre><code>[[3 4 5] [4 5 6]]</code></pre><p>切片还可以包括省略号 …，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p><p>实例</p><pre><code>import numpy as npa = np.array([[1,2,3],[3,4,5],[4,5,6]])  print (a[...,1])   # 第2列元素print (a[1,...])   # 第2行元素print (a[...,1:])  # 第2列及剩下的所有元素</code></pre><p>输出结果为：</p><pre><code>[2 4 5][3 4 5][[2 3] [4 5] [5 6]]</code></pre><h3 id="NumPy-高级索引"><a href="#NumPy-高级索引" class="headerlink" title="NumPy 高级索引"></a>NumPy 高级索引</h3><ul><li>整数数组索引</li><li>布尔索引</li><li>花式索引</li></ul><h3 id="NumPy-广播-Broadcast"><a href="#NumPy-广播-Broadcast" class="headerlink" title="NumPy 广播(Broadcast)"></a>NumPy 广播(Broadcast)</h3><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p><p>如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p><pre><code>import numpy as np a = np.array([1,2,3,4]) b = np.array([10,20,30,40]) c = a * b print (c)</code></pre><p>输出结果为：</p><pre><code>[ 10  40  90 160]</code></pre><p>当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。如：</p><pre><code>import numpy as np a = np.array([[ 0, 0, 0],           [10,10,10],           [20,20,20],           [30,30,30]])b = np.array([1,2,3])print(a + b)</code></pre><p>输出结果为：</p><pre><code>[[ 1  2  3] [11 12 13] [21 22 23] [31 32 33]]</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-de5bcc31bbecc9fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>广播的规则:</p><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。</li><li>输出数组的形状是输入数组形状的各个维度上的最大值。</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。</li><li>当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。</li></ul><p>简单理解：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：</p><ul><li>数组拥有相同形状。</li><li>当前维度的值相等。</li><li>当前维度的值有一个是 1。</li></ul><p>若条件不满足，抛出 “ValueError: frames are not aligned” 异常。</p><h3 id="NumPy-迭代数组"><a href="#NumPy-迭代数组" class="headerlink" title="NumPy 迭代数组"></a>NumPy 迭代数组</h3><p>NumPy 迭代器对象 numpy.nditer 提供了一种灵活访问一个或者多个数组元素的方式。</p><p>迭代器最基本的任务的可以完成对数组元素的访问。</p><p>接下来我们使用 arange() 函数创建一个 2X3 数组，并使用 nditer 对它进行迭代。</p><pre><code>import numpy as npa = np.arange(6).reshape(2,3)print ('原始数组是：')print (a)print ('\n')print ('迭代输出元素：')for x in np.nditer(a):    print (x, end=", " )print ('\n')</code></pre><p>输出结果为：</p><pre><code>原始数组是：[[0 1 2] [3 4 5]]迭代输出元素：0, 1, 2, 3, 4, 5, </code></pre><p>以上实例不是使用标准 C 或者 Fortran 顺序，选择的顺序是和数组内存布局一致的，这样做是为了提升访问的效率，默认是行序优先（row-major order，或者说是 C-order）。</p><p>这反映了默认情况下只需访问每个元素，而无需考虑其特定顺序。我们可以通过迭代上述数组的转置来看到这一点，并与以 C 顺序访问数组转置的 copy 方式做对比，如下实例：</p><pre><code>import numpy as npa = np.arange(6).reshape(2,3)for x in np.nditer(a.T):    print (x, end=", " )print ('\n')for x in np.nditer(a.T.copy(order='C')):    print (x, end=", " )print ('\n')</code></pre><p>输出结果为：</p><pre><code>0, 1, 2, 3, 4, 5, 0, 3, 1, 4, 2, 5, </code></pre><p>从上述例子可以看出，a 和 a.T 的遍历顺序是一样的，也就是他们在内存中的存储顺序也是一样的，但是 a.T.copy(order = ‘C’) 的遍历结果是不同的，那是因为它和前两种的存储方式是不一样的，默认是按行访问。</p><p><strong>控制遍历顺序</strong><br>for x in np.nditer(a, order=’F’):Fortran order，即是列序优先；<br>for x in np.nditer(a.T, order=’C’):C order，即是行序优先；</p><p><strong>修改数组中元素的值</strong><br>nditer 对象有另一个可选参数 op_flags。 默认情况下，nditer 将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定 read-write 或者 write-only 的模式。</p><p><strong>使用外部循环</strong><br>nditer类的构造器拥有flags参数，它可以接受下列值：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7d2b0669e6bb65de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>广播迭代</strong><br>如果两个数组是可广播的，nditer 组合对象能够同时迭代它们。 假设数组 a 的维度为 3X4，数组 b 的维度为 1X4 ，则使用以下迭代器（数组 b 被广播到 a 的大小）。</p><h3 id="Numpy-数组操作"><a href="#Numpy-数组操作" class="headerlink" title="Numpy 数组操作"></a>Numpy 数组操作</h3><p><strong>修改数组形状</strong><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f2d06e9db8323294.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.reshape</strong><br>numpy.reshape 函数可以在不改变数据的条件下修改形状，格式如下： numpy.reshape(arr, newshape, order=’C’)</p><ul><li>arr：要修改形状的数组</li><li>newshape：整数或者整数数组，新的形状应当兼容原有形状</li><li>order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’k’ – 元素在内存中的出现顺序。</li></ul><p><strong>numpy.ndarray.flat</strong><br>numpy.ndarray.flat 是一个数组元素迭代器</p><p><strong>numpy.ndarray.flatten</strong><br>numpy.ndarray.flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组，格式如下：</p><pre><code>ndarray.flatten(order='C')</code></pre><p>参数说明：</p><ul><li>order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。</li></ul><p><strong>numpy.ravel</strong><br>numpy.ravel() 展平的数组元素，顺序通常是”C风格”，返回的是数组视图（view，有点类似 C/C++引用reference的意味），修改会影响原始数组。</p><p>该函数接收两个参数：</p><pre><code>numpy.ravel(a, order='C')</code></pre><p>参数说明：</p><ul><li>order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。</li></ul><p><strong>翻转数组</strong><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-e7cc83b5e6dee2ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.transpose</strong><br>numpy.transpose 函数用于对换数组的维度，格式如下：</p><pre><code>numpy.transpose(arr, axes)</code></pre><p>参数说明:</p><ul><li>arr：要操作的数组</li><li>axes：整数列表，对应维度，通常所有维度都会对换。</li></ul><p><strong>numpy.rollaxis</strong><br>numpy.rollaxis 函数向后滚动特定的轴到一个特定位置，格式如下：</p><pre><code>numpy.rollaxis(arr, axis, start)</code></pre><p>参数说明：</p><ul><li>arr：数组</li><li>axis：要向后滚动的轴，其它轴的相对位置不会改变</li><li>start：默认为零，表示完整的滚动。会滚动到特定位置。</li></ul><p><strong>numpy.swapaxes</strong><br>numpy.swapaxes 函数用于交换数组的两个轴，格式如下：</p><pre><code>numpy.swapaxes(arr, axis1, axis2)</code></pre><ul><li>arr：输入的数组</li><li>axis1：对应第一个轴的整数</li><li>axis2：对应第二个轴的整数</li></ul><p><strong>修改数组维度</strong><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-932b54f20b2f213b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.broadcast</strong><br>numpy.broadcast 用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。</p><p><strong>numpy.broadcast_to</strong><br>numpy.broadcast_to 函数将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。</p><pre><code>numpy.broadcast_to(array, shape, subok)</code></pre><p><strong>numpy.expand_dims</strong><br>numpy.expand_dims 函数通过在指定位置插入新的轴来扩展数组形状，函数格式如下:</p><pre><code> numpy.expand_dims(arr, axis)</code></pre><p>参数说明：</p><ul><li>arr：输入数组</li><li>axis：新轴插入的位置</li></ul><p><strong>numpy.squeeze</strong><br>numpy.squeeze 函数从给定数组的形状中删除一维的条目，函数格式如下：</p><pre><code>numpy.squeeze(arr, axis)</code></pre><p>参数说明：</p><ul><li>arr：输入数组</li><li>axis：整数或整数元组，用于选择形状中一维条目的子集</li></ul><h3 id="连接数组"><a href="#连接数组" class="headerlink" title="连接数组"></a>连接数组</h3><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-2c328fe33d5e182f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.concatenate</strong><br>numpy.concatenate 函数用于沿指定轴连接相同形状的两个或多个数组，格式如下：</p><pre><code>numpy.concatenate((a1, a2, ...), axis)</code></pre><p>参数说明：</p><ul><li>a1, a2, …：相同类型的数组</li><li>axis：沿着它连接数组的轴，默认为 0</li></ul><p><strong>numpy.stack</strong><br>numpy.stack 函数用于沿新轴连接数组序列，格式如下：</p><pre><code>numpy.stack(arrays, axis)</code></pre><p>参数说明：</p><ul><li>arrays相同形状的数组序列</li><li>axis：返回数组中的轴，输入数组沿着它来堆叠</li></ul><p><strong>numpy.hstack</strong><br>numpy.hstack 是 numpy.stack 函数的变体，它通过水平堆叠来生成数组。</p><p><strong>numpy.vstack</strong><br>numpy.vstack 是 numpy.stack 函数的变体，它通过垂直堆叠来生成数组。</p><p><strong>分割数组</strong><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-b90db31e02fc9ce9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.split</strong><br>numpy.split 函数沿特定的轴将数组分割为子数组，格式如下：</p><pre><code>numpy.split(ary, indices_or_sections, axis)</code></pre><p>参数说明：</p><ul><li>ary：被分割的数组</li><li>indices_or_sections：果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭）</li><li>axis：沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分</li></ul><p><strong>numpy.hsplit</strong><br>numpy.hsplit 函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组。</p><p><strong>numpy.vsplit</strong><br>numpy.vsplit 沿着垂直轴分割，其分割方式与hsplit用法相同。</p><h3 id="数组元素的添加与删除"><a href="#数组元素的添加与删除" class="headerlink" title="数组元素的添加与删除"></a>数组元素的添加与删除</h3><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-8fae55a7e4ce8c85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.resize</strong><br>numpy.resize 函数返回指定大小的新数组。</p><p>如果新数组大小大于原始大小，则包含原始数组中的元素的副本。</p><pre><code>numpy.resize(arr, shape)</code></pre><p>参数说明：</p><ul><li>arr：要修改大小的数组</li><li>shape：返回数组的新形状</li></ul><p><strong>numpy.append</strong><br>numpy.append 函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的维度必须匹配否则将生成ValueError。</p><p>append 函数返回的始终是一个一维数组。</p><pre><code>numpy.append(arr, values, axis=None)</code></pre><p>参数说明：</p><ul><li>arr：输入数组</li><li>values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）</li><li>axis：默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。</li></ul><p><strong>numpy.insert</strong><br>numpy.insert 函数在给定索引之前，沿给定轴在输入数组中插入值。</p><p>如果值的类型转换为要插入，则它与输入数组不同。 插入没有原地的，函数会返回一个新数组。 此外，如果未提供轴，则输入数组会被展开。</p><pre><code>numpy.insert(arr, obj, values, axis)</code></pre><p>参数说明：</p><ul><li>arr：输入数组</li><li>obj：在其之前插入值的索引</li><li>values：要插入的值</li><li>axis：沿着它插入的轴，如果未提供，则输入数组会被展开</li></ul><p><strong>numpy.delete</strong><br>numpy.delete 函数返回从输入数组中删除指定子数组的新数组。 与 insert() 函数的情况一样，如果未提供轴参数，则输入数组将展开。</p><pre><code>Numpy.delete(arr, obj, axis)</code></pre><p>参数说明：</p><ul><li>arr：输入数组</li><li>obj：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</li><li>axis：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</li></ul><p><strong>numpy.unique</strong><br>numpy.unique 函数用于去除数组中的重复元素。</p><pre><code>numpy.unique(arr, return_index, return_inverse, return_counts)</code></pre><ul><li>arr：输入数组，如果不是一维数组则会展开</li><li>return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储</li><li>return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储</li><li>return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数</li></ul><h3 id="NumPy-位运算"><a href="#NumPy-位运算" class="headerlink" title="NumPy 位运算"></a>NumPy 位运算</h3><p>NumPy “bitwise_” 开头的函数是位运算函数。</p><p>NumPy 位运算包括以下几个函数：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-d2002e3200dea632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-字符串函数"><a href="#NumPy-字符串函数" class="headerlink" title="NumPy 字符串函数"></a>NumPy 字符串函数</h3><p>以下函数用于对 dtype 为 numpy.string_ 或 numpy.unicode_ 的数组执行向量化字符串操作。 它们基于 Python 内置库中的标准字符串函数。</p><p>这些函数在字符数组类（numpy.char）中定义。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7b14ae371864668b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-数学函数"><a href="#NumPy-数学函数" class="headerlink" title="NumPy 数学函数"></a>NumPy 数学函数</h3><p><strong>三角函数</strong><br>NumPy 提供了标准的三角函数：sin()、cos()、tan()。</p><p><strong>舍入函数</strong><br>numpy.around() 函数返回指定数字的四舍五入值。</p><pre><code>numpy.around(a,decimals)</code></pre><p>参数说明：</p><ul><li>a: 数组</li><li>decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置</li></ul><p><strong>numpy.floor()</strong><br>numpy.floor() 返回数字的下舍整数。</p><p><strong>numpy.ceil()</strong><br>numpy.ceil() 返回数字的上入整数。</p><h3 id="NumPy-算术函数"><a href="#NumPy-算术函数" class="headerlink" title="NumPy 算术函数"></a>NumPy 算术函数</h3><p>NumPy 算术函数包含简单的加减乘除: add()，subtract()，multiply() 和 divide()。</p><p>需要注意的是数组必须具有相同的形状或符合数组广播规则。</p><p>此外 Numpy 也包含了其他重要的算术函数。</p><p><strong>numpy.reciprocal()</strong><br>numpy.reciprocal() 函数返回参数逐元素的倒数。如 1/4 倒数为 4/1。</p><p><strong>numpy.power()</strong><br>numpy.power() 函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。</p><p><strong>numpy.mod()</strong><br>numpy.mod() 计算输入数组中相应元素的相除后的余数。 函数 numpy.remainder() 也产生相同的结果。</p><h3 id="NumPy-统计函数"><a href="#NumPy-统计函数" class="headerlink" title="NumPy 统计函数"></a>NumPy 统计函数</h3><p><strong>numpy.amin() 和 numpy.amax()</strong><br>numpy.amin() 用于计算数组中的元素沿指定轴的最小值。</p><p>numpy.amax() 用于计算数组中的元素沿指定轴的最大值。</p><p><strong>numpy.ptp()</strong><br>numpy.ptp()函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p><p><strong>numpy.percentile()</strong><br>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 函数numpy.percentile()接受以下参数。</p><pre><code>numpy.percentile(a, q, axis)</code></pre><p>参数说明：</p><ul><li>a: 输入数组</li><li>q: 要计算的百分位数，在 0 ~ 100 之间</li><li>axis: 沿着它计算百分位数的轴<br>首先明确百分位数：</li></ul><p>第 p 个百分位数是这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有 (100-p)% 的数据项大于或等于这个值。</p><p>举个例子：高等院校的入学考试成绩经常以百分位数的形式报告。比如，假设某个考生在入学考试中的语文部分的原始分数为 54 分。相对于参加同一考试的其他学生来说，他的成绩如何并不容易知道。但是如果原始分数54分恰好对应的是第70百分位数，我们就能知道大约70%的学生的考分比他低，而约30%的学生考分比他高。</p><p>这里的 p = 70。</p><p><strong>numpy.median()</strong><br>numpy.median() 函数用于计算数组 a 中元素的中位数（中值）</p><p><strong>numpy.mean()</strong><br>numpy.mean() 函数返回数组中元素的算术平均值。 如果提供了轴，则沿其计算。</p><p>算术平均值是沿轴的元素的总和除以元素的数量。</p><p><strong>numpy.average()</strong><br>numpy.average() 函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。</p><p>该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。</p><p>加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。</p><p>考虑数组[1,2,3,4]和相应的权重[4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。</p><p><strong>标准差</strong><br>标准差是一组数据平均值分散程度的一种度量。</p><p>标准差是方差的算术平方根。</p><p>标准差公式如下：</p><pre><code>std = sqrt(mean((x - x.mean())**2))</code></pre><p>如果数组是 [1，2，3，4]，则其平均值为 2.5。 因此，差的平方是 [2.25,0.25,0.25,2.25]，并且其平均值的平方根除以 4，即 sqrt(5/4) ，结果为 1.1180339887498949。</p><p><strong>方差</strong><br>统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即 mean((x - x.mean())** 2)。</p><p>换句话说，标准差是方差的平方根。</p><h3 id="NumPy-排序、条件刷选函数"><a href="#NumPy-排序、条件刷选函数" class="headerlink" title="NumPy 排序、条件刷选函数"></a>NumPy 排序、条件刷选函数</h3><p>NumPy 提供了多种排序的方法。 这些排序函数实现不同的排序算法，每个排序算法的特征在于执行速度，最坏情况性能，所需的工作空间和算法的稳定性。 下表显示了三种排序算法的比较。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-253e8d77eb1b7539.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.sort()</strong><br>numpy.sort() 函数返回输入数组的排序副本。函数格式如下：</p><pre><code>numpy.sort(a, axis, kind, order)</code></pre><p><strong>numpy.argsort()</strong><br>numpy.argsort() 函数返回的是数组值从小到大的索引值。</p><p><strong>numpy.lexsort()</strong><br>numpy.lexsort() 用于对多个序列进行排序。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p><p>这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。</p><p><strong>msort、sort_complex、partition、argpartition</strong></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7b94c231e2b3a965.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.argmax() 和 numpy.argmin()</strong><br>numpy.argmax() 和 numpy.argmin()函数分别沿给定轴返回最大和最小元素的索引。</p><p><strong>numpy.nonzero()</strong><br>numpy.nonzero() 函数返回输入数组中非零元素的索引。</p><p><strong>numpy.where()</strong><br>numpy.where() 函数返回输入数组中满足给定条件的元素的索引。</p><p><strong>numpy.extract()</strong><br>numpy.extract() 函数根据某个条件从数组中抽取元素，返回满条件的元素。</p><h3 id="NumPy-字节交换"><a href="#NumPy-字节交换" class="headerlink" title="NumPy 字节交换"></a>NumPy 字节交换</h3><p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。字节顺序，是跨越多字节的程序对象的存储规则。</p><ul><li><p>大端模式：指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</p></li><li><p>小端模式：指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</p></li></ul><p>例如在 C 语言中，一个类型为 int 的变量 x 地址为 0x100，那么其对应地址表达式&amp;x的值为 0x100。且x的四个字节将被存储在存储器的 0x100, 0x101, 0x102, 0x103位置。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cfb1dc912601047a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.ndarray.byteswap()</strong><br>numpy.ndarray.byteswap() 函数将 ndarray 中每个元素中的字节进行大小端转换。</p><h3 id="NumPy-矩阵库-Matrix"><a href="#NumPy-矩阵库-Matrix" class="headerlink" title="NumPy 矩阵库(Matrix)"></a>NumPy 矩阵库(Matrix)</h3><p>NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。</p><p><strong>matlib.empty()</strong><br>matlib.empty() 函数返回一个新的矩阵，语法格式为：</p><pre><code>numpy.matlib.empty(shape, dtype, order)</code></pre><p>参数说明：</p><pre><code>shape: 定义新矩阵形状的整数或整数元组Dtype: 可选，数据类型order: C（行序优先） 或者 F（列序优先）</code></pre><p><strong>numpy.matlib.zeros()</strong><br>numpy.matlib.zeros() 函数创建一个以 0 填充的矩阵。</p><p><strong>numpy.matlib.ones()</strong><br>numpy.matlib.ones()函数创建一个以 1 填充的矩阵。</p><p><strong>numpy.matlib.eye()</strong><br>numpy.matlib.eye() 函数返回一个矩阵，对角线元素为 1，其他位置为零。</p><pre><code>numpy.matlib.eye(n, M,k, dtype)</code></pre><p>参数说明：</p><pre><code>n: 返回矩阵的行数M: 返回矩阵的列数，默认为 nk: 对角线的索引dtype: 数据类型</code></pre><p><strong>numpy.matlib.identity()</strong><br>numpy.matlib.identity() 函数返回给定大小的单位矩阵。</p><p>单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-270c1beafc8a5565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.matlib.rand()</strong><br>numpy.matlib.rand() 函数创建一个给定大小的矩阵，数据是随机填充的。</p><h3 id="NumPy-线性代数"><a href="#NumPy-线性代数" class="headerlink" title="NumPy 线性代数"></a>NumPy 线性代数</h3><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-3d0280b2e9ab232a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.dot()</strong><br>numpy.dot() 对于两个一维的数组，计算的是这两个数组对应下标元素的乘积和(数学上称之为内积)；对于二维数组，计算的是两个数组的矩阵乘积；对于多维数组，它的通用计算公式如下，即结果数组中的每个元素都是：数组a的最后一维上的所有元素与数组b的倒数第二位上的所有元素的乘积和： dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])。</p><pre><code>numpy.dot(a, b, out=None) </code></pre><p>参数说明：</p><pre><code>a : ndarray 数组b : ndarray 数组out : ndarray, 可选，用来保存dot()的计算结果</code></pre><p><strong>numpy.vdot()</strong><br>numpy.vdot() 函数是两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数是多维数组，它会被展开。</p><p><strong>numpy.inner()</strong><br>numpy.inner() 函数返回一维数组的向量内积。对于更高的维度，它返回最后一个轴上的和的乘积。</p><p><strong>numpy.matmul</strong><br>numpy.matmul 函数返回两个数组的矩阵乘积。 虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。</p><p>另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。</p><p><strong>numpy.linalg.det()</strong><br>numpy.linalg.det() 函数计算输入矩阵的行列式。</p><p>行列式在线性代数中是非常有用的值。 它从方阵的对角元素计算。 对于 2×2 矩阵，它是左上和右下元素的乘积与其他两个的乘积的差。</p><p>换句话说，对于矩阵[[a，b]，[c，d]]，行列式计算为 ad-bc。 较大的方阵被认为是 2×2 矩阵的组合。</p><p><strong>numpy.linalg.solve()</strong><br>numpy.linalg.solve() 函数给出了矩阵形式的线性方程的解。</p><p>考虑以下线性方程：</p><p>x + y + z = 6</p><p>2y + 5z = -4</p><p>2x + 5y - z = 27<br>可以使用矩阵表示为：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6a10ed854cec035f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>如果矩阵成为A、X和B，方程变为：</p><p>AX = B</p><p>或</p><p>X = A^(-1)B</p><p><strong>numpy.linalg.inv()</strong><br>numpy.linalg.inv() 函数计算矩阵的乘法逆矩阵。</p><p>逆矩阵（inverse matrix）：设A是数域上的一个n阶矩阵，若在相同数域上存在另一个n阶矩阵B，使得： AB=BA=E ，则我们称B是A的逆矩阵，而A则被称为可逆矩阵。注：E为单位矩阵。</p><h3 id="NumPy-IO"><a href="#NumPy-IO" class="headerlink" title="NumPy IO"></a>NumPy IO</h3><p>Numpy 可以读写磁盘上的文本数据或二进制数据。</p><p>NumPy 为 ndarray 对象引入了一个简单的文件格式：npy。</p><p>npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。</p><p>常用的 IO 函数有：</p><ul><li>load() 和 save() 函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npy 的文件中。</li><li>savze() 函数用于将多个数组写入文件，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npz 的文件中。</li><li>loadtxt() 和 savetxt() 函数处理正常的文本文件(.txt 等)</li></ul><p><strong>numpy.save()</strong><br>numpy.save() 函数将数组保存到以 .npy 为扩展名的文件中。</p><pre><code>numpy.save(file, arr, allow_pickle=True, fix_imports=True)</code></pre><p>参数说明：</p><pre><code>file：要保存的文件，扩展名为 .npy，如果文件路径末尾没有扩展名 .npy，该扩展名会被自动加上。arr: 要保存的数组allow_pickle: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python 中的 pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。fix_imports: 可选，为了方便 Pyhton2 中读取 Python3 保存的数据。</code></pre><p><strong>np.savez</strong><br>numpy.savez() 函数将多个数组保存到以 npz 为扩展名的文件中。</p><pre><code>numpy.savez(file, *args, **kwds)</code></pre><p>参数说明：</p><pre><code>file：要保存的文件，扩展名为 .npz，如果文件路径末尾没有扩展名 .npz，该扩展名会被自动加上。args: 要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为 arr_0, arr_1, …　。kwds: 要保存的数组使用关键字名称。</code></pre><p><strong>savetxt()</strong><br>savetxt() 函数是以简单的文本文件格式存储数据，对应的使用 loadtxt() 函数来获取数据。</p><pre><code>np.loadtxt(FILENAME, dtype=int, delimiter=' ')np.savetxt(FILENAME, a, fmt="%d", delimiter=",")</code></pre><p>参数 delimiter 可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python画一只会眨眼睛的皮卡丘</title>
      <link href="/posts/blog-python03.html"/>
      <url>/posts/blog-python03.html</url>
      
        <content type="html"><![CDATA[<h1 id="Pikaqiu-用turtle绘画的皮卡丘"><a href="#Pikaqiu-用turtle绘画的皮卡丘" class="headerlink" title="Pikaqiu 用turtle绘画的皮卡丘"></a>Pikaqiu 用turtle绘画的皮卡丘</h1><ol><li>首先我们导入turtle库和time库（用来做动画使用）:<pre><code>import turtle as timport time</code></pre></li><li>由于turtle没有画曲线的函数，因此我们自定义画曲线函数,函数有4个参数，ang偏转角度，dis移动步长，step步长增幅，n遍历次数，说白了就是将曲线转化为很多条短长的直线：<pre><code>#画左偏曲线函数def radian_left(ang,dis,step,n): for i in range(n):     dis+=step #dis增大step     t.lt(ang) #向左转ang度     t.fd(dis) #向前走dis的步长    def radian_right(ang,dis,step,n): for i in range(n):     dis+=step     t.rt(ang) #向左转ang度     t.fd(dis) #向前走dis的步长</code></pre></li><li>定义画耳朵，眼睛，嘴，轮廓，脚画尾巴的函数，具体见python文件</li><li>初始化皮卡丘：<pre><code>#初始化def Init(): InitEars() InitTail() InitFoots() InitBody() InitFace() InitHands() InitEyes()</code></pre></li><li>定义Upgrade函数和Upgarde_init函数制作眨眼动画：<pre><code>#眨眼睛def Upgarde(): InitEars() InitTail() InitFoots() InitBody() InitFace() InitHands() CloseEyes()def Upgarde_Init(): InitEars() InitTail() InitFoots() InitBody() InitFace() InitHands() InitEyes()</code></pre><ol start="6"><li>Main函数定义：<pre><code>def main():Init()  t.tracer(False)   #眨眼睛动画for i in range(30):  if i%2==0:      t.reset()      t.hideturtle()      Upgarde()      t.update()      time.sleep(0.3)  else:      t.reset()      t.hideturtle()      Upgarde_Init()      t.update()      time.sleep(1)        </code></pre><h1 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h1><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-b70381c6d5e08b89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pikaqiu.png"></li></ol></li></ol><p>视频动画可以打包下载该文件，点击pikaqiu.mp4观看<br><a href="https://github.com/JackHCC/Pikaqiu" target="_blank" rel="noopener">Github源码下载地址</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | Turtle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Turtle详解</title>
      <link href="/posts/blog-python02.html"/>
      <url>/posts/blog-python02.html</url>
      
        <content type="html"><![CDATA[<p>#turtle绘图的基础知识：<br>####1.画布</p><pre><code>turtle.screensize(canvwidth=None, canvheight=None, bg=None)</code></pre><p>参数分别为画布的宽(单位像素), 高, 背景颜色。如：turtle.screensize(800,600, “green”)</p><pre><code>turtle.screensize() #返回默认大小(400, 300)turtle.setup(width=0.5, height=0.75, startx=None, starty=None)</code></pre><p>参数：width, height: 输入宽和高为整数时, 表示像素; 为小数时, 表示占据电脑屏幕的比例，(startx, starty): 这一坐标表示矩形窗口左上角顶点的位置, 如果为空,则窗口位于屏幕中心。</p><p>####2.画笔<br>####2.1 画笔的状态<br>在画布上，默认有一个坐标原点为画布中心的坐标轴，坐标原点上有一只面朝x轴正方向小乌龟。这里我们描述小乌龟时使用了两个词语：坐标原点(位置)，面朝x轴正方向(方向)， turtle绘图中，就是使用位置方向描述小乌龟(画笔)的状态。</p><p>####2.2 画笔的属性<br>画笔(画笔的属性，颜色、画线的宽度等)</p><pre><code>    1) turtle.pensize()：设置画笔的宽度；    2) turtle.pencolor()：没有参数传入，返回当前画笔颜色，传入参数设置画笔颜色，可以是字符串如"green", "red",也可以是RGB 3元组。    3) turtle.speed(speed)：设置画笔移动速度，画笔绘制的速度范围[0,10]整数，数字越大越快。</code></pre><p>####2.3 绘图命令</p><p>操纵海龟绘图有着许多的命令，这些命令可以划分为3种：一种为运动命令，一种为画笔控制命令，还有一种是全局控制命令。<br>######(1)    画笔运动命令</p><ul><li>turtle.forward(distance)</li></ul><p>向当前画笔方向移动distance像素长度</p><ul><li>turtle.backward(distance)</li></ul><p>向当前画笔相反方向移动distance像素长度</p><ul><li>turtle.right(degree)</li></ul><p>顺时针移动degree°</p><ul><li>turtle.left(degree)</li></ul><p>逆时针移动degree°</p><ul><li>turtle.pendown()</li></ul><p>移动时绘制图形，缺省时也为绘制</p><ul><li>turtle.goto(x,y)</li></ul><p>将画笔移动到坐标为x,y的位置</p><ul><li>turtle.penup()</li></ul><p>提起笔移动，不绘制图形，用于另起一个地方绘制</p><ul><li>turtle.circle()</li></ul><p>画圆，半径为正(负)，表示圆心在画笔的左边(右边)画圆</p><ul><li>setx( )</li></ul><p>将当前x轴移动到指定位置</p><ul><li>sety( )</li></ul><p>将当前y轴移动到指定位置</p><ul><li>setheading(angle)</li></ul><p>设置当前朝向为angle角度</p><ul><li>home()</li></ul><p>设置当前画笔位置为原点，朝向东。</p><ul><li><p>dot(r)<br>######(2)     画笔控制命令</p></li><li><p>turtle.fillcolor(colorstring)</p></li></ul><p>绘制图形的填充颜色</p><ul><li>turtle.color(color1, color2)</li></ul><p>同时设置pencolor=color1, fillcolor=color2</p><ul><li>turtle.filling()</li></ul><p>返回当前是否在填充状态</p><ul><li>turtle.begin_fill()</li></ul><p>准备开始填充图形</p><ul><li>turtle.end_fill()</li></ul><p>填充完成</p><ul><li>turtle.hideturtle()</li></ul><p>隐藏画笔的turtle形状</p><ul><li>turtle.showturtle()</li></ul><p>显示画笔的turtle形状<br>######(3)    全局控制命令</p><ul><li>turtle.clear()</li></ul><p>清空turtle窗口，但是turtle的位置和状态不会改变</p><ul><li>turtle.reset()</li></ul><p>清空窗口，重置turtle状态为起始状态</p><ul><li>turtle.undo()</li></ul><p>撤销上一个turtle动作</p><ul><li>turtle.isvisible()</li></ul><p>返回当前turtle是否可见</p><ul><li>stamp()</li></ul><p>复制当前图形</p><ul><li>turtle.write(s [,font=(“font-name”,font_size,”font_type”)])</li></ul><p>写文本，s为文本内容，font是字体的参数，分别为字体名称，大小和类型；font为可选项，font参数也是可选项<br>######(4)    其他命令</p><ul><li>turtle.mainloop()或turtle.done()</li></ul><p>启动事件循环 -调用Tkinter的mainloop函数。</p><p>必须是乌龟图形程序中的最后一个语句。</p><ul><li>turtle.mode(mode=None)</li></ul><p>设置乌龟模式（“standard”，“logo”或“world”）并执行重置。如果没有给出模式，则返回当前模式。</p><ul><li>turtle.delay(delay=None)</li></ul><p>设置或返回以毫秒为单位的绘图延迟。</p><ul><li>turtle.begin_poly()</li></ul><p>开始记录多边形的顶点。当前的乌龟位置是多边形的第一个顶点。</p><ul><li>turtle.end_poly()</li></ul><p>停止记录多边形的顶点。当前的乌龟位置是多边形的最后一个顶点。将与第一个顶点相连。</p><ul><li>turtle.get_poly()</li></ul><p>返回最后记录的多边形。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | Turtle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识</title>
      <link href="/posts/blog-python01.html"/>
      <url>/posts/blog-python01.html</url>
      
        <content type="html"><![CDATA[<h1 id="课程笔记"><a href="#课程笔记" class="headerlink" title="$课程笔记"></a>$课程笔记</h1><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-c7908d67f53948e5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><a href="https://www.w3cschool.cn/python/dict" target="_blank" rel="noopener">python相关函数查询</a></p><p><a href="https://docs.python.org/zh-cn/3/tutorial/index.html" target="_blank" rel="noopener">官方API文档</a></p><p><a href="https://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">菜鸟教程python</a></p><p><a href="https://www.w3cschool.cn/python/" target="_blank" rel="noopener">w3school教程python</a></p><h3 id="一-基本元素"><a href="#一-基本元素" class="headerlink" title="一.基本元素"></a>一.基本元素</h3><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul><li>变量赋值：<pre><code>a="hello world"</code></pre></li><li>变量命名：<br>• 字母：a-z, A-Z, 其他语言的字母符号<br>• 数字：0-9 (不可以出现在首字符)<br>• 下划线：_ （可以单用）</li><li>注意事项<br>• 在赋值时，变量即被创建，变量的值和类<br>型在赋值的时候被确定。<br>• 不需要声明（declaration）<br>• 变量名大小写敏感：A, a是不同的变量<br>• 变量可以被重新赋值<h5 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h5></li><li>数值类型<br>• 整数 Integers: 12 0 -12987 0123 0X1A2 10294L<br>   大致相当于C语言的 ‘int’ 或 ‘long’<br>   范围可以非常大（大致无限）<br>   八进制数以“0” 开始 (0981 是非法的!)<br>   十六进制以0X开始<br>• 浮点数Floating point: 12.03 1E1 -1.54E-21<br>   相当于C语言的double<br>• 复数Complex numbers: 1+3J<pre><code>语言原生支持</code></pre></li></ul><p><strong>运算注意事项：</strong><br>• 操作符和C语言类似，例如 +, -, /, <em>, %<br>• 幂操作：**</em><br>• 优先级和括号的作用相似</p><ul><li>逻辑类型<br>• 预定义值：True False<br>• 数值 0 认为是假，其他值认为是真<br>• 操作符：not, and, or</li></ul><p><strong>运算注意事项：</strong><br>• 比较运算获得逻辑值，运算符: &lt;, &lt;=, &gt;, &gt;=,<br>==, !=</p><ul><li><p>字符串类型<br>• 使用函数str, int, float等类型名进行转换</p><pre><code>b=int(a)c=flaot(a)d=str(a)</code></pre><p>• 字符串的拼接和整数乘法</p><pre><code>a="hello"+"world"b="hello"*2</code></pre><h5 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h5></li><li><p>代码缩进<br>• Python语 语 言 的 行 前 空 白 是 有 语 法 意 义 的<br>• 在源文件中，应该统一采取一种缩进格式<br>缩进进4个空格 （ 推 荐 标 准 ）<br>缩进2个空格<br>缩进1制表符（tab）<br>上述缩进不可以混用<br>• 连续处于相同缩进层次的语句构成一个语句块（Block）</p></li><li><p>条件语句</p><pre><code>if 条件：elif 条件：else:</code></pre></li><li><p>循环语句(for)<br>• 循环语句for<br>• range(n)表明从0开始，到n-1（含）。</p><pre><code>s = 0for i in range(10): # 0,1,...9  s += iprint(s)</code></pre></li><li><p>循环语句(while)</p><pre><code>s = 0i = 0while s&lt;10:  s += i  i += 1print(s)</code></pre></li><li><p>导入语句<br>三种写法：</p><pre><code>from math import *# use pi, cos, sin, ...from math import cos, sin# only use cos, sinimport math# use math.cos, math.sin, ...</code></pre></li><li><p>定义函数<br>• 用def定义函数，可以有参数和返回值</p><pre><code>def double(x):  return x * 2</code></pre><h5 id="turtle库详解"><a href="#turtle库详解" class="headerlink" title="turtle库详解"></a>turtle库详解</h5><p><a href="https://www.jianshu.com/p/29f5c970fa80" target="_blank" rel="noopener">python：turtle库详解</a></p><h3 id="python类型"><a href="#python类型" class="headerlink" title="python类型"></a>python类型</h3><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>• 标量类型<br>—— 逻辑类型(bool)<br>—— 整数(int)、浮点数(float)、复数(complex)<br>—— 空 类型 型(None)<br>• 集合类型<br>—— 字符串(str)<br>—— 列表(list)<br>—— 字典(dict)<br>—— 元组(tuple)<br>—— 集合(set)<br>• 自定义类型<br>—— 类 class</p><h5 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h5><p>• 除法有两种：/, // 后者是整除<br>—— 7/3 = 2.3333333333333335<br>—— 7//3 = 2<br>—— 7.0 // 3.0 = 2.0<br>• 幂运算允许实数<br>—— 7 ** 2 = 49<br>—— 7 ** 0.5 = 2.6457513110645907<br>• 不同类型的数值运算就高不就低<br>—— int —— float —— complex</p><h5 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h5><p>• 表达式</p><pre><code>x if c else y </code></pre><p>相当于</p><pre><code>c? x : y</code></pre><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>• 字符串的进阶操作</p><pre><code>'p' in s </code></pre><p>• 下标以0为开始</p><pre><code>s[0] # index: offset 0s[2:6] # slice: part of strings[:6] s[6:]</code></pre><p>• 逆序的下标</p><pre><code>s[-1]s[-3:-1]s[1:-1]s[-3:]</code></pre><p>• 步长：begin:end:step</p><pre><code>s[::2]s[1::3]s[5:1::-1]"live"[::-1]</code></pre><h5 id="不可修改类型-Immutable"><a href="#不可修改类型-Immutable" class="headerlink" title="不可修改类型 Immutable"></a>不可修改类型 Immutable</h5><p>• 数值类型、字符串类型是不可修改类型<br>—— 后续讲解的元组（tuple）类型也是不可修改类型<br>• 它们的值是常数，不可以修改<br>—— 我们并不能把“1”修改为“2”，把“abc”改为“def”；<br>—— 作为值，它的含义是确定的、不变的。<br>• 赋值语句（Assignment）是给这些常数的值赋予不同的名称</p><h5 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h5><pre><code>s = 'I love Python's.count('on') # 查找子串出现次数s.find('ove') # 查找子串首见位置s.replace('Python', 'C++') # 替换three = '3'three.isdigit() # 是否为数字字符?</code></pre><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5></li><li><p>相关事项<br>• 表（或称为列表，广义表）是python最重要<br>和常用的容器类<br>• 由一系列有序排列的对象构成（Ordered<br>collection of objects）~ C语言的数组<br>• 异构（Heterogenous），一个列表可以包含<br>多种类型的对象。</p><pre><code>r = [1, 2.0, 3, 5] # list的字面构造r[1] # 正数下标自首部计数，首部为0r[-1] # 负数下标自尾部计数，尾部为-1r[1:3] # 前闭后开区间w = r + [10, 19] # 连接t = [0.0] * 10 # 重复len(r)</code></pre></li><li><p>列表操作</p><pre><code>r = [[9, 8], 2.0, 3, 'word']r[0:3] = [1, 2, 5, 6] # 修改片段r[1:3] = [] # 删除元素r[1:1] = [ 'new' ] # 赋值语句左右侧都是片段；等价于插入[1, 'new', 6, 'word']r[len(r):] = [ 'last' ] # 在尾部插入[1, 'new', 6, 'word', 'last']</code></pre></li><li><p>列表的方法</p><pre><code>r.insert(0, 'f') # 在0位置增加新元素'f'del r[0]r.append(9) # 尾部增加元素r.sort() # in-place 排序r.reverse() # 逆序</code></pre></li><li><p>判断两个变量是否指向同一对象<br>• 利用id函数，返回对象的唯一标志<br>• id(x) == id(y) 表明x和y实际上是同一对象<br>• x is y</p></li><li><p>列表推导</p><pre><code>[i for i in range(9)][i*2 for i in range(9)][i for i in range(100) if '4' not in str(i)]</code></pre><p>• 补充<br>—— Python 一行语句过长，可以用 \ 续行<br>—— 若在括号（花方圆均可）内可以自由换行</p><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5></li><li><p>基本事项<br>• 字典是一种数据组织方式，它根据 key获得对应的value<br>• key称为键，key是无序的，或者说不关注其顺序。<br>• value称为值，可以是任意的对象。<br>• 字典也称为映射(mapping)、哈希(hash)表、查找表(lookup table)等。</p></li><li><p>字典操作</p><pre><code>g = {'Tom': 'boy', 'Mary': 'girl'}g['Tom'] # 以key为索引g.has_key('Mary')g['Jack'] = 'boy' # 增加键值对del g['Tom'] # 删除键，删除键到值的绑定h = {'Tom': 12, 'Mary': 'good'}'Per' in h # 在键的集合中检测h.get('Per', 'unknown') # 如果查找失败则返回缺省值h.keys() # 由键组成的列表，顺序不确定h.values() # 由值组成的列表，顺序不确定h.items() # 顺序同上len(h) # 键的数量</code></pre><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5></li><li><p>注意事项<br>• 与list相同，但不可改变（immutable）<br>• 一旦创建，不可修改。（Once created, can’t be changed.）</p><pre><code>t = (1, 3, 2)t[1] # 3(a, b, c) = t # 元组赋值a, b, c # (1, 3, 2)</code></pre><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5></li><li><p>注意事项<br>• 数学中的集合，无序，不重复（set）<br>• 去重的时候很有用</p><pre><code>s = set()s = {1, 2, 3}s.add(4) # {1,2,3,4}s.add(1) # {1,2,3,4}t = {1,2}# &amp;交集，|并集 - 差集s - t # {3,4}</code></pre><h5 id="容器间转换"><a href="#容器间转换" class="headerlink" title="容器间转换"></a>容器间转换</h5><p>• list, set, dict 作为类型名可以实现转换<br>—— list(“abc”)    = [“a”, “b”, “c”]<br>—— set([1,2,2])     = {1,2}</p><h3 id="Python语句"><a href="#Python语句" class="headerlink" title="Python语句"></a>Python语句</h3><h5 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h5><p>• pass是一个（占位）空语句，不做任何事情<br>• 动因<br>—— python利用缩进表达语句块，如果语句块是空的，不写会有错；<br>—— 这种情况下，可以写上pass</p><h5 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h5><p>• for可以遍历任意的容器<br>—— 对词典遍历的是keys()<br>• range(n)是一个内置函数，返回0~n-1的列表<br>• range(start, stop, step)</p><h5 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h5><p>• 跳出最内层的循环<br>• python没有直接跳出外层循环的语法手段<br>—— 通常会借助额外的flag变量<br>—— 异常处理</p><h5 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h5><p>• 它结束当前迭代，并跳到下一次迭代开头。即跳过循环体中余下的语句，但不结束循环。<br>• 可以用等价的if语句描述</p><h5 id="for-while-else语句"><a href="#for-while-else语句" class="headerlink" title="for/while-else语句"></a>for/while-else语句</h5><p>• 只要不是break跳出循环，就执行else语句<br>• 相比C语言减少一个flag变量</p><pre><code>r = [1, 3, 10, 98, -2, 48]for i in r:  if i &lt; 0:      print('input contains negative value!')      breakelse:  print('input is OK')</code></pre><h5 id="exec和eval"><a href="#exec和eval" class="headerlink" title="exec和eval"></a>exec和eval</h5><p>• 动态地编写Python代码，并将其作为语句进<br>行执行或作为表达式进行计算<br>• 函数exec将字符串作为代码执行<br>• eval计算用字符串表示的Python表达式的值，<br>并返回结果。<br>• 如下代码来创建一个Python计算器</p><h5 id="assert断言语句"><a href="#assert断言语句" class="headerlink" title="assert断言语句"></a>assert断言语句</h5><p>• 要求某些条件得到满足，否则将引发异常<br>• 确保程序的参数合理<br>• 对于不合理的情况，明确引发异常</p><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5></li><li><p>完整的异常处理</p><pre><code>try:  1 / 0except NameError:  print("Unknown variable")         出现异常时执行。。。else:  print("That went well!")             没有出现异常时执行finally:  print("Cleaning up.")             任何情况下都会执行</code></pre><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>• 函数名：规则与变量名相同<br>• 参数列表：调用函数时传递给它的值<br>—— 可以由零个，一个或者多个参数组成<br>—— 当有多个参数时，各个参数用逗号分隔<br>• 函数体：函数被调用时执行的代码<br>—— 由一个或多个语句组成<br>—— 在执行到末尾或return语句时退出函数<br>—— 返回结果<br>• 函数调用的形式<br>—— 函数名( 参数列表 )<br>• 形式参数（名）：定义函数时，函数名后面圆括号中的变量。形参只在函数内部有效。<br>• 实际参数（值）：调用函数时，函数名后面圆括号中的变量。</p><h5 id="参数能否修改：总结"><a href="#参数能否修改：总结" class="headerlink" title="参数能否修改：总结"></a>参数能否修改：总结</h5><p>• 凡是Immutable类型的参数，传入的对象值不可能修改<br>• 对于Mutable类型的参数：<br>—— 若对形参进行赋值，并不能改变传入对象的值<br>—— 若对形参进行in-place的修改，则该修改也反应在传入的对象上</p><h5 id="关键字参数的缺省值"><a href="#关键字参数的缺省值" class="headerlink" title="关键字参数的缺省值"></a>关键字参数的缺省值</h5><p>• 可以设定一些参数的缺省值（默认值）<br>• 如果调用者没有提供，则使用缺失值</p><pre><code>def hello(name, greeting="Hello"):</code></pre><p>• 允许用户提供任意数量的参数</p><pre><code>def sum_of_all(*values):</code></pre><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5></li><li><p>注意事项<br>• 如果没有局部变量和全局变量同名，可以直接读取全局变量。<br>• 如果有一个局部变量与待访问的全局变量同名，则无法直接访问全局变量，因为它被局部变量遮住了。<br>• 可以使用关键字 global（nonlocal）修饰变量名，表明和全局（外层）变量关联。<br>• Python的函数可以作为返回值</p><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>• lambda可以用来定义函数</p><pre><code>pow2_a = lambda x: x*xdef pow2_b(x):    return x*x</code></pre><p>两者功能相同</p><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>• 对于稍微大型的程序，代码量较大，不宜<br>放在一个文件中<br>• 模块可以将代码分散在不同的文件</p><h5 id="主模块"><a href="#主模块" class="headerlink" title="主模块"></a>主模块</h5><pre><code>if __name__ == "__main__":    do_something()</code></pre><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><h5 id="字符的分类"><a href="#字符的分类" class="headerlink" title="字符的分类"></a>字符的分类</h5><p>• 数字 digits 01234567890<br>• 字母 letter<br>大写ABCDEFGHIJKLMNOPQRSTUVWXYZ<br>小写 abcdefghijklmnopqrstuvwxyz<br>• 空白字符：空格，\t\n\r\v<br>• 对应Unicode，上述概念有一定拓展。</p><h5 id="字符串对象方法"><a href="#字符串对象方法" class="headerlink" title="字符串对象方法"></a>字符串对象方法</h5></li><li><p><strong>capitalize()</strong> 字符串首字母大写</p></li><li><p><strong>lower()</strong> 转为小写</p></li><li><p><strong>upper()</strong> 转为大写</p></li><li><p><strong>find(s)/rfind(s)</strong>  正向/逆向查找子串s的出现位置</p></li><li><p><strong>count(s)</strong>  查找s出现的次数</p></li><li><p><strong>strip()</strong>  移除开始和结束的空白</p></li><li><p><strong>lstrip()/rstrip()</strong>移除开始/结束的空白</p></li><li><p><strong>replace(s, r)</strong> 将子串s替换为r（缺省为全替换，可以仅替换指定次数）</p></li><li><p><strong>isalpha()/isdigit()</strong> 是否是字母、数字等……</p></li><li><p><strong>isupper()/Islower()</strong> 是否大写小写等….</p></li><li><p><strong>startswith(s)/endswith(s)</strong> 是否以s作为字符串的开始或结尾</p></li><li><p><strong>s.split(sep)</strong> 将字符串sep作为分隔符，对字符串s进行分解，返回列表</p></li><li><p><strong>sep.join(parts)</strong>  将各部分用分隔符sep连接在一起</p></li></ul><h5 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h5><p>• 字符串的格式化有三种方法<br>• %, format, f-string</p><ul><li>% 操作符</li></ul><p><strong>用法:</strong> str % parameter_tuple</p><pre><code>"the number is %d" % 30</code></pre><ul><li>%-format</li></ul><p><strong>%c</strong> character<br><strong>%s</strong> string conversion via str() prior to formatting<br><strong>%i</strong>  signed decimal integer<br><strong>%d</strong> signed decimal integer<br><strong>%u</strong> unsigned decimal integer<br><strong>%o</strong> octal integer<br><strong>%x</strong> hexadecimal integer (lowercase letters)<br><strong>%X</strong> hexadecimal integer (UPPERcase letters)<br><strong>%e</strong> exponential notation (with lowercase ‘e’)<br><strong>%E</strong> exponential notation (with UPPERcase ‘E’)<br><strong>%f</strong> floating point real number<br><strong>%g</strong> the shorter of %f and %e<br><strong>%G</strong> the shorter of %f and %E<br><strong>*</strong> argument specifies width or precision<br><strong>-</strong>  left justification<br><strong>+</strong> display the sign<br><strong><sp></sp></strong> leave a blank space before a positive number<br><strong>#</strong> add the octal leading zero ( ‘0’ ) or hexadecimal leading ‘0x’or ‘0X’, depending on whether ‘x’ or ‘X’ were used.<br><strong>0</strong> pad from left with zeros (instead of spaces)<br><strong>%</strong> ‘%%’ leaves you with a single literal ‘%’<br><strong>(var)</strong> mapping variable (dictionary arguments)<br><strong>m.n.</strong> m is the minimum total width and n is the number of digitsto display after the decimal point (if appl.)</p><pre><code>name = "John"age = 23print("%s is %d years old." % (name, age))</code></pre><ul><li>str.format方法<br>• 原先的用法：’%s %s’ % (‘one’, ‘two’)<br>• 目前的用法：’{} {}’.format(‘one’, ‘two’)<pre><code>"{0} {1}, you may have won ${2}" .format("Mr.", "Smith",10000)'int, {0:5}, in a field of width 5'.format(7)' {0:10.5f}, fixed at 5 decimal places.'.format(3.1415926)</code></pre></li><li>f-string<pre><code>name = "Eric"age = 24f"Hello, {name}. You are {age}."</code></pre>f-string是python3版本的新语法，是一种表达式。</li><li>split-join<br>• split用于将长字符串进行分解<br>• join用于合并短字符串<br>• 常见的分隔符号有：\t , ; . - /<pre><code>"www.ustb.edu.cn".split(".")[ int(i) for i in "166.111.4.80".split(".") ]".".join([ f"{i}" for i in [166, 111, 4, 80] ])</code></pre><h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5></li><li>通配符：匹配任意字符</li><li>字符组（类）<br>• 字符类 [] 用于匹配一组字符<br>• 可以用 [^] 表达不匹配组里面的任意字符<br>• Ranges 可以表示一个范围的字符<br>—— [1-9] 即 [123456789]<br>—— [abcde] 即 [a-e]<br>—— [abcde123456789] 即 [a-e1-9]</li><li>预定义的字符组</li></ul><p><strong>\d</strong>  数字 [0-9]<br><strong>\D</strong> 非数字 [^0-9]<br><strong>\s</strong> 空白字符 [ \f\n\r\t\v]<br><strong>\S</strong> 非空白字符 [^ \f\n\r\t\v]<br><strong>\w</strong> 字母数字下划线 [A-Za-z0-9_]<br><strong>\W</strong> 非字母数字下划线 [^A-Za-z0-9_]</p><ul><li>锚 Anchors<br>• ^ 即行首 beginning of the line，在多行模式下匹配每行的开始位置<br>• $ 即行尾 means end of the line，在多行模式下匹配每行的结束位置<br>• \A 仅行首<br>• \Z 仅行尾<br>• \b 匹配单词的边界<br>—— 从字母数字到非字母数字的过渡边界，\w\W 或 \W\w</li><li>重复指示Repetions<br>• 三种 * + ?<br>• * 指示其前置内容0<del>+inf次出现，也就是<br>任意多次<br>• + 1</del>+inf<br>• ? 0~1</li><li>重复数量的范围指示<br>• 可以用 {n,m} 指示范围<br>—— {n,m} 表示n~m次<br>—— {n} 表示恰好n次 exactly n occurrences<br>—— {n,} 表示至少n次 at least n occurrences<br>• 示例:<br>—— .{0,} 等价于 .*<br>—— a{2,} 等价于 aaa*</li><li>子表达式<br>• 重复指示仅修饰其前面的一个符号，如果<br>想表示多个符号，需要对正则表达式进行<br>分组，用 （）进行划分，称为子表达式<br>• 子表达式作为一个整体被修饰<br>—— a* 匹配a的0次货多次出现<br>—— abc* 匹配 ab, abc, abcc, abccc, …<br>—— (abc)* 匹配 abc, abcabc, abcabcabc, …<br>—— (abc){2,3} 匹配 abcabc or abcabcabc</li><li>或<br>• 符号 | 表示匹配该符号前面的或后面的子表达式<br>—— (T|Fl)an 匹配 Tan or Flan<br>—— ^(From|Subject): 匹配邮件头部<br>• 优先级最低，可以用 （） 改变<br>•  示例：<br>—— At(ten|nine)tion 匹配Attention or Atninetion<br>—— 不能匹配Atten or ninetion 除非未加括号即Atten|ninetion</li><li>转义<br>• 很多字符（如“.”）在正则表达式中有特殊含义，如果只代表它原本的字面意义就需要转义，例如“.”仅匹配句点本身。<br>—— 目标仅匹配单个句点： .<br>—— 在正则表达式层面需要看到： .<br>—— 在字符串书写时需要写： “\.”<br>• 匹配反斜线<br>—— 目标仅匹配单个反斜线： <br>—— 在正则表达式层面需要看到： \<br>—— 在字符串书写时需要写： “\\“<br>• 匹配数字\d<br>—— 在正则表达式层面需要看到： \d<br>—— 在字符串书写时需要写： “\d”</li></ul><p>• 匹配国内电话号码：\d{3}‐\d{8}|\d{4}‐\d{7}<br>—— 如 0511-4405222 或 021-87888822<br>• 腾讯QQ号：[1‐9][0‐9]{4,}<br>—— 腾讯QQ号从10000开始<br>• 中国邮政编码：[1‐9]\d{5}(?!\d)<br>—— 中国邮政编码为6位数字<br>• 匹配身份证：\d{15}|\d{18}<br>—— 中国的身份证为15位或18位<br>• 匹配ip地址：\d+.\d+.\d+.\d+<br>—— 提取ip地址时有用</p><ul><li><p>子表达式的引用<br>• \n  此处n是一个数字，表示第n个子表达式的值。子表达式的序号按左括号计数。<br>• 例如：<br>—— (.+) \1 匹配 55 55，或者the the<br>• 可以给子表达式予以命名<br>• (?P<name>…)<br>• (?P=name)</name></p><h5 id="Python的正则表达式模块"><a href="#Python的正则表达式模块" class="headerlink" title="Python的正则表达式模块"></a>Python的正则表达式模块</h5><p>• 模块导入 <strong>import re</strong><br>• 匹配：re.match() 查找字符串的开始部分是否匹配，不向后查找（类似字符串startswith）<br>• 查找：re.search() 查找是否存在匹配（类似字符串find）<br>• 替换：re.sub() 替换正则表达式（类似字符串replace）</p></li><li><p>match的用例</p><pre><code>s = "2019‐03‐20 is a rainy day"pat = "\\d‐\\d‐\\d"m = re.match(pat, s)m.start()m.end()m.group()  #返回匹配对象(Match)，有start, end, group方法</code></pre></li><li><p>search的用例</p><pre><code>s = "It is reported that 2019‐03‐20 is a rainyday."pat = "\\d‐\\d‐\\d"m = re.search(pat, s)m.start()m.end()m.group() </code></pre></li><li><p>多次查找findall/finditer</p><pre><code>s = """You smiled and talked to me of nothing and I felt that for this I had been waiting long."re.findall("\\b(\\w+ed)\\b", s)re.finditer(...) # 类似，但返回一个个Match对象</code></pre></li><li><p>替换sub<br>• 04/30/2018 转换为 2018-04-30<br>• 利用re.sub</p><pre><code>import reprint re.sub("([0‐9]{2})/([0‐9]{2})/([0‐9]{4})","\\3‐\\1‐\\2","This is a test 01/30/2019.")</code></pre><h5 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h5></li><li><p>基础概念<br>• 文件包括两种类型：文本文件和二进制文件<br>• 二进制文件：直接由比特0和比特1组成，没有统一字符编码，文件内部数据的组织格式与文件用途有关。<br>• 文本文件：以ASCII码方式存储的文件。<br>• 二进制文件和文本文件区别：仅编码（人为的理解）存在差异。<br>• 文件包括两种类型：文本文件和二进制文件<br>• 二进制文件：直接由比特0和比特1组成，没有统一字符编码，文件内部数据的组织格式与文件用途有关。<br>• 文本文件：以ASCII码方式存储的文件。<br>• 二进制文件和文本文件区别：仅编码（人为的理解）存在差异。</p></li><li><p>文件操作<br>• 打开文件 open<br>—— 建立磁盘上的文件与程序中的对象相关联<br>—— 通过相关的文件对象获得<br>• 文件操作<br>—— 读取<br>—— 写入<br>—— 定位<br>—— 其它：追加、计算等<br>• 关闭文件 close<br>—— 切断文件与程序的联系<br>—— 写入磁盘，并释放文件缓冲区</p></li><li><p>文件打开操作<br>• 打开文件<br>—— Python使用open()函数打开文件并返回文件对象：</p><pre><code>&lt;变量名&gt;=open(file, mode = 'r')</code></pre><p>—— open函数有两个参数：文件名和打开模式。文件名可以是包含完整路径的名字，或当前路径下的文件名。<br>—— 第二个参数制定文件打开模式。<br>• open()函数提供7种基本的打开模式</p></li></ul><p><strong>‘r’</strong>  以只读方式打开文件（默认）如果文件不存在，返回异常FileNotFoundError。<br><strong>‘w’</strong> 以写入的方式打开文件，文件不存在则创建，会覆盖已<br>存在的文件。<br><strong>‘x’</strong> 打开一个新文件来写数据。文件不存在则创建，如果数<br>据已经存在则返回异常FileExistsError。<br><strong>‘a’</strong> 以写入模式打开，文件不存在则创建，如果文件存在，<br>则在末尾追加写入。<br><strong>‘b’</strong> 以 二进制模式打开文件。<br><strong>‘t’</strong> 以 文本模式打开 （默认）。<br><strong>‘+’</strong> 可读写模式（可添加到其它模式中使用）。<br>• 模式的组合使用<br>—— ‘r’,’w’,’x’,’a’可以和’b’,’t’,’+’组合使用，形成既表达读写又表达文件模式的方式。<br><strong>例如：</strong><br>——‘wb’表示“写二进制数据”<br>——‘x+b’表示读写一个新的二进制文件</p><ul><li>文件的读写操作<br>• 文件的读写：根据打开方式不同可以对文件进行相应的读写操作，Python提供4个常用的文件内容读取方法。</li></ul><p><strong><file>.readall()</file></strong> 读入整个文件内容，返回一个字符串或字节流。<br><strong><file>.read(size=‐1)</file></strong> 从文件读取size个字符，当未给定size或给定负值的时候，读取剩余的所有字符，文件指针指向文件末尾。<br><strong><file>.readline(size=‐1)</file></strong> 从文件中读入一行内容，如果给出参数，读入该行前size长度的字符串或字节流。<br><strong><file>.readline(hint=‐1)</file></strong>从文件中读入所有行，以每行为元素形成一个列表，如果给出参数，读入hint行。<br>• Python提供3个与文件内容写入有关的方法。<br><strong><file>.write(str)</file></strong> 将字符串str写入文件。<br><strong><file>.writelines(lines)</file></strong>将一个元素为字符串的列表写入文件。<br><strong><file>.seek(offset,from)</file></strong>改变当前文件操作指针的位置，从from(0代表文件起始位置，1代表当前位置，2代表文件末尾）偏移offset个字节。</p><ul><li>文件操作示例<br>• 文本文件逐行打印输出<pre><code>fo = open(fname ,"rt")for line in fo.readlines():  print(line)fo.close()</code></pre></li><li>文件操作示例<pre><code>f1 = open(f1name, "rt")f2 = open(f1name, "wt")f2.write(f1.read().upper())f1.close()f2.close()</code></pre></li><li>with语句<br>• 容易忘记关闭(close)文件<pre><code>f = open('todos.txt')for chore in f  print(chore, end='')tasks.close()#使用with语句重写这个代码with open('todos.txt') as f:for chore in f:  print(chore, end='')</code></pre>• with确保即使发生异常，也可以正确的关闭文件</li><li>编码的文件<br>• 若打开有编码的文件，需要用codecs模块<br>• import codecs<pre><code>f1 = codecs.open(fname, "r", "utf‐8")f2 = codecs.open(fname, "w", "gb2312")</code></pre></li><li>词频统计<pre><code>f = open("alice.txt", "rt")all = f.read()f.close()count_word = {}for w in all.split():  w_lowercase = w.lower()  count_word[w_lowercase] = \                                      count_word.get(w_lowercase, 0) + 1result = [(v, k) for k, v in count_word.items()]result.sort()top10 = result[‐10:]for v,k in top10[::‐1]:  print(f"Word {k}, occurs {v} times")</code></pre><h5 id="汉字的处理"><a href="#汉字的处理" class="headerlink" title="汉字的处理"></a>汉字的处理</h5></li><li>导入库<br>• pip install regex<br>• import regex as re<br>• \p{han} 匹配汉字</li><li>汉字分词<br>• jieba是Python中一个重要的第三方中文分词函数库。<br>• 第三方库，需要安装</li></ul><p><strong>jieba.cut(s)</strong> 精确模式，返回一个可迭代的数据类型<br><strong>jieba.cut(s,cut all=True)</strong> 全模式，输出文本s中所有可能单词<br><strong>jieba.cut_for_search(s)</strong> 搜索引擎模式，适合搜索引擎建立索引的分词结果<br><strong>jieba.lcut(s)</strong> 精确模式，返回一个列表类型，建议使用<br><strong>jieba.lcut(s,cut all=True)</strong> 全模式，返回一个列表类型，建议使用<br><strong>jieba.lcut_for_search(s)</strong> 搜索引擎模式，返回一个列表类型，建议使用<br><strong>jieba.add_word(w)</strong> 向分词词典中增加新词w</p><h3 id="OOP编程"><a href="#OOP编程" class="headerlink" title="OOP编程"></a>OOP编程</h3><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>• 类是类型概念的发展。<br>—— 对象是广义的“数据值”。<br>—— 对象所属的数据类型就是“类”。<br>—— 用于描述复杂数据的静态和动态行为。<br>• 类（class）：描述相似对象的共性。包括<br>—— 数据<br>—— 操作：方法（method）<br>• 对象是类的实例（instance）<br>—— 创建对象<br>• 类的封装:数据和操作结合成一个程序单元,对外部隐藏内部实现细节。<br>—— 不允许用户直接操作类中被隐藏的信息。<br>—— 用户也无需了解隐藏的信息就能使用该类。<br>• 类对外公开方法名称和调用格式,即界面。<br>—— 外界向对象发消息。(方法名及参数)<br>—— 对象响应消息,执行相应方法。<br>—— 外界只能按对象允许的方式来处理对象数据。<br>• 封装的好处<br>—— 安全:对象自己的方法处理自己的数据<br>—— 易用:使用者无需了解内部实现细节<br>—— 易维护:实现者修改内部实现不会影响使用者<br>—— 标准化:同类甚至不同类的对象对使用者都呈现同样的操作界面<br>• 方法定义同函数定义</p><pre><code>def &lt;methodname&gt;(self, other params):</code></pre><p>—— 方法是依附于类的函数,普通函数则是独立的。<br>—— 方法的第一个参数是专用的，习惯用名字self。<br>—— 大体上等价于C++的this<br>—— 只能通过向对象发消息来调用方法。<br>• 对象是数据和操作的结合。<br>—— 方法对应于操作<br>—— 对象的数据以实例变量形式定义。<br>—— 实例变量：self.varname<br>—— 对象变量和所指向的数据本质上是一个词典<br>—— self.varname  即 self[“varname”]<br>—— 实例变量的赋值主要出现在<strong>init</strong>()方法中。</p><ul><li>类的定义实例<pre><code>class Circle:""" Class definition for a circle """def __init__(self, radius):  self.radius = radiusdef getRadius(self):  return self.radiusdef getArea(self):" Obtain the area of a circle"  return math.pi*self.radius**2</code></pre></li><li>创建实例<br>• 实例创建<br>&lt; 变量&gt; = &lt; 类名&gt; （&lt; 实参&gt; ）<br>这里&lt;类名&gt;相当于一个函数，称为构造器，用来构造实例。<br>• 成员访问<br>• 方法调用<br>—— 类似函数调用,但需指明实例(对象)<br>—— &lt; 实例&gt;.&lt; 方法名&gt;(&lt; 实参&gt;)<br>—— &lt;实例&gt;就是与形参self对应的实参<br>• 数据成员访问<br>—— &lt; 实例&gt;.&lt; 数据成员名&gt;<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5>• 在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class） 。<br>• 继承是面向对象的重要特征之一，继承是两个类或者多个类之间的父子关系，子类继承了父类的所有实例变量和方法。<br>• 继承实现了代码的重用。重用已经存在的数据和行为，减少代码的重新编写。<br>• Python在类名后用一对圆括号表示继承关系，括号中的类表示父类。<pre><code>class 类名（被继承的类）：</code></pre></li><li>实例和类的关系判定<br>• isinstance(s, t)函数判定s是否t类型（及其子类型）<br>—— isinstance(c, Circle)<br>—— isinstance(c, DrawableCircle)<br>• 继承关系：is-a  （注：相当于c++的公有继承）<br>• DrawableCircle is a Circle<br>• 一个实例属于某个子类，则也属于父类，反之则不行。<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5>• 当对一个对象调用draw()函数时，它会根据自己的对象类型执行不同的draw方法<br>—— FilledDrawableCircle.draw()<br>—— DrawableCircle.draw()<br>• 对于相同的方法，会有不同的实现版本，这就是多态（Polymorphism）<h3 id="科学计算与可视化"><a href="#科学计算与可视化" class="headerlink" title="科学计算与可视化"></a>科学计算与可视化</h3><h5 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h5>• NumPy（Numeric Python）是Python语言的一个扩展包。<br>• 由多维数组对象和数组计算函数共同组成的库，支持多维数组、矩阵运算以及大量数值计算功能。</li><li>Numpy产生动机<br>• 标准的Python中用列表(list)保存一组值，可以作为数组使用。<br>• Python列表的元素可以是任何对象，因此对象需要额外的信息保存其类型等信息，Python本身是解释型语言。因此，对数值运算来说，效率较低。<br>—— 1000*1000的矩阵乘法，基于python实现三层循环超过10分钟。<br>—— Numpy 大约0.03秒。<br>• 计算效率直接影响了科学计算、机器学习的可用性。<br>• Python的列表不支持数值计算语义<br>• 能否实现矢量、矩阵的加法？乘法？逆？<br>• 因此，需要原生支持数值计算语义的，高效率的Python库<br>• NumPy的诞生弥补了这些不足<br>• NumPy提供了两种基本的对象<br>—— ndarray（ndimensional array object ）<br>—— ufunc（ universal function object）<br>• ndarray(数组)是存储单一数据类型的多维数组。<br>• ufunc 是对数组进行处理的函数。<pre><code>• 安装：pip install numpy• 导入：import numpy as np</code></pre></li><li>Numpy的优势<br>• NumPy 通 常 与 SciPy(Scientific Python)和Matplotlib(绘图库)一起使用，这种组合广泛用于替代Matlab，已成为流行的技术方案。<br>• Python：通用语言<br>• Matlab：专用语言<br>• NumPy是开源的（Open-Source）</li><li>Numpy做什么<br>• 矢量、矩阵和高维数组（张量）的数值运<br>算和逻辑运算<br>• 线性代数相关的操作<br>• 随机数生成<br>• 傅立叶变换<br>• 图形操作<br>• 其他功能</li><li>量<br>• 矢量 Vectors<br>• 矩阵 Matrices<br>• 图像 Images<br>• 张量 Tensors</li><li>Ndarray<br>• ndarray：N维数组类型<br>• 描述相同类型的元素集合<br>• 使用基于零的索引访集合中的项目<br>• ndarray中的每个元素类型（dtype）相同，占用的内存大小也相同。</li><li>Ndarray的创建<br>• numpy.array(object, dtype = None, order =None)<br>• object通常是一个容器或迭代器，根据其内容生成一个ndarray对象实例<br>• dtype如果不指定，自动从实际数据中推断<br>• order和内存中数据排列有关</li><li>dtype<br>• int8, int16, int32, int64<br>• uint8, uint16, uint32, uint64<br>• float16, float32, float64<br>• complex64, complex128</li><li>数组属性<br>• 数组的维度：ndim<br>• 数组的形状：shape<pre><code>import numpy as npx = np.array([1, 2, 3])y = np.array([4.0, 5, 6])print(x.dtype, x.shape, x.ndim)print(y.dtype, y.shape, y.ndim)z = x + yprint(z)</code></pre></li><li>数组创建<br>• 数组创建的其他方法<br>—— numpy.empty：空，不初始化值，值可能任意<br>—— numpy.zeros：0<br>—— numpy.ones：1<br>—— numpy.arange：start, stop, step 可以为浮点数，但是不推荐用在浮点数场合。<br>—— numpy.linspace：start, stop, number 实现均匀划分（默认含右侧端点），推荐在浮点数场合使用。<pre><code>array = np.array([[0,1,2],[2,3,4]])# [[0 1 2]#  [2 3 4]]array = np.zeros((2,3))# [[0. 0. 0.]# [0. 0. 0.]]array = np.ones((2,3))# [[1. 1. 1.]# [1. 1. 1.]]</code></pre>• eye 单位矩阵<br>• 浮点数优先用linspace，避免累计误差<br>• np.random 类似于random<pre><code>array = np.eye(3)# [[1. 0. 0.]# [0. 1. 0.]# [0. 0. 1.]]array = np.arange(0, 10, 2)# [0, 2, 4, 6, 8]array = np.linspace(0, 1, 11)# [0. , 0.1, 0.2, 0.3,…, 0.7, 0.8, 0.9, 1. ]array = np.random.randint(0, 10, (3,3))# [[6 4 3]# [1 5 6]# [9 8 5]])</code></pre></li><li>索引和切片(slice)<br>• 一维数组的索引和切片大体与list相同<pre><code>a = np.arange(9)a[0]# 0a[3:7]# array([3, 4, 5, 6])a[:7:2]# array([0, 2, 4, 6])a[::‐1]#array([8, 7, 6, 5, 4, 3, 2, 1, 0])</code></pre>• 多维数组：每一个维度都可以进行索引或切片，<br>返回一个标量或多维的子数组（view）。<br>• 对此子数组的修改可能会反应在原数据上！<pre><code>b = np.array([[0,1,2],[3,4,5]])#[[0 1 2]#  [2 3 4]]b[0,1]# 1b[1,:]#[3,4,5]b[:,2]#[2,5]</code></pre></li><li>数组的运算<br>• shape相同的多维数组，支持+ ‐ * / % &lt; &gt; == &gt;= &lt;= 等运算，对应的元素逐个进行运算，返回具有相同shape的多维数组<br>• 单目运算作用在数组上，对每个元素逐个实施，包括负号 ‐ 以及单自变量函数 sin,cos 等<br>• 上述运算是element-wise意义上的<pre><code>arr = np.array([[1., 2., 3.], [4., 5., 6.]])print(arr)[[1. 2. 3.][4. 5. 6.]]print(arr * arr)[[ 1. 4. 9.][16. 25. 36.]]print(arr ‐ arr)[[0. 0. 0.][0. 0. 0.]]</code></pre></li><li>数组的运算：广播<br>• shape不相同的数组如何运算？<br>• 一般意义的逐元素的运算不可实现。<br>• 但可以通过广播实现，小的数组被广播为大的数组，从而使得两个数组兼容。<br>• 在下列规则满足时可以广播：<br>—— 维数小的数组，在它的shape前面补“1”<br>—— 在某个维度两个数组大小或者相同或者有一个是“1”<br>—— 如果在某个维度是“1”，则需要任何下标[*]时，用[0]元素代替（相当于复制为很多份）<br>• 等价地说，广播运算在下列情况之一成立时可以执行<br>—— 具有相同的shape<br>—— 具有相同的维度，shape每一维的值或者相同或者有一方为1<br>—— 具有不同的维度，但是维数少的在前面补齐“1”后符合上述条件</li><li>逻辑型数组索引<br>• 逻辑型数组可以作为索引<br>—— 如比较运算的结果为一个逻辑型数组<br>• 掩码（Mask），表示仅取索引True的元素，构成一个子数组。<pre><code>x = np.arange(10)mod5 = x % 1 == 1x [ mod5 ] # [1, 6]x [ x &gt; 5 ] ?</code></pre>• 整数型数组（或list）可以作为索引<br>• 逐个取出每个整数对应下标的元素，得到ndarray数组的子集<pre><code>x = np.arange(10)*10# array([ 0, 10, 20, 30, 40,50, 60, 70, 80, 90])x[[1,3]]# array([ 10, 30])x[[5,3,7]]# array([ 50, 30, 70])</code></pre></li><li>view和copy<br>• 为了提高效率、节约空间，有些numpy操作返回的是view，对view的修改可以改动原始数组中的数据改动原始数组中的数据。<br>• 具体返回view或copy需要查看函数说明。<br>• 显式的复制可以用copy函数。<br>—— a.copy()<br>—— np.copy(a)</li><li>数组的拼接<br>• np.concatenate([a1, a2, …],axis=0, out=None)<br>• 参数说明：<br>—— a1, a2, … : 一系列的ndarray，必需是相同的shape，除非在第axis维可以存在差异。<br>—— axis : int, 缺省为0<br>• 按照第axis维把上述数组拼接在一起<pre><code>A = np.ones((4,1))array([[1.],[1.],[1.],[1.]]B = np.zeros((4,2))array([[0., 0.],[0., 0.],[0., 0.],[0., 0.]])C = np.concatenate([A, B], axis=1)array([[1., 0., 0.],[1., 0., 0.],[1., 0., 0.],[1., 0., 0.]])</code></pre></li><li>数组的创建<br>• np.zeros_like<br>• np.ones_like<br>• np.empty_like<br>• 参数是另一个数组，按照其形状创建一个0/1/空的数组</li><li>reshape<br>• 在保持总元素的数目不变的条件下，数组的形状可以更改<br>• 默认的order是row-major<pre><code>a = np.array([1,2,3,4,5,6])a = a.reshape(3,2)"""array([[1, 2],[3, 4],[5, 6]])"""a = a.reshape(2,‐1)</code></pre></li><li>平坦化<br>• .ravel()<br>• .flat<pre><code>x = np.array([[1, 2, 3], [4, 5, 6]])print(np.ravel(x))[1 2 3 4 5 6]for i in x.flat: #属性，不需要加()，返回iterator  print(i)</code></pre></li><li>转置<br>• .transpose 交换两个轴 axes<br>• .T 相当于transposes前两个轴<pre><code>x = np.arange(4).reshape((2,2))"""array([[0, 1],[2, 3]])"""np.transpose(x) # x.transpose((1,0)), or x.T"""array([[0, 2],[1, 3]])"""</code></pre></li><li>数组的IO<br>• 可以存储为NPY/NPZ文件<br>• 可以同时存储多个数组<br>• save存储为非压缩格式<br>• savez存储压缩格式<pre><code>np.savez('data.npz', a=a)data = np.load('data.npz')a = data['a'] # data是一个词典</code></pre>• 读入文本文件<br>• 可以指定注释、分隔符、编码等<pre><code>from io import StringIO# 用字符串模拟一个file对象c = StringIO("0 1\n2 3")np.loadtxt(c)array([[ 0., 1.],[ 2., 3.]])</code></pre>• 读入图像文件<pre><code>from scipy.misc import imreadim = imread("lenna.png")print(im.shape, im.dtype)# (330, 330, 3) uint8im_grey = im[:,:,0]*0.299 + im[:,:,1]*0.587 + im[:,:,2]*0.114import matplotlib.pyplot as pltplt.imshow(im_grey, cmap='gray')plt.show()</code></pre></li><li>ufunc<br>• 除了四则运算，常见的数学函数也作为ufunc提供，可以在数组上操作.<br>• 单次numpy.sin的速度只有math.sin的1/4，但大数组的numpy.sin比math.sin快20多倍。这是因为numpy.sin在C语言级别进行循环计算。</li><li>聚集运算<br>• np.sum(a) 对数组a求和<br>• 其他参数：<br>—— axis=None 在特定的维度上求和，默认为全部<br>求和<br>—— out=None 输出直接存入该参数<br>—— initial=初始值<pre><code>np.sum([[0, 1], [0, 5]])#6np.sum([[0, 1], [0, 5]], axis=0)#array([0, 6])np.sum([[0, 1], [0, 5]], axis=1)#array([1, 5])np.sum([])#0.0</code></pre></li><li>其他聚集操作<br>• all 布尔型：与<br>• any 布尔型：或<br>• max 最大值<br>• min 最小值<br>• mean 均值<br>• std 标准差</li><li>类型转换<br>.astype(T) 转为T类型<pre><code>x = array([[0, 1],[2, 3]])x.astype(np.float32)"""array([[0., 1.],[2., 3.]], dtype=float32)"""</code></pre></li><li>矩阵运算<br>• NumPy对于多维数组的运 算，缺省情况下并不使用矩阵运算（特指 乘除法）。<br>• numpy库提供了matrix类，使用matrix类创建矩阵对象，它们的加减乘除运算缺省采用矩阵方式计算<br>• NumPy中同时存在ndarray和matrix对象，容易混淆，需要注意。</li><li>矩阵运算<br>• 矩阵的乘积可以使用dot函数进行计算。<br>• dot<br>—— 对于两个一维的数组，计算的是这两个数组对<br>应下标元素的乘积和（内积）。<br>—— 对于二维数组，计算的是两个数组的矩阵乘积。<br>—— 对于多维数组，通用计算公式为数组a的最后一维上的所有元素与数组b的倒数第二维上的所有元素的乘积和：<br>• dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])<pre><code>a = np.array([[2, 0], [0, 1]])b = np.array([[4, 1], [2, 2]])c = np.dot(a, b)  """array([[8, 2],[2, 2]])"""</code></pre></li><li>排序<br>• .sort() 对数组进行排序，将改变数组的内容。<br>• .argsort() 返冋数组的排序下标<pre><code>a = np.array([5,3,2,4,1])a.argsort()array([4, 2, 1, 3, 0], dtype=int64)</code></pre></li><li>NumPy模块<br>• numpy.linalg模块<br>—— 包含线性代数的函数。可以计算逆矩阵、求特征值、奇异值分解、解线性方程组以及求解行列式、秩等<br>• numpy.fft模块<br>—— 提供了快速傅里叶变换及其逆变换。<br>• numpy.random 模块<br>—— 支持二项分布、超几何分布、正态分布等</li><li>numpy.linalg<br>• 解方程<br>3 * x0 +  x1 = 9<br>x0 + 2 * x1 = 8<pre><code>a = np.array([[3,1], [1,2]])b = np.array([9,8])x = np.linalg.solve(a, b)xarray([ 2., 3.])np.allclose(np.dot(a, x), b)</code></pre><h5 id="MATPLOTLIB"><a href="#MATPLOTLIB" class="headerlink" title="MATPLOTLIB"></a>MATPLOTLIB</h5>• Python绘图库。<br>• 由 John Hunter (1968-2012) 创建。<br>• 拥有一套和Matlab几乎相同语法的绘图库。<br>• 也拥有另一套面向对象的绘图库。<br>• <a href="http://matplotlib.org/" target="_blank" rel="noopener">http://matplotlib.org/</a> 参考 Example 和 Gallery。</li><li>导入<br>• import matplotlib.pyplot as plt<br>• from matplotlib.pyplot import *<br>• pyplot模块模拟了matlab接口</li><li>入门示例<pre><code>import numpy as npfrom matplotlib.pyplot import *#or: from matplotlib.pylab import * # pylab = pyplot + numpyx = np.linspace(0, 5, 10)y = x ** 2figure()plot(x, y, 'r‐o')xlabel('x')ylabel('y')title('title')show()</code></pre></li><li>Plot<br>• x:如果缺少x则按照(0,1,2,3…)<br>• y<br>• “r‐o”: red, 实线, 圆点<br>—— 类似有 “g‐‐x”  绿色虚线X<br>• plot改为semilogx, semilogy, loglog<br>可以变为对数坐标尺度</li><li>颜色<br>• 单词，如’red’<br>• 字母，如’r’<br>• 6位16进制数，如’#FF0000’或’#ff0000’<br>• 三(RGB)或四(RGBA)元组，如(1, 0, 0)或(1,0,0,1)<br>• 灰度字符串，如’0.8’<pre><code>import numpy as npimport matplotlib.pyplot as plta = b = np.linspace(0, 3, 50)c = np.exp(a)d = c[::‐1]plt.plot(a, c, 'r‐‐', label='Model length')plt.plot(a, d, 'b:', label='Data length')plt.plot(a, c+d, 'k', label='Total message length')legend = plt.legend(loc='upper center', shadow=True)legend.get_frame().set_facecolor('#00FFCC')plt.show()</code></pre></li><li>保存绘图<br>• plt.savefig()<br>—— 文件名是必需参数。<br>—— 示例：plt.savefig(“abc.png”, bbox_inches=’tight’)<br>—— bboxinches=’tight’ 去掉不需要的白边。<br>• plt.show()<br>—— 只在屏幕上显示。</li><li>多个绘图<pre><code>x = np.linspace(0.0, 6.28, 100)y1 = np.cos(x)y2 = np.sin(x)plt.subplot(2, 1, 1)plt.plot(x, y1, 'yo‐')plt.grid(True)plt.subplot(2, 1, 2)plt.plot(x, y2, 'r.‐')plt.xlabel('time (s)')plt.show()</code></pre></li><li>直方图<pre><code>mu, sigma = 100, 15x = mu + sigma * np.random.randn(10000)n, bins, patches = plt.hist(x, 50,normed=1,facecolor='g',alpha=0.75)plt.xlabel('Smarts')plt.ylabel('Probability')plt.title('Histogram of IQ')plt.text(60, .025,r'$\mu=100,\ \sigma=15$')plt.axis([40, 160, 0, 0.03])plt.grid(True)plt.show()</code></pre></li><li>散点图<pre><code>x = np.random.random(50)y = np.random.random(50)c = np.random.random(50)  # color of pointss = 500 * np.random.random(50)  # size of pointsfig, ax = plt.subplots()im = ax.scatter(x, y, c=c, s=s, cmap=plt.cm.jet)# Add a colorbarfig.colorbar(im, ax=ax)# set the color limitsim.set_clim(0.0, 1.0)</code></pre><h3 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h3><h5 id="检查网站地图"><a href="#检查网站地图" class="headerlink" title="检查网站地图"></a>检查网站地图</h5>• Sitemap（网站地图）<br>• 网站提供的Sitemap文件可以帮助爬虫定位网站所有网页的链接；<br>• Sitemap文件提供了爬取网站的有效方式，但该文件经常存在缺失、过期或不完整。<h5 id="检测网站构建技术"><a href="#检测网站构建技术" class="headerlink" title="检测网站构建技术"></a>检测网站构建技术</h5>• 构建网站的技术类型会对爬取产生影响。<br>—— 例如网页是动态生成的还是静态页面。<br>• 安装 builtwith 库，将URL作为参数，该库<br>返回网站使用的技术特征。<br>• pip install builtwith<h5 id="调研网站的所有者"><a href="#调研网站的所有者" class="headerlink" title="调研网站的所有者"></a>调研网站的所有者</h5>• 根据网站的所有者，判定爬虫的下载速度等；<br>• 为了找到网站的所有者，可以使用WHOIS协议查询域名的注册者。<br>• 安装：pip install python-whois<h5 id="下载单个网页"><a href="#下载单个网页" class="headerlink" title="下载单个网页"></a>下载单个网页</h5>• python提供了urllib2, requests等库<pre><code>import requestsurl = 'http://www.weather.com.cn/weather/101010100.shtml' # URL地址header = {'User‐Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36(KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36Core/1.53.3226.400 QQBrowser/9.6.11681.400'}req = requests.get(url, headers=header, timeout=60)req.encoding = 'utf‐8' # 设置文本编码code = req.status_code # 返回状态，200代表OKprint(code)</code></pre>• 遇到错误怎么办？(code!=200)<br>• 下载时遇到的错误经常是临时性的：<br>_ 如服务器过载时返回的503 Service Unavailable错误；<br>_ 对于此类错误，可以尝试重新下载。<br>• 非临时性错误<br>_ 如果服务器返回的是404 Not Found错误，说明该网页目前并不存在，再次尝试同样的请求也通常会再次出错。<br>• 400+错误发生在客户端，500+错误则发生在服务端。<br>• 在code为500+时可以重试下载，但通常应该等待一段时间。<h5 id="分析网页的三类技术"><a href="#分析网页的三类技术" class="headerlink" title="分析网页的三类技术"></a>分析网页的三类技术</h5>• 正则表达式<br>_ 无视HTML语言，直接利用正则表达式筛选出所需的部分，包括天气和URL；<br>• BeatifulSoup<br>_ 将HTML进行解析，利用树结构进行分析；<br>• lxml<br>_ 将HTML进行解析，基于XPATH查询语言进行分析。</li><li>BeatifulSoup<br>• Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库；<br>• 支持惯用的文档导航、查找、修改文档的方式；<br>• 提高效率，通常较正则表达式可以节省数小时甚至数天的工作时间。<br>• pip install beautifulsoup4<pre><code>from bs4 import BeautifulSouphtml_doc = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class="story"&gt;Once upon a time there were three little sisters;and their names were&lt;a href="http://example.com/elsie" class="sister"id="link1"&gt;Elsie&lt;/a&gt;,&lt;a href="http://example.com/lacie" class="sister"id="link2"&gt;Lacie&lt;/a&gt; and&lt;a href="http://example.com/tillie" class="sister"id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class="story"&gt;...&lt;/p&gt;"""soup = BeautifulSoup(html_doc)print(soup.prettify()) # 排版soup.title# &lt;title&gt;The Dormouse's story&lt;/title&gt;soup.title.name# 'title'soup.title.string# 'The Dormouse's story'soup.title.parent.name# 'head'soup.p# &lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;soup.p['class']# 'title'soup.a# &lt;a class="sister" href="http://example.com/elsie"id="link1"&gt;Elsie&lt;/a&gt;soup.find_all('a')# [&lt;a class="sister" href="http://example.com/elsie"id="link1"&gt;Elsie&lt;/a&gt;,#  &lt;a class="sister" href="http://example.com/lacie"id="link2"&gt;Lacie&lt;/a&gt;,#  &lt;a class="sister" href="http://example.com/tillie"id="link3"&gt;Tillie&lt;/a&gt;]soup.find(id="link3")# &lt;a class="sister" href="http://example.com/tillie"id="link3"&gt;Tillie&lt;/a&gt;</code></pre>• 从文档中找到所有a标签的链接<pre><code>for link in soup.find_all('a'):    print(link.get('href'))# http://example.com/elsie# http://example.com/lacie# http://example.com/tillie</code></pre>• 从文档中获取所有文字内容<pre><code>print(soup.get_text())# The Dormouse's story## The Dormouse's story## Once upon a time there were three little sisters; and their\names were# Elsie, Lacie and ...</code></pre></li><li>如何遍历网页内容<br>• BS4提供了children, parents, next_element等<br>一系列方法，可以对元素的子元素、父元<br>素、兄弟元素等进行导航，从而遍历整个<br>网页。<br>• BS4也提供了正则表达式等方法。<br>• BS4的介绍可以参考：<br><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a></li><li>链接爬虫<br>• 链接爬虫表现得更像普通用户，它跟踪链接，访问感兴趣的内容。<br>• 通过跟踪所有链接的方式，可以下载整个网站的页面。<br>• 这种方法会下载大量并不需要的网页，通常应该利用正则表达式匹配/过滤需要爬取的网页。<br>• 避免链接爬虫陷阱<br>• 某些网站会动态生成页面内容，有可能造成理论上无限多的页面。<br>——例如：日历网站，链接指向“下个月”<br>• 通常应该定义爬虫最大深度，避免爬虫陷阱。<h3 id="图形界面开发GUI"><a href="#图形界面开发GUI" class="headerlink" title="图形界面开发GUI"></a>图形界面开发GUI</h3><a href="https://www.jianshu.com/p/db0af187ab26" target="_blank" rel="noopener">python图形化GUI：pyQt5详解</a><br><a href="https://www.jianshu.com/p/8ce24bd03978" target="_blank" rel="noopener">python图形化GUI：pyQt5-tools详解</a><h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5>• Model（模型）是应用程序中用于处理应用程序数据逻辑的部<br>分，通常模型对象负责在数据库中存取数据。<br>• View（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。<br>• Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。<br>• MVC 分层有助于管理复杂的应用程序，因为您可以在一个时间内专门关注一个方面。例如，您可以在不依赖业务逻辑的情况下专注于视图设计。同时也让应用程序的测试更加容易。<br>• MVC 分层同时也简化了分组开发。不同的开发人员可同时开发视图、控制器逻辑和业务逻辑。</li></ul><p><a href="https://www.jianshu.com/p/38167906095e" target="_blank" rel="noopener">python：PIL图像处理</a></p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><h5 id="EXCEL自动化"><a href="#EXCEL自动化" class="headerlink" title="EXCEL自动化"></a>EXCEL自动化</h5><p>• Excel 是 Windows 环境下流行的、强大的电子表格应用。<br>—— 包括LibreOffice Calc，OpenOffice Calc，WPS等软件也可以读写xlsx格式。<br>• openpyxl 模块让 Python 程序能读取和修改Excel 电子表格文件。最新版本2.6.2。<br>• <a href="https://openpyxl.readthedocs.io" target="_blank" rel="noopener">https://openpyxl.readthedocs.io</a><br>• 安装：pip install openpyxl</p><ul><li>取得工作簿及工作表<pre><code>import openpyxlwb = openpyxl.load_workbook('example.xlsx')wb.sheetnamessheet = wb['Sheet3']sheet.titleanotherSheet = wb.activeanotherSheet</code></pre></li><li>取得单元格<pre><code>sheet = wb['Sheet1']sheet['A1']sheet['A1'].valuec = sheet['B1']c.valuefor i in range(1, 5):  print(i, sheet.cell(row=i, column=2).value)</code></pre></li><li>取得矩形区域<pre><code>for rowOfCellObjects in sheet['A1':'C3']:    for cellObj in rowOfCellObjects:          print(cellObj.coordinate, cellObj.value)    print('‐‐‐ END OF ROW ‐‐‐')</code></pre></li><li>取得行或者列：支持循环迭代<pre><code>for i in sheet.rows:    print(i)for i in sheet.columns:    print(i)</code></pre></li><li>数据结果的保存<br>• 保存在txt文件中<br>• 保存在csv文件中<br>• 保存在py文件中<pre><code>import pprintresultFile = open('result.py', 'w')resultFile.write('pay_sum = ' + pprint.pformat(pay_sum))resultFile.close()</code></pre></li><li>创建空白工作簿和表<pre><code>import openpyxlwb = openpyxl.Workbook()print(wb.sheetnames)sh = wb.activesh.title = "My Data"wb.save("mydata.xlsx")</code></pre></li><li>创建和删除工作表<pre><code>import openpyxl&gt;&gt;&gt; wb = openpyxl.Workbook()&gt;&gt;&gt; wb.get_sheet_names()['Sheet']&gt;&gt;&gt; sh1 = wb.create_sheet()&lt;Worksheet "Sheet1"&gt;&gt;&gt;&gt; wb.get_sheet_names()['Sheet', 'Sheet1']&gt;&gt;&gt; wb.create_sheet(index=0, title='First Sheet')&lt;Worksheet "First Sheet"&gt;&gt;&gt;&gt; wb.get_sheet_names()['First Sheet', 'Sheet', 'Sheet1']&gt;&gt;&gt; wb.remove_sheet(sh1)   #删除表&gt;&gt;&gt; wb.get_sheet_names()['First Sheet', 'Sheet']</code></pre></li><li>将值写入单元格<pre><code>import openpyxlwb = openpyxl.Workbook()sheet = wb.activesheet['A1'].value = 'Hello world!'wb.save("hello.xlsx")</code></pre></li><li>其他功能<br>• 改变字体<br>• 使用公式<br>• 设置行高和列宽<br>• 单元格拆分<br>• 绘制图表<br>例子：乘法表<pre><code>import openpyxlwb = openpyxl.Workbook()sheet = wb.activefor i in range(1, 10):sheet.cell(row=i+1, column=1).value = isheet.cell(row=1, column=i+1).value = ifor i in range(1, 10):for j in range(1, 10):sheet.cell(row=i+1, column=j+1).value=i*jwb.save("99.xlsx")</code></pre><h5 id="WORD自动化"><a href="#WORD自动化" class="headerlink" title="WORD自动化"></a>WORD自动化</h5>• Microsoft公司的Word是一套功能丰富的办公软件，所提供的docx格式可以存储文本以及字体、颜色等丰富的信息。<br>• docx的读写比txt文件要复杂，需要第三方库的支持。<br>• pip install python‐docx<br>• 注意：导入的时候用 import docx</li><li>docx文件结构<br>• docx 文件有很多结构。<br>• 这些结构在 python-docx 中用 3 种不同的类型来表示。<br>• Document 对象表示整个文档。<br>• Document 对象包含一个 Paragraph 对象的列表，Paragraph即文档中的段落。<br>• 每个 Paragraph 对象都包含一个 Run 对象的列表。</li><li>读取文档<pre><code>import docxdoc = docx.Document('libai.docx')print(len(doc.paragraphs)# 8print(doc.paragraphs[0].text)# '铁杵成针'print(doc.paragraphs[2].text)# '李白是唐代的大诗人，但是小时候读书并不用功。...'print(doc.paragraphs[2].runs)#[&lt;docx.text.run.Run at 0x1e0e56a3c50&gt;,...]print(doc.paragraphs[2].runs[0].text)#'李白是唐代的大诗人，'print(doc.paragraphs[2].runs[1].text)#'但是小时候读书并不用功'</code></pre></li><li>获取Word中的纯文本<br>• 如果不关注样式，只希望获得所有的文本<br>• 参考代码实现：<pre><code>import docxdef getText(filename):    doc = docx.Document(filename)    fullText = []    for para in doc.paragraphs:          fullText.append(para.text)    return '\n'.join(fullText)</code></pre></li><li>Word中的样式<br>• Word有很多样式，可以通过段落或run对象的style属性获得。<br>• 可以通过设置下列属性产生不同的样式<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cdf1dbbe2c7c7ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>修改样式<pre><code>import docxdoc = docx.Document('libai.docx')doc.paragraphs[2].runs[0].underline = Truedoc.save('restyled‐libai.docx')</code></pre></li><li>生成Word文档<br>• doc.add_paragraph(text) 新建一个段落，返回段落对象。<br>• para.add_run(text) 新建一个run，返回run对象。<br>• doc.add_heading(text, level) 新建一个标题，层级为level<br>• doc.add_picture(filename) 新建一个图片<pre><code>import docxdoc = docx.Document()doc.add_heading('静夜思', 0)doc.add_heading('李白', 1)for s in ["床前明月光", "疑是地上霜", "举头望明月","低头思故乡"]:para = doc.add_paragraph(s)para.add_run("/")doc.add_picture("green.jpg")doc.save('mydoc.docx')</code></pre><h5 id="PDF自动化"><a href="#PDF自动化" class="headerlink" title="PDF自动化"></a>PDF自动化</h5>• PDF 表示 Portable Document Format 便携式文件格式，由Adobe Systems在1993年用于文件交换所发展出的文件格式。<br>• 本部分专注两件事：<br>—— 从 PDF 读取文本内容<br>—— 从已有的文档页面生成新的 PDF。<br>• pip install pyPDF2</li><li>PDF读取文字<pre><code>import PyPDF2with open('04067093.pdf', 'rb') as pdfFile:pdfReader = PyPDF2.PdfFileReader(pdfFile)print("Total pages: ", pdfReader.numPages)page0 = pdfReader.getPage(0)print(page0.extractText())</code></pre></li><li>合并PDF<pre><code>import PyPDF2pdf1File = open('00294849.pdf', 'rb')pdf2File = open('04067093.pdf', 'rb')pdf1Reader = PyPDF2.PdfFileReader(pdf1File)pdf2Reader = PyPDF2.PdfFileReader(pdf2File)pdfWriter = PyPDF2.PdfFileWriter()for pageNum in range(pdf1Reader.numPages):    pageObj = pdf1Reader.getPage(pageNum)    pdfWriter.addPage(pageObj)for pageNum in range(pdf2Reader.numPages):    pageObj = pdf2Reader.getPage(pageNum)    pdfWriter.addPage(pageObj)pdfOutputFile = open('combined.pdf', 'wb')pdfWriter.write(pdfOutputFile)pdfOutputFile.close(); pdf1File.close(); pdf2File.close()</code></pre></li><li>页面旋转和叠加<br>• rotateClockwise(0, 90, 180, 270)<br>• rotateCounterClockwise(…)<br>_ 可以将页面对象旋转<br>• mergePage(anotherPage)<br>_ 可以将页面叠加（水印）<br>• 综合上述功能，可以实现pdf文件的合并、页面抽取、旋转、叠印等功能。</li><li>PDF中文编码问题<br>• pyPDF2不能读取中文编码的文字；<br>• 可以使用pdfminer库或其他类似的库。<pre><code>import iofrom pdfminer.converter import TextConverterfrom pdfminer.pdfinterp import PDFPageInterpreterfrom pdfminer.pdfinterp import PDFResourceManagerfrom pdfminer.pdfpage import PDFPagedef extract_text_from_pdf(pdf_path):  resource_manager = PDFResourceManager()  fake_file_handle = io.StringIO()  converter = TextConverter(resource_manager, fake_file_handle)  page_interpreter = PDFPageInterpreter(resource_manager, converter)  with open(pdf_path, 'rb') as fh:      for page in PDFPage.get_pages(fh, caching=True):          page_interpreter.process_page(page)      text = fake_file_handle.getvalue()  converter.close()  fake_file_handle.close()  if text:      return textif __name__ == '__main__':print(extract_text_from_pdf('CH9‐图形界面开发A.pdf'))</code></pre><h5 id="图像处理自动化"><a href="#图像处理自动化" class="headerlink" title="图像处理自动化"></a>图像处理自动化</h5>• 图像处理已经是深入日常生活，Photoshop的缩写已经成为图像处理的代名词。<br>• 如果需要编辑大量的图像，手工编辑可能是漫长、枯燥的工作。<br>• Pillow 是一个第三方 Python 模块，用于处理图像文件。该模块包含一些函数，可以很容易地裁剪图像、调整图像大小，以及编辑图像的内容，从而轻松地自动编辑成千上万的图像。</li><li>颜色和 RGBA 值<br>• 计算机程序通常将图像中的颜色表示为RGBA 值。RGBA 值是一组数字，指定顔色中的红、绿、蓝和 alpha（透明度）的值。<br>• 这些值是从 0到 255（最高）的整数。<br>• 这些 RGBA 值分配给单个像素，像素是计算机屏幕上能显示一种颜色的最小点。<br>• 像素的 RGB 设置准确地告诉它应该显示哪种颜色的色彩。</li><li>Alpha通道<br>• 图像也有一个 alpha 值，用于生成 RGBA 值。如果图像显示在屏幕上，遮住了背景图像或桌面墙纸，alpha 值决定了“透过”颜色可以看到多少程度的背景。<br>• 如果alpha 值为 0，表示完全透明。<br>• 如果alpha 值为 255，表示完全不透明。</li><li>获取颜色<pre><code>&gt;&gt;&gt; from PIL import ImageColor&gt;&gt;&gt; ImageColor.getcolor('red', 'RGBA')(255, 0, 0, 255)&gt;&gt;&gt; ImageColor.getcolor('RED', 'RGBA')(255, 0, 0, 255)&gt;&gt;&gt; ImageColor.getcolor('Black', 'RGBA')(0, 0, 0, 255)&gt;&gt;&gt; ImageColor.getcolor('chocolate', 'RGBA')(210, 105, 30, 255)&gt;&gt;&gt; ImageColor.getcolor('CornflowerBlue', 'RGBA')(100, 149, 237, 255)</code></pre></li><li>图像坐标系<br>• 左上角坐标为(0,0)<br>• y正方向向下<br>• x正方向向右</li><li>Box<br>• 一个矩形元组参数，表示图像中的一个矩形区域。四个整数按顺序分别是：<br>_左：该矩形的最左边的 x 坐标。<br>_顶：该矩形的顶边的 y 坐标。<br>_右：该矩形的最右边右面一个像素的 x 坐标。<br>_底：该矩形的底边下面一个像素的 y 坐标。<br>• 矩形元组（3, 1, 9, 6）</li><li>图像的打开和存储<pre><code>&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; img = Image.open('horse.jpg')&gt;&gt;&gt; img.size　 (1674, 1116)&gt;&gt;&gt; width, height = img.size&gt;&gt;&gt; img.format'JPG'&gt;&gt;&gt; img.save('horse.png')</code></pre></li><li>生成新图像<pre><code>from PIL import Imageim = Image.new('RGBA', (100, 200), 'purple')im.save('purpleImage.png')im2 = Image.new('RGBA', (20, 20))im2.save('transparentImage.png')</code></pre></li><li>裁剪图片<pre><code>croppedIm = img.crop((600, 200, 1000, 800))croppedIm.save('cropped‐horse.png')</code></pre></li><li>复制和粘贴<pre><code>from PIL import Imageimg = Image.open('horse.jpg')croppedIm = img.crop((600, 200, 1000, 800))horsehead = croppedIm.copy()img.paste(horsehead, (1200, 200))img.save('horse2.jpg')</code></pre></li><li>调整图像大小及旋转图像<pre><code>from PIL import Imageimg = Image.open('horse.jpg')width, height = img.sizeimg44 = img.resize((width//4, height//4), Image.NEAREST)img42 = img.resize((width//4, height//2), Image.NEAREST)imgr30 = img.rotate(30)img44.save('horse44.jpg')img42.save('horse42.jpg')imgr30.save('horse_r30.jpg')</code></pre></li><li>更改单个像素<br>• 单个像素的颜色通过 getpixel()和putpixel()方法取得和设置。它们都接受一个元组，表示像素的 x 和 y坐标。<br>• putpixel()方法还接受一个元组，作为该像素的颜色。这个顔色参数是四整数 RGBA 元组或三整数 RGB 元组。<br>• 注：1. 能改一个像素就能进行任意的图像编辑；</li></ul><ol start="2"><li>图片像素很多时，本方法很慢。<pre><code>img = Image.new('RGB', (200, 100), 'black')print(img.getpixel((0, 0)))for x in range(100):for y in range(50):img.putpixel((x, y), (210, 210, 210))img.save('putPixel.png')</code></pre></li></ol><ul><li>绘制形状<br>• ImageDraw 方法在图像上绘制各种形状。<br>• 点：point(xy, fill)方法绘制单个像素。xy 参数表示要画的点的列表。该列表可以是 x和 y 坐标的元组的列表，例如[(x, y), (x, y), …]，或是没有元组的 x和 y 坐标的列表，例如[x1, y1, x2, y2, …]。<br>• 线：line(xy, fill, width)方法绘制一条线或一系列的线。xy 是一个元组的列表，例如[(x, y), (x,y), …]，或整数列表，例如[x1, y1, x2, y2, …]。每个点都是正在绘制的线上的一个连接点。<br>• 矩形、椭圆、多边形、文字等。<pre><code>from PIL import Image, ImageDrawim = Image.new('RGBA', (200, 200), 'white')draw = ImageDraw.Draw(im)draw.line([(0, 0), (199, 0), (199, 199), (0, 199), (0,0)], fill='black')draw.rectangle((20, 30, 60, 60), fill='blue')draw.ellipse((120, 30, 160, 60), fill='red')draw.polygon(((57, 87), (79, 62), (94, 85), (120, 90),(103, 113)), fill='brown')for i in range(100, 200, 10):draw.line([(i, 0), (200, i ‐ 100)], fill='green')im.save('drawing.png')</code></pre><h5 id="键盘鼠标自动化"><a href="#键盘鼠标自动化" class="headerlink" title="键盘鼠标自动化"></a>键盘鼠标自动化</h5>• 白盒：完成了解docx/xlsx格式细节，通过python直接生成符合格式的文档。<br>• 灰色：Word/Excel提供某种控制接口（如COM接口），通过COM接口操作Word/Excel软件达到预期目标。<br>• 黑色：缺乏控制接口，仅能通过模拟键盘和鼠标事件驱动GUI软件。</li><li>pyautogui<br>• pyautogui模块可以模拟鼠标移动、按键和滚动鼠标滚轮等。<br>• 本节仅介绍pyautogui的部分功能。<br>• <a href="http://pyautogui.readthedocs.org/" target="_blank" rel="noopener">http://pyautogui.readthedocs.org/</a><br>• 安装：<br>_ pip install PyGetWindow==0.0.1<br>_ pip install pyautogui</li><li>注意事项<br>• Python 能以想象不到的高速移动鼠标并击键。它可能太快，导致被控程序跟不上。<br>• 如果出了问题，而程序仍然继续到处移动鼠标，计算机就会失去控制（因为你的键盘和鼠标被人控制了）。<br>—— 如果程序自己在移动鼠标，停止它可能很难。你可能无法点击“关闭”按钮<br>• Windows 和 Linux  上，注销的热键是 Ctrl-Alt-Del ，有可能会失去目前没有保存的文档。</li><li>预防措施<br>• 设置脚本在每次函数调用后暂停一段时间，让用户有很短的时间窗口来控制鼠标和键盘。<br>—— 将pyautogui.PAUSE 变量设置为要暂停的秒数。如设置：pyautogui.PAUSE = 1.5。<br>• 开启pyautogui 自动防故障功能。<br>—— 将鼠标移到屏幕的左上角，将导致pyautogui.FailSafeException 异常。<br>—— 故障时应尽可能快地向左上移动鼠标，以触发异常。<br>—— 该异常可以用try语句捕获。</li><li>屏幕坐标系<br>• 左上角为原点<br>• x向右为正方向<br>• y向下为正方向<pre><code>import pyautogui as agwidth, height = ag.size()print(width, height)#1366, 768</code></pre></li><li>移动鼠标<pre><code>import pyautoguifor i in range(10):ag.moveTo(100, 100, duration=0.25)ag.moveTo(200, 100, duration=0.25)ag.moveTo(200, 200, duration=0.25)ag.moveTo(100, 200, duration=0.25)</code></pre></li><li>获取鼠标位置<br>• position()函数获得鼠标当前的位置。<br>• 为了持续跟踪获得鼠标位置，可以采用下述代码：<pre><code>print('Press Ctrl‐C to quit.')try:  while True:      x, y = pyautogui.position()      print(f"mouse at {x:4d}, {y:4d}")except KeyboardInterrupt:  print('\nDone.')</code></pre></li><li>点击鼠标<br>• 当前位置点击 click() 方法。<br>• 若在位置(x,y) 点击，采用click(x,y)方法。<br>• 默认情况下点击左键。若指定鼠标按键，则需要button关键字参数，取值为 ‘left’、’middle’或’right’。<br>• 例：<br>_ click(100, 150, button=’left’)<br>_ click(200, 250, button=’right’)<br>• 模拟鼠标按下：mouseDown()<br>• 释放鼠标按键：mouseUp()<br>• 函数参数与 click()<br>_ click = mouseDown + mouseUp<br>• 鼠标双击：doubleClick()</li><li>拖动鼠标<br>• Drag即按住一个按键不放同时移动鼠标。<br>_ 通过拖动文件图标，在文件夹之间移动文件；<br>_ 可以拖动绘图。<br>• dragTo() 和 dragRel() 函数将鼠标拖动到一个新的位置，或相对当前的位置。<br>_ 函数的参数与moveTo() 和 moveRel() 相似。<pre><code>import pyautogui as agimport timetime.sleep(5)ag.click()distance = 200while distance &gt; 0:  ag.dragRel(distance, 0, duration=0.2) # move right  distance = distance ‐ 5  ag.dragRel(0, distance, duration=0.2) # move down  ag.dragRel(‐distance, 0, duration=0.2) # move left  distance = distance ‐ 5  ag.dragRel(0, ‐distance, duration=0.2) # move up</code></pre></li><li>获取屏幕内容<pre><code>import pyautoguiim = pyautogui.screenshot()im.save("capture.png")</code></pre>• 做GUI自动测试时，可以利用截图分析按钮是否正常或者变灰（利用Pillow库的getpixel方法）。<br>• 可以做一个软件，随着鼠标移动，自动取得不同位置的颜色。</li><li>屏幕图像识别<br>• 提前准备一幅（截图后取出）的局部图像：<br>• locateOnScreen(‘want.png’)<br>• 找到屏幕上完全匹配的图像所在的box，然后可在box的中心（或其他位置）进行点击。</li><li>键盘<br>• typewrite()方法模拟发送按键<br>_ typewrite(‘Hello world!’)<br>_ typewrite([‘a’, ‘b’, ‘left’, ‘left’,’X’, ‘Y’])<br>_ 前者均为正常按键<br>_ 后者的’left’表示“左方向键”</li><li>键盘：特殊键<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f6e85cea98792463.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>键盘模拟<br>• keyDown()和keyUp()将向计算发送虚拟的按键和释放。<br>• press() 函数模拟完整的击键。<pre><code>keyDown('shift');press('1');keyUp('shift')</code></pre>相当于 Shift-1 ，即“ ! ”键<br>• hotkey() 按参数自左向右依次模拟按键倒序模拟释放。<br>_ hotkey(‘ctrl’, ‘alt’, ‘shift’, ‘s’)</li><li>可能完成的任务<br>• 模拟键盘及鼠标，实现自动填表；<br>• 填写Excel表格；<br>• 编写Word文件。<br>• 自动玩游戏；<br>• 网络爬虫：<br>• 模拟键盘输入关键字，发送“回车”键，获得页面；<br>• 利用键盘另存当前页面；<br>• 点击“下一页”，继续另存当前页面<br>• 聊天机器人<br>• 模拟键盘输入微信、QQ等<br>• 在AI时代，视觉、听觉和模拟发声、模拟形象都可以实现。<h3 id="数据存储与程序调试"><a href="#数据存储与程序调试" class="headerlink" title="数据存储与程序调试"></a>数据存储与程序调试</h3><h5 id="数据转换存储"><a href="#数据转换存储" class="headerlink" title="数据转换存储"></a>数据转换存储</h5>• 数据的存储交换发生在：<br>_ 在同一程序的不同片段之间；<br>_ 在不同的程序之间；<br>_ 在不同主机之间。<br>• 这些数据可能存储一些简单的文本和数值，也可能是非常复杂具有结构的一组数据。<br>• 为了实现数据的存储和交换，有多种相对流行的数据存储交换方式：<br>_ 文件或数据库。</li><li>INI文件<br>• INI用来表示简单的、分层次的配置文件，其内涵类似于Python的词典。<br>• 本质是纯文本文件，但有一些简单的格式。</li><li>INI文件的读写<br>• 由于格式非常简单，可以基于一般文件的read/write进行存取。<br>• Python提供了内置库：<pre><code>import configparserconfig = configparser.ConfigParser()config.add_section('Init')config.set('Init', 'Server', '127.0.0.1')config.set('Init', 'Port', '12000')with open('my.ini', 'wt') as configfile:  config.write(configfile)</code></pre></li><li>pickle<br>• Pickle库可以实现任意python对象的存储。<pre><code>import pickletodo = ['write a blog post','reply an email','read a book']pickle_file = open('todo.pickle', 'wb')pickle.dump(todo, pickle_file)</code></pre></li><li>Pickle &amp; cPickle<br>• Pickle<pre><code>pickle_file = open('todo.pickle', "rb")todo = pickle.load(pickle_file)pickle_file.close()print(todo)</code></pre></li><li>JSON<br>• Pickle仅限于Python程序使用，如何和其他语言交互？<br>• JSON (JavaScript Object Notation) 是跨语言的轻量级数据交换格式。<br>• 易于被人工读取、修改，也容易被机器读取和写入。<br>• 符合 ECMA-262 3rd Edition标准。<br>• JSON语言无关，它可以方便的被 C, C++, C#,Java, JavaScript, Perl, Python等语言读取和生成。<br>• 结论：JSON是理想的数据交换格式，可以实<br>现跨语言的、跨计算机的复杂数据传输。<pre><code>import jsondatastore = { "room‐number": 100,"use": "reception","sq‐ft": 50,"price": [100, 200, 300]}with open("ds.json", 'w') as f:  json.dump(datastore, f)with open("ds.json", 'r') as f:  data = json.load(f)print(data)</code></pre></li><li>数据库<br>• 文件存储不适用于大项目，此时需要使用数据库。<br>• 数据管理系统 Database Management System= DBMS<br>_ 一系列存储数据的文件；<br>_ 一系列程序用于访问和更新其中的数据。<br>• 目前最流行的数据库是关系型数据库。</li><li>SQLite<br>• SQlite 是开源的数据库，可以嵌入在其他程序中，不需要安装。<br>• 单机版本，不能并发、不能网络访问、不需要用户名密码鉴权（但可以加密）。<br>• Portable – 仅使用了ANSI-standard C语言，因此可在各种平台编译；<br>• Reliable – 良好的测试，开源代码；<br>• Small – 300 kb 的库，只需要16kb的stack和100kb的heap，甚至可以运行在单片机上。</li><li>建库<pre><code>import sqlite3conn = sqlite3.connect('example.db')c = conn.cursor()c.execute('''CREATE TABLE money(日期, 姓名, 支出)''')for d, n, m in [("2019‐4‐1", "Li Lei", 52),("2019‐4‐2", "Han Meimei", 300),("2019‐4‐5", "Li Lei", 230),("2019‐4‐8", "Li Lei", 170),("2019‐4‐10", "Han Meimei", 96)]:  c.execute("INSERT INTO money VALUES (?,?,?)",(d,n,m))conn.commit()conn.close()</code></pre></li><li>用库<pre><code>import sqlite3conn = sqlite3.connect('example.db')c = conn.cursor()result = c.execute('''select 姓名, 支出    from money where 支出&gt;100;''')for row in result:  name = row[0]  pay = row[1]  print(f"{name} pay {pay}&gt;100")conn.close()</code></pre></li><li>其他格式<br>• MAT：Matlab数据存储格式<br>• Python可以直接读取MAT文件，Python也可以调用Matlab完成特定任务。<h5 id="目录处理"><a href="#目录处理" class="headerlink" title="目录处理"></a>目录处理</h5>• 查找目录下的子目录和文件<br>_ glob库<br>• 遍历目录<br>_ os.walk方法</li><li>实例<pre><code>import osfrom os.path import join, getsizefor root, dirs, files in os.walk('.'):print("root=", root)print(sum(getsize(join(root, name)) for name in files), end="")print("bytes in", len(files),"non‐directory files")</code></pre><h5 id="测试和调试"><a href="#测试和调试" class="headerlink" title="测试和调试"></a>测试和调试</h5></li><li>测试驱动Test-driven开发<br>• pytest是一个强大的Python测试工具。<br>• pytest是软件测试框架，它会自动找到用户写的测试用例，运行测试并报告结果。<br>• 支持插件或第三方扩展<br>• 容易与其他工具对接。<br>• pip install pytest</li><li>规则<br>• pytest 测试样例的规则：<br>_ 测试文件以 test_ 开头（以 <em>test 结尾也可以）<br>_ 测试类以 Test 开头，并且不能带有 <strong>init</strong> 方法<br>_ 测试函数以 test</em> 开头<br>_ 断言使用基本的 assert 即可<br>• pytest自动执行所有的测试，并报告通过和失败的测试用例数量。</li><li>print-调试</li><li>使用日志文件<br>• 对大规模程序长期运行而言，故障的机会是很少的，难以通过print获得；<br>• 日志是一种非常好的手段，可以用于记录程序运行过程中的各种信息。<br>• 理想的日志可以用来恢复和重现程序的运行过程。<br>• 内置的logging库。</li><li>日志等级<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-1a0cf572c74b3490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>利用IPython.embed调试<br>• from IPython import embed<br>• 在需要调试的位置加入embed()函数<br>• 可以在现场运行python解释器，可以自由执行任何python语句，包括：<br>_ 打印输出任何变量<br>_ 修改和删除任何变量<br>• print/logging应对复杂数据结构的能力不足，embed()是较为理想的选择。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些实用有趣的Web分享</title>
      <link href="/posts/webshare1.html"/>
      <url>/posts/webshare1.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：个人常用的一些实用便捷的以及有趣的网站汇总</p><p>温馨提示：多图预警，流量党注意</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h3 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h3><ul><li><p><a href="https://slidesgo.com/" target="_blank" rel="noopener">PPT优质模板：全免费</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05NzZjMWM1M2MyMDk0NGE1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.officeplus.cn/Template/Home.shtml" target="_blank" rel="noopener">OfficePlus</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227142828441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3></li><li><p><a href="https://www.wondercv.com/" target="_blank" rel="noopener">超级简历</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227122034626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><a href="https://www.wondercv.com/" target="_blank" rel="noopener">五百丁简历</a><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227122149491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul><li><a href="https://smallpdf.com/" target="_blank" rel="noopener">Smallpdf：在线pdf转换</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kM2JmZmU2ZjZjOGQ2YjE5LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h3 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h3><ul><li><p><a href="https://www.xiuzhan365.com/" target="_blank" rel="noopener">秀展网：在线MG动画制作</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01ODlmOGY4NTZkOGY4MDQyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.weiciyun.com/" target="_blank" rel="noopener">微词云：文字云艺术生成器</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zYWRiYzI0NTFjYWEwNGUwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://creativemass.cn/#/" target="_blank" rel="noopener">Creative Mass：创意导航</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kZThiYzc0YWNlMmFlNjM1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.grammarly.com/" target="_blank" rel="noopener">语法：免费写作助手</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02NjgwOWEwMWIxOTEzYTEwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://sorry.xuty.tk/sorry/" target="_blank" rel="noopener">表情锅：在线制作表情包</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1lOGJhNzk4ODlhZmNkZjM1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://zh.wix.com/" target="_blank" rel="noopener">网页制作</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi00Y2JkZTRiM2RkZjA4NDcwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.akuziti.com/yw/" target="_blank" rel="noopener">艺术字在线生成</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03NWZmNWRiNzhiODNmZWQ5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://giphy.com/" target="_blank" rel="noopener">Gif工具</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01YTJjZWU2YzdkMjQ5YWM0LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><ul><li><p><a href="https://www.chuangkit.com/dc.html" target="_blank" rel="noopener">创客贴</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03MzhmZTBkNDQ2ZjE1Y2JiLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.canva.com/" target="_blank" rel="noopener">Canva</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0wNjAyYTllYzYwNTEzNjAzLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.zitijia.com/" target="_blank" rel="noopener">字体家：商用字体下载</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227142459182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><a href="https://h5.bce.baidu.com/store" target="_blank" rel="noopener">H5设计</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/2020022714322343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><p> <a href="https://www.nounplus.net/" target="_blank" rel="noopener">Nounplus：在线查英语语法拼写错误</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0xZThjMjg0MWRlZTkxMWE5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p><ul><li><a href="http://www.gfxcamp.com/" target="_blank" rel="noopener">龋齿一号</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05YTY0MWNmMTdlM2IxMTRlLnBuZw?x-oss-process=image/format,png" alt="image.png"><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3></li><li><a href="http://tools.jb51.net/" target="_blank" rel="noopener">脚本之家在线工具</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227143425667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p><a href="https://www.materialtools.com/?page=1" target="_blank" rel="noopener">云短信：临时验证码</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03OGFkYzMyNDRiNjI0MzUyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://everytimezone.com/" target="_blank" rel="noopener">时差</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01OTlkMjNkZGNiYTg5NzFiLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h3 id="综合学习平台"><a href="#综合学习平台" class="headerlink" title="综合学习平台"></a>综合学习平台</h3><ul><li><p><a href="https://study.163.com/" target="_blank" rel="noopener">网易云课堂</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iY2Q0MDZlZjExZjY2YTU4LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.icourse163.org/" target="_blank" rel="noopener">中国大学mooc</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zNmY0NjBmOGQ0MThiM2ZlLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://ke.qq.com/" target="_blank" rel="noopener">腾讯课堂</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03Mzc5MGE5YzM4YTY1M2EzLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://next.xuetangx.com/" target="_blank" rel="noopener">学堂在线</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03NDk4Njk5ODdjYzNkODQ2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.51zxw.net/" target="_blank" rel="noopener">我要自学网</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iZjllZGE5ODQ4NzUwY2E2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul><li><p><a href="https://www.allhistory.com/" target="_blank" rel="noopener">全历史：世界各国历史记录和联系检索</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03NjYyZmFkYTU2ZWRkMGNlLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.ageeye.cn/" target="_blank" rel="noopener">发现中国：地图分享知识</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jMGY3ODQxMTM3Mzk0MGZiLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="医学"><a href="#医学" class="headerlink" title="医学"></a>医学</h3><ul><li><a href="https://www.mvyxws.com/" target="_blank" rel="noopener">医学微视</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02YjU3NjFjN2EwNDUyOWM1LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="新媒体"><a href="#新媒体" class="headerlink" title="新媒体"></a>新媒体</h1><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><ul><li><p><a href="https://www.kaolamedia.com/" target="_blank" rel="noopener">考拉新媒体导肮</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jNzcyNGJmNzI0NWYyNWVkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://tophub.today/" target="_blank" rel="noopener">今日热榜</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02MGNiNGEwYjgyYWFjMjQ4LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h3><ul><li><a href="https://mj.yuzhua.com/search/3.html" target="_blank" rel="noopener">鱼爪传媒</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0yY2YxMDE2OTQ5MWNiNGE2LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="导航-1"><a href="#导航-1" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="http://guozhivip.com/nav/" target="_blank" rel="noopener">果汁导航</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02ZDVkNzI1MDBmODg3ZDQ5LnBuZw?x-oss-process=image/format,png" alt="image.png"></li><li><a href="https://ailongmiao.com/" target="_blank" rel="noopener">龙喵网</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/2020022714393084.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><a href="https://webjike.com/" target="_blank" rel="noopener">小呆导航</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227144016570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>[北邮人导航](<a href="http://byr.wiki/）" target="_blank" rel="noopener">http://byr.wiki/）</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227144203360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><h3 id="开源平台"><a href="#开源平台" class="headerlink" title="开源平台"></a>开源平台</h3><ul><li><p><a href="https://github.com/" target="_blank" rel="noopener">Github：全球最大的开源平台</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01Mjc0MGYzYjIxMmI5N2Q2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://gitee.com/" target="_blank" rel="noopener">Gitee：国内开源平台</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02ZWJmMzg3Nzk2YzMxNDUwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.gitkraken.com/" target="_blank" rel="noopener">GitKraken：开源工具</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1hYzFkYmM2YzI2ZjM0MjExLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="博客论坛"><a href="#博客论坛" class="headerlink" title="博客论坛"></a>博客论坛</h3><ul><li><p><a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN：博客平台</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kZjk3ZThiM2MyNjY0NTgxLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.cnblogs.com/" target="_blank" rel="noopener">博客园</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kY2NiZmRhNjE1MTNlMzkyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="私人优秀博客推荐"><a href="#私人优秀博客推荐" class="headerlink" title="私人优秀博客推荐"></a>私人优秀博客推荐</h3><ul><li><a href="https://wangyasai.github.io/" target="_blank" rel="noopener">赛亚</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05ZjVkZmZhMWY3ZTU0YzE3LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><ul><li><p><a href="http://data.stats.gov.cn/index.htm" target="_blank" rel="noopener">国家统计局</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kYTFlNTQyMjNiN2M1ZGE2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.chyxx.com/" target="_blank" rel="noopener">中国产业信息网</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jMTg5YWRiNzczMTk3ZTdkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://hao.199it.com/" target="_blank" rel="noopener">大数据导航</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0wNTIxMmM0NjZlMWYyODIwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.visualcapitalist.com/" target="_blank" rel="noopener">数据表</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1lNWQ4ODc3Njg3MzVkYzQ5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="专业"><a href="#专业" class="headerlink" title="专业"></a>专业</h3><ul><li><p><a href="http://moon.bao.ac.cn/mul/index/list" target="_blank" rel="noopener">月球与行星多媒体数据库</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0xOTM3ZTMzMjVhMmRjOTY4LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://everysecond.io/" target="_blank" rel="noopener">Every Second</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iZGUzYTZiZTQ2N2I1YzBiLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h1 id="学术"><a href="#学术" class="headerlink" title="学术"></a>学术</h1><ul><li><p><a href="https://www.cnki.net/" target="_blank" rel="noopener">中国知网</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0yY2RjYzUzMGQ1YTJjOTE2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.wanfangdata.com.cn/" target="_blank" rel="noopener">万方数据知识服务平台</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi00MzZlODQ4ZDc2NGU3MGZhLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.termonline.cn/index.htm" target="_blank" rel="noopener">术语在线：专业术语查询</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01MTYwZTcxNjBmYTUwMmE0LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.oalib.com/" target="_blank" rel="noopener">Open Access Library：开源学术平台</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01MWE3ZWNjNzE0MDQ5NGU3LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.wdl.org/zh/" target="_blank" rel="noopener">世界数字图书馆</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01YjNmNjNkYWM1ZmJlYTM3LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.keoaeic.org/" target="_blank" rel="noopener">AEIC学术会议网</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04ZTMxZmY2OGNlNTMxMGE1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.cn-ki.net/" target="_blank" rel="noopener">iData-知识检索</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zZDk3ZGY4MjU3MjZhNTQ1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h3 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h3><ul><li><p><a href="https://www.pexels.com/" target="_blank" rel="noopener">Pexels</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227143554202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227143637753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><a href="http://bg-patterns.com/" target="_blank" rel="noopener">Bg-patterns：背景图下载</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iMWNjYTRhZTdlNDIzYzRjLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><ul><li><p><a href="https://cover.olook.me/" target="_blank" rel="noopener">网易云封面助手：封面下载</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi00NGU3MjdmNTNjMjdkNGUwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.pngall.com/thug-life-png" target="_blank" rel="noopener">PNG下载</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jY2MwZWVmNjhlYWY3Mzg2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h3><ul><li><p><a href="https://www.ls.graphics/meshgradients" target="_blank" rel="noopener">Free Mesh Gradient Collection：渐变图</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05YjgxZDM4YjYyZWM5OWRiLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://duotone.shapefactory.co/?f=f56468&amp;t=27184f&amp;q=_" target="_blank" rel="noopener">Duotone：双色</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi00NzM3ZmEzYWMyZGE5ZmMyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://photomosh.com/" target="_blank" rel="noopener">Photomosh：在线效果</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01ZTE3NTU1MGNkMzg0NjZkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://petalica-paint.pixiv.dev/index_zh.html" target="_blank" rel="noopener">自动上色</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05YmQyM2EwNjQ1NDEyYWY5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://experiments.withgoogle.com/autodraw" target="_blank" rel="noopener">简笔画</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01MmJiOTYwNzg0OWJkMjg0LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://watereffect.net/" target="_blank" rel="noopener">水效果处理</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iMTlkMjMwNDI0MjJkNmY3LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.remove.bg/zh" target="_blank" rel="noopener">在线抠图</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227142203515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><a href="https://www.yasuotu.com/" target="_blank" rel="noopener">图片在线压缩</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227142956542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="二维码制作"><a href="#二维码制作" class="headerlink" title="二维码制作"></a>二维码制作</h3></li><li><p><a href="https://cli.im/" target="_blank" rel="noopener">草料二维码</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227143036991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><h3 id="视频制作"><a href="#视频制作" class="headerlink" title="视频制作"></a>视频制作</h3><ul><li><a href="https://2zimu.com/#/" target="_blank" rel="noopener">突字幕：在线加字幕</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04ZGQwNWY4MjVkM2QzYjdjLnBuZw?x-oss-process=image/format,png" alt="image.png"></li><li><a href="https://panzoid.com/" target="_blank" rel="noopener">Panzoid：在线片头制作</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/2020022714195340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h1><h3 id="在线音乐制作"><a href="#在线音乐制作" class="headerlink" title="在线音乐制作"></a>在线音乐制作</h3><ul><li><p><a href="https://learningmusic.ableton.com/" target="_blank" rel="noopener">Get started making music</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kMWY3OGZkMDVjMDhlNWU2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://bongo.cat/" target="_blank" rel="noopener">Bongo Cat：音乐猫</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jNjYxYTE2ODJlYjQ5MmM5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.madeon.fr/adventuremachine/?t=1,10,26,35" target="_blank" rel="noopener">Madeon：音乐制作</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zMjQ1YzNhZGVjMjQ4MjY4LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.autopiano.cn/" target="_blank" rel="noopener">自由钢琴</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1mMmE4OGZiNmY5NzhhNjMwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="音频处理"><a href="#音频处理" class="headerlink" title="音频处理"></a>音频处理</h3><ul><li><p><a href="https://melody.ml/" target="_blank" rel="noopener">音乐分轨：AI伴奏人声分离</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1hMzEwMmJlNzEwODdhZWVmLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://asoftmurmur.com/" target="_blank" rel="noopener">背景音合成器</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02YTI2Mjg5MWUzN2U0ZTY2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h3><ul><li><a href="http://listen1.github.io/listen1/" target="_blank" rel="noopener">listen1：多平台集成检索</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0xNThmM2VjOGFlZDA3MGU0LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul><li><a href="https://sonniss.com/" target="_blank" rel="noopener">免费游戏音效下载</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kMmRjMDdkMTA5NjVlODM2LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h1><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><ul><li><p><a href="https://taiko.bui.pm/" target="_blank" rel="noopener">太鼓达人</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zYmRiNmRhMjBkNTRlYmVjLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://nazo.one-story.cn/" target="_blank" rel="noopener">Nazo Game：解谜</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jMGM3ODE0OTZmYjM2ODFhLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://cavalierchallenge.com/" target="_blank" rel="noopener">Cavalier：在线游戏</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0yYjllOTllNjNiNTI1MGMyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://nexus.leagueoflegends.com/en-us/" target="_blank" rel="noopener">Nexus</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04MTI5ZDZiYzU4ODRiODNjLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://pos.biborg.com/fr/" target="_blank" rel="noopener">POS</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi00Njk0YzkxYWMzNDE3OGI5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ul><li><p><a href="http://www.shushubuyue.net/#" target="_blank" rel="noopener">叔叔不约：匿名聊天</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02OGUzOTNiZTYxNWU5ZDViLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://touchpianist.com/" target="_blank" rel="noopener">Touch Pianist</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04Y2RjYTNjMGFhYTJmMWE2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h1 id="参观"><a href="#参观" class="headerlink" title="参观"></a>参观</h1><h3 id="会议"><a href="#会议" class="headerlink" title="会议"></a>会议</h3><ul><li><a href="http://www.eshow365.com/" target="_blank" rel="noopener">E展网：获取各种博览会参观信息</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1lMWQ2YTJhMTc1OTg1NTExLnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h1><h3 id="实体餐品"><a href="#实体餐品" class="headerlink" title="实体餐品"></a>实体餐品</h3><ul><li><p><a href="https://www.dxomark.com/" target="_blank" rel="noopener">Dxomark：摄影产品</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03ZjA5NTEwYzg1ZjNjNzZkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://sf.taobao.com/?spm=a213w.7398504.sfhead2014.2.9vuB5l&amp;current=index" target="_blank" rel="noopener">司法拍卖</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04OGRiNzZhY2UyYWMyZWEyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://auction.jd.com/haiguan.html" target="_blank" rel="noopener">京东拍卖</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0wMmYxMmE5MTNlZWYxZDk1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><ul><li><a href="http://adobe.v404.cn/adobe/" target="_blank" rel="noopener">Adobe全套</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1hZmI5MzAwMGFjZjBjMDg3LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="趣味"><a href="#趣味" class="headerlink" title="趣味"></a>趣味</h1><h3 id="有趣"><a href="#有趣" class="headerlink" title="有趣"></a>有趣</h3><ul><li><p><a href="http://www.bigpixel.cn/index.html" target="_blank" rel="noopener">大像素：千亿像素看中国各地全景图</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0yYWZlZDE2ZTRlYWM4ZjNkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://artbreeder.com/" target="_blank" rel="noopener">AI融合</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05NWI0ODU0OWZkZGI2Zjk2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://humanbenchmark.com/" target="_blank" rel="noopener">人类测试</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kZjMzNDE5Njc2ZTk4MzE2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://userinyerface.com/game.html" target="_blank" rel="noopener">反人类UI</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iYjU0OWY3ZTVkMDQ0M2M5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://neave.com/" target="_blank" rel="noopener">Neave Interactive：在线有趣的应用</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04N2IxM2MyOTVjZjYzNzY0LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://timelineofearth.com/" target="_blank" rel="noopener">地球时间</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02Mzc0M2Y3MzM2YTI5Y2U3LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://zh.forvo.com/user/hikari1/pronounced-words/page-2/" target="_blank" rel="noopener">学说话</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05YWY1NjliMTBkODJhOTg0LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.ro.me/" target="_blank" rel="noopener">RoMe</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03OTA2MTZiNGE4Zjc5MTFkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://burymewithmymoney.com/" target="_blank" rel="noopener">bury me with my money</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03MTM0MmI2MDlhYzBjNDkzLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="神秘"><a href="#神秘" class="headerlink" title="神秘"></a>神秘</h3><ul><li><a href="https://resn.co.nz/#" target="_blank" rel="noopener">Resn：首次加载较慢</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kMzgxZGFiMDY4MzZlM2VhLnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h1><ul><li><a href="https://www.wuxiaworld.com/" target="_blank" rel="noopener">武侠世界</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zZTgxMzUxNDA4NmQ4YmNjLnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Share </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/helloworld.html"/>
      <url>/posts/helloworld.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
