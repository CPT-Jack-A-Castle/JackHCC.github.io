<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python实战：小道具小功能实现</title>
      <link href="/posts/blog-python12.html"/>
      <url>/posts/blog-python12.html</url>
      
        <content type="html"><![CDATA[<h5 id="文末有所有项目的源码地址，可供参考："><a href="#文末有所有项目的源码地址，可供参考：" class="headerlink" title="文末有所有项目的源码地址，可供参考："></a>文末有所有项目的源码地址，可供参考：</h5><h3 id="Image-Edit"><a href="#Image-Edit" class="headerlink" title="Image-Edit"></a>Image-Edit</h3><h5 id="几个基本的图片编辑工具，包括一下功能："><a href="#几个基本的图片编辑工具，包括一下功能：" class="headerlink" title="几个基本的图片编辑工具，包括一下功能："></a>几个基本的图片编辑工具，包括一下功能：</h5><ul><li>文件：打开，保存，退出</li><li>编辑：放大，缩小，灰度，亮度，旋转，截图</li><li>变换：傅里叶变换，离散余弦变换，Radon变换</li><li>噪声：高斯，椒盐，斑点，泊松</li><li>滤波：高通，低通，平滑，锐化</li><li>直方图统计：R直方图，G直方图，B直方图</li><li>图像增强：伪彩色，真彩色，直方图均衡，NTSC颜色模型，YCbCr颜色模型，HSV颜色模型</li><li>阈值分割</li><li>生态学处理</li><li>特征提取</li><li>图像分类与识别</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-dd904df9db6b4a24?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库文件需要"><a href="#库文件需要" class="headerlink" title="库文件需要"></a>库文件需要</h5><pre><code> 1. PyQt5 2. sys 3. os 4. opencv2 5. numpy 6. scipy 7. matplotlib</code></pre><h3 id="Beautify-Camera"><a href="#Beautify-Camera" class="headerlink" title="Beautify-Camera"></a>Beautify-Camera</h3><h5 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>文件：打开，保存，打开摄像头</li><li>操作：还原，人脸识别</li><li>滤镜：怀旧，木刻，灰色，彩色，风格化，增强细节</li><li>调节：亮度，饱和度，伽马变换，边缘保持</li><li>磨皮美白：美白度，磨皮程度，磨皮精度</li><li>灰度直方图</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-08e784fc5ae40737?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库文件需要-1"><a href="#库文件需要-1" class="headerlink" title="库文件需要"></a>库文件需要</h5><pre><code> 1. PyQt5 2. sys 3. opencv2 4. numpy 5. matplotlib</code></pre><h5 id="相关代码说明"><a href="#相关代码说明" class="headerlink" title="相关代码说明"></a>相关代码说明</h5><ul><li><p>人脸识别</p><pre><code># 人脸识别  def detect_face(self):      img = self.raw_image      face_cascade = cv2.CascadeClassifier('./haarcascade_frontalface_default.xml')      gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)      faces = face_cascade.detectMultiScale(gray, 1.3, 5)      return faces</code></pre></li><li><p>皮肤识别</p><pre><code># 皮肤识别  def detect_skin(self):      img = self.raw_image      rows, cols, channals = img.shape      for r in range(rows):          for c in range(cols):              B = img.item(r, c, 0)              G = img.item(r, c, 1)              R = img.item(r, c, 2)              if (abs(R - G) &gt; 15) and (R &gt; G) and (R &gt; B):                  if (R &gt; 95) and (G &gt; 40) and (B &gt; 20) and (max(R, G, B) - min(R, G, B) &gt; 15):                      self.imgskin[r, c] = (1, 1, 1)                  elif (R &gt; 220) and (G &gt; 210) and (B &gt; 170):                      self.imgskin[r, c] = (1, 1, 1)</code></pre></li><li><p>其他不做详解</p></li></ul><h3 id="Calculator"><a href="#Calculator" class="headerlink" title="Calculator"></a>Calculator</h3><h5 id="主要功能-1"><a href="#主要功能-1" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>基本的加减乘除和开根号等运算</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f9b852ac6c40ef25?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库文件需求"><a href="#库文件需求" class="headerlink" title="库文件需求"></a>库文件需求</h5><pre><code>1.math2.tkinter</code></pre><h3 id="pyQt5-Calculator"><a href="#pyQt5-Calculator" class="headerlink" title="pyQt5-Calculator"></a>pyQt5-Calculator</h3><h5 id="主要功能-2"><a href="#主要功能-2" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>基本的加减乘除和开根号等运算</li></ul><p>1.calculator.py</p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-08132a3099f58ccd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><p>2.Calculator_.py</p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-3b052cc5951cb1f3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库文件需求-1"><a href="#库文件需求-1" class="headerlink" title="库文件需求"></a>库文件需求</h5><pre><code>1.PyQt52.sys3.math</code></pre><h3 id="Painting绘画"><a href="#Painting绘画" class="headerlink" title="Painting绘画"></a>Painting绘画</h3><h5 id="主要功能-3"><a href="#主要功能-3" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>File：新建画板，打开图片，保存图片</li><li>Edit：复制，清空画板</li><li>Image：翻转</li><li>工具：基本画笔，橡皮擦，图形创建工具等</li><li>编辑区，色彩调节区，字体调节区等</li></ul><h5 id="库文件需求-2"><a href="#库文件需求-2" class="headerlink" title="库文件需求"></a>库文件需求</h5><pre><code>1.PyQt52.random3.type4.os</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-94153ceb969517fd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h3 id="NotePad"><a href="#NotePad" class="headerlink" title="NotePad"></a>NotePad</h3><h5 id="主要功能-4"><a href="#主要功能-4" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>基本文本编辑，类似于记事本</li></ul><h5 id="库文件需求-3"><a href="#库文件需求-3" class="headerlink" title="库文件需求"></a>库文件需求</h5><pre><code>1.pyQt52.sys3.os</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-054412aceafbc63f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h3 id="RandomPassWord"><a href="#RandomPassWord" class="headerlink" title="RandomPassWord"></a>RandomPassWord</h3><h5 id="主要功能-5"><a href="#主要功能-5" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>随机生成一串密码，包括大小写字母，数字，符号，可指定长度</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f815c1dd28390162.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库文件引入"><a href="#库文件引入" class="headerlink" title="库文件引入"></a>库文件引入</h5><pre><code>1.secrets2.pyQt53.sys</code></pre><h3 id="Browser"><a href="#Browser" class="headerlink" title="Browser"></a>Browser</h3><h5 id="主要功能-6"><a href="#主要功能-6" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>基本浏览器功能</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-c4addcf72cd0bbd3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库函数需求"><a href="#库函数需求" class="headerlink" title="库函数需求"></a>库函数需求</h5><pre><code>1.pyQt52.os3.sys</code></pre><h3 id="MusicPlayer"><a href="#MusicPlayer" class="headerlink" title="MusicPlayer"></a>MusicPlayer</h3><h5 id="主要功能-7"><a href="#主要功能-7" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>音乐播放器</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-630c03ab25054cbb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库函数引用"><a href="#库函数引用" class="headerlink" title="库函数引用"></a>库函数引用</h5><pre><code>1.os2.sys3.time4.pyQt5</code></pre><h3 id="PyTunes"><a href="#PyTunes" class="headerlink" title="PyTunes"></a>PyTunes</h3><h5 id="主要功能-8"><a href="#主要功能-8" class="headerlink" title="主要功能"></a>主要功能</h5><ul><li>轻量级音乐播放器</li></ul><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-33d57b3fd6ebd253.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h5 id="库函数引用-1"><a href="#库函数引用-1" class="headerlink" title="库函数引用"></a>库函数引用</h5><pre><code>1.sys2.pyQt5</code></pre><p><strong>源码地址：</strong><a href="https://github.com/JackHCC/Mini-Tools" target="_blank" rel="noopener">https://github.com/JackHCC/Mini-Tools</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-机器学习模块PyTorch</title>
      <link href="/posts/blog-python11.html"/>
      <url>/posts/blog-python11.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/JackHCC/API-for-PyTorch" target="_blank" rel="noopener">点击访问：PyTorch中文API应用具体代码地址</a></p><h1 id="自动求导机制"><a href="#自动求导机制" class="headerlink" title="自动求导机制"></a>自动求导机制</h1><p>本说明将概述Autograd如何工作并记录操作。了解这些并不是绝对必要的，但我们建议您熟悉它，因为它将帮助您编写更高效，更简洁的程序，并可帮助您进行调试。</p><h2 id="从后向中排除子图"><a href="#从后向中排除子图" class="headerlink" title="从后向中排除子图"></a>从后向中排除子图</h2><p>每个变量都有两个标志：<code>requires_grad</code>和<code>volatile</code>。它们都允许从梯度计算中精细地排除子图，并可以提高效率。</p><h3 id="requires-grad"><a href="#requires-grad" class="headerlink" title="requires_grad"></a><code>requires_grad</code></h3><p>如果有一个单一的输入操作需要梯度，它的输出也需要梯度。相反，只有所有输入都不需要梯度，输出才不需要。如果其中所有的变量都不需要梯度进行，后向计算不会在子图中执行。</p><pre><code>&gt;&gt;&gt; x = Variable(torch.randn(5, 5))&gt;&gt;&gt; y = Variable(torch.randn(5, 5))&gt;&gt;&gt; z = Variable(torch.randn(5, 5), requires_grad=True)&gt;&gt;&gt; a = x + y&gt;&gt;&gt; a.requires_gradFalse&gt;&gt;&gt; b = a + z&gt;&gt;&gt; b.requires_gradTrue</code></pre><p>这个标志特别有用，当您想要冻结部分模型时，或者您事先知道不会使用某些参数的梯度。例如，如果要对预先训练的CNN进行优化，只要切换冻结模型中的<code>requires_grad</code>标志就足够了，直到计算到最后一层才会保存中间缓冲区，其中的仿射变换将使用需要梯度的权重并且网络的输出也将需要它们。</p><pre><code>model = torchvision.models.resnet18(pretrained=True)for param in model.parameters():    param.requires_grad = False# Replace the last fully-connected layer# Parameters of newly constructed modules have requires_grad=True by defaultmodel.fc = nn.Linear(512, 100)# Optimize only the classifieroptimizer = optim.SGD(model.fc.parameters(), lr=1e-2, momentum=0.9)</code></pre><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h3><p>纯粹的inference模式下推荐使用<code>volatile</code>，当你确定你甚至不会调用<code>.backward()</code>时。它比任何其他自动求导的设置更有效——它将使用绝对最小的内存来评估模型。<code>volatile</code>也决定了<code>require_grad is False</code>。</p><p><code>volatile</code>不同于<code>require_grad</code>的传递。如果一个操作甚至只有有一个<code>volatile</code>的输入，它的输出也将是<code>volatile</code>。<code>Volatility</code>比“不需要梯度”更容易传递——只需要一个<code>volatile</code>的输入即可得到一个<code>volatile</code>的输出，相对的，需要所有的输入“不需要梯度”才能得到不需要梯度的输出。使用volatile标志，您不需要更改模型参数的任何设置来用于inference。创建一个<code>volatile</code>的输入就够了，这将保证不会保存中间状态。</p><pre><code>&gt;&gt;&gt; regular_input = Variable(torch.randn(5, 5))&gt;&gt;&gt; volatile_input = Variable(torch.randn(5, 5), volatile=True)&gt;&gt;&gt; model = torchvision.models.resnet18(pretrained=True)&gt;&gt;&gt; model(regular_input).requires_gradTrue&gt;&gt;&gt; model(volatile_input).requires_gradFalse&gt;&gt;&gt; model(volatile_input).volatileTrue&gt;&gt;&gt; model(volatile_input).creator is NoneTrue</code></pre><h2 id="自动求导如何编码历史信息"><a href="#自动求导如何编码历史信息" class="headerlink" title="自动求导如何编码历史信息"></a>自动求导如何编码历史信息</h2><p>每个变量都有一个<code>.creator</code>属性，它指向把它作为输出的函数。这是一个由<code>Function</code>对象作为节点组成的有向无环图（DAG）的入口点，它们之间的引用就是图的边。每次执行一个操作时，一个表示它的新<code>Function</code>就被实例化，它的<code>forward()</code>方法被调用，并且它输出的<code>Variable</code>的创建者被设置为这个<code>Function</code>。然后，通过跟踪从任何变量到叶节点的路径，可以重建创建数据的操作序列，并自动计算梯度。</p><p>需要注意的一点是，整个图在每次迭代时都是从头开始重新创建的，这就允许使用任意的Python控制流语句，这样可以在每次迭代时改变图的整体形状和大小。在启动训练之前不必对所有可能的路径进行编码—— what you run is what you differentiate.</p><h2 id="Variable上的In-place操作"><a href="#Variable上的In-place操作" class="headerlink" title="Variable上的In-place操作"></a>Variable上的In-place操作</h2><p>在自动求导中支持in-place操作是一件很困难的事情，我们在大多数情况下都不鼓励使用它们。Autograd的缓冲区释放和重用非常高效，并且很少场合下in-place操作能实际上明显降低内存的使用量。除非您在内存压力很大的情况下，否则您可能永远不需要使用它们。</p><p>限制in-place操作适用性主要有两个原因：</p><p>１．覆盖梯度计算所需的值。这就是为什么变量不支持<code>log_</code>。它的梯度公式需要原始输入，而虽然通过计算反向操作可以重新创建它，但在数值上是不稳定的，并且需要额外的工作，这往往会与使用这些功能的目的相悖。</p><p>２．每个in-place操作实际上需要实现重写计算图。不合适的版本只需分配新对象并保留对旧图的引用，而in-place操作则需要将所有输入的<code>creator</code>更改为表示此操作的<code>Function</code>。这就比较棘手，特别是如果有许多变量引用相同的存储（例如通过索引或转置创建的），并且如果被修改输入的存储被任何其他<code>Variable</code>引用，则in-place函数实际上会抛出错误。</p><h2 id="In-place正确性检查"><a href="#In-place正确性检查" class="headerlink" title="In-place正确性检查"></a>In-place正确性检查</h2><p>每个变量保留有version counter，它每次都会递增，当在任何操作中被使用时。当<code>Function</code>保存任何用于后向的tensor时，还会保存其包含变量的version counter。一旦访问<code>self.saved_tensors</code>，它将被检查，如果它大于保存的值，则会引起错误。</p><h1 id="CUDA语义"><a href="#CUDA语义" class="headerlink" title="CUDA语义"></a>CUDA语义</h1><p><code>torch.cuda</code>会记录当前选择的GPU，并且分配的所有CUDA张量将在上面创建。可以使用<code>torch.cuda.device</code>上下文管理器更改所选设备。</p><p>但是，一旦张量被分配，您可以直接对其进行操作，而不考虑所选择的设备，结果将始终放在与张量相同的设备上。</p><p>默认情况下，不支持跨GPU操作，唯一的例外是<code>copy_()</code>。 除非启用对等存储器访问，否则对分布不同设备上的张量任何启动操作的尝试都将会引发错误。</p><p>下面你可以找到一个展示如下的小例子：</p><pre><code>x = torch.cuda.FloatTensor(1)# x.get_device() == 0y = torch.FloatTensor(1).cuda()# y.get_device() == 0with torch.cuda.device(1):    # allocates a tensor on GPU 1    a = torch.cuda.FloatTensor(1)    # transfers a tensor from CPU to GPU 1    b = torch.FloatTensor(1).cuda()    # a.get_device() == b.get_device() == 1    c = a + b    # c.get_device() == 1    z = x + y    # z.get_device() == 0    # even within a context, you can give a GPU id to the .cuda call    d = torch.randn(2).cuda(2)    # d.get_device() == 2</code></pre><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="使用固定的内存缓冲区"><a href="#使用固定的内存缓冲区" class="headerlink" title="使用固定的内存缓冲区"></a>使用固定的内存缓冲区</h3><p>当副本来自固定（页锁）内存时，主机到GPU的复制速度要快很多。CPU张量和存储开放了一个<code>pin_memory()</code>方法，它返回该对象的副本，而它的数据放在固定区域中。</p><p>另外，一旦固定了张量或存储，就可以使用异步的GPU副本。只需传递一个额外的<code>async=True</code>参数到<code>cuda()</code>的调用。这可以用于将数据传输与计算重叠。</p><p>通过将<code>pin_memory=True</code>传递给其构造函数，可以使<code>DataLoader</code>将batch返回到固定内存中。</p><h3 id="使用-nn-DataParallel-替代-multiprocessing"><a href="#使用-nn-DataParallel-替代-multiprocessing" class="headerlink" title="使用 nn.DataParallel 替代 multiprocessing"></a>使用 nn.DataParallel 替代 multiprocessing</h3><p>大多数涉及批量输入和多个GPU的情况应默认使用<code>DataParallel</code>来使用多个GPU。尽管有GIL的存在，单个python进程也可能使多个GPU饱和。</p><p>从0.1.9版本开始，大量的GPU(8+)可能未被充分利用。然而，这是一个已知的问题，也正在积极开发。和往常一样，测试你的用例吧。</p><p>调用<code>multiprocessing</code>来利用CUDA模型存在重要的注意事项；使用具有多处理功能的CUDA模型有重要的注意事项; 除非就是需要谨慎地满足数据处理需求，否则您的程序很可能会出现错误或未定义的行为。</p><h1 id="扩展PyTorch"><a href="#扩展PyTorch" class="headerlink" title="扩展PyTorch"></a>扩展PyTorch</h1><h2 id="扩展-torch-autograd"><a href="#扩展-torch-autograd" class="headerlink" title="扩展 torch.autograd"></a>扩展 torch.autograd</h2><p>如果你想要添加一个新的 <code>Operation</code> 到<code>autograd</code>的话，你的<code>Operation</code>需要继承 <code>class Function</code>。<code>autograd</code>使用<code>Function</code>计算结果和梯度，同时编码 <code>operation</code>的历史。每个新的 <code>operation(function)</code> 都需要实现三个方法：</p><ul><li><p><code>__init__ (optional)</code> - 如果你的<code>operation</code>包含非<code>Variable</code>参数，那么就将其作为<code>__init__</code>的参数传入到<code>operation</code>中。例如：<code>AddConstant Function</code>加一个常数，<code>Transpose Function</code>需要指定哪两个维度需要交换。如果你的<code>operation</code>不需要额外的参数，你可以忽略<code>__init__</code>。</p></li><li><p><code>forward()</code> - 在里面写执行此<code>operation</code>的代码。可以有任意数量的参数。如果你对某些参数指定了默认值，则这些参数是可传可不传的。记住：<code>forward()</code>的参数只能是<code>Variable</code>。函数的返回值既可以是 <code>Variable</code>也可以是<code>Variables</code>的<code>tuple</code>。同时，请参考 <code>Function</code>[function]的 <code>doc</code>，查阅有哪些 方法是只能在<code>forward</code>中调用的。</p></li><li><p><code>backward()</code> - 梯度计算公式。 参数的个数和<code>forward</code>返回值的个数一样，每个参数代表传回到此<code>operation</code>的梯度. <code>backward()</code>的返回值的个数应该和此<code>operation</code>输入的个数一样，每个返回值对应了输入值的梯度。如果<code>operation</code>的输入不需要梯度，或者不可导，你可以返回<code>None</code>。 如果<code>forward()</code>存在可选参数，你可以返回比输入更多的梯度，只是返回的是<code>None</code>。</p></li></ul><p>下面是 <code>Linear</code> 的实现代码：</p><pre><code># Inherit from Functionclass Linear(Function):    # bias is an optional argument    def forward(self, input, weight, bias=None):        self.save_for_backward(input, weight, bias)        output = input.mm(weight.t())        if bias is not None:            output += bias.unsqueeze(0).expand_as(output)        return output    # This function has only a single output, so it gets only one gradient    def backward(self, grad_output):        # This is a pattern that is very convenient - at the top of backward        # unpack saved_tensors and initialize all gradients w.r.t. inputs to        # None. Thanks to the fact that additional trailing Nones are        # ignored, the return statement is simple even when the function has        # optional inputs.        input, weight, bias = self.saved_tensors        grad_input = grad_weight = grad_bias = None        # These needs_input_grad checks are optional and there only to        # improve efficiency. If you want to make your code simpler, you can        # skip them. Returning gradients for inputs that don't require it is        # not an error.        if self.needs_input_grad[0]:            grad_input = grad_output.mm(weight)        if self.needs_input_grad[1]:            grad_weight = grad_output.t().mm(input)        if bias is not None and self.needs_input_grad[2]:            grad_bias = grad_output.sum(0).squeeze(0)        return grad_input, grad_weight, grad_bias</code></pre><p>现在，为了可以更简单的使用自定义的<code>operation</code>，我们建议将其用一个简单的 <code>helper function</code> 包装起来。 functions:</p><pre><code>def linear(input, weight, bias=None):    # First braces create a Function object. Any arguments given here    # will be passed to __init__. Second braces will invoke the __call__    # operator, that will then use forward() to compute the result and    # return it.    return Linear()(input, weight, bias)</code></pre><p>你可能想知道你刚刚实现的 <code>backward</code>方法是否正确的计算了梯度。你可以使用 小的有限的差分进行数值估计。</p><pre><code>from torch.autograd import gradcheck# gradchek takes a tuple of tensor as input, check if your gradient# evaluated with these tensors are close enough to numerical# approximations and returns True if they all verify this condition.input = (Variable(torch.randn(20,20).double(), requires_grad=True),)test = gradcheck.gradcheck(Linear(), input, eps=1e-6, atol=1e-4)print(test)</code></pre><h2 id="扩展-torch-nn"><a href="#扩展-torch-nn" class="headerlink" title="扩展 torch.nn"></a>扩展 torch.nn</h2><p><code>nn</code> 包含两种接口 - <code>modules</code>和他们的<code>functional</code>版本。通过这两个接口，你都可以扩展<code>nn</code>。但是我们建议，在扩展<code>layer</code>的时候，使用<code>modules</code>， 因为<code>modules</code>保存着参数和<code>buffer</code>。如果不需要参数的话，那么建议使用<code>functional</code>(激活函数，pooling，这些都不需要参数)。</p><p>增加一个<code>operation</code>的 <code>functional</code>版本已经在上面一节介绍完毕。</p><p>增加一个模块(<code>module</code>)。 由于<code>nn</code>重度使用<code>autograd</code>。所以，添加一个新<code>module</code>需要实现一个 用来执行 计算 和 计算梯度 的<code>Function</code>。从现在开始，假定我们想要实现一个<code>Linear module</code>，记得之前我们已经实现了一个<code>Linear Funciton</code>。 只需要很少的代码就可以完成这个工作。 现在，我们需要实现两个方法：</p><ul><li><p><code>__init__ (optional)</code> - 输入参数，例如<code>kernel sizes</code>, <code>numbers of features</code>, 等等。同时初始化 <code>parameters</code>和<code>buffers</code>。</p></li><li><p><code>forward()</code> - 实例化一个执行<code>operation</code>的<code>Function</code>，使用它执行<code>operation</code>。和<code>functional wrapper(上面实现的那个简单的wrapper)</code>十分类似。</p></li></ul><p><code>Linear module</code>实现代码:</p><pre><code>class Linear(nn.Module):    def __init__(self, input_features, output_features, bias=True):        self.input_features = input_features        self.output_features = output_features        # nn.Parameter is a special kind of Variable, that will get        # automatically registered as Module's parameter once it's assigned        # as an attribute. Parameters and buffers need to be registered, or        # they won't appear in .parameters() (doesn't apply to buffers), and        # won't be converted when e.g. .cuda() is called. You can use        # .register_buffer() to register buffers.        # nn.Parameters can never be volatile and, different than Variables,        # they require gradients by default.        self.weight = nn.Parameter(torch.Tensor(input_features, output_features))        if bias:            self.bias = nn.Parameter(torch.Tensor(output_features))        else:            # You should always register all possible parameters, but the            # optional ones can be None if you want.            self.register_parameter('bias', None)        # Not a very smart way to initialize weights        self.weight.data.uniform_(-0.1, 0.1)        if bias is not None:            self.bias.data.uniform_(-0.1, 0.1)    def forward(self, input):        # See the autograd section for explanation of what happens here.        return Linear()(input, self.weight, self.bias)        #注意这个Linear是之前实现过的Linear</code></pre><h2 id="编写自定义C扩展"><a href="#编写自定义C扩展" class="headerlink" title="编写自定义C扩展"></a>编写自定义<code>C</code>扩展</h2><p>Coming soon. For now you can find an example at <a href="https://github.com/pytorch/extension-ffi" target="_blank" rel="noopener">GitHub</a>.</p><h1 id="多进程最佳实践"><a href="#多进程最佳实践" class="headerlink" title="多进程最佳实践"></a>多进程最佳实践</h1><p><code>torch.multiprocessing</code>是Python<code>multiprocessing</code>的替代品。它支持完全相同的操作，但扩展了它以便通过<code>multiprocessing.Queue</code>发送的所有张量将其数据移动到共享内存中，并且只会向其他进程发送一个句柄。</p><blockquote><p><strong>Note</strong></p><p>当<code>Variable</code>发送到另一个进程时，<code>Variable.data</code>和<code>Variable.grad.data</code>都将被共享。</p></blockquote><p>这允许实现各种训练方法，如Hogwild，A3C或需要异步操作的任何其他方法。</p><h2 id="共享CUDA张量"><a href="#共享CUDA张量" class="headerlink" title="共享CUDA张量"></a>共享CUDA张量</h2><p>仅在Python 3中使用<code>spawn</code>或<code>forkserver</code>启动方法才支持在进程之间共享CUDA张量。Python 2中的<code>multiprocessing</code>只能使用<code>fork</code>创建子进程，并且不被CUDA运行时所支持。</p><blockquote><p><strong>Warning</strong></p><p>CUDA API要求导出到其他进程的分配，只要它们被使用就要一直保持有效。您应该小心，确保您共享的CUDA张量只要有必要就不要超出范围。这不是共享模型参数的问题，但传递其他类型的数据应该小心。注意，此限制不适用于共享CPU内存。</p></blockquote><h2 id="最佳实践和提示"><a href="#最佳实践和提示" class="headerlink" title="最佳实践和提示"></a>最佳实践和提示</h2><h3 id="避免和抵制死锁"><a href="#避免和抵制死锁" class="headerlink" title="避免和抵制死锁"></a>避免和抵制死锁</h3><p>当一个新进程被产生时，有很多事情可能会出错，最常见的死锁原因是后台线程。如果有任何线程持有锁或导入模块，并且<code>fork</code>被调用，则子进程很可能处于损坏的状态，并以不同的方式死锁或失败。注意，即使您没有，Python内置的库也可能会这样做 —— 不需要看得比<code>multiprocessing</code>更远。<code>multiprocessing.Queue</code>实际上是一个非常复杂的类，它产生用于序列化，发送和接收对象的多个线程，它们也可能引起上述问题。如果您发现自己处于这种情况，请尝试使用<code>multiprocessing.queues.SimpleQueue</code>，这不会使用任何其他线程。</p><p>我们正在竭尽全力把它设计得更简单，并确保这些死锁不会发生，但有些事情无法控制。如果有任何问题您无法一时无法解决，请尝试在论坛上提出，我们将看看是否可以解决问题。</p><h3 id="重用经过队列的缓冲区"><a href="#重用经过队列的缓冲区" class="headerlink" title="重用经过队列的缓冲区"></a>重用经过队列的缓冲区</h3><p>记住每次将<code>Tensor</code>放入<code>multiprocessing.Queue</code>时，必须将其移动到共享内存中。如果它已经被共享，它是一个无效的操作，否则会产生一个额外的内存副本，这会减缓整个进程。即使你有一个进程池来发送数据到一个进程，使它返回缓冲区 —— 这几乎是免费的，并且允许你在发送下一个batch时避免产生副本。</p><h3 id="异步多进程训练（例如Hogwild）"><a href="#异步多进程训练（例如Hogwild）" class="headerlink" title="异步多进程训练（例如Hogwild）"></a>异步多进程训练（例如Hogwild）</h3><p>使用<code>torch.multiprocessing</code>，可以异步地训练模型，参数可以一直共享，也可以定期同步。在第一种情况下，我们建议发送整个模型对象，而在后者中，我们建议只发送<code>state_dict()</code>。</p><p>我们建议使用<code>multiprocessing.Queue</code>来在进程之间传递各种PyTorch对象。例如， 当使用fork启动方法时，可能会继承共享内存中的张量和存储器，但这是非常容易出错的，应谨慎使用，而且只能由高级用户使用。队列虽然有时是一个较不优雅的解决方案，但基本上能在所有情况下正常工作。</p><blockquote><p><strong>Warning</strong> 你应该注意有关全局语句，它们没有被<code>if __name__ == '__main__'</code>保护。如果使用与<code>fork</code>不同的启动方法，则它们将在所有子进程中执行。</p></blockquote><h4 id="Hogwild"><a href="#Hogwild" class="headerlink" title="Hogwild"></a>Hogwild</h4><p>在<a href="https://github.com/pytorch/examples/tree/master/mnist_hogwild" target="_blank" rel="noopener">examples repository</a>中可以找到具体的Hogwild实现，可以展示代码的整体结构。下面也有一个小例子：</p><pre><code>import torch.multiprocessing as mpfrom model import MyModeldef train(model):    # Construct data_loader, optimizer, etc.    for data, labels in data_loader:        optimizer.zero_grad()        loss_fn(model(data), labels).backward()        optimizer.step()  # This will update the shared parametersif __name__ == '__main__':    num_processes = 4    model = MyModel()    # NOTE: this is required for the ``fork`` method to work    model.share_memory()    processes = []    for rank in range(num_processes):        p = mp.Process(target=train, args=(model,))        p.start()        processes.append(p)    for p in processes:      p.join()</code></pre><h1 id="序列化语义"><a href="#序列化语义" class="headerlink" title="序列化语义"></a>序列化语义</h1><h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="保存模型的推荐方法"><a href="#保存模型的推荐方法" class="headerlink" title="保存模型的推荐方法"></a>保存模型的推荐方法</h3><p>这主要有两种方法序列化和恢复模型。</p><p>第一种（推荐）只保存和加载模型参数：</p><pre><code>torch.save(the_model.state_dict(), PATH)</code></pre><p>然后：</p><pre><code>the_model = TheModelClass(*args, **kwargs)the_model.load_state_dict(torch.load(PATH))</code></pre><p>第二种保存和加载整个模型：</p><pre><code>torch.save(the_model, PATH)</code></pre><p>然后：</p><pre><code>the_model = torch.load(PATH)</code></pre><p>然而，在这种情况下，序列化的数据被绑定到特定的类和固定的目录结构，所以当在其他项目中使用时，或者在一些严重的重构器之后它可能会以各种方式break。</p><h1 id="torch"><a href="#torch" class="headerlink" title="torch"></a>torch</h1><p>包 <code>torch</code> 包含了多维张量的数据结构以及基于其上的多种数学操作。另外，它也提供了多种工具，其中一些可以更有效地对张量和任意类型进行序列化。</p><p>它有CUDA 的对应实现，可以在NVIDIA GPU上进行张量运算(计算能力&gt;=2.0)。</p><h1 id="张量-Tensors"><a href="#张量-Tensors" class="headerlink" title="张量 Tensors"></a>张量 Tensors</h1><p><strong>torch.is_tensor</strong><a href="http://pytorch.org/docs/_modules/torch.html#is_tensor" target="_blank" rel="noopener">[source]</a></p><pre><code>torch.is_tensor(obj)</code></pre><p>如果<em>obj</em> 是一个pytorch张量，则返回True</p><ul><li>参数： obj (Object) – 判断对象</li></ul><hr><p><strong>torch.is_storage</strong> <a href="http://pytorch.org/docs/_modules/torch.html#is_storage" target="_blank" rel="noopener">[source]</a></p><pre><code>torch.is_storage(obj)</code></pre><p>如何<em>obj</em> 是一个pytorch storage对象，则返回True</p><ul><li>参数： input (Object) – 判断对象</li></ul><hr><p><strong>torch.</strong>set_default_tensor_type****<a href="http://pytorch.org/docs/_modules/torch.html#set_default_tensor_type" target="_blank" rel="noopener">[source]</a></p><pre><code>torch.set_default_tensor_type(t)</code></pre><hr><p><strong>torch.numel</strong></p><pre><code>torch.numel(input)-&gt;int</code></pre><p>返回<code>input</code> 张量中的元素个数</p><ul><li>参数: input (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener"><em>Tensor</em></a>) – 输入张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; a = torch.randn(1,2,3,4,5)&gt;&gt;&gt; torch.numel(a)120&gt;&gt;&gt; a = torch.zeros(4,4)&gt;&gt;&gt; torch.numel(a)16</code></pre><hr><p><strong>torch.set_printoptions</strong><a href="http://pytorch.org/docs/_modules/torch/_tensor_str.html#set_printoptions" target="_blank" rel="noopener">[source]</a></p><pre><code>torch.set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, profile=None)</code></pre><p>设置打印选项。 完全参考自<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.set_printoptions.html" target="_blank" rel="noopener"> Numpy</a>。</p><p>参数:</p><ul><li>precision – 浮点数输出的精度位数 (默认为8 )</li><li>threshold – 阈值，触发汇总显示而不是完全显示(repr)的数组元素的总数 （默认为1000）</li><li>edgeitems – 汇总显示中，每维（轴）两端显示的项数（默认值为3）</li><li>linewidth – 用于插入行间隔的每行字符数（默认为80）。Thresholded matricies will ignore this parameter.</li><li>profile – pretty打印的完全默认值。 可以覆盖上述所有选项 (默认为short, full)</li></ul><h2 id="创建操作-Creation-Ops"><a href="#创建操作-Creation-Ops" class="headerlink" title="创建操作 Creation Ops"></a>创建操作 Creation Ops</h2><p><strong>torch.eye</strong></p><pre><code>torch.eye(n, m=None, out=None)</code></pre><p>返回一个2维张量，对角线位置全1，其它位置全0</p><p>参数:</p><ul><li>n (<a href="https://docs.python.org/2/library/functions.html#int" target="_blank" rel="noopener">int</a> ) – 行数</li><li>m (<a href="https://docs.python.org/2/library/functions.html#int" target="_blank" rel="noopener">int</a>, <em>optional</em>) – 列数.如果为None,则默认为<em>n</em></li><li>out (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener"><em>Tensor</em></a>, <em>optinal</em>) - Output tensor</li></ul><p>返回值: 对角线位置全1，其它位置全0的2维张量</p><p>返回值类型: <a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener">Tensor</a></p><p>例子:</p><pre><code>&gt;&gt;&gt; torch.eye(3) 1  0  0 0  1  0 0  0  1[torch.FloatTensor of size 3x3]</code></pre><hr><p><strong>from_numpy</strong></p><pre><code>torch.from_numpy(ndarray) → Tensor</code></pre><p>Numpy桥，将<code>numpy.ndarray</code> 转换为pytorch的 <code>Tensor</code>。 返回的张量tensor和numpy的ndarray共享同一内存空间。修改一个会导致另外一个也被修改。返回的张量不能改变大小。</p><p>例子:</p><pre><code>&gt;&gt;&gt; a = numpy.array([1, 2, 3])&gt;&gt;&gt; t = torch.from_numpy(a)&gt;&gt;&gt; ttorch.LongTensor([1, 2, 3])&gt;&gt;&gt; t[0] = -1&gt;&gt;&gt; aarray([-1,  2,  3])</code></pre><p><strong>torch.linspace</strong></p><pre><code>torch.linspace(start, end, steps=100, out=None) → Tensor</code></pre><p>返回一个1维张量，包含在区间<code>start</code> 和 <code>end</code> 上均匀间隔的<code>steps</code>个点。 输出1维张量的长度为<code>steps</code>。</p><p>参数:</p><ul><li>start (float) – 序列的起始点</li><li>end (float) – 序列的最终值</li><li>steps (int) – 在<code>start</code> 和 <code>end</code>间生成的样本数</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; torch.linspace(3, 10, steps=5)  3.0000  4.7500  6.5000  8.2500 10.0000[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.linspace(-10, 10, steps=5)-10 -5  0  5 10[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.linspace(start=-10, end=10, steps=5)-10 -5  0  5 10[torch.FloatTensor of size 5]</code></pre><hr><p><strong>torch.logspace</strong></p><pre><code>torch.logspace(start, end, steps=100, out=None) → Tensor</code></pre><p>返回一个1维张量，包含在区间 10的start次方到10的end次方上以对数刻度均匀间隔的<code>steps</code>个点。 输出1维张量的长度为<code>steps</code>。</p><p>参数:</p><ul><li>start (float) – 序列的起始点</li><li>end (float) – 序列的最终值</li><li>steps (int) – 在<code>start</code> 和 <code>end</code>间生成的样本数</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; torch.logspace(start=-10, end=10, steps=5) 1.0000e-10 1.0000e-05 1.0000e+00 1.0000e+05 1.0000e+10[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.logspace(start=0.1, end=1.0, steps=5)  1.2589  2.1135  3.5481  5.9566 10.0000[torch.FloatTensor of size 5]</code></pre><p><strong>torch.ones</strong></p><pre><code>torch.ones(*sizes, out=None) → Tensor</code></pre><p>返回一个全为1 的张量，形状由可变参数<code>sizes</code>定义。</p><p>参数:</p><ul><li>sizes (int…) – 整数序列，定义了输出形状</li><li>out (Tensor, optional) – 结果张量 例子:</li></ul><pre><code>&gt;&gt;&gt; torch.ones(2, 3) 1  1  1 1  1  1[torch.FloatTensor of size 2x3]&gt;&gt;&gt; torch.ones(5) 1 1 1 1 1[torch.FloatTensor of size 5]</code></pre><hr><p><strong>torch.rand</strong></p><pre><code>torch.rand(*sizes, out=None) → Tensor</code></pre><p>返回一个张量，包含了从区间[0,1)的均匀分布中抽取的一组随机数，形状由可变参数<code>sizes</code> 定义。</p><p>参数:</p><ul><li>sizes (int…) – 整数序列，定义了输出形状</li><li>out (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener"><em>Tensor</em></a>, <em>optinal</em>) - 结果张量 例子：</li></ul><pre><code>&gt;&gt;&gt; torch.rand(4) 0.9193 0.3347 0.3232 0.7715[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.rand(2, 3) 0.5010  0.5140  0.0719 0.1435  0.5636  0.0538[torch.FloatTensor of size 2x3]</code></pre><hr><p><strong>torch.randn</strong></p><pre><code>torch.randn(*sizes, out=None) → Tensor</code></pre><p>返回一个张量，包含了从标准正态分布(均值为0，方差为 1，即高斯白噪声)中抽取一组随机数，形状由可变参数<code>sizes</code>定义。 参数:</p><ul><li>sizes (int…) – 整数序列，定义了输出形状</li><li>out (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener"><em>Tensor</em></a>, <em>optinal</em>) - 结果张量</li></ul><p>例子：:</p><pre><code>&gt;&gt;&gt; torch.randn(4)-0.1145 0.0094-1.1717 0.9846[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.randn(2, 3) 1.4339  0.3351 -1.0999 1.5458 -0.9643 -0.3558[torch.FloatTensor of size 2x3]</code></pre><hr><p><strong>torch.randperm</strong></p><pre><code>torch.randperm(n, out=None) → LongTensor</code></pre><p>给定参数<code>n</code>，返回一个从<code>0</code> 到<code>n -1</code> 的随机整数排列。</p><p>参数:</p><ul><li>n (int) – 上边界(不包含)</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.randperm(4) 2 1 3 0[torch.LongTensor of size 4]</code></pre><hr><p><strong>torch.arange</strong></p><pre><code>torch.arange(start, end, step=1, out=None) → Tensor</code></pre><p>参数:</p><ul><li>start (float) – 序列的起始点</li><li>end (float) – 序列的终止点</li><li>step (float) – 相邻点的间隔大小</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.arange(1, 4) 1 2 3[torch.FloatTensor of size 3]&gt;&gt;&gt; torch.arange(1, 2.5, 0.5) 1.0000 1.5000 2.0000[torch.FloatTensor of size 3]</code></pre><hr><p><strong>torch.range</strong></p><pre><code>torch.range(start, end, step=1, out=None) → Tensor</code></pre><p><strong>警告</strong>：建议使用函数 <code>torch.arange()</code></p><p>参数:</p><ul><li>start (float) – 序列的起始点</li><li>end (float) – 序列的最终值</li><li>step (int) – 相邻点的间隔大小</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.range(1, 4) 1 2 3 4[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.range(1, 4, 0.5) 1.0000 1.5000 2.0000 2.5000 3.0000 3.5000 4.0000[torch.FloatTensor of size 7]</code></pre><hr><p><strong>torch.zeros</strong></p><pre><code>torch.zeros(*sizes, out=None) → Tensor</code></pre><p>返回一个全为标量 0 的张量，形状由可变参数<code>sizes</code> 定义。</p><p>参数:</p><ul><li>sizes (int…) – 整数序列，定义了输出形状</li><li>out (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener">Tensor</a>, <em>optional</em>) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.zeros(2, 3) 0  0  0 0  0  0[torch.FloatTensor of size 2x3]&gt;&gt;&gt; torch.zeros(5) 0 0 0 0 0[torch.FloatTensor of size 5]</code></pre><hr><h2 id="索引-切片-连接-换位Indexing-Slicing-Joining-Mutating-Ops"><a href="#索引-切片-连接-换位Indexing-Slicing-Joining-Mutating-Ops" class="headerlink" title="索引,切片,连接,换位Indexing, Slicing, Joining, Mutating Ops"></a>索引,切片,连接,换位Indexing, Slicing, Joining, Mutating Ops</h2><h3 id="torch-cat"><a href="#torch-cat" class="headerlink" title="torch.cat"></a>torch.cat</h3><pre><code>torch.cat(inputs, dimension=0) → Tensor</code></pre><p>在给定维度上对输入的张量序列<code>seq</code> 进行连接操作。</p><p><code>torch.cat()</code>可以看做 <code>torch.split()</code> 和 <code>torch.chunk()</code>的反操作。 <code>cat()</code> 函数可以通过下面例子更好的理解。</p><p>参数:</p><ul><li>inputs (<em>sequence of Tensors</em>) – 可以是任意相同Tensor 类型的python 序列</li><li>dimension (<em>int</em>, <em>optional</em>) – 沿着此维连接张量序列。</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.randn(2, 3)&gt;&gt;&gt; x 0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735[torch.FloatTensor of size 2x3]&gt;&gt;&gt; torch.cat((x, x, x), 0) 0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735 0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735 0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735[torch.FloatTensor of size 6x3]&gt;&gt;&gt; torch.cat((x, x, x), 1) 0.5983 -0.0341  2.4918  0.5983 -0.0341  2.4918  0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735  1.5981 -0.5265 -0.8735  1.5981 -0.5265 -0.8735[torch.FloatTensor of size 2x9]</code></pre><h3 id="torch-chunk"><a href="#torch-chunk" class="headerlink" title="torch.chunk"></a>torch.chunk</h3><pre><code>torch.chunk(tensor, chunks, dim=0)</code></pre><p>在给定维度(轴)上将输入张量进行分块儿。</p><p>参数:</p><ul><li>tensor (Tensor) – 待分块的输入张量</li><li>chunks (int) – 分块的个数</li><li>dim (int) – 沿着此维度进行分块</li></ul><h3 id="torch-gather"><a href="#torch-gather" class="headerlink" title="torch.gather"></a>torch.gather</h3><pre><code>torch.gather(input, dim, index, out=None) → Tensor</code></pre><p>沿给定轴<code>dim</code>，将输入索引张量<code>index</code>指定位置的值进行聚合。</p><p>对一个3维张量，输出可以定义为：</p><pre><code>out[i][j][k] = tensor[index[i][j][k]][j][k]  # dim=0out[i][j][k] = tensor[i][index[i][j][k]][k]  # dim=1out[i][j][k] = tensor[i][j][index[i][j][k]]  # dim=3</code></pre><p>例子：</p><pre><code>&gt;&gt;&gt; t = torch.Tensor([[1,2],[3,4]])&gt;&gt;&gt; torch.gather(t, 1, torch.LongTensor([[0,0],[1,0]])) 1  1 4  3[torch.FloatTensor of size 2x2]</code></pre><p>参数:</p><ul><li>input (Tensor) – 源张量</li><li>dim (int) – 索引的轴</li><li>index (LongTensor) – 聚合元素的下标</li><li>out (Tensor, optional) – 目标张量</li></ul><h3 id="torch-index-select"><a href="#torch-index-select" class="headerlink" title="torch.index_select"></a>torch.index_select</h3><pre><code>torch.index_select(input, dim, index, out=None) → Tensor</code></pre><p>沿着指定维度对输入进行切片，取<code>index</code>中指定的相应项(<code>index</code>为一个LongTensor)，然后返回到一个新的张量， 返回的张量与原始张量_Tensor_有相同的维度(在指定轴上)。</p><p>注意： 返回的张量不与原始张量共享内存空间。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 索引的轴</li><li>index (LongTensor) – 包含索引下标的一维张量</li><li>out (Tensor, optional) – 目标张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.randn(3, 4)&gt;&gt;&gt; x 1.2045  2.4084  0.4001  1.1372 0.5596  1.5677  0.6219 -0.7954 1.3635 -1.2313 -0.5414 -1.8478[torch.FloatTensor of size 3x4]&gt;&gt;&gt; indices = torch.LongTensor([0, 2])&gt;&gt;&gt; torch.index_select(x, 0, indices) 1.2045  2.4084  0.4001  1.1372 1.3635 -1.2313 -0.5414 -1.8478[torch.FloatTensor of size 2x4]&gt;&gt;&gt; torch.index_select(x, 1, indices) 1.2045  0.4001 0.5596  0.6219 1.3635 -0.5414[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-masked-select"><a href="#torch-masked-select" class="headerlink" title="torch.masked_select"></a>torch.masked_select</h3><pre><code>torch.masked_select(input, mask, out=None) → Tensor</code></pre><p>根据掩码张量<code>mask</code>中的二元值，取输入张量中的指定项( <code>mask</code>为一个 <em>ByteTensor</em>)，将取值返回到一个新的1D张量，</p><p>张量 <code>mask</code>须跟<code>input</code>张量有相同数量的元素数目，但形状或维度不需要相同。 注意： 返回的张量不与原始张量共享内存空间。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>mask (ByteTensor) – 掩码张量，包含了二元索引值</li><li>out (Tensor, optional) – 目标张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.randn(3, 4)&gt;&gt;&gt; x 1.2045  2.4084  0.4001  1.1372 0.5596  1.5677  0.6219 -0.7954 1.3635 -1.2313 -0.5414 -1.8478[torch.FloatTensor of size 3x4]&gt;&gt;&gt; indices = torch.LongTensor([0, 2])&gt;&gt;&gt; torch.index_select(x, 0, indices) 1.2045  2.4084  0.4001  1.1372 1.3635 -1.2313 -0.5414 -1.8478[torch.FloatTensor of size 2x4]&gt;&gt;&gt; torch.index_select(x, 1, indices) 1.2045  0.4001 0.5596  0.6219 1.3635 -0.5414[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-nonzero"><a href="#torch-nonzero" class="headerlink" title="torch.nonzero"></a>torch.nonzero</h3><pre><code>torch.nonzero(input, out=None) → LongTensor</code></pre><p>返回一个包含输入<code>input</code>中非零元素索引的张量。输出张量中的每行包含输入中非零元素的索引。</p><p>如果输入<code>input</code>有<code>n</code>维，则输出的索引张量<code>output</code>的形状为 z x n, 这里 z 是输入张量<code>input</code>中所有非零元素的个数。</p><p>参数:</p><ul><li>input (Tensor) – 源张量</li><li>out (LongTensor, optional) – 包含索引值的结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.nonzero(torch.Tensor([1, 1, 1, 0, 1])) 0 1 2 4[torch.LongTensor of size 4x1]&gt;&gt;&gt; torch.nonzero(torch.Tensor([[0.6, 0.0, 0.0, 0.0],...                             [0.0, 0.4, 0.0, 0.0],...                             [0.0, 0.0, 1.2, 0.0],...                             [0.0, 0.0, 0.0,-0.4]])) 0  0 1  1 2  2 3  3[torch.LongTensor of size 4x2]</code></pre><h3 id="torch-split"><a href="#torch-split" class="headerlink" title="torch.split"></a>torch.split</h3><pre><code>torch.split(tensor, split_size, dim=0)</code></pre><p>将输入张量分割成相等形状的chunks（如果可分）。 如果沿指定维的张量形状大小不能被<code>split_size</code> 整分， 则最后一个分块会小于其它分块。</p><p>参数:</p><ul><li>tensor (Tensor) – 待分割张量</li><li>split_size (int) – 单个分块的形状大小</li><li>dim (int) – 沿着此维进行分割</li></ul><h3 id="torch-squeeze"><a href="#torch-squeeze" class="headerlink" title="torch.squeeze"></a>torch.squeeze</h3><pre><code>torch.squeeze(input, dim=None, out=None)</code></pre><p>注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int, optional) – 如果给定，则<code>input</code>只会在给定维度挤压</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.zeros(2,1,2,1,2)&gt;&gt;&gt; x.size()(2L, 1L, 2L, 1L, 2L)&gt;&gt;&gt; y = torch.squeeze(x)&gt;&gt;&gt; y.size()(2L, 2L, 2L)&gt;&gt;&gt; y = torch.squeeze(x, 0)&gt;&gt;&gt; y.size()(2L, 1L, 2L, 1L, 2L)&gt;&gt;&gt; y = torch.squeeze(x, 1)&gt;&gt;&gt; y.size()(2L, 2L, 1L, 2L)</code></pre><h3 id="torch-stack-source"><a href="#torch-stack-source" class="headerlink" title="torch.stack[source]"></a>torch.stack<a href="http://pytorch.org/docs/_modules/torch/functional.html#stack" target="_blank" rel="noopener">[source]</a></h3><pre><code>torch.stack(sequence, dim=0)</code></pre><p>沿着一个新维度对输入张量序列进行连接。 序列中所有的张量都应该为相同形状。</p><p>参数:</p><ul><li>sqequence (Sequence) – 待连接的张量序列</li><li>dim (int) – 插入的维度。必须介于 0 与 待连接的张量序列数之间。</li></ul><h3 id="torch-t"><a href="#torch-t" class="headerlink" title="torch.t"></a>torch.t</h3><pre><code>torch.t(input, out=None) → Tensor</code></pre><p>输入一个矩阵（2维张量），并转置0, 1维。 可以被视为函数<code>transpose(input, 0, 1)</code>的简写函数。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 结果张量</li></ul><pre><code>&gt;&gt;&gt; x = torch.randn(2, 3)&gt;&gt;&gt; x 0.4834  0.6907  1.3417-0.1300  0.5295  0.2321[torch.FloatTensor of size 2x3]&gt;&gt;&gt; torch.t(x) 0.4834 -0.1300 0.6907  0.5295 1.3417  0.2321[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-transpose"><a href="#torch-transpose" class="headerlink" title="torch.transpose"></a>torch.transpose</h3><pre><code>torch.transpose(input, dim0, dim1, out=None) → Tensor</code></pre><p>返回输入矩阵<code>input</code>的转置。交换维度<code>dim0</code>和<code>dim1</code>。 输出张量与输入张量共享内存，所以改变其中一个会导致另外一个也被修改。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>dim0 (int) – 转置的第一维</li><li>dim1 (int) – 转置的第二维</li></ul><pre><code>&gt;&gt;&gt; x = torch.randn(2, 3)&gt;&gt;&gt; x 0.5983 -0.0341  2.4918 1.5981 -0.5265 -0.8735[torch.FloatTensor of size 2x3]&gt;&gt;&gt; torch.transpose(x, 0, 1) 0.5983  1.5981-0.0341 -0.5265 2.4918 -0.8735[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-unbind"><a href="#torch-unbind" class="headerlink" title="torch.unbind"></a>torch.unbind</h3><pre><code>torch.unbind(tensor, dim=0)[source]</code></pre><p>移除指定维后，返回一个元组，包含了沿着指定维切片后的各个切片</p><p>参数:</p><ul><li>tensor (Tensor) – 输入张量</li><li>dim (int) – 删除的维度</li></ul><h3 id="torch-unsqueeze"><a href="#torch-unsqueeze" class="headerlink" title="torch.unsqueeze"></a>torch.unsqueeze</h3><pre><code>torch.unsqueeze(input, dim, out=None)</code></pre><p>返回一个新的张量，对输入的制定位置插入维度 1</p><p>注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。</p><p>参数:</p><ul><li>tensor (Tensor) – 输入张量</li><li>dim (int) – 插入维度的索引</li><li>out (Tensor, optional) – 结果张量</li></ul><pre><code>&gt;&gt;&gt; x = torch.Tensor([1, 2, 3, 4])&gt;&gt;&gt; torch.unsqueeze(x, 0) 1  2  3  4[torch.FloatTensor of size 1x4]&gt;&gt;&gt; torch.unsqueeze(x, 1) 1 2 3 4[torch.FloatTensor of size 4x1]</code></pre><hr><h2 id="随机抽样-Random-sampling"><a href="#随机抽样-Random-sampling" class="headerlink" title="随机抽样 Random sampling"></a>随机抽样 Random sampling</h2><h3 id="torch-manual-seed"><a href="#torch-manual-seed" class="headerlink" title="torch.manual_seed"></a>torch.manual_seed</h3><pre><code>torch.manual_seed(seed)</code></pre><p>设定生成随机数的种子，并返回一个 <em>torch._C.Generator</em> 对象.</p><p>参数: seed (int or long) – 种子.</p><h3 id="torch-initial-seed"><a href="#torch-initial-seed" class="headerlink" title="torch.initial_seed"></a>torch.initial_seed</h3><pre><code>torch.initial_seed()</code></pre><p>返回生成随机数的原始种子值（python long）。</p><h3 id="torch-get-rng-state"><a href="#torch-get-rng-state" class="headerlink" title="torch.get_rng_state"></a>torch.get_rng_state</h3><pre><code>torch.get_rng_state()[source]</code></pre><p>返回随机生成器状态(<em>ByteTensor</em>)</p><h3 id="torch-set-rng-state"><a href="#torch-set-rng-state" class="headerlink" title="torch.set_rng_state"></a>torch.set_rng_state</h3><pre><code>torch.set_rng_state(new_state)[source]</code></pre><p>设定随机生成器状态 参数: new_state (torch.ByteTensor) – 期望的状态</p><h3 id="torch-default-generator"><a href="#torch-default-generator" class="headerlink" title="torch.default_generator"></a>torch.default_generator</h3><pre><code>torch.default_generator = &lt;torch._C.Generator object&gt;</code></pre><h3 id="torch-bernoulli"><a href="#torch-bernoulli" class="headerlink" title="torch.bernoulli"></a>torch.bernoulli</h3><pre><code>torch.bernoulli(input, out=None) → Tensor</code></pre><p>从伯努利分布中抽取二元随机数(0 或者 1)。</p><p>输出张量的第<em><code>i</code></em>个元素值， 将会以输入张量的第<em><code>i</code></em>个概率值等于<code>1</code>。</p><p>返回值将会是与输入相同大小的张量，每个值为0或者1 参数:</p><ul><li>input (Tensor) – 输入为伯努利分布的概率值</li><li>out (Tensor, optional) – 输出张量(可选)</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.Tensor(3, 3).uniform_(0, 1) # generate a uniform random matrix with range [0, 1]&gt;&gt;&gt; a 0.7544  0.8140  0.9842 0.5282  0.0595  0.6445 0.1925  0.9553  0.9732[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.bernoulli(a) 1  1  1 0  0  1 0  1  1[torch.FloatTensor of size 3x3]&gt;&gt;&gt; a = torch.ones(3, 3) # probability of drawing "1" is 1&gt;&gt;&gt; torch.bernoulli(a) 1  1  1 1  1  1 1  1  1[torch.FloatTensor of size 3x3]&gt;&gt;&gt; a = torch.zeros(3, 3) # probability of drawing "1" is 0&gt;&gt;&gt; torch.bernoulli(a) 0  0  0 0  0  0 0  0  0[torch.FloatTensor of size 3x3]</code></pre><hr><h3 id="torch-multinomial"><a href="#torch-multinomial" class="headerlink" title="torch.multinomial"></a>torch.multinomial</h3><pre><code>torch.multinomial(input, num_samples,replacement=False, out=None) → LongTensor</code></pre><p>返回一个张量，每行包含从<code>input</code>相应行中定义的多项分布中抽取的<code>num_samples</code>个样本。</p><p><strong>[注意]</strong>:输入<code>input</code>每行的值不需要总和为1 (这里我们用来做权重)，但是必须非负且总和不能为0。</p><p>当抽取样本时，依次从左到右排列(第一个样本对应第一列)。</p><p>如果参数<code>replacement</code> 为 <em>True</em>, 则样本抽取可以重复。否则，一个样本在每行不能被重复抽取。</p><p>参数<code>num_samples</code>必须小于<code>input</code>长度(即，<code>input</code>的列数，如果是<code>input</code>是一个矩阵)。</p><p>参数:</p><ul><li>input (Tensor) – 包含概率值的张量</li><li>num_samples (int) – 抽取的样本数</li><li>replacement (bool, optional) – 布尔值，决定是否能重复抽取</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; weights = torch.Tensor([0, 10, 3, 0]) # create a Tensor of weights&gt;&gt;&gt; torch.multinomial(weights, 4) 1 2 0 0[torch.LongTensor of size 4]&gt;&gt;&gt; torch.multinomial(weights, 4, replacement=True) 1 2 1 2[torch.LongTensor of size 4]</code></pre><h3 id="torch-normal"><a href="#torch-normal" class="headerlink" title="torch.normal()"></a>torch.normal()</h3><pre><code>torch.normal(means, std, out=None)</code></pre><p>返回一个张量，包含从给定参数<code>means</code>,<code>std</code>的离散正态分布中抽取随机数。 均值<code>means</code>是一个张量，包含每个输出元素相关的正态分布的均值。 <code>std</code>是一个张量，包含每个输出元素相关的正态分布的标准差。 均值和标准差的形状不须匹配，但每个张量的元素个数须相同。</p><p>参数:</p><ul><li>means (Tensor) – 均值</li><li>std (Tensor) – 标准差</li><li>out (Tensor) – 可选的输出张量</li></ul><pre><code>torch.normal(means=torch.arange(1, 11), std=torch.arange(1, 0, -0.1)) 1.5104 1.6955 2.4895 4.9185 4.9895 6.9155 7.3683 8.1836 8.7164 9.8916[torch.FloatTensor of size 10]</code></pre><pre><code>torch.normal(mean=0.0, std, out=None)</code></pre><p>与上面函数类似，所有抽取的样本共享均值。</p><p>参数:</p><ul><li>means (Tensor,optional) – 所有分布均值</li><li>std (Tensor) – 每个元素的标准差</li><li>out (Tensor) – 可选的输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; torch.normal(mean=0.5, std=torch.arange(1, 6))  0.5723  0.0871 -0.3783 -2.5689 10.7893[torch.FloatTensor of size 5]</code></pre><pre><code>torch.normal(means, std=1.0, out=None)</code></pre><p>与上面函数类似，所有抽取的样本共享标准差。</p><p>参数:</p><ul><li>means (Tensor) – 每个元素的均值</li><li>std (float, optional) – 所有分布的标准差</li><li>out (Tensor) – 可选的输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; torch.normal(means=torch.arange(1, 6)) 1.1681 2.8884 3.7718 2.5616 4.2500[torch.FloatTensor of size 5]</code></pre><hr><h2 id="序列化-Serialization"><a href="#序列化-Serialization" class="headerlink" title="序列化 Serialization"></a>序列化 Serialization</h2><h3 id="torch-saves-source"><a href="#torch-saves-source" class="headerlink" title="torch.saves[source]"></a>torch.saves<a href="http://pytorch.org/docs/_modules/torch/serialization.html#save" target="_blank" rel="noopener">[source]</a></h3><pre><code>torch.save(obj, f, pickle_module=&lt;module 'pickle' from '/home/jenkins/miniconda/lib/python3.5/pickle.py'&gt;, pickle_protocol=2)</code></pre><p>保存一个对象到一个硬盘文件上 参考: <a href="http://pytorch.org/docs/notes/serialization.html#recommend-saving-models" target="_blank" rel="noopener">Recommended approach for saving a model</a> 参数：</p><ul><li>obj – 保存对象</li><li>f － 类文件对象 (返回文件描述符)或一个保存文件名的字符串</li><li>pickle_module – 用于pickling元数据和对象的模块</li><li>pickle_protocol – 指定pickle protocal 可以覆盖默认参数</li></ul><h3 id="torch-load-source"><a href="#torch-load-source" class="headerlink" title="torch.load[source]"></a>torch.load<a href="http://pytorch.org/docs/_modules/torch/serialization.html#load" target="_blank" rel="noopener">[source]</a></h3><pre><code>torch.load(f, map_location=None, pickle_module=&lt;module 'pickle' from '/home/jenkins/miniconda/lib/python3.5/pickle.py'&gt;)</code></pre><p>从磁盘文件中读取一个通过<code>torch.save()</code>保存的对象。 <code>torch.load()</code> 可通过参数<code>map_location</code> 动态地进行内存重映射，使其能从不动设备中读取文件。一般调用时，需两个参数: storage 和 location tag. 返回不同地址中的storage，或着返回None (此时地址可以通过默认方法进行解析). 如果这个参数是字典的话，意味着其是从文件的地址标记到当前系统的地址标记的映射。 默认情况下， location tags中 “cpu”对应host tensors，‘cuda:device_id’ (e.g. ‘cuda:2’) 对应cuda tensors。 用户可以通过register_package进行扩展，使用自己定义的标记和反序列化方法。</p><p>参数:</p><ul><li>f – 类文件对象 (返回文件描述符)或一个保存文件名的字符串</li><li>map_location – 一个函数或字典规定如何remap存储位置</li><li>pickle_module – 用于unpickling元数据和对象的模块 (必须匹配序列化文件时的pickle_module )</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; torch.load('tensors.pt')# Load all tensors onto the CPU&gt;&gt;&gt; torch.load('tensors.pt', map_location=lambda storage, loc: storage)# Map tensors from GPU 1 to GPU 0&gt;&gt;&gt; torch.load('tensors.pt', map_location={'cuda:1':'cuda:0'})</code></pre><h2 id="并行化-Parallelism"><a href="#并行化-Parallelism" class="headerlink" title="并行化 Parallelism"></a>并行化 Parallelism</h2><h3 id="torch-get-num-threads"><a href="#torch-get-num-threads" class="headerlink" title="torch.get_num_threads"></a>torch.get_num_threads</h3><pre><code>torch.get_num_threads() → int</code></pre><p>获得用于并行化CPU操作的OpenMP线程数</p><hr><h3 id="torch-set-num-threads"><a href="#torch-set-num-threads" class="headerlink" title="torch.set_num_threads"></a>torch.set_num_threads</h3><pre><code>torch.set_num_threads(int)</code></pre><p>设定用于并行化CPU操作的OpenMP线程数</p><h1 id="数学操作Math-operations"><a href="#数学操作Math-operations" class="headerlink" title="数学操作Math operations"></a>数学操作Math operations</h1><h2 id="Pointwise-Ops"><a href="#Pointwise-Ops" class="headerlink" title="Pointwise Ops"></a>Pointwise Ops</h2><h3 id="torch-abs"><a href="#torch-abs" class="headerlink" title="torch.abs"></a>torch.abs</h3><pre><code>torch.abs(input, out=None) → Tensor</code></pre><p>计算输入张量的每个元素绝对值</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.abs(torch.FloatTensor([-1, -2, 3]))FloatTensor([1, 2, 3])</code></pre><h3 id="torch-acos-input-out-None-→-Tensor"><a href="#torch-acos-input-out-None-→-Tensor" class="headerlink" title="torch.acos(input, out=None) → Tensor"></a>torch.acos(input, out=None) → Tensor</h3><pre><code>torch.acos(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入张量每个元素的反余弦。 参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (<a href="http://pytorch.org/docs/tensors.html#torch.Tensor" target="_blank" rel="noopener">Tensor</a>, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.acos(a) 2.2608 1.2956 1.1075    nan[torch.FloatTensor of size 4]</code></pre><h3 id="torch-add"><a href="#torch-add" class="headerlink" title="torch.add()"></a>torch.add()</h3><pre><code>torch.add(input, value, out=None)</code></pre><p>如果输入<code>input</code>是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>value</code>取整数、实数皆可。】</p><ul><li>input (Tensor) – 输入张量</li><li>value (Number) – 添加到输入每个元素的数</li><li>out (Tensor, optional) – 结果张量</li></ul><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 0.4050-1.2227 1.8688-0.4185[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.add(a, 20) 20.4050 18.7773 21.8688 19.5815[torch.FloatTensor of size 4]</code></pre><pre><code>torch.add(input, value=1, other, out=None)</code></pre><p>两个张量 <code>input</code> and <code>other</code>的尺寸不需要匹配，但元素总数必须一样。</p><p><strong>注意</strong> :当两个张量形状不匹配时，输入张量的形状会作为输出张量的尺寸。</p><p>如果<code>other</code>是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>value</code>取整数、实数皆可。】</p><p>参数:</p><ul><li>input (Tensor) – 第一个输入张量</li><li>value (Number) – 用于第二个张量的尺寸因子</li><li>other (Tensor) – 第二个输入张量</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; import torch&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.9310 2.0330 0.0852-0.2941[torch.FloatTensor of size 4]&gt;&gt;&gt; b = torch.randn(2, 2)&gt;&gt;&gt; b 1.0663  0.2544-0.1513  0.0749[torch.FloatTensor of size 2x2]&gt;&gt;&gt; torch.add(a, 10, b) 9.7322 4.5770-1.4279 0.4552[torch.FloatTensor of size 4]</code></pre><h3 id="torch-addcdiv"><a href="#torch-addcdiv" class="headerlink" title="torch.addcdiv"></a>torch.addcdiv</h3><pre><code>torch.addcdiv(tensor, value=1, tensor1, tensor2, out=None) → Tensor</code></pre><p>用<code>tensor2</code>对<code>tensor1</code>逐元素相除，然后乘以标量值<code>value</code> 并加到<code>tensor</code>。</p><p>张量的形状不需要匹配，但元素数量必须一致。</p><p>如果输入是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。</p><p>参数：</p><ul><li>tensor (Tensor) – 张量，对 tensor1 ./ tensor 进行相加</li><li>value (Number, optional) – 标量，对 tensor1 ./ tensor2 进行相乘</li><li>tensor1 (Tensor) – 张量，作为被除数(分子)</li><li>tensor2 (Tensor) –张量，作为除数(分母)</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; t = torch.randn(2, 3)&gt;&gt;&gt; t1 = torch.randn(1, 6)&gt;&gt;&gt; t2 = torch.randn(6, 1)&gt;&gt;&gt; torch.addcdiv(t, 0.1, t1, t2) 0.0122 -0.0188 -0.2354 0.7396 -1.5721  1.2878[torch.FloatTensor of size 2x3]</code></pre><h3 id="torch-addcmul"><a href="#torch-addcmul" class="headerlink" title="torch.addcmul"></a>torch.addcmul</h3><pre><code>torch.addcmul(tensor, value=1, tensor1, tensor2, out=None) → Tensor</code></pre><p>用<code>tensor2</code>对<code>tensor1</code>逐元素相乘，并对结果乘以标量值<code>value</code>然后加到<code>tensor</code>。 张量的形状不需要匹配，但元素数量必须一致。 如果输入是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。</p><p>参数：</p><ul><li>tensor (Tensor) – 张量，对tensor1 ./ tensor 进行相加</li><li>value (Number, optional) – 标量，对 tensor1 . tensor2 进行相乘</li><li>tensor1 (Tensor) – 张量，作为乘子1</li><li>tensor2 (Tensor) –张量，作为乘子2</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; t = torch.randn(2, 3)&gt;&gt;&gt; t1 = torch.randn(1, 6)&gt;&gt;&gt; t2 = torch.randn(6, 1)&gt;&gt;&gt; torch.addcmul(t, 0.1, t1, t2) 0.0122 -0.0188 -0.2354 0.7396 -1.5721  1.2878[torch.FloatTensor of size 2x3]</code></pre><h3 id="torch-asin"><a href="#torch-asin" class="headerlink" title="torch.asin"></a>torch.asin</h3><pre><code>torch.asin(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的反正弦函数</p><p>参数：</p><ul><li>tensor (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.asin(a)-0.6900 0.2752 0.4633    nan[torch.FloatTensor of size 4]</code></pre><h3 id="torch-atan"><a href="#torch-atan" class="headerlink" title="torch.atan"></a>torch.atan</h3><pre><code>torch.atan(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的反正切函数</p><p>参数：</p><ul><li>tensor (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.atan(a)-0.5669 0.2653 0.4203 0.9196[torch.FloatTensor of size 4]</code></pre><h3 id="torch-atan2"><a href="#torch-atan2" class="headerlink" title="torch.atan2"></a>torch.atan2</h3><pre><code>torch.atan2(input1, input2, out=None) → Tensor</code></pre><p>返回一个新张量，包含两个输入张量<code>input1</code>和<code>input2</code>的反正切函数</p><p>参数：</p><ul><li>input1 (Tensor) – 第一个输入张量</li><li>input2 (Tensor) – 第二个输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.atan2(a, torch.randn(4))-2.4167 2.9755 0.9363 1.6613[torch.FloatTensor of size 4]</code></pre><h3 id="torch-ceil"><a href="#torch-ceil" class="headerlink" title="torch.ceil"></a>torch.ceil</h3><pre><code>torch.ceil(input, out=None) → Tensor</code></pre><p>天井函数，对输入<code>input</code>张量每个元素向上取整, 即取不小于每个元素的最小整数，并返回结果到输出。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.ceil(a) 2 1-0-0[torch.FloatTensor of size 4]</code></pre><h3 id="torch-clamp"><a href="#torch-clamp" class="headerlink" title="torch.clamp"></a>torch.clamp</h3><pre><code>torch.clamp(input, min, max, out=None) → Tensor</code></pre><p>操作定义如下：</p><pre><code>      | min, if x_i &lt; miny_i = | x_i, if min &lt;= x_i &lt;= max      | max, if x_i &gt; max</code></pre><p>如果输入是FloatTensor or DoubleTensor类型，则参数<code>min</code> <code>max</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>min</code>， <code>max</code>取整数、实数皆可。】</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>min (Number) – 限制范围下限</li><li>max (Number) – 限制范围上限</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.clamp(a, min=-0.5, max=0.5) 0.5000 0.3912-0.5000-0.5000[torch.FloatTensor of size 4]</code></pre><pre><code>torch.clamp(input, *, min, out=None) → Tensor</code></pre><p>将输入<code>input</code>张量每个元素的限制到不小于<code>min</code> ，并返回结果到一个新张量。</p><p>如果输入是FloatTensor or DoubleTensor类型，则参数 <code>min</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>min</code>取整数、实数皆可。】</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>value (Number) – 限制范围下限</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.clamp(a, min=0.5) 1.3869 0.5000 0.5000 0.5000[torch.FloatTensor of size 4]</code></pre><pre><code>torch.clamp(input, *, max, out=None) → Tensor</code></pre><p>将输入<code>input</code>张量每个元素的限制到不大于<code>max</code> ，并返回结果到一个新张量。</p><p>如果输入是FloatTensor or DoubleTensor类型，则参数 <code>max</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>max</code>取整数、实数皆可。】</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>value (Number) – 限制范围上限</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.clamp(a, max=0.5) 0.5000 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]</code></pre><h3 id="torch-cos"><a href="#torch-cos" class="headerlink" title="torch.cos"></a>torch.cos</h3><pre><code>torch.cos(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的余弦。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.cos(a) 0.8041 0.9633 0.9018 0.2557[torch.FloatTensor of size 4]</code></pre><h3 id="torch-cosh"><a href="#torch-cosh" class="headerlink" title="torch.cosh"></a>torch.cosh</h3><pre><code>torch.cosh(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的双曲余弦。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.cosh(a) 1.2095 1.0372 1.1015 1.9917[torch.FloatTensor of size 4]</code></pre><h3 id="torch-div"><a href="#torch-div" class="headerlink" title="torch.div()"></a>torch.div()</h3><pre><code>torch.div(input, value, out=None)</code></pre><p>如果输入是FloatTensor or DoubleTensor类型，则参数 <code>value</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>value</code>取整数、实数皆可。】</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>value (Number) – 除数</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(5)&gt;&gt;&gt; a-0.6147-1.1237-0.1604-0.6853 0.1063[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.div(a, 0.5)-1.2294-2.2474-0.3208-1.3706 0.2126[torch.FloatTensor of size 5]</code></pre><pre><code>torch.div(input, other, out=None)</code></pre><p>两张量形状不须匹配，但元素数须一致。</p><p>注意：当形状不匹配时，<code>input</code>的形状作为输出张量的形状。</p><p>参数：</p><ul><li>input (Tensor) – 张量(分子)</li><li>other (Tensor) – 张量(分母)</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4,4)&gt;&gt;&gt; a-0.1810  0.4017  0.2863 -0.1013 0.6183  2.0696  0.9012 -1.5933 0.5679  0.4743 -0.0117 -0.1266-0.1213  0.9629  0.2682  1.5968[torch.FloatTensor of size 4x4]&gt;&gt;&gt; b = torch.randn(8, 2)&gt;&gt;&gt; b 0.8774  0.7650 0.8866  1.4805-0.6490  1.1172 1.4259 -0.8146 1.4633 -0.1228 0.4643 -0.6029 0.3492  1.5270 1.6103 -0.6291[torch.FloatTensor of size 8x2]&gt;&gt;&gt; torch.div(a, b)-0.2062  0.5251  0.3229 -0.0684-0.9528  1.8525  0.6320  1.9559 0.3881 -3.8625 -0.0253  0.2099-0.3473  0.6306  0.1666 -2.5381[torch.FloatTensor of size 4x4]</code></pre><h3 id="torch-exp"><a href="#torch-exp" class="headerlink" title="torch.exp"></a>torch.exp</h3><pre><code>torch.exp(tensor, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的指数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><pre><code>&gt;&gt;&gt; torch.exp(torch.Tensor([0, math.log(2)]))torch.FloatTensor([1, 2])</code></pre><h3 id="torch-floor"><a href="#torch-floor" class="headerlink" title="torch.floor"></a>torch.floor</h3><pre><code>torch.floor(input, out=None) → Tensor</code></pre><p>床函数: 返回一个新张量，包含输入<code>input</code>张量每个元素的floor，即不小于元素的最大整数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.floor(a) 1 0-1-1[torch.FloatTensor of size 4]</code></pre><h3 id="torch-fmod"><a href="#torch-fmod" class="headerlink" title="torch.fmod"></a>torch.fmod</h3><pre><code>torch.fmod(input, divisor, out=None) → Tensor</code></pre><p>计算除法余数。 除数与被除数可能同时含有整数和浮点数。此时，余数的正负与被除数相同。</p><p>参数： - input (Tensor) – 被除数 - divisor (Tensor or float) – 除数，一个数或与被除数相同类型的张量 - out (Tensor, optional) – 输出张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.fmod(torch.Tensor([-3, -2, -1, 1, 2, 3]), 2)torch.FloatTensor([-1, -0, -1, 1, 0, 1])&gt;&gt;&gt; torch.fmod(torch.Tensor([1, 2, 3, 4, 5]), 1.5)torch.FloatTensor([1.0, 0.5, 0.0, 1.0, 0.5])</code></pre><p>参考: <a href="http://pytorch.org/docs/torch.html#torch.remainder" target="_blank" rel="noopener"><code>torch.remainder()</code></a>, 计算逐元素余数， 相当于python 中的 % 操作符。</p><h3 id="torch-frac"><a href="#torch-frac" class="headerlink" title="torch.frac"></a>torch.frac</h3><pre><code>torch.frac(tensor, out=None) → Tensor</code></pre><p>返回每个元素的分数部分。</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.frac(torch.Tensor([1, 2.5, -3.2])torch.FloatTensor([0, 0.5, -0.2])</code></pre><h3 id="torch-lerp"><a href="#torch-lerp" class="headerlink" title="torch.lerp"></a>torch.lerp</h3><pre><code>torch.lerp(start, end, weight, out=None)</code></pre><p>参数：</p><ul><li>start (Tensor) – 起始点张量</li><li>end (Tensor) – 终止点张量</li><li>weight (float) – 插值公式的weight</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; start = torch.arange(1, 5)&gt;&gt;&gt; end = torch.Tensor(4).fill_(10)&gt;&gt;&gt; start 1 2 3 4[torch.FloatTensor of size 4]&gt;&gt;&gt; end 10 10 10 10[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.lerp(start, end, 0.5) 5.5000 6.0000 6.5000 7.0000[torch.FloatTensor of size 4]</code></pre><h3 id="torch-log"><a href="#torch-log" class="headerlink" title="torch.log"></a>torch.log</h3><pre><code>torch.log(input, out=None) → Tensor</code></pre><p>计算<code>input</code> 的自然对数</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(5)&gt;&gt;&gt; a-0.4183 0.3722-0.3091 0.4149 0.5857[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.log(a)    nan-0.9883    nan-0.8797-0.5349[torch.FloatTensor of size 5]</code></pre><h3 id="torch-log1p"><a href="#torch-log1p" class="headerlink" title="torch.log1p"></a>torch.log1p</h3><pre><code>torch.log1p(input, out=None) → Tensor</code></pre><p>注意：对值比较小的输入，此函数比<code>torch.log()</code>更准确。</p><p>如果输入是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(5)&gt;&gt;&gt; a-0.4183 0.3722-0.3091 0.4149 0.5857[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.log1p(a)-0.5418 0.3164-0.3697 0.3471 0.4611[torch.FloatTensor of size 5]</code></pre><h3 id="torch-mul"><a href="#torch-mul" class="headerlink" title="torch.mul"></a>torch.mul</h3><pre><code>torch.mul(input, value, out=None)</code></pre><p>如果输入是FloatTensor or DoubleTensor类型，则<code>value</code> 必须为实数，否则须为整数。【译注：似乎并非如此，无关输入类型，<code>value</code>取整数、实数皆可。】</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>value (Number) – 乘到每个元素的数</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(3)&gt;&gt;&gt; a-0.9374-0.5254-0.6069[torch.FloatTensor of size 3]&gt;&gt;&gt; torch.mul(a, 100)-93.7411-52.5374-60.6908[torch.FloatTensor of size 3]</code></pre><pre><code>torch.mul(input, other, out=None)</code></pre><p>两计算张量形状不须匹配，但总元素数须一致。 <strong>注意</strong>：当形状不匹配时，<code>input</code>的形状作为输入张量的形状。</p><p>参数：</p><ul><li>input (Tensor) – 第一个相乘张量</li><li>other (Tensor) – 第二个相乘张量</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4,4)&gt;&gt;&gt; a-0.7280  0.0598 -1.4327 -0.5825-0.1427 -0.0690  0.0821 -0.3270-0.9241  0.5110  0.4070 -1.1188-0.8308  0.7426 -0.6240 -1.1582[torch.FloatTensor of size 4x4]&gt;&gt;&gt; b = torch.randn(2, 8)&gt;&gt;&gt; b 0.0430 -1.0775  0.6015  1.1647 -0.6549  0.0308 -0.1670  1.0742-1.2593  0.0292 -0.0849  0.4530  1.2404 -0.4659 -0.1840  0.5974[torch.FloatTensor of size 2x8]&gt;&gt;&gt; torch.mul(a, b)-0.0313 -0.0645 -0.8618 -0.6784 0.0934 -0.0021 -0.0137 -0.3513 1.1638  0.0149 -0.0346 -0.5068-1.0304 -0.3460  0.1148 -0.6919[torch.FloatTensor of size 4x4]</code></pre><h3 id="torch-neg"><a href="#torch-neg" class="headerlink" title="torch.neg"></a>torch.neg</h3><pre><code>torch.neg(input, out=None) → Tensor</code></pre><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(5)&gt;&gt;&gt; a-0.4430 1.1690-0.8836-0.4565 0.2968[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.neg(a) 0.4430-1.1690 0.8836 0.4565-0.2968[torch.FloatTensor of size 5]</code></pre><h3 id="torch-pow"><a href="#torch-pow" class="headerlink" title="torch.pow"></a>torch.pow</h3><pre><code>torch.pow(input, exponent, out=None)</code></pre><p>对输入<code>input</code>的按元素求<code>exponent</code>次幂值，并返回结果张量。 幂值<code>exponent</code> 可以为单一 <code>float</code> 数或者与<code>input</code>相同元素数的张量。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>exponent (float or Tensor) – 幂值</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.5274-0.8232-2.1128 1.7558[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.pow(a, 2) 0.2781 0.6776 4.4640 3.0829[torch.FloatTensor of size 4]&gt;&gt;&gt; exp = torch.arange(1, 5)&gt;&gt;&gt; a = torch.arange(1, 5)&gt;&gt;&gt; a 1 2 3 4[torch.FloatTensor of size 4]&gt;&gt;&gt; exp 1 2 3 4[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.pow(a, exp)   1   4  27 256[torch.FloatTensor of size 4]</code></pre><pre><code>torch.pow(base, input, out=None)</code></pre><p><code>base</code> 为标量浮点值,<code>input</code>为张量， 返回的输出张量 <code>out</code> 与输入张量相同形状。</p><p>参数：</p><ul><li>base (float) – 标量值，指数的底</li><li>input ( Tensor) – 幂值</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; exp = torch.arange(1, 5)&gt;&gt;&gt; base = 2&gt;&gt;&gt; torch.pow(base, exp)  2  4  8 16[torch.FloatTensor of size 4]</code></pre><h3 id="torch-reciprocal"><a href="#torch-reciprocal" class="headerlink" title="torch.reciprocal"></a>torch.reciprocal</h3><pre><code>torch.reciprocal(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的倒数，即 1.0/x。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.reciprocal(a) 0.7210 2.5565-1.1583-1.8289[torch.FloatTensor of size 4]</code></pre><h3 id="torch-remainder"><a href="#torch-remainder" class="headerlink" title="torch.remainder"></a>torch.remainder</h3><pre><code>torch.remainder(input, divisor, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的除法余数。 除数与被除数可能同时包含整数或浮点数。余数与除数有相同的符号。</p><p>参数：</p><ul><li>input (Tensor) – 被除数</li><li>divisor (Tensor or float) – 除数，一个数或者与除数相同大小的张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; torch.remainder(torch.Tensor([-3, -2, -1, 1, 2, 3]), 2)torch.FloatTensor([1, 0, 1, 1, 0, 1])&gt;&gt;&gt; torch.remainder(torch.Tensor([1, 2, 3, 4, 5]), 1.5)torch.FloatTensor([1.0, 0.5, 0.0, 1.0, 0.5])</code></pre><p><strong>参考</strong>: 函数<code>torch.fmod()</code> 同样可以计算除法余数，相当于 C 的 库函数<code>fmod()</code></p><h3 id="torch-round"><a href="#torch-round" class="headerlink" title="torch.round"></a>torch.round</h3><pre><code>torch.round(input, out=None) → Tensor</code></pre><p>返回一个新张量，将输入<code>input</code>张量每个元素舍入到最近的整数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.2290 1.3409-0.5662-0.0899[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.round(a) 1 1-1-0[torch.FloatTensor of size 4]</code></pre><h3 id="torch-rsqrt"><a href="#torch-rsqrt" class="headerlink" title="torch.rsqrt"></a>torch.rsqrt</h3><pre><code>torch.rsqrt(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的平方根倒数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.2290 1.3409-0.5662-0.0899[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.rsqrt(a) 0.9020 0.8636    nan    nan[torch.FloatTensor of size 4]</code></pre><h3 id="torch-sigmoid"><a href="#torch-sigmoid" class="headerlink" title="torch.sigmoid"></a>torch.sigmoid</h3><pre><code>torch.sigmoid(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的sigmoid值。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.4972 1.3512 0.1056-0.2650[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.sigmoid(a) 0.3782 0.7943 0.5264 0.4341[torch.FloatTensor of size 4]</code></pre><h3 id="torch-sign"><a href="#torch-sign" class="headerlink" title="torch.sign"></a>torch.sign</h3><pre><code>torch.sign(input, out=None) → Tensor</code></pre><p>符号函数：返回一个新张量，包含输入<code>input</code>张量每个元素的正负。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.sign(a)-1 1 1 1[torch.FloatTensor of size 4]</code></pre><h3 id="torch-sin"><a href="#torch-sin" class="headerlink" title="torch.sin"></a>torch.sin</h3><pre><code>torch.sin(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的正弦。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.sin(a)-0.5944 0.2684 0.4322 0.9667[torch.FloatTensor of size 4]</code></pre><h3 id="torch-sinh"><a href="#torch-sinh" class="headerlink" title="torch.sinh"></a>torch.sinh</h3><pre><code>torch.sinh(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的双曲正弦。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.sinh(a)-0.6804 0.2751 0.4619 1.7225[torch.FloatTensor of size 4]</code></pre><h3 id="torch-sqrt"><a href="#torch-sqrt" class="headerlink" title="torch.sqrt"></a>torch.sqrt</h3><pre><code>torch.sqrt(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的平方根。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.2290 1.3409-0.5662-0.0899[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.sqrt(a) 1.1086 1.1580    nan    nan[torch.FloatTensor of size 4]</code></pre><h3 id="torch-tan"><a href="#torch-tan" class="headerlink" title="torch.tan"></a>torch.tan</h3><pre><code>torch.tan(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的正切。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.tan(a)-0.7392 0.2786 0.4792 3.7801[torch.FloatTensor of size 4]</code></pre><h3 id="torch-tanh"><a href="#torch-tanh" class="headerlink" title="torch.tanh"></a>torch.tanh</h3><pre><code>torch.tanh(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的双曲正切。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.6366 0.2718 0.4469 1.3122[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.tanh(a)-0.5625 0.2653 0.4193 0.8648[torch.FloatTensor of size 4]</code></pre><h3 id="torch-trunc"><a href="#torch-trunc" class="headerlink" title="torch.trunc"></a>torch.trunc</h3><pre><code>torch.trunc(input, out=None) → Tensor</code></pre><p>返回一个新张量，包含输入<code>input</code>张量每个元素的截断值(标量x的截断值是最接近其的整数，其比x更接近零。简而言之，有符号数的小数部分被舍弃)。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a-0.4972 1.3512 0.1056-0.2650[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.trunc(a)-0 1 0-0[torch.FloatTensor of size 4]</code></pre><h2 id="Reduction-Ops"><a href="#Reduction-Ops" class="headerlink" title="Reduction Ops"></a>Reduction Ops</h2><h3 id="torch-cumprod"><a href="#torch-cumprod" class="headerlink" title="torch.cumprod"></a>torch.cumprod</h3><pre><code>torch.cumprod(input, dim, out=None) → Tensor</code></pre><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 累积积操作的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(10)&gt;&gt;&gt; a 1.1148 1.8423 1.4143-0.4403 1.2859-1.2514-0.4748 1.1735-1.6332-0.4272[torch.FloatTensor of size 10]&gt;&gt;&gt; torch.cumprod(a, dim=0) 1.1148 2.0537 2.9045-1.2788-1.6444 2.0578-0.9770-1.1466 1.8726-0.8000[torch.FloatTensor of size 10]&gt;&gt;&gt; a[5] = 0.0&gt;&gt;&gt; torch.cumprod(a, dim=0) 1.1148 2.0537 2.9045-1.2788-1.6444-0.0000 0.0000 0.0000-0.0000 0.0000[torch.FloatTensor of size 10]</code></pre><h3 id="torch-cumsum"><a href="#torch-cumsum" class="headerlink" title="torch.cumsum"></a>torch.cumsum</h3><pre><code>torch.cumsum(input, dim, out=None) → Tensor</code></pre><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 累积和操作的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(10)&gt;&gt;&gt; a-0.6039-0.2214-0.3705-0.0169 1.3415-0.1230 0.9719 0.6081-0.1286 1.0947[torch.FloatTensor of size 10]&gt;&gt;&gt; torch.cumsum(a, dim=0)-0.6039-0.8253-1.1958-1.2127 0.1288 0.0058 0.9777 1.5858 1.4572 2.5519[torch.FloatTensor of size 10]</code></pre><hr><h3 id="torch-dist"><a href="#torch-dist" class="headerlink" title="torch.dist"></a>torch.dist</h3><pre><code>torch.dist(input, other, p=2, out=None) → Tensor</code></pre><p>返回 (<code>input</code> - <code>other</code>) 的 <code>p</code>范数 。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>other (Tensor) – 右侧输入张量</li><li>p (float, optional) – 所计算的范数</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.randn(4)&gt;&gt;&gt; x 0.2505-0.4571-0.3733 0.7807[torch.FloatTensor of size 4]&gt;&gt;&gt; y = torch.randn(4)&gt;&gt;&gt; y 0.7782-0.5185 1.4106-2.4063[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.dist(x, y, 3.5)3.302832063224223&gt;&gt;&gt; torch.dist(x, y, 3)3.3677282206393286&gt;&gt;&gt; torch.dist(x, y, 0)inf&gt;&gt;&gt; torch.dist(x, y, 1)5.560028076171875</code></pre><h3 id="torch-mean"><a href="#torch-mean" class="headerlink" title="torch.mean"></a>torch.mean</h3><pre><code>torch.mean(input) → float</code></pre><p>返回输入张量所有元素的均值。</p><p>参数： input (Tensor) – 输入张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a-0.2946 -0.9143  2.1809[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.mean(a)0.32398951053619385</code></pre><pre><code>torch.mean(input, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维度<code>dim</code>上每行的均值。</p><p>输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – the dimension to reduce</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 4)&gt;&gt;&gt; a-1.2738 -0.3058  0.1230 -1.9615 0.8771 -0.5430 -0.9233  0.9879 1.4107  0.0317 -0.6823  0.2255-1.3854  0.4953 -0.2160  0.2435[torch.FloatTensor of size 4x4]&gt;&gt;&gt; torch.mean(a, 1)-0.8545 0.0997 0.2464-0.2157[torch.FloatTensor of size 4x1]</code></pre><h3 id="torch-median"><a href="#torch-median" class="headerlink" title="torch.median"></a>torch.median</h3><pre><code>torch.median(input, dim=-1, values=None, indices=None) -&gt; (Tensor, LongTensor)</code></pre><p>返回输入张量给定维度每行的中位数，同时返回一个包含中位数的索引的<code>LongTensor</code>。</p><p><code>dim</code>值默认为输入张量的最后一维。 输出形状与输入相同，除了给定维度上为1.</p><p><em>注意</em>: 这个函数还没有在<code>torch.cuda.Tensor</code>中定义</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 缩减的维度</li><li>values (Tensor, optional) – 结果张量</li><li>indices (Tensor, optional) – 返回的索引结果张量</li></ul><pre><code>&gt;&gt;&gt; a -0.6891 -0.6662 0.2697  0.7412 0.5254 -0.7402 0.5528 -0.2399[torch.FloatTensor of size 4x2]&gt;&gt;&gt; a = torch.randn(4, 5)&gt;&gt;&gt; a 0.4056 -0.3372  1.0973 -2.4884  0.4334 2.1336  0.3841  0.1404 -0.1821 -0.7646-0.2403  1.3975 -2.0068  0.1298  0.0212-1.5371 -0.7257 -0.4871 -0.2359 -1.1724[torch.FloatTensor of size 4x5]&gt;&gt;&gt; torch.median(a, 1)( 0.4056 0.1404 0.0212-0.7257[torch.FloatTensor of size 4x1], 0 2 4 1[torch.LongTensor of size 4x1])</code></pre><h3 id="torch-mode"><a href="#torch-mode" class="headerlink" title="torch.mode"></a>torch.mode</h3><pre><code>torch.mode(input, dim=-1, values=None, indices=None) -&gt; (Tensor, LongTensor)</code></pre><p>返回给定维<code>dim</code>上，每行的众数值。 同时返回一个<code>LongTensor</code>，包含众数职的索引。<code>dim</code>值默认为输入张量的最后一维。</p><p>输出形状与输入相同，除了给定维度上为1.</p><p><em>注意</em>: 这个函数还没有在<code>torch.cuda.Tensor</code>中定义</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 缩减的维度</li><li>values (Tensor, optional) – 结果张量</li><li>indices (Tensor, optional) – 返回的索引张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a -0.6891 -0.6662 0.2697  0.7412 0.5254 -0.7402 0.5528 -0.2399[torch.FloatTensor of size 4x2]&gt;&gt;&gt; a = torch.randn(4, 5)&gt;&gt;&gt; a 0.4056 -0.3372  1.0973 -2.4884  0.4334 2.1336  0.3841  0.1404 -0.1821 -0.7646-0.2403  1.3975 -2.0068  0.1298  0.0212-1.5371 -0.7257 -0.4871 -0.2359 -1.1724[torch.FloatTensor of size 4x5]&gt;&gt;&gt; torch.mode(a, 1)(-2.4884-0.7646-2.0068-1.5371[torch.FloatTensor of size 4x1], 3 4 2 0[torch.LongTensor of size 4x1])</code></pre><h3 id="torch-norm"><a href="#torch-norm" class="headerlink" title="torch.norm"></a>torch.norm</h3><pre><code>torch.norm(input, p=2) → float</code></pre><p>返回输入张量<code>input</code> 的p 范数。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>p (float,optional) – 范数计算中的幂指数值</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a-0.4376 -0.5328  0.9547[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.norm(a, 3)1.0338925067372466</code></pre><pre><code>torch.norm(input, p, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维<code>dim</code> 上每行的p 范数。 输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>p (float) – 范数计算中的幂指数值</li><li>dim (int) – 缩减的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 2)&gt;&gt;&gt; a-0.6891 -0.6662 0.2697  0.7412 0.5254 -0.7402 0.5528 -0.2399[torch.FloatTensor of size 4x2]&gt;&gt;&gt; torch.norm(a, 2, 1) 0.9585 0.7888 0.9077 0.6026[torch.FloatTensor of size 4x1]&gt;&gt;&gt; torch.norm(a, 0, 1) 2 2 2 2[torch.FloatTensor of size 4x1]</code></pre><h3 id="torch-prod"><a href="#torch-prod" class="headerlink" title="torch.prod"></a>torch.prod</h3><pre><code>torch.prod(input) → float</code></pre><p>返回输入张量<code>input</code> 所有元素的积。</p><p>参数：input (Tensor) – 输入张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a 0.6170  0.3546  0.0253[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.prod(a)0.005537458061418483</code></pre><pre><code>torch.prod(input, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维度上每行的积。 输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 缩减的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 2)&gt;&gt;&gt; a 0.1598 -0.6884-0.1831 -0.4412-0.9925 -0.6244-0.2416 -0.8080[torch.FloatTensor of size 4x2]&gt;&gt;&gt; torch.prod(a, 1)-0.1100 0.0808 0.6197 0.1952[torch.FloatTensor of size 4x1]</code></pre><h3 id="torch-std"><a href="#torch-std" class="headerlink" title="torch.std"></a>torch.std</h3><pre><code>torch.std(input) → float</code></pre><p>返回输入张量<code>input</code> 所有元素的标准差。</p><p>参数：- input (Tensor) – 输入张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a-1.3063  1.4182 -0.3061[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.std(a)1.3782334731508061</code></pre><pre><code>torch.std(input, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维度上每行的标准差。 输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 缩减的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 4)&gt;&gt;&gt; a 0.1889 -2.4856  0.0043  1.8169-0.7701 -0.4682 -2.2410  0.4098 0.1919 -1.1856 -1.0361  0.9085 0.0173  1.0662  0.2143 -0.5576[torch.FloatTensor of size 4x4]&gt;&gt;&gt; torch.std(a, dim=1) 1.7756 1.1025 1.0045 0.6725[torch.FloatTensor of size 4x1]</code></pre><h3 id="torch-sum"><a href="#torch-sum" class="headerlink" title="torch.sum"></a>torch.sum</h3><pre><code>torch.sum(input) → float</code></pre><p>返回输入张量<code>input</code> 所有元素的和。</p><p>输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a 0.6170  0.3546  0.0253[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.sum(a)0.9969287421554327</code></pre><pre><code>torch.sum(input, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维度上每行的和。 输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 缩减的维度</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 4)&gt;&gt;&gt; a-0.4640  0.0609  0.1122  0.4784-1.3063  1.6443  0.4714 -0.7396-1.3561 -0.1959  1.0609 -1.9855 2.6833  0.5746 -0.5709 -0.4430[torch.FloatTensor of size 4x4]&gt;&gt;&gt; torch.sum(a, 1) 0.1874 0.0698-2.4767 2.2440[torch.FloatTensor of size 4x1]</code></pre><h3 id="torch-var"><a href="#torch-var" class="headerlink" title="torch.var"></a>torch.var</h3><pre><code>torch.var(input) → float</code></pre><p>返回输入张量所有元素的方差</p><p>输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a-1.3063  1.4182 -0.3061[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.var(a)1.899527506513334</code></pre><pre><code>torch.var(input, dim, out=None) → Tensor</code></pre><p>返回输入张量给定维度上每行的方差。 输出形状与输入相同，除了给定维度上为1.</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – the dimension to reduce</li><li>out (Tensor, optional) – 结果张量 例子：</li></ul><pre><code>&gt;&gt;&gt; a = torch.randn(4, 4)&gt;&gt;&gt; a-1.2738 -0.3058  0.1230 -1.9615 0.8771 -0.5430 -0.9233  0.9879 1.4107  0.0317 -0.6823  0.2255-1.3854  0.4953 -0.2160  0.2435[torch.FloatTensor of size 4x4]&gt;&gt;&gt; torch.var(a, 1) 0.8859 0.9509 0.7548 0.6949[torch.FloatTensor of size 4x1]</code></pre><h2 id="比较操作-Comparison-Ops"><a href="#比较操作-Comparison-Ops" class="headerlink" title="比较操作 Comparison Ops"></a>比较操作 Comparison Ops</h2><h3 id="torch-eq"><a href="#torch-eq" class="headerlink" title="torch.eq"></a>torch.eq</h3><pre><code>torch.eq(input, other, out=None) → Tensor</code></pre><p>比较元素相等性。第二个参数可为一个数或与第一个参数同类型形状的张量。</p><p>参数：</p><ul><li>input (Tensor) – 待比较张量</li><li>other (Tensor or float) – 比较张量或数</li><li>out (Tensor, optional) – 输出张量，须为 ByteTensor类型 or 与<code>input</code>同类型</li></ul><p>返回值： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果(相等为1，不等为0 )</p><p>返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.eq(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]]))1  00  1[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-equal"><a href="#torch-equal" class="headerlink" title="torch.equal"></a>torch.equal</h3><pre><code>torch.equal(tensor1, tensor2) → bool</code></pre><p>如果两个张量有相同的形状和元素值，则返回<code>True</code> ，否则 <code>False</code>。</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.equal(torch.Tensor([1, 2]), torch.Tensor([1, 2]))True</code></pre><h3 id="torch-ge"><a href="#torch-ge" class="headerlink" title="torch.ge"></a>torch.ge</h3><pre><code>torch.ge(input, other, out=None) → Tensor</code></pre><p>如果两个张量有相同的形状和元素值，则返回<code>True</code> ，否则 <code>False</code>。 第二个参数可以为一个数或与第一个参数相同形状和类型的张量</p><p>参数:</p><ul><li>input (Tensor) – 待对比的张量</li><li>other (Tensor or float) – 对比的张量或<code>float</code>值</li><li>out (Tensor, optional) – 输出张量。必须为<code>ByteTensor</code>或者与第一个参数<code>tensor</code>相同类型。</li></ul><p>返回值： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果(是否 input &gt;= other )。 返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.ge(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]])) 1  1 0  1[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-gt"><a href="#torch-gt" class="headerlink" title="torch.gt"></a>torch.gt</h3><pre><code>torch.gt(input, other, out=None) → Tensor</code></pre><p>参数:</p><ul><li>input (Tensor) – 要对比的张量</li><li>other (Tensor or float) – 要对比的张量或<code>float</code>值</li><li>out (Tensor, optional) – 输出张量。必须为<code>ByteTensor</code>或者与第一个参数<code>tensor</code>相同类型。</li></ul><p>返回值： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果(是否 input &gt;= other )。 返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.gt(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]])) 0  1 0  0[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-kthvalue"><a href="#torch-kthvalue" class="headerlink" title="torch.kthvalue"></a>torch.kthvalue</h3><pre><code>torch.kthvalue(input, k, dim=None, out=None) -&gt; (Tensor, LongTensor)</code></pre><p>取输入张量<code>input</code>指定维上第k 个最小值。如果不指定<code>dim</code>，则默认为<code>input</code>的最后一维。</p><p>返回一个元组 <em>(values,indices)</em>，其中<code>indices</code>是原始输入张量<code>input</code>中沿<code>dim</code>维的第 <code>k</code> 个最小值下标。</p><p>参数:</p><ul><li>input (Tensor) – 要对比的张量</li><li>k (int) – 第 <code>k</code> 个最小值</li><li>dim (int, optional) – 沿着此维进行排序</li><li>out (tuple, optional) – 输出元组 (Tensor, LongTensor) 可选地给定作为 输出 buffers</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.arange(1, 6)&gt;&gt;&gt; x 1 2 3 4 5[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.kthvalue(x, 4)( 4[torch.FloatTensor of size 1], 3[torch.LongTensor of size 1])</code></pre><h3 id="torch-le"><a href="#torch-le" class="headerlink" title="torch.le"></a>torch.le</h3><pre><code>torch.le(input, other, out=None) → Tensor</code></pre><p>参数:</p><ul><li>input (Tensor) – 要对比的张量</li><li>other (Tensor or float ) – 对比的张量或<code>float</code>值</li><li>out (Tensor, optional) – 输出张量。必须为<code>ByteTensor</code>或者与第一个参数<code>tensor</code>相同类型。</li></ul><p>返回值： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果(是否 input &gt;= other )。 返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.le(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]])) 1  0 1  1[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-lt"><a href="#torch-lt" class="headerlink" title="torch.lt"></a>torch.lt</h3><pre><code>torch.lt(input, other, out=None) → Tensor</code></pre><p>第二个参数可以为一个数或与第一个参数相同形状和类型的张量</p><p>参数:</p><ul><li>input (Tensor) – 要对比的张量</li><li>other (Tensor or float ) – 对比的张量或<code>float</code>值</li><li>out (Tensor, optional) – 输出张量。必须为<code>ByteTensor</code>或者与第一个参数<code>tensor</code>相同类型。</li></ul><p>input： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果(是否 tensor &gt;= other )。 返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.lt(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]])) 0  0 1  0[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-max"><a href="#torch-max" class="headerlink" title="torch.max"></a>torch.max</h3><pre><code>torch.max()</code></pre><p>返回输入张量所有元素的最大值。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a 0.4729 -0.2266 -0.2085[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.max(a)0.4729</code></pre><pre><code>torch.max(input, dim, max=None, max_indices=None) -&gt; (Tensor, LongTensor)</code></pre><p>返回输入张量给定维度上每行的最大值，并同时返回每个最大值的位置索引。</p><p>输出形状中，将<code>dim</code>维设定为1，其它与输入形状保持一致。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 指定的维度</li><li>max (Tensor, optional) – 结果张量，包含给定维度上的最大值</li><li>max_indices (LongTensor, optional) – 结果张量，包含给定维度上每个最大值的位置索引</li></ul><p>例子：</p><pre><code>&gt;&gt; a = torch.randn(4, 4)&gt;&gt; a0.0692  0.3142  1.2513 -0.54280.9288  0.8552 -0.2073  0.64091.0695 -0.0101 -2.4507 -1.22300.7426 -0.7666  0.4862 -0.6628torch.FloatTensor of size 4x4]&gt;&gt;&gt; torch.max(a, 1)( 1.2513 0.9288 1.0695 0.7426[torch.FloatTensor of size 4x1], 2 0 0 0[torch.LongTensor of size 4x1])</code></pre><pre><code>torch.max(input, other, out=None) → Tensor</code></pre><p>输出形状中，将<code>dim</code>维设定为1，其它与输入形状保持一致。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>other (Tensor) – 输出张量</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; b = torch.randn(4)&gt;&gt;&gt; b 1.0067-0.8010 0.6258 0.3627[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.max(a, b) 1.3869 0.3912 0.6258 0.3627[torch.FloatTensor of size 4]</code></pre><h3 id="torch-min"><a href="#torch-min" class="headerlink" title="torch.min"></a>torch.min</h3><pre><code>torch.min(input) → float</code></pre><p>返回输入张量所有元素的最小值。</p><p>参数: input (Tensor) – 输入张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(1, 3)&gt;&gt;&gt; a 0.4729 -0.2266 -0.2085[torch.FloatTensor of size 1x3]&gt;&gt;&gt; torch.min(a)-0.22663167119026184</code></pre><pre><code>torch.min(input, dim, min=None, min_indices=None) -&gt; (Tensor, LongTensor)</code></pre><p>返回输入张量给定维度上每行的最小值，并同时返回每个最小值的位置索引。</p><p>输出形状中，将<code>dim</code>维设定为1，其它与输入形状保持一致。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – 指定的维度</li><li>min (Tensor, optional) – 结果张量，包含给定维度上的最小值</li><li>min_indices (LongTensor, optional) – 结果张量，包含给定维度上每个最小值的位置索引</li></ul><p>例子：</p><pre><code>&gt;&gt; a = torch.randn(4, 4)&gt;&gt; a0.0692  0.3142  1.2513 -0.54280.9288  0.8552 -0.2073  0.64091.0695 -0.0101 -2.4507 -1.22300.7426 -0.7666  0.4862 -0.6628torch.FloatTensor of size 4x4]&gt;&gt; torch.min(a, 1)0.54280.20732.45070.7666torch.FloatTensor of size 4x1]3221torch.LongTensor of size 4x1]</code></pre><pre><code>torch.min(input, other, out=None) → Tensor</code></pre><p>两张量形状不需匹配，但元素数须相同。</p><p>注意：当形状不匹配时，<code>input</code>的形状作为返回张量的形状。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>other (Tensor) – 第二个输入张量</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4)&gt;&gt;&gt; a 1.3869 0.3912-0.8634-0.5468[torch.FloatTensor of size 4]&gt;&gt;&gt; b = torch.randn(4)&gt;&gt;&gt; b 1.0067-0.8010 0.6258 0.3627[torch.FloatTensor of size 4]&gt;&gt;&gt; torch.min(a, b) 1.0067-0.8010-0.8634-0.5468[torch.FloatTensor of size 4]</code></pre><h3 id="torch-ne"><a href="#torch-ne" class="headerlink" title="torch.ne"></a>torch.ne</h3><pre><code>torch.ne(input, other, out=None) → Tensor</code></pre><p>参数:</p><ul><li>input (Tensor) – 待对比的张量</li><li>other (Tensor or float) – 对比的张量或<code>float</code>值</li><li>out (Tensor, optional) – 输出张量。必须为<code>ByteTensor</code>或者与<code>input</code>相同类型。</li></ul><p>返回值： 一个 <code>torch.ByteTensor</code> 张量，包含了每个位置的比较结果 (如果 tensor != other 为<code>True</code> ，返回<code>1</code>)。</p><p>返回类型： Tensor</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.ne(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]])) 0  1 1  0[torch.ByteTensor of size 2x2]</code></pre><h3 id="torch-sort"><a href="#torch-sort" class="headerlink" title="torch.sort"></a>torch.sort</h3><pre><code>torch.sort(input, dim=None, descending=False, out=None) -&gt; (Tensor, LongTensor)</code></pre><p>对输入张量<code>input</code>沿着指定维按升序排序。如果不给定<code>dim</code>，则默认为输入的最后一维。如果指定参数<code>descending</code>为<code>True</code>，则按降序排序</p><p>返回元组 (sorted_tensor, sorted_indices) ， <code>sorted_indices</code> 为原始输入中的下标。</p><p>参数:</p><ul><li>input (Tensor) – 要对比的张量</li><li>dim (int, optional) – 沿着此维排序</li><li>descending (bool, optional) – 布尔值，控制升降排序</li><li>out (tuple, optional) – 输出张量。必须为<code>ByteTensor</code>或者与第一个参数<code>tensor</code>相同类型。</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.randn(3, 4)&gt;&gt;&gt; sorted, indices = torch.sort(x)&gt;&gt;&gt; sorted-1.6747  0.0610  0.1190  1.4137-1.4782  0.7159  1.0341  1.3678-0.3324 -0.0782  0.3518  0.4763[torch.FloatTensor of size 3x4]&gt;&gt;&gt; indices 0  1  3  2 2  1  0  3 3  1  0  2[torch.LongTensor of size 3x4]&gt;&gt;&gt; sorted, indices = torch.sort(x, 0)&gt;&gt;&gt; sorted-1.6747 -0.0782 -1.4782 -0.3324 0.3518  0.0610  0.4763  0.1190 1.0341  0.7159  1.4137  1.3678[torch.FloatTensor of size 3x4]&gt;&gt;&gt; indices 0  2  1  2 2  0  2  0 1  1  0  1[torch.LongTensor of size 3x4]</code></pre><h3 id="torch-topk"><a href="#torch-topk" class="headerlink" title="torch.topk"></a>torch.topk</h3><pre><code>torch.topk(input, k, dim=None, largest=True, sorted=True, out=None) -&gt; (Tensor, LongTensor)</code></pre><p>沿给定<code>dim</code>维度返回输入张量<code>input</code>中 <code>k</code> 个最大值。 如果不指定<code>dim</code>，则默认为<code>input</code>的最后一维。 如果为<code>largest</code>为 <code>False</code> ，则返回最小的 <code>k</code> 个值。</p><p>返回一个元组 <em>(values,indices)</em>，其中<code>indices</code>是原始输入张量<code>input</code>中测元素下标。 如果设定布尔值<code>sorted</code> 为_True_，将会确保返回的 <code>k</code> 个值被排序。</p><p>参数:</p><ul><li>input (Tensor) – 输入张量</li><li>k (int) – “top-k”中的<code>k</code></li><li>dim (int, optional) – 排序的维</li><li>largest (bool, optional) – 布尔值，控制返回最大或最小值</li><li>sorted (bool, optional) – 布尔值，控制返回值是否排序</li><li>out (tuple, optional) – 可选输出张量 (Tensor, LongTensor) output buffers</li></ul><pre><code>&gt;&gt;&gt; x = torch.arange(1, 6)&gt;&gt;&gt; x 1 2 3 4 5[torch.FloatTensor of size 5]&gt;&gt;&gt; torch.topk(x, 3)( 5 4 3[torch.FloatTensor of size 3], 4 3 2[torch.LongTensor of size 3])&gt;&gt;&gt; torch.topk(x, 3, 0, largest=False)( 1 2 3[torch.FloatTensor of size 3], 0 1 2[torch.LongTensor of size 3])</code></pre><h2 id="其它操作-Other-Operations"><a href="#其它操作-Other-Operations" class="headerlink" title="其它操作 Other Operations"></a>其它操作 Other Operations</h2><h3 id="torch-cross"><a href="#torch-cross" class="headerlink" title="torch.cross"></a>torch.cross</h3><pre><code>torch.cross(input, other, dim=-1, out=None) → Tensor</code></pre><p>返回沿着维度<code>dim</code>上，两个张量<code>input</code>和<code>other</code>的向量积（叉积）。 <code>input</code>和<code>other</code> 必须有相同的形状，且指定的<code>dim</code>维上size必须为<code>3</code>。</p><p>如果不指定<code>dim</code>，则默认为第一个尺度为<code>3</code>的维。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>other (Tensor) – 第二个输入张量</li><li>dim (int, optional) – 沿着此维进行叉积操作</li><li>out (Tensor,optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(4, 3)&gt;&gt;&gt; a-0.6652 -1.0116 -0.6857 0.2286  0.4446 -0.5272 0.0476  0.2321  1.9991 0.6199  1.1924 -0.9397[torch.FloatTensor of size 4x3]&gt;&gt;&gt; b = torch.randn(4, 3)&gt;&gt;&gt; b-0.1042 -1.1156  0.1947 0.9947  0.1149  0.4701-1.0108  0.8319 -0.0750 0.9045 -1.3754  1.0976[torch.FloatTensor of size 4x3]&gt;&gt;&gt; torch.cross(a, b, dim=1)-0.9619  0.2009  0.6367 0.2696 -0.6318 -0.4160-1.6805 -2.0171  0.2741 0.0163 -1.5304 -1.9311[torch.FloatTensor of size 4x3]&gt;&gt;&gt; torch.cross(a, b)-0.9619  0.2009  0.6367 0.2696 -0.6318 -0.4160-1.6805 -2.0171  0.2741 0.0163 -1.5304 -1.9311[torch.FloatTensor of size 4x3]</code></pre><h3 id="torch-diag"><a href="#torch-diag" class="headerlink" title="torch.diag"></a>torch.diag</h3><pre><code>torch.diag(input, diagonal=0, out=None) → Tensor</code></pre><ul><li>如果输入是一个向量(1D 张量)，则返回一个以<code>input</code>为对角线元素的2D方阵</li><li>如果输入是一个矩阵(2D 张量)，则返回一个包含<code>input</code>对角线元素的1D张量</li></ul><p>参数<code>diagonal</code>指定对角线:</p><ul><li><code>diagonal</code> = 0, 主对角线</li><li><code>diagonal</code> &gt; 0, 主对角线之上</li><li><code>diagonal</code> &lt; 0, 主对角线之下</li></ul><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>diagonal (int, optional) – 指定对角线</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><ul><li>取得以<code>input</code>为对角线的方阵：</li></ul><pre><code>&gt;&gt;&gt; a = torch.randn(3)&gt;&gt;&gt; a 1.0480-2.3405-1.1138[torch.FloatTensor of size 3]&gt;&gt;&gt; torch.diag(a) 1.0480  0.0000  0.0000 0.0000 -2.3405  0.0000 0.0000  0.0000 -1.1138[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.diag(a, 1) 0.0000  1.0480  0.0000  0.0000 0.0000  0.0000 -2.3405  0.0000 0.0000  0.0000  0.0000 -1.1138 0.0000  0.0000  0.0000  0.0000[torch.FloatTensor of size 4x4]</code></pre><ul><li>取得给定矩阵第<code>k</code>个对角线:</li></ul><pre><code>&gt;&gt;&gt; a = torch.randn(3, 3)&gt;&gt;&gt; a-1.5328 -1.3210 -1.5204 0.8596  0.0471 -0.2239-0.6617  0.0146 -1.0817[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.diag(a, 0)-1.5328 0.0471-1.0817[torch.FloatTensor of size 3]&gt;&gt;&gt; torch.diag(a, 1)-1.3210-0.2239[torch.FloatTensor of size 2]</code></pre><h3 id="torch-histc"><a href="#torch-histc" class="headerlink" title="torch.histc"></a>torch.histc</h3><pre><code>torch.histc(input, bins=100, min=0, max=0, out=None) → Tensor</code></pre><p>计算输入张量的直方图。以<code>min</code>和<code>max</code>为range边界，将其均分成<code>bins</code>个直条，然后将排序好的数据划分到各个直条(bins)中。如果<code>min</code>和<code>max</code>都为0, 则利用数据中的最大最小值作为边界。</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>bins (int) – 直方图 bins(直条)的个数(默认100个)</li><li>min (int) – range的下边界(包含)</li><li>max (int) – range的上边界(包含)</li><li>out (Tensor, optional) – 结果张量</li></ul><p>返回： 直方图 返回类型：张量</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.histc(torch.FloatTensor([1, 2, 1]), bins=4, min=0, max=3)FloatTensor([0, 2, 1, 0])</code></pre><h3 id="torch-renorm"><a href="#torch-renorm" class="headerlink" title="torch.renorm"></a>torch.renorm</h3><pre><code>torch.renorm(input, p, dim, maxnorm, out=None) → Tensor</code></pre><p>返回一个张量，包含规范化后的各个子张量，使得沿着<code>dim</code>维划分的各子张量的p范数小于<code>maxnorm</code>。</p><p><strong>注意</strong> 如果p范数的值小于<code>maxnorm</code>，则当前子张量不需要修改。</p><p><strong>注意</strong>: 更详细解释参考<a href="http://torch7.readthedocs.io/en/rtd/maths/" target="_blank" rel="noopener">torch7</a> 以及<a href="https://arxiv.org/pdf/1207.0580.pdf" target="_blank" rel="noopener">Hinton et al. 2012, p. 2</a></p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>p (float) – 范数的p</li><li>dim (int) – 沿着此维切片，得到张量子集</li><li>maxnorm (float) – 每个子张量的范数的最大值</li><li>out (Tensor, optional) – 结果张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.ones(3, 3)&gt;&gt;&gt; x[1].fill_(2)&gt;&gt;&gt; x[2].fill_(3)&gt;&gt;&gt; x 1  1  1 2  2  2 3  3  3[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.renorm(x, 1, 0, 5) 1.0000  1.0000  1.0000 1.6667  1.6667  1.6667 1.6667  1.6667  1.6667[torch.FloatTensor of size 3x3]</code></pre><h3 id="torch-trace"><a href="#torch-trace" class="headerlink" title="torch.trace"></a>torch.trace</h3><pre><code>torch.trace(input) → float</code></pre><p>返回输入2维矩阵对角线元素的和(迹)</p><p>例子：</p><pre><code>&gt;&gt;&gt; x = torch.arange(1, 10).view(3, 3)&gt;&gt;&gt; x 1  2  3 4  5  6 7  8  9[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.trace(x)15.0</code></pre><h3 id="torch-tril"><a href="#torch-tril" class="headerlink" title="torch.tril"></a>torch.tril</h3><pre><code>torch.tril(input, k=0, out=None) → Tensor</code></pre><p>返回一个张量<code>out</code>，包含输入矩阵(2D张量)的下三角部分，<code>out</code>其余部分被设为<code>0</code>。这里所说的下三角部分为矩阵指定对角线<code>diagonal</code>之上的元素。</p><p>参数<code>k</code>控制对角线: - <code>k</code> = 0, 主对角线 - <code>k</code> &gt; 0, 主对角线之上 - <code>k</code> &lt; 0, 主对角线之下</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>k (int, optional) – 指定对角线</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(3,3)&gt;&gt;&gt; a 1.3225  1.7304  1.4573-0.3052 -0.3111 -0.1809 1.2469  0.0064 -1.6250[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.tril(a) 1.3225  0.0000  0.0000-0.3052 -0.3111  0.0000 1.2469  0.0064 -1.6250[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.tril(a, k=1) 1.3225  1.7304  0.0000-0.3052 -0.3111 -0.1809 1.2469  0.0064 -1.6250[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.tril(a, k=-1) 0.0000  0.0000  0.0000-0.3052  0.0000  0.0000 1.2469  0.0064  0.0000[torch.FloatTensor of size 3x3]</code></pre><h3 id="torch-triu"><a href="#torch-triu" class="headerlink" title="torch.triu"></a>torch.triu</h3><pre><code>torch.triu(input, k=0, out=None) → Tensor</code></pre><p>返回一个张量，包含输入矩阵(2D张量)的上三角部分，其余部分被设为<code>0</code>。这里所说的上三角部分为矩阵指定对角线<code>diagonal</code>之上的元素。</p><p>参数<code>k</code>控制对角线: - <code>k</code> = 0, 主对角线 - <code>k</code> &gt; 0, 主对角线之上 - <code>k</code> &lt; 0, 主对角线之下</p><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>k (int, optional) – 指定对角线</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.randn(3,3)&gt;&gt;&gt; a 1.3225  1.7304  1.4573-0.3052 -0.3111 -0.1809 1.2469  0.0064 -1.6250[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.triu(a) 1.3225  1.7304  1.4573 0.0000 -0.3111 -0.1809 0.0000  0.0000 -1.6250[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.triu(a, k=1) 0.0000  1.7304  1.4573 0.0000  0.0000 -0.1809 0.0000  0.0000  0.0000[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.triu(a, k=-1) 1.3225  1.7304  1.4573-0.3052 -0.3111 -0.1809 0.0000  0.0064 -1.6250[torch.FloatTensor of size 3x3]</code></pre><h2 id="BLAS-and-LAPACK-Operations"><a href="#BLAS-and-LAPACK-Operations" class="headerlink" title="BLAS and LAPACK Operations"></a>BLAS and LAPACK Operations</h2><h3 id="torch-addbmm"><a href="#torch-addbmm" class="headerlink" title="torch.addbmm"></a>torch.addbmm</h3><pre><code>torch.addbmm(beta=1, mat, alpha=1, batch1, batch2, out=None) → Tensor</code></pre><p>对类型为 <em>FloatTensor</em> 或 <em>DoubleTensor</em> 的输入，<code>alpha</code>and <code>beta</code>必须为实数，否则两个参数须为整数。</p><p>参数：</p><ul><li>beta (Number, optional) – 用于<code>mat</code>的乘子</li><li>mat (Tensor) – 相加矩阵</li><li>batch1 (Tensor) – 第一批相乘矩阵</li><li>batch2 (Tensor) – 第二批相乘矩阵</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; M = torch.randn(3, 5)&gt;&gt;&gt; batch1 = torch.randn(10, 3, 4)&gt;&gt;&gt; batch2 = torch.randn(10, 4, 5)&gt;&gt;&gt; torch.addbmm(M, batch1, batch2) -3.1162  11.0071   7.3102   0.1824  -7.6892  1.8265   6.0739   0.4589  -0.5641  -5.4283 -9.3387  -0.1794  -1.2318  -6.8841  -4.7239[torch.FloatTensor of size 3x5]</code></pre><h3 id="torch-addmm"><a href="#torch-addmm" class="headerlink" title="torch.addmm"></a>torch.addmm</h3><pre><code>torch.addmm(beta=1, mat, alpha=1, mat1, mat2, out=None) → Tensor</code></pre><p>对类型为 <em>FloatTensor</em> 或 <em>DoubleTensor</em> 的输入，<code>beta</code>and <code>alpha</code>必须为实数，否则两个参数须为整数。</p><p>参数 ：</p><ul><li><p>beta (Number, optional) – 用于<code>mat</code>的乘子</p></li><li><p>mat (Tensor) – 相加矩阵</p></li><li><p>mat1 (Tensor) – 第一个相乘矩阵</p></li><li><p>mat2 (Tensor) – 第二个相乘矩阵</p></li><li><p>out (Tensor, optional) – 输出张量</p></li></ul><pre><code>&gt;&gt;&gt; M = torch.randn(2, 3)&gt;&gt;&gt; mat1 = torch.randn(2, 3)&gt;&gt;&gt; mat2 = torch.randn(3, 3)&gt;&gt;&gt; torch.addmm(M, mat1, mat2)-0.4095 -1.9703  1.3561 5.7674 -4.9760  2.7378[torch.FloatTensor of size 2x3]</code></pre><h3 id="torch-addmv"><a href="#torch-addmv" class="headerlink" title="torch.addmv"></a>torch.addmv</h3><pre><code>torch.addmv(beta=1, tensor, alpha=1, mat, vec, out=None) → Tensor</code></pre><p>对类型为_FloatTensor_或_DoubleTensor_的输入，<code>alpha</code>and <code>beta</code>必须为实数，否则两个参数须为整数。</p><p>参数 ：</p><ul><li>beta (Number, optional) – 用于<code>mat</code>的乘子</li><li>mat (Tensor) – 相加矩阵</li><li>mat (Tensor) – 相乘矩阵</li><li>vec (Tensor) – 相乘向量</li><li>out (Tensor, optional) – 输出张量</li></ul><pre><code>&gt;&gt;&gt; M = torch.randn(2)&gt;&gt;&gt; mat = torch.randn(2, 3)&gt;&gt;&gt; vec = torch.randn(3)&gt;&gt;&gt; torch.addmv(M, mat, vec)-2.0939-2.2950[torch.FloatTensor of size 2]</code></pre><h3 id="torch-addr"><a href="#torch-addr" class="headerlink" title="torch.addr"></a>torch.addr</h3><pre><code>torch.addr(beta=1, mat, alpha=1, vec1, vec2, out=None) → Tensor</code></pre><p>对类型为_FloatTensor_或_DoubleTensor_的输入，<code>alpha</code>and <code>beta</code>必须为实数，否则两个参数须为整数。</p><p>参数 ：</p><ul><li>beta (Number, optional) – 用于<code>mat</code>的乘子</li><li>mat (Tensor) – 相加矩阵</li><li>vec1 (Tensor) – 第一个相乘向量</li><li>vec2 (Tensor) – 第二个相乘向量</li><li>out (Tensor, optional) – 输出张量</li></ul><pre><code>&gt;&gt;&gt; vec1 = torch.arange(1, 4)&gt;&gt;&gt; vec2 = torch.arange(1, 3)&gt;&gt;&gt; M = torch.zeros(3, 2)&gt;&gt;&gt; torch.addr(M, vec1, vec2) 1  2 2  4 3  6[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-baddbmm"><a href="#torch-baddbmm" class="headerlink" title="torch.baddbmm"></a>torch.baddbmm</h3><pre><code>torch.baddbmm(beta=1, mat, alpha=1, batch1, batch2, out=None) → Tensor</code></pre><p>对类型为_FloatTensor_或_DoubleTensor_的输入，<code>alpha</code>and <code>beta</code>必须为实数，否则两个参数须为整数。</p><p>参数：</p><ul><li>beta (Number, optional) – 用于<code>mat</code>的乘子</li><li>mat (Tensor) – 相加矩阵</li><li>batch1 (Tensor) – 第一批相乘矩阵</li><li>batch2 (Tensor) – 第二批相乘矩阵</li><li>out (Tensor, optional) – 输出张量</li></ul><pre><code>&gt;&gt;&gt; M = torch.randn(10, 3, 5)&gt;&gt;&gt; batch1 = torch.randn(10, 3, 4)&gt;&gt;&gt; batch2 = torch.randn(10, 4, 5)&gt;&gt;&gt; torch.baddbmm(M, batch1, batch2).size()torch.Size([10, 3, 5])</code></pre><h3 id="torch-bmm"><a href="#torch-bmm" class="headerlink" title="torch.bmm"></a>torch.bmm</h3><pre><code>torch.bmm(batch1, batch2, out=None) → Tensor</code></pre><p>对类型为 <em>FloatTensor</em> 或 <em>DoubleTensor</em> 的输入，<code>alpha</code>and <code>beta</code>必须为实数，否则两个参数须为整数。</p><p>参数：</p><ul><li>batch1 (Tensor) – 第一批相乘矩阵</li><li>batch2 (Tensor) – 第二批相乘矩阵</li><li>out (Tensor, optional) – 输出张量</li></ul><pre><code>&gt;&gt;&gt; batch1 = torch.randn(10, 3, 4)&gt;&gt;&gt; batch2 = torch.randn(10, 4, 5)&gt;&gt;&gt; res = torch.bmm(batch1, batch2)&gt;&gt;&gt; res.size()torch.Size([10, 3, 5])</code></pre><h3 id="torch-btrifact"><a href="#torch-btrifact" class="headerlink" title="torch.btrifact"></a>torch.btrifact</h3><pre><code>torch.btrifact(A, info=None) → Tensor, IntTensor</code></pre><p>返回一个元组，包含LU 分解和<code>pivots</code> 。 可选参数<code>info</code>决定是否对每个minibatch样本进行分解。<code>info</code> are from dgetrf and a non-zero value indicates an error occurred. 如果用CUDA的话，这个值来自于CUBLAS，否则来自LAPACK。</p><p>参数： A (Tensor) – 待分解张量</p><pre><code>&gt;&gt;&gt; A = torch.randn(2, 3, 3)&gt;&gt;&gt; A_LU = A.btrifact()</code></pre><h3 id="torch-btrisolve"><a href="#torch-btrisolve" class="headerlink" title="torch.btrisolve"></a>torch.btrisolve</h3><pre><code>torch.btrisolve(b, LU_data, LU_pivots) → Tensor</code></pre><p>参数：</p><ul><li>b (Tensor) – RHS 张量.</li><li>LU_data (Tensor) – Pivoted LU factorization of A from btrifact.</li><li>LU_pivots (IntTensor) – LU 分解的Pivots.</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; A = torch.randn(2, 3, 3)&gt;&gt;&gt; b = torch.randn(2, 3)&gt;&gt;&gt; A_LU = torch.btrifact(A)&gt;&gt;&gt; x = b.btrisolve(*A_LU)&gt;&gt;&gt; torch.norm(A.bmm(x.unsqueeze(2)) - b)6.664001874625056e-08</code></pre><h3 id="torch-dot"><a href="#torch-dot" class="headerlink" title="torch.dot"></a>torch.dot</h3><pre><code>torch.dot(tensor1, tensor2) → float</code></pre><p>计算两个张量的点乘(内乘),两个张量都为1-D 向量.</p><p>例子：</p><pre><code>&gt;&gt;&gt; torch.dot(torch.Tensor([2, 3]), torch.Tensor([2, 1]))7.0</code></pre><h3 id="torch-eig"><a href="#torch-eig" class="headerlink" title="torch.eig"></a>torch.eig</h3><pre><code>torch.eig(a, eigenvectors=False, out=None) -&gt; (Tensor, Tensor)</code></pre><p>计算实方阵<code>a</code> 的特征值和特征向量</p><p>参数：</p><ul><li>a (Tensor) – 方阵，待计算其特征值和特征向量</li><li>eigenvectors (bool) – 布尔值，如果<code>True</code>，则同时计算特征值和特征向量，否则只计算特征值。</li><li>out (tuple, optional) – 输出元组</li></ul><p>返回值： 元组，包括：</p><ul><li>e (Tensor): a 的右特征向量</li><li>v (Tensor): 如果<code>eigenvectors</code>为<code>True</code>，则为包含特征向量的张量; 否则为空张量</li></ul><p>返回值类型： (Tensor, Tensor)</p><h3 id="torch-gels"><a href="#torch-gels" class="headerlink" title="torch.gels"></a>torch.gels</h3><pre><code>torch.gels(B, A, out=None) → Tensor</code></pre><p>注意： 返回矩阵总是被转置，无论输入矩阵的原始布局如何，总会被转置；即，总是有 stride (1, m) 而不是 (m, 1).</p><p>参数：</p><ul><li>B (Tensor) – 矩阵B</li><li>out (tuple, optional) – 输出元组</li></ul><p>返回值： 元组，包括：</p><ul><li>X (Tensor): 最小二乘解</li><li>qr (Tensor): QR 分解的细节</li></ul><p>返回值类型： (Tensor, Tensor)</p><p>例子：</p><pre><code>&gt;&gt;&gt; A = torch.Tensor([[1, 1, 1],...                   [2, 3, 4],...                   [3, 5, 2],...                   [4, 2, 5],...                   [5, 4, 3]])&gt;&gt;&gt; B = torch.Tensor([[-10, -3],                      [ 12, 14],                      [ 14, 12],                      [ 16, 16],                      [ 18, 16]])&gt;&gt;&gt; X, _ = torch.gels(B, A)&gt;&gt;&gt; X2.0000  1.00001.0000  1.00001.0000  2.0000[torch.FloatTensor of size 3x2]</code></pre><h3 id="torch-geqrf"><a href="#torch-geqrf" class="headerlink" title="torch.geqrf"></a>torch.geqrf</h3><pre><code>torch.geqrf(input, out=None) -&gt; (Tensor, Tensor)</code></pre><p>这是一个直接调用LAPACK的底层函数。 一般使用<code>torch.qr()</code></p><p>计算输入的QR 分解，但是并不会分别创建Q,R两个矩阵，而是直接调用LAPACK 函数 Rather, this directly calls the underlying LAPACK function ?geqrf which produces a sequence of ‘elementary reflectors’.</p><p>参考 <a href="https://software.intel.com/en-us/node/521004" target="_blank" rel="noopener">LAPACK文档</a>获取更详细信息。</p><p>参数:</p><ul><li>input (Tensor) – 输入矩阵</li><li>out (tuple, optional) – 元组，包含输出张量 (Tensor, Tensor)</li></ul><h3 id="torch-ger"><a href="#torch-ger" class="headerlink" title="torch.ger"></a>torch.ger</h3><pre><code>torch.ger(vec1, vec2, out=None) → Tensor</code></pre><p>计算两向量<code>vec1</code>,<code>vec2</code>的张量积。如果<code>vec1</code>的长度为<code>n</code>,<code>vec2</code>长度为<code>m</code>，则输出<code>out</code>应为形如n x m的矩阵。</p><p>参数:</p><ul><li>vec1 (Tensor) – 1D 输入向量</li><li>vec2 (Tensor) – 1D 输入向量</li><li>out (tuple, optional) – 输出张量</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; v1 = torch.arange(1, 5)&gt;&gt;&gt; v2 = torch.arange(1, 4)&gt;&gt;&gt; torch.ger(v1, v2)  1   2   3  2   4   6  3   6   9  4   8  12[torch.FloatTensor of size 4x3]</code></pre><h3 id="torch-gesv"><a href="#torch-gesv" class="headerlink" title="torch.gesv"></a>torch.gesv</h3><pre><code>torch.gesv(B, A, out=None) -&gt; (Tensor, Tensor)</code></pre><p>例子:</p><pre><code>&gt;&gt;&gt; A = torch.Tensor([[6.80, -2.11,  5.66,  5.97,  8.23],...                   [-6.05, -3.30,  5.36, -4.44,  1.08],...                   [-0.45,  2.58, -2.70,  0.27,  9.04],...                   [8.32,  2.71,  4.35,  -7.17,  2.14],...                   [-9.67, -5.14, -7.26,  6.08, -6.87]]).t()&gt;&gt;&gt; B = torch.Tensor([[4.02,  6.19, -8.22, -7.57, -3.03],...                   [-1.56,  4.00, -8.67,  1.75,  2.86],...                   [9.81, -4.09, -4.57, -8.61,  8.99]]).t()&gt;&gt;&gt; X, LU = torch.gesv(B, A)&gt;&gt;&gt; torch.dist(B, torch.mm(A, X))9.250057093890353e-06</code></pre><h3 id="torch-inverse"><a href="#torch-inverse" class="headerlink" title="torch.inverse"></a>torch.inverse</h3><pre><code>torch.inverse(input, out=None) → Tensor</code></pre><p>对方阵输入<code>input</code> 取逆。</p><p><em>注意</em> ： Irrespective of the original strides, the returned matrix will be transposed, i.e. with strides (1, m) instead of (m, 1)</p><p>参数 ：</p><ul><li>input (Tensor) – 输入2维张量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; x = torch.rand(10, 10)&gt;&gt;&gt; x 0.7800  0.2267  0.7855  0.9479  0.5914  0.7119  0.4437  0.9131  0.1289  0.1982 0.0045  0.0425  0.2229  0.4626  0.6210  0.0207  0.6338  0.7067  0.6381  0.8196 0.8350  0.7810  0.8526  0.9364  0.7504  0.2737  0.0694  0.5899  0.8516  0.3883 0.6280  0.6016  0.5357  0.2936  0.7827  0.2772  0.0744  0.2627  0.6326  0.9153 0.7897  0.0226  0.3102  0.0198  0.9415  0.9896  0.3528  0.9397  0.2074  0.6980 0.5235  0.6119  0.6522  0.3399  0.3205  0.5555  0.8454  0.3792  0.4927  0.6086 0.1048  0.0328  0.5734  0.6318  0.9802  0.4458  0.0979  0.3320  0.3701  0.0909 0.2616  0.3485  0.4370  0.5620  0.5291  0.8295  0.7693  0.1807  0.0650  0.8497 0.1655  0.2192  0.6913  0.0093  0.0178  0.3064  0.6715  0.5101  0.2561  0.3396 0.4370  0.4695  0.8333  0.1180  0.4266  0.4161  0.0699  0.4263  0.8865  0.2578[torch.FloatTensor of size 10x10]&gt;&gt;&gt; x = torch.rand(10, 10)&gt;&gt;&gt; y = torch.inverse(x)&gt;&gt;&gt; z = torch.mm(x, y)&gt;&gt;&gt; z 1.0000  0.0000  0.0000 -0.0000  0.0000  0.0000  0.0000  0.0000 -0.0000 -0.0000 0.0000  1.0000 -0.0000  0.0000  0.0000  0.0000 -0.0000 -0.0000 -0.0000 -0.0000 0.0000  0.0000  1.0000 -0.0000 -0.0000  0.0000  0.0000  0.0000 -0.0000 -0.0000 0.0000  0.0000  0.0000  1.0000  0.0000  0.0000  0.0000 -0.0000 -0.0000  0.0000 0.0000  0.0000 -0.0000 -0.0000  1.0000  0.0000  0.0000 -0.0000 -0.0000 -0.0000 0.0000  0.0000  0.0000 -0.0000  0.0000  1.0000 -0.0000 -0.0000 -0.0000 -0.0000 0.0000  0.0000  0.0000 -0.0000  0.0000  0.0000  1.0000  0.0000 -0.0000  0.0000 0.0000  0.0000 -0.0000 -0.0000  0.0000  0.0000 -0.0000  1.0000 -0.0000  0.0000-0.0000  0.0000 -0.0000 -0.0000  0.0000  0.0000 -0.0000 -0.0000  1.0000 -0.0000-0.0000  0.0000 -0.0000 -0.0000 -0.0000  0.0000 -0.0000 -0.0000  0.0000  1.0000[torch.FloatTensor of size 10x10]&gt;&gt;&gt; torch.max(torch.abs(z - torch.eye(10))) # Max nonzero5.096662789583206e-07</code></pre><h3 id="torch-mm"><a href="#torch-mm" class="headerlink" title="torch.mm"></a>torch.mm</h3><pre><code>torch.mm(mat1, mat2, out=None) → Tensor</code></pre><p>参数 ：</p><ul><li>mat1 (Tensor) – 第一个相乘矩阵</li><li>mat2 (Tensor) – 第二个相乘矩阵</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; mat1 = torch.randn(2, 3)&gt;&gt;&gt; mat2 = torch.randn(3, 3)&gt;&gt;&gt; torch.mm(mat1, mat2) 0.0519 -0.3304  1.2232 4.3910 -5.1498  2.7571[torch.FloatTensor of size 2x3]</code></pre><h3 id="torch-mv"><a href="#torch-mv" class="headerlink" title="torch.mv"></a>torch.mv</h3><pre><code>torch.mv(mat, vec, out=None) → Tensor</code></pre><p>参数 ：</p><ul><li>mat (Tensor) – 相乘矩阵</li><li>vec (Tensor) – 相乘向量</li><li>out (Tensor, optional) – 输出张量</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; mat = torch.randn(2, 3)&gt;&gt;&gt; vec = torch.randn(3)&gt;&gt;&gt; torch.mv(mat, vec)-2.0939-2.2950[torch.FloatTensor of size 2]</code></pre><h3 id="torch-orgqr"><a href="#torch-orgqr" class="headerlink" title="torch.orgqr"></a>torch.orgqr</h3><pre><code>torch.orgqr()</code></pre><h3 id="torch-ormqr"><a href="#torch-ormqr" class="headerlink" title="torch.ormqr"></a>torch.ormqr</h3><pre><code>torch.ormqr()</code></pre><h3 id="torch-potrf"><a href="#torch-potrf" class="headerlink" title="torch.potrf"></a>torch.potrf</h3><pre><code>torch.potrf()</code></pre><h3 id="torch-potri"><a href="#torch-potri" class="headerlink" title="torch.potri"></a>torch.potri</h3><pre><code>torch.potri()</code></pre><h3 id="torch-potrs"><a href="#torch-potrs" class="headerlink" title="torch.potrs"></a>torch.potrs</h3><pre><code>torch.potrs()</code></pre><h3 id="torch-pstrf"><a href="#torch-pstrf" class="headerlink" title="torch.pstrf"></a>torch.pstrf</h3><pre><code>torch.pstrf()</code></pre><h3 id="torch-qr"><a href="#torch-qr" class="headerlink" title="torch.qr"></a>torch.qr</h3><pre><code>torch.qr(input, out=None) -&gt; (Tensor, Tensor)</code></pre><p>本函数返回一个thin(reduced)QR分解。</p><p><strong>注意</strong> 如果输入很大，可能可能会丢失精度。</p><p><strong>注意</strong> 本函数依赖于你的LAPACK实现，虽然总能返回一个合法的分解，但不同平台可能得到不同的结果。</p><p>Irrespective of the original strides, the returned matrix q will be transposed, i.e. with strides (1, m) instead of (m, 1).</p><p>参数：</p><ul><li>input (Tensor) – 输入的2维张量</li><li>out (tuple, optional) – 输出元组<code>tuple</code>，包含Q和R</li></ul><p>例子:</p><pre><code>&gt;&gt;&gt; a = torch.Tensor([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])&gt;&gt;&gt; q, r = torch.qr(a)&gt;&gt;&gt; q-0.8571  0.3943  0.3314-0.4286 -0.9029 -0.0343 0.2857 -0.1714  0.9429[torch.FloatTensor of size 3x3]&gt;&gt;&gt; r -14.0000  -21.0000   14.0000   0.0000 -175.0000   70.0000   0.0000    0.0000  -35.0000[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.mm(q, r).round()  12  -51    4   6  167  -68  -4   24  -41[torch.FloatTensor of size 3x3]&gt;&gt;&gt; torch.mm(q.t(), q).round() 1 -0  0-0  1  0 0  0  1[torch.FloatTensor of size 3x3]</code></pre><h3 id="torch-svd"><a href="#torch-svd" class="headerlink" title="torch.svd"></a>torch.svd</h3><pre><code>torch.svd(input, some=True, out=None) -&gt; (Tensor, Tensor, Tensor)</code></pre><p><code>some</code> 代表了需要计算的奇异值数目。如果 <code>some=True</code>, it computes some and some=False computes all.</p><p>Irrespective of the original strides, the returned matrix U will be transposed, i.e. with strides (1, n) instead of (n, 1).</p><p>参数：</p><ul><li>input (Tensor) – 输入的2维张量</li><li>some (bool, optional) – 布尔值，控制需计算的奇异值数目</li><li>out (tuple, optional) – 结果<code>tuple</code></li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.Tensor([[8.79,  6.11, -9.15,  9.57, -3.49,  9.84],...                   [9.93,  6.91, -7.93,  1.64,  4.02,  0.15],...                   [9.83,  5.04,  4.86,  8.83,  9.80, -8.99],...                   [5.45, -0.27,  4.85,  0.74, 10.00, -6.02],...                   [3.16,  7.98,  3.01,  5.80,  4.27, -5.31]]).t()&gt;&gt;&gt; a  8.7900   9.9300   9.8300   5.4500   3.1600  6.1100   6.9100   5.0400  -0.2700   7.9800 -9.1500  -7.9300   4.8600   4.8500   3.0100  9.5700   1.6400   8.8300   0.7400   5.8000 -3.4900   4.0200   9.8000  10.0000   4.2700  9.8400   0.1500  -8.9900  -6.0200  -5.3100[torch.FloatTensor of size 6x5]&gt;&gt;&gt; u, s, v = torch.svd(a)&gt;&gt;&gt; u-0.5911  0.2632  0.3554  0.3143  0.2299-0.3976  0.2438 -0.2224 -0.7535 -0.3636-0.0335 -0.6003 -0.4508  0.2334 -0.3055-0.4297  0.2362 -0.6859  0.3319  0.1649-0.4697 -0.3509  0.3874  0.1587 -0.5183 0.2934  0.5763 -0.0209  0.3791 -0.6526[torch.FloatTensor of size 6x5]&gt;&gt;&gt; s 27.4687 22.6432  8.5584  5.9857  2.0149[torch.FloatTensor of size 5]&gt;&gt;&gt; v-0.2514  0.8148 -0.2606  0.3967 -0.2180-0.3968  0.3587  0.7008 -0.4507  0.1402-0.6922 -0.2489 -0.2208  0.2513  0.5891-0.3662 -0.3686  0.3859  0.4342 -0.6265-0.4076 -0.0980 -0.4932 -0.6227 -0.4396[torch.FloatTensor of size 5x5]&gt;&gt;&gt; torch.dist(a, torch.mm(torch.mm(u, torch.diag(s)), v.t()))8.934150226306685e-06</code></pre><h3 id="torch-symeig"><a href="#torch-symeig" class="headerlink" title="torch.symeig"></a>torch.symeig</h3><pre><code>torch.symeig(input, eigenvectors=False, upper=True, out=None) -&gt; (Tensor, Tensor)</code></pre><p><strong>注意</strong>: 不管原来Irrespective of the original strides, the returned matrix V will be transposed, i.e. with strides (1, m) instead of (m, 1)</p><p>参数：</p><ul><li>input (Tensor) – 输入对称矩阵</li><li>eigenvectors (boolean, optional) – 布尔值（可选），控制是否计算特征向量</li><li>upper (boolean, optional) – 布尔值（可选），控制是否考虑上三角或下三角区域</li><li>out (tuple, optional) – 输出元组(Tensor, Tensor)</li></ul><p>例子：</p><pre><code>&gt;&gt;&gt; a = torch.Tensor([[ 1.96,  0.00,  0.00,  0.00,  0.00],...                   [-6.49,  3.80,  0.00,  0.00,  0.00],...                   [-0.47, -6.39,  4.17,  0.00,  0.00],...                   [-7.20,  1.50, -1.51,  5.70,  0.00],...                   [-0.65, -6.34,  2.67,  1.80, -7.10]]).t()&gt;&gt;&gt; e, v = torch.symeig(a, eigenvectors=True)&gt;&gt;&gt; e-11.0656 -6.2287  0.8640  8.8655 16.0948[torch.FloatTensor of size 5]&gt;&gt;&gt; v-0.2981 -0.6075  0.4026 -0.3745  0.4896-0.5078 -0.2880 -0.4066 -0.3572 -0.6053-0.0816 -0.3843 -0.6600  0.5008  0.3991-0.0036 -0.4467  0.4553  0.6204 -0.4564-0.8041  0.4480  0.1725  0.3108  0.1622[torch.FloatTensor of size 5x5]</code></pre><h3 id="torch-trtrs"><a href="#torch-trtrs" class="headerlink" title="torch.trtrs"></a>torch.trtrs</h3><pre><code> torch.trtrs()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-关键词动态爬取图片保存于本地</title>
      <link href="/posts/blog-python10.html"/>
      <url>/posts/blog-python10.html</url>
      
        <content type="html"><![CDATA[<h1 id="利用关键词动态爬取想要的图片"><a href="#利用关键词动态爬取想要的图片" class="headerlink" title="利用关键词动态爬取想要的图片"></a>利用关键词动态爬取想要的图片</h1><h3 id="导入相关库"><a href="#导入相关库" class="headerlink" title="导入相关库"></a>导入相关库</h3><p>主要是requests库</p><pre><code>import re  # 导入正则表达式模块import requests  # python HTTP客户端 编写爬虫和测试服务器经常用到的模块import random  # 随机生成一个数，范围[0,1]import os #创建路径</code></pre><h3 id="写爬虫爬取图片函数"><a href="#写爬虫爬取图片函数" class="headerlink" title="写爬虫爬取图片函数"></a>写爬虫爬取图片函数</h3><pre><code>def spiderPic(html, keyword):       #html：网页；keyword：关键词    print('正在查找 ' + keyword + ' 对应的图片,请稍后......')    for addr in re.findall('"objURL":"(.*?)"', html, re.S):  # 动态查找URL        print('正在爬取URL地址：' + str(addr)[0:40] + '...')  # 爬取的地址长度超过40时，用'...'代替后面的内容        try:            pics = requests.get(addr, timeout=10)  # 请求URL时间（最大10秒）        except requests.exceptions.ConnectionError:            print('您当前请求的URL地址出现错误')            continue        fq = open('E:\\img\\' + (keyword + '_' + str(random.randrange(0, 1000, 4)) + '.jpg'), 'wb')  # 下载图片，并保存和命名        fq.write(pics.content)        fq.close()</code></pre><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><pre><code>if __name__ == '__main__':    word = input('请输入你要搜索的图片关键字：')    result = requests.get(        # 通过百度引擎搜索关键词链接        'http://image.baidu.com/search/index?tn=baiduimage&amp;ps=1&amp;ct=201326592&amp;lm=-1&amp;cl=2&amp;nc=1&amp;ie=utf-8&amp;word=' + word)</code></pre><h3 id="存放图片文件夹创建"><a href="#存放图片文件夹创建" class="headerlink" title="存放图片文件夹创建"></a>存放图片文件夹创建</h3><p>加入判断是否存在该文件目录</p><pre><code>path='E:\\img\\';# 判断路径是否存在isExists = os.path.exists(path)### 判断结果if not isExists:    # 如果不存在则创建目录    # 创建目录操作函数    os.makedirs(path)    print    path + '创建成功'else:    # 如果目录存在则不创建，并提示目录已存在    print    path + ' 目录已存在'</code></pre><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><pre><code>spiderPic(result.text, word)</code></pre><h3 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h3><p>我们在输入提示后输入关键词 “风景”并开始爬取图片<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-15547726d83bbca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"><br>爬取的图片在img文件夹中</p><p>源码地址：<a href="https://github.com/JackHCC/KeyWord-Crawler" target="_blank" rel="noopener">https://github.com/JackHCC/KeyWord-Crawler</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-照片墙设计布局爱心形状</title>
      <link href="/posts/blog-python09.html"/>
      <url>/posts/blog-python09.html</url>
      
        <content type="html"><![CDATA[<h1 id="python照片墙设计"><a href="#python照片墙设计" class="headerlink" title="python照片墙设计"></a>python照片墙设计</h1><h3 id="代码规划："><a href="#代码规划：" class="headerlink" title="代码规划："></a>代码规划：</h3><ul><li>将爬虫爬取的图片进行处理，减小尺寸</li><li>将处理好的图片进行照片墙设计<h3 id="图片处理ImageSolve-py-批量处理"><a href="#图片处理ImageSolve-py-批量处理" class="headerlink" title="图片处理ImageSolve.py:批量处理"></a>图片处理ImageSolve.py:批量处理</h3></li><li>导入库：PIL:图像处理；glob<pre><code>from PIL import Imageimport os.pathimport glob</code></pre></li><li>定义ReSize函数：<pre><code>#由于爬虫获取的照片尺寸太大，我们更改爬虫获取的照片尺寸大小def Resize(file, outdir, width, height):  imgFile = Image.open(file)  try:      newImage = imgFile.resize((width, height), Image.BILINEAR)    #更改尺寸      newImage.save(os.path.join(outdir, os.path.basename(file)))     #输出保存图片  except Exception as e:      print(e)</code></pre></li><li>处理后照片的存储<pre><code>for file in glob.glob("res\\*.jpg"):  # 图片所在的目录  Resize(file, "new", 100, 100)  # 新图片存放的目录</code></pre><h3 id="照片墙展示"><a href="#照片墙展示" class="headerlink" title="照片墙展示"></a>照片墙展示</h3></li><li>导入库<pre><code>import sysfrom PyQt5.QtGui import QPixmapfrom PyQt5.QtWidgets import *</code></pre></li><li>Qt窗口基本创建<pre><code>app = QApplication(sys.argv)</code></pre></li></ul><p>win = QWidget()<br>win.resize(760, 540)<br>win.move(0, 0)<br>layout=QGridLayout(win)</p><p>positionSet()<br>win.setWindowTitle(‘GUI’)<br>win.show()</p><pre><code>+ 背景图设置</code></pre><p>b=QLabel(win)<br>b.setPixmap(QPixmap(“bg.jpg”))<br>b.setGeometry(0,0,820,640)</p><pre><code>+ 布局函数</code></pre><p>def positionSet():</p><p>```</p><h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-0d7f2df2852585b1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><p>源码地址：<a href="https://github.com/JackHCC/SlideShow" target="_blank" rel="noopener">https://github.com/JackHCC/SlideShow</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PIL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-机器学习Scikit-learn</title>
      <link href="/posts/blog-python08.html"/>
      <url>/posts/blog-python08.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h1><p><a href="http://sklearn.apachecn.org/#/" target="_blank" rel="noopener">官方中文文档</a></p><h1 id="机器学习方式"><a href="#机器学习方式" class="headerlink" title="机器学习方式"></a>机器学习方式</h1><p>机器学习可以分为以下五个大类：</p><p>(1 )监督学习：从给定的训练数据集中学习出-一个函数，当新的数据到来时，可以根据这个函数预测结果。监督学习的训练集要求是输人和输出，也可以说是特征和目标。训练集中的目标是由人标注的。常见的监督学习算法包括回归与分类。</p><p>(2)无监督学习：无监督学习与监督学习相比，训练集没有人为标注的结果。常见的无监督学习算法有聚类等。</p><p>(3)半监督学习：这是一”种介于监督学习与无监督学习之间的方法。</p><p>(4)迁移学习：将已经训练好的模型参数迁移到新的模型来帮助新模型训练数据集。</p><p>(5)增强学习：通过观察周围环境来学习。每个动作都会对环境有所影响，学习对象根据观察到的周围环境的反馈来做出判断。</p><h1 id="sklearn使用"><a href="#sklearn使用" class="headerlink" title="sklearn使用"></a>sklearn使用</h1><h2 id="1-获取数据"><a href="#1-获取数据" class="headerlink" title="1. 获取数据"></a>1. 获取数据</h2><h3 id="1-1-导入sklearn数据集"><a href="#1-1-导入sklearn数据集" class="headerlink" title="1.1 导入sklearn数据集"></a>1.1 导入sklearn数据集</h3><p>　　sklearn中包含了大量的优质的数据集，在你学习机器学习的过程中，你可以通过使用这些数据集实现出不同的模型，从而提高你的动手实践能力，同时这个过程也可以加深你对理论知识的理解和把握。（这一步我也亟需加强，一起加油！^-^）</p><p>首先呢，要想使用sklearn中的数据集，必须导入datasets模块：</p><pre><code>from sklearn import datasets</code></pre><p> 下图中包含了大部分sklearn中数据集，调用方式也在图中给出，这里我们拿iris的数据来举个例子：</p><p>　　<img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a9d7246ca1e92847.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-c6aff0d49c840280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><pre><code>iris = datasets.load_iris() # 导入数据集X = iris.data # 获得其特征向量y = iris.target # 获得样本label</code></pre><h3 id="1-2-创建数据集"><a href="#1-2-创建数据集" class="headerlink" title="1.2 创建数据集"></a>1.2 创建数据集</h3><p>　　你除了可以使用sklearn自带的数据集，还可以自己去创建训练样本，具体用法参见《<a href="http://scikit-learn.org/stable/datasets/" target="_blank" rel="noopener">Dataset loading utilities</a>》，这里我们简单介绍一些，sklearn中的samples generator包含的大量创建样本数据的方法：</p><p>　　 <img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0253a891a44411bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-257e1464a9a2a74d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>下面我们拿分类问题的样本生成器举例子：</p><pre><code>from sklearn.datasets.samples_generator import make_classificationX, y = make_classification(n_samples=6, n_features=5, n_informative=2,     n_redundant=2, n_classes=2, n_clusters_per_class=2, scale=1.0,     random_state=20) # n_samples：指定样本数 # n_features：指定特征数 # n_classes：指定几分类 # random_state：随机种子，使得随机状可重</code></pre><pre><code>&gt;&gt;&gt; for x_,y_ in zip(X,y): print(y_,end=': ') print(x_)0: [-0.6600737  -0.0558978   0.82286793  1.1003977  -0.93493796] 1: [ 0.4113583   0.06249216 -0.90760075 -1.41296696  2.059838 ] 1: [ 1.52452016 -0.01867812  0.20900899  1.34422289 -1.61299022]0: [-1.25725859  0.02347952 -0.28764782 -1.32091378 -0.88549315]0: [-3.28323172  0.03899168 -0.43251277 -2.86249859 -1.10457948] 1: [ 1.68841011  0.06754955 -1.02805579 -0.83132182  0.93286635]</code></pre><h2 id="2-数据预处理"><a href="#2-数据预处理" class="headerlink" title="2. 数据预处理"></a>2. 数据预处理</h2><p>　　数据预处理阶段是机器学习中不可缺少的一环，它会使得数据更加有效的被模型或者评估器识别。下面我们来看一下sklearn中有哪些平时我们常用的函数：</p><pre><code>from sklearn import preprocessing</code></pre><h3 id="2-1-数据归一化"><a href="#2-1-数据归一化" class="headerlink" title="2.1 数据归一化"></a>2.1 数据归一化</h3><p>　　为了使得训练数据的标准化规则与测试数据的标准化规则同步，preprocessing中提供了很多Scaler：</p><pre><code>data = [[0, 0], [0, 0], [1, 1], [1, 1]] # 1\. 基于mean和std的标准化scaler = preprocessing.StandardScaler().fit(train_data)scaler.transform(train_data)scaler.transform(test_data) # 2\. 将每个特征值归一化到一个固定范围scaler = preprocessing.MinMaxScaler(feature_range=(0, 1)).fit(train_data)scaler.transform(train_data)scaler.transform(test_data) #feature_range: 定义归一化范围，注用（）括起来</code></pre><h3 id="2-2-正则化（normalize）"><a href="#2-2-正则化（normalize）" class="headerlink" title="2.2 正则化（normalize）"></a>2.2 正则化（<code>normalize</code>）</h3><p>　　当你想要计算两个样本的相似度时必不可少的一个操作，就是正则化。其思想是：首先求出样本的p-范数，然后该样本的所有元素都要除以该范数，这样最终使得每个样本的范数都为1。</p><pre><code>&gt;&gt;&gt; X = [[ 1., -1.,  2.],...      [ 2.,  0.,  0.],...      [ 0., 1., -1.]] &gt;&gt;&gt; X_normalized = preprocessing.normalize(X, norm='l2') &gt;&gt;&gt; X_normalized                                      array([[ 0.40..., -0.40...,  0.81...],       [ 1.  ...,  0\.  ...,  0\.  ...],       [ 0\.  ..., 0.70..., -0.70...]])</code></pre><h3 id="2-3-one-hot编码"><a href="#2-3-one-hot编码" class="headerlink" title="2.3 one-hot编码"></a>2.3 one-hot编码</h3><p>　　one-hot编码是一种对离散特征值的编码方式，在LR模型中常用到，用于给线性模型增加非线性能力。</p><pre><code>data = [[0, 0, 3], [1, 1, 0], [0, 2, 1], [1, 0, 2]]encoder = preprocessing.OneHotEncoder().fit(data)enc.transform(data).toarray()</code></pre><h2 id="3-数据集拆分"><a href="#3-数据集拆分" class="headerlink" title="3. 数据集拆分"></a>3. 数据集拆分</h2><p>　　在得到训练数据集时，通常我们经常会把训练数据集进一步拆分成训练集和验证集，这样有助于我们模型参数的选取。</p><pre><code># 作用：将数据集划分为 训练集和测试集 # 格式：train_test_split(*arrays, **options)from sklearn.mode_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42) """ 参数           返回---arrays：样本数组，包含特征向量和标签test_size：　　float-获得多大比重的测试样本 （默认：0.25）　　int - 获得多少个测试样本train_size: 同test_sizerandom_state:　　int - 随机种子（种子固定，实验可复现）shuffle - 是否在分割之前对数据进行洗牌（默认True）分割后的列表，长度=2*len(arrays), 　　(train-test split) """</code></pre><h2 id="4-定义模型"><a href="#4-定义模型" class="headerlink" title="4. 定义模型"></a>4. 定义模型</h2><p>　　在这一步我们首先要分析自己数据的类型，搞清出你要用什么模型来做，然后我们就可以在sklearn中定义模型了。sklearn为所有模型提供了非常相似的接口，这样使得我们可以更加快速的熟悉所有模型的用法。在这之前我们先来看看模型的常用属性和功能：</p><pre><code># 拟合模型model.fit(X_train, y_train) # 模型预测model.predict(X_test) # 获得这个模型的参数model.get_params() # 为模型进行打分model.score(data_X, data_y) # 线性回归：R square； 分类问题： acc</code></pre><h3 id="4-1-线性回归"><a href="#4-1-线性回归" class="headerlink" title="4.1 线性回归"></a>4.1 线性回归</h3><pre><code>from sklearn.linear_model import LinearRegression # 定义线性回归模型model = LinearRegression(fit_intercept=True, normalize=False,     copy_X=True, n_jobs=1) """ 参数---    fit_intercept：是否计算截距。False-模型没有截距    normalize： 当fit_intercept设置为False时，该参数将被忽略。 如果为真，则回归前的回归系数X将通过减去平均值并除以l2-范数而归一化。     n_jobs：指定线程数 """</code></pre><p>　　　　　　<img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-fe12917cfabb9875.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="4-2-逻辑回归LR"><a href="#4-2-逻辑回归LR" class="headerlink" title="4.2 逻辑回归LR"></a>4.2 逻辑回归LR</h3><pre><code>from sklearn.linear_model import LogisticRegression # 定义逻辑回归模型model = LogisticRegression(penalty=’l2’, dual=False, tol=0.0001, C=1.0,     fit_intercept=True, intercept_scaling=1, class_weight=None,     random_state=None, solver=’liblinear’, max_iter=100, multi_class=’ovr’,     verbose=0, warm_start=False, n_jobs=1) """参数---    penalty：使用指定正则化项（默认：l2）    dual: n_samples &gt; n_features取False（默认）    C：正则化强度的反，值越小正则化强度越大    n_jobs: 指定线程数    random_state：随机数生成器    fit_intercept: 是否需要常量 """</code></pre><h3 id="4-3-朴素贝叶斯算法NB"><a href="#4-3-朴素贝叶斯算法NB" class="headerlink" title="4.3 朴素贝叶斯算法NB"></a>4.3 朴素贝叶斯算法NB</h3><pre><code>from sklearn import naive_bayesmodel = naive_bayes.GaussianNB() # 高斯贝叶斯model = naive_bayes.MultinomialNB(alpha=1.0, fit_prior=True, class_prior=None)model = naive_bayes.BernoulliNB(alpha=1.0, binarize=0.0, fit_prior=True, class_prior=None) """ 文本分类问题常用MultinomialNB参数---    alpha：平滑参数    fit_prior：是否要学习类的先验概率；false-使用统一的先验概率    class_prior: 是否指定类的先验概率；若指定则不能根据参数调整    binarize: 二值化的阈值，若为None，则假设输入由二进制向量组成 """</code></pre><h3 id="4-4-决策树DT"><a href="#4-4-决策树DT" class="headerlink" title="4.4 决策树DT"></a>4.4 决策树DT</h3><pre><code>from sklearn import tree model = tree.DecisionTreeClassifier(criterion=’gini’, max_depth=None,     min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0,     max_features=None, random_state=None, max_leaf_nodes=None,     min_impurity_decrease=0.0, min_impurity_split=None,     class_weight=None, presort=False) """参数---    criterion ：特征选择准则gini/entropy    max_depth：树的最大深度，None-尽量下分    min_samples_split：分裂内部节点，所需要的最小样本树    min_samples_leaf：叶子节点所需要的最小样本数    max_features: 寻找最优分割点时的最大特征数    max_leaf_nodes：优先增长到最大叶子节点数    min_impurity_decrease：如果这种分离导致杂质的减少大于或等于这个值，则节点将被拆分。 """</code></pre><h3 id="4-5-支持向量机SVM"><a href="#4-5-支持向量机SVM" class="headerlink" title="4.5 支持向量机SVM"></a>4.5 支持向量机SVM</h3><pre><code>from sklearn.svm import SVCmodel = SVC(C=1.0, kernel=’rbf’, gamma=’auto’) """参数---    C：误差项的惩罚参数C    gamma: 核相关系数。浮点数，If gamma is ‘auto’ then 1/n_features will be used instead. """</code></pre><h3 id="4-6-k近邻算法KNN"><a href="#4-6-k近邻算法KNN" class="headerlink" title="4.6 k近邻算法KNN"></a>4.6 k近邻算法KNN</h3><pre><code>from sklearn import neighbors #定义kNN分类模型model = neighbors.KNeighborsClassifier(n_neighbors=5, n_jobs=1) # 分类model = neighbors.KNeighborsRegressor(n_neighbors=5, n_jobs=1) # 回归"""参数---    n_neighbors： 使用邻居的数目    n_jobs：并行任务数 """</code></pre><h3 id="4-7-多层感知机（神经网络）"><a href="#4-7-多层感知机（神经网络）" class="headerlink" title="4.7 多层感知机（神经网络）"></a>4.7 多层感知机（神经网络）</h3><pre><code>from sklearn.neural_network import MLPClassifier # 定义多层感知机分类算法model = MLPClassifier(activation='relu', solver='adam', alpha=0.0001) """参数---    hidden_layer_sizes: 元祖    activation：激活函数    solver ：优化算法{‘lbfgs’, ‘sgd’, ‘adam’}    alpha：L2惩罚(正则化项)参数。 """</code></pre><h2 id="5-模型评估与选择篇"><a href="#5-模型评估与选择篇" class="headerlink" title="5. 模型评估与选择篇"></a>5. 模型评估与选择篇</h2><h3 id="5-1-交叉验证"><a href="#5-1-交叉验证" class="headerlink" title="5.1 交叉验证"></a>5.1 交叉验证</h3><pre><code>from sklearn.model_selection import cross_val_scorecross_val_score(model, X, y=None, scoring=None, cv=None, n_jobs=1) """参数---    model：拟合数据的模型    cv ： k-fold    scoring: 打分参数-‘accuracy’、‘f1’、‘precision’、‘recall’ 、‘roc_auc’、'neg_log_loss'等等 """</code></pre><h3 id="5-2-检验曲线"><a href="#5-2-检验曲线" class="headerlink" title="5.2 检验曲线"></a>5.2 检验曲线</h3><p>　　使用检验曲线，我们可以更加方便的改变模型参数，获取模型表现。</p><pre><code>from sklearn.model_selection import validation_curvetrain_score, test_score = validation_curve(model, X, y, param_name, param_range, cv=None, scoring=None, n_jobs=1) """参数---    model:用于fit和predict的对象    X, y: 训练集的特征和标签    param_name：将被改变的参数的名字    param_range： 参数的改变范围    cv：k-fold返回值---   train_score: 训练集得分（array）    test_score: 验证集得分（array） """</code></pre><p><a href="http://scikit-learn.org/stable/auto_examples/model_selection/plot_validation_curve.html#sphx-glr-auto-examples-model-selection-plot-validation-curve-py" target="_blank" rel="noopener">例子</a></p><h2 id="6-保存模型"><a href="#6-保存模型" class="headerlink" title="6. 保存模型"></a>6. 保存模型</h2><p>　　最后，我们可以将我们训练好的model保存到本地，或者放到线上供用户使用，那么如何保存训练好的model呢？主要有下面两种方式：</p><h3 id="6-1-保存为pickle文件"><a href="#6-1-保存为pickle文件" class="headerlink" title="6.1 保存为pickle文件"></a>6.1 保存为pickle文件</h3><pre><code>import pickle # 保存模型with open('model.pickle', 'wb') as f:    pickle.dump(model, f) # 读取模型with open('model.pickle', 'rb') as f:    model = pickle.load(f)model.predict(X_test)</code></pre><h3 id="6-2-sklearn自带方法joblib"><a href="#6-2-sklearn自带方法joblib" class="headerlink" title="6.2 sklearn自带方法joblib"></a>6.2 sklearn自带方法joblib</h3><pre><code>from sklearn.externals import joblib # 保存模型joblib.dump(model, 'model.pickle') #载入模型model = joblib.load('model.pickle')</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Matplotlib数据可视化</title>
      <link href="/posts/blog-python07.html"/>
      <url>/posts/blog-python07.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://link.jianshu.com/?t=https://www.gitbook.com/book/wizardforcel/matplotlib-intro-tut/details" target="_blank" rel="noopener">在线阅读</a></li><li><a href="https://link.jianshu.com/?t=https://www.gitbook.com/download/pdf/book/wizardforcel/matplotlib-intro-tut" target="_blank" rel="noopener">PDF格式</a></li><li><a href="https://link.jianshu.com/?t=https://www.gitbook.com/download/epub/book/wizardforcel/matplotlib-intro-tut" target="_blank" rel="noopener">EPUB格式</a></li><li><a href="https://link.jianshu.com/?t=https://www.gitbook.com/download/mobi/book/wizardforcel/matplotlib-intro-tut" target="_blank" rel="noopener">MOBI格式</a></li><li><a href="https://link.jianshu.com/?t=https://github.com/wizardforcel/matplotlib-intro-tut-zh" target="_blank" rel="noopener">代码仓库</a><h1 id="第一章-Matplotlib-简介"><a href="#第一章-Matplotlib-简介" class="headerlink" title="第一章 Matplotlib 简介"></a>第一章 Matplotlib 简介</h1></li></ul><p>这里涉及Matplotlib 数据可视化模块的多个方面。 Matplotlib 能够创建多数类型的图表，如条形图，散点图，条形图，饼图，堆叠图，3D 图和地图图表。</p><p>首先，为了实际使用 Matplotlib，我们需要安装它。</p><p>如果你安装了更高版本的 Python，你应该能够打开<code>cmd.exe</code>或终端，然后执行：</p><pre><code>pip install matplotlib</code></pre><p>注意：如果上面的较短命令不工作，你可能需要执行<code>C:/Python34/Scripts/pip install matplotlib</code>。</p><p>如果在导入<code>matplotlib</code>时，你会收到类似『无命名模块』和模块名称的错误，这意味着你还需要安装该模块。 一个常见的问题是缺少名为<code>six</code>的模块。 这意味着你需要使用<code>pip</code>安装<code>six</code>。</p><p>或者，你可以前往 Matplotlib.org 并通过访问下载页面下载适当的版本进行安装。 请记住，因为你的操作系统为 64 位，你不一定需要 64 位版本的 Python。 如果你不打算尝试 64 位，你可以使用 32 位。 打开 IDLE 并阅读顶部。 如果它说你是 64 位，你就是 64 位，如果它说是 32 位，那么你就是 32 位。 一旦你安装了 Python，你就做好了准备，你可以编写任何你想要的逻辑。 我喜欢使用 IDLE 来编程，但你可以随意使用任何你喜欢的东西。</p><pre><code>import matplotlib.pyplot as plt</code></pre><p>这一行导入集成的<code>pyplot</code>，我们将在整个系列中使用它。 我们将<code>pyplot</code>导入为<code>plt</code>，这是使用<code>pylot</code>的 python 程序的传统惯例。</p><pre><code>plt.plot([1,2,3],[5,7,4])</code></pre><p>接下来，我们调用<code>plot</code>的<code>.plot</code>方法绘制一些坐标。 这个<code>.plot</code>需要许多参数，但前两个是<code>'x'</code>和<code>'y'</code>坐标，我们放入列表。 这意味着，根据这些列表我们拥有 3 个坐标：<code>1,5</code> <code>2,7</code>和<code>3,4</code>。</p><p><code>plt.plot</code>在后台『绘制』这个绘图，但绘制了我们想要的一切之后，当我们准备好的时候，我们需要把它带到屏幕上。</p><pre><code>plt.show()</code></pre><p>这样，应该弹出一个图形。 如果没有，有时它可以弹出，或者你可能得到一个错误。 你的图表应如下所示：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-fd9dc5b819eee2af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这个窗口是一个 matplotlib 窗口，它允许我们查看我们的图形，以及与它进行交互和访问。 你可以将鼠标悬停在图表上，并查看通常在右下角的坐标。 你也可以使用按钮。 它们可能在不同的位置，但在上图中，这些按钮在左下角。</p><h2 id="Home（主页）"><a href="#Home（主页）" class="headerlink" title="Home（主页）"></a><code>Home</code>（主页）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-ab1c99dc1ef372d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>一旦你开始浏览你的图表，主页按钮会帮助你。 如果你想要返回原始视图，可以单击它。 在浏览图表之前单击此按钮将不会生效。</p><h2 id="Forward-Back（前进-后退）"><a href="#Forward-Back（前进-后退）" class="headerlink" title="Forward/Back（前进/后退）"></a><code>Forward/Back</code>（前进/后退）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-99b6fdd250908e9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这些按钮可以像浏览器中的前进和后退按钮一样使用。 你可以单击这些来移回到你之前的位置，或再次前进。</p><h2 id="Pan（平移）"><a href="#Pan（平移）" class="headerlink" title="Pan（平移）"></a><code>Pan</code>（平移）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-38a450e6ab426002.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>你可以点击平移按钮，之后点击并拖拽你的图表。</p><h2 id="Zoom（缩放）"><a href="#Zoom（缩放）" class="headerlink" title="Zoom（缩放）"></a><code>Zoom</code>（缩放）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-986d4901b894c101.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>缩放按钮可让你单击它，然后单击并拖动出要放大的方形区域。 放大需要左键单击并拖动。 你也可以右键单击并拖动来缩小。</p><h2 id="Configure-Subplots（配置子图）"><a href="#Configure-Subplots（配置子图）" class="headerlink" title="Configure Subplots（配置子图）"></a><code>Configure Subplots</code>（配置子图）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-cf8ab1dd29554afc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>此按钮允许你对图形和绘图配置各种间距选项。 点击它会弹出：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-97d5ced902265b4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>每个蓝色条形都是一个滑块，它允许你调整内边距。 其中有些现在没有任何效果，因为没有任何其他子图。 前四个值调整图形到窗口边缘的边距。 之后<code>wspace</code>和<code>hspace</code>对应于当你绘制多个子图时，它们的水平或竖直间距。</p><h2 id="Save（保存）"><a href="#Save（保存）" class="headerlink" title="Save（保存）"></a><code>Save</code>（保存）</h2><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0e48f4e59778e08a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>此按钮允许你以各种形式保存图形。</p><p>所以这是 matplotlib 的快速介绍，我们之后会涉及更多。</p><h1 id="第二章-图例、标题和标签"><a href="#第二章-图例、标题和标签" class="headerlink" title="第二章 图例、标题和标签"></a>第二章 图例、标题和标签</h1><p>在本教程中，我们将讨论 Matplotlib 中的图例，标题和标签。 很多时候，图形可以不言自明，但是图形带有标题，轴域上的标签和图例，来解释每一行是什么非常必要。</p><blockquote><p>注：轴域（<code>Axes</code>）即两条坐标轴围城的区域。</p></blockquote><p>从这里开始：</p><pre><code>import matplotlib.pyplot as pltx = [1,2,3]y = [5,7,4]x2 = [1,2,3]y2 = [10,14,12]</code></pre><p>这样我们可以画出两个线条，接下来：</p><pre><code>plt.plot(x, y, label='First Line')plt.plot(x2, y2, label='Second Line')</code></pre><p>在这里，我们绘制了我们已经看到的东西，但这次我们添加另一个参数<code>label</code>。 这允许我们为线条指定名称，我们以后可以在图例中显示它。 我们的其余代码为：</p><pre><code>plt.xlabel('Plot Number')plt.ylabel('Important var')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p>使用<code>plt.xlabel</code>和<code>plt.ylabel</code>，我们可以为这些相应的轴创建标签。 接下来，我们可以使用<code>plt.title</code>创建图的标题，然后我们可以使用<code>plt.legend()</code>生成默认图例。 结果图如下：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-74fabfe13552bc2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第三章-条形图和直方图"><a href="#第三章-条形图和直方图" class="headerlink" title="第三章 条形图和直方图"></a>第三章 条形图和直方图</h1><p>这个教程中我们会涉及条形图和直方图。我们先来看条形图：</p><pre><code>import matplotlib.pyplot as pltplt.bar([1,3,5,7,9],[5,2,7,8,2], label="Example one")plt.bar([2,4,6,8,10],[8,6,2,5,6], label="Example two", color='g')plt.legend()plt.xlabel('bar number')plt.ylabel('bar height')plt.title('Epic Graph\nAnother Line! Whoa')plt.show()</code></pre><p><code>plt.bar</code>为我们创建条形图。 如果你没有明确选择一种颜色，那么虽然做了多个图，所有的条看起来会一样。 这让我们有机会使用一个新的 Matplotlib 自定义选项。 你可以在任何类型的绘图中使用颜色，例如<code>g</code>为绿色，<code>b</code>为蓝色，<code>r</code>为红色，等等。 你还可以使用十六进制颜色代码，如<code>#191970</code>。</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-52b8c12da35ac96d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>接下来，我们会讲解直方图。 直方图非常像条形图，倾向于通过将区段组合在一起来显示分布。 这个例子可能是年龄的分组，或测试的分数。 我们并不是显示每一组的年龄，而是按照 20 ~ 25，25 ~ 30… 等等来显示年龄。 这里有一个例子：</p><pre><code>import matplotlib.pyplot as pltpopulation_ages = [22,55,62,45,21,22,34,42,42,4,99,102,110,120,121,122,130,111,115,112,80,75,65,54,44,43,42,48]bins = [0,10,20,30,40,50,60,70,80,90,100,110,120,130]plt.hist(population_ages, bins, histtype='bar', rwidth=0.8)plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p>产生的图表为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-f9bc20699e3270fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>对于<code>plt.hist</code>，你首先需要放入所有的值，然后指定放入哪个桶或容器。 在我们的例子中，我们绘制了一堆年龄，并希望以 10 年的增量来显示它们。 我们将条形的宽度设为 0.8，但是如果你想让条形变宽，或者变窄，你可以选择其他的宽度。</p><h1 id="第四章-散点图"><a href="#第四章-散点图" class="headerlink" title="第四章 散点图"></a>第四章 散点图</h1><p>接下来，我们将介绍散点图。散点图通常用于比较两个变量来寻找相关性或分组，如果你在 3 维绘制则是 3 个。</p><p>散点图的一些示例代码：</p><pre><code>import matplotlib.pyplot as pltx = [1,2,3,4,5,6,7,8]y = [5,2,4,2,1,4,5,2]plt.scatter(x,y, label='skitscat', color='k', s=25, marker="o")plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-65aedb5516804258.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><code>plt.scatter</code>不仅允许我们绘制<code>x</code>和<code>y</code>，而且还可以让我们决定所使用的标记颜色，大小和类型。 有一堆标记选项，请参阅 <a href="https://link.jianshu.com?t=http://matplotlib.org/api/markers_api.html" target="_blank" rel="noopener">Matplotlib 标记文档</a>中的所有选项。</p><h1 id="第五章-堆叠图"><a href="#第五章-堆叠图" class="headerlink" title="第五章 堆叠图"></a>第五章 堆叠图</h1><p>在这篇 Matplotlib 数据可视化教程中，我们要介绍如何创建堆叠图。 堆叠图用于显示『部分对整体』随时间的关系。 堆叠图基本上类似于饼图，只是随时间而变化。</p><p>让我们考虑一个情况，我们一天有 24 小时，我们想看看我们如何花费时间。 我们将我们的活动分为：睡觉，吃饭，工作和玩耍。</p><p>我们假设我们要在 5 天的时间内跟踪它，因此我们的初始数据将如下所示：</p><pre><code>import matplotlib.pyplot as pltdays = [1,2,3,4,5]sleeping = [7,8,6,11,7]eating =   [2,3,4,3,2]working =  [7,8,7,2,2]playing =  [8,5,7,8,13]</code></pre><p>因此，我们的<code>x</code>轴将包括<code>day</code>变量，即 1, 2, 3, 4 和 5。然后，日期的各个成分保存在它们各自的活动中。 像这样绘制它们：</p><pre><code>plt.stackplot(days, sleeping,eating,working,playing, colors=['m','c','r','k'])plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-e840375ace5b8641.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>在这里，我们可以至少在颜色上看到，我们如何花费我们的时间。 问题是，如果不回头看代码，我们不知道什么颜色是什么。 下一个问题是，对于多边形来说，我们实际上不能为数据添加『标签』。 因此，在任何不止是线条，带有像这样的填充或堆叠图的地方，我们不能以固有方式标记出特定的部分。 这不应该阻止程序员。 我们可以解决这个问题：</p><pre><code>import matplotlib.pyplot as pltdays = [1,2,3,4,5]sleeping = [7,8,6,11,7]eating =   [2,3,4,3,2]working =  [7,8,7,2,2]playing =  [8,5,7,8,13]plt.plot([],[],color='m', label='Sleeping', linewidth=5)plt.plot([],[],color='c', label='Eating', linewidth=5)plt.plot([],[],color='r', label='Working', linewidth=5)plt.plot([],[],color='k', label='Playing', linewidth=5)plt.stackplot(days, sleeping,eating,working,playing, colors=['m','c','r','k'])plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0e5233d43903c2a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>我们在这里做的是画一些空行，给予它们符合我们的堆叠图的相同颜色，和正确标签。 我们还使它们线宽为 5，使线条在图例中显得较宽。 现在，我们可以很容易地看到，我们如何花费我们的时间。</p><h1 id="第六章-饼图"><a href="#第六章-饼图" class="headerlink" title="第六章 饼图"></a>第六章 饼图</h1><p>饼图很像堆叠图，只是它们位于某个时间点。 通常，饼图用于显示部分对于整体的情况，通常以％为单位。 幸运的是，Matplotlib 会处理切片大小以及一切事情，我们只需要提供数值。</p><pre><code>import matplotlib.pyplot as pltslices = [7,2,2,13]activities = ['sleeping','eating','working','playing']cols = ['c','m','r','b']plt.pie(slices,        labels=activities,        colors=cols,        startangle=90,        shadow= True,        explode=(0,0.1,0,0),        autopct='%1.1f%%')plt.title('Interesting Graph\nCheck it out')plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-f22a951b92ef4824.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>在<code>plt.pie</code>中，我们需要指定『切片』，这是每个部分的相对大小。 然后，我们指定相应切片的颜色列表。 接下来，我们可以选择指定图形的『起始角度』。 这使你可以在任何地方开始绘图。 在我们的例子中，我们为饼图选择了 90 度角，这意味着第一个部分是一个竖直线条。 接下来，我们可以选择给绘图添加一个字符大小的阴影，然后我们甚至可以使用<code>explode</code>拉出一个切片。</p><p>我们总共有四个切片，所以对于<code>explode</code>，如果我们不想拉出任何切片，我们传入<code>0,0,0,0</code>。 如果我们想要拉出第一个切片，我们传入<code>0.1,0,0,0</code>。</p><p>最后，我们使用<code>autopct</code>，选择将百分比放置到图表上面。</p><h1 id="第七章-从文件加载数据"><a href="#第七章-从文件加载数据" class="headerlink" title="第七章 从文件加载数据"></a>第七章 从文件加载数据</h1><p>很多时候，我们想要绘制文件中的数据。 有许多类型的文件，以及许多方法，你可以使用它们从文件中提取数据来图形化。 在这里，我们将展示几种方法。 首先，我们将使用内置的<code>csv</code>模块加载CSV文件，然后我们将展示如何使用 NumPy（第三方模块）加载文件。</p><pre><code>import matplotlib.pyplot as pltimport csvx = []y = []with open('example.txt','r') as csvfile:    plots = csv.reader(csvfile, delimiter=',')    for row in plots:        x.append(int(row[0]))        y.append(int(row[1]))plt.plot(x,y, label='Loaded from file!')plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-5cdf1d5247930ab3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这里，我们打开样例文件，包含以下数据：</p><pre><code>1,52,33,44,75,46,37,58,79,410,4</code></pre><p>接下来，我们使用<code>csv</code>模块读取数据。 <code>csv</code>读取器自动按行分割文件，然后使用我们选择的分隔符分割文件中的数据。 在我们的例子中，这是一个逗号。 注意：<code>csv</code>模块和<code>csv reader</code>不需要文件在字面上是一个.csv文件。 它可以是任何具有分隔数据的简单的文本文件。</p><p>一旦我们这样做了，我们将索引为 0 的元素存储到<code>x</code>列表，将索引为 1 的元素存储到<code>y</code>列表中。 之后，我们都设置好了，准备绘图，然后显示数据。</p><p>虽然使用 CSV 模块是完全正常的，但使用 NumPy 模块来加载我们的文件和数据，可能对我们更有意义。 如果你没有 NumPy，你需要按下面的步骤来获取它。 为了了解安装模块的更多信息，请参阅 <a href="https://link.jianshu.com?t=http://pythonprogramming.net/using-pip-install-for-python-modules/" target="_blank" rel="noopener">pip 教程</a>。 大多数人应该都能打开命令行，并执行<code>pip install numpy</code>。</p><p>如果不能，请参阅链接中的教程。</p><p>一旦你安装了 NumPy，你可以编写如下代码：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npx, y = np.loadtxt('example.txt', delimiter=',', unpack=True)plt.plot(x,y, label='Loaded from file!')plt.xlabel('x')plt.ylabel('y')plt.title('Interesting Graph\nCheck it out')plt.legend()plt.show()</code></pre><p>结果应该是相同的图表。 稍后，当我们加载数据时，我们可以利用 NumPy 为我们做一些更多的工作，但这是教程未来的内容。 就像<code>csv</code>模块不需要一个特地的<code>.csv</code>一样，<code>loadtxt</code>函数不要求文件是一个<code>.txt</code>文件，它可以是一个<code>.csv</code>，它甚至可以是一个 python 列表对象。</p><h1 id="第八章-从网络加载数据"><a href="#第八章-从网络加载数据" class="headerlink" title="第八章 从网络加载数据"></a>第八章 从网络加载数据</h1><p>除了从文件加载数据，另一个流行的数据源是互联网。 我们可以用各种各样的方式从互联网加载数据，但对我们来说，我们只是简单地读取网站的源代码，然后通过简单的拆分来分离数据。</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport matplotlib.dates as mdatesdef graph_data(stock):    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line:                stock_data.append(line)</code></pre><p>这里有很多步骤。首先，我们看到<code>import</code>。 <code>pyplot</code>像往常一样导入，然后导入了<code>numpy</code>，然后是用于访问互联网的<code>urllib</code>，然后导入了<code>matplotlib.dates</code>作为<code>mdates</code>，它对于将日期戳转换为 matplotlib 可以理解的日期很有用。</p><p>接下来，我们开始构建我们的<code>graph_data</code>函数。在这里，我们首先定义包含股票数据的网址。之后，我们写一些<code>urllib</code>代码来访问该 URL，然后使用<code>.read</code>读取源代码，之后我们继续解码该数据。如果你使用 Python 2，则不必使用<code>decode</code>。</p><p>然后，我们定义一个空列表，这是我们将要放置股票数据的地方，我们也开始使用<code>split_source</code>变量拆分数据，以换行符拆分。</p><p>现在，如果你去看源代码，用<code>stock</code>替换 URL 中的<code>+stock+</code>，像 AAPL 那样，你可以看到大多数页面数据确实是股票定价信息，但有一些头信息我们需要过滤掉。为此，我们使用一些基本的过滤，检查它们来确保每行有 6 个数据点，然后确保术语<code>values</code>不在行中。</p><p>现在，我们已经解析了数据，并做好了准备。我们将使用 NumPy：</p><pre><code>date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                      delimiter=',',                                                      unpack=True,                                                      # %Y = full year. 2015                                                      # %y = partial year 15                                                      # %m = number month                                                      # %d = number day                                                      # %H = hours                                                      # %M = minutes                                                      # %S = seconds                                                      # 12-06-2014                                                      # %m-%d-%Y                                                      converters={0: bytespdate2num('%Y%m%d')})</code></pre><p>我们在这里所做的是，使用<code>numpy</code>的<code>loadtxt</code>函数，并将这六个元素解构到六个变量。 这里的第一个参数是<code>stock_data</code>，这是我们加载的数据。 然后，我们指定<code>delimiter</code>（这里是逗号），然后我们指定我们确实想要在这里解包变量，不是一个变量，而是我们定义的这组变量。 最后，我们使用可选的<code>converters</code>参数来指定我们要转换的元素（<code>0</code>），以及我们打算要怎么做。 我们传递一个名为<code>bytespdate2num</code>的函数，它还不存在，但我们下面会编写它。</p><h1 id="第九章-时间戳的转换"><a href="#第九章-时间戳的转换" class="headerlink" title="第九章 时间戳的转换"></a>第九章 时间戳的转换</h1><p>本教程的重点是将来自 Yahoo finance API 的日期转换为 Matplotlib 可理解的日期。 为了实现它，我们要写一个新的函数，<code>bytespdate2num</code>。</p><pre><code>def bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverter</code></pre><p>此函数接受数据，基于编码来解码数据，然后返回它。</p><p>将此应用于我们的程序的其余部分：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          # %Y = full year. 2015                                                          # %y = partial year 15                                                          # %m = number month                                                          # %d = number day                                                          # %H = hours                                                          # %M = minutes                                                          # %S = seconds                                                          # 12-06-2014                                                          # %m-%d-%Y                                                          converters={0: bytespdate2num('%Y%m%d')})    plt.plot_date(date, closep,'-', label='Price')    plt.xlabel('Date')    plt.ylabel('Price')    plt.title('Interesting Graph\nCheck it out')    plt.legend()    plt.show()graph_data('TSLA')</code></pre><p>如果你绘制 TSLA，结果图应该看起来像这样：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-4ecbc2e94a4d3abc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第十章-基本的自定义"><a href="#第十章-基本的自定义" class="headerlink" title="第十章 基本的自定义"></a>第十章 基本的自定义</h1><p>在 Matplotlib 教程中，我们将讨论一些可能的图表自定义。 为了开始修改子图，我们必须定义它们。 我们很快会谈论他们，但有两种定义并构造子图的主要方法。 现在，我们只使用其中一个，但我们会很快解释它们。</p><p>现在，修改我们的<code>graph_data</code>函数：</p><pre><code>def graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))</code></pre><p>为了修改图表，我们需要引用它，所以我们将它存储到变量<code>fig</code>。 然后我们将<code>ax1</code>定义为图表上的子图。 我们在这里使用<code>subplot2grid</code>，这是获取子图的两种主要方法之一。 我们将深入讨论这些东西，但现在，你应该看到我们有 2 个元组，它们提供了<code>(1,1)</code>和<code>(0,0)</code>。 <code>1,1</code>表明这是一个 1×1 网格。 然后<code>0,0</code>表明这个子图的『起点』将为<code>0,0</code>。</p><p>接下来，通过我们已经编写的代码来获取和解析数据：</p><pre><code>stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'source_code = urllib.request.urlopen(stock_price_url).read().decode()stock_data = []split_source = source_code.split('\n')for line in split_source:    split_line = line.split(',')    if len(split_line) == 6:        if 'values' not in line and 'labels' not in line:            stock_data.append(line)date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                      delimiter=',',                                                      unpack=True,                                                      converters={0: bytespdate2num('%Y%m%d')})</code></pre><p>下面，我们这样绘制数据：</p><pre><code>ax1.plot_date(date, closep,'-', label='Price')</code></pre><p>现在，由于我们正在绘制日期，我们可能会发现，如果我们放大，日期会在水平方向上移动。但是，我们可以自定义这些刻度标签，像这样：</p><pre><code>for label in ax1.xaxis.get_ticklabels():    label.set_rotation(45)</code></pre><p>这将使标签转动到对角线方向。 接下来，我们可以添加一个网格：</p><pre><code>ax1.grid(True)</code></pre><p>然后，其它东西我们保留默认，但我们也可能需要略微调整绘图，因为日期跑到了图表外面。 记不记得我们在第一篇教程中讨论的<code>configure subplots</code>按钮？ 我们不仅可以以这种方式配置图表，我们还可以在代码中配置它们，以下是我们设置这些参数的方式：</p><pre><code>plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)</code></pre><p>现在，为了防止我们把你遗留在某个地方，这里是完整的代码：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    ax1.plot_date(date, closep,'-', label='Price')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.grid(True)#, color='g', linestyle='-', linewidth=5)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title('Interesting Graph\nCheck it out')    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('TSLA')</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-e13743e9a0142564.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第十一章-Unix-时间"><a href="#第十一章-Unix-时间" class="headerlink" title="第十一章 Unix 时间"></a>第十一章 Unix 时间</h1><p>在这个 Matplotlib 教程中，我们将介绍如何处理 unix 时间戳的转换，然后在图形中绘制日期戳。 使用 Yahoo Finance API，你会注意到，如果你使用较大的时间间隔，如<code>1y</code>（一年），你会得到我们一直在使用的日期戳，但如果你使用<code>10d</code>（10 天），反之你会得到 unix 时间的时间戳。</p><p>Unix 时间是 1970 年 1 月 1 日以后的秒数，它是跨程序的标准化时间表示方法。 也就是说，Matplotlib 并不欢迎 unix 时间戳。 这里是你可以使用 Matplotlib 来处理 unix 时间的方式：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10d/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True)    dateconv = np.vectorize(dt.datetime.fromtimestamp)    date = dateconv(date)##    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,##                                                          delimiter=',',##                                                          unpack=True,##                                                          converters={0: bytespdate2num('%Y%m%d')})    ax1.plot_date(date, closep,'-', label='Price')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.grid(True)#, color='g', linestyle='-', linewidth=5)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title('Interesting Graph\nCheck it out')    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('TSLA')</code></pre><p>所以在这里，我们所做的是 unix 时间的写入处理，并注释掉我们以前的代码，因为我们为之后的使用而保存它。 这里的主要区别是：</p><pre><code>dateconv = np.vectorize(dt.datetime.fromtimestamp)date = dateconv(date)</code></pre><p>这里，我们将时间戳转换为日期戳，然后将其转换为 Matplotlib 想要的时间。</p><p>现在，由于某些原因，我的 unix 时间带有另一行包含 6 个元素的数据，并且它包含了术语<code>label</code>，因此，在我们解析数据的<code>for</code>循环中，我们为你再添加一个需要注意的检查：</p><pre><code>for line in split_source:    split_line = line.split(',')    if len(split_line) == 6:        if 'values' not in line and 'labels' not in line:            stock_data.append(line)</code></pre><p>现在你的图表应该类似：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-4de0a34533b0fca1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这里的所有扁平线条的原因是市场关闭。 有了这个短期数据，我们可以得到日内数据。 所以交易开放时有很多点，然后市场关闭时就没有了，然后又是一堆，然后又是没有。</p><h1 id="第十二章-颜色和填充"><a href="#第十二章-颜色和填充" class="headerlink" title="第十二章 颜色和填充"></a>第十二章 颜色和填充</h1><p>在本教程中，我们将介绍一些更多的自定义，比如颜色和线条填充。</p><p>我们要做的第一个改动是将<code>plt.title</code>更改为<code>stock</code>变量。</p><pre><code>plt.title(stock)</code></pre><p>现在，让我们来介绍一下如何更改标签颜色。 我们可以通过修改我们的轴对象来实现：</p><pre><code>ax1.xaxis.label.set_color('c')ax1.yaxis.label.set_color('r')</code></pre><p>如果我们运行它，我们会看到标签改变了颜色，就像在单词中那样。</p><p>接下来，我们可以为要显示的轴指定具体数字，而不是像这样的自动选择：</p><pre><code>ax1.set_yticks([0,25,50,75])</code></pre><p>接下来，我想介绍填充。 填充所做的事情，是在变量和你选择的一个数值之间填充颜色。 例如，我们可以这样：</p><pre><code>ax1.fill_between(date, 0, closep)</code></pre><p>所以到这里，我们的代码为：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    ax1.fill_between(date, 0, closep)    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.grid(True)#, color='g', linestyle='-', linewidth=5)    ax1.xaxis.label.set_color('c')    ax1.yaxis.label.set_color('r')    ax1.set_yticks([0,25,50,75])    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-f2b03db492944c72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>填充的一个问题是，我们可能最后会把东西都覆盖起来。 我们可以用透明度来解决它：</p><pre><code>ax1.fill_between(date, 0, closep)</code></pre><p>现在，让我们介绍条件填充。 让我们假设图表的起始位置是我们开始买入 eBay 的地方。 这里，如果价格低于这个价格，我们可以向上填充到原来的价格，然后如果它超过了原始价格，我们可以向下填充。 我们可以这样做：</p><pre><code>ax1.fill_between(date, closep[0], closep)</code></pre><p>会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-57b56f07db5bece0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>如果我们想用红色和绿色填充来展示收益/损失，那么与原始价格相比，绿色填充用于上升（注：国外股市的颜色和国内相反），红色填充用于下跌？ 没问题！ 我们可以添加一个<code>where</code>参数，如下所示：</p><pre><code>ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5)</code></pre><p>这里，我们填充当前价格和原始价格之间的区域，其中当前价格高于原始价格。 我们给予它绿色的前景色，因为这是一个上升，而且我们使用微小的透明度。</p><p>我们仍然不能对多边形数据（如填充）应用标签，但我们可以像以前一样实现空线条，因此我们可以：</p><pre><code>ax1.plot([],[],linewidth=5, label='loss', color='r',alpha=0.5)ax1.plot([],[],linewidth=5, label='gain', color='g',alpha=0.5)ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5)ax1.fill_between(date, closep, closep[0],where=(closep &lt; closep[0]), facecolor='r', alpha=0.5)</code></pre><p>这向我们提供了一些填充，以及用于处理标签的空线条，我们打算将其显示在图例中。这里完整的代码是：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    ax1.plot_date(date, closep,'-', label='Price')    ax1.plot([],[],linewidth=5, label='loss', color='r',alpha=0.5)    ax1.plot([],[],linewidth=5, label='gain', color='g',alpha=0.5)    ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5)    ax1.fill_between(date, closep, closep[0],where=(closep &lt; closep[0]), facecolor='r', alpha=0.5)    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.grid(True)#, color='g', linestyle='-', linewidth=5)    ax1.xaxis.label.set_color('c')    ax1.yaxis.label.set_color('r')    ax1.set_yticks([0,25,50,75])    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>现在我们的结果是：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-069af451720b65f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第十三章-边框和水平线条"><a href="#第十三章-边框和水平线条" class="headerlink" title="第十三章 边框和水平线条"></a>第十三章 边框和水平线条</h1><p>欢迎阅读另一个定制教程，在这里我们使用 Matplotlib 讨论边框和水平线条。 有时候你可能想做的事情是改变边框的颜色，或者甚至完全删除它们。</p><p>图形的边框基本上是图形的边界，其中有刻度线等东西。为了改变边框的颜色，你可以做一些类似这样的事情：</p><pre><code>ax1.spines['left'].set_color('c')</code></pre><p>在这里，我们引用了我们的边框字典，表示我们要调整左边框，然后我们使用<code>set_color</code>方法将颜色设置为<code>'c'</code>，它是青色。</p><p>如果我们想删除所有边框怎么办？ 我们可以这样做：</p><pre><code>ax1.spines['right'].set_visible(False)ax1.spines['top'].set_visible(False)</code></pre><p>这是非常类似的代码，删除了右边框和上边框。</p><p>很难看到我们修改了左边框的颜色，所以让我们通过修改线宽来使它变得很明显：</p><pre><code>ax1.spines['left'].set_linewidth(5)</code></pre><p>现在，左边框变成了非常粗也非常显眼的青色。 最后，如果我们想修改刻度参数怎么办？ 假如不想要黑色的日期，我们想要一些橙色的日期？ 没问题！</p><pre><code>ax1.tick_params(axis='x', colors='#f06215')</code></pre><p>现在我们的日期是橙色了！ 接下来，让我们来看看我们如何绘制一条水平线。 你当然可以将你创建的一组新数据绘制成一条水平线，但你不需要这样做。 你可以：</p><pre><code>ax1.axhline(closep[0], color='k', linewidth=5)</code></pre><p>所以在这里，我们的整个代码是：</p><pre><code>import matplotlib.pyplot as pltimport numpy as npimport urllibimport datetime as dtimport matplotlib.dates as mdatesdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=10y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    ax1.plot_date(date, closep,'-', label='Price')    ax1.plot([],[],linewidth=5, label='loss', color='r',alpha=0.5)    ax1.plot([],[],linewidth=5, label='gain', color='g',alpha=0.5)    ax1.axhline(closep[0], color='k', linewidth=5)    ax1.fill_between(date, closep, closep[0],where=(closep &gt; closep[0]), facecolor='g', alpha=0.5)    ax1.fill_between(date, closep, closep[0],where=(closep &lt; closep[0]), facecolor='r', alpha=0.5)    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.grid(True)    #ax1.xaxis.label.set_color('c')    #ax1.yaxis.label.set_color('r')    ax1.set_yticks([0,25,50,75])    ax1.spines['left'].set_color('c')    ax1.spines['right'].set_visible(False)    ax1.spines['top'].set_visible(False)    ax1.spines['left'].set_linewidth(5)    ax1.tick_params(axis='x', colors='#f06215')    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('ebay')</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-18c832847bc0f71c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第十四章-OHLC-K-线图"><a href="#第十四章-OHLC-K-线图" class="headerlink" title="第十四章 OHLC K 线图"></a>第十四章 OHLC K 线图</h1><p>在 Matplotlib 教程中，我们将介绍如何在 Matplotlib 中创建开，高，低，关（OHLC）的 K 线图。 这些图表用于以精简形式显示时间序列股价信息。 为了实现它，我们首先需要导入一些模块：</p><pre><code>import matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlc</code></pre><p>我们引入了<code>ticker</code>，允许我们修改图表底部的<code>ticker</code>信息。 然后我们从<code>matplotlib.finance</code>模块中引入<code>candlestick_ohlc</code>功能。</p><p>现在，我们需要组织我们的数据来和 matplotlib 协作。 如果你刚刚加入我们，我们得到的数据如下：</p><pre><code>stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv'source_code = urllib.request.urlopen(stock_price_url).read().decode()stock_data = []split_source = source_code.split('\n')for line in split_source:    split_line = line.split(',')    if len(split_line) == 6:        if 'values' not in line and 'labels' not in line:            stock_data.append(line)date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                      delimiter=',',                                                      unpack=True,                                                      converters={0: bytespdate2num('%Y%m%d')})</code></pre><p>现在，我们需要构建一个 Python 列表，其中每个元素都是数据。 我们可以修改我们的<code>loadtxt</code>函数，使其不解构，但随后我们还是希望引用特定的数据点。 我们可以解决这个问题，但是我们最后可能只拥有两个单独的数据集。 为此，我们执行以下操作：</p><pre><code>x = 0y = len(date)ohlc = []while x &lt; y:    append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]    ohlc.append(append_me)    x+=1</code></pre><p>有了这个，我们现在将 OHLC 数据列表存储到我们的变量<code>ohlc</code>。 现在我们可以这样绘制：</p><pre><code>candlestick_ohlc(ax1, ohlc)</code></pre><p>图表应该是这样：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-60ffe36a409afe6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>不幸的是，<code>x</code>轴上的<code>datetime</code>数据不是日期戳的形式。 我们可以处理它：</p><pre><code>ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))</code></pre><p>此外，红/黑着色依我看不是最好的选择。 我们应该使用绿色表示上升和红色表示下降。 为此，我们可以：</p><pre><code>candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')</code></pre><p>最后，我们可以将<code>x</code>标签设置为我们想要的数量，像这样：</p><pre><code>ax1.xaxis.set_major_locator(mticker.MaxNLocator(10))</code></pre><p>现在，完整代码现在是这样：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcimport numpy as npimport urllibimport datetime as dtdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax1.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax1.grid(True)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-4f2d9fb663f851cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>还要注意，我们从前面的教程中删除了大部分<code>ax1</code>的修改。</p><h1 id="第十五章-样式"><a href="#第十五章-样式" class="headerlink" title="第十五章 样式"></a>第十五章 样式</h1><p>在这个 Matplotlib 教程中，我们将讨论样式。 我们用于 Matplotlib 的样式非常相似于用于 HTML 页面的 CSS（层叠样式表）。 正如你在这里可以看到的，我们对图形所做的所有修改都会叠加，而且我们目前只有一个轴域。 我们可以使用<code>for</code>循环，至少使代码量降低，但我们也可以在 Matplotlib 中利用这些样式。</p><p>样式页的想法是将自定义样式写入文件，然后，为了使用这些更改并将其应用于图形，所有你需要做的就是导入样式，然后使用该特定样式。 这样，让我们假设你发现自己总是改变图形的各种元素。 你不必为每个图表编写 25 ~ 200 行自定义代码，只需将其写入一个样式，然后加载该样式，并以两行应用所有这些更改即可！ 让我们开始吧。</p><pre><code>from matplotlib import style</code></pre><p>接下来，我们指定要使用的样式。 Matplotlib 已经有了几种样式。</p><p>我们可以这样来使用样式：</p><pre><code>style.use('ggplot')</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-3ad2c87140de8855.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>除了标题，标签的颜色是灰色的，轴域的背景是浅灰色，我们可以立即分辨字体是不同的。 我们还注意到，网格实际上是一个白色的实线。 我们的 K 线图保持不变，主要是因为我们在事后定制它。 在样式中加载时，更改会生效，但如果在加载样式后编写新的自定义代码，你的更改也会生效。</p><p>因为我们试图展示样式模块，但是让我们继续，简单绘制几行，并暂且注释掉 K 线图：</p><pre><code>#candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')ax1.plot(date,closep)ax1.plot(date,openp)</code></pre><p>会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-8fa5b684a13eb408.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>已经比默认值好多了！</p><p>样式的另一个例子是<code>fivethirtyeight</code>：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-390e540781b5f0de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>你可以这样查看所有的可用样式：</p><pre><code>print(plt.style.available)</code></pre><p>我这里它提供了<code>['bmh', 'dark_background', 'ggplot', 'fivethirtyeight', 'grayscale']</code>。</p><p>让我们尝试<code>dark_background</code>：</p><pre><code>style.use('dark_background')</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-040521aa581616e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>现在，如果你想制作自己的风格呢？ 首先，你需要找到样式目录。 为了实现它，如果你知道它在哪里，你可以前往你的 matplotlib 目录，或者你可以找到该目录。 如果你不知道如何找到该目录，你可以执行以下操作：</p><pre><code>print(plt.__file__)</code></pre><p>这至少会告诉你<code>pyplot</code>模块的位置。</p><p>在 matplotlib 目录中，你需要寻找<code>mpl-data</code>。 然后在那里，你需要寻找<code>stylelib</code>。 在 Windows 上 ，我的完整路径是：<code>C:\Python34\Lib\site-packages\matplotlib\mpl-data\stylelib</code>。</p><p>那里应该显示了所有可用的<code>.mplstyle</code>文件。 你可以编辑、复制或重命名它们，然后在那里修改为你想要的东西。 然后，无论你用什么来命名<code>.mplstyle</code>文件，都要放在<code>style.use</code>中。</p><h1 id="第十六章-实时图表"><a href="#第十六章-实时图表" class="headerlink" title="第十六章 实时图表"></a>第十六章 实时图表</h1><p>在这篇 Matplotlib 教程中，我们将介绍如何创建实时更新图表，可以在数据源更新时更新其图表。 你可能希望将此用于绘制股票实时定价数据，或者可以将传感器连接到计算机，并且显示传感器实时数据。 为此，我们使用 Matplotlib 的动画功能。</p><p>最开始：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.animation as animationfrom matplotlib import style</code></pre><p>这里，唯一的新增导入是<code>matplotlib.animation as animation</code>。 这是一个模块，允许我们在显示之后对图形进行动画处理。</p><p>接下来，我们添加一些你熟悉的代码，如果你一直关注这个系列：</p><pre><code>style.use('fivethirtyeight')fig = plt.figure()ax1 = fig.add_subplot(1,1,1)</code></pre><p>现在我们编写动画函数：</p><pre><code>def animate(i):    graph_data = open('example.txt','r').read()    lines = graph_data.split('\n')    xs = []    ys = []    for line in lines:        if len(line) &gt; 1:            x, y = line.split(',')            xs.append(x)            ys.append(y)    ax1.clear()    ax1.plot(xs, ys)</code></pre><p>我们在这里做的是构建数据，然后绘制它。 注意我们这里不调用<code>plt.show()</code>。 我们从一个示例文件读取数据，其内容如下：</p><pre><code>1,52,33,44,75,46,37,58,79,410,4</code></pre><p>我们打开上面的文件，然后存储每一行，用逗号分割成<code>xs</code>和<code>ys</code>，我们将要绘制它。 然后：</p><pre><code>ani = animation.FuncAnimation(fig, animate, interval=1000)plt.show()</code></pre><p>我们运行动画，将动画放到图表中（<code>fig</code>），运行<code>animate</code>的动画函数，最后我们设置了 1000 的间隔，即 1000 毫秒或 1 秒。</p><p>运行此图表的结果应该像往常一样生成图表。 然后，你应该能够使用新的坐标更新<code>example.txt</code>文件。 这样做会生成一个自动更新的图表，如下：</p><p>[图片上传失败…(image-3aca35-1558443769838)]</p><h1 id="第十七章-注解和文本"><a href="#第十七章-注解和文本" class="headerlink" title="第十七章 注解和文本"></a>第十七章 注解和文本</h1><p>在本教程中，我们将讨论如何向 Matplotlib 图形添加文本。 我们可以通过两种方式来实现。 一种是将文本放置在图表上的某个位置。 另一个是专门注解图表上的绘图，来引起注意。</p><p>这里的起始代码是教程 15，它在这里：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)def bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax1.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax1.grid(True)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('ebay')</code></pre><p>所以这里是 Yahoo Finance API 的 eBay 的 OHLC K 线图。 这里我们要讲解的第一件事是向图形添加文本。</p><pre><code>font_dict = {'family':'serif',             'color':'darkred',             'size':15}ax1.text(date[10], closep[1],'Text Example', fontdict=font_dict)</code></pre><p>在这里，我们需要做一些事情。 首先，我们使用<code>ax1.text</code>添加文本。 我们使用我们的数据，以坐标形式给出此文本的位置。 首先给出文本的坐标，然后给出要放置的实际文本。 接下来，我们使用<code>fontdict</code>参数添加一个数据字典，来使用所用的字体。 在我们的字体字典中，我们将字体更改为<code>serif</code>，颜色为『深红色』，然后将字体大小更改为 15。这将全部应用于我们的图表上的文本，如下所示：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-31586a626a3d1952.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>太棒了，接下来我们可以做的是，注解某个特定的绘图。 我们希望这样做来给出更多的信息。 在 eBay 的例子中，也许我们想解释某个具体绘图，或给出一些关于发生了什么的信息。 在股价的例子中，也许有一些发生的新闻会影响价格。 你可以注解新闻来自哪里，这将有助于解释定价变化。</p><pre><code>ax1.annotate('Bad News!',(date[9],highp[9]),             xytext=(0.8, 0.9), textcoords='axes fraction',             arrowprops = dict(facecolor='grey',color='grey'))</code></pre><p>这里，我们用<code>ax1.annotate</code>来注解。 我们首先传递我们想要注解的文本，然后传递我们让这个注解指向的坐标。 我们这样做，是因为当我们注释时，我们可以绘制线条和指向特定点的箭头。 接下来，我们指定<code>xytext</code>的位置。 它可以是像我们用于文本放置的坐标位置，但是让我们展示另一个例子。 它可以为轴域小数，所以我们使用 0.8 和 0.9。 这意味着文本的位置在<code>x</code>轴的80％和<code>y</code>轴的90％处。 这样，如果我们移动图表，文本将保持在相同位置。</p><p>执行它，会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-2693ab1290c82f96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>根据你学习这个教程的时间，所指向的点可能有所不同，这只是一个注解的例子，其中有一些合理的想法，即为什么我们需要注解一些东西。</p><p>当图表启动时，请尝试单击平移按钮（蓝色十字），然后移动图表。 你会看到文本保持不动，但箭头跟随移动并继续指向我们想要的具体的点。 这很酷吧！</p><p>最后一个图表的完整代码：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)def bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax1.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax1.grid(True)    ax1.annotate('Bad News!',(date[9],highp[9]),                 xytext=(0.8, 0.9), textcoords='axes fraction',                 arrowprops = dict(facecolor='grey',color='grey'))##    # Text placement example:##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    ax1.text(date[10], closep[1],'Text Example', fontdict=font_dict)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    #plt.legend()    plt.subplots_adjust(left=0.09, bottom=0.20, right=0.94, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('ebay')</code></pre><p>现在，使用注解，我们可以做一些其他事情，如注解股票图表的最后价格。 这就是我们接下来要做的。</p><h1 id="第十八章-注解股票图表的最后价格"><a href="#第十八章-注解股票图表的最后价格" class="headerlink" title="第十八章 注解股票图表的最后价格"></a>第十八章 注解股票图表的最后价格</h1><p>在这个 Matplotlib 教程中，我们将展示如何跟踪股票的最后价格的示例，通过将其注解到轴域的右侧，就像许多图表应用程序会做的那样。</p><p>虽然人们喜欢在他们的实时图表中看到历史价格，他们也想看到最新的价格。 大多数应用程序做的是，在价格的<code>y</code>轴高度处注释最后价格，然后突出显示它，并在价格变化时，在框中将其略微移动。 使用我们最近学习的注解教程，我们可以添加一个<code>bbox</code>。</p><p>我们的核心代码是：</p><pre><code>bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)ax1.annotate(str(closep[-1]), (date[-1], closep[-1]),             xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)</code></pre><p>我们使用<code>ax1.annotate</code>来放置最后价格的字符串值。 我们不在这里使用它，但我们将要注解的点指定为图上最后一个点。 接下来，我们使用<code>xytext</code>将我们的文本放置到特定位置。 我们将它的<code>y</code>坐标指定为最后一个点的<code>y</code>坐标，<code>x</code>坐标指定为最后一个点的<code>x</code>坐标，再加上几个点。我们这样做是为了将它移出图表。 将文本放在图形外面就足够了，但现在它只是一些浮动文本。</p><p>我们使用<code>bbox</code>参数在文本周围创建一个框。 我们使用<code>bbox_props</code>创建一个属性字典，包含盒子样式，然后是白色（<code>w</code>）前景色，黑色（<code>k</code>）边框颜色并且线宽为 1。 更多框样式请参阅 <a href="https://link.jianshu.com?t=http://matplotlib.org/users/annotations_guide.html" target="_blank" rel="noopener">matplotlib 注解文档</a>。</p><p>最后，这个注解向右移动，需要我们使用<code>subplots_adjust</code>来创建一些新空间：</p><pre><code>plt.subplots_adjust(left=0.11, bottom=0.24, right=0.87, top=0.90, wspace=0.2, hspace=0)</code></pre><p>这里的完整代码如下：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)def bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((1,1), (0,0))    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1m/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    candlestick_ohlc(ax1, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax1.xaxis.get_ticklabels():        label.set_rotation(45)    ax1.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax1.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax1.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax1.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+3, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax1.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text##    ax1.text(date[10], closep[1],'Text Example', fontdict=font_dict)    plt.xlabel('Date')    plt.ylabel('Price')    plt.title(stock)    #plt.legend()    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.87, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-80de7ea61e49212b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第十九章-子图"><a href="#第十九章-子图" class="headerlink" title="第十九章 子图"></a>第十九章 子图</h1><p>在这个 Matplotlib 教程中，我们将讨论子图。 有两种处理子图的主要方法，用于在同一图上创建多个图表。 现在，我们将从一个干净的代码开始。 如果你一直关注这个教程，那么请确保保留旧的代码，或者你可以随时重新查看上一个教程的代码。</p><p>首先，让我们使用样式，创建我们的图表，然后创建一个随机创建示例绘图的函数：</p><pre><code>import randomimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use('fivethirtyeight')fig = plt.figure()def create_plots():    xs = []    ys = []    for i in range(10):        x = i        y = random.randrange(10)        xs.append(x)        ys.append(y)    return xs, ys</code></pre><p>现在，我们开始使用<code>add_subplot</code>方法创建子图：</p><pre><code>ax1 = fig.add_subplot(221)ax2 = fig.add_subplot(222)ax3 = fig.add_subplot(212)</code></pre><p>它的工作原理是使用 3 个数字，即：行数（<code>numRows</code>）、列数（<code>numCols</code>）和绘图编号（<code>plotNum</code>）。</p><p>所以，221 表示两行两列的第一个位置。222 是两行两列的第二个位置。最后，212 是两行一列的第二个位置。</p><pre><code>2x2：+-----+-----+|  1  |  2  |+-----+-----+|  3  |  4  |+-----+-----+2x1：+-----------+|     1     |+-----------+|     2     |+-----------+</code></pre><blockquote><p>译者注：原文此处表述有误，译文已更改。</p></blockquote><blockquote><p>译者注：<code>221</code>是缩写形式，仅在行数乘列数小于 10 时有效，否则要写成<code>2,2,1</code>。</p></blockquote><p>此代码结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-c927e9ad943f9c86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这就是<code>add_subplot</code>。 尝试一些你认为可能很有趣的配置，然后尝试使用<code>add_subplot</code>创建它们，直到你感到满意。</p><p>接下来，让我们介绍另一种方法，它是<code>subplot2grid</code>。</p><p>删除或注释掉其他轴域定义，然后添加：</p><pre><code>ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1)ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1)</code></pre><p>所以，<code>add_subplot</code>不能让我们使一个绘图覆盖多个位置。 但是这个新的<code>subplot2grid</code>可以。 所以，<code>subplot2grid</code>的工作方式是首先传递一个元组，它是网格形状。 我们传递了<code>(6,1)</code>，这意味着整个图表分为六行一列。 下一个元组是左上角的起始点。 对于<code>ax1</code>，这是<code>0,0</code>，因此它起始于顶部。 接下来，我们可以选择指定<code>rowspan</code>和<code>colspan</code>。 这是轴域所占的行数和列数。</p><pre><code>6x1：          colspan=1(0,0)   +-----------+        |    ax1    | rowspan=1(1,0)   +-----------+        |           |        |    ax2    | rowspan=4        |           |        |           |(5,0)   +-----------+        |    ax3    | rowspan=1        +-----------+</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-efd554f7f908c9fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>显然，我们在这里有一些重叠的问题，我们可以调整子图来处理它。</p><p>再次，尝试构思各种配置的子图，使用<code>subplot2grid</code>制作出来，直到你感到满意！</p><p>我们将继续使用<code>subplot2grid</code>，将它应用到我们已经逐步建立的代码中，我们将在下一个教程中继续。</p><h1 id="第二十一章-更多指标数据"><a href="#第二十一章-更多指标数据" class="headerlink" title="第二十一章 更多指标数据"></a>第二十一章 更多指标数据</h1><p>在这篇 Matplotlib 教程中，我们介绍了添加一些简单的函数来计算数据，以便我们填充我们的轴域。 一个是简单的移动均值，另一个是简单的价格 HML 计算。</p><p>这些新函数是：</p><pre><code>def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lows</code></pre><p>你不需要太过专注于理解移动均值的工作原理，我们只是对样本数据来计算它，以便可以学习更多自定义 Matplotlib 的东西。</p><p>我们还想在脚本顶部为移动均值定义一些值：</p><pre><code>MA1 = 10MA2 = 30</code></pre><p>下面，在我们的<code>graph_data</code>函数中：</p><pre><code>ma1 = moving_average(closep,MA1)ma2 = moving_average(closep,MA2)start = len(date[MA2-1:])h_l = list(map(high_minus_low, highp, lowp))</code></pre><p>在这里，我们计算两个移动均值和 HML。</p><p>我们还定义了一个『起始』点。 我们这样做是因为我们希望我们的数据排成一行。 例如，20 天的移动均值需要 20 个数据点。 这意味着我们不能在第 5 天真正计算 20 天的移动均值。 因此，当我们计算移动均值时，我们会失去一些数据。 为了处理这种数据的减法，我们使用起始变量来计算应该有多少数据。 这里，我们可以安全地使用<code>[-start:]</code>绘制移动均值，并且如果我们希望的话，对所有绘图进行上述步骤来排列数据。</p><p>接下来，我们可以在<code>ax1</code>上绘制 HML，通过这样：</p><pre><code>ax1.plot_date(date,h_l,'-')</code></pre><p>最后我们可以通过这样向<code>ax3</code>添加移动均值：</p><pre><code>ax3.plot(date[-start:], ma1[-start:])ax3.plot(date[-start:], ma2[-start:])</code></pre><p>我们的完整代码，包括增加我们所用的时间范围：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1)    plt.xlabel('Date')    plt.ylabel('Price')    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1)    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date,h_l,'-')    candlestick_ohlc(ax2, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax2.xaxis.get_ticklabels():        label.set_rotation(45)    ax2.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax2.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax3.plot(date[-start:], ma1[-start:])    ax3.plot(date[-start:], ma2[-start:])    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>代码效果如图：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-d289f6cde6d705de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第二十二章-自定义填充、修剪和清除"><a href="#第二十二章-自定义填充、修剪和清除" class="headerlink" title="第二十二章 自定义填充、修剪和清除"></a>第二十二章 自定义填充、修剪和清除</h1><p>欢迎阅读另一个 Matplotlib 教程！ 在本教程中，我们将清除图表，然后再做一些自定义。</p><p>我们当前的代码是：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1)    plt.xlabel('Date')    plt.ylabel('Price')    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1)    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date,h_l,'-')    candlestick_ohlc(ax2, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    for label in ax2.xaxis.get_ticklabels():        label.set_rotation(45)    ax2.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax2.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax3.plot(date[-start:], ma1[-start:])    ax3.plot(date[-start:], ma2[-start:])    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>现在我认为向我们的移动均值添加自定义填充是一个很好的主意。 移动均值通常用于说明价格趋势。 这个想法是，你可以计算一个快速和一个慢速的移动均值。 一般来说，移动均值用于使价格变得『平滑』。 他们总是『滞后』于价格，但是我们的想法是计算不同的速度。 移动均值越大就越『慢』。 所以这个想法是，如果『较快』的移动均值超过『较慢』的均值，那么价格就会上升，这是一件好事。 如果较快的 MA 从较慢的 MA 下方穿过，则这是下降趋势并且通常被视为坏事。 我的想法是在快速和慢速 MA 之间填充，『上升』趋势为绿色，然后下降趋势为红色。 方法如下：</p><pre><code>ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                 where=(ma1[-start:] &lt; ma2[-start:]),                 facecolor='r', edgecolor='r', alpha=0.5)ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                 where=(ma1[-start:] &gt; ma2[-start:]),                 facecolor='g', edgecolor='g', alpha=0.5)</code></pre><p>下面，我们会碰到一些我们可解决的问题：</p><pre><code>ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))for label in ax3.xaxis.get_ticklabels():    label.set_rotation(45)plt.setp(ax1.get_xticklabels(), visible=False)plt.setp(ax2.get_xticklabels(), visible=False)</code></pre><p>这里，我们剪切和粘贴<code>ax2</code>日期格式，然后我们将<code>x</code>刻度标签设置为<code>false</code>，去掉它们！</p><p>我们还可以通过在轴域定义中执行以下操作，为每个轴域提供自定义标签：</p><pre><code>fig = plt.figure()ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)plt.title(stock)ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1)plt.xlabel('Date')plt.ylabel('Price')ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1)</code></pre><p>接下来，我们可以看到，我们<code>y</code>刻度有许多数字，经常互相覆盖。 我们也看到轴之间互相重叠。 我们可以这样：</p><pre><code>ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=5, prune='lower'))</code></pre><p>所以，这里发生的是，我们通过首先将<code>nbins</code>设置为 5 来修改我们的<code>y</code>轴对象。这意味着我们显示的标签最多为 5 个。然后我们还可以『修剪』标签，因此，在我们这里， 我们修剪底部标签，这会使它消失，所以现在不会有任何文本重叠。 我们仍然可能打算修剪<code>ax2</code>的顶部标签，但这里是我们目前为止的源代码：</p><p>当前的源码：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    plt.ylabel('H-L')    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1)    plt.ylabel('Price')    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1)    plt.ylabel('MAvgs')    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date,h_l,'-')    ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=5, prune='lower'))    candlestick_ohlc(ax2, ohlc, width=0.4, colorup='#77d879', colordown='#db3f3f')    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax3.plot(date[-start:], ma1[-start:], linewidth=1)    ax3.plot(date[-start:], ma2[-start:], linewidth=1)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &lt; ma2[-start:]),                     facecolor='r', edgecolor='r', alpha=0.5)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &gt; ma2[-start:]),                     facecolor='g', edgecolor='g', alpha=0.5)    ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))    for label in ax3.xaxis.get_ticklabels():        label.set_rotation(45)    plt.setp(ax1.get_xticklabels(), visible=False)    plt.setp(ax2.get_xticklabels(), visible=False)    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-228d950fb6e2a065.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>看起来好了一些，但是仍然有一些东西需要清除。</p><h1 id="第二十三章-共享-X-轴"><a href="#第二十三章-共享-X-轴" class="headerlink" title="第二十三章 共享 X 轴"></a>第二十三章 共享 X 轴</h1><p>在这个 Matplotlib 数据可视化教程中，我们将讨论<code>sharex</code>选项，它允许我们在图表之间共享<code>x</code>轴。将<code>sharex</code>看做『复制 x』也许更好。</p><p>在我们开始之前，首先我们要做些修剪并在另一个轴上设置最大刻度数，如下所示：</p><pre><code>ax2.yaxis.set_major_locator(mticker.MaxNLocator(nbins=7, prune='upper'))</code></pre><p>以及</p><pre><code>ax3.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='upper'))</code></pre><p>现在，让我们共享所有轴域之间的<code>x</code>轴。 为此，我们需要将其添加到轴域定义中：</p><pre><code>fig = plt.figure()ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)plt.title(stock)plt.ylabel('H-L')ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1, sharex=ax1)plt.ylabel('Price')ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1, sharex=ax1)plt.ylabel('MAvgs')</code></pre><p>上面，对于<code>ax2</code>和<code>ax3</code>，我们添加一个新的参数，称为<code>sharex</code>，然后我们说，我们要与<code>ax1</code>共享<code>x</code>轴。</p><p>使用这种方式，我们可以加载图表，然后我们可以放大到一个特定的点，结果将是这样：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-5edfc228b965924d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>所以这意味着所有轴域沿着它们的<code>x</code>轴一起移动。 这很酷吧！</p><p>接下来，让我们将<code>[-start:]</code>应用到所有数据，所以所有轴域都起始于相同地方。 我们最终的代码为：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    plt.ylabel('H-L')    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1, sharex=ax1)    plt.ylabel('Price')    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1, sharex=ax1)    plt.ylabel('MAvgs')    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date[-start:],h_l[-start:],'-')    ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='lower'))    candlestick_ohlc(ax2, ohlc[-start:], width=0.4, colorup='#77d879', colordown='#db3f3f')    ax2.yaxis.set_major_locator(mticker.MaxNLocator(nbins=7, prune='upper'))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax3.plot(date[-start:], ma1[-start:], linewidth=1)    ax3.plot(date[-start:], ma2[-start:], linewidth=1)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &lt; ma2[-start:]),                     facecolor='r', edgecolor='r', alpha=0.5)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &gt; ma2[-start:]),                     facecolor='g', edgecolor='g', alpha=0.5)    ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax3.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='upper'))    for label in ax3.xaxis.get_ticklabels():        label.set_rotation(45)    plt.setp(ax1.get_xticklabels(), visible=False)    plt.setp(ax2.get_xticklabels(), visible=False)    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('EBAY')</code></pre><p>下面我们会讨论如何创建多个<code>y</code>轴。</p><h1 id="第二十四章-多个-Y-轴"><a href="#第二十四章-多个-Y-轴" class="headerlink" title="第二十四章 多个 Y 轴"></a>第二十四章 多个 Y 轴</h1><p>在这篇 Matplotlib 教程中，我们将介绍如何在同一子图上使用多个 Y 轴。 在我们的例子中，我们有兴趣在同一个图表及同一个子图上绘制股票价格和交易量。</p><p>为此，首先我们需要定义一个新的轴域，但是这个轴域是<code>ax2</code>仅带有<code>x</code>轴的『双生子』。</p><p>这足以创建轴域了。我们叫它<code>ax2v</code>，因为这个轴域是<code>ax2</code>加交易量。</p><p>现在，我们在轴域上定义绘图，我们将添加：</p><pre><code>ax2v.fill_between(date[-start:],0, volume[-start:], facecolor='#0079a3', alpha=0.4)</code></pre><p>我们在 0 和当前交易量之间填充，给予它蓝色的前景色，然后给予它一个透明度。 我们想要应用幽冥毒，以防交易量最终覆盖其它东西，所以我们仍然可以看到这两个元素。</p><p>所以，到现在为止，我们的代码为：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    plt.ylabel('H-L')    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1, sharex=ax1)    plt.ylabel('Price')    ax2v = ax2.twinx()    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1, sharex=ax1)    plt.ylabel('MAvgs')    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date[-start:],h_l[-start:],'-')    ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='lower'))    candlestick_ohlc(ax2, ohlc[-start:], width=0.4, colorup='#77d879', colordown='#db3f3f')    ax2.yaxis.set_major_locator(mticker.MaxNLocator(nbins=7, prune='upper'))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax2v.fill_between(date[-start:],0, volume[-start:], facecolor='#0079a3', alpha=0.4)    ax3.plot(date[-start:], ma1[-start:], linewidth=1)    ax3.plot(date[-start:], ma2[-start:], linewidth=1)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &lt; ma2[-start:]),                     facecolor='r', edgecolor='r', alpha=0.5)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &gt; ma2[-start:]),                     facecolor='g', edgecolor='g', alpha=0.5)    ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax3.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='upper'))    for label in ax3.xaxis.get_ticklabels():        label.set_rotation(45)    plt.setp(ax1.get_xticklabels(), visible=False)    plt.setp(ax2.get_xticklabels(), visible=False)    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('GOOG')</code></pre><p>会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0afba1786b413e08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>太棒了，到目前为止还不错。 接下来，我们可能要删除新<code>y</code>轴上的标签，然后我们也可能不想让交易量占用太多空间。 没问题：</p><p>首先：</p><pre><code>ax2v.axes.yaxis.set_ticklabels([])</code></pre><p>上面将<code>y</code>刻度标签设置为一个空列表，所以不会有任何标签了。</p><blockquote><p>译者注：所以将标签删除之后，添加新轴的意义是什么？直接在原轴域上绘图就可以了。</p></blockquote><p>接下来，我们可能要将网格设置为<code>false</code>，使轴域上不会有双网格：</p><pre><code>ax2v.grid(False)</code></pre><p>最后，为了处理交易量占用很多空间，我们可以做以下操作：</p><pre><code>ax2v.set_ylim(0, 3*volume.max())</code></pre><p>所以这设置<code>y</code>轴显示范围从 0 到交易量的最大值的 3 倍。 这意味着，在最高点，交易量最多可占据图形的33％。 所以，增加<code>volume.max</code>的倍数越多，空间就越小/越少。</p><p>现在，我们的图表为：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure()    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    plt.ylabel('H-L')    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1, sharex=ax1)    plt.ylabel('Price')    ax2v = ax2.twinx()    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1, sharex=ax1)    plt.ylabel('MAvgs')    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date[-start:],h_l[-start:],'-')    ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='lower'))    candlestick_ohlc(ax2, ohlc[-start:], width=0.4, colorup='#77d879', colordown='#db3f3f')    ax2.yaxis.set_major_locator(mticker.MaxNLocator(nbins=7, prune='upper'))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+5, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax2v.fill_between(date[-start:],0, volume[-start:], facecolor='#0079a3', alpha=0.4)    ax2v.axes.yaxis.set_ticklabels([])    ax2v.grid(False)    ax2v.set_ylim(0, 3*volume.max())    ax3.plot(date[-start:], ma1[-start:], linewidth=1)    ax3.plot(date[-start:], ma2[-start:], linewidth=1)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &lt; ma2[-start:]),                     facecolor='r', edgecolor='r', alpha=0.5)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &gt; ma2[-start:]),                     facecolor='g', edgecolor='g', alpha=0.5)    ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax3.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='upper'))    for label in ax3.xaxis.get_ticklabels():        label.set_rotation(45)    plt.setp(ax1.get_xticklabels(), visible=False)    plt.setp(ax2.get_xticklabels(), visible=False)    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    plt.show()graph_data('GOOG')</code></pre><p>到这里，我们差不多完成了。 这里唯一的缺陷是一个好的图例。 一些线条是显而易见的，但人们可能会好奇移动均值的参数是什么，我们这里是 10 和 30。 添加自定义图例是下一个教程中涉及的内容。</p><h1 id="第二十五章-自定义图例"><a href="#第二十五章-自定义图例" class="headerlink" title="第二十五章 自定义图例"></a>第二十五章 自定义图例</h1><p>在这篇 Matplotlib 教程中，我们将讨论自定义图例。 我们已经介绍了<a href="https://link.jianshu.com?t=http://pythonprogramming.net/legends-titles-labels-matplotlib-tutorial/" target="_blank" rel="noopener">添加图例的基础知识</a>。</p><p>图例的主要问题通常是图例阻碍了数据的展示。 这里有几个选项。 一个选项是将图例放在轴域外，但是我们在这里有多个子图，这是非常困难的。 相反，我们将使图例稍微小一点，然后应用一个透明度。</p><p>首先，为了创建一个图例，我们需要向我们的数据添加我们想要显示在图例上的标签。</p><pre><code>ax1.plot_date(date[-start:],h_l[-start:],'-', label='H-L')...ax2v.plot([],[], color='#0079a3', alpha=0.4, label='Volume')...ax3.plot(date[-start:], ma1[-start:], linewidth=1, label=(str(MA1)+'MA'))ax3.plot(date[-start:], ma2[-start:], linewidth=1, label=(str(MA2)+'MA'))</code></pre><p>请注意，我们通过创建空行为交易量添加了标签。 请记住，我们不能对任何填充应用标签，所以这就是我们添加这个空行的原因。</p><p>现在，我们可以在右下角添加图例，通过在<code>plt.show()</code>之前执行以下操作：</p><pre><code>ax1.legend()ax2v.legend()ax3.legend()</code></pre><p>会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-8ed0949ea9e20edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>所以，我们可以看到，图例还是占用了一些位置。 让我们更改位置，大小并添加透明度：</p><pre><code>ax1.legend()leg = ax1.legend(loc=9, ncol=2,prop={'size':11})leg.get_frame().set_alpha(0.4)ax2v.legend()leg = ax2v.legend(loc=9, ncol=2,prop={'size':11})leg.get_frame().set_alpha(0.4)ax3.legend()leg = ax3.legend(loc=9, ncol=2,prop={'size':11})leg.get_frame().set_alpha(0.4)</code></pre><p>所有的图例位于位置 9（上中间）。 有很多地方可放置图例，我们可以为参数传入不同的位置号码，来看看它们都位于哪里。 <code>ncol</code>参数允许我们指定图例中的列数。 这里只有一列，如果图例中有 2 个项目，他们将堆叠在一列中。 最后，我们将尺寸规定为更小。 之后，我们对整个图例应用<code>0.4</code>的透明度。</p><p>现在我们的结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-395f6c13913c7a53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>完整的代码为：</p><pre><code>import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport matplotlib.ticker as mtickerfrom matplotlib.finance import candlestick_ohlcfrom matplotlib import styleimport numpy as npimport urllibimport datetime as dtstyle.use('fivethirtyeight')print(plt.style.available)print(plt.__file__)MA1 = 10MA2 = 30def moving_average(values, window):    weights = np.repeat(1.0, window)/window    smas = np.convolve(values, weights, 'valid')    return smasdef high_minus_low(highs, lows):    return highs-lowsdef bytespdate2num(fmt, encoding='utf-8'):    strconverter = mdates.strpdate2num(fmt)    def bytesconverter(b):        s = b.decode(encoding)        return strconverter(s)    return bytesconverterdef graph_data(stock):    fig = plt.figure(facecolor='#f0f0f0')    ax1 = plt.subplot2grid((6,1), (0,0), rowspan=1, colspan=1)    plt.title(stock)    plt.ylabel('H-L')    ax2 = plt.subplot2grid((6,1), (1,0), rowspan=4, colspan=1, sharex=ax1)    plt.ylabel('Price')    ax2v = ax2.twinx()    ax3 = plt.subplot2grid((6,1), (5,0), rowspan=1, colspan=1, sharex=ax1)    plt.ylabel('MAvgs')    stock_price_url = 'http://chartapi.finance.yahoo.com/instrument/1.0/'+stock+'/chartdata;type=quote;range=1y/csv'    source_code = urllib.request.urlopen(stock_price_url).read().decode()    stock_data = []    split_source = source_code.split('\n')    for line in split_source:        split_line = line.split(',')        if len(split_line) == 6:            if 'values' not in line and 'labels' not in line:                stock_data.append(line)    date, closep, highp, lowp, openp, volume = np.loadtxt(stock_data,                                                          delimiter=',',                                                          unpack=True,                                                          converters={0: bytespdate2num('%Y%m%d')})    x = 0    y = len(date)    ohlc = []    while x &lt; y:        append_me = date[x], openp[x], highp[x], lowp[x], closep[x], volume[x]        ohlc.append(append_me)        x+=1    ma1 = moving_average(closep,MA1)    ma2 = moving_average(closep,MA2)    start = len(date[MA2-1:])    h_l = list(map(high_minus_low, highp, lowp))    ax1.plot_date(date[-start:],h_l[-start:],'-', label='H-L')    ax1.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='lower'))    candlestick_ohlc(ax2, ohlc[-start:], width=0.4, colorup='#77d879', colordown='#db3f3f')    ax2.yaxis.set_major_locator(mticker.MaxNLocator(nbins=7, prune='upper'))    ax2.grid(True)    bbox_props = dict(boxstyle='round',fc='w', ec='k',lw=1)    ax2.annotate(str(closep[-1]), (date[-1], closep[-1]),                 xytext = (date[-1]+4, closep[-1]), bbox=bbox_props)##    # Annotation example with arrow##    ax2.annotate('Bad News!',(date[11],highp[11]),##                 xytext=(0.8, 0.9), textcoords='axes fraction',##                 arrowprops = dict(facecolor='grey',color='grey'))####    ##    # Font dict example##    font_dict = {'family':'serif',##                 'color':'darkred',##                 'size':15}##    # Hard coded text ##    ax2.text(date[10], closep[1],'Text Example', fontdict=font_dict)    ax2v.plot([],[], color='#0079a3', alpha=0.4, label='Volume')    ax2v.fill_between(date[-start:],0, volume[-start:], facecolor='#0079a3', alpha=0.4)    ax2v.axes.yaxis.set_ticklabels([])    ax2v.grid(False)    ax2v.set_ylim(0, 3*volume.max())    ax3.plot(date[-start:], ma1[-start:], linewidth=1, label=(str(MA1)+'MA'))    ax3.plot(date[-start:], ma2[-start:], linewidth=1, label=(str(MA2)+'MA'))    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &lt; ma2[-start:]),                     facecolor='r', edgecolor='r', alpha=0.5)    ax3.fill_between(date[-start:], ma2[-start:], ma1[-start:],                     where=(ma1[-start:] &gt; ma2[-start:]),                     facecolor='g', edgecolor='g', alpha=0.5)    ax3.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))    ax3.xaxis.set_major_locator(mticker.MaxNLocator(10))    ax3.yaxis.set_major_locator(mticker.MaxNLocator(nbins=4, prune='upper'))    for label in ax3.xaxis.get_ticklabels():        label.set_rotation(45)    plt.setp(ax1.get_xticklabels(), visible=False)    plt.setp(ax2.get_xticklabels(), visible=False)    plt.subplots_adjust(left=0.11, bottom=0.24, right=0.90, top=0.90, wspace=0.2, hspace=0)    ax1.legend()    leg = ax1.legend(loc=9, ncol=2,prop={'size':11})    leg.get_frame().set_alpha(0.4)    ax2v.legend()    leg = ax2v.legend(loc=9, ncol=2,prop={'size':11})    leg.get_frame().set_alpha(0.4)    ax3.legend()    leg = ax3.legend(loc=9, ncol=2,prop={'size':11})    leg.get_frame().set_alpha(0.4)    plt.show()    fig.savefig('google.png', facecolor=fig.get_facecolor())graph_data('GOOG')</code></pre><p>现在我们可以看到图例，但也看到了图例下的任何信息。 还要注意额外函数<code>fig.savefig</code>。 这是自动保存图形的图像的方式。 我们还可以设置所保存的图形的前景色，使背景不是白色的，如我们的例子所示。</p><p>这就是目前为止，我想要显示的典型 Matplotlib 图表。 接下来，我们将涉及<code>Basemap</code>，它是一个 Matplotlib 扩展，用于绘制地理位置，然后我打算讲解 Matplotlib 中的 3D 图形。</p><h1 id="第二十六章-Basemap-地理绘图"><a href="#第二十六章-Basemap-地理绘图" class="headerlink" title="第二十六章 Basemap 地理绘图"></a>第二十六章 Basemap 地理绘图</h1><p>在这个 Matplotlib 教程中，我们将涉及地理绘图模块<code>Basemap</code>。 <code>Basemap</code>是 Matplotlib 的扩展。</p><p>为了使用<code>Basemap</code>，我们首先需要安装它。 为了获得<code>Basemap</code>，你可以从这里获取：<a href="https://link.jianshu.com?t=http://matplotlib.org/basemap/users/download.html" target="_blank" rel="noopener">http://matplotlib.org/basemap/users/download.html</a>，或者你可以访问<a href="https://link.jianshu.com?t=http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a>。</p><p>如果你在安装<code>Basemap</code>时遇到问题，请查看<a href="https://link.jianshu.com?t=http://pythonprogramming.net/using-pip-install-for-python-modules/" target="_blank" rel="noopener"><code>pip</code>安装教程</a>。</p><p>一旦你安装了<code>Basemap</code>，你就可以创建地图了。 首先，让我们投影一个简单的地图。 为此，我们需要导入<code>Basemap</code>，<code>pyplot</code>，创建投影，至少绘制某种轮廓或数据，然后我们可以显示图形。</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill')m.drawcoastlines()plt.show()</code></pre><p>上面的代码结果如下：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-569ad48f57937c8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这是使用 Miller 投影完成的，这只是许多<a href="https://link.jianshu.com?t=http://matplotlib.org/basemap/users/mapsetup.html" target="_blank" rel="noopener"><code>Basemap</code>投影选项</a>之一。</p><h1 id="第二十七章-Basemap-自定义"><a href="#第二十七章-Basemap-自定义" class="headerlink" title="第二十七章 Basemap 自定义"></a>第二十七章 Basemap 自定义</h1><p>在这篇 Matplotlib 教程中，我们继续使用<code>Basemap</code>地理绘图扩展。 我们将展示一些我们可用的自定义选项。</p><p>首先，从上一个教程中获取我们的起始代码：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill')m.drawcoastlines()plt.show()</code></pre><p>我们可以从放大到特定区域来开始：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill',            llcrnrlat = -40,            llcrnrlon = -40,            urcrnrlat = 50,            urcrnrlon = 75)m.drawcoastlines()plt.show()</code></pre><p>这里的参数是：</p><ul><li><code>llcrnrlat</code> - 左下角的纬度</li><li><code>llcrnrlon</code> - 左下角的经度</li><li><code>urcrnrlat</code> - 右上角的纬度</li><li><code>urcrnrlon</code> - 右上角的经度</li></ul><p>此外，坐标需要转换，其中西经和南纬坐标是负值，北纬和东经坐标是正值。</p><p>使用这些坐标，<code>Basemap</code>会选择它们之间的区域。</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-05da7c940b2df3ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>下面，我们要使用一些东西，类似：</p><pre><code>m.drawcountries(linewidth=2)</code></pre><p>这会画出国家，并使用线宽为 2 的线条生成分界线。</p><p>另一个选项是：</p><pre><code>m.drawstates(color='b')</code></pre><p>这会用蓝色线条画出州。</p><p>你也可以执行：</p><pre><code>m.drawcounties(color='darkred')</code></pre><p>这会画出国家。</p><p>所以，我们的代码是：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill',            llcrnrlat = -90,            llcrnrlon = -180,            urcrnrlat = 90,            urcrnrlon = 180)m.drawcoastlines()m.drawcountries(linewidth=2)m.drawstates(color='b')m.drawcounties(color='darkred')plt.title('Basemap Tutorial')plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-0defc2500a817a8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>很难说，但我们定义了美国的区县的线条。 我们可以使用放大镜放大<code>Basemap</code>图形，就像其他图形那样，会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a7a79fe24a963910.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>另一个有用的选项是<code>Basemap</code>调用中的『分辨率』选项。</p><pre><code>m = Basemap(projection='mill',            llcrnrlat = -90,            llcrnrlon = -180,            urcrnrlat = 90,            urcrnrlon = 180,            resolution='l')</code></pre><p>分辨率的选项为：</p><ul><li><code>c</code> - 粗糙</li><li><code>l</code> - 低</li><li><code>h</code> - 高</li><li><code>f</code> - 完整</li></ul><p>对于更高的分辨率，你应该放大到很大，否则这可能只是浪费。</p><p>另一个选项是使用<code>etopo()</code>绘制地形，如：</p><pre><code>m.etopo()</code></pre><p>使用<code>drawcountries</code>方法绘制此图形会生成：</p><p>[图片上传失败…(image-eaca82-1558445064342)]</p><p>最后，有一个蓝色的大理石版本，你可以调用：</p><pre><code>m.bluemarble()</code></pre><p>会生成：</p><p>[图片上传失败…(image-3f9978-1558445064342)]</p><p>目前为止的代码：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill',            llcrnrlat = -90,            llcrnrlon = -180,            urcrnrlat = 90,            urcrnrlon = 180,            resolution='l')m.drawcoastlines()m.drawcountries(linewidth=2)##m.drawstates(color='b')##m.drawcounties(color='darkred')#m.fillcontinents()#m.etopo()m.bluemarble()plt.title('Basemap Tutorial')plt.show()</code></pre><h1 id="第二十八章-在-Basemap-中绘制坐标"><a href="#第二十八章-在-Basemap-中绘制坐标" class="headerlink" title="第二十八章 在 Basemap 中绘制坐标"></a>第二十八章 在 Basemap 中绘制坐标</h1><p>欢迎阅读另一个 Matplotlib Basemap 教程。 在本教程中，我们将介绍如何绘制单个坐标，以及如何在地理区域中连接这些坐标。</p><p>首先，我们将从一些基本的起始数据开始：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill',            llcrnrlat = 25,            llcrnrlon = -130,            urcrnrlat = 50,            urcrnrlon = -60,            resolution='l')m.drawcoastlines()m.drawcountries(linewidth=2)m.drawstates(color='b')</code></pre><p>接下来，我们可以绘制坐标，从获得它们的实际坐标开始。 记住，南纬和西经坐标需要转换为负值。 例如，纽约市是北纬<code>40.7127</code>西经<code>74.0059</code>。 我们可以在我们的程序中定义这些坐标，如：</p><pre><code>NYClat, NYClon = 40.7127, -74.0059</code></pre><p>之后我们将这些转换为要绘制的<code>x</code>和<code>y</code>坐标。</p><pre><code>xpt, ypt = m(NYClon, NYClat)</code></pre><p>注意这里，我们现在已经将坐标顺序翻转为<code>lon, lat</code>（纬度，经度）。 坐标通常以<code>lat, lon</code>顺序给出。 然而，在图形中，<code>lat, long</code>转换为<code>y, x</code>，我们显然不需要。 在某些时候，你必须翻转它们。 不要忘记这部分！</p><p>最后，我们可以绘制如下的坐标：</p><pre><code>m.plot(xpt, ypt, 'c*', markersize=15)</code></pre><p>这个图表上有一个青色的星，大小为 15。更多标记类型请参阅：<a href="https://link.jianshu.com?t=http://matplotlib.org/api/markers_api.html" target="_blank" rel="noopener">Matplotlib 标记文档</a>。</p><p>接下来，让我们再画一个位置，洛杉矶，加利福尼亚：</p><pre><code>LAlat, LAlon = 34.05, -118.25xpt, ypt = m(LAlon, LAlat)m.plot(xpt, ypt, 'g^', markersize=15)</code></pre><p>这次我们画出一个绿色三角，执行代码会生成：</p><p>[图片上传失败…(image-8e5eff-1558445064342)]</p><p>如果我们想连接这些图块怎么办？原来，我们可以像其它 Matplotlib 图表那样实现它。</p><p>首先，我们将那些<code>xpt</code>和<code>ypt</code>坐标保存到列表，类似这样的东西：</p><pre><code>xs = []ys = []NYClat, NYClon = 40.7127, -74.0059xpt, ypt = m(NYClon, NYClat)xs.append(xpt)ys.append(ypt)m.plot(xpt, ypt, 'c*', markersize=15)LAlat, LAlon = 34.05, -118.25xpt, ypt = m(LAlon, LAlat)xs.append(xpt)ys.append(ypt)m.plot(xpt, ypt, 'g^', markersize=15)m.plot(xs, ys, color='r', linewidth=3, label='Flight 98')</code></pre><p>会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-d8819d892b150a41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>太棒了。有时我们需要以圆弧连接图上的两个坐标。如何实现呢？</p><pre><code>m.drawgreatcircle(NYClon, NYClat, LAlon, LAlat, color='c', linewidth=3, label='Arc')</code></pre><p>我们的完整代码为：</p><pre><code>from mpl_toolkits.basemap import Basemapimport matplotlib.pyplot as pltm = Basemap(projection='mill',            llcrnrlat = 25,            llcrnrlon = -130,            urcrnrlat = 50,            urcrnrlon = -60,            resolution='l')m.drawcoastlines()m.drawcountries(linewidth=2)m.drawstates(color='b')#m.drawcounties(color='darkred')#m.fillcontinents()#m.etopo()#m.bluemarble()xs = []ys = []NYClat, NYClon = 40.7127, -74.0059xpt, ypt = m(NYClon, NYClat)xs.append(xpt)ys.append(ypt)m.plot(xpt, ypt, 'c*', markersize=15)LAlat, LAlon = 34.05, -118.25xpt, ypt = m(LAlon, LAlat)xs.append(xpt)ys.append(ypt)m.plot(xpt, ypt, 'g^', markersize=15)m.plot(xs, ys, color='r', linewidth=3, label='Flight 98')m.drawgreatcircle(NYClon, NYClat, LAlon, LAlat, color='c', linewidth=3, label='Arc')plt.legend(loc=4)plt.title('Basemap Tutorial')plt.show()</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-865c2809f199d4c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这就是<code>Basemap</code>的全部了，下一章关于 Matplotlib 的 3D 绘图。</p><h1 id="第二十九章-3D-绘图"><a href="#第二十九章-3D-绘图" class="headerlink" title="第二十九章 3D 绘图"></a>第二十九章 3D 绘图</h1><p>您好，欢迎阅读 Matplotlib 教程中的 3D 绘图。 Matplotlib 已经内置了三维图形，所以我们不需要再下载任何东西。 首先，我们需要引入一些完整的模块：</p><pre><code>from mpl_toolkits.mplot3d import axes3dimport matplotlib.pyplot as plt</code></pre><p>使用<code>axes3d</code>是因为它需要不同种类的轴域，以便在三维中实际绘制一些东西。 下面：</p><pre><code>fig = plt.figure()ax1 = fig.add_subplot(111, projection='3d')</code></pre><p>在这里，我们像通常一样定义图形，然后我们将<code>ax1</code>定义为通常的子图，只是这次使用 3D 投影。 我们需要这样做，以便提醒 Matplotlib 我们要提供三维数据。</p><p>现在让我们创建一些 3D 数据：</p><pre><code>x = [1,2,3,4,5,6,7,8,9,10]y = [5,6,7,8,2,5,6,3,7,2]z = [1,2,6,3,2,7,3,3,7,2]</code></pre><p>接下来，我们绘制它。 首先，让我们展示一个简单的线框示例：</p><pre><code>ax1.plot_wireframe(x,y,z)</code></pre><p>最后：</p><pre><code>ax1.set_xlabel('x axis')ax1.set_ylabel('y axis')ax1.set_zlabel('z axis')plt.show()</code></pre><p>我们完整的代码是：</p><pre><code>from mpl_toolkits.mplot3d import axes3dimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use('fivethirtyeight')fig = plt.figure()ax1 = fig.add_subplot(111, projection='3d')x = [1,2,3,4,5,6,7,8,9,10]y = [5,6,7,8,2,5,6,3,7,2]z = [1,2,6,3,2,7,3,3,7,2]ax1.plot_wireframe(x,y,z)ax1.set_xlabel('x axis')ax1.set_ylabel('y axis')ax1.set_zlabel('z axis')plt.show()</code></pre><p>结果为（包括所用的样式）：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-9d239adc0dcb7a4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这些 3D 图形可以进行交互。 首先，您可以使用鼠标左键单击并拖动来移动图形。 您还可以使用鼠标右键单击并拖动来放大或缩小。</p><h1 id="第三十章-3D-散点图"><a href="#第三十章-3D-散点图" class="headerlink" title="第三十章 3D 散点图"></a>第三十章 3D 散点图</h1><p>欢迎阅读另一个 3D Matplotlib 教程，会涉及如何绘制三维散点图。</p><p>绘制 3D 散点图非常类似于通常的散点图以及 3D 线框图。</p><p>一个简单示例：</p><pre><code>from mpl_toolkits.mplot3d import axes3dimport matplotlib.pyplot as pltfrom matplotlib import stylestyle.use('ggplot')fig = plt.figure()ax1 = fig.add_subplot(111, projection='3d')x = [1,2,3,4,5,6,7,8,9,10]y = [5,6,7,8,2,5,6,3,7,2]z = [1,2,6,3,2,7,3,3,7,2]x2 = [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]y2 = [-5,-6,-7,-8,-2,-5,-6,-3,-7,-2]z2 = [1,2,6,3,2,7,3,3,7,2]ax1.scatter(x, y, z, c='g', marker='o')ax1.scatter(x2, y2, z2, c ='r', marker='o')ax1.set_xlabel('x axis')ax1.set_ylabel('y axis')ax1.set_zlabel('z axis')plt.show()</code></pre><p>结果为：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a225497e6ca29fad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>要记住你可以修改这些绘图的大小和标记，就像通常的散点图那样。</p><h1 id="第三十一章-3D-条形图"><a href="#第三十一章-3D-条形图" class="headerlink" title="第三十一章 3D 条形图"></a>第三十一章 3D 条形图</h1><p>在这个 Matplotlib 教程中，我们要介绍 3D 条形图。 3D 条形图是非常独特的，因为它允许我们绘制多于 3 个维度。 不，你不能超过第三个维度来绘制，但你可以绘制多于 3 个维度。</p><p>对于条形图，你需要拥有条形的起点，条形的高度和宽度。 但对于 3D 条形图，你还有另一个选项，就是条形的深度。 大多数情况下，条形图从轴上的条形平面开始，但是你也可以通过打破此约束来添加另一个维度。 然而，我们会让它非常简单：</p><pre><code>from mpl_toolkits.mplot3d import axes3dimport matplotlib.pyplot as pltimport numpy as npfrom matplotlib import stylestyle.use('ggplot')fig = plt.figure()ax1 = fig.add_subplot(111, projection='3d')x3 = [1,2,3,4,5,6,7,8,9,10]y3 = [5,6,7,8,2,5,6,3,7,2]z3 = np.zeros(10)dx = np.ones(10)dy = np.ones(10)dz = [1,2,3,4,5,6,7,8,9,10]ax1.bar3d(x3, y3, z3, dx, dy, dz)ax1.set_xlabel('x axis')ax1.set_ylabel('y axis')ax1.set_zlabel('z axis')plt.show()</code></pre><p>注意这里，我们必须定义<code>x</code>、<code>y</code>和<code>z</code>，然后是 3 个维度的宽度、高度和深度。 这会生成：</p><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-f56fa917c5a3b201.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h1 id="第三十二章-总结"><a href="#第三十二章-总结" class="headerlink" title="第三十二章 总结"></a>第三十二章 总结</h1><p>欢迎阅读最后的 Matplotlib 教程。 在这里我们将整理整个系列，并显示一个稍微更复杂的 3D 线框图：</p><pre><code>from mpl_toolkits.mplot3d import axes3dimport matplotlib.pyplot as pltimport numpy as npfrom matplotlib import stylestyle.use('ggplot')fig = plt.figure()ax1 = fig.add_subplot(111, projection='3d')x, y, z = axes3d.get_test_data()print(axes3d.__file__)ax1.plot_wireframe(x,y,z, rstride = 3, cstride = 3)ax1.set_xlabel('x axis')ax1.set_ylabel('y axis')ax1.set_zlabel('z axis')plt.show()</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-ae3534e87f53f7f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>如果你从一开始就关注这个教程的话，那么你已经学会了 Matplotlib 提供的大部分内容。 你可能不相信，但Matplotlib 仍然可以做很多其他的事情！ 请继续学习，你可以随时访问 Matplotlib.org，并查看示例和图库页面。</p><p>如果你发现自己大量使用 Matplotlib，请考虑捐助给 <a href="https://link.jianshu.com?t=http://numfocus.org/news/2012/08/28/johnhunter/" target="_blank" rel="noopener">John Hunter Memorial 基金</a>。</p><blockquote><p>注：空间曲面的画法</p></blockquote><blockquote><pre><code># 二次抛物面 z = x^2 + y^2x = np.linspace(-10, 10, 101)y = xx, y = np.meshgrid(x, y)z = x ** 2 + y ** 2ax = plot.subplot(111, projection='3d')ax.plot_wireframe(x, y, z)plot.show()</code></pre></blockquote><blockquote><p><img src="/images/loading.gif" data-original="//upload-images.jianshu.io/upload_images/118142-c9f07724a4639d94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="image"></p></blockquote><blockquote><pre><code># 半径为 1 的球t = np.linspace(0, np.pi * 2, 100)s = np.linspace(0, np.pi, 100)t, s = np.meshgrid(t, s)x = np.cos(t) * np.sin(s)y = np.sin(t) * np.sin(s)z = np.cos(s)ax = plot.subplot(111, projection='3d')ax.plot_wireframe(x, y, z)plot.show()</code></pre></blockquote><blockquote><p><img src="/images/loading.gif" data-original="//upload-images.jianshu.io/upload_images/118142-de70433e1947688e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="image"></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | Matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-GUI图像化开发PyQt5</title>
      <link href="/posts/blog-python06.html"/>
      <url>/posts/blog-python06.html</url>
      
        <content type="html"><![CDATA[<h3 id="创建第一个GUI界面"><a href="#创建第一个GUI界面" class="headerlink" title="创建第一个GUI界面"></a>创建第一个GUI界面</h3><p>首先，我们使用pyqt5的窗口小部件创建一个最基本的GUI：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import *app = QApplication(sys.argv)   #应用程序对象win = QWidget()   #窗口控件对象win.show()sys.exit(app.exec_())    #事件循环发生在应用程序中</code></pre><ol><li>在上面的程序中，我们首先引用了需要的模块：sys和pyqt5的QtWidgets模块：</li></ol><ul><li>sys模块提供了访问由解释器使用或维护的变量和与解释器进行交互的函数；</li><li>QtWidgets模块包含提供一组UI元素以创建经典桌面式用户界面的方法，可以让我们很方便地创建窗口对象。</li></ul><ol start="2"><li>接着，我们实例化了一个应用程序对象QApplication()，在PyQt5中，每个应用程序都必须实例化一个QApplication()：</li><li>然后我们创建了一个QWidget()对象，它是pyqt5中所有的图形用户界面的基类:</li><li>再是使用QWidget对象的show()方法将创建的窗口显示出来:</li><li>最后，我们调用应用程序对象的exec_()方法来运行程序的主循环，并使用sys.exit()方法确保程序能够完美的退出。<h3 id="设置窗口标题、大小和位置"><a href="#设置窗口标题、大小和位置" class="headerlink" title="设置窗口标题、大小和位置"></a>设置窗口标题、大小和位置</h3><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import *app = QApplication(sys.argv)win = QWidget()win.resize(450,150)win.move(0,300)win.setWindowTitle('GUI')win.show()sys.exit(app.exec_())</code></pre>在这个程序中，我们设置了以下三点：</li></ol><ul><li>使用QWidget()对象的resize()方法设置窗口的大小为450*150；</li><li>使用QWidget()对象的move()方法，将窗口移动到显示器上x=0，y=300的位置；</li><li>使用QWidget()对象的setWindowTitle()方法，为我们的窗口设置了一个标题。<h3 id="面向对象化"><a href="#面向对象化" class="headerlink" title="面向对象化"></a>面向对象化</h3>前面的例子中，我们使用的是面向函数的编程方式。Python支持面对函数和面向对象两种编程方式，在PyQt5中，使用面向对象的编程方式更加符合其特点。所以接下来我们使用面对对象的编程方式来创建GUI程序。</li></ul><p>我们先将上一篇的例子，改造为面对对象的形式：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QWidgetclass GUi():    def __init__(self):        self.initUI()    def initUI(self):        self.win = QWidget()        self.win.setWindowTitle('GUI')if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUi()    gui.win.show()    sys.exit(app.exec_())</code></pre><p>在这里，我们创建了一个名为GUi的类，通过initUI()方法来创建窗口，并在初始化方法init()中调用它。</p><h3 id="在类中继承"><a href="#在类中继承" class="headerlink" title="在类中继承"></a>在类中继承</h3><p>除了使用原生的类，我们还能从pyqt5中继承一些模块，以此来获得相关模块的属性。比如，我们创建一个继承于QWidget()的类，那么它就拥有了QWidget()的方法和属性，这样我们就可以不实例化一个QWidget()对象而直接拥有QWidget()的属性：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QWidget# 继承自QWidgetclass GUi(QWidget):    def __init__(self):        # 实例化super类，用来创建窗口        super().__init__()        self.initUI()    def initUI(self):        self.setWindowTitle('GUI')if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUi()    gui.show()    sys.exit(app.exec_())</code></pre><h3 id="添加状态栏"><a href="#添加状态栏" class="headerlink" title="添加状态栏"></a>添加状态栏</h3><p>我们可以通过QMainWindow的statusBar()方法来设置GUI窗口底部的状态消息栏。</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QMainWindow,QApplicationclass GUI(QMainWindow):    def __init__(self):        super().__init__()        self.iniUI()    def iniUI(self):        self.setWindowTitle("州的先生Zmister.com Python GUI教程")        self.resize(400,300)        # 设置状态消息栏文本        self.statusBar().showMessage("文本状态栏")if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUI()    gui.show()    sys.exit(app.exec_())</code></pre><h3 id="添加菜单栏"><a href="#添加菜单栏" class="headerlink" title="添加菜单栏"></a>添加菜单栏</h3><p>同时，我们可以使用QMainWindow的statusBar()方法来在窗口中添加一个菜单栏：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QActionclass GUI(QMainWindow):    def __init__(self):        super().__init__()        self.iniUI()    def iniUI(self):        self.setWindowTitle("州的先生zmister.com PythonGUI教程")        self.statusBar().showMessage("文本状态栏")        self.resize(400, 300)        # 创建一个菜单栏        menu = self.menuBar()        # 创建一个菜单        file_menu = menu.addMenu("文件")        # 创建一个行为        new_action = QAction('新文件',self)        # 添加一个行为到菜单        file_menu.addAction(new_action)        # 更新状态栏文本        new_action.setStatusTip('新的文件')if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUI()    gui.show()    sys.exit(app.exec_())</code></pre><p>接下来，我们添加一个“修改”菜单按钮，再添加一个退出行为，用于后面进行退出关闭窗口：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QActionclass GUI(QMainWindow):    def __init__(self):        super().__init__()        self.iniUI()    def iniUI(self):        self.setWindowTitle("州的先生zmister.com PythonGUI教程")        self.statusBar().showMessage("文本状态栏")        self.resize(400, 300)        # 创建一个菜单栏        menu = self.menuBar()        # 创建两个个菜单        file_menu = menu.addMenu("文件")        file_menu.addSeparator()        edit_menu = menu.addMenu('修改')        # 创建一个行为        new_action = QAction('新的文件',self)        # 更新状态栏文本        new_action.setStatusTip('打开新的文件')        # 添加一个行为到菜单        file_menu.addAction(new_action)        # 创建退出行为        exit_action = QAction('退出',self)        # 退出操作        exit_action.setStatusTip("点击退出应用程序")        # 点击关闭程序        exit_action.triggered.connect(self.close)        # 设置退出快捷键        exit_action.setShortcut('Ctrl+Q')        # 添加退出行为到菜单上        file_menu.addAction(exit_action)if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUI()    gui.show()    sys.exit(app.exec_())</code></pre><p>我们像创建第一个菜单那样创建了第二个菜单“修改”菜单，然后创建了一个“退出”行为，重点看一下它的代码：</p><pre><code># 创建退出行为 exit_action = QAction('退出',self)# 退出操作exit_action.setStatusTip("点击退出应用程序")# 点击关闭程序exit_action.triggered.connect(self.close)# 设置退出快捷键exit_action.setShortcut('Ctrl+Q')# 添加退出行为到菜单上file_menu.addAction(exit_action)</code></pre><p>首先使用QAction()对象创建一个行为，然后使用setStatusTip()方法设置他的状态文本提示，接着使用triggered.connect()方法调用关闭窗口的接口，再使用setShortcut()方法设置了行为的快捷键，最后添加行为到菜单上。</p><h3 id="添加Label标签部件"><a href="#添加Label标签部件" class="headerlink" title="添加Label标签部件"></a>添加Label标签部件</h3><p>我们先在窗口中添加一个标签Label，使用QLabel模块。</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabelclass GUI(QMainWindow):    def __init__(self):        super().__init__()        self.iniUI()    def iniUI(self):        self.setWindowTitle("GUI")        self.resize(400, 300)        self.add_menu_and_statu()        self.add_position_layout()    # 添加菜单栏和状态栏    def add_menu_and_statu(self):        self.statusBar().showMessage("文本状态栏")        # 创建一个菜单栏        menu = self.menuBar()        # 创建两个菜单        file_menu = menu.addMenu("文件")        file_menu.addSeparator()        edit_menu = menu.addMenu('修改')        # 创建一个行为        new_action = QAction('新的文件',self)        # 更新状态栏文本        new_action.setStatusTip('打开新的文件')        # 添加一个行为到菜单        file_menu.addAction(new_action)        # 创建退出行为        exit_action = QAction('退出',self)        # 退出操作        exit_action.setStatusTip("点击退出应用程序")        # 点击关闭程序        exit_action.triggered.connect(self.close)        # 设置退出快捷键        exit_action.setShortcut('Ctrl+Q')        # 添加退出行为到菜单上        file_menu.addAction(exit_action)    # 添加布局部件    def add_position_layout(self):        label = QLabel("第一个标签",self)if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUI()    gui.show()    sys.exit(app.exec_())</code></pre><p>与之前的代码不同的是，我们新增了一个add_position_layout()方法，并在里面实例化了一个QLabel对象。<br>我们在add_position_layout方法中添加:</p><pre><code>label.move(10,20)</code></pre><p>这样一句代码，将label向右移动10个像素，向下移动20个像素<br>手动设置移动的高度很不灵活，我们可以先获取菜单栏的高度，再确定label标签移动的位置。<br>我们可以使用部件的size()方法获取部件的宽和高，使用height()方法获取部件的高度，使用width()方法获取到部件的宽度：</p><pre><code>    # 添加布局部件    def add_position_layout(self):        # 获取菜单栏的高度        mbar_height = self.menuBar().height()        # 第一个标签        label_1 = QLabel("第一个标签",self)        label_1.move(10,mbar_height)        # 第二个标签        label_2 = QLabel('第二个标签',self)        label_2.move(10,mbar_height*2)</code></pre><p>在add_position_layout()方法中，我们首先使用self.menuBar().height()获取到菜单栏的高度，然后新建了两个Label标签，移动的高度分别为菜单栏高度的一倍和两倍</p><h3 id="添加按钮部件"><a href="#添加按钮部件" class="headerlink" title="添加按钮部件"></a>添加按钮部件</h3><p>除了添加Label标签，我们还可以在窗口中使用QPushButton对象来创建按钮部件：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabel,QPushButtonclass GUI(QMainWindow):    def __init__(self):        super().__init__()        self.iniUI()    def iniUI(self):        self.setWindowTitle("Python")        self.resize(400, 300)        self.add_menu_and_statu()        self.add_position_layout()    # 添加菜单栏和状态栏    def add_menu_and_statu(self):        self.statusBar().showMessage("文本状态栏")        # 创建一个菜单栏        menu = self.menuBar()        # 创建两个菜单        file_menu = menu.addMenu("文件")        file_menu.addSeparator()        edit_menu = menu.addMenu('修改')        # 创建一个行为        new_action = QAction('新的文件',self)        # 更新状态栏文本        new_action.setStatusTip('打开新的文件')        # 添加一个行为到菜单        file_menu.addAction(new_action)        # 创建退出行为        exit_action = QAction('退出',self)        # 退出操作        exit_action.setStatusTip("点击退出应用程序")        # 点击关闭程序        exit_action.triggered.connect(self.close)        # 设置退出快捷键        exit_action.setShortcut('Ctrl+Q')        # 添加退出行为到菜单上        file_menu.addAction(exit_action)    # 添加布局部件    def add_position_layout(self):        # 获取菜单栏的高度        mbar_height = self.menuBar().height()        # 第一个标签        label_1 = QLabel("第一个标签",self)        label_1.move(10,mbar_height)        # 第二个标签        label_2 = QLabel('第二个标签',self)        label_2.move(10,mbar_height*2)        # 第一个按钮        button_1 = QPushButton("按钮1",self)        button_1.move(label_1.width(),mbar_height)        # 第二个按钮        button_2 = QPushButton("按钮2",self)        button_2.move(label_2.width(),mbar_height*2)if __name__ == '__main__':    app = QApplication(sys.argv)    gui = GUI()    gui.show()    sys.exit(app.exec_())</code></pre><h3 id="使用水平垂直布局"><a href="#使用水平垂直布局" class="headerlink" title="使用水平垂直布局"></a>使用水平垂直布局</h3><p>在前面的程序中，我们使用部件的move()方法来指定部件的位置，虽然很灵活，但是如果部件很多的话，就会很繁琐。<br>PyQt5提供了布局管理模块来支持部件的水平布局和垂直布局：</p><ul><li><p>QHBoxLayout：水平布局；</p></li><li><p>QVBoxLayout ：垂直布局。<br>接下来，我们在程序中使用这两种布局来讲label标签和button按钮放入布局中。</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabel,QPushButton,QVBoxLayout,QHBoxLayout,QWidgetclass GUI(QMainWindow):  def __init__(self):      super().__init__()      self.iniUI()  def iniUI(self):      self.setWindowTitle("PythonGUI")      self.resize(400, 300)      self.add_menu_and_statu()      self.horizontal_vertical_box_layout()  # 添加菜单栏和状态栏  def add_menu_and_statu(self):      self.statusBar().showMessage("文本状态栏")      # 创建一个菜单栏      menu = self.menuBar()      # 创建两个菜单      file_menu = menu.addMenu("文件")      file_menu.addSeparator()      edit_menu = menu.addMenu('修改')      # 创建一个行为      new_action = QAction('新的文件',self)      # 更新状态栏文本      new_action.setStatusTip('打开新的文件')      # 添加一个行为到菜单      file_menu.addAction(new_action)      # 创建退出行为      exit_action = QAction('退出',self)      # 退出操作      exit_action.setStatusTip("点击退出应用程序")      # 点击关闭程序      exit_action.triggered.connect(self.close)      # 设置退出快捷键      exit_action.setShortcut('Ctrl+Q')      # 添加退出行为到菜单上      file_menu.addAction(exit_action)  # 水平垂直布局  def horizontal_vertical_box_layout(self):      # 两个标签      label_1 = QLabel('第一个标签')      label_2 = QLabel('第二个标签')      # 两个按钮      button_1 = QPushButton('第一个按钮')      button_2 = QPushButton('第二个按钮')      # 创建两个水平盒子      hbox_1 = QHBoxLayout()      hbox_2 = QHBoxLayout()      # 在水平盒子1中添加一个标签和一个按钮      hbox_1.addWidget(label_1)      hbox_1.addWidget(button_1)      # 在水平盒子2中添加标签2和按钮2      hbox_2.addWidget(label_2)      hbox_2.addWidget(button_2)      # 创建一个垂直盒子，包含两个水平盒子      vbox = QVBoxLayout()      vbox.addLayout(hbox_1)      vbox.addLayout(hbox_2)      # 创建一个窗口部件，设置布局为垂直盒子      layout_widget = QWidget()      layout_widget.setLayout(vbox)      self.setCentralWidget(layout_widget)if __name__ == '__main__':  app = QApplication(sys.argv)  gui = GUI()  gui.show()  sys.exit(app.exec_())</code></pre><p>我们在horizontal_vertical_box_layout()方法中创建了一个窗口部件、一个垂直盒子、两个水平盒子、两个按钮和两个文本标签，分别进行了嵌套.</p><h3 id="使用网格布局"><a href="#使用网格布局" class="headerlink" title="使用网格布局"></a>使用网格布局</h3><p>在PyQt5中，除了能够使用垂直布局和水平布局，我们还可以使用网格布局来管理窗口部件。<br>网格布局使用QGridLayout模块来创建，然后使用addWidget()方法添加窗口小部件以及它的位置：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabel,QPushButton,QVBoxLayout,QHBoxLayout,QWidget,QGridLayoutclass GUI(QMainWindow):  def __init__(self):      super().__init__()      self.iniUI()  def iniUI(self):      self.setWindowTitle("PythonGUI")      self.resize(400, 300)      self.add_menu_and_statu()      self.grid_layout()  # 添加菜单栏和状态栏  def add_menu_and_statu(self):      self.statusBar().showMessage("文本状态栏")      # 创建一个菜单栏      menu = self.menuBar()      # 创建两个菜单      file_menu = menu.addMenu("文件")      file_menu.addSeparator()      edit_menu = menu.addMenu('修改')      # 创建一个行为      new_action = QAction('新的文件',self)      # 更新状态栏文本      new_action.setStatusTip('打开新的文件')      # 添加一个行为到菜单      file_menu.addAction(new_action)      # 创建退出行为      exit_action = QAction('退出',self)      # 退出操作      exit_action.setStatusTip("点击退出应用程序")      # 点击关闭程序      exit_action.triggered.connect(self.close)      # 设置退出快捷键      exit_action.setShortcut('Ctrl+Q')      # 添加退出行为到菜单上      file_menu.addAction(exit_action)  # 网格布局  def grid_layout(self):      # 两个标签      label_1 = QLabel('第一个标签')      label_2 = QLabel('第二个标签')      # 两个按钮      button_1 = QPushButton('第一个按钮')      button_2 = QPushButton('第二个按钮')      # 创建一个网格布局对象      grid_layout = QGridLayout()      # 在网格中添加窗口部件      grid_layout.addWidget(label_1,0,0) # 放置在0行0列      grid_layout.addWidget(button_1,0,1) # 0行1列      grid_layout.addWidget(label_2,1,0) # 1行0列      grid_layout.addWidget(button_2,1,1) # 1行1列      # 创建一个窗口对象      layout_widget = QWidget()      # 设置窗口的布局层      layout_widget.setLayout(grid_layout)      self.setCentralWidget(layout_widget)if __name__ == '__main__':  app = QApplication(sys.argv)  gui = GUI()  gui.show()  sys.exit(app.exec_())</code></pre><p>在网格布局中，我们可以指定表格的对齐方式，使用网格布局对象的setAlignment()方法：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabel,QPushButton,QVBoxLayout,QHBoxLayout,QWidget,QGridLayoutfrom PyQt5.QtCore import Qtclass GUI(QMainWindow):  def __init__(self):      super().__init__()      self.iniUI()  def iniUI(self):      self.setWindowTitle("PythonGUI")      self.resize(400, 300)      self.add_menu_and_statu()      self.grid_layout()  # 添加菜单栏和状态栏  def add_menu_and_statu(self):      self.statusBar().showMessage("文本状态栏")      # 创建一个菜单栏      menu = self.menuBar()      # 创建两个菜单      file_menu = menu.addMenu("文件")      file_menu.addSeparator()      edit_menu = menu.addMenu('修改')      # 创建一个行为      new_action = QAction('新的文件',self)      # 更新状态栏文本      new_action.setStatusTip('打开新的文件')      # 添加一个行为到菜单      file_menu.addAction(new_action)      # 创建退出行为      exit_action = QAction('退出',self)      # 退出操作      exit_action.setStatusTip("点击退出应用程序")      # 点击关闭程序      exit_action.triggered.connect(self.close)      # 设置退出快捷键      exit_action.setShortcut('Ctrl+Q')      # 添加退出行为到菜单上      file_menu.addAction(exit_action)  # 网格布局  def grid_layout(self):      # 两个标签      label_1 = QLabel('第一个标签')      label_2 = QLabel('第二个标签')      # 两个按钮      button_1 = QPushButton('第一个按钮')      button_2 = QPushButton('第二个按钮')      # 创建一个网格布局对象      grid_layout = QGridLayout()      # 在网格中添加窗口部件      grid_layout.addWidget(label_1,0,0) # 放置在0行0列      grid_layout.addWidget(button_1,0,1) # 0行1列      grid_layout.addWidget(label_2,1,0) # 1行0列      grid_layout.addWidget(button_2,1,1) # 1行1列      grid_layout.setAlignment(Qt.AlignTop)      # 创建一个窗口对象      layout_widget = QWidget()      # 设置窗口的布局层      layout_widget.setLayout(grid_layout)      self.setCentralWidget(layout_widget)if __name__ == '__main__':  app = QApplication(sys.argv)  gui = GUI()  gui.show()  sys.exit(app.exec_())</code></pre><p>我们从PyQt5的QtCore模块中导入了Qt模块，用来指定对齐方式：</p><pre><code>from PyQt5.QtCore import Qt</code></pre><p>然后在创建的网格布局对象下，使用setAlignment来指定这个表格布局的对齐方式，内容为Qt的AlignTop属性，表示顶部对齐：</p><pre><code>grid_layout.setAlignment(Qt.AlignTop)</code></pre><p>除了对网格布局对象设置对齐方式，还能够对窗口小部件单独设置对齐方式，同样使用setAlignment()方法，传递两个参数，一个使部件名，一个使对齐方式：</p><pre><code>grid_layout.setAlignment(label_1,Qt.AlignRight)</code></pre><p>在对窗口部件设置行列的位置的时候，我们除了可以指定其行数和列数，还能够指定其跨越多少行以及跨越多少列，我们新建一个按钮，让其占1行和5列，看看效果：</p><pre><code># coding:utf-8import sysfrom PyQt5.QtWidgets import QApplication,QMainWindow,QAction,QLabel,QPushButton,QVBoxLayout,QHBoxLayout,QWidget,QGridLayoutfrom PyQt5.QtCore import Qtclass GUI(QMainWindow):  def __init__(self):      super().__init__()      self.iniUI()  def iniUI(self):      self.setWindowTitle("PythonGUI")      self.resize(400, 300)      self.add_menu_and_statu()      self.grid_layout()  # 添加菜单栏和状态栏  def add_menu_and_statu(self):      self.statusBar().showMessage("文本状态栏")      # 创建一个菜单栏      menu = self.menuBar()      # 创建两个菜单      file_menu = menu.addMenu("文件")      file_menu.addSeparator()      edit_menu = menu.addMenu('修改')      # 创建一个行为      new_action = QAction('新的文件',self)      # 更新状态栏文本      new_action.setStatusTip('打开新的文件')      # 添加一个行为到菜单      file_menu.addAction(new_action)      # 创建退出行为      exit_action = QAction('退出',self)      # 退出操作      exit_action.setStatusTip("点击退出应用程序")      # 点击关闭程序      exit_action.triggered.connect(self.close)      # 设置退出快捷键      exit_action.setShortcut('Ctrl+Q')      # 添加退出行为到菜单上      file_menu.addAction(exit_action)  # 表格布局  def grid_layout(self):      # 两个标签      label_1 = QLabel('第一个标签')      label_2 = QLabel('第二个标签')      # 两个按钮      button_1 = QPushButton('第一个按钮')      button_2 = QPushButton('第二个按钮')      button_3 = QPushButton('第三个按钮')      # 创建一个表格布局对象      grid_layout = QGridLayout()      # 在表格中添加窗口部件      grid_layout.addWidget(label_1,0,0) # 放置在0行0列      grid_layout.addWidget(button_1,0,1) # 0行1列      grid_layout.addWidget(label_2,1,0) # 1行0列      grid_layout.addWidget(button_2,1,1) # 1行1列      grid_layout.addWidget(button_3,2,0,1,5)      # 对齐方式      grid_layout.setAlignment(Qt.AlignTop)      grid_layout.setAlignment(label_1,Qt.AlignRight)      # 创建一个窗口对象      layout_widget = QWidget()      # 设置窗口的布局层      layout_widget.setLayout(grid_layout)      self.setCentralWidget(layout_widget)if __name__ == '__main__':  app = QApplication(sys.argv)  gui = GUI()  gui.show()  sys.exit(app.exec_())</code></pre><h3 id="安装PyQt5-设计师工具"><a href="#安装PyQt5-设计师工具" class="headerlink" title="安装PyQt5 设计师工具"></a>安装PyQt5 设计师工具</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装:"></a>安装:</h5><pre><code>pip install pyqt5-tools</code></pre><h5 id="使用Qt-Designer创建GUI窗口"><a href="#使用Qt-Designer创建GUI窗口" class="headerlink" title="使用Qt Designer创建GUI窗口:"></a>使用Qt Designer创建GUI窗口:</h5><p>打开qt设计师之后，我们可以在“新建窗体”窗口中选择各种窗口的模板来进行窗口的创建:<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-bc7cabd3e6a1c5df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>接下来，我们使用qt设计师创建一个GUI 窗口程序。</p></li><li><p>通过Qt Designer创建第一个GUI窗口<br>我们在“新建窗体”窗口中选择“Main Window”来创建一个空白的主窗口：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-bee59060c47e97ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>qt设计师的主面板出现了一个空白的窗口GUI，我们可以使用快捷键Ctrl+R对窗口进行预览：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-76e68a9e2646ece2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>在右侧的选项栏中，可以对窗口的各种属性进行设置：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-12b41190aa24829b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>如图我们修改了窗口的大小。</p></li><li><p>修改窗口标题<br>新建的窗口使用的是默认的标题，我们可以在右侧的“windowTitle”选项中修改窗口标题：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-ff16218e32bcd75a.gif?imageMogr2/auto-orient/strip" alt="image"></p></li><li><p>在GUI中添加菜单栏和子菜单<br>使用qt设计师也可以很方便地创建菜单和子菜单，直接点击操作，简单迅速：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-ccbca8c01d8c18c8.gif?imageMogr2/auto-orient/strip" alt="image"></p></li><li><p>为菜单选项添加图标<br>菜单创建之后，只有文字很是单调，我们可以在icon选项中为菜单添加图标：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-8842fbf61cd48fda.gif?imageMogr2/auto-orient/strip" alt="image"></p></li><li><p>添加文本到状态栏<br>在上一篇中，我们使用statusBar()方法来设置窗口状态栏的文本，在qt设计师中，通过“statusTip”选项同样可以快速设置：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-ce9e37e9db5074ac.gif?imageMogr2/auto-orient/strip" alt="image"></p></li><li><p>保存UI设计<br>最后，我们保存设计好的qt设计文件，以供日后使用：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-5c18c91ca1a91d94.gif?imageMogr2/auto-orient/strip" alt="image"></p></li></ul><h3 id="通过Qt设计师在GUI中添加窗口部件"><a href="#通过Qt设计师在GUI中添加窗口部件" class="headerlink" title="通过Qt设计师在GUI中添加窗口部件"></a>通过Qt设计师在GUI中添加窗口部件</h3><h5 id="继续添加一个菜单"><a href="#继续添加一个菜单" class="headerlink" title="继续添加一个菜单"></a>继续添加一个菜单</h5><p>使用代码创建了GUI，我们继续在GUI窗口中创建一个“修改”菜单：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-3dbc23ea52c30731.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="为“退出”菜单添加状态栏信息"><a href="#为“退出”菜单添加状态栏信息" class="headerlink" title="为“退出”菜单添加状态栏信息"></a>为“退出”菜单添加状态栏信息</h5><p>目前使用qt设计师创建的GUI中，当鼠标移动到菜单项时，底部的状态栏是不会有变化的：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-d8b0d93f1e465283.gif?imageMogr2/auto-orient/strip" alt="image"><br>我们通过右侧的属性设置列表中的“statusTip”，设置为：当鼠标移动到“退出”按钮时，状态栏提示“点击退出应用程序”：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-99bc57de238dcded.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="为“退出”菜单添加一个关闭信号，来实现点击关闭程序"><a href="#为“退出”菜单添加一个关闭信号，来实现点击关闭程序" class="headerlink" title="为“退出”菜单添加一个关闭信号，来实现点击关闭程序"></a>为“退出”菜单添加一个关闭信号，来实现点击关闭程序</h5><p>在qt设计师面板右侧的“信号/槽编辑器”中，我们可以添加一个信号/槽。<br>在Pyqt中，响应和操作可以通过信号/槽来实现，一个信号槽由发送者、信号、接收者和槽组成，发送者发生信号，然后接收者调用槽。</p><p>我们使用信号槽来为“退出”菜单添加一个关闭窗口的操作：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-6bf581dba81dfd8b.gif?imageMogr2/auto-orient/strip" alt="image"><br>其中：</p><ul><li>发送者为“退出”菜单的name;</li><li>信号为triggerd()，也就是触发的意思；</li><li>接收者为主窗口；</li><li>槽为close()方法，也就是退出操作。<h5 id="为“退出”菜单项添加一个快捷键"><a href="#为“退出”菜单项添加一个快捷键" class="headerlink" title="为“退出”菜单项添加一个快捷键"></a>为“退出”菜单项添加一个快捷键</h5>在实现了“退出”菜单项的功能之后，我们可以为菜单项设置一个快捷键，以进行快捷操作。</li></ul><p>快捷键的设置在“动作编辑器”选项卡中进行编辑设置：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-c92b1d59432250c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>双击快捷键，弹出快捷键的编辑窗口：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-bfe8f55ad08f2edf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640" alt="image"><br>我们设置Ctrl+Q作为退出的快捷键：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-fe7e220f47863d06.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="在窗口中添加选项卡"><a href="#在窗口中添加选项卡" class="headerlink" title="在窗口中添加选项卡"></a>在窗口中添加选项卡</h5><p>选项卡在GUI程序中是很常见的小部件，可以分隔不同的内。在qt设计师中，可以直接从左侧的部件列表中拖拽添加到窗口中：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-2a1c6967cf418ac1.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="在选项卡中添加按钮和其他小部件"><a href="#在选项卡中添加按钮和其他小部件" class="headerlink" title="在选项卡中添加按钮和其他小部件"></a>在选项卡中添加按钮和其他小部件</h5><p>在主窗口中添加选项卡部件后，我们可以在选项卡部件中继续添加其他的小部件，我们分别拖拽添加一个按钮部件和一个刻度盘部件（添加部件之后，部件属性可以在右侧的属性列表中进行设置）：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-9529263f1638cf1e.gif?imageMogr2/auto-orient/strip" alt="image"></p><h3 id="使用Qt设计师进行窗口布局"><a href="#使用Qt设计师进行窗口布局" class="headerlink" title="使用Qt设计师进行窗口布局"></a>使用Qt设计师进行窗口布局</h3><h5 id="垂直布局"><a href="#垂直布局" class="headerlink" title="垂直布局"></a>垂直布局</h5><p>从左侧面板的“Layouts”栏中拖拽“Vertical Layout”到GUI窗口中，设置好布局大小，再在“Buttons”栏中拖拽3个“Push Button”到设置好大小的“Vertical Layout”中：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-34b3153b7bf7984e.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="水平布局"><a href="#水平布局" class="headerlink" title="水平布局"></a>水平布局</h5><p>从左侧面板的“Layouts”栏中拖拽“Horizontal Layout”到GUI窗口中，设置好布局大小，再在“Buttons”栏中拖拽3个“Push Button”到设置好大小的“Horizontal Layout”中：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-3d63f8db65137bb8.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="使用水平布局、垂直布局的另一种方式"><a href="#使用水平布局、垂直布局的另一种方式" class="headerlink" title="使用水平布局、垂直布局的另一种方式"></a>使用水平布局、垂直布局的另一种方式</h5><p>上面我们使用的是先设置一个布局部件，再将窗口部件放入布局部件之中布局方式。除此之外，我们还可以先在GUI窗口中放置窗口部件，框选需要进行布局的部件，再使用工具栏中的“水平布局”、“垂直布局”按钮对窗口部件进行布局管理：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-cd216aa5919da58c.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h5><p>与垂直布局和水平布局一样，网格布局也可以使用上述的两种方法来对窗口部件进行布局管理：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-02e34c849829440b.gif?imageMogr2/auto-orient/strip" alt="image"><br>除了对部件进行布局之外，我们还可以在网格中再进行嵌套布局：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-18d6689d1cdfae1f.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="容器布局"><a href="#容器布局" class="headerlink" title="容器布局"></a>容器布局</h5><p>除了使用布局控件之外，我们还能使用容器进行粗略的布局，下面以groupBox容器作为演示：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-a80aa69e355d5d6d.gif?imageMogr2/auto-orient/strip" alt="image"></p><h5 id="使用“Spacer”间隔"><a href="#使用“Spacer”间隔" class="headerlink" title="使用“Spacer”间隔"></a>使用“Spacer”间隔</h5><p>我们在布局部件中放置的窗口部件都是等距离的，如果我们需要对其中某个部件的距离设置远一点呢，可以使用“Spacer”间隔部件。<br>“Spacer”部件分为两种：</p><ul><li>Horizontal Spacer：垂直间隔；</li><li>Vertical Spacer：水平间隔。<br>间隔部件在左侧部件的“Spacer”栏中，下面我们演示一下：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-c812a0136a6addc1.gif?imageMogr2/auto-orient/strip" alt="image"><h5 id="为标签设置“伙伴”"><a href="#为标签设置“伙伴”" class="headerlink" title="为标签设置“伙伴”"></a>为标签设置“伙伴”</h5>Pyqt中有一个好用的基本功能就是“伙伴”部件，当用户键入标签的快捷键时，光标的焦点会出现在标签的伙伴上。例如：我们有一个用户名的标签和一个用户名的输入框，设置用户名标签与用户名输入框为“伙伴”，设置用户名标签的文本为”用户名(&amp;2)”，表示用户名标签的快捷键为Alt+2，如果我们按快捷键Alt+2，那么光标的输入符就会移动到用户名的输入框中。</li></ul><p>qt设计师中，“伙伴”功能，在工具栏的“编辑伙伴”按钮中：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-ac1289af24eee320.gif?imageMogr2/auto-orient/strip" alt="image"></p><h3 id="转换qt设计师的ui代码为Python代码"><a href="#转换qt设计师的ui代码为Python代码" class="headerlink" title="转换qt设计师的ui代码为Python代码"></a>转换qt设计师的ui代码为Python代码</h3><h5 id="查看qt设计师生成的UI文件"><a href="#查看qt设计师生成的UI文件" class="headerlink" title="查看qt设计师生成的UI文件"></a>查看qt设计师生成的UI文件</h5><p>我们在qt设计师中设计好的GUI窗口都会被保存为.ui格式的文件。<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-3bdca8401cdc4b77.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>实质上，.ui文件依然是文本格式文件，我们使用notepad++打开刚刚保存的.ui文件：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-aec4627b7ae4eb76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/840" alt="image"><br>可以发现，.ui文件其实是一个xml文件，其通过不同的标签来表示不同的窗口部件或是行为和信号槽的声明和描述。</p><h5 id="通过pyuic5转换UI文件为Python文件"><a href="#通过pyuic5转换UI文件为Python文件" class="headerlink" title="通过pyuic5转换UI文件为Python文件"></a>通过pyuic5转换UI文件为Python文件</h5><p>设计好的UI文件如何需要转换为Python文件，该怎么办？毕竟我们需要使用Python来扩展GUI的功能。</p><p>我们可以使用PyQt自带的pyuic5工具，对Qt设计师保存的.ui文件进行转换。</p><p>pyuic5是一个命令行工具，直接在cmd命令行界面运行即可。下面我们使用pyuic5将刚刚保存的UI文件转换问Python代码：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-01778d3227a1f501.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>运行之后，便会自动生成一个ui2py.py的python文件，我们打开看看：</p><pre><code>from PyQt5 import QtCore, QtGui, QtWidgetsclass Ui_MainWindow(object):    def setupUi(self, MainWindow):        MainWindow.setObjectName("MainWindow")        MainWindow.resize(585, 477)        self.centralwidget = QtWidgets.QWidget(MainWindow)        self.centralwidget.setObjectName("centralwidget")        self.pushButton = QtWidgets.QPushButton(self.centralwidget)        self.pushButton.setGeometry(QtCore.QRect(170, 140, 75, 23))        self.pushButton.setObjectName("pushButton")        MainWindow.setCentralWidget(self.centralwidget)        self.menubar = QtWidgets.QMenuBar(MainWindow)        self.menubar.setGeometry(QtCore.QRect(0, 0, 585, 23))        self.menubar.setObjectName("menubar")        self.menu = QtWidgets.QMenu(self.menubar)        self.menu.setObjectName("menu")        MainWindow.setMenuBar(self.menubar)        self.statusbar = QtWidgets.QStatusBar(MainWindow)        self.statusbar.setObjectName("statusbar")        MainWindow.setStatusBar(self.statusbar)        self.actionMen1 = QtWidgets.QAction(MainWindow)        self.actionMen1.setObjectName("actionMen1")        self.actionMen2 = QtWidgets.QAction(MainWindow)        self.actionMen2.setObjectName("actionMen2")        self.menu.addAction(self.actionMen1)        self.menu.addSeparator()        self.menu.addAction(self.actionMen2)        self.menubar.addAction(self.menu.menuAction())        self.retranslateUi(MainWindow)        QtCore.QMetaObject.connectSlotsByName(MainWindow)    def retranslateUi(self, MainWindow):        _translate = QtCore.QCoreApplication.translate        MainWindow.setWindowTitle(_translate("MainWindow", "州的先生zmister.com PythonGUI教程"))        self.pushButton.setText(_translate("MainWindow", "PushButton"))        self.menu.setTitle(_translate("MainWindow", "文件"))        self.actionMen1.setText(_translate("MainWindow", "men1"))        self.actionMen2.setText(_translate("MainWindow", "men2"))if __name__ == "__main__":    import sys    app = QtWidgets.QApplication(sys.argv)    MainWindow = QtWidgets.QMainWindow()    ui = Ui_MainWindow()    ui.setupUi(MainWindow)    MainWindow.show()    sys.exit(app.exec_())</code></pre><p>生成的是标准的Python代码，运行一下，看看是否和qt设计师中的一致：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-872443049a153b3e.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h5 id="修改信号槽"><a href="#修改信号槽" class="headerlink" title="修改信号槽"></a>修改信号槽</h5><p>除了直接使用UI文件转换而来的PythonGUI代码，我们有时候也需要对部分事件进行修改。<br>我们可以在qt设计师中添加简单的信号槽，复制的信号槽还是得自己在python代码中定义。</p><p>首先，我们在窗口中添加一个label标签，设置一个信号槽为：点击按钮的时候，label标签就清空。<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-740601008cb3ac84.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>然后使用pyuic5将其转换为Python代码，运行正常，按钮的信号槽也正常：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-bdb8602afe300755.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-bdb8602afe300755.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>下面，我们并不想在点击button按钮的时候label标签消失，而是换一个文字。我们该怎么做呢？</p><p>直接在Python代码中进行修改，添加一个方法，并连接到信号槽上：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-563c759f395572c3.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>现在点击按钮之后，label标签会变为“zmister”而不是像之前那样清空。</p><h3 id="在主窗口中调用对话框"><a href="#在主窗口中调用对话框" class="headerlink" title="在主窗口中调用对话框"></a>在主窗口中调用对话框</h3><h5 id="一、创建两个窗口"><a href="#一、创建两个窗口" class="headerlink" title="一、创建两个窗口"></a>一、创建两个窗口</h5><p>根据本篇的最终目标——在主窗口中调用对话窗口，我们先使用qt设计师创建两个窗口，其中一个主窗口MainWindows，一个含有两个按钮的对话窗口Dialog。</p><p>通过qt设计师新建一个MainWindows窗口，并在其中放置一个按钮：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-3fa60dd34af48bb7.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>保存为UI文件，再新建一个对话窗口：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-c22ddf8df0584532.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>同样保存为UI文件。<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-cd8246c55fc7c0ee.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>这样我们本地文件夹有两个可供转换为Python代码的UI文件：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-0b2049c78e7aa45e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h5 id="二、转换UI文件为Python代码文件"><a href="#二、转换UI文件为Python代码文件" class="headerlink" title="二、转换UI文件为Python代码文件"></a>二、转换UI文件为Python代码文件</h5><p>保存好两个窗口的UI文件之后，我们继续使用pyuic5工具，将这两个UI文件转换为Python代码文件。<br>打开命令行输入：</p><pre><code>pyuic5 -x -o mainWindow.py mainWindow.uipyuic5 -x -o dialog.py dialog.ui</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-52f229f250597097.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>运行一下转换出来的Python文件，是否正常：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-1ad78cb14b74c934.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h5 id="三、从主窗口中调用对话框窗口"><a href="#三、从主窗口中调用对话框窗口" class="headerlink" title="三、从主窗口中调用对话框窗口"></a>三、从主窗口中调用对话框窗口</h5><p>在进行下一步之前，我们先在主窗口mainWindow中添加一个文本标签，设置文本为空，字体加大：<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-fa3cc63b4314a492.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>有个这个label我们可以将对对话框的操作，反馈在label标签中。</p><p>保存UI文件，使用pyuic5重新转换一次Python代码。</p><p>为了在主窗口代码中调用对话框窗口，我们需要在mainWindow.py文件中引入对话框窗口：</p><pre><code>from GUI import dialog</code></pre><p>然后定义在主窗口的主类中定义一个方法，用来显示对话框窗口：</p><pre><code>def click_button(self):    Dialog = QtWidgets.QDialog()    ui = dialog.Ui_Dialog()    ui.setupUi(Dialog)    Dialog.show()    Dialog.exec_()</code></pre><p>定义好了方法，我们需要对按钮进行点击调用的绑定，这在setupUi()方法中进行设置：</p><pre><code>self.pushButton.clicked.connect(self.click_button)</code></pre><p>这样就实现了按钮点击绑定对话框。<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-85b9c1c0986b3142.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>我们知道，我们的对话框是有两个按钮的，一个“OK”，一个“Cancel”，在我们的GUI程序中，点击任意一个都会关闭对话框，效果似乎是一样的，但在PyQt5的内部机制的，这是两个不同的事件，下面我们就通过之前设置的label标签，展示其不同的机制。</p><p>我们修改一下click_button()方法，修改如下：</p><pre><code>def click_button(self):    Dialog = QtWidgets.QDialog()    ui = dialog.Ui_Dialog()    ui.setupUi(Dialog)    Dialog.show()    # Dialog.exec_()    rsp = Dialog.exec_()    if rsp == QtWidgets.QDialog.Accepted:        self.label.setText("点击了OK")    else:        self.label.setText("点击了Cannel")</code></pre><p>在这里我们将对话框的运行赋值给了一个变量，然后将其与QtWidgets.QDialog.Accepted进行比较，QtWidgets.QDialog.Accepted表示的是对话框的接收事件，也就是“OK”代表的事件，如果为接收时间，设置label标签为“点击了OK”，否则设置label标签为“点击了Cannel”<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/38544-38b164313cdf120b.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | PyQt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Pandas详解</title>
      <link href="/posts/blog-python05.html"/>
      <url>/posts/blog-python05.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、生成数据表"><a href="#一、生成数据表" class="headerlink" title="一、生成数据表"></a>一、生成数据表</h1><h2 id="1、首先导入pandas库，一般都会用到numpy库，所以我们先导入备用："><a href="#1、首先导入pandas库，一般都会用到numpy库，所以我们先导入备用：" class="headerlink" title="1、首先导入pandas库，一般都会用到numpy库，所以我们先导入备用："></a>1、首先导入pandas库，一般都会用到numpy库，所以我们先导入备用：</h2><p>import numpy as np<br>import pandas as pd</p><h2 id="2、导入CSV或者xlsx文件："><a href="#2、导入CSV或者xlsx文件：" class="headerlink" title="2、导入CSV或者xlsx文件："></a>2、导入CSV或者xlsx文件：</h2><p>df = pd.DataFrame(pd.read_csv(‘name.csv’,header=1))<br>df = pd.DataFrame(pd.read_excel(‘name.xlsx’))</p><h2 id="3、用pandas创建数据表："><a href="#3、用pandas创建数据表：" class="headerlink" title="3、用pandas创建数据表："></a>3、用pandas创建数据表：</h2><pre><code>df = pd.DataFrame({"id":[1001,1002,1003,1004,1005,1006],  "date":pd.date_range('20130102', periods=6),  "city":['Beijing ', 'SH', ' guangzhou ', 'Shenzhen', 'shanghai', 'BEIJING '], "age":[23,44,54,32,34,32], "category":['100-A','100-B','110-A','110-C','210-A','130-F'],  "price":[1200,np.nan,2133,5433,np.nan,4432]},  columns =['id','date','city','category','age','price'])</code></pre><h1 id="二、数据表信息查看"><a href="#二、数据表信息查看" class="headerlink" title="二、数据表信息查看"></a>二、数据表信息查看</h1><h2 id="1、维度查看："><a href="#1、维度查看：" class="headerlink" title="1、维度查看："></a>1、维度查看：</h2><p>df.shape</p><h2 id="2、数据表基本信息（维度、列名称、数据格式、所占空间等）："><a href="#2、数据表基本信息（维度、列名称、数据格式、所占空间等）：" class="headerlink" title="2、数据表基本信息（维度、列名称、数据格式、所占空间等）："></a>2、数据表基本信息（维度、列名称、数据格式、所占空间等）：</h2><p>df.info()</p><h2 id="3、每一列数据的格式："><a href="#3、每一列数据的格式：" class="headerlink" title="3、每一列数据的格式："></a>3、每一列数据的格式：</h2><p>df.dtypes</p><h2 id="4、某一列格式："><a href="#4、某一列格式：" class="headerlink" title="4、某一列格式："></a>4、某一列格式：</h2><p>df[‘B’].dtype</p><h2 id="5、空值："><a href="#5、空值：" class="headerlink" title="5、空值："></a>5、空值：</h2><p>df.isnull()</p><h2 id="6、查看某一列空值："><a href="#6、查看某一列空值：" class="headerlink" title="6、查看某一列空值："></a>6、查看某一列空值：</h2><p>df.isnull()</p><h2 id="7、查看某一列的唯一值："><a href="#7、查看某一列的唯一值：" class="headerlink" title="7、查看某一列的唯一值："></a>7、查看某一列的唯一值：</h2><p>df[‘B’].unique()</p><h2 id="8、查看数据表的值："><a href="#8、查看数据表的值：" class="headerlink" title="8、查看数据表的值："></a>8、查看数据表的值：</h2><p>df.values</p><h2 id="9、查看列名称："><a href="#9、查看列名称：" class="headerlink" title="9、查看列名称："></a>9、查看列名称：</h2><p>df.columns</p><h2 id="10、查看前10行数据、后10行数据："><a href="#10、查看前10行数据、后10行数据：" class="headerlink" title="10、查看前10行数据、后10行数据："></a>10、查看前10行数据、后10行数据：</h2><p>df.head() #默认前10行数据<br>df.tail() #默认后10 行数据</p><h1 id="三、数据表清洗"><a href="#三、数据表清洗" class="headerlink" title="三、数据表清洗"></a>三、数据表清洗</h1><h2 id="1、用数字0填充空值："><a href="#1、用数字0填充空值：" class="headerlink" title="1、用数字0填充空值："></a>1、用数字0填充空值：</h2><p>df.fillna(value=0)</p><h2 id="2、使用列prince的均值对NA进行填充："><a href="#2、使用列prince的均值对NA进行填充：" class="headerlink" title="2、使用列prince的均值对NA进行填充："></a>2、使用列prince的均值对NA进行填充：</h2><p>df[‘prince’].fillna(df[‘prince’].mean())</p><h2 id="3、清楚city字段的字符空格："><a href="#3、清楚city字段的字符空格：" class="headerlink" title="3、清楚city字段的字符空格："></a>3、清楚city字段的字符空格：</h2><p>df[‘city’]=df[‘city’].map(str.strip)</p><h2 id="4、大小写转换："><a href="#4、大小写转换：" class="headerlink" title="4、大小写转换："></a>4、大小写转换：</h2><p>df[‘city’]=df[‘city’].str.lower()</p><h2 id="5、更改数据格式："><a href="#5、更改数据格式：" class="headerlink" title="5、更改数据格式："></a>5、更改数据格式：</h2><p>df[‘price’].astype(‘int’)</p><h2 id="6、更改列名称："><a href="#6、更改列名称：" class="headerlink" title="6、更改列名称："></a>6、更改列名称：</h2><p>df.rename(columns={‘category’: ‘category-size’})</p><h2 id="7、删除后出现的重复值："><a href="#7、删除后出现的重复值：" class="headerlink" title="7、删除后出现的重复值："></a>7、删除后出现的重复值：</h2><p>df[‘city’].drop_duplicates()</p><h2 id="8、删除先出现的重复值："><a href="#8、删除先出现的重复值：" class="headerlink" title="8、删除先出现的重复值："></a>8、删除先出现的重复值：</h2><p>df[‘city’].drop_duplicates(keep=’last’)</p><h2 id="9、数据替换："><a href="#9、数据替换：" class="headerlink" title="9、数据替换："></a>9、数据替换：</h2><p>df[‘city’].replace(‘sh’, ‘shanghai’)</p><h1 id="四、数据预处理"><a href="#四、数据预处理" class="headerlink" title="四、数据预处理"></a>四、数据预处理</h1><pre><code>df1=pd.DataFrame({"id":[1001,1002,1003,1004,1005,1006,1007,1008], "gender":['male','female','male','female','male','female','male','female'],"pay":['Y','N','Y','Y','N','Y','N','Y',],"m-point":[10,12,20,40,40,40,30,20]})</code></pre><h2 id="1、数据表合并"><a href="#1、数据表合并" class="headerlink" title="1、数据表合并"></a>1、数据表合并</h2><h3 id="1-1-merge"><a href="#1-1-merge" class="headerlink" title="1.1 merge"></a>1.1 merge</h3><pre><code>df_inner=pd.merge(df,df1,how='inner')  # 匹配合并，交集df_left=pd.merge(df,df1,how='left')        #df_right=pd.merge(df,df1,how='right')df_outer=pd.merge(df,df1,how='outer')  #并集</code></pre><h3 id="1-2-append"><a href="#1-2-append" class="headerlink" title="1.2 append"></a>1.2 append</h3><pre><code>result = df1.append(df2)</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-1a90a4c989ad7427?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p><h3 id="1-3-join"><a href="#1-3-join" class="headerlink" title="1.3 join"></a>1.3 join</h3><pre><code>result = left.join(right, on='key')</code></pre><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-e674e35fb121bf4b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p><h3 id="1-4-concat"><a href="#1-4-concat" class="headerlink" title="1.4 concat"></a>1.4 concat</h3><pre><code>pd.concat(objs, axis=0, join='outer', join_axes=None, ignore_index=False,          keys=None, levels=None, names=None, verify_integrity=False,          copy=True)</code></pre><p>objs︰ 一个序列或系列、 综合或面板对象的映射。如果字典中传递，将作为键参数，使用排序的键，除非它传递，在这种情况下的值将会选择 （见下文）。任何没有任何反对将默默地被丢弃，除非他们都没有在这种情况下将引发 ValueError。<br>axis: {0，1，…}，默认值为 0。要连接沿轴。<br>join: {‘内部’、 ‘外’}，默认 ‘外’。如何处理其他 axis(es) 上的索引。联盟内、 外的交叉口。<br>ignore_index︰ 布尔值、 默认 False。如果为 True，则不要串联轴上使用的索引值。由此产生的轴将标记 0，…，n-1。这是有用的如果你串联串联轴没有有意义的索引信息的对象。请注意在联接中仍然受到尊重的其他轴上的索引值。<br>join_axes︰ 索引对象的列表。具体的指标，用于其他 n-1 轴而不是执行内部/外部设置逻辑。<br>keys︰ 序列，默认为无。构建分层索引使用通过的键作为最外面的级别。如果多个级别获得通过，应包含元组。<br>levels︰ 列表的序列，默认为无。具体水平 （唯一值） 用于构建多重。否则，他们将推断钥匙。<br>names︰ 列表中，默认为无。由此产生的分层索引中的级的名称。<br>verify_integrity︰ 布尔值、 默认 False。检查是否新的串联的轴包含重复项。这可以是相对于实际数据串联非常昂贵。<br>副本︰ 布尔值、 默认 True。如果为 False，请不要，不必要地复制数据。</p><p>例子：1.frames = [df1, df2, df3]<br>2.result = pd.concat(frames)<br><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-a9599d77ce922494?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="这里写图片描述"></p><h2 id="2、设置索引列"><a href="#2、设置索引列" class="headerlink" title="2、设置索引列"></a>2、设置索引列</h2><p>df_inner.set_index(‘id’)</p><h2 id="3、按照特定列的值排序："><a href="#3、按照特定列的值排序：" class="headerlink" title="3、按照特定列的值排序："></a>3、按照特定列的值排序：</h2><p>df_inner.sort_values(by=[‘age’])</p><h2 id="4、按照索引列排序："><a href="#4、按照索引列排序：" class="headerlink" title="4、按照索引列排序："></a>4、按照索引列排序：</h2><p>df_inner.sort_index()</p><h2 id="5、如果prince列的值-gt-3000，group列显示high，否则显示low："><a href="#5、如果prince列的值-gt-3000，group列显示high，否则显示low：" class="headerlink" title="5、如果prince列的值>3000，group列显示high，否则显示low："></a>5、如果prince列的值&gt;3000，group列显示high，否则显示low：</h2><p>df_inner[‘group’] = np.where(df_inner[‘price’] &gt; 3000,’high’,’low’)</p><h2 id="6、对复合多个条件的数据进行分组标记"><a href="#6、对复合多个条件的数据进行分组标记" class="headerlink" title="6、对复合多个条件的数据进行分组标记"></a>6、对复合多个条件的数据进行分组标记</h2><p>df_inner.loc[(df_inner[‘city’] == ‘beijing’) &amp; (df_inner[‘price’] &gt;= 4000), ‘sign’]=1</p><h2 id="7、对category字段的值依次进行分列，并创建数据表，索引值为df-inner的索引列，列名称为category和size"><a href="#7、对category字段的值依次进行分列，并创建数据表，索引值为df-inner的索引列，列名称为category和size" class="headerlink" title="7、对category字段的值依次进行分列，并创建数据表，索引值为df_inner的索引列，列名称为category和size"></a>7、对category字段的值依次进行分列，并创建数据表，索引值为df_inner的索引列，列名称为category和size</h2><p>pd.DataFrame((x.split(‘-‘) for x in df_inner[‘category’]),index=df_inner.index,columns=[‘category’,’size’]))</p><h2 id="8、将完成分裂后的数据表和原df-inner数据表进行匹配"><a href="#8、将完成分裂后的数据表和原df-inner数据表进行匹配" class="headerlink" title="8、将完成分裂后的数据表和原df_inner数据表进行匹配"></a>8、将完成分裂后的数据表和原df_inner数据表进行匹配</h2><p>df_inner=pd.merge(df_inner,split,right_index=True, left_index=True)</p><h1 id="五、数据提取"><a href="#五、数据提取" class="headerlink" title="五、数据提取"></a>五、数据提取</h1><p>主要用到的三个函数：loc,iloc和ix，loc函数按标签值进行提取，iloc按位置进行提取，ix可以同时按标签和位置进行提取。</p><h2 id="1、按索引提取单行的数值"><a href="#1、按索引提取单行的数值" class="headerlink" title="1、按索引提取单行的数值"></a>1、按索引提取单行的数值</h2><p>df_inner.loc[3]</p><h2 id="2、按索引提取区域行数值"><a href="#2、按索引提取区域行数值" class="headerlink" title="2、按索引提取区域行数值"></a>2、按索引提取区域行数值</h2><p>df_inner.iloc[0:5]</p><h2 id="3、重设索引"><a href="#3、重设索引" class="headerlink" title="3、重设索引"></a>3、重设索引</h2><p>df_inner.reset_index()</p><h2 id="4、设置日期为索引"><a href="#4、设置日期为索引" class="headerlink" title="4、设置日期为索引"></a>4、设置日期为索引</h2><p>df_inner=df_inner.set_index(‘date’)</p><h2 id="5、提取4日之前的所有数据"><a href="#5、提取4日之前的所有数据" class="headerlink" title="5、提取4日之前的所有数据"></a>5、提取4日之前的所有数据</h2><p>df_inner[:’2013-01-04’]</p><h2 id="6、使用iloc按位置区域提取数据"><a href="#6、使用iloc按位置区域提取数据" class="headerlink" title="6、使用iloc按位置区域提取数据"></a>6、使用iloc按位置区域提取数据</h2><p>df_inner.iloc[:3,:2] #冒号前后的数字不再是索引的标签名称，而是数据所在的位置，从0开始，前三行，前两列。</p><h2 id="7、适应iloc按位置单独提起数据"><a href="#7、适应iloc按位置单独提起数据" class="headerlink" title="7、适应iloc按位置单独提起数据"></a>7、适应iloc按位置单独提起数据</h2><p>df_inner.iloc[[0,2,5],[4,5]] #提取第0、2、5行，4、5列</p><h2 id="8、使用ix按索引标签和位置混合提取数据"><a href="#8、使用ix按索引标签和位置混合提取数据" class="headerlink" title="8、使用ix按索引标签和位置混合提取数据"></a>8、使用ix按索引标签和位置混合提取数据</h2><p>df_inner.ix[:’2013-01-03’,:4] #2013-01-03号之前，前四列数据</p><h2 id="9、判断city列的值是否为北京"><a href="#9、判断city列的值是否为北京" class="headerlink" title="9、判断city列的值是否为北京"></a>9、判断city列的值是否为北京</h2><p>df_inner[‘city’].isin([‘beijing’])</p><h2 id="10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来"><a href="#10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来" class="headerlink" title="10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来"></a>10、判断city列里是否包含beijing和shanghai，然后将符合条件的数据提取出来</h2><p>df_inner.loc[df_inner[‘city’].isin([‘beijing’,’shanghai’])]</p><h2 id="11、提取前三个字符，并生成数据表"><a href="#11、提取前三个字符，并生成数据表" class="headerlink" title="11、提取前三个字符，并生成数据表"></a>11、提取前三个字符，并生成数据表</h2><p>pd.DataFrame(category.str[:3])</p><h1 id="六、数据筛选"><a href="#六、数据筛选" class="headerlink" title="六、数据筛选"></a>六、数据筛选</h1><p>使用与、或、非三个条件配合大于、小于、等于对数据进行筛选，并进行计数和求和。</p><h2 id="1、使用“与”进行筛选"><a href="#1、使用“与”进行筛选" class="headerlink" title="1、使用“与”进行筛选"></a>1、使用“与”进行筛选</h2><p>df_inner.loc[(df_inner[‘age’] &gt; 25) &amp; (df_inner[‘city’] == ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]]</p><h2 id="2、使用“或”进行筛选"><a href="#2、使用“或”进行筛选" class="headerlink" title="2、使用“或”进行筛选"></a>2、使用“或”进行筛选</h2><p>df_inner.loc[(df_inner[‘age’] &gt; 25) | (df_inner[‘city’] == ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]].sort([‘age’])</p><h2 id="3、使用“非”条件进行筛选"><a href="#3、使用“非”条件进行筛选" class="headerlink" title="3、使用“非”条件进行筛选"></a>3、使用“非”条件进行筛选</h2><p>df_inner.loc[(df_inner[‘city’] != ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]].sort([‘id’])</p><h2 id="4、对筛选后的数据按city列进行计数"><a href="#4、对筛选后的数据按city列进行计数" class="headerlink" title="4、对筛选后的数据按city列进行计数"></a>4、对筛选后的数据按city列进行计数</h2><p>df_inner.loc[(df_inner[‘city’] != ‘beijing’), [‘id’,’city’,’age’,’category’,’gender’]].sort([‘id’]).city.count()</p><h2 id="5、使用query函数进行筛选"><a href="#5、使用query函数进行筛选" class="headerlink" title="5、使用query函数进行筛选"></a>5、使用query函数进行筛选</h2><p>df_inner.query(‘city == [“beijing”, “shanghai”]’)</p><h2 id="6、对筛选后的结果按prince进行求和"><a href="#6、对筛选后的结果按prince进行求和" class="headerlink" title="6、对筛选后的结果按prince进行求和"></a>6、对筛选后的结果按prince进行求和</h2><p>df_inner.query(‘city == [“beijing”, “shanghai”]’).price.sum()</p><h1 id="七、数据汇总"><a href="#七、数据汇总" class="headerlink" title="七、数据汇总"></a>七、数据汇总</h1><p>主要函数是groupby和pivote_table</p><h2 id="1、对所有的列进行计数汇总"><a href="#1、对所有的列进行计数汇总" class="headerlink" title="1、对所有的列进行计数汇总"></a>1、对所有的列进行计数汇总</h2><p>df_inner.groupby(‘city’).count()</p><h2 id="2、按城市对id字段进行计数"><a href="#2、按城市对id字段进行计数" class="headerlink" title="2、按城市对id字段进行计数"></a>2、按城市对id字段进行计数</h2><p>df_inner.groupby(‘city’)[‘id’].count()</p><h2 id="3、对两个字段进行汇总计数"><a href="#3、对两个字段进行汇总计数" class="headerlink" title="3、对两个字段进行汇总计数"></a>3、对两个字段进行汇总计数</h2><p>df_inner.groupby([‘city’,’size’])[‘id’].count()</p><h2 id="4、对city字段进行汇总，并分别计算prince的合计和均值"><a href="#4、对city字段进行汇总，并分别计算prince的合计和均值" class="headerlink" title="4、对city字段进行汇总，并分别计算prince的合计和均值"></a>4、对city字段进行汇总，并分别计算prince的合计和均值</h2><p>df_inner.groupby(‘city’)[‘price’].agg([len,np.sum, np.mean])</p><h1 id="八、数据统计"><a href="#八、数据统计" class="headerlink" title="八、数据统计"></a>八、数据统计</h1><p>数据采样，计算标准差，协方差和相关系数</p><h2 id="1、简单的数据采样"><a href="#1、简单的数据采样" class="headerlink" title="1、简单的数据采样"></a>1、简单的数据采样</h2><p>df_inner.sample(n=3)</p><h2 id="2、手动设置采样权重"><a href="#2、手动设置采样权重" class="headerlink" title="2、手动设置采样权重"></a>2、手动设置采样权重</h2><p>weights = [0, 0, 0, 0, 0.5, 0.5]<br>df_inner.sample(n=2, weights=weights)</p><h2 id="3、采样后不放回"><a href="#3、采样后不放回" class="headerlink" title="3、采样后不放回"></a>3、采样后不放回</h2><p>df_inner.sample(n=6, replace=False)</p><h2 id="4、采样后放回"><a href="#4、采样后放回" class="headerlink" title="4、采样后放回"></a>4、采样后放回</h2><p>df_inner.sample(n=6, replace=True)</p><h2 id="5、-数据表描述性统计"><a href="#5、-数据表描述性统计" class="headerlink" title="5、 数据表描述性统计"></a>5、 数据表描述性统计</h2><p>df_inner.describe().round(2).T #round函数设置显示小数位，T表示转置</p><h2 id="6、计算列的标准差"><a href="#6、计算列的标准差" class="headerlink" title="6、计算列的标准差"></a>6、计算列的标准差</h2><p>df_inner[‘price’].std()</p><h2 id="7、计算两个字段间的协方差"><a href="#7、计算两个字段间的协方差" class="headerlink" title="7、计算两个字段间的协方差"></a>7、计算两个字段间的协方差</h2><p>df_inner[‘price’].cov(df_inner[‘m-point’])</p><h2 id="8、数据表中所有字段间的协方差"><a href="#8、数据表中所有字段间的协方差" class="headerlink" title="8、数据表中所有字段间的协方差"></a>8、数据表中所有字段间的协方差</h2><p>df_inner.cov()</p><h2 id="9、两个字段的相关性分析"><a href="#9、两个字段的相关性分析" class="headerlink" title="9、两个字段的相关性分析"></a>9、两个字段的相关性分析</h2><p>df_inner[‘price’].corr(df_inner[‘m-point’]) #相关系数在-1到1之间，接近1为正相关，接近-1为负相关，0为不相关</p><h2 id="10、数据表的相关性分析"><a href="#10、数据表的相关性分析" class="headerlink" title="10、数据表的相关性分析"></a>10、数据表的相关性分析</h2><p>df_inner.corr()</p><h1 id="九、数据输出"><a href="#九、数据输出" class="headerlink" title="九、数据输出"></a>九、数据输出</h1><p>分析后的数据可以输出为xlsx格式和csv格式</p><h2 id="1、写入Excel"><a href="#1、写入Excel" class="headerlink" title="1、写入Excel"></a>1、写入Excel</h2><p>df_inner.to_excel(‘excel_to_python.xlsx’, sheet_name=’bluewhale_cc’)</p><h2 id="2、写入到CSV"><a href="#2、写入到CSV" class="headerlink" title="2、写入到CSV"></a>2、写入到CSV</h2><p>df_inner.to_csv(‘excel_to_python.csv’)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Numpy详解</title>
      <link href="/posts/blog-python04.html"/>
      <url>/posts/blog-python04.html</url>
      
        <content type="html"><![CDATA[<h3 id="NumPy-Ndarray-对象"><a href="#NumPy-Ndarray-对象" class="headerlink" title="NumPy Ndarray 对象"></a>NumPy Ndarray 对象</h3><p>NumPy 最重要的一个特点是其 N 维数组对象 ndarray，它是一系列同类型数据的集合，以 0 下标为开始进行集合中元素的索引。</p><p>ndarray 对象是用于存放同类型元素的多维数组。</p><p>ndarray 中的每个元素在内存中都有相同存储大小的区域。</p><p>ndarray 内部由以下内容组成：</p><ul><li><p>一个指向数据（内存或内存映射文件中的一块数据）的指针。</p></li><li><p>数据类型或 dtype，描述在数组中的固定大小值的格子。</p></li><li><p>一个表示数组形状（shape）的元组，表示各维度大小的元组。</p></li><li><p>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要”跨过”的字节数。</p></li></ul><p>ndarray 的内部结构:<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-ed8acce11bbcd6bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>跨度可以是负数，这样会使数组在内存中后向移动，切片中 obj[::-1] 或 obj[:,::-1] 就是如此。</p><p>创建一个 ndarray 只需调用 NumPy 的 array 函数即可：</p><pre><code>numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-548ea678b56011aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-数据类型"><a href="#NumPy-数据类型" class="headerlink" title="NumPy 数据类型"></a>NumPy 数据类型</h3><p>numpy 支持的数据类型比 Python 内置的类型要多很多，基本上可以和 C 语言的数据类型对应上，其中部分类型对应为 Python 内置的类型。下表列举了常用 NumPy 基本类型。</p><ul><li>bool_    布尔型数据类型（True 或者 False）</li><li>int_    默认的整数类型（类似于 C 语言中的 long，int32 或 int64）</li><li>intc    与 C 的 int 类型一样，一般是 int32 或 int 64</li><li>intp    用于索引的整数类型（类似于 C 的 ssize_t，一般情况下仍然是 int32 或 int64）</li><li>int8    字节（-128 to 127）</li><li>int16    整数（-32768 to 32767）</li><li>int32    整数（-2147483648 to 2147483647）</li><li>int64    整数（-9223372036854775808 to 9223372036854775807）</li><li>uint8    无符号整数（0 to 255）</li><li>uint16    无符号整数（0 to 65535）</li><li>uint32    无符号整数（0 to 4294967295）</li><li>uint64    无符号整数（0 to 18446744073709551615）</li><li>float_    float64 类型的简写</li><li>float16    半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</li><li>float32    单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</li><li>float64    双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</li><li>complex_    complex128 类型的简写，即 128 位复数</li><li>complex64    复数，表示双 32 位浮点数（实数部分和虚数部分）</li><li>complex128    复数，表示双 64 位浮点数（实数部分和虚数部分）</li></ul><p>numpy 的数值类型实际上是 dtype 对象的实例，并对应唯一的字符，包括 np.bool_，np.int32，np.float32，等等。</p><h3 id="数据类型对象-dtype"><a href="#数据类型对象-dtype" class="headerlink" title="数据类型对象 (dtype)"></a>数据类型对象 (dtype)</h3><p>数据类型对象是用来描述与数组对应的内存区域如何使用，这依赖如下几个方面：</p><ul><li>数据的类型（整数，浮点数或者 Python 对象）</li><li>数据的大小（例如， 整数使用多少个字节存储）</li><li>数据的字节顺序（小端法或大端法）</li><li>在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分</li><li>如果数据类型是子数组，它的形状和数据类型<br>字节顺序是通过对数据类型预先设定”&lt;”或”&gt;”来决定的。”&lt;”意味着小端法(最小值存储在最小的地址，即低位组放在最前面)。”&gt;”意味着大端法(最重要的字节存储在最小的地址，即高位组放在最前面)。</li></ul><p>dtype 对象是使用以下语法构造的：</p><pre><code>numpy.dtype(object, align, copy)</code></pre><ul><li>object - 要转换为的数据类型对象</li><li>align - 如果为 true，填充字段使其类似 C 的结构体。</li><li>copy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用</li></ul><p>每个内建类型都有一个唯一定义它的字符代码，如下：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7c1c38e30b7100ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-数组属性"><a href="#NumPy-数组属性" class="headerlink" title="NumPy 数组属性"></a>NumPy 数组属性</h3><p>NumPy 数组的维数称为秩（rank），一维数组的秩为 1，二维数组的秩为 2，以此类推。</p><p>在 NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是 NumPy 中的轴（axis），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。</p><p>很多时候可以声明 axis。axis=0，表示沿着第 0 轴进行操作，即对<strong>每一列</strong>进行操作；axis=1，表示沿着第1轴进行操作，即对<strong>每一行</strong>进行操作。</p><p>NumPy 的数组中比较重要 ndarray 对象属性有：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-9c3ef5fd9250e4e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>ndarray.flags 返回 ndarray 对象的内存信息，包含以下属性：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6e4f7c2b8b6bc255.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-创建数组"><a href="#NumPy-创建数组" class="headerlink" title="NumPy 创建数组"></a>NumPy 创建数组</h3><p>ndarray 数组除了可以使用底层 ndarray 构造器来创建外，也可以通过以下几种方式来创建。</p><p><strong>numpy.empty</strong></p><p>numpy.empty 方法用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组：</p><pre><code>numpy.empty(shape, dtype = float, order = 'C')</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-dcada345e558e5a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.zeros</strong><br>创建指定大小的数组，数组元素以 0 来填充：</p><pre><code>numpy.zeros(shape, dtype = float, order = 'C')</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-af5db82b47841510.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.ones</strong><br>创建指定形状的数组，数组元素以 1 来填充：</p><pre><code>numpy.ones(shape, dtype = None, order = 'C')</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-dda70286db2d9ca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-从已有的数组创建数组"><a href="#NumPy-从已有的数组创建数组" class="headerlink" title="NumPy 从已有的数组创建数组"></a>NumPy 从已有的数组创建数组</h3><p><strong>numpy.asarray</strong><br>numpy.asarray 类似 numpy.array，但 numpy.asarray 只有三个，比 numpy.array 少两个。</p><pre><code>numpy.asarray(a, dtype = None, order = None)</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-44811e18ac421b72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.frombuffer</strong><br>numpy.frombuffer 用于实现动态数组。</p><p>numpy.frombuffer 接受 buffer 输入参数，以流的形式读入转化成 ndarray 对象。</p><pre><code>numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0)</code></pre><p><em>注意：buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。</em><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-106c550ac6996c34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.fromiter</strong><br>numpy.fromiter 方法从可迭代对象中建立 ndarray 对象，返回一维数组。</p><pre><code>numpy.fromiter(iterable, dtype, count=-1)</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-202a56a2011bbe3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-从数值范围创建数组"><a href="#NumPy-从数值范围创建数组" class="headerlink" title="NumPy 从数值范围创建数组"></a>NumPy 从数值范围创建数组</h3><p><strong>numpy.arange</strong><br>numpy 包中的使用 arange 函数创建数值范围并返回 ndarray 对象，函数格式如下：</p><pre><code>numpy.arange(start, stop, step, dtype)</code></pre><p>根据 start 与 stop 指定的范围以及 step 设定的步长，生成一个 ndarray。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-bbd5489c746a4048.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.linspace</strong><br>numpy.linspace 函数用于创建一个一维数组，数组是一个等差数列构成的，格式如下：</p><pre><code>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7313240ab629e03e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.logspace</strong><br>numpy.logspace 函数用于创建一个于等比数列。格式如下：</p><pre><code>np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></pre><p>base 参数意思是取对数的时候 log 的下标。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-1d29c671ae48f329.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-切片和索引"><a href="#NumPy-切片和索引" class="headerlink" title="NumPy 切片和索引"></a>NumPy 切片和索引</h3><p>ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样。</p><p>ndarray 数组可以基于 0 - n 的下标进行索引，切片对象可以通过内置的 slice 函数，并设置 start, stop 及 step 参数进行，从原数组中切割出一个新数组。</p><p>实例</p><pre><code>import numpy as npa = np.arange(10)s = slice(2,7,2)   # 从索引 2 开始到索引 7 停止，间隔为2print (a[s])</code></pre><p>输出结果为：</p><pre><code>[2  4  6]</code></pre><p>以上实例中，我们首先通过 arange() 函数创建 ndarray 对象。 然后，分别设置起始，终止和步长的参数为 2，7 和 2。</p><p>我们也可以通过冒号分隔切片参数 start:stop:step 来进行切片操作：</p><p>实例</p><pre><code>import numpy as npa = np.arange(10)  b = a[2:7:2]   # 从索引 2 开始到索引 7 停止，间隔为 2print(b)</code></pre><p>输出结果为：</p><pre><code>[2  4  6]</code></pre><p>冒号 : 的解释：如果只放置一个参数，如 [2]，将返回与该索引相对应的单个元素。如果为 [2:]，表示从该索引开始以后的所有项都将被提取。如果使用了两个参数，如 [2:7]，那么则提取两个索引(不包括停止索引)之间的项。</p><p>实例</p><pre><code>import numpy as npa = np.arange(10)  # [0 1 2 3 4 5 6 7 8 9]b = a[5] print(b)</code></pre><p>输出结果为：</p><pre><code>5</code></pre><p>实例</p><pre><code>import numpy as npa = np.arange(10)print(a[2:])</code></pre><p>输出结果为：</p><pre><code>[2  3  4  5  6  7  8  9]</code></pre><p>实例</p><pre><code>import numpy as npa = np.arange(10)  # [0 1 2 3 4 5 6 7 8 9]print(a[2:5])</code></pre><p>输出结果为：</p><pre><code>[2  3  4]</code></pre><p>多维数组同样适用上述索引提取方法：</p><p>实例</p><pre><code>import numpy as npa = np.array([[1,2,3],[3,4,5],[4,5,6]])print(a)# 从某个索引处开始切割print('从数组索引 a[1:] 处开始切割')print(a[1:])</code></pre><p>输出结果为：</p><pre><code>[[1 2 3] [3 4 5] [4 5 6]]</code></pre><p>从数组索引 a[1:] 处开始切割</p><pre><code>[[3 4 5] [4 5 6]]</code></pre><p>切片还可以包括省略号 …，来使选择元组的长度与数组的维度相同。 如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p><p>实例</p><pre><code>import numpy as npa = np.array([[1,2,3],[3,4,5],[4,5,6]])  print (a[...,1])   # 第2列元素print (a[1,...])   # 第2行元素print (a[...,1:])  # 第2列及剩下的所有元素</code></pre><p>输出结果为：</p><pre><code>[2 4 5][3 4 5][[2 3] [4 5] [5 6]]</code></pre><h3 id="NumPy-高级索引"><a href="#NumPy-高级索引" class="headerlink" title="NumPy 高级索引"></a>NumPy 高级索引</h3><ul><li>整数数组索引</li><li>布尔索引</li><li>花式索引</li></ul><h3 id="NumPy-广播-Broadcast"><a href="#NumPy-广播-Broadcast" class="headerlink" title="NumPy 广播(Broadcast)"></a>NumPy 广播(Broadcast)</h3><p>广播(Broadcast)是 numpy 对不同形状(shape)的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。</p><p>如果两个数组 a 和 b 形状相同，即满足 a.shape == b.shape，那么 a*b 的结果就是 a 与 b 数组对应位相乘。这要求维数相同，且各维度的长度相同。</p><pre><code>import numpy as np a = np.array([1,2,3,4]) b = np.array([10,20,30,40]) c = a * b print (c)</code></pre><p>输出结果为：</p><pre><code>[ 10  40  90 160]</code></pre><p>当运算中的 2 个数组的形状不同时，numpy 将自动触发广播机制。如：</p><pre><code>import numpy as np a = np.array([[ 0, 0, 0],           [10,10,10],           [20,20,20],           [30,30,30]])b = np.array([1,2,3])print(a + b)</code></pre><p>输出结果为：</p><pre><code>[[ 1  2  3] [11 12 13] [21 22 23] [31 32 33]]</code></pre><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-de5bcc31bbecc9fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>广播的规则:</p><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。</li><li>输出数组的形状是输入数组形状的各个维度上的最大值。</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。</li><li>当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。</li></ul><p>简单理解：对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：</p><ul><li>数组拥有相同形状。</li><li>当前维度的值相等。</li><li>当前维度的值有一个是 1。</li></ul><p>若条件不满足，抛出 “ValueError: frames are not aligned” 异常。</p><h3 id="NumPy-迭代数组"><a href="#NumPy-迭代数组" class="headerlink" title="NumPy 迭代数组"></a>NumPy 迭代数组</h3><p>NumPy 迭代器对象 numpy.nditer 提供了一种灵活访问一个或者多个数组元素的方式。</p><p>迭代器最基本的任务的可以完成对数组元素的访问。</p><p>接下来我们使用 arange() 函数创建一个 2X3 数组，并使用 nditer 对它进行迭代。</p><pre><code>import numpy as npa = np.arange(6).reshape(2,3)print ('原始数组是：')print (a)print ('\n')print ('迭代输出元素：')for x in np.nditer(a):    print (x, end=", " )print ('\n')</code></pre><p>输出结果为：</p><pre><code>原始数组是：[[0 1 2] [3 4 5]]迭代输出元素：0, 1, 2, 3, 4, 5, </code></pre><p>以上实例不是使用标准 C 或者 Fortran 顺序，选择的顺序是和数组内存布局一致的，这样做是为了提升访问的效率，默认是行序优先（row-major order，或者说是 C-order）。</p><p>这反映了默认情况下只需访问每个元素，而无需考虑其特定顺序。我们可以通过迭代上述数组的转置来看到这一点，并与以 C 顺序访问数组转置的 copy 方式做对比，如下实例：</p><pre><code>import numpy as npa = np.arange(6).reshape(2,3)for x in np.nditer(a.T):    print (x, end=", " )print ('\n')for x in np.nditer(a.T.copy(order='C')):    print (x, end=", " )print ('\n')</code></pre><p>输出结果为：</p><pre><code>0, 1, 2, 3, 4, 5, 0, 3, 1, 4, 2, 5, </code></pre><p>从上述例子可以看出，a 和 a.T 的遍历顺序是一样的，也就是他们在内存中的存储顺序也是一样的，但是 a.T.copy(order = ‘C’) 的遍历结果是不同的，那是因为它和前两种的存储方式是不一样的，默认是按行访问。</p><p><strong>控制遍历顺序</strong><br>for x in np.nditer(a, order=’F’):Fortran order，即是列序优先；<br>for x in np.nditer(a.T, order=’C’):C order，即是行序优先；</p><p><strong>修改数组中元素的值</strong><br>nditer 对象有另一个可选参数 op_flags。 默认情况下，nditer 将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定 read-write 或者 write-only 的模式。</p><p><strong>使用外部循环</strong><br>nditer类的构造器拥有flags参数，它可以接受下列值：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7d2b0669e6bb65de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>广播迭代</strong><br>如果两个数组是可广播的，nditer 组合对象能够同时迭代它们。 假设数组 a 的维度为 3X4，数组 b 的维度为 1X4 ，则使用以下迭代器（数组 b 被广播到 a 的大小）。</p><h3 id="Numpy-数组操作"><a href="#Numpy-数组操作" class="headerlink" title="Numpy 数组操作"></a>Numpy 数组操作</h3><p><strong>修改数组形状</strong><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f2d06e9db8323294.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.reshape</strong><br>numpy.reshape 函数可以在不改变数据的条件下修改形状，格式如下： numpy.reshape(arr, newshape, order=’C’)</p><ul><li>arr：要修改形状的数组</li><li>newshape：整数或者整数数组，新的形状应当兼容原有形状</li><li>order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’k’ – 元素在内存中的出现顺序。</li></ul><p><strong>numpy.ndarray.flat</strong><br>numpy.ndarray.flat 是一个数组元素迭代器</p><p><strong>numpy.ndarray.flatten</strong><br>numpy.ndarray.flatten 返回一份数组拷贝，对拷贝所做的修改不会影响原始数组，格式如下：</p><pre><code>ndarray.flatten(order='C')</code></pre><p>参数说明：</p><ul><li>order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。</li></ul><p><strong>numpy.ravel</strong><br>numpy.ravel() 展平的数组元素，顺序通常是”C风格”，返回的是数组视图（view，有点类似 C/C++引用reference的意味），修改会影响原始数组。</p><p>该函数接收两个参数：</p><pre><code>numpy.ravel(a, order='C')</code></pre><p>参数说明：</p><ul><li>order：’C’ – 按行，’F’ – 按列，’A’ – 原顺序，’K’ – 元素在内存中的出现顺序。</li></ul><p><strong>翻转数组</strong><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-e7cc83b5e6dee2ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.transpose</strong><br>numpy.transpose 函数用于对换数组的维度，格式如下：</p><pre><code>numpy.transpose(arr, axes)</code></pre><p>参数说明:</p><ul><li>arr：要操作的数组</li><li>axes：整数列表，对应维度，通常所有维度都会对换。</li></ul><p><strong>numpy.rollaxis</strong><br>numpy.rollaxis 函数向后滚动特定的轴到一个特定位置，格式如下：</p><pre><code>numpy.rollaxis(arr, axis, start)</code></pre><p>参数说明：</p><ul><li>arr：数组</li><li>axis：要向后滚动的轴，其它轴的相对位置不会改变</li><li>start：默认为零，表示完整的滚动。会滚动到特定位置。</li></ul><p><strong>numpy.swapaxes</strong><br>numpy.swapaxes 函数用于交换数组的两个轴，格式如下：</p><pre><code>numpy.swapaxes(arr, axis1, axis2)</code></pre><ul><li>arr：输入的数组</li><li>axis1：对应第一个轴的整数</li><li>axis2：对应第二个轴的整数</li></ul><p><strong>修改数组维度</strong><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-932b54f20b2f213b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.broadcast</strong><br>numpy.broadcast 用于模仿广播的对象，它返回一个对象，该对象封装了将一个数组广播到另一个数组的结果。</p><p><strong>numpy.broadcast_to</strong><br>numpy.broadcast_to 函数将数组广播到新形状。它在原始数组上返回只读视图。 它通常不连续。 如果新形状不符合 NumPy 的广播规则，该函数可能会抛出ValueError。</p><pre><code>numpy.broadcast_to(array, shape, subok)</code></pre><p><strong>numpy.expand_dims</strong><br>numpy.expand_dims 函数通过在指定位置插入新的轴来扩展数组形状，函数格式如下:</p><pre><code> numpy.expand_dims(arr, axis)</code></pre><p>参数说明：</p><ul><li>arr：输入数组</li><li>axis：新轴插入的位置</li></ul><p><strong>numpy.squeeze</strong><br>numpy.squeeze 函数从给定数组的形状中删除一维的条目，函数格式如下：</p><pre><code>numpy.squeeze(arr, axis)</code></pre><p>参数说明：</p><ul><li>arr：输入数组</li><li>axis：整数或整数元组，用于选择形状中一维条目的子集</li></ul><h3 id="连接数组"><a href="#连接数组" class="headerlink" title="连接数组"></a>连接数组</h3><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-2c328fe33d5e182f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.concatenate</strong><br>numpy.concatenate 函数用于沿指定轴连接相同形状的两个或多个数组，格式如下：</p><pre><code>numpy.concatenate((a1, a2, ...), axis)</code></pre><p>参数说明：</p><ul><li>a1, a2, …：相同类型的数组</li><li>axis：沿着它连接数组的轴，默认为 0</li></ul><p><strong>numpy.stack</strong><br>numpy.stack 函数用于沿新轴连接数组序列，格式如下：</p><pre><code>numpy.stack(arrays, axis)</code></pre><p>参数说明：</p><ul><li>arrays相同形状的数组序列</li><li>axis：返回数组中的轴，输入数组沿着它来堆叠</li></ul><p><strong>numpy.hstack</strong><br>numpy.hstack 是 numpy.stack 函数的变体，它通过水平堆叠来生成数组。</p><p><strong>numpy.vstack</strong><br>numpy.vstack 是 numpy.stack 函数的变体，它通过垂直堆叠来生成数组。</p><p><strong>分割数组</strong><br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-b90db31e02fc9ce9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><strong>numpy.split</strong><br>numpy.split 函数沿特定的轴将数组分割为子数组，格式如下：</p><pre><code>numpy.split(ary, indices_or_sections, axis)</code></pre><p>参数说明：</p><ul><li>ary：被分割的数组</li><li>indices_or_sections：果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭）</li><li>axis：沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分</li></ul><p><strong>numpy.hsplit</strong><br>numpy.hsplit 函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组。</p><p><strong>numpy.vsplit</strong><br>numpy.vsplit 沿着垂直轴分割，其分割方式与hsplit用法相同。</p><h3 id="数组元素的添加与删除"><a href="#数组元素的添加与删除" class="headerlink" title="数组元素的添加与删除"></a>数组元素的添加与删除</h3><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-8fae55a7e4ce8c85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.resize</strong><br>numpy.resize 函数返回指定大小的新数组。</p><p>如果新数组大小大于原始大小，则包含原始数组中的元素的副本。</p><pre><code>numpy.resize(arr, shape)</code></pre><p>参数说明：</p><ul><li>arr：要修改大小的数组</li><li>shape：返回数组的新形状</li></ul><p><strong>numpy.append</strong><br>numpy.append 函数在数组的末尾添加值。 追加操作会分配整个数组，并把原来的数组复制到新数组中。 此外，输入数组的维度必须匹配否则将生成ValueError。</p><p>append 函数返回的始终是一个一维数组。</p><pre><code>numpy.append(arr, values, axis=None)</code></pre><p>参数说明：</p><ul><li>arr：输入数组</li><li>values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）</li><li>axis：默认为 None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。</li></ul><p><strong>numpy.insert</strong><br>numpy.insert 函数在给定索引之前，沿给定轴在输入数组中插入值。</p><p>如果值的类型转换为要插入，则它与输入数组不同。 插入没有原地的，函数会返回一个新数组。 此外，如果未提供轴，则输入数组会被展开。</p><pre><code>numpy.insert(arr, obj, values, axis)</code></pre><p>参数说明：</p><ul><li>arr：输入数组</li><li>obj：在其之前插入值的索引</li><li>values：要插入的值</li><li>axis：沿着它插入的轴，如果未提供，则输入数组会被展开</li></ul><p><strong>numpy.delete</strong><br>numpy.delete 函数返回从输入数组中删除指定子数组的新数组。 与 insert() 函数的情况一样，如果未提供轴参数，则输入数组将展开。</p><pre><code>Numpy.delete(arr, obj, axis)</code></pre><p>参数说明：</p><ul><li>arr：输入数组</li><li>obj：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</li><li>axis：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开</li></ul><p><strong>numpy.unique</strong><br>numpy.unique 函数用于去除数组中的重复元素。</p><pre><code>numpy.unique(arr, return_index, return_inverse, return_counts)</code></pre><ul><li>arr：输入数组，如果不是一维数组则会展开</li><li>return_index：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储</li><li>return_inverse：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储</li><li>return_counts：如果为true，返回去重数组中的元素在原数组中的出现次数</li></ul><h3 id="NumPy-位运算"><a href="#NumPy-位运算" class="headerlink" title="NumPy 位运算"></a>NumPy 位运算</h3><p>NumPy “bitwise_” 开头的函数是位运算函数。</p><p>NumPy 位运算包括以下几个函数：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-d2002e3200dea632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-字符串函数"><a href="#NumPy-字符串函数" class="headerlink" title="NumPy 字符串函数"></a>NumPy 字符串函数</h3><p>以下函数用于对 dtype 为 numpy.string_ 或 numpy.unicode_ 的数组执行向量化字符串操作。 它们基于 Python 内置库中的标准字符串函数。</p><p>这些函数在字符数组类（numpy.char）中定义。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7b14ae371864668b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="NumPy-数学函数"><a href="#NumPy-数学函数" class="headerlink" title="NumPy 数学函数"></a>NumPy 数学函数</h3><p><strong>三角函数</strong><br>NumPy 提供了标准的三角函数：sin()、cos()、tan()。</p><p><strong>舍入函数</strong><br>numpy.around() 函数返回指定数字的四舍五入值。</p><pre><code>numpy.around(a,decimals)</code></pre><p>参数说明：</p><ul><li>a: 数组</li><li>decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置</li></ul><p><strong>numpy.floor()</strong><br>numpy.floor() 返回数字的下舍整数。</p><p><strong>numpy.ceil()</strong><br>numpy.ceil() 返回数字的上入整数。</p><h3 id="NumPy-算术函数"><a href="#NumPy-算术函数" class="headerlink" title="NumPy 算术函数"></a>NumPy 算术函数</h3><p>NumPy 算术函数包含简单的加减乘除: add()，subtract()，multiply() 和 divide()。</p><p>需要注意的是数组必须具有相同的形状或符合数组广播规则。</p><p>此外 Numpy 也包含了其他重要的算术函数。</p><p><strong>numpy.reciprocal()</strong><br>numpy.reciprocal() 函数返回参数逐元素的倒数。如 1/4 倒数为 4/1。</p><p><strong>numpy.power()</strong><br>numpy.power() 函数将第一个输入数组中的元素作为底数，计算它与第二个输入数组中相应元素的幂。</p><p><strong>numpy.mod()</strong><br>numpy.mod() 计算输入数组中相应元素的相除后的余数。 函数 numpy.remainder() 也产生相同的结果。</p><h3 id="NumPy-统计函数"><a href="#NumPy-统计函数" class="headerlink" title="NumPy 统计函数"></a>NumPy 统计函数</h3><p><strong>numpy.amin() 和 numpy.amax()</strong><br>numpy.amin() 用于计算数组中的元素沿指定轴的最小值。</p><p>numpy.amax() 用于计算数组中的元素沿指定轴的最大值。</p><p><strong>numpy.ptp()</strong><br>numpy.ptp()函数计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p><p><strong>numpy.percentile()</strong><br>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 函数numpy.percentile()接受以下参数。</p><pre><code>numpy.percentile(a, q, axis)</code></pre><p>参数说明：</p><ul><li>a: 输入数组</li><li>q: 要计算的百分位数，在 0 ~ 100 之间</li><li>axis: 沿着它计算百分位数的轴<br>首先明确百分位数：</li></ul><p>第 p 个百分位数是这样一个值，它使得至少有 p% 的数据项小于或等于这个值，且至少有 (100-p)% 的数据项大于或等于这个值。</p><p>举个例子：高等院校的入学考试成绩经常以百分位数的形式报告。比如，假设某个考生在入学考试中的语文部分的原始分数为 54 分。相对于参加同一考试的其他学生来说，他的成绩如何并不容易知道。但是如果原始分数54分恰好对应的是第70百分位数，我们就能知道大约70%的学生的考分比他低，而约30%的学生考分比他高。</p><p>这里的 p = 70。</p><p><strong>numpy.median()</strong><br>numpy.median() 函数用于计算数组 a 中元素的中位数（中值）</p><p><strong>numpy.mean()</strong><br>numpy.mean() 函数返回数组中元素的算术平均值。 如果提供了轴，则沿其计算。</p><p>算术平均值是沿轴的元素的总和除以元素的数量。</p><p><strong>numpy.average()</strong><br>numpy.average() 函数根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值。</p><p>该函数可以接受一个轴参数。 如果没有指定轴，则数组会被展开。</p><p>加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数。</p><p>考虑数组[1,2,3,4]和相应的权重[4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值。</p><p><strong>标准差</strong><br>标准差是一组数据平均值分散程度的一种度量。</p><p>标准差是方差的算术平方根。</p><p>标准差公式如下：</p><pre><code>std = sqrt(mean((x - x.mean())**2))</code></pre><p>如果数组是 [1，2，3，4]，则其平均值为 2.5。 因此，差的平方是 [2.25,0.25,0.25,2.25]，并且其平均值的平方根除以 4，即 sqrt(5/4) ，结果为 1.1180339887498949。</p><p><strong>方差</strong><br>统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方值的平均数，即 mean((x - x.mean())** 2)。</p><p>换句话说，标准差是方差的平方根。</p><h3 id="NumPy-排序、条件刷选函数"><a href="#NumPy-排序、条件刷选函数" class="headerlink" title="NumPy 排序、条件刷选函数"></a>NumPy 排序、条件刷选函数</h3><p>NumPy 提供了多种排序的方法。 这些排序函数实现不同的排序算法，每个排序算法的特征在于执行速度，最坏情况性能，所需的工作空间和算法的稳定性。 下表显示了三种排序算法的比较。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-253e8d77eb1b7539.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.sort()</strong><br>numpy.sort() 函数返回输入数组的排序副本。函数格式如下：</p><pre><code>numpy.sort(a, axis, kind, order)</code></pre><p><strong>numpy.argsort()</strong><br>numpy.argsort() 函数返回的是数组值从小到大的索引值。</p><p><strong>numpy.lexsort()</strong><br>numpy.lexsort() 用于对多个序列进行排序。把它想象成对电子表格进行排序，每一列代表一个序列，排序时优先照顾靠后的列。</p><p>这里举一个应用场景：小升初考试，重点班录取学生按照总成绩录取。在总成绩相同时，数学成绩高的优先录取，在总成绩和数学成绩都相同时，按照英语成绩录取…… 这里，总成绩排在电子表格的最后一列，数学成绩在倒数第二列，英语成绩在倒数第三列。</p><p><strong>msort、sort_complex、partition、argpartition</strong></p><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-7b94c231e2b3a965.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.argmax() 和 numpy.argmin()</strong><br>numpy.argmax() 和 numpy.argmin()函数分别沿给定轴返回最大和最小元素的索引。</p><p><strong>numpy.nonzero()</strong><br>numpy.nonzero() 函数返回输入数组中非零元素的索引。</p><p><strong>numpy.where()</strong><br>numpy.where() 函数返回输入数组中满足给定条件的元素的索引。</p><p><strong>numpy.extract()</strong><br>numpy.extract() 函数根据某个条件从数组中抽取元素，返回满条件的元素。</p><h3 id="NumPy-字节交换"><a href="#NumPy-字节交换" class="headerlink" title="NumPy 字节交换"></a>NumPy 字节交换</h3><p>在几乎所有的机器上，多字节对象都被存储为连续的字节序列。字节顺序，是跨越多字节的程序对象的存储规则。</p><ul><li><p>大端模式：指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。</p></li><li><p>小端模式：指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</p></li></ul><p>例如在 C 语言中，一个类型为 int 的变量 x 地址为 0x100，那么其对应地址表达式&amp;x的值为 0x100。且x的四个字节将被存储在存储器的 0x100, 0x101, 0x102, 0x103位置。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cfb1dc912601047a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.ndarray.byteswap()</strong><br>numpy.ndarray.byteswap() 函数将 ndarray 中每个元素中的字节进行大小端转换。</p><h3 id="NumPy-矩阵库-Matrix"><a href="#NumPy-矩阵库-Matrix" class="headerlink" title="NumPy 矩阵库(Matrix)"></a>NumPy 矩阵库(Matrix)</h3><p>NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象。</p><p><strong>matlib.empty()</strong><br>matlib.empty() 函数返回一个新的矩阵，语法格式为：</p><pre><code>numpy.matlib.empty(shape, dtype, order)</code></pre><p>参数说明：</p><pre><code>shape: 定义新矩阵形状的整数或整数元组Dtype: 可选，数据类型order: C（行序优先） 或者 F（列序优先）</code></pre><p><strong>numpy.matlib.zeros()</strong><br>numpy.matlib.zeros() 函数创建一个以 0 填充的矩阵。</p><p><strong>numpy.matlib.ones()</strong><br>numpy.matlib.ones()函数创建一个以 1 填充的矩阵。</p><p><strong>numpy.matlib.eye()</strong><br>numpy.matlib.eye() 函数返回一个矩阵，对角线元素为 1，其他位置为零。</p><pre><code>numpy.matlib.eye(n, M,k, dtype)</code></pre><p>参数说明：</p><pre><code>n: 返回矩阵的行数M: 返回矩阵的列数，默认为 nk: 对角线的索引dtype: 数据类型</code></pre><p><strong>numpy.matlib.identity()</strong><br>numpy.matlib.identity() 函数返回给定大小的单位矩阵。</p><p>单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-270c1beafc8a5565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.matlib.rand()</strong><br>numpy.matlib.rand() 函数创建一个给定大小的矩阵，数据是随机填充的。</p><h3 id="NumPy-线性代数"><a href="#NumPy-线性代数" class="headerlink" title="NumPy 线性代数"></a>NumPy 线性代数</h3><p><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-3d0280b2e9ab232a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>numpy.dot()</strong><br>numpy.dot() 对于两个一维的数组，计算的是这两个数组对应下标元素的乘积和(数学上称之为内积)；对于二维数组，计算的是两个数组的矩阵乘积；对于多维数组，它的通用计算公式如下，即结果数组中的每个元素都是：数组a的最后一维上的所有元素与数组b的倒数第二位上的所有元素的乘积和： dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])。</p><pre><code>numpy.dot(a, b, out=None) </code></pre><p>参数说明：</p><pre><code>a : ndarray 数组b : ndarray 数组out : ndarray, 可选，用来保存dot()的计算结果</code></pre><p><strong>numpy.vdot()</strong><br>numpy.vdot() 函数是两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数是多维数组，它会被展开。</p><p><strong>numpy.inner()</strong><br>numpy.inner() 函数返回一维数组的向量内积。对于更高的维度，它返回最后一个轴上的和的乘积。</p><p><strong>numpy.matmul</strong><br>numpy.matmul 函数返回两个数组的矩阵乘积。 虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。</p><p>另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。</p><p><strong>numpy.linalg.det()</strong><br>numpy.linalg.det() 函数计算输入矩阵的行列式。</p><p>行列式在线性代数中是非常有用的值。 它从方阵的对角元素计算。 对于 2×2 矩阵，它是左上和右下元素的乘积与其他两个的乘积的差。</p><p>换句话说，对于矩阵[[a，b]，[c，d]]，行列式计算为 ad-bc。 较大的方阵被认为是 2×2 矩阵的组合。</p><p><strong>numpy.linalg.solve()</strong><br>numpy.linalg.solve() 函数给出了矩阵形式的线性方程的解。</p><p>考虑以下线性方程：</p><p>x + y + z = 6</p><p>2y + 5z = -4</p><p>2x + 5y - z = 27<br>可以使用矩阵表示为：<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-6a10ed854cec035f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>如果矩阵成为A、X和B，方程变为：</p><p>AX = B</p><p>或</p><p>X = A^(-1)B</p><p><strong>numpy.linalg.inv()</strong><br>numpy.linalg.inv() 函数计算矩阵的乘法逆矩阵。</p><p>逆矩阵（inverse matrix）：设A是数域上的一个n阶矩阵，若在相同数域上存在另一个n阶矩阵B，使得： AB=BA=E ，则我们称B是A的逆矩阵，而A则被称为可逆矩阵。注：E为单位矩阵。</p><h3 id="NumPy-IO"><a href="#NumPy-IO" class="headerlink" title="NumPy IO"></a>NumPy IO</h3><p>Numpy 可以读写磁盘上的文本数据或二进制数据。</p><p>NumPy 为 ndarray 对象引入了一个简单的文件格式：npy。</p><p>npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。</p><p>常用的 IO 函数有：</p><ul><li>load() 和 save() 函数是读写文件数组数据的两个主要函数，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npy 的文件中。</li><li>savze() 函数用于将多个数组写入文件，默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为 .npz 的文件中。</li><li>loadtxt() 和 savetxt() 函数处理正常的文本文件(.txt 等)</li></ul><p><strong>numpy.save()</strong><br>numpy.save() 函数将数组保存到以 .npy 为扩展名的文件中。</p><pre><code>numpy.save(file, arr, allow_pickle=True, fix_imports=True)</code></pre><p>参数说明：</p><pre><code>file：要保存的文件，扩展名为 .npy，如果文件路径末尾没有扩展名 .npy，该扩展名会被自动加上。arr: 要保存的数组allow_pickle: 可选，布尔值，允许使用 Python pickles 保存对象数组，Python 中的 pickle 用于在保存到磁盘文件或从磁盘文件读取之前，对对象进行序列化和反序列化。fix_imports: 可选，为了方便 Pyhton2 中读取 Python3 保存的数据。</code></pre><p><strong>np.savez</strong><br>numpy.savez() 函数将多个数组保存到以 npz 为扩展名的文件中。</p><pre><code>numpy.savez(file, *args, **kwds)</code></pre><p>参数说明：</p><pre><code>file：要保存的文件，扩展名为 .npz，如果文件路径末尾没有扩展名 .npz，该扩展名会被自动加上。args: 要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为 arr_0, arr_1, …　。kwds: 要保存的数组使用关键字名称。</code></pre><p><strong>savetxt()</strong><br>savetxt() 函数是以简单的文本文件格式存储数据，对应的使用 loadtxt() 函数来获取数据。</p><pre><code>np.loadtxt(FILENAME, dtype=int, delimiter=' ')np.savetxt(FILENAME, a, fmt="%d", delimiter=",")</code></pre><p>参数 delimiter 可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python画一只会眨眼睛的皮卡丘</title>
      <link href="/posts/blog-python03.html"/>
      <url>/posts/blog-python03.html</url>
      
        <content type="html"><![CDATA[<h1 id="Pikaqiu-用turtle绘画的皮卡丘"><a href="#Pikaqiu-用turtle绘画的皮卡丘" class="headerlink" title="Pikaqiu 用turtle绘画的皮卡丘"></a>Pikaqiu 用turtle绘画的皮卡丘</h1><ol><li>首先我们导入turtle库和time库（用来做动画使用）:<pre><code>import turtle as timport time</code></pre></li><li>由于turtle没有画曲线的函数，因此我们自定义画曲线函数,函数有4个参数，ang偏转角度，dis移动步长，step步长增幅，n遍历次数，说白了就是将曲线转化为很多条短长的直线：<pre><code>#画左偏曲线函数def radian_left(ang,dis,step,n): for i in range(n):     dis+=step #dis增大step     t.lt(ang) #向左转ang度     t.fd(dis) #向前走dis的步长    def radian_right(ang,dis,step,n): for i in range(n):     dis+=step     t.rt(ang) #向左转ang度     t.fd(dis) #向前走dis的步长</code></pre></li><li>定义画耳朵，眼睛，嘴，轮廓，脚画尾巴的函数，具体见python文件</li><li>初始化皮卡丘：<pre><code>#初始化def Init(): InitEars() InitTail() InitFoots() InitBody() InitFace() InitHands() InitEyes()</code></pre></li><li>定义Upgrade函数和Upgarde_init函数制作眨眼动画：<pre><code>#眨眼睛def Upgarde(): InitEars() InitTail() InitFoots() InitBody() InitFace() InitHands() CloseEyes()def Upgarde_Init(): InitEars() InitTail() InitFoots() InitBody() InitFace() InitHands() InitEyes()</code></pre><ol start="6"><li>Main函数定义：<pre><code>def main():Init()  t.tracer(False)   #眨眼睛动画for i in range(30):  if i%2==0:      t.reset()      t.hideturtle()      Upgarde()      t.update()      time.sleep(0.3)  else:      t.reset()      t.hideturtle()      Upgarde_Init()      t.update()      time.sleep(1)        </code></pre><h1 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h1><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-b70381c6d5e08b89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pikaqiu.png"></li></ol></li></ol><p>视频动画可以打包下载该文件，点击pikaqiu.mp4观看<br><a href="https://github.com/JackHCC/Pikaqiu" target="_blank" rel="noopener">Github源码下载地址</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | Turtle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-Turtle详解</title>
      <link href="/posts/blog-python02.html"/>
      <url>/posts/blog-python02.html</url>
      
        <content type="html"><![CDATA[<p>#turtle绘图的基础知识：<br>####1.画布</p><pre><code>turtle.screensize(canvwidth=None, canvheight=None, bg=None)</code></pre><p>参数分别为画布的宽(单位像素), 高, 背景颜色。如：turtle.screensize(800,600, “green”)</p><pre><code>turtle.screensize() #返回默认大小(400, 300)turtle.setup(width=0.5, height=0.75, startx=None, starty=None)</code></pre><p>参数：width, height: 输入宽和高为整数时, 表示像素; 为小数时, 表示占据电脑屏幕的比例，(startx, starty): 这一坐标表示矩形窗口左上角顶点的位置, 如果为空,则窗口位于屏幕中心。</p><p>####2.画笔<br>####2.1 画笔的状态<br>在画布上，默认有一个坐标原点为画布中心的坐标轴，坐标原点上有一只面朝x轴正方向小乌龟。这里我们描述小乌龟时使用了两个词语：坐标原点(位置)，面朝x轴正方向(方向)， turtle绘图中，就是使用位置方向描述小乌龟(画笔)的状态。</p><p>####2.2 画笔的属性<br>画笔(画笔的属性，颜色、画线的宽度等)</p><pre><code>    1) turtle.pensize()：设置画笔的宽度；    2) turtle.pencolor()：没有参数传入，返回当前画笔颜色，传入参数设置画笔颜色，可以是字符串如"green", "red",也可以是RGB 3元组。    3) turtle.speed(speed)：设置画笔移动速度，画笔绘制的速度范围[0,10]整数，数字越大越快。</code></pre><p>####2.3 绘图命令</p><p>操纵海龟绘图有着许多的命令，这些命令可以划分为3种：一种为运动命令，一种为画笔控制命令，还有一种是全局控制命令。<br>######(1)    画笔运动命令</p><ul><li>turtle.forward(distance)</li></ul><p>向当前画笔方向移动distance像素长度</p><ul><li>turtle.backward(distance)</li></ul><p>向当前画笔相反方向移动distance像素长度</p><ul><li>turtle.right(degree)</li></ul><p>顺时针移动degree°</p><ul><li>turtle.left(degree)</li></ul><p>逆时针移动degree°</p><ul><li>turtle.pendown()</li></ul><p>移动时绘制图形，缺省时也为绘制</p><ul><li>turtle.goto(x,y)</li></ul><p>将画笔移动到坐标为x,y的位置</p><ul><li>turtle.penup()</li></ul><p>提起笔移动，不绘制图形，用于另起一个地方绘制</p><ul><li>turtle.circle()</li></ul><p>画圆，半径为正(负)，表示圆心在画笔的左边(右边)画圆</p><ul><li>setx( )</li></ul><p>将当前x轴移动到指定位置</p><ul><li>sety( )</li></ul><p>将当前y轴移动到指定位置</p><ul><li>setheading(angle)</li></ul><p>设置当前朝向为angle角度</p><ul><li>home()</li></ul><p>设置当前画笔位置为原点，朝向东。</p><ul><li><p>dot(r)<br>######(2)     画笔控制命令</p></li><li><p>turtle.fillcolor(colorstring)</p></li></ul><p>绘制图形的填充颜色</p><ul><li>turtle.color(color1, color2)</li></ul><p>同时设置pencolor=color1, fillcolor=color2</p><ul><li>turtle.filling()</li></ul><p>返回当前是否在填充状态</p><ul><li>turtle.begin_fill()</li></ul><p>准备开始填充图形</p><ul><li>turtle.end_fill()</li></ul><p>填充完成</p><ul><li>turtle.hideturtle()</li></ul><p>隐藏画笔的turtle形状</p><ul><li>turtle.showturtle()</li></ul><p>显示画笔的turtle形状<br>######(3)    全局控制命令</p><ul><li>turtle.clear()</li></ul><p>清空turtle窗口，但是turtle的位置和状态不会改变</p><ul><li>turtle.reset()</li></ul><p>清空窗口，重置turtle状态为起始状态</p><ul><li>turtle.undo()</li></ul><p>撤销上一个turtle动作</p><ul><li>turtle.isvisible()</li></ul><p>返回当前turtle是否可见</p><ul><li>stamp()</li></ul><p>复制当前图形</p><ul><li>turtle.write(s [,font=(“font-name”,font_size,”font_type”)])</li></ul><p>写文本，s为文本内容，font是字体的参数，分别为字体名称，大小和类型；font为可选项，font参数也是可选项<br>######(4)    其他命令</p><ul><li>turtle.mainloop()或turtle.done()</li></ul><p>启动事件循环 -调用Tkinter的mainloop函数。</p><p>必须是乌龟图形程序中的最后一个语句。</p><ul><li>turtle.mode(mode=None)</li></ul><p>设置乌龟模式（“standard”，“logo”或“world”）并执行重置。如果没有给出模式，则返回当前模式。</p><ul><li>turtle.delay(delay=None)</li></ul><p>设置或返回以毫秒为单位的绘图延迟。</p><ul><li>turtle.begin_poly()</li></ul><p>开始记录多边形的顶点。当前的乌龟位置是多边形的第一个顶点。</p><ul><li>turtle.end_poly()</li></ul><p>停止记录多边形的顶点。当前的乌龟位置是多边形的最后一个顶点。将与第一个顶点相连。</p><ul><li>turtle.get_poly()</li></ul><p>返回最后记录的多边形。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python | Turtle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础知识</title>
      <link href="/posts/blog-python01.html"/>
      <url>/posts/blog-python01.html</url>
      
        <content type="html"><![CDATA[<h1 id="课程笔记"><a href="#课程笔记" class="headerlink" title="$课程笔记"></a>$课程笔记</h1><p><img src="/images/loading.gif" data-original="http://upload-images.jianshu.io/upload_images/14093662-c7908d67f53948e5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><a href="https://www.w3cschool.cn/python/dict" target="_blank" rel="noopener">python相关函数查询</a></p><p><a href="https://docs.python.org/zh-cn/3/tutorial/index.html" target="_blank" rel="noopener">官方API文档</a></p><p><a href="https://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">菜鸟教程python</a></p><p><a href="https://www.w3cschool.cn/python/" target="_blank" rel="noopener">w3school教程python</a></p><h3 id="一-基本元素"><a href="#一-基本元素" class="headerlink" title="一.基本元素"></a>一.基本元素</h3><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ul><li>变量赋值：<pre><code>a="hello world"</code></pre></li><li>变量命名：<br>• 字母：a-z, A-Z, 其他语言的字母符号<br>• 数字：0-9 (不可以出现在首字符)<br>• 下划线：_ （可以单用）</li><li>注意事项<br>• 在赋值时，变量即被创建，变量的值和类<br>型在赋值的时候被确定。<br>• 不需要声明（declaration）<br>• 变量名大小写敏感：A, a是不同的变量<br>• 变量可以被重新赋值<h5 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h5></li><li>数值类型<br>• 整数 Integers: 12 0 -12987 0123 0X1A2 10294L<br>   大致相当于C语言的 ‘int’ 或 ‘long’<br>   范围可以非常大（大致无限）<br>   八进制数以“0” 开始 (0981 是非法的!)<br>   十六进制以0X开始<br>• 浮点数Floating point: 12.03 1E1 -1.54E-21<br>   相当于C语言的double<br>• 复数Complex numbers: 1+3J<pre><code>语言原生支持</code></pre></li></ul><p><strong>运算注意事项：</strong><br>• 操作符和C语言类似，例如 +, -, /, <em>, %<br>• 幂操作：**</em><br>• 优先级和括号的作用相似</p><ul><li>逻辑类型<br>• 预定义值：True False<br>• 数值 0 认为是假，其他值认为是真<br>• 操作符：not, and, or</li></ul><p><strong>运算注意事项：</strong><br>• 比较运算获得逻辑值，运算符: &lt;, &lt;=, &gt;, &gt;=,<br>==, !=</p><ul><li><p>字符串类型<br>• 使用函数str, int, float等类型名进行转换</p><pre><code>b=int(a)c=flaot(a)d=str(a)</code></pre><p>• 字符串的拼接和整数乘法</p><pre><code>a="hello"+"world"b="hello"*2</code></pre><h5 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h5></li><li><p>代码缩进<br>• Python语 语 言 的 行 前 空 白 是 有 语 法 意 义 的<br>• 在源文件中，应该统一采取一种缩进格式<br>缩进进4个空格 （ 推 荐 标 准 ）<br>缩进2个空格<br>缩进1制表符（tab）<br>上述缩进不可以混用<br>• 连续处于相同缩进层次的语句构成一个语句块（Block）</p></li><li><p>条件语句</p><pre><code>if 条件：elif 条件：else:</code></pre></li><li><p>循环语句(for)<br>• 循环语句for<br>• range(n)表明从0开始，到n-1（含）。</p><pre><code>s = 0for i in range(10): # 0,1,...9  s += iprint(s)</code></pre></li><li><p>循环语句(while)</p><pre><code>s = 0i = 0while s&lt;10:  s += i  i += 1print(s)</code></pre></li><li><p>导入语句<br>三种写法：</p><pre><code>from math import *# use pi, cos, sin, ...from math import cos, sin# only use cos, sinimport math# use math.cos, math.sin, ...</code></pre></li><li><p>定义函数<br>• 用def定义函数，可以有参数和返回值</p><pre><code>def double(x):  return x * 2</code></pre><h5 id="turtle库详解"><a href="#turtle库详解" class="headerlink" title="turtle库详解"></a>turtle库详解</h5><p><a href="https://www.jianshu.com/p/29f5c970fa80" target="_blank" rel="noopener">python：turtle库详解</a></p><h3 id="python类型"><a href="#python类型" class="headerlink" title="python类型"></a>python类型</h3><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><p>• 标量类型<br>—— 逻辑类型(bool)<br>—— 整数(int)、浮点数(float)、复数(complex)<br>—— 空 类型 型(None)<br>• 集合类型<br>—— 字符串(str)<br>—— 列表(list)<br>—— 字典(dict)<br>—— 元组(tuple)<br>—— 集合(set)<br>• 自定义类型<br>—— 类 class</p><h5 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h5><p>• 除法有两种：/, // 后者是整除<br>—— 7/3 = 2.3333333333333335<br>—— 7//3 = 2<br>—— 7.0 // 3.0 = 2.0<br>• 幂运算允许实数<br>—— 7 ** 2 = 49<br>—— 7 ** 0.5 = 2.6457513110645907<br>• 不同类型的数值运算就高不就低<br>—— int —— float —— complex</p><h5 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h5><p>• 表达式</p><pre><code>x if c else y </code></pre><p>相当于</p><pre><code>c? x : y</code></pre><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>• 字符串的进阶操作</p><pre><code>'p' in s </code></pre><p>• 下标以0为开始</p><pre><code>s[0] # index: offset 0s[2:6] # slice: part of strings[:6] s[6:]</code></pre><p>• 逆序的下标</p><pre><code>s[-1]s[-3:-1]s[1:-1]s[-3:]</code></pre><p>• 步长：begin:end:step</p><pre><code>s[::2]s[1::3]s[5:1::-1]"live"[::-1]</code></pre><h5 id="不可修改类型-Immutable"><a href="#不可修改类型-Immutable" class="headerlink" title="不可修改类型 Immutable"></a>不可修改类型 Immutable</h5><p>• 数值类型、字符串类型是不可修改类型<br>—— 后续讲解的元组（tuple）类型也是不可修改类型<br>• 它们的值是常数，不可以修改<br>—— 我们并不能把“1”修改为“2”，把“abc”改为“def”；<br>—— 作为值，它的含义是确定的、不变的。<br>• 赋值语句（Assignment）是给这些常数的值赋予不同的名称</p><h5 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h5><pre><code>s = 'I love Python's.count('on') # 查找子串出现次数s.find('ove') # 查找子串首见位置s.replace('Python', 'C++') # 替换three = '3'three.isdigit() # 是否为数字字符?</code></pre><h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5></li><li><p>相关事项<br>• 表（或称为列表，广义表）是python最重要<br>和常用的容器类<br>• 由一系列有序排列的对象构成（Ordered<br>collection of objects）~ C语言的数组<br>• 异构（Heterogenous），一个列表可以包含<br>多种类型的对象。</p><pre><code>r = [1, 2.0, 3, 5] # list的字面构造r[1] # 正数下标自首部计数，首部为0r[-1] # 负数下标自尾部计数，尾部为-1r[1:3] # 前闭后开区间w = r + [10, 19] # 连接t = [0.0] * 10 # 重复len(r)</code></pre></li><li><p>列表操作</p><pre><code>r = [[9, 8], 2.0, 3, 'word']r[0:3] = [1, 2, 5, 6] # 修改片段r[1:3] = [] # 删除元素r[1:1] = [ 'new' ] # 赋值语句左右侧都是片段；等价于插入[1, 'new', 6, 'word']r[len(r):] = [ 'last' ] # 在尾部插入[1, 'new', 6, 'word', 'last']</code></pre></li><li><p>列表的方法</p><pre><code>r.insert(0, 'f') # 在0位置增加新元素'f'del r[0]r.append(9) # 尾部增加元素r.sort() # in-place 排序r.reverse() # 逆序</code></pre></li><li><p>判断两个变量是否指向同一对象<br>• 利用id函数，返回对象的唯一标志<br>• id(x) == id(y) 表明x和y实际上是同一对象<br>• x is y</p></li><li><p>列表推导</p><pre><code>[i for i in range(9)][i*2 for i in range(9)][i for i in range(100) if '4' not in str(i)]</code></pre><p>• 补充<br>—— Python 一行语句过长，可以用 \ 续行<br>—— 若在括号（花方圆均可）内可以自由换行</p><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5></li><li><p>基本事项<br>• 字典是一种数据组织方式，它根据 key获得对应的value<br>• key称为键，key是无序的，或者说不关注其顺序。<br>• value称为值，可以是任意的对象。<br>• 字典也称为映射(mapping)、哈希(hash)表、查找表(lookup table)等。</p></li><li><p>字典操作</p><pre><code>g = {'Tom': 'boy', 'Mary': 'girl'}g['Tom'] # 以key为索引g.has_key('Mary')g['Jack'] = 'boy' # 增加键值对del g['Tom'] # 删除键，删除键到值的绑定h = {'Tom': 12, 'Mary': 'good'}'Per' in h # 在键的集合中检测h.get('Per', 'unknown') # 如果查找失败则返回缺省值h.keys() # 由键组成的列表，顺序不确定h.values() # 由值组成的列表，顺序不确定h.items() # 顺序同上len(h) # 键的数量</code></pre><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5></li><li><p>注意事项<br>• 与list相同，但不可改变（immutable）<br>• 一旦创建，不可修改。（Once created, can’t be changed.）</p><pre><code>t = (1, 3, 2)t[1] # 3(a, b, c) = t # 元组赋值a, b, c # (1, 3, 2)</code></pre><h5 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h5></li><li><p>注意事项<br>• 数学中的集合，无序，不重复（set）<br>• 去重的时候很有用</p><pre><code>s = set()s = {1, 2, 3}s.add(4) # {1,2,3,4}s.add(1) # {1,2,3,4}t = {1,2}# &amp;交集，|并集 - 差集s - t # {3,4}</code></pre><h5 id="容器间转换"><a href="#容器间转换" class="headerlink" title="容器间转换"></a>容器间转换</h5><p>• list, set, dict 作为类型名可以实现转换<br>—— list(“abc”)    = [“a”, “b”, “c”]<br>—— set([1,2,2])     = {1,2}</p><h3 id="Python语句"><a href="#Python语句" class="headerlink" title="Python语句"></a>Python语句</h3><h5 id="pass语句"><a href="#pass语句" class="headerlink" title="pass语句"></a>pass语句</h5><p>• pass是一个（占位）空语句，不做任何事情<br>• 动因<br>—— python利用缩进表达语句块，如果语句块是空的，不写会有错；<br>—— 这种情况下，可以写上pass</p><h5 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h5><p>• for可以遍历任意的容器<br>—— 对词典遍历的是keys()<br>• range(n)是一个内置函数，返回0~n-1的列表<br>• range(start, stop, step)</p><h5 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h5><p>• 跳出最内层的循环<br>• python没有直接跳出外层循环的语法手段<br>—— 通常会借助额外的flag变量<br>—— 异常处理</p><h5 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h5><p>• 它结束当前迭代，并跳到下一次迭代开头。即跳过循环体中余下的语句，但不结束循环。<br>• 可以用等价的if语句描述</p><h5 id="for-while-else语句"><a href="#for-while-else语句" class="headerlink" title="for/while-else语句"></a>for/while-else语句</h5><p>• 只要不是break跳出循环，就执行else语句<br>• 相比C语言减少一个flag变量</p><pre><code>r = [1, 3, 10, 98, -2, 48]for i in r:  if i &lt; 0:      print('input contains negative value!')      breakelse:  print('input is OK')</code></pre><h5 id="exec和eval"><a href="#exec和eval" class="headerlink" title="exec和eval"></a>exec和eval</h5><p>• 动态地编写Python代码，并将其作为语句进<br>行执行或作为表达式进行计算<br>• 函数exec将字符串作为代码执行<br>• eval计算用字符串表示的Python表达式的值，<br>并返回结果。<br>• 如下代码来创建一个Python计算器</p><h5 id="assert断言语句"><a href="#assert断言语句" class="headerlink" title="assert断言语句"></a>assert断言语句</h5><p>• 要求某些条件得到满足，否则将引发异常<br>• 确保程序的参数合理<br>• 对于不合理的情况，明确引发异常</p><h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h5></li><li><p>完整的异常处理</p><pre><code>try:  1 / 0except NameError:  print("Unknown variable")         出现异常时执行。。。else:  print("That went well!")             没有出现异常时执行finally:  print("Cleaning up.")             任何情况下都会执行</code></pre><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>• 函数名：规则与变量名相同<br>• 参数列表：调用函数时传递给它的值<br>—— 可以由零个，一个或者多个参数组成<br>—— 当有多个参数时，各个参数用逗号分隔<br>• 函数体：函数被调用时执行的代码<br>—— 由一个或多个语句组成<br>—— 在执行到末尾或return语句时退出函数<br>—— 返回结果<br>• 函数调用的形式<br>—— 函数名( 参数列表 )<br>• 形式参数（名）：定义函数时，函数名后面圆括号中的变量。形参只在函数内部有效。<br>• 实际参数（值）：调用函数时，函数名后面圆括号中的变量。</p><h5 id="参数能否修改：总结"><a href="#参数能否修改：总结" class="headerlink" title="参数能否修改：总结"></a>参数能否修改：总结</h5><p>• 凡是Immutable类型的参数，传入的对象值不可能修改<br>• 对于Mutable类型的参数：<br>—— 若对形参进行赋值，并不能改变传入对象的值<br>—— 若对形参进行in-place的修改，则该修改也反应在传入的对象上</p><h5 id="关键字参数的缺省值"><a href="#关键字参数的缺省值" class="headerlink" title="关键字参数的缺省值"></a>关键字参数的缺省值</h5><p>• 可以设定一些参数的缺省值（默认值）<br>• 如果调用者没有提供，则使用缺失值</p><pre><code>def hello(name, greeting="Hello"):</code></pre><p>• 允许用户提供任意数量的参数</p><pre><code>def sum_of_all(*values):</code></pre><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5></li><li><p>注意事项<br>• 如果没有局部变量和全局变量同名，可以直接读取全局变量。<br>• 如果有一个局部变量与待访问的全局变量同名，则无法直接访问全局变量，因为它被局部变量遮住了。<br>• 可以使用关键字 global（nonlocal）修饰变量名，表明和全局（外层）变量关联。<br>• Python的函数可以作为返回值</p><h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>• lambda可以用来定义函数</p><pre><code>pow2_a = lambda x: x*xdef pow2_b(x):    return x*x</code></pre><p>两者功能相同</p><h5 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h5><p>• 对于稍微大型的程序，代码量较大，不宜<br>放在一个文件中<br>• 模块可以将代码分散在不同的文件</p><h5 id="主模块"><a href="#主模块" class="headerlink" title="主模块"></a>主模块</h5><pre><code>if __name__ == "__main__":    do_something()</code></pre><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><h5 id="字符的分类"><a href="#字符的分类" class="headerlink" title="字符的分类"></a>字符的分类</h5><p>• 数字 digits 01234567890<br>• 字母 letter<br>大写ABCDEFGHIJKLMNOPQRSTUVWXYZ<br>小写 abcdefghijklmnopqrstuvwxyz<br>• 空白字符：空格，\t\n\r\v<br>• 对应Unicode，上述概念有一定拓展。</p><h5 id="字符串对象方法"><a href="#字符串对象方法" class="headerlink" title="字符串对象方法"></a>字符串对象方法</h5></li><li><p><strong>capitalize()</strong> 字符串首字母大写</p></li><li><p><strong>lower()</strong> 转为小写</p></li><li><p><strong>upper()</strong> 转为大写</p></li><li><p><strong>find(s)/rfind(s)</strong>  正向/逆向查找子串s的出现位置</p></li><li><p><strong>count(s)</strong>  查找s出现的次数</p></li><li><p><strong>strip()</strong>  移除开始和结束的空白</p></li><li><p><strong>lstrip()/rstrip()</strong>移除开始/结束的空白</p></li><li><p><strong>replace(s, r)</strong> 将子串s替换为r（缺省为全替换，可以仅替换指定次数）</p></li><li><p><strong>isalpha()/isdigit()</strong> 是否是字母、数字等……</p></li><li><p><strong>isupper()/Islower()</strong> 是否大写小写等….</p></li><li><p><strong>startswith(s)/endswith(s)</strong> 是否以s作为字符串的开始或结尾</p></li><li><p><strong>s.split(sep)</strong> 将字符串sep作为分隔符，对字符串s进行分解，返回列表</p></li><li><p><strong>sep.join(parts)</strong>  将各部分用分隔符sep连接在一起</p></li></ul><h5 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h5><p>• 字符串的格式化有三种方法<br>• %, format, f-string</p><ul><li>% 操作符</li></ul><p><strong>用法:</strong> str % parameter_tuple</p><pre><code>"the number is %d" % 30</code></pre><ul><li>%-format</li></ul><p><strong>%c</strong> character<br><strong>%s</strong> string conversion via str() prior to formatting<br><strong>%i</strong>  signed decimal integer<br><strong>%d</strong> signed decimal integer<br><strong>%u</strong> unsigned decimal integer<br><strong>%o</strong> octal integer<br><strong>%x</strong> hexadecimal integer (lowercase letters)<br><strong>%X</strong> hexadecimal integer (UPPERcase letters)<br><strong>%e</strong> exponential notation (with lowercase ‘e’)<br><strong>%E</strong> exponential notation (with UPPERcase ‘E’)<br><strong>%f</strong> floating point real number<br><strong>%g</strong> the shorter of %f and %e<br><strong>%G</strong> the shorter of %f and %E<br><strong>*</strong> argument specifies width or precision<br><strong>-</strong>  left justification<br><strong>+</strong> display the sign<br><strong><sp></sp></strong> leave a blank space before a positive number<br><strong>#</strong> add the octal leading zero ( ‘0’ ) or hexadecimal leading ‘0x’or ‘0X’, depending on whether ‘x’ or ‘X’ were used.<br><strong>0</strong> pad from left with zeros (instead of spaces)<br><strong>%</strong> ‘%%’ leaves you with a single literal ‘%’<br><strong>(var)</strong> mapping variable (dictionary arguments)<br><strong>m.n.</strong> m is the minimum total width and n is the number of digitsto display after the decimal point (if appl.)</p><pre><code>name = "John"age = 23print("%s is %d years old." % (name, age))</code></pre><ul><li>str.format方法<br>• 原先的用法：’%s %s’ % (‘one’, ‘two’)<br>• 目前的用法：’{} {}’.format(‘one’, ‘two’)<pre><code>"{0} {1}, you may have won ${2}" .format("Mr.", "Smith",10000)'int, {0:5}, in a field of width 5'.format(7)' {0:10.5f}, fixed at 5 decimal places.'.format(3.1415926)</code></pre></li><li>f-string<pre><code>name = "Eric"age = 24f"Hello, {name}. You are {age}."</code></pre>f-string是python3版本的新语法，是一种表达式。</li><li>split-join<br>• split用于将长字符串进行分解<br>• join用于合并短字符串<br>• 常见的分隔符号有：\t , ; . - /<pre><code>"www.ustb.edu.cn".split(".")[ int(i) for i in "166.111.4.80".split(".") ]".".join([ f"{i}" for i in [166, 111, 4, 80] ])</code></pre><h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5></li><li>通配符：匹配任意字符</li><li>字符组（类）<br>• 字符类 [] 用于匹配一组字符<br>• 可以用 [^] 表达不匹配组里面的任意字符<br>• Ranges 可以表示一个范围的字符<br>—— [1-9] 即 [123456789]<br>—— [abcde] 即 [a-e]<br>—— [abcde123456789] 即 [a-e1-9]</li><li>预定义的字符组</li></ul><p><strong>\d</strong>  数字 [0-9]<br><strong>\D</strong> 非数字 [^0-9]<br><strong>\s</strong> 空白字符 [ \f\n\r\t\v]<br><strong>\S</strong> 非空白字符 [^ \f\n\r\t\v]<br><strong>\w</strong> 字母数字下划线 [A-Za-z0-9_]<br><strong>\W</strong> 非字母数字下划线 [^A-Za-z0-9_]</p><ul><li>锚 Anchors<br>• ^ 即行首 beginning of the line，在多行模式下匹配每行的开始位置<br>• $ 即行尾 means end of the line，在多行模式下匹配每行的结束位置<br>• \A 仅行首<br>• \Z 仅行尾<br>• \b 匹配单词的边界<br>—— 从字母数字到非字母数字的过渡边界，\w\W 或 \W\w</li><li>重复指示Repetions<br>• 三种 * + ?<br>• * 指示其前置内容0<del>+inf次出现，也就是<br>任意多次<br>• + 1</del>+inf<br>• ? 0~1</li><li>重复数量的范围指示<br>• 可以用 {n,m} 指示范围<br>—— {n,m} 表示n~m次<br>—— {n} 表示恰好n次 exactly n occurrences<br>—— {n,} 表示至少n次 at least n occurrences<br>• 示例:<br>—— .{0,} 等价于 .*<br>—— a{2,} 等价于 aaa*</li><li>子表达式<br>• 重复指示仅修饰其前面的一个符号，如果<br>想表示多个符号，需要对正则表达式进行<br>分组，用 （）进行划分，称为子表达式<br>• 子表达式作为一个整体被修饰<br>—— a* 匹配a的0次货多次出现<br>—— abc* 匹配 ab, abc, abcc, abccc, …<br>—— (abc)* 匹配 abc, abcabc, abcabcabc, …<br>—— (abc){2,3} 匹配 abcabc or abcabcabc</li><li>或<br>• 符号 | 表示匹配该符号前面的或后面的子表达式<br>—— (T|Fl)an 匹配 Tan or Flan<br>—— ^(From|Subject): 匹配邮件头部<br>• 优先级最低，可以用 （） 改变<br>•  示例：<br>—— At(ten|nine)tion 匹配Attention or Atninetion<br>—— 不能匹配Atten or ninetion 除非未加括号即Atten|ninetion</li><li>转义<br>• 很多字符（如“.”）在正则表达式中有特殊含义，如果只代表它原本的字面意义就需要转义，例如“.”仅匹配句点本身。<br>—— 目标仅匹配单个句点： .<br>—— 在正则表达式层面需要看到： .<br>—— 在字符串书写时需要写： “\.”<br>• 匹配反斜线<br>—— 目标仅匹配单个反斜线： <br>—— 在正则表达式层面需要看到： \<br>—— 在字符串书写时需要写： “\\“<br>• 匹配数字\d<br>—— 在正则表达式层面需要看到： \d<br>—— 在字符串书写时需要写： “\d”</li></ul><p>• 匹配国内电话号码：\d{3}‐\d{8}|\d{4}‐\d{7}<br>—— 如 0511-4405222 或 021-87888822<br>• 腾讯QQ号：[1‐9][0‐9]{4,}<br>—— 腾讯QQ号从10000开始<br>• 中国邮政编码：[1‐9]\d{5}(?!\d)<br>—— 中国邮政编码为6位数字<br>• 匹配身份证：\d{15}|\d{18}<br>—— 中国的身份证为15位或18位<br>• 匹配ip地址：\d+.\d+.\d+.\d+<br>—— 提取ip地址时有用</p><ul><li><p>子表达式的引用<br>• \n  此处n是一个数字，表示第n个子表达式的值。子表达式的序号按左括号计数。<br>• 例如：<br>—— (.+) \1 匹配 55 55，或者the the<br>• 可以给子表达式予以命名<br>• (?P<name>…)<br>• (?P=name)</name></p><h5 id="Python的正则表达式模块"><a href="#Python的正则表达式模块" class="headerlink" title="Python的正则表达式模块"></a>Python的正则表达式模块</h5><p>• 模块导入 <strong>import re</strong><br>• 匹配：re.match() 查找字符串的开始部分是否匹配，不向后查找（类似字符串startswith）<br>• 查找：re.search() 查找是否存在匹配（类似字符串find）<br>• 替换：re.sub() 替换正则表达式（类似字符串replace）</p></li><li><p>match的用例</p><pre><code>s = "2019‐03‐20 is a rainy day"pat = "\\d‐\\d‐\\d"m = re.match(pat, s)m.start()m.end()m.group()  #返回匹配对象(Match)，有start, end, group方法</code></pre></li><li><p>search的用例</p><pre><code>s = "It is reported that 2019‐03‐20 is a rainyday."pat = "\\d‐\\d‐\\d"m = re.search(pat, s)m.start()m.end()m.group() </code></pre></li><li><p>多次查找findall/finditer</p><pre><code>s = """You smiled and talked to me of nothing and I felt that for this I had been waiting long."re.findall("\\b(\\w+ed)\\b", s)re.finditer(...) # 类似，但返回一个个Match对象</code></pre></li><li><p>替换sub<br>• 04/30/2018 转换为 2018-04-30<br>• 利用re.sub</p><pre><code>import reprint re.sub("([0‐9]{2})/([0‐9]{2})/([0‐9]{4})","\\3‐\\1‐\\2","This is a test 01/30/2019.")</code></pre><h5 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h5></li><li><p>基础概念<br>• 文件包括两种类型：文本文件和二进制文件<br>• 二进制文件：直接由比特0和比特1组成，没有统一字符编码，文件内部数据的组织格式与文件用途有关。<br>• 文本文件：以ASCII码方式存储的文件。<br>• 二进制文件和文本文件区别：仅编码（人为的理解）存在差异。<br>• 文件包括两种类型：文本文件和二进制文件<br>• 二进制文件：直接由比特0和比特1组成，没有统一字符编码，文件内部数据的组织格式与文件用途有关。<br>• 文本文件：以ASCII码方式存储的文件。<br>• 二进制文件和文本文件区别：仅编码（人为的理解）存在差异。</p></li><li><p>文件操作<br>• 打开文件 open<br>—— 建立磁盘上的文件与程序中的对象相关联<br>—— 通过相关的文件对象获得<br>• 文件操作<br>—— 读取<br>—— 写入<br>—— 定位<br>—— 其它：追加、计算等<br>• 关闭文件 close<br>—— 切断文件与程序的联系<br>—— 写入磁盘，并释放文件缓冲区</p></li><li><p>文件打开操作<br>• 打开文件<br>—— Python使用open()函数打开文件并返回文件对象：</p><pre><code>&lt;变量名&gt;=open(file, mode = 'r')</code></pre><p>—— open函数有两个参数：文件名和打开模式。文件名可以是包含完整路径的名字，或当前路径下的文件名。<br>—— 第二个参数制定文件打开模式。<br>• open()函数提供7种基本的打开模式</p></li></ul><p><strong>‘r’</strong>  以只读方式打开文件（默认）如果文件不存在，返回异常FileNotFoundError。<br><strong>‘w’</strong> 以写入的方式打开文件，文件不存在则创建，会覆盖已<br>存在的文件。<br><strong>‘x’</strong> 打开一个新文件来写数据。文件不存在则创建，如果数<br>据已经存在则返回异常FileExistsError。<br><strong>‘a’</strong> 以写入模式打开，文件不存在则创建，如果文件存在，<br>则在末尾追加写入。<br><strong>‘b’</strong> 以 二进制模式打开文件。<br><strong>‘t’</strong> 以 文本模式打开 （默认）。<br><strong>‘+’</strong> 可读写模式（可添加到其它模式中使用）。<br>• 模式的组合使用<br>—— ‘r’,’w’,’x’,’a’可以和’b’,’t’,’+’组合使用，形成既表达读写又表达文件模式的方式。<br><strong>例如：</strong><br>——‘wb’表示“写二进制数据”<br>——‘x+b’表示读写一个新的二进制文件</p><ul><li>文件的读写操作<br>• 文件的读写：根据打开方式不同可以对文件进行相应的读写操作，Python提供4个常用的文件内容读取方法。</li></ul><p><strong><file>.readall()</file></strong> 读入整个文件内容，返回一个字符串或字节流。<br><strong><file>.read(size=‐1)</file></strong> 从文件读取size个字符，当未给定size或给定负值的时候，读取剩余的所有字符，文件指针指向文件末尾。<br><strong><file>.readline(size=‐1)</file></strong> 从文件中读入一行内容，如果给出参数，读入该行前size长度的字符串或字节流。<br><strong><file>.readline(hint=‐1)</file></strong>从文件中读入所有行，以每行为元素形成一个列表，如果给出参数，读入hint行。<br>• Python提供3个与文件内容写入有关的方法。<br><strong><file>.write(str)</file></strong> 将字符串str写入文件。<br><strong><file>.writelines(lines)</file></strong>将一个元素为字符串的列表写入文件。<br><strong><file>.seek(offset,from)</file></strong>改变当前文件操作指针的位置，从from(0代表文件起始位置，1代表当前位置，2代表文件末尾）偏移offset个字节。</p><ul><li>文件操作示例<br>• 文本文件逐行打印输出<pre><code>fo = open(fname ,"rt")for line in fo.readlines():  print(line)fo.close()</code></pre></li><li>文件操作示例<pre><code>f1 = open(f1name, "rt")f2 = open(f1name, "wt")f2.write(f1.read().upper())f1.close()f2.close()</code></pre></li><li>with语句<br>• 容易忘记关闭(close)文件<pre><code>f = open('todos.txt')for chore in f  print(chore, end='')tasks.close()#使用with语句重写这个代码with open('todos.txt') as f:for chore in f:  print(chore, end='')</code></pre>• with确保即使发生异常，也可以正确的关闭文件</li><li>编码的文件<br>• 若打开有编码的文件，需要用codecs模块<br>• import codecs<pre><code>f1 = codecs.open(fname, "r", "utf‐8")f2 = codecs.open(fname, "w", "gb2312")</code></pre></li><li>词频统计<pre><code>f = open("alice.txt", "rt")all = f.read()f.close()count_word = {}for w in all.split():  w_lowercase = w.lower()  count_word[w_lowercase] = \                                      count_word.get(w_lowercase, 0) + 1result = [(v, k) for k, v in count_word.items()]result.sort()top10 = result[‐10:]for v,k in top10[::‐1]:  print(f"Word {k}, occurs {v} times")</code></pre><h5 id="汉字的处理"><a href="#汉字的处理" class="headerlink" title="汉字的处理"></a>汉字的处理</h5></li><li>导入库<br>• pip install regex<br>• import regex as re<br>• \p{han} 匹配汉字</li><li>汉字分词<br>• jieba是Python中一个重要的第三方中文分词函数库。<br>• 第三方库，需要安装</li></ul><p><strong>jieba.cut(s)</strong> 精确模式，返回一个可迭代的数据类型<br><strong>jieba.cut(s,cut all=True)</strong> 全模式，输出文本s中所有可能单词<br><strong>jieba.cut_for_search(s)</strong> 搜索引擎模式，适合搜索引擎建立索引的分词结果<br><strong>jieba.lcut(s)</strong> 精确模式，返回一个列表类型，建议使用<br><strong>jieba.lcut(s,cut all=True)</strong> 全模式，返回一个列表类型，建议使用<br><strong>jieba.lcut_for_search(s)</strong> 搜索引擎模式，返回一个列表类型，建议使用<br><strong>jieba.add_word(w)</strong> 向分词词典中增加新词w</p><h3 id="OOP编程"><a href="#OOP编程" class="headerlink" title="OOP编程"></a>OOP编程</h3><h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>• 类是类型概念的发展。<br>—— 对象是广义的“数据值”。<br>—— 对象所属的数据类型就是“类”。<br>—— 用于描述复杂数据的静态和动态行为。<br>• 类（class）：描述相似对象的共性。包括<br>—— 数据<br>—— 操作：方法（method）<br>• 对象是类的实例（instance）<br>—— 创建对象<br>• 类的封装:数据和操作结合成一个程序单元,对外部隐藏内部实现细节。<br>—— 不允许用户直接操作类中被隐藏的信息。<br>—— 用户也无需了解隐藏的信息就能使用该类。<br>• 类对外公开方法名称和调用格式,即界面。<br>—— 外界向对象发消息。(方法名及参数)<br>—— 对象响应消息,执行相应方法。<br>—— 外界只能按对象允许的方式来处理对象数据。<br>• 封装的好处<br>—— 安全:对象自己的方法处理自己的数据<br>—— 易用:使用者无需了解内部实现细节<br>—— 易维护:实现者修改内部实现不会影响使用者<br>—— 标准化:同类甚至不同类的对象对使用者都呈现同样的操作界面<br>• 方法定义同函数定义</p><pre><code>def &lt;methodname&gt;(self, other params):</code></pre><p>—— 方法是依附于类的函数,普通函数则是独立的。<br>—— 方法的第一个参数是专用的，习惯用名字self。<br>—— 大体上等价于C++的this<br>—— 只能通过向对象发消息来调用方法。<br>• 对象是数据和操作的结合。<br>—— 方法对应于操作<br>—— 对象的数据以实例变量形式定义。<br>—— 实例变量：self.varname<br>—— 对象变量和所指向的数据本质上是一个词典<br>—— self.varname  即 self[“varname”]<br>—— 实例变量的赋值主要出现在<strong>init</strong>()方法中。</p><ul><li>类的定义实例<pre><code>class Circle:""" Class definition for a circle """def __init__(self, radius):  self.radius = radiusdef getRadius(self):  return self.radiusdef getArea(self):" Obtain the area of a circle"  return math.pi*self.radius**2</code></pre></li><li>创建实例<br>• 实例创建<br>&lt; 变量&gt; = &lt; 类名&gt; （&lt; 实参&gt; ）<br>这里&lt;类名&gt;相当于一个函数，称为构造器，用来构造实例。<br>• 成员访问<br>• 方法调用<br>—— 类似函数调用,但需指明实例(对象)<br>—— &lt; 实例&gt;.&lt; 方法名&gt;(&lt; 实参&gt;)<br>—— &lt;实例&gt;就是与形参self对应的实参<br>• 数据成员访问<br>—— &lt; 实例&gt;.&lt; 数据成员名&gt;<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5>• 在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class） 。<br>• 继承是面向对象的重要特征之一，继承是两个类或者多个类之间的父子关系，子类继承了父类的所有实例变量和方法。<br>• 继承实现了代码的重用。重用已经存在的数据和行为，减少代码的重新编写。<br>• Python在类名后用一对圆括号表示继承关系，括号中的类表示父类。<pre><code>class 类名（被继承的类）：</code></pre></li><li>实例和类的关系判定<br>• isinstance(s, t)函数判定s是否t类型（及其子类型）<br>—— isinstance(c, Circle)<br>—— isinstance(c, DrawableCircle)<br>• 继承关系：is-a  （注：相当于c++的公有继承）<br>• DrawableCircle is a Circle<br>• 一个实例属于某个子类，则也属于父类，反之则不行。<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5>• 当对一个对象调用draw()函数时，它会根据自己的对象类型执行不同的draw方法<br>—— FilledDrawableCircle.draw()<br>—— DrawableCircle.draw()<br>• 对于相同的方法，会有不同的实现版本，这就是多态（Polymorphism）<h3 id="科学计算与可视化"><a href="#科学计算与可视化" class="headerlink" title="科学计算与可视化"></a>科学计算与可视化</h3><h5 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h5>• NumPy（Numeric Python）是Python语言的一个扩展包。<br>• 由多维数组对象和数组计算函数共同组成的库，支持多维数组、矩阵运算以及大量数值计算功能。</li><li>Numpy产生动机<br>• 标准的Python中用列表(list)保存一组值，可以作为数组使用。<br>• Python列表的元素可以是任何对象，因此对象需要额外的信息保存其类型等信息，Python本身是解释型语言。因此，对数值运算来说，效率较低。<br>—— 1000*1000的矩阵乘法，基于python实现三层循环超过10分钟。<br>—— Numpy 大约0.03秒。<br>• 计算效率直接影响了科学计算、机器学习的可用性。<br>• Python的列表不支持数值计算语义<br>• 能否实现矢量、矩阵的加法？乘法？逆？<br>• 因此，需要原生支持数值计算语义的，高效率的Python库<br>• NumPy的诞生弥补了这些不足<br>• NumPy提供了两种基本的对象<br>—— ndarray（ndimensional array object ）<br>—— ufunc（ universal function object）<br>• ndarray(数组)是存储单一数据类型的多维数组。<br>• ufunc 是对数组进行处理的函数。<pre><code>• 安装：pip install numpy• 导入：import numpy as np</code></pre></li><li>Numpy的优势<br>• NumPy 通 常 与 SciPy(Scientific Python)和Matplotlib(绘图库)一起使用，这种组合广泛用于替代Matlab，已成为流行的技术方案。<br>• Python：通用语言<br>• Matlab：专用语言<br>• NumPy是开源的（Open-Source）</li><li>Numpy做什么<br>• 矢量、矩阵和高维数组（张量）的数值运<br>算和逻辑运算<br>• 线性代数相关的操作<br>• 随机数生成<br>• 傅立叶变换<br>• 图形操作<br>• 其他功能</li><li>量<br>• 矢量 Vectors<br>• 矩阵 Matrices<br>• 图像 Images<br>• 张量 Tensors</li><li>Ndarray<br>• ndarray：N维数组类型<br>• 描述相同类型的元素集合<br>• 使用基于零的索引访集合中的项目<br>• ndarray中的每个元素类型（dtype）相同，占用的内存大小也相同。</li><li>Ndarray的创建<br>• numpy.array(object, dtype = None, order =None)<br>• object通常是一个容器或迭代器，根据其内容生成一个ndarray对象实例<br>• dtype如果不指定，自动从实际数据中推断<br>• order和内存中数据排列有关</li><li>dtype<br>• int8, int16, int32, int64<br>• uint8, uint16, uint32, uint64<br>• float16, float32, float64<br>• complex64, complex128</li><li>数组属性<br>• 数组的维度：ndim<br>• 数组的形状：shape<pre><code>import numpy as npx = np.array([1, 2, 3])y = np.array([4.0, 5, 6])print(x.dtype, x.shape, x.ndim)print(y.dtype, y.shape, y.ndim)z = x + yprint(z)</code></pre></li><li>数组创建<br>• 数组创建的其他方法<br>—— numpy.empty：空，不初始化值，值可能任意<br>—— numpy.zeros：0<br>—— numpy.ones：1<br>—— numpy.arange：start, stop, step 可以为浮点数，但是不推荐用在浮点数场合。<br>—— numpy.linspace：start, stop, number 实现均匀划分（默认含右侧端点），推荐在浮点数场合使用。<pre><code>array = np.array([[0,1,2],[2,3,4]])# [[0 1 2]#  [2 3 4]]array = np.zeros((2,3))# [[0. 0. 0.]# [0. 0. 0.]]array = np.ones((2,3))# [[1. 1. 1.]# [1. 1. 1.]]</code></pre>• eye 单位矩阵<br>• 浮点数优先用linspace，避免累计误差<br>• np.random 类似于random<pre><code>array = np.eye(3)# [[1. 0. 0.]# [0. 1. 0.]# [0. 0. 1.]]array = np.arange(0, 10, 2)# [0, 2, 4, 6, 8]array = np.linspace(0, 1, 11)# [0. , 0.1, 0.2, 0.3,…, 0.7, 0.8, 0.9, 1. ]array = np.random.randint(0, 10, (3,3))# [[6 4 3]# [1 5 6]# [9 8 5]])</code></pre></li><li>索引和切片(slice)<br>• 一维数组的索引和切片大体与list相同<pre><code>a = np.arange(9)a[0]# 0a[3:7]# array([3, 4, 5, 6])a[:7:2]# array([0, 2, 4, 6])a[::‐1]#array([8, 7, 6, 5, 4, 3, 2, 1, 0])</code></pre>• 多维数组：每一个维度都可以进行索引或切片，<br>返回一个标量或多维的子数组（view）。<br>• 对此子数组的修改可能会反应在原数据上！<pre><code>b = np.array([[0,1,2],[3,4,5]])#[[0 1 2]#  [2 3 4]]b[0,1]# 1b[1,:]#[3,4,5]b[:,2]#[2,5]</code></pre></li><li>数组的运算<br>• shape相同的多维数组，支持+ ‐ * / % &lt; &gt; == &gt;= &lt;= 等运算，对应的元素逐个进行运算，返回具有相同shape的多维数组<br>• 单目运算作用在数组上，对每个元素逐个实施，包括负号 ‐ 以及单自变量函数 sin,cos 等<br>• 上述运算是element-wise意义上的<pre><code>arr = np.array([[1., 2., 3.], [4., 5., 6.]])print(arr)[[1. 2. 3.][4. 5. 6.]]print(arr * arr)[[ 1. 4. 9.][16. 25. 36.]]print(arr ‐ arr)[[0. 0. 0.][0. 0. 0.]]</code></pre></li><li>数组的运算：广播<br>• shape不相同的数组如何运算？<br>• 一般意义的逐元素的运算不可实现。<br>• 但可以通过广播实现，小的数组被广播为大的数组，从而使得两个数组兼容。<br>• 在下列规则满足时可以广播：<br>—— 维数小的数组，在它的shape前面补“1”<br>—— 在某个维度两个数组大小或者相同或者有一个是“1”<br>—— 如果在某个维度是“1”，则需要任何下标[*]时，用[0]元素代替（相当于复制为很多份）<br>• 等价地说，广播运算在下列情况之一成立时可以执行<br>—— 具有相同的shape<br>—— 具有相同的维度，shape每一维的值或者相同或者有一方为1<br>—— 具有不同的维度，但是维数少的在前面补齐“1”后符合上述条件</li><li>逻辑型数组索引<br>• 逻辑型数组可以作为索引<br>—— 如比较运算的结果为一个逻辑型数组<br>• 掩码（Mask），表示仅取索引True的元素，构成一个子数组。<pre><code>x = np.arange(10)mod5 = x % 1 == 1x [ mod5 ] # [1, 6]x [ x &gt; 5 ] ?</code></pre>• 整数型数组（或list）可以作为索引<br>• 逐个取出每个整数对应下标的元素，得到ndarray数组的子集<pre><code>x = np.arange(10)*10# array([ 0, 10, 20, 30, 40,50, 60, 70, 80, 90])x[[1,3]]# array([ 10, 30])x[[5,3,7]]# array([ 50, 30, 70])</code></pre></li><li>view和copy<br>• 为了提高效率、节约空间，有些numpy操作返回的是view，对view的修改可以改动原始数组中的数据改动原始数组中的数据。<br>• 具体返回view或copy需要查看函数说明。<br>• 显式的复制可以用copy函数。<br>—— a.copy()<br>—— np.copy(a)</li><li>数组的拼接<br>• np.concatenate([a1, a2, …],axis=0, out=None)<br>• 参数说明：<br>—— a1, a2, … : 一系列的ndarray，必需是相同的shape，除非在第axis维可以存在差异。<br>—— axis : int, 缺省为0<br>• 按照第axis维把上述数组拼接在一起<pre><code>A = np.ones((4,1))array([[1.],[1.],[1.],[1.]]B = np.zeros((4,2))array([[0., 0.],[0., 0.],[0., 0.],[0., 0.]])C = np.concatenate([A, B], axis=1)array([[1., 0., 0.],[1., 0., 0.],[1., 0., 0.],[1., 0., 0.]])</code></pre></li><li>数组的创建<br>• np.zeros_like<br>• np.ones_like<br>• np.empty_like<br>• 参数是另一个数组，按照其形状创建一个0/1/空的数组</li><li>reshape<br>• 在保持总元素的数目不变的条件下，数组的形状可以更改<br>• 默认的order是row-major<pre><code>a = np.array([1,2,3,4,5,6])a = a.reshape(3,2)"""array([[1, 2],[3, 4],[5, 6]])"""a = a.reshape(2,‐1)</code></pre></li><li>平坦化<br>• .ravel()<br>• .flat<pre><code>x = np.array([[1, 2, 3], [4, 5, 6]])print(np.ravel(x))[1 2 3 4 5 6]for i in x.flat: #属性，不需要加()，返回iterator  print(i)</code></pre></li><li>转置<br>• .transpose 交换两个轴 axes<br>• .T 相当于transposes前两个轴<pre><code>x = np.arange(4).reshape((2,2))"""array([[0, 1],[2, 3]])"""np.transpose(x) # x.transpose((1,0)), or x.T"""array([[0, 2],[1, 3]])"""</code></pre></li><li>数组的IO<br>• 可以存储为NPY/NPZ文件<br>• 可以同时存储多个数组<br>• save存储为非压缩格式<br>• savez存储压缩格式<pre><code>np.savez('data.npz', a=a)data = np.load('data.npz')a = data['a'] # data是一个词典</code></pre>• 读入文本文件<br>• 可以指定注释、分隔符、编码等<pre><code>from io import StringIO# 用字符串模拟一个file对象c = StringIO("0 1\n2 3")np.loadtxt(c)array([[ 0., 1.],[ 2., 3.]])</code></pre>• 读入图像文件<pre><code>from scipy.misc import imreadim = imread("lenna.png")print(im.shape, im.dtype)# (330, 330, 3) uint8im_grey = im[:,:,0]*0.299 + im[:,:,1]*0.587 + im[:,:,2]*0.114import matplotlib.pyplot as pltplt.imshow(im_grey, cmap='gray')plt.show()</code></pre></li><li>ufunc<br>• 除了四则运算，常见的数学函数也作为ufunc提供，可以在数组上操作.<br>• 单次numpy.sin的速度只有math.sin的1/4，但大数组的numpy.sin比math.sin快20多倍。这是因为numpy.sin在C语言级别进行循环计算。</li><li>聚集运算<br>• np.sum(a) 对数组a求和<br>• 其他参数：<br>—— axis=None 在特定的维度上求和，默认为全部<br>求和<br>—— out=None 输出直接存入该参数<br>—— initial=初始值<pre><code>np.sum([[0, 1], [0, 5]])#6np.sum([[0, 1], [0, 5]], axis=0)#array([0, 6])np.sum([[0, 1], [0, 5]], axis=1)#array([1, 5])np.sum([])#0.0</code></pre></li><li>其他聚集操作<br>• all 布尔型：与<br>• any 布尔型：或<br>• max 最大值<br>• min 最小值<br>• mean 均值<br>• std 标准差</li><li>类型转换<br>.astype(T) 转为T类型<pre><code>x = array([[0, 1],[2, 3]])x.astype(np.float32)"""array([[0., 1.],[2., 3.]], dtype=float32)"""</code></pre></li><li>矩阵运算<br>• NumPy对于多维数组的运 算，缺省情况下并不使用矩阵运算（特指 乘除法）。<br>• numpy库提供了matrix类，使用matrix类创建矩阵对象，它们的加减乘除运算缺省采用矩阵方式计算<br>• NumPy中同时存在ndarray和matrix对象，容易混淆，需要注意。</li><li>矩阵运算<br>• 矩阵的乘积可以使用dot函数进行计算。<br>• dot<br>—— 对于两个一维的数组，计算的是这两个数组对<br>应下标元素的乘积和（内积）。<br>—— 对于二维数组，计算的是两个数组的矩阵乘积。<br>—— 对于多维数组，通用计算公式为数组a的最后一维上的所有元素与数组b的倒数第二维上的所有元素的乘积和：<br>• dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])<pre><code>a = np.array([[2, 0], [0, 1]])b = np.array([[4, 1], [2, 2]])c = np.dot(a, b)  """array([[8, 2],[2, 2]])"""</code></pre></li><li>排序<br>• .sort() 对数组进行排序，将改变数组的内容。<br>• .argsort() 返冋数组的排序下标<pre><code>a = np.array([5,3,2,4,1])a.argsort()array([4, 2, 1, 3, 0], dtype=int64)</code></pre></li><li>NumPy模块<br>• numpy.linalg模块<br>—— 包含线性代数的函数。可以计算逆矩阵、求特征值、奇异值分解、解线性方程组以及求解行列式、秩等<br>• numpy.fft模块<br>—— 提供了快速傅里叶变换及其逆变换。<br>• numpy.random 模块<br>—— 支持二项分布、超几何分布、正态分布等</li><li>numpy.linalg<br>• 解方程<br>3 * x0 +  x1 = 9<br>x0 + 2 * x1 = 8<pre><code>a = np.array([[3,1], [1,2]])b = np.array([9,8])x = np.linalg.solve(a, b)xarray([ 2., 3.])np.allclose(np.dot(a, x), b)</code></pre><h5 id="MATPLOTLIB"><a href="#MATPLOTLIB" class="headerlink" title="MATPLOTLIB"></a>MATPLOTLIB</h5>• Python绘图库。<br>• 由 John Hunter (1968-2012) 创建。<br>• 拥有一套和Matlab几乎相同语法的绘图库。<br>• 也拥有另一套面向对象的绘图库。<br>• <a href="http://matplotlib.org/" target="_blank" rel="noopener">http://matplotlib.org/</a> 参考 Example 和 Gallery。</li><li>导入<br>• import matplotlib.pyplot as plt<br>• from matplotlib.pyplot import *<br>• pyplot模块模拟了matlab接口</li><li>入门示例<pre><code>import numpy as npfrom matplotlib.pyplot import *#or: from matplotlib.pylab import * # pylab = pyplot + numpyx = np.linspace(0, 5, 10)y = x ** 2figure()plot(x, y, 'r‐o')xlabel('x')ylabel('y')title('title')show()</code></pre></li><li>Plot<br>• x:如果缺少x则按照(0,1,2,3…)<br>• y<br>• “r‐o”: red, 实线, 圆点<br>—— 类似有 “g‐‐x”  绿色虚线X<br>• plot改为semilogx, semilogy, loglog<br>可以变为对数坐标尺度</li><li>颜色<br>• 单词，如’red’<br>• 字母，如’r’<br>• 6位16进制数，如’#FF0000’或’#ff0000’<br>• 三(RGB)或四(RGBA)元组，如(1, 0, 0)或(1,0,0,1)<br>• 灰度字符串，如’0.8’<pre><code>import numpy as npimport matplotlib.pyplot as plta = b = np.linspace(0, 3, 50)c = np.exp(a)d = c[::‐1]plt.plot(a, c, 'r‐‐', label='Model length')plt.plot(a, d, 'b:', label='Data length')plt.plot(a, c+d, 'k', label='Total message length')legend = plt.legend(loc='upper center', shadow=True)legend.get_frame().set_facecolor('#00FFCC')plt.show()</code></pre></li><li>保存绘图<br>• plt.savefig()<br>—— 文件名是必需参数。<br>—— 示例：plt.savefig(“abc.png”, bbox_inches=’tight’)<br>—— bboxinches=’tight’ 去掉不需要的白边。<br>• plt.show()<br>—— 只在屏幕上显示。</li><li>多个绘图<pre><code>x = np.linspace(0.0, 6.28, 100)y1 = np.cos(x)y2 = np.sin(x)plt.subplot(2, 1, 1)plt.plot(x, y1, 'yo‐')plt.grid(True)plt.subplot(2, 1, 2)plt.plot(x, y2, 'r.‐')plt.xlabel('time (s)')plt.show()</code></pre></li><li>直方图<pre><code>mu, sigma = 100, 15x = mu + sigma * np.random.randn(10000)n, bins, patches = plt.hist(x, 50,normed=1,facecolor='g',alpha=0.75)plt.xlabel('Smarts')plt.ylabel('Probability')plt.title('Histogram of IQ')plt.text(60, .025,r'$\mu=100,\ \sigma=15$')plt.axis([40, 160, 0, 0.03])plt.grid(True)plt.show()</code></pre></li><li>散点图<pre><code>x = np.random.random(50)y = np.random.random(50)c = np.random.random(50)  # color of pointss = 500 * np.random.random(50)  # size of pointsfig, ax = plt.subplots()im = ax.scatter(x, y, c=c, s=s, cmap=plt.cm.jet)# Add a colorbarfig.colorbar(im, ax=ax)# set the color limitsim.set_clim(0.0, 1.0)</code></pre><h3 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h3><h5 id="检查网站地图"><a href="#检查网站地图" class="headerlink" title="检查网站地图"></a>检查网站地图</h5>• Sitemap（网站地图）<br>• 网站提供的Sitemap文件可以帮助爬虫定位网站所有网页的链接；<br>• Sitemap文件提供了爬取网站的有效方式，但该文件经常存在缺失、过期或不完整。<h5 id="检测网站构建技术"><a href="#检测网站构建技术" class="headerlink" title="检测网站构建技术"></a>检测网站构建技术</h5>• 构建网站的技术类型会对爬取产生影响。<br>—— 例如网页是动态生成的还是静态页面。<br>• 安装 builtwith 库，将URL作为参数，该库<br>返回网站使用的技术特征。<br>• pip install builtwith<h5 id="调研网站的所有者"><a href="#调研网站的所有者" class="headerlink" title="调研网站的所有者"></a>调研网站的所有者</h5>• 根据网站的所有者，判定爬虫的下载速度等；<br>• 为了找到网站的所有者，可以使用WHOIS协议查询域名的注册者。<br>• 安装：pip install python-whois<h5 id="下载单个网页"><a href="#下载单个网页" class="headerlink" title="下载单个网页"></a>下载单个网页</h5>• python提供了urllib2, requests等库<pre><code>import requestsurl = 'http://www.weather.com.cn/weather/101010100.shtml' # URL地址header = {'User‐Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36(KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36Core/1.53.3226.400 QQBrowser/9.6.11681.400'}req = requests.get(url, headers=header, timeout=60)req.encoding = 'utf‐8' # 设置文本编码code = req.status_code # 返回状态，200代表OKprint(code)</code></pre>• 遇到错误怎么办？(code!=200)<br>• 下载时遇到的错误经常是临时性的：<br>_ 如服务器过载时返回的503 Service Unavailable错误；<br>_ 对于此类错误，可以尝试重新下载。<br>• 非临时性错误<br>_ 如果服务器返回的是404 Not Found错误，说明该网页目前并不存在，再次尝试同样的请求也通常会再次出错。<br>• 400+错误发生在客户端，500+错误则发生在服务端。<br>• 在code为500+时可以重试下载，但通常应该等待一段时间。<h5 id="分析网页的三类技术"><a href="#分析网页的三类技术" class="headerlink" title="分析网页的三类技术"></a>分析网页的三类技术</h5>• 正则表达式<br>_ 无视HTML语言，直接利用正则表达式筛选出所需的部分，包括天气和URL；<br>• BeatifulSoup<br>_ 将HTML进行解析，利用树结构进行分析；<br>• lxml<br>_ 将HTML进行解析，基于XPATH查询语言进行分析。</li><li>BeatifulSoup<br>• Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库；<br>• 支持惯用的文档导航、查找、修改文档的方式；<br>• 提高效率，通常较正则表达式可以节省数小时甚至数天的工作时间。<br>• pip install beautifulsoup4<pre><code>from bs4 import BeautifulSouphtml_doc = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class="story"&gt;Once upon a time there were three little sisters;and their names were&lt;a href="http://example.com/elsie" class="sister"id="link1"&gt;Elsie&lt;/a&gt;,&lt;a href="http://example.com/lacie" class="sister"id="link2"&gt;Lacie&lt;/a&gt; and&lt;a href="http://example.com/tillie" class="sister"id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class="story"&gt;...&lt;/p&gt;"""soup = BeautifulSoup(html_doc)print(soup.prettify()) # 排版soup.title# &lt;title&gt;The Dormouse's story&lt;/title&gt;soup.title.name# 'title'soup.title.string# 'The Dormouse's story'soup.title.parent.name# 'head'soup.p# &lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;soup.p['class']# 'title'soup.a# &lt;a class="sister" href="http://example.com/elsie"id="link1"&gt;Elsie&lt;/a&gt;soup.find_all('a')# [&lt;a class="sister" href="http://example.com/elsie"id="link1"&gt;Elsie&lt;/a&gt;,#  &lt;a class="sister" href="http://example.com/lacie"id="link2"&gt;Lacie&lt;/a&gt;,#  &lt;a class="sister" href="http://example.com/tillie"id="link3"&gt;Tillie&lt;/a&gt;]soup.find(id="link3")# &lt;a class="sister" href="http://example.com/tillie"id="link3"&gt;Tillie&lt;/a&gt;</code></pre>• 从文档中找到所有a标签的链接<pre><code>for link in soup.find_all('a'):    print(link.get('href'))# http://example.com/elsie# http://example.com/lacie# http://example.com/tillie</code></pre>• 从文档中获取所有文字内容<pre><code>print(soup.get_text())# The Dormouse's story## The Dormouse's story## Once upon a time there were three little sisters; and their\names were# Elsie, Lacie and ...</code></pre></li><li>如何遍历网页内容<br>• BS4提供了children, parents, next_element等<br>一系列方法，可以对元素的子元素、父元<br>素、兄弟元素等进行导航，从而遍历整个<br>网页。<br>• BS4也提供了正则表达式等方法。<br>• BS4的介绍可以参考：<br><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a></li><li>链接爬虫<br>• 链接爬虫表现得更像普通用户，它跟踪链接，访问感兴趣的内容。<br>• 通过跟踪所有链接的方式，可以下载整个网站的页面。<br>• 这种方法会下载大量并不需要的网页，通常应该利用正则表达式匹配/过滤需要爬取的网页。<br>• 避免链接爬虫陷阱<br>• 某些网站会动态生成页面内容，有可能造成理论上无限多的页面。<br>——例如：日历网站，链接指向“下个月”<br>• 通常应该定义爬虫最大深度，避免爬虫陷阱。<h3 id="图形界面开发GUI"><a href="#图形界面开发GUI" class="headerlink" title="图形界面开发GUI"></a>图形界面开发GUI</h3><a href="https://www.jianshu.com/p/db0af187ab26" target="_blank" rel="noopener">python图形化GUI：pyQt5详解</a><br><a href="https://www.jianshu.com/p/8ce24bd03978" target="_blank" rel="noopener">python图形化GUI：pyQt5-tools详解</a><h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5>• Model（模型）是应用程序中用于处理应用程序数据逻辑的部<br>分，通常模型对象负责在数据库中存取数据。<br>• View（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。<br>• Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。<br>• MVC 分层有助于管理复杂的应用程序，因为您可以在一个时间内专门关注一个方面。例如，您可以在不依赖业务逻辑的情况下专注于视图设计。同时也让应用程序的测试更加容易。<br>• MVC 分层同时也简化了分组开发。不同的开发人员可同时开发视图、控制器逻辑和业务逻辑。</li></ul><p><a href="https://www.jianshu.com/p/38167906095e" target="_blank" rel="noopener">python：PIL图像处理</a></p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><h5 id="EXCEL自动化"><a href="#EXCEL自动化" class="headerlink" title="EXCEL自动化"></a>EXCEL自动化</h5><p>• Excel 是 Windows 环境下流行的、强大的电子表格应用。<br>—— 包括LibreOffice Calc，OpenOffice Calc，WPS等软件也可以读写xlsx格式。<br>• openpyxl 模块让 Python 程序能读取和修改Excel 电子表格文件。最新版本2.6.2。<br>• <a href="https://openpyxl.readthedocs.io" target="_blank" rel="noopener">https://openpyxl.readthedocs.io</a><br>• 安装：pip install openpyxl</p><ul><li>取得工作簿及工作表<pre><code>import openpyxlwb = openpyxl.load_workbook('example.xlsx')wb.sheetnamessheet = wb['Sheet3']sheet.titleanotherSheet = wb.activeanotherSheet</code></pre></li><li>取得单元格<pre><code>sheet = wb['Sheet1']sheet['A1']sheet['A1'].valuec = sheet['B1']c.valuefor i in range(1, 5):  print(i, sheet.cell(row=i, column=2).value)</code></pre></li><li>取得矩形区域<pre><code>for rowOfCellObjects in sheet['A1':'C3']:    for cellObj in rowOfCellObjects:          print(cellObj.coordinate, cellObj.value)    print('‐‐‐ END OF ROW ‐‐‐')</code></pre></li><li>取得行或者列：支持循环迭代<pre><code>for i in sheet.rows:    print(i)for i in sheet.columns:    print(i)</code></pre></li><li>数据结果的保存<br>• 保存在txt文件中<br>• 保存在csv文件中<br>• 保存在py文件中<pre><code>import pprintresultFile = open('result.py', 'w')resultFile.write('pay_sum = ' + pprint.pformat(pay_sum))resultFile.close()</code></pre></li><li>创建空白工作簿和表<pre><code>import openpyxlwb = openpyxl.Workbook()print(wb.sheetnames)sh = wb.activesh.title = "My Data"wb.save("mydata.xlsx")</code></pre></li><li>创建和删除工作表<pre><code>import openpyxl&gt;&gt;&gt; wb = openpyxl.Workbook()&gt;&gt;&gt; wb.get_sheet_names()['Sheet']&gt;&gt;&gt; sh1 = wb.create_sheet()&lt;Worksheet "Sheet1"&gt;&gt;&gt;&gt; wb.get_sheet_names()['Sheet', 'Sheet1']&gt;&gt;&gt; wb.create_sheet(index=0, title='First Sheet')&lt;Worksheet "First Sheet"&gt;&gt;&gt;&gt; wb.get_sheet_names()['First Sheet', 'Sheet', 'Sheet1']&gt;&gt;&gt; wb.remove_sheet(sh1)   #删除表&gt;&gt;&gt; wb.get_sheet_names()['First Sheet', 'Sheet']</code></pre></li><li>将值写入单元格<pre><code>import openpyxlwb = openpyxl.Workbook()sheet = wb.activesheet['A1'].value = 'Hello world!'wb.save("hello.xlsx")</code></pre></li><li>其他功能<br>• 改变字体<br>• 使用公式<br>• 设置行高和列宽<br>• 单元格拆分<br>• 绘制图表<br>例子：乘法表<pre><code>import openpyxlwb = openpyxl.Workbook()sheet = wb.activefor i in range(1, 10):sheet.cell(row=i+1, column=1).value = isheet.cell(row=1, column=i+1).value = ifor i in range(1, 10):for j in range(1, 10):sheet.cell(row=i+1, column=j+1).value=i*jwb.save("99.xlsx")</code></pre><h5 id="WORD自动化"><a href="#WORD自动化" class="headerlink" title="WORD自动化"></a>WORD自动化</h5>• Microsoft公司的Word是一套功能丰富的办公软件，所提供的docx格式可以存储文本以及字体、颜色等丰富的信息。<br>• docx的读写比txt文件要复杂，需要第三方库的支持。<br>• pip install python‐docx<br>• 注意：导入的时候用 import docx</li><li>docx文件结构<br>• docx 文件有很多结构。<br>• 这些结构在 python-docx 中用 3 种不同的类型来表示。<br>• Document 对象表示整个文档。<br>• Document 对象包含一个 Paragraph 对象的列表，Paragraph即文档中的段落。<br>• 每个 Paragraph 对象都包含一个 Run 对象的列表。</li><li>读取文档<pre><code>import docxdoc = docx.Document('libai.docx')print(len(doc.paragraphs)# 8print(doc.paragraphs[0].text)# '铁杵成针'print(doc.paragraphs[2].text)# '李白是唐代的大诗人，但是小时候读书并不用功。...'print(doc.paragraphs[2].runs)#[&lt;docx.text.run.Run at 0x1e0e56a3c50&gt;,...]print(doc.paragraphs[2].runs[0].text)#'李白是唐代的大诗人，'print(doc.paragraphs[2].runs[1].text)#'但是小时候读书并不用功'</code></pre></li><li>获取Word中的纯文本<br>• 如果不关注样式，只希望获得所有的文本<br>• 参考代码实现：<pre><code>import docxdef getText(filename):    doc = docx.Document(filename)    fullText = []    for para in doc.paragraphs:          fullText.append(para.text)    return '\n'.join(fullText)</code></pre></li><li>Word中的样式<br>• Word有很多样式，可以通过段落或run对象的style属性获得。<br>• 可以通过设置下列属性产生不同的样式<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-cdf1dbbe2c7c7ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>修改样式<pre><code>import docxdoc = docx.Document('libai.docx')doc.paragraphs[2].runs[0].underline = Truedoc.save('restyled‐libai.docx')</code></pre></li><li>生成Word文档<br>• doc.add_paragraph(text) 新建一个段落，返回段落对象。<br>• para.add_run(text) 新建一个run，返回run对象。<br>• doc.add_heading(text, level) 新建一个标题，层级为level<br>• doc.add_picture(filename) 新建一个图片<pre><code>import docxdoc = docx.Document()doc.add_heading('静夜思', 0)doc.add_heading('李白', 1)for s in ["床前明月光", "疑是地上霜", "举头望明月","低头思故乡"]:para = doc.add_paragraph(s)para.add_run("/")doc.add_picture("green.jpg")doc.save('mydoc.docx')</code></pre><h5 id="PDF自动化"><a href="#PDF自动化" class="headerlink" title="PDF自动化"></a>PDF自动化</h5>• PDF 表示 Portable Document Format 便携式文件格式，由Adobe Systems在1993年用于文件交换所发展出的文件格式。<br>• 本部分专注两件事：<br>—— 从 PDF 读取文本内容<br>—— 从已有的文档页面生成新的 PDF。<br>• pip install pyPDF2</li><li>PDF读取文字<pre><code>import PyPDF2with open('04067093.pdf', 'rb') as pdfFile:pdfReader = PyPDF2.PdfFileReader(pdfFile)print("Total pages: ", pdfReader.numPages)page0 = pdfReader.getPage(0)print(page0.extractText())</code></pre></li><li>合并PDF<pre><code>import PyPDF2pdf1File = open('00294849.pdf', 'rb')pdf2File = open('04067093.pdf', 'rb')pdf1Reader = PyPDF2.PdfFileReader(pdf1File)pdf2Reader = PyPDF2.PdfFileReader(pdf2File)pdfWriter = PyPDF2.PdfFileWriter()for pageNum in range(pdf1Reader.numPages):    pageObj = pdf1Reader.getPage(pageNum)    pdfWriter.addPage(pageObj)for pageNum in range(pdf2Reader.numPages):    pageObj = pdf2Reader.getPage(pageNum)    pdfWriter.addPage(pageObj)pdfOutputFile = open('combined.pdf', 'wb')pdfWriter.write(pdfOutputFile)pdfOutputFile.close(); pdf1File.close(); pdf2File.close()</code></pre></li><li>页面旋转和叠加<br>• rotateClockwise(0, 90, 180, 270)<br>• rotateCounterClockwise(…)<br>_ 可以将页面对象旋转<br>• mergePage(anotherPage)<br>_ 可以将页面叠加（水印）<br>• 综合上述功能，可以实现pdf文件的合并、页面抽取、旋转、叠印等功能。</li><li>PDF中文编码问题<br>• pyPDF2不能读取中文编码的文字；<br>• 可以使用pdfminer库或其他类似的库。<pre><code>import iofrom pdfminer.converter import TextConverterfrom pdfminer.pdfinterp import PDFPageInterpreterfrom pdfminer.pdfinterp import PDFResourceManagerfrom pdfminer.pdfpage import PDFPagedef extract_text_from_pdf(pdf_path):  resource_manager = PDFResourceManager()  fake_file_handle = io.StringIO()  converter = TextConverter(resource_manager, fake_file_handle)  page_interpreter = PDFPageInterpreter(resource_manager, converter)  with open(pdf_path, 'rb') as fh:      for page in PDFPage.get_pages(fh, caching=True):          page_interpreter.process_page(page)      text = fake_file_handle.getvalue()  converter.close()  fake_file_handle.close()  if text:      return textif __name__ == '__main__':print(extract_text_from_pdf('CH9‐图形界面开发A.pdf'))</code></pre><h5 id="图像处理自动化"><a href="#图像处理自动化" class="headerlink" title="图像处理自动化"></a>图像处理自动化</h5>• 图像处理已经是深入日常生活，Photoshop的缩写已经成为图像处理的代名词。<br>• 如果需要编辑大量的图像，手工编辑可能是漫长、枯燥的工作。<br>• Pillow 是一个第三方 Python 模块，用于处理图像文件。该模块包含一些函数，可以很容易地裁剪图像、调整图像大小，以及编辑图像的内容，从而轻松地自动编辑成千上万的图像。</li><li>颜色和 RGBA 值<br>• 计算机程序通常将图像中的颜色表示为RGBA 值。RGBA 值是一组数字，指定顔色中的红、绿、蓝和 alpha（透明度）的值。<br>• 这些值是从 0到 255（最高）的整数。<br>• 这些 RGBA 值分配给单个像素，像素是计算机屏幕上能显示一种颜色的最小点。<br>• 像素的 RGB 设置准确地告诉它应该显示哪种颜色的色彩。</li><li>Alpha通道<br>• 图像也有一个 alpha 值，用于生成 RGBA 值。如果图像显示在屏幕上，遮住了背景图像或桌面墙纸，alpha 值决定了“透过”颜色可以看到多少程度的背景。<br>• 如果alpha 值为 0，表示完全透明。<br>• 如果alpha 值为 255，表示完全不透明。</li><li>获取颜色<pre><code>&gt;&gt;&gt; from PIL import ImageColor&gt;&gt;&gt; ImageColor.getcolor('red', 'RGBA')(255, 0, 0, 255)&gt;&gt;&gt; ImageColor.getcolor('RED', 'RGBA')(255, 0, 0, 255)&gt;&gt;&gt; ImageColor.getcolor('Black', 'RGBA')(0, 0, 0, 255)&gt;&gt;&gt; ImageColor.getcolor('chocolate', 'RGBA')(210, 105, 30, 255)&gt;&gt;&gt; ImageColor.getcolor('CornflowerBlue', 'RGBA')(100, 149, 237, 255)</code></pre></li><li>图像坐标系<br>• 左上角坐标为(0,0)<br>• y正方向向下<br>• x正方向向右</li><li>Box<br>• 一个矩形元组参数，表示图像中的一个矩形区域。四个整数按顺序分别是：<br>_左：该矩形的最左边的 x 坐标。<br>_顶：该矩形的顶边的 y 坐标。<br>_右：该矩形的最右边右面一个像素的 x 坐标。<br>_底：该矩形的底边下面一个像素的 y 坐标。<br>• 矩形元组（3, 1, 9, 6）</li><li>图像的打开和存储<pre><code>&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; img = Image.open('horse.jpg')&gt;&gt;&gt; img.size　 (1674, 1116)&gt;&gt;&gt; width, height = img.size&gt;&gt;&gt; img.format'JPG'&gt;&gt;&gt; img.save('horse.png')</code></pre></li><li>生成新图像<pre><code>from PIL import Imageim = Image.new('RGBA', (100, 200), 'purple')im.save('purpleImage.png')im2 = Image.new('RGBA', (20, 20))im2.save('transparentImage.png')</code></pre></li><li>裁剪图片<pre><code>croppedIm = img.crop((600, 200, 1000, 800))croppedIm.save('cropped‐horse.png')</code></pre></li><li>复制和粘贴<pre><code>from PIL import Imageimg = Image.open('horse.jpg')croppedIm = img.crop((600, 200, 1000, 800))horsehead = croppedIm.copy()img.paste(horsehead, (1200, 200))img.save('horse2.jpg')</code></pre></li><li>调整图像大小及旋转图像<pre><code>from PIL import Imageimg = Image.open('horse.jpg')width, height = img.sizeimg44 = img.resize((width//4, height//4), Image.NEAREST)img42 = img.resize((width//4, height//2), Image.NEAREST)imgr30 = img.rotate(30)img44.save('horse44.jpg')img42.save('horse42.jpg')imgr30.save('horse_r30.jpg')</code></pre></li><li>更改单个像素<br>• 单个像素的颜色通过 getpixel()和putpixel()方法取得和设置。它们都接受一个元组，表示像素的 x 和 y坐标。<br>• putpixel()方法还接受一个元组，作为该像素的颜色。这个顔色参数是四整数 RGBA 元组或三整数 RGB 元组。<br>• 注：1. 能改一个像素就能进行任意的图像编辑；</li></ul><ol start="2"><li>图片像素很多时，本方法很慢。<pre><code>img = Image.new('RGB', (200, 100), 'black')print(img.getpixel((0, 0)))for x in range(100):for y in range(50):img.putpixel((x, y), (210, 210, 210))img.save('putPixel.png')</code></pre></li></ol><ul><li>绘制形状<br>• ImageDraw 方法在图像上绘制各种形状。<br>• 点：point(xy, fill)方法绘制单个像素。xy 参数表示要画的点的列表。该列表可以是 x和 y 坐标的元组的列表，例如[(x, y), (x, y), …]，或是没有元组的 x和 y 坐标的列表，例如[x1, y1, x2, y2, …]。<br>• 线：line(xy, fill, width)方法绘制一条线或一系列的线。xy 是一个元组的列表，例如[(x, y), (x,y), …]，或整数列表，例如[x1, y1, x2, y2, …]。每个点都是正在绘制的线上的一个连接点。<br>• 矩形、椭圆、多边形、文字等。<pre><code>from PIL import Image, ImageDrawim = Image.new('RGBA', (200, 200), 'white')draw = ImageDraw.Draw(im)draw.line([(0, 0), (199, 0), (199, 199), (0, 199), (0,0)], fill='black')draw.rectangle((20, 30, 60, 60), fill='blue')draw.ellipse((120, 30, 160, 60), fill='red')draw.polygon(((57, 87), (79, 62), (94, 85), (120, 90),(103, 113)), fill='brown')for i in range(100, 200, 10):draw.line([(i, 0), (200, i ‐ 100)], fill='green')im.save('drawing.png')</code></pre><h5 id="键盘鼠标自动化"><a href="#键盘鼠标自动化" class="headerlink" title="键盘鼠标自动化"></a>键盘鼠标自动化</h5>• 白盒：完成了解docx/xlsx格式细节，通过python直接生成符合格式的文档。<br>• 灰色：Word/Excel提供某种控制接口（如COM接口），通过COM接口操作Word/Excel软件达到预期目标。<br>• 黑色：缺乏控制接口，仅能通过模拟键盘和鼠标事件驱动GUI软件。</li><li>pyautogui<br>• pyautogui模块可以模拟鼠标移动、按键和滚动鼠标滚轮等。<br>• 本节仅介绍pyautogui的部分功能。<br>• <a href="http://pyautogui.readthedocs.org/" target="_blank" rel="noopener">http://pyautogui.readthedocs.org/</a><br>• 安装：<br>_ pip install PyGetWindow==0.0.1<br>_ pip install pyautogui</li><li>注意事项<br>• Python 能以想象不到的高速移动鼠标并击键。它可能太快，导致被控程序跟不上。<br>• 如果出了问题，而程序仍然继续到处移动鼠标，计算机就会失去控制（因为你的键盘和鼠标被人控制了）。<br>—— 如果程序自己在移动鼠标，停止它可能很难。你可能无法点击“关闭”按钮<br>• Windows 和 Linux  上，注销的热键是 Ctrl-Alt-Del ，有可能会失去目前没有保存的文档。</li><li>预防措施<br>• 设置脚本在每次函数调用后暂停一段时间，让用户有很短的时间窗口来控制鼠标和键盘。<br>—— 将pyautogui.PAUSE 变量设置为要暂停的秒数。如设置：pyautogui.PAUSE = 1.5。<br>• 开启pyautogui 自动防故障功能。<br>—— 将鼠标移到屏幕的左上角，将导致pyautogui.FailSafeException 异常。<br>—— 故障时应尽可能快地向左上移动鼠标，以触发异常。<br>—— 该异常可以用try语句捕获。</li><li>屏幕坐标系<br>• 左上角为原点<br>• x向右为正方向<br>• y向下为正方向<pre><code>import pyautogui as agwidth, height = ag.size()print(width, height)#1366, 768</code></pre></li><li>移动鼠标<pre><code>import pyautoguifor i in range(10):ag.moveTo(100, 100, duration=0.25)ag.moveTo(200, 100, duration=0.25)ag.moveTo(200, 200, duration=0.25)ag.moveTo(100, 200, duration=0.25)</code></pre></li><li>获取鼠标位置<br>• position()函数获得鼠标当前的位置。<br>• 为了持续跟踪获得鼠标位置，可以采用下述代码：<pre><code>print('Press Ctrl‐C to quit.')try:  while True:      x, y = pyautogui.position()      print(f"mouse at {x:4d}, {y:4d}")except KeyboardInterrupt:  print('\nDone.')</code></pre></li><li>点击鼠标<br>• 当前位置点击 click() 方法。<br>• 若在位置(x,y) 点击，采用click(x,y)方法。<br>• 默认情况下点击左键。若指定鼠标按键，则需要button关键字参数，取值为 ‘left’、’middle’或’right’。<br>• 例：<br>_ click(100, 150, button=’left’)<br>_ click(200, 250, button=’right’)<br>• 模拟鼠标按下：mouseDown()<br>• 释放鼠标按键：mouseUp()<br>• 函数参数与 click()<br>_ click = mouseDown + mouseUp<br>• 鼠标双击：doubleClick()</li><li>拖动鼠标<br>• Drag即按住一个按键不放同时移动鼠标。<br>_ 通过拖动文件图标，在文件夹之间移动文件；<br>_ 可以拖动绘图。<br>• dragTo() 和 dragRel() 函数将鼠标拖动到一个新的位置，或相对当前的位置。<br>_ 函数的参数与moveTo() 和 moveRel() 相似。<pre><code>import pyautogui as agimport timetime.sleep(5)ag.click()distance = 200while distance &gt; 0:  ag.dragRel(distance, 0, duration=0.2) # move right  distance = distance ‐ 5  ag.dragRel(0, distance, duration=0.2) # move down  ag.dragRel(‐distance, 0, duration=0.2) # move left  distance = distance ‐ 5  ag.dragRel(0, ‐distance, duration=0.2) # move up</code></pre></li><li>获取屏幕内容<pre><code>import pyautoguiim = pyautogui.screenshot()im.save("capture.png")</code></pre>• 做GUI自动测试时，可以利用截图分析按钮是否正常或者变灰（利用Pillow库的getpixel方法）。<br>• 可以做一个软件，随着鼠标移动，自动取得不同位置的颜色。</li><li>屏幕图像识别<br>• 提前准备一幅（截图后取出）的局部图像：<br>• locateOnScreen(‘want.png’)<br>• 找到屏幕上完全匹配的图像所在的box，然后可在box的中心（或其他位置）进行点击。</li><li>键盘<br>• typewrite()方法模拟发送按键<br>_ typewrite(‘Hello world!’)<br>_ typewrite([‘a’, ‘b’, ‘left’, ‘left’,’X’, ‘Y’])<br>_ 前者均为正常按键<br>_ 后者的’left’表示“左方向键”</li><li>键盘：特殊键<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-f6e85cea98792463.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>键盘模拟<br>• keyDown()和keyUp()将向计算发送虚拟的按键和释放。<br>• press() 函数模拟完整的击键。<pre><code>keyDown('shift');press('1');keyUp('shift')</code></pre>相当于 Shift-1 ，即“ ! ”键<br>• hotkey() 按参数自左向右依次模拟按键倒序模拟释放。<br>_ hotkey(‘ctrl’, ‘alt’, ‘shift’, ‘s’)</li><li>可能完成的任务<br>• 模拟键盘及鼠标，实现自动填表；<br>• 填写Excel表格；<br>• 编写Word文件。<br>• 自动玩游戏；<br>• 网络爬虫：<br>• 模拟键盘输入关键字，发送“回车”键，获得页面；<br>• 利用键盘另存当前页面；<br>• 点击“下一页”，继续另存当前页面<br>• 聊天机器人<br>• 模拟键盘输入微信、QQ等<br>• 在AI时代，视觉、听觉和模拟发声、模拟形象都可以实现。<h3 id="数据存储与程序调试"><a href="#数据存储与程序调试" class="headerlink" title="数据存储与程序调试"></a>数据存储与程序调试</h3><h5 id="数据转换存储"><a href="#数据转换存储" class="headerlink" title="数据转换存储"></a>数据转换存储</h5>• 数据的存储交换发生在：<br>_ 在同一程序的不同片段之间；<br>_ 在不同的程序之间；<br>_ 在不同主机之间。<br>• 这些数据可能存储一些简单的文本和数值，也可能是非常复杂具有结构的一组数据。<br>• 为了实现数据的存储和交换，有多种相对流行的数据存储交换方式：<br>_ 文件或数据库。</li><li>INI文件<br>• INI用来表示简单的、分层次的配置文件，其内涵类似于Python的词典。<br>• 本质是纯文本文件，但有一些简单的格式。</li><li>INI文件的读写<br>• 由于格式非常简单，可以基于一般文件的read/write进行存取。<br>• Python提供了内置库：<pre><code>import configparserconfig = configparser.ConfigParser()config.add_section('Init')config.set('Init', 'Server', '127.0.0.1')config.set('Init', 'Port', '12000')with open('my.ini', 'wt') as configfile:  config.write(configfile)</code></pre></li><li>pickle<br>• Pickle库可以实现任意python对象的存储。<pre><code>import pickletodo = ['write a blog post','reply an email','read a book']pickle_file = open('todo.pickle', 'wb')pickle.dump(todo, pickle_file)</code></pre></li><li>Pickle &amp; cPickle<br>• Pickle<pre><code>pickle_file = open('todo.pickle', "rb")todo = pickle.load(pickle_file)pickle_file.close()print(todo)</code></pre></li><li>JSON<br>• Pickle仅限于Python程序使用，如何和其他语言交互？<br>• JSON (JavaScript Object Notation) 是跨语言的轻量级数据交换格式。<br>• 易于被人工读取、修改，也容易被机器读取和写入。<br>• 符合 ECMA-262 3rd Edition标准。<br>• JSON语言无关，它可以方便的被 C, C++, C#,Java, JavaScript, Perl, Python等语言读取和生成。<br>• 结论：JSON是理想的数据交换格式，可以实<br>现跨语言的、跨计算机的复杂数据传输。<pre><code>import jsondatastore = { "room‐number": 100,"use": "reception","sq‐ft": 50,"price": [100, 200, 300]}with open("ds.json", 'w') as f:  json.dump(datastore, f)with open("ds.json", 'r') as f:  data = json.load(f)print(data)</code></pre></li><li>数据库<br>• 文件存储不适用于大项目，此时需要使用数据库。<br>• 数据管理系统 Database Management System= DBMS<br>_ 一系列存储数据的文件；<br>_ 一系列程序用于访问和更新其中的数据。<br>• 目前最流行的数据库是关系型数据库。</li><li>SQLite<br>• SQlite 是开源的数据库，可以嵌入在其他程序中，不需要安装。<br>• 单机版本，不能并发、不能网络访问、不需要用户名密码鉴权（但可以加密）。<br>• Portable – 仅使用了ANSI-standard C语言，因此可在各种平台编译；<br>• Reliable – 良好的测试，开源代码；<br>• Small – 300 kb 的库，只需要16kb的stack和100kb的heap，甚至可以运行在单片机上。</li><li>建库<pre><code>import sqlite3conn = sqlite3.connect('example.db')c = conn.cursor()c.execute('''CREATE TABLE money(日期, 姓名, 支出)''')for d, n, m in [("2019‐4‐1", "Li Lei", 52),("2019‐4‐2", "Han Meimei", 300),("2019‐4‐5", "Li Lei", 230),("2019‐4‐8", "Li Lei", 170),("2019‐4‐10", "Han Meimei", 96)]:  c.execute("INSERT INTO money VALUES (?,?,?)",(d,n,m))conn.commit()conn.close()</code></pre></li><li>用库<pre><code>import sqlite3conn = sqlite3.connect('example.db')c = conn.cursor()result = c.execute('''select 姓名, 支出    from money where 支出&gt;100;''')for row in result:  name = row[0]  pay = row[1]  print(f"{name} pay {pay}&gt;100")conn.close()</code></pre></li><li>其他格式<br>• MAT：Matlab数据存储格式<br>• Python可以直接读取MAT文件，Python也可以调用Matlab完成特定任务。<h5 id="目录处理"><a href="#目录处理" class="headerlink" title="目录处理"></a>目录处理</h5>• 查找目录下的子目录和文件<br>_ glob库<br>• 遍历目录<br>_ os.walk方法</li><li>实例<pre><code>import osfrom os.path import join, getsizefor root, dirs, files in os.walk('.'):print("root=", root)print(sum(getsize(join(root, name)) for name in files), end="")print("bytes in", len(files),"non‐directory files")</code></pre><h5 id="测试和调试"><a href="#测试和调试" class="headerlink" title="测试和调试"></a>测试和调试</h5></li><li>测试驱动Test-driven开发<br>• pytest是一个强大的Python测试工具。<br>• pytest是软件测试框架，它会自动找到用户写的测试用例，运行测试并报告结果。<br>• 支持插件或第三方扩展<br>• 容易与其他工具对接。<br>• pip install pytest</li><li>规则<br>• pytest 测试样例的规则：<br>_ 测试文件以 test_ 开头（以 <em>test 结尾也可以）<br>_ 测试类以 Test 开头，并且不能带有 <strong>init</strong> 方法<br>_ 测试函数以 test</em> 开头<br>_ 断言使用基本的 assert 即可<br>• pytest自动执行所有的测试，并报告通过和失败的测试用例数量。</li><li>print-调试</li><li>使用日志文件<br>• 对大规模程序长期运行而言，故障的机会是很少的，难以通过print获得；<br>• 日志是一种非常好的手段，可以用于记录程序运行过程中的各种信息。<br>• 理想的日志可以用来恢复和重现程序的运行过程。<br>• 内置的logging库。</li><li>日志等级<br><img src="/images/loading.gif" data-original="https://upload-images.jianshu.io/upload_images/14093662-1a0cf572c74b3490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>利用IPython.embed调试<br>• from IPython import embed<br>• 在需要调试的位置加入embed()函数<br>• 可以在现场运行python解释器，可以自由执行任何python语句，包括：<br>_ 打印输出任何变量<br>_ 修改和删除任何变量<br>• print/logging应对复杂数据结构的能力不足，embed()是较为理想的选择。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些实用有趣的Web分享</title>
      <link href="/posts/webshare1.html"/>
      <url>/posts/webshare1.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：个人常用的一些实用便捷的以及有趣的网站汇总</p><p>温馨提示：多图预警，流量党注意</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h3 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h3><ul><li><p><a href="https://slidesgo.com/" target="_blank" rel="noopener">PPT优质模板：全免费</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05NzZjMWM1M2MyMDk0NGE1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.officeplus.cn/Template/Home.shtml" target="_blank" rel="noopener">OfficePlus</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227142828441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3></li><li><p><a href="https://www.wondercv.com/" target="_blank" rel="noopener">超级简历</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227122034626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><a href="https://www.wondercv.com/" target="_blank" rel="noopener">五百丁简历</a><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227122149491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul><li><a href="https://smallpdf.com/" target="_blank" rel="noopener">Smallpdf：在线pdf转换</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kM2JmZmU2ZjZjOGQ2YjE5LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h3 id="制作"><a href="#制作" class="headerlink" title="制作"></a>制作</h3><ul><li><p><a href="https://www.xiuzhan365.com/" target="_blank" rel="noopener">秀展网：在线MG动画制作</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01ODlmOGY4NTZkOGY4MDQyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.weiciyun.com/" target="_blank" rel="noopener">微词云：文字云艺术生成器</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zYWRiYzI0NTFjYWEwNGUwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://creativemass.cn/#/" target="_blank" rel="noopener">Creative Mass：创意导航</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kZThiYzc0YWNlMmFlNjM1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.grammarly.com/" target="_blank" rel="noopener">语法：免费写作助手</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02NjgwOWEwMWIxOTEzYTEwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://sorry.xuty.tk/sorry/" target="_blank" rel="noopener">表情锅：在线制作表情包</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1lOGJhNzk4ODlhZmNkZjM1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://zh.wix.com/" target="_blank" rel="noopener">网页制作</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi00Y2JkZTRiM2RkZjA4NDcwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.akuziti.com/yw/" target="_blank" rel="noopener">艺术字在线生成</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03NWZmNWRiNzhiODNmZWQ5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://giphy.com/" target="_blank" rel="noopener">Gif工具</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01YTJjZWU2YzdkMjQ5YWM0LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><ul><li><p><a href="https://www.chuangkit.com/dc.html" target="_blank" rel="noopener">创客贴</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03MzhmZTBkNDQ2ZjE1Y2JiLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.canva.com/" target="_blank" rel="noopener">Canva</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0wNjAyYTllYzYwNTEzNjAzLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.zitijia.com/" target="_blank" rel="noopener">字体家：商用字体下载</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227142459182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><a href="https://h5.bce.baidu.com/store" target="_blank" rel="noopener">H5设计</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/2020022714322343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><p> <a href="https://www.nounplus.net/" target="_blank" rel="noopener">Nounplus：在线查英语语法拼写错误</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0xZThjMjg0MWRlZTkxMWE5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p><ul><li><a href="http://www.gfxcamp.com/" target="_blank" rel="noopener">龋齿一号</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05YTY0MWNmMTdlM2IxMTRlLnBuZw?x-oss-process=image/format,png" alt="image.png"><h3 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h3></li><li><a href="http://tools.jb51.net/" target="_blank" rel="noopener">脚本之家在线工具</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227143425667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p><a href="https://www.materialtools.com/?page=1" target="_blank" rel="noopener">云短信：临时验证码</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03OGFkYzMyNDRiNjI0MzUyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://everytimezone.com/" target="_blank" rel="noopener">时差</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01OTlkMjNkZGNiYTg5NzFiLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h3 id="综合学习平台"><a href="#综合学习平台" class="headerlink" title="综合学习平台"></a>综合学习平台</h3><ul><li><p><a href="https://study.163.com/" target="_blank" rel="noopener">网易云课堂</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iY2Q0MDZlZjExZjY2YTU4LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.icourse163.org/" target="_blank" rel="noopener">中国大学mooc</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zNmY0NjBmOGQ0MThiM2ZlLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://ke.qq.com/" target="_blank" rel="noopener">腾讯课堂</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03Mzc5MGE5YzM4YTY1M2EzLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://next.xuetangx.com/" target="_blank" rel="noopener">学堂在线</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03NDk4Njk5ODdjYzNkODQ2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.51zxw.net/" target="_blank" rel="noopener">我要自学网</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iZjllZGE5ODQ4NzUwY2E2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul><li><p><a href="https://www.allhistory.com/" target="_blank" rel="noopener">全历史：世界各国历史记录和联系检索</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03NjYyZmFkYTU2ZWRkMGNlLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.ageeye.cn/" target="_blank" rel="noopener">发现中国：地图分享知识</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jMGY3ODQxMTM3Mzk0MGZiLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="医学"><a href="#医学" class="headerlink" title="医学"></a>医学</h3><ul><li><a href="https://www.mvyxws.com/" target="_blank" rel="noopener">医学微视</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02YjU3NjFjN2EwNDUyOWM1LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="新媒体"><a href="#新媒体" class="headerlink" title="新媒体"></a>新媒体</h1><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><ul><li><p><a href="https://www.kaolamedia.com/" target="_blank" rel="noopener">考拉新媒体导肮</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jNzcyNGJmNzI0NWYyNWVkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://tophub.today/" target="_blank" rel="noopener">今日热榜</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02MGNiNGEwYjgyYWFjMjQ4LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="推广"><a href="#推广" class="headerlink" title="推广"></a>推广</h3><ul><li><a href="https://mj.yuzhua.com/search/3.html" target="_blank" rel="noopener">鱼爪传媒</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0yY2YxMDE2OTQ5MWNiNGE2LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="导航-1"><a href="#导航-1" class="headerlink" title="导航"></a>导航</h1><ul><li><a href="http://guozhivip.com/nav/" target="_blank" rel="noopener">果汁导航</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02ZDVkNzI1MDBmODg3ZDQ5LnBuZw?x-oss-process=image/format,png" alt="image.png"></li><li><a href="https://ailongmiao.com/" target="_blank" rel="noopener">龙喵网</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/2020022714393084.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><a href="https://webjike.com/" target="_blank" rel="noopener">小呆导航</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227144016570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>[北邮人导航](<a href="http://byr.wiki/）" target="_blank" rel="noopener">http://byr.wiki/）</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227144203360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h1><h3 id="开源平台"><a href="#开源平台" class="headerlink" title="开源平台"></a>开源平台</h3><ul><li><p><a href="https://github.com/" target="_blank" rel="noopener">Github：全球最大的开源平台</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01Mjc0MGYzYjIxMmI5N2Q2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://gitee.com/" target="_blank" rel="noopener">Gitee：国内开源平台</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02ZWJmMzg3Nzk2YzMxNDUwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.gitkraken.com/" target="_blank" rel="noopener">GitKraken：开源工具</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1hYzFkYmM2YzI2ZjM0MjExLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="博客论坛"><a href="#博客论坛" class="headerlink" title="博客论坛"></a>博客论坛</h3><ul><li><p><a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN：博客平台</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kZjk3ZThiM2MyNjY0NTgxLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.cnblogs.com/" target="_blank" rel="noopener">博客园</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kY2NiZmRhNjE1MTNlMzkyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="私人优秀博客推荐"><a href="#私人优秀博客推荐" class="headerlink" title="私人优秀博客推荐"></a>私人优秀博客推荐</h3><ul><li><a href="https://wangyasai.github.io/" target="_blank" rel="noopener">赛亚</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05ZjVkZmZhMWY3ZTU0YzE3LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h1><h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><ul><li><p><a href="http://data.stats.gov.cn/index.htm" target="_blank" rel="noopener">国家统计局</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kYTFlNTQyMjNiN2M1ZGE2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.chyxx.com/" target="_blank" rel="noopener">中国产业信息网</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jMTg5YWRiNzczMTk3ZTdkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://hao.199it.com/" target="_blank" rel="noopener">大数据导航</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0wNTIxMmM0NjZlMWYyODIwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.visualcapitalist.com/" target="_blank" rel="noopener">数据表</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1lNWQ4ODc3Njg3MzVkYzQ5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="专业"><a href="#专业" class="headerlink" title="专业"></a>专业</h3><ul><li><p><a href="http://moon.bao.ac.cn/mul/index/list" target="_blank" rel="noopener">月球与行星多媒体数据库</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0xOTM3ZTMzMjVhMmRjOTY4LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://everysecond.io/" target="_blank" rel="noopener">Every Second</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iZGUzYTZiZTQ2N2I1YzBiLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h1 id="学术"><a href="#学术" class="headerlink" title="学术"></a>学术</h1><ul><li><p><a href="https://www.cnki.net/" target="_blank" rel="noopener">中国知网</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0yY2RjYzUzMGQ1YTJjOTE2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.wanfangdata.com.cn/" target="_blank" rel="noopener">万方数据知识服务平台</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi00MzZlODQ4ZDc2NGU3MGZhLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.termonline.cn/index.htm" target="_blank" rel="noopener">术语在线：专业术语查询</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01MTYwZTcxNjBmYTUwMmE0LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.oalib.com/" target="_blank" rel="noopener">Open Access Library：开源学术平台</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01MWE3ZWNjNzE0MDQ5NGU3LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.wdl.org/zh/" target="_blank" rel="noopener">世界数字图书馆</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01YjNmNjNkYWM1ZmJlYTM3LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.keoaeic.org/" target="_blank" rel="noopener">AEIC学术会议网</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04ZTMxZmY2OGNlNTMxMGE1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.cn-ki.net/" target="_blank" rel="noopener">iData-知识检索</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zZDk3ZGY4MjU3MjZhNTQ1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><h3 id="图片下载"><a href="#图片下载" class="headerlink" title="图片下载"></a>图片下载</h3><ul><li><p><a href="https://www.pexels.com/" target="_blank" rel="noopener">Pexels</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227143554202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><a href="https://unsplash.com/" target="_blank" rel="noopener">Unsplash</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227143637753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><a href="http://bg-patterns.com/" target="_blank" rel="noopener">Bg-patterns：背景图下载</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iMWNjYTRhZTdlNDIzYzRjLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><ul><li><p><a href="https://cover.olook.me/" target="_blank" rel="noopener">网易云封面助手：封面下载</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi00NGU3MjdmNTNjMjdkNGUwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.pngall.com/thug-life-png" target="_blank" rel="noopener">PNG下载</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jY2MwZWVmNjhlYWY3Mzg2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h3><ul><li><p><a href="https://www.ls.graphics/meshgradients" target="_blank" rel="noopener">Free Mesh Gradient Collection：渐变图</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05YjgxZDM4YjYyZWM5OWRiLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://duotone.shapefactory.co/?f=f56468&amp;t=27184f&amp;q=_" target="_blank" rel="noopener">Duotone：双色</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi00NzM3ZmEzYWMyZGE5ZmMyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://photomosh.com/" target="_blank" rel="noopener">Photomosh：在线效果</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01ZTE3NTU1MGNkMzg0NjZkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://petalica-paint.pixiv.dev/index_zh.html" target="_blank" rel="noopener">自动上色</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05YmQyM2EwNjQ1NDEyYWY5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://experiments.withgoogle.com/autodraw" target="_blank" rel="noopener">简笔画</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi01MmJiOTYwNzg0OWJkMjg0LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://watereffect.net/" target="_blank" rel="noopener">水效果处理</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iMTlkMjMwNDI0MjJkNmY3LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.remove.bg/zh" target="_blank" rel="noopener">在线抠图</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227142203515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p><a href="https://www.yasuotu.com/" target="_blank" rel="noopener">图片在线压缩</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227142956542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="二维码制作"><a href="#二维码制作" class="headerlink" title="二维码制作"></a>二维码制作</h3></li><li><p><a href="https://cli.im/" target="_blank" rel="noopener">草料二维码</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/20200227143036991.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><h3 id="视频制作"><a href="#视频制作" class="headerlink" title="视频制作"></a>视频制作</h3><ul><li><a href="https://2zimu.com/#/" target="_blank" rel="noopener">突字幕：在线加字幕</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04ZGQwNWY4MjVkM2QzYjdjLnBuZw?x-oss-process=image/format,png" alt="image.png"></li><li><a href="https://panzoid.com/" target="_blank" rel="noopener">Panzoid：在线片头制作</a><br><img src="/images/loading.gif" data-original="https://img-blog.csdnimg.cn/2020022714195340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMDQyMDI0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h1 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h1><h3 id="在线音乐制作"><a href="#在线音乐制作" class="headerlink" title="在线音乐制作"></a>在线音乐制作</h3><ul><li><p><a href="https://learningmusic.ableton.com/" target="_blank" rel="noopener">Get started making music</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kMWY3OGZkMDVjMDhlNWU2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://bongo.cat/" target="_blank" rel="noopener">Bongo Cat：音乐猫</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jNjYxYTE2ODJlYjQ5MmM5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.madeon.fr/adventuremachine/?t=1,10,26,35" target="_blank" rel="noopener">Madeon：音乐制作</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zMjQ1YzNhZGVjMjQ4MjY4LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://www.autopiano.cn/" target="_blank" rel="noopener">自由钢琴</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1mMmE4OGZiNmY5NzhhNjMwLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="音频处理"><a href="#音频处理" class="headerlink" title="音频处理"></a>音频处理</h3><ul><li><p><a href="https://melody.ml/" target="_blank" rel="noopener">音乐分轨：AI伴奏人声分离</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1hMzEwMmJlNzEwODdhZWVmLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://asoftmurmur.com/" target="_blank" rel="noopener">背景音合成器</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02YTI2Mjg5MWUzN2U0ZTY2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="音乐播放器"><a href="#音乐播放器" class="headerlink" title="音乐播放器"></a>音乐播放器</h3><ul><li><a href="http://listen1.github.io/listen1/" target="_blank" rel="noopener">listen1：多平台集成检索</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0xNThmM2VjOGFlZDA3MGU0LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul><li><a href="https://sonniss.com/" target="_blank" rel="noopener">免费游戏音效下载</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kMmRjMDdkMTA5NjVlODM2LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h1><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><ul><li><p><a href="https://taiko.bui.pm/" target="_blank" rel="noopener">太鼓达人</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zYmRiNmRhMjBkNTRlYmVjLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://nazo.one-story.cn/" target="_blank" rel="noopener">Nazo Game：解谜</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1jMGM3ODE0OTZmYjM2ODFhLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://cavalierchallenge.com/" target="_blank" rel="noopener">Cavalier：在线游戏</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0yYjllOTllNjNiNTI1MGMyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://nexus.leagueoflegends.com/en-us/" target="_blank" rel="noopener">Nexus</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04MTI5ZDZiYzU4ODRiODNjLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://pos.biborg.com/fr/" target="_blank" rel="noopener">POS</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi00Njk0YzkxYWMzNDE3OGI5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><ul><li><p><a href="http://www.shushubuyue.net/#" target="_blank" rel="noopener">叔叔不约：匿名聊天</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02OGUzOTNiZTYxNWU5ZDViLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://touchpianist.com/" target="_blank" rel="noopener">Touch Pianist</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04Y2RjYTNjMGFhYTJmMWE2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h1 id="参观"><a href="#参观" class="headerlink" title="参观"></a>参观</h1><h3 id="会议"><a href="#会议" class="headerlink" title="会议"></a>会议</h3><ul><li><a href="http://www.eshow365.com/" target="_blank" rel="noopener">E展网：获取各种博览会参观信息</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1lMWQ2YTJhMTc1OTg1NTExLnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h1><h3 id="实体餐品"><a href="#实体餐品" class="headerlink" title="实体餐品"></a>实体餐品</h3><ul><li><p><a href="https://www.dxomark.com/" target="_blank" rel="noopener">Dxomark：摄影产品</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03ZjA5NTEwYzg1ZjNjNzZkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://sf.taobao.com/?spm=a213w.7398504.sfhead2014.2.9vuB5l&amp;current=index" target="_blank" rel="noopener">司法拍卖</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04OGRiNzZhY2UyYWMyZWEyLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://auction.jd.com/haiguan.html" target="_blank" rel="noopener">京东拍卖</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0wMmYxMmE5MTNlZWYxZDk1LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><ul><li><a href="http://adobe.v404.cn/adobe/" target="_blank" rel="noopener">Adobe全套</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1hZmI5MzAwMGFjZjBjMDg3LnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="趣味"><a href="#趣味" class="headerlink" title="趣味"></a>趣味</h1><h3 id="有趣"><a href="#有趣" class="headerlink" title="有趣"></a>有趣</h3><ul><li><p><a href="http://www.bigpixel.cn/index.html" target="_blank" rel="noopener">大像素：千亿像素看中国各地全景图</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0yYWZlZDE2ZTRlYWM4ZjNkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://artbreeder.com/" target="_blank" rel="noopener">AI融合</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05NWI0ODU0OWZkZGI2Zjk2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://humanbenchmark.com/" target="_blank" rel="noopener">人类测试</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kZjMzNDE5Njc2ZTk4MzE2LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://userinyerface.com/game.html" target="_blank" rel="noopener">反人类UI</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1iYjU0OWY3ZTVkMDQ0M2M5LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://neave.com/" target="_blank" rel="noopener">Neave Interactive：在线有趣的应用</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi04N2IxM2MyOTVjZjYzNzY0LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://timelineofearth.com/" target="_blank" rel="noopener">地球时间</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi02Mzc0M2Y3MzM2YTI5Y2U3LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="https://zh.forvo.com/user/hikari1/pronounced-words/page-2/" target="_blank" rel="noopener">学说话</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi05YWY1NjliMTBkODJhOTg0LnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://www.ro.me/" target="_blank" rel="noopener">RoMe</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03OTA2MTZiNGE4Zjc5MTFkLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li><li><p><a href="http://burymewithmymoney.com/" target="_blank" rel="noopener">bury me with my money</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi03MTM0MmI2MDlhYzBjNDkzLnBuZw?x-oss-process=image/format,png" alt="image.png"></p></li></ul><h3 id="神秘"><a href="#神秘" class="headerlink" title="神秘"></a>神秘</h3><ul><li><a href="https://resn.co.nz/#" target="_blank" rel="noopener">Resn：首次加载较慢</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi1kMzgxZGFiMDY4MzZlM2VhLnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><h1 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h1><ul><li><a href="https://www.wuxiaworld.com/" target="_blank" rel="noopener">武侠世界</a><br><img src="/images/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDA5MzY2Mi0zZTgxMzUxNDA4NmQ4YmNjLnBuZw?x-oss-process=image/format,png" alt="image.png"></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Share </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/helloworld.html"/>
      <url>/posts/helloworld.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
