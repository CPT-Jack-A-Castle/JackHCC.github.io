<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Python全解析, JackHCC">
    <meta name="description" content="Python3.10语言手册">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Python全解析 | JackHCC</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my.css">
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="JackHCC" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-hopscotch.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JackHCC</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">JackHCC</div>
        <div class="logo-desc">
            
            Make the world betterrrr!!!
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JackHCC/JackHCC.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JackHCC/JackHCC.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/1.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Python全解析</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 30px;
        bottom: 146px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Python/">
                                <span class="chip bg-color">Python</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Language/" class="post-category">
                                Language
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-11-08
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-11-08
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    133.8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    516 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Python-基础教程"><a href="#Python-基础教程" class="headerlink" title="Python 基础教程"></a>Python 基础教程</h1><h2 id="1-Python-解释器"><a href="#1-Python-解释器" class="headerlink" title="1. Python 解释器"></a>1. Python 解释器</h2><h3 id="调用解释器"><a href="#调用解释器" class="headerlink" title="调用解释器"></a>调用解释器</h3><p>Python 解释器在可用的机器上通常安装于 <code>/usr/local/bin/python3.10</code> 路径下；将 <code>/usr/local/bin</code> 加入你的 Unix 终端的搜索路径就可以通过键入以下命令来启动它:</p>
<pre><code>python3.10</code></pre><p>这样，就可以在 shell 中运行 Python 了。因为可以选择安装目录，解释器也有可能安装在别的位置；如果还不明白，就去问问身边的 Python 大神或系统管理员。（例如，常见备选路径还有 <code>/usr/local/python</code>。）</p>
<p>在 Windows 机器上当你从 Microsoft Store 安装 Python 之后，<code>python3.10</code> 命令将可使用。 如果你安装了 py.exe 启动器，你将可以使用 <code>py</code> 命令。</p>
<p>在主提示符中，输入文件结束符（Unix 里是 Control-D，Windows 里是 Control-Z），就会退出解释器，退出状态码为 0。如果不能退出，还可以输入这个命令：<code>quit()</code>。</p>
<p>在支持 <a href="https://tiswww.case.edu/php/chet/readline/rltop.html" target="_blank" rel="noopener">GNU Readline</a> 库的系统中，解释器的行编辑功能包括交互式编辑、历史替换、代码补全等。检测是否支持命令行编辑最快速的方式是，在首次出现 Python 提示符时，输入 Control-P。听到“哔”提示音，说明支持行编辑；如果没有反应，或回显了 <code>^P</code>，则说明不支持行编辑；只能用退格键删除当前行的字符。</p>
<p>解释器的操作方式类似 Unix Shell：用与 tty 设备关联的标准输入调用时，可以交互式地读取和执行命令；以文件名参数，或标准输入文件调用时，则读取并执行文件中的 <em>脚本</em>。</p>
<p>启动解释器的另一种方式是 <code>python -c command [arg] ...</code>，这与 shell 的 <code>-c</code> 选项类似，其中，<em>command</em> 需换成要执行的语句。由于 Python 语句经常包含空格等被 shell 特殊对待的字符，一般情况下，建议用单引号标注整个 <em>command</em>。</p>
<p>Python 模块也可以当作脚本使用。输入：<code>python -m module [arg] ...</code>，会执行 <em>module</em> 的源文件，这跟在命令行把路径写全了一样。</p>
<p>在交互模式下运行脚本文件，只要在脚本名称参数前，加上选项 <code>-i</code> 就可以了。</p>
<h4 id="传入参数"><a href="#传入参数" class="headerlink" title="传入参数"></a>传入参数</h4><p>解释器读取命令行参数，把脚本名与其他参数转化为字符串列表存到 <code>sys</code> 模块的 <code>argv</code> 变量里。执行 <code>import sys</code>，可以导入这个模块，并访问该列表。该列表最少有一个元素；未给定输入参数时，<code>sys.argv[0]</code> 是空字符串。给定脚本名是 <code>'-'</code> （标准输入）时，<code>sys.argv[0]</code> 是 <code>'-'</code>。使用 <code>-c</code> <em>command</em> 时，<code>sys.argv[0]</code> 是 <code>'-c'</code>。如果使用选项 <code>-m</code> <em>module*，<code>sys.argv[0]</code> 就是包含目录的模块全名。解释器不处理 <code>-c</code> *command</em> 或 <code>-m</code> <em>module</em> 之后的选项，而是直接留在 <code>sys.argv</code> 中由命令或模块来处理。</p>
<h4 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h4><p>在终端（tty）输入并执行指令时，解释器在 <em>交互模式（interactive mode）</em> 中运行。在这种模式中，会显示 <em>主提示符</em>，提示输入下一条指令，主提示符通常用三个大于号（<code>&gt;&gt;&gt;</code>）表示；输入连续行时，显示 <em>次要提示符</em>，默认是三个点（<code>...</code>）。进入解释器时，首先显示欢迎信息、版本信息、版权声明，然后才是提示符：</p>
<pre><code>$ python3.10
Python 3.10 (default, June 4 2019, 09:25:04)
[GCC 4.8.2] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;</code></pre><p>输入多行架构的语句时，要用连续行。以 <code>if</code> 为例：</p>
<pre><code>&gt;&gt;&gt; the_world_is_flat = True
&gt;&gt;&gt; if the_world_is_flat:
...     print("Be careful not to fall off!")
...
Be careful not to fall off!</code></pre><h3 id="解释器的运行环境"><a href="#解释器的运行环境" class="headerlink" title="解释器的运行环境"></a>解释器的运行环境</h3><h4 id="源文件的字符编码"><a href="#源文件的字符编码" class="headerlink" title="源文件的字符编码"></a>源文件的字符编码</h4><p>默认情况下，Python 源码文件的编码是 UTF-8。这种编码支持世界上大多数语言的字符，可以用于字符串字面值、变量、函数名及注释 —— 尽管标准库只用常规的 ASCII 字符作为变量名或函数名，可移植代码都应遵守此约定。要正确显示这些字符，编辑器必须能识别 UTF-8 编码，而且必须使用支持文件中所有字符的字体。</p>
<p>如果不使用默认编码，则要声明文件的编码，文件的 <em>第一</em> 行要写成特殊注释。句法如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: encoding -*-</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中，<em>encoding</em> 可以是 Python 支持的任意一种 <code>codecs</code>。</p>
<p>比如，声明使用 Windows-1252 编码，源码文件要写成：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: cp1252 -*-</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><em>第一行</em> 的规则也有一种例外情况，源码以 UNIX “shebang” 行 开头。此时，编码声明要写在文件的第二行。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python3</span>
<span class="token comment" spellcheck="true"># -*- coding: cp1252 -*-</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Unix 系统中，为了不与同时安装的 Python 2.x 冲突，Python 3.x 解释器默认安装的执行文件名不是 <code>python</code>。</p>
<h2 id="2-Python-速览"><a href="#2-Python-速览" class="headerlink" title="2. Python 速览"></a>2. Python 速览</h2><p>下面的例子以是否显示提示符（&gt;&gt;&gt; 与 …）区分输入与输出：输入例子中的代码时，要键入以提示符开头的行中提示符后的所有内容；未以提示符开头的行是解释器的输出。注意，例子中的某行出现的第二个提示符是用来结束多行命令的，此时，要键入一个空白行。</p>
<p>本手册中的许多例子，甚至交互式命令都包含注释。Python 注释以 <code>#</code> 开头，直到该物理行结束。注释可以在行开头，或空白符与代码之后，但不能在字符串里面。字符串中的 # 号就是 # 号。注释用于阐明代码，Python 不解释注释，键入例子时，可以不输入注释。</p>
<p>示例如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># this is the first comment</span>
spam <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># and this is the second comment</span>
          <span class="token comment" spellcheck="true"># ... and now a third!</span>
text <span class="token operator">=</span> <span class="token string">"# This is not a comment because it's inside quotes."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Python-用作计算器"><a href="#Python-用作计算器" class="headerlink" title="Python 用作计算器"></a>Python 用作计算器</h3><p>现在，尝试一些简单的 Python 命令。启动解释器，等待主提示符（<code>&gt;&gt;&gt;</code> ）出现。</p>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>解释器像一个简单的计算器：输入表达式，就会给出答案。表达式的语法很直接：运算符 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 的用法和其他大部分语言一样（比如，Pascal 或 C）；括号 (<code>()</code>) 用来分组。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span>
<span class="token number">4</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token number">50</span> <span class="token operator">-</span> <span class="token number">5</span><span class="token operator">*</span><span class="token number">6</span>
<span class="token number">20</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">50</span> <span class="token operator">-</span> <span class="token number">5</span><span class="token operator">*</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">4</span>
<span class="token number">5.0</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token number">8</span> <span class="token operator">/</span> <span class="token number">5</span>  <span class="token comment" spellcheck="true"># division always returns a floating point number</span>
<span class="token number">1.6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>整数（如，<code>2</code>、<code>4</code>、<code>20</code> ）的类型是 <code>int</code>，带小数（如，<code>5.0</code>、<code>1.6</code> ）的类型是 <code>float</code>。本教程后半部分将介绍更多数字类型。</p>
<p>除法运算（<code>/</code>）返回浮点数。用 <code>//</code> 运算符执行 floor division 的结果是整数（忽略小数）；计算余数用 <code>%</code>：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token number">17</span> <span class="token operator">/</span> <span class="token number">3</span>  <span class="token comment" spellcheck="true"># classic division returns a float</span>
<span class="token number">5.666666666666667</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token number">17</span> <span class="token operator">//</span> <span class="token number">3</span>  <span class="token comment" spellcheck="true"># floor division discards the fractional part</span>
<span class="token number">5</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token number">17</span> <span class="token operator">%</span> <span class="token number">3</span>  <span class="token comment" spellcheck="true"># the % operator returns the remainder of the division</span>
<span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">2</span>  <span class="token comment" spellcheck="true"># floored quotient * divisor + remainder</span>
<span class="token number">17</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Python 用 <code>**</code> 运算符计算乘方：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token number">5</span> <span class="token operator">**</span> <span class="token number">2</span>  <span class="token comment" spellcheck="true"># 5 squared</span>
<span class="token number">25</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">7</span>  <span class="token comment" spellcheck="true"># 2 to the power of 7</span>
<span class="token number">128</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>等号（<code>=</code>）用于给变量赋值。赋值后，下一个交互提示符的位置不显示任何结果：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> width <span class="token operator">=</span> <span class="token number">20</span>
<span class="token operator">>></span><span class="token operator">></span> height <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">9</span>
<span class="token operator">>></span><span class="token operator">></span> width <span class="token operator">*</span> height
<span class="token number">900</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果变量未定义（即，未赋值），使用该变量会提示错误：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> n  <span class="token comment" spellcheck="true"># try to access an undefined variable</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
NameError<span class="token punctuation">:</span> name <span class="token string">'n'</span> <span class="token keyword">is</span> <span class="token operator">not</span> defined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>Python 全面支持浮点数；混合类型运算数的运算会把整数转换为浮点数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">3.75</span> <span class="token operator">-</span> <span class="token number">1</span>
<span class="token number">14.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>交互模式下，上次输出的表达式会赋给变量 <code>_</code>。把 Python 当作计算器时，用该变量实现下一步计算更简单，例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> tax <span class="token operator">=</span> <span class="token number">12.5</span> <span class="token operator">/</span> <span class="token number">100</span>
<span class="token operator">>></span><span class="token operator">></span> price <span class="token operator">=</span> <span class="token number">100.50</span>
<span class="token operator">>></span><span class="token operator">></span> price <span class="token operator">*</span> tax
<span class="token number">12.5625</span>
<span class="token operator">>></span><span class="token operator">></span> price <span class="token operator">+</span> _
<span class="token number">113.0625</span>
<span class="token operator">>></span><span class="token operator">></span> round<span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token number">113.06</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最好把该变量当作只读类型。不要为它显式赋值，否则会创建一个同名独立局部变量，该变量会用它的魔法行为屏蔽内置变量。</p>
<p>除了 <code>int</code> 和 <code>float</code>，Python 还支持其他数字类型，例如 <code>Decimal</code> 或 <code>Fraction</code>。Python 还内置支持 复数，后缀 <code>j</code> 或 <code>J</code> 用于表示虚数（例如 <code>3+5j</code> ）。</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>除了数字，Python 还可以操作字符串。字符串有多种表现形式，用单引号（<code>'……'</code>）或双引号（<code>"……"</code>）标注的结果相同 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/c3d9757e793a6825.md#id4" target="_blank" rel="noopener">2</a>。反斜杠 <code>\</code> 用于转义：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'spam eggs'</span>  <span class="token comment" spellcheck="true"># single quotes</span>
<span class="token string">'spam eggs'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'doesn\'t'</span>  <span class="token comment" spellcheck="true"># use \' to escape the single quote...</span>
<span class="token string">"doesn't"</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">"doesn't"</span>  <span class="token comment" spellcheck="true"># ...or use double quotes instead</span>
<span class="token string">"doesn't"</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'"Yes," they said.'</span>
<span class="token string">'"Yes," they said.'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">"\"Yes,\" they said."</span>
<span class="token string">'"Yes," they said.'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'"Isn\'t," they said.'</span>
<span class="token string">'"Isn\'t," they said.'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>交互式解释器会为输出的字符串加注引号，特殊字符使用反斜杠转义。虽然，有时输出的字符串看起来与输入的字符串不一样（外加的引号可能会改变），但两个字符串是相同的。如果字符串中有单引号而没有双引号，该字符串外将加注双引号，反之，则加注单引号。<code>print()</code> 函数输出的内容更简洁易读，它会省略两边的引号，并输出转义后的特殊字符：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'"Isn\'t," they said.'</span>
<span class="token string">'"Isn\'t," they said.'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'"Isn\'t," they said.'</span><span class="token punctuation">)</span>
<span class="token string">"Isn't,"</span> they said<span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">'First line.\nSecond line.'</span>  <span class="token comment" spellcheck="true"># \n means newline</span>
<span class="token operator">>></span><span class="token operator">></span> s  <span class="token comment" spellcheck="true"># without print(), \n is included in the output</span>
<span class="token string">'First line.\nSecond line.'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># with print(), \n produces a new line</span>
First line<span class="token punctuation">.</span>
Second line<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果不希望前置 <code>\</code> 的字符转义成特殊字符，可以使用 <em>原始字符串</em>，在引号前添加 <code>r</code> 即可：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'C:\some\name'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># here \n means newline!</span>
C<span class="token punctuation">:</span>\some
ame
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token string">'C:\some\name'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># note the r before the quote</span>
C<span class="token punctuation">:</span>\some\name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>字符串字面值可以实现跨行连续输入。实现方式是用三引号：<code>"""..."""</code> 或 <code>'''...'''</code>，字符串行尾会自动加上回车换行，如果不需要回车换行，在行尾添加 <code>\</code> 即可。示例如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token triple-quoted-string string">"""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
"""</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出如下（注意，第一行没有换行）：</p>
<pre class="line-numbers language-python"><code class="language-python">Usage<span class="token punctuation">:</span> thingy <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span>
     <span class="token operator">-</span>h                        Display this usage message
     <span class="token operator">-</span>H hostname               Hostname to connect to<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>字符串可以用 <code>+</code> 合并（粘到一起），也可以用 <code>*</code> 重复：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># 3 times 'un', followed by 'ium'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token string">'un'</span> <span class="token operator">+</span> <span class="token string">'ium'</span>
<span class="token string">'unununium'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>相邻的两个或多个 <em>字符串字面值</em> （引号标注的字符）会自动合并：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Py'</span> <span class="token string">'thon'</span>
<span class="token string">'Python'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>拆分长字符串时，这个功能特别实用：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> text <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'Put several strings within parentheses '</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token string">'to have them joined together.'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> text
<span class="token string">'Put several strings within parentheses to have them joined together.'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这项功能只能用于两个字面值，不能用于变量或表达式：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> prefix <span class="token operator">=</span> <span class="token string">'Py'</span>
<span class="token operator">>></span><span class="token operator">></span> prefix <span class="token string">'thon'</span>  <span class="token comment" spellcheck="true"># can't concatenate a variable and a string literal</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span>
    prefix <span class="token string">'thon'</span>
                <span class="token operator">^</span>
SyntaxError<span class="token punctuation">:</span> invalid syntax
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token string">'un'</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">'ium'</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span>
    <span class="token punctuation">(</span><span class="token string">'un'</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">'ium'</span>
                   <span class="token operator">^</span>
SyntaxError<span class="token punctuation">:</span> invalid syntax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>合并多个变量，或合并变量与字面值，要用 <code>+</code>：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> prefix <span class="token operator">+</span> <span class="token string">'thon'</span>
<span class="token string">'Python'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>字符串支持 <em>索引</em> （下标访问），第一个字符的索引是 0。单字符没有专用的类型，就是长度为一的字符串：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> word <span class="token operator">=</span> <span class="token string">'Python'</span>
<span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># character in position 0</span>
<span class="token string">'P'</span>
<span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># character in position 5</span>
<span class="token string">'n'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>索引还支持负数，用负数索引时，从右边开始计数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># last character</span>
<span class="token string">'n'</span>
<span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># second-last character</span>
<span class="token string">'o'</span>
<span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token string">'P'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，-0 和 0 一样，因此，负数索引从 -1 开始。</p>
<p>除了索引，字符串还支持 <em>切片<em>。索引可以提取单个字符，</em>切片</em> 则提取子字符串：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># characters from position 0 (included) to 2 (excluded)</span>
<span class="token string">'Py'</span>
<span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># characters from position 2 (included) to 5 (excluded)</span>
<span class="token string">'tho'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>切片索引的默认值很有用；省略开始索引时，默认值为 0，省略结束索引时，默认为到字符串的结尾：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># character from the beginning to position 2 (excluded)</span>
<span class="token string">'Py'</span>
<span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># characters from position 4 (included) to the end</span>
<span class="token string">'on'</span>
<span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># characters from the second-last (included) to the end</span>
<span class="token string">'on'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，输出结果包含切片开始，但不包含切片结束。因此，<code>s[:i] + s[i:]</code> 总是等于 <code>s</code>：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> word<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token string">'Python'</span>
<span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">+</span> word<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token string">'Python'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>还可以这样理解切片，索引指向的是字符 <em>之间</em> ，第一个字符的左侧标为 0，最后一个字符的右侧标为 <em>n</em> ，<em>n</em> 是字符串长度。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"> <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
 <span class="token operator">|</span> P <span class="token operator">|</span> y <span class="token operator">|</span> t <span class="token operator">|</span> h <span class="token operator">|</span> o <span class="token operator">|</span> n <span class="token operator">|</span>
 <span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
 <span class="token number">0</span>   <span class="token number">1</span>   <span class="token number">2</span>   <span class="token number">3</span>   <span class="token number">4</span>   <span class="token number">5</span>   <span class="token number">6</span>
<span class="token operator">-</span><span class="token number">6</span>  <span class="token operator">-</span><span class="token number">5</span>  <span class="token operator">-</span><span class="token number">4</span>  <span class="token operator">-</span><span class="token number">3</span>  <span class="token operator">-</span><span class="token number">2</span>  <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一行数字是字符串中索引 0…6 的位置，第二行数字是对应的负数索引位置。<em>i</em> 到 <em>j</em> 的切片由 <em>i</em> 和 <em>j</em> 之间所有对应的字符组成。</p>
<p>对于使用非负索引的切片，如果两个索引都不越界，切片长度就是起止索引之差。例如， <code>word[1:3]</code> 的长度是 2。</p>
<p>索引越界会报错：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># the word only has 6 characters</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
IndexError<span class="token punctuation">:</span> string index out of range<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是，切片会自动处理越界索引：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">42</span><span class="token punctuation">]</span>
<span class="token string">'on'</span>
<span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token number">42</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>Python 字符串不能修改，是 immutable 的。因此，为字符串中某个索引位置赋值会报错：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'J'</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> <span class="token string">'str'</span> object does <span class="token operator">not</span> support item assignment
<span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'py'</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> <span class="token string">'str'</span> object does <span class="token operator">not</span> support item assignment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要生成不同的字符串，应新建一个字符串：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'J'</span> <span class="token operator">+</span> word<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token string">'Jython'</span>
<span class="token operator">>></span><span class="token operator">></span> word<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">'py'</span>
<span class="token string">'Pypy'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>内置函数 <code>len()</code> 返回字符串的长度：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">'supercalifragilisticexpialidocious'</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token number">34</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>Python 支持多种 <em>复合</em> 数据类型，可将不同值组合在一起。最常用的 <em>列表</em> ，是用方括号标注，逗号分隔的一组值。<em>列表</em> 可以包含不同类型的元素，但一般情况下，各个元素的类型相同：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> squares <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> squares
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>和字符串（及其他内置 sequence 类型）一样，列表也支持索引和切片：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> squares<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># indexing returns the item</span>
<span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> squares<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">25</span>
<span class="token operator">>></span><span class="token operator">></span> squares<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># slicing returns a new list</span>
<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>切片操作返回包含请求元素的新列表。以下切片操作会返回列表的 浅拷贝：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> squares<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>列表还支持合并操作：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> squares <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>与 immutable 字符串不同, 列表是 mutable 类型，其内容可以改变：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> cubes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token number">65</span><span class="token punctuation">,</span> <span class="token number">125</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># something's wrong here</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token number">4</span> <span class="token operator">**</span> <span class="token number">3</span>  <span class="token comment" spellcheck="true"># the cube of 4 is 64, not 65!</span>
<span class="token number">64</span>
<span class="token operator">>></span><span class="token operator">></span> cubes<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">64</span>  <span class="token comment" spellcheck="true"># replace the wrong value</span>
<span class="token operator">>></span><span class="token operator">></span> cubes
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">125</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>append()</code> <em>方法</em> 可以在列表结尾添加新元素（详见后文）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> cubes<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">216</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># add the cube of 6</span>
<span class="token operator">>></span><span class="token operator">></span> cubes<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">7</span> <span class="token operator">**</span> <span class="token number">3</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># and the cube of 7</span>
<span class="token operator">>></span><span class="token operator">></span> cubes
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">125</span><span class="token punctuation">,</span> <span class="token number">216</span><span class="token punctuation">,</span> <span class="token number">343</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>为切片赋值可以改变列表大小，甚至清空整个列表：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> letters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> letters
<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># replace some values</span>
<span class="token operator">>></span><span class="token operator">></span> letters<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> letters
<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># now remove them</span>
<span class="token operator">>></span><span class="token operator">></span> letters<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> letters
<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># clear the list by replacing all the elements with an empty list</span>
<span class="token operator">>></span><span class="token operator">></span> letters<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> letters
<span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>内置函数 <code>len()</code> 也支持列表：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> letters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>letters<span class="token punctuation">)</span>
<span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>还可以嵌套列表（创建包含其他列表的列表），例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> n <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> n<span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> x
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token string">'b'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="走向编程的第一步"><a href="#走向编程的第一步" class="headerlink" title="走向编程的第一步"></a>走向编程的第一步</h3><p>当然，Python 还可以完成比二加二更复杂的任务。 例如，可以编写 <a href="https://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="noopener">斐波那契数列</a> 的初始子序列，如下所示：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Fibonacci series:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true"># the sum of two elements defines the next</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">while</span> a <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a<span class="token operator">+</span>b
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">0</span>
<span class="token number">1</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
<span class="token number">5</span>
<span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>本例引入了几个新功能。</p>
<ul>
<li><p>第一行中的 <em>多重赋值</em>：变量 <code>a</code> 和 <code>b</code> 同时获得新值 0 和 1。最后一行又用了一次多重赋值，这体现在右表达式在赋值前就已经求值了。右表达式求值顺序为从左到右。</p>
</li>
<li><p><code>while</code> 循环只要条件（这里指：<code>a &lt; 10</code>）保持为真就会一直执行。Python 和 C 一样，任何非零整数都为真，零为假。这个条件也可以是字符串或列表的值，事实上，任何序列都可以；长度非零就为真，空序列则为假。示例中的判断只是最简单的比较。比较操作符的标准写法和 C 语言一样： <code>&lt;</code> （小于）、 <code>&gt;</code> （大于）、 <code>==</code> （等于）、 <code>&lt;=</code> （小于等于)、 <code>&gt;=</code> （大于等于）及 <code>!=</code> （不等于）。</p>
</li>
<li><p><em>循环体</em> 是 <em>缩进的</em> ：缩进是 Python 组织语句的方式。在交互式命令行里，得为每个缩输入制表符或空格。使用文本编辑器可以实现更复杂的输入方式；所有像样的文本编辑器都支持自动缩进。交互式输入复合语句时, 要在最后输入空白行表示结束（因为解析器不知道哪一行代码是最后一行）。注意，同一块语句的每一行的缩进相同。</p>
</li>
<li><p><code>print()</code> 函数输出给定参数的值。与表达式不同（比如，之前计算器的例子），它能处理多个参数，包括浮点数与字符串。它输出的字符串不带引号，且各参数项之间会插入一个空格，这样可以实现更好的格式化操作：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> i <span class="token operator">=</span> <span class="token number">256</span><span class="token operator">*</span><span class="token number">256</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'The value of i is'</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
The value of i <span class="token keyword">is</span> <span class="token number">65536</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>关键字参数 <em>end</em> 可以取消输出后面的换行, 或用另一个字符串结尾：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">while</span> a <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">','</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a<span class="token operator">+</span>b
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">55</span><span class="token punctuation">,</span><span class="token number">89</span><span class="token punctuation">,</span><span class="token number">144</span><span class="token punctuation">,</span><span class="token number">233</span><span class="token punctuation">,</span><span class="token number">377</span><span class="token punctuation">,</span><span class="token number">610</span><span class="token punctuation">,</span><span class="token number">987</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>注：</p>
<ul>
<li><code>**</code> 比 <code>-</code> 的优先级更高, 所以 <code>-3**2</code> 会被解释成 <code>-(3**2)</code> ，因此，结果是 <code>-9</code>。要避免这个问题，并且得到 <code>9</code>, 可以用 <code>(-3)**2</code>。</li>
<li>和其他语言不一样，特殊字符如 <code>\n</code> 在单引号（<code>'...'</code>）和双引号（<code>"..."</code>）里的意义一样。这两种引号唯一的区别是，不需要在单引号里转义双引号 <code>"</code>，但必须把单引号转义成 <code>\'</code>，反之亦然。</li>
</ul>
<h2 id="3-流程控制工具"><a href="#3-流程控制工具" class="headerlink" title="3. 流程控制工具"></a>3. 流程控制工具</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a><code>if</code> 语句</h3><p>最让人耳熟能详的应该是 <code>if</code> 语句。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"Please enter an integer: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Please enter an integer<span class="token punctuation">:</span> <span class="token number">42</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     x <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Negative changed to zero'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">elif</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Zero'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">elif</span> x <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Single'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'More'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
More<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>if 语句包含零个或多个 <code>elif</code> 子句，及可选的 <code>else</code> 子句。关键字 ‘<code>elif</code>‘ 是 ‘else if’ 的缩写，适用于避免过多的缩进。可以把 <code>if</code> … <code>elif</code> … <code>elif</code> … 序列看作是其他语言中 <code>switch</code> 或 <code>case</code> 语句的替代品。</p>
<p>如果你要将同一个值与多个常量进行比较，或是要检查特定类型或属性，你可能会发现 <code>match</code> 语句是很有用的。 </p>
<h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a><code>for</code> 语句</h3><p>Python 的 <code>for</code> 语句与 C 或 Pascal 中的不同。Python 的 <code>for</code> 语句不迭代算术递增数值（如 Pascal），或是给予用户定义迭代步骤和暂停条件的能力（如 C），而是迭代列表或字符串等任意序列，元素的迭代顺序与在序列中出现的顺序一致。 例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Measure some strings:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> words <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'cat'</span><span class="token punctuation">,</span> <span class="token string">'window'</span><span class="token punctuation">,</span> <span class="token string">'defenestrate'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> w <span class="token keyword">in</span> words<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> len<span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
cat <span class="token number">3</span>
window <span class="token number">6</span>
defenestrate <span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>遍历某个集合的同时修改该集合的内容，很难获取想要的结果。要在遍历时修改集合的内容，应该遍历该集合的副本或创建新的集合：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Create a sample collection</span>
users <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Hans'</span><span class="token punctuation">:</span> <span class="token string">'active'</span><span class="token punctuation">,</span> <span class="token string">'Éléonore'</span><span class="token punctuation">:</span> <span class="token string">'inactive'</span><span class="token punctuation">,</span> <span class="token string">'景太郎'</span><span class="token punctuation">:</span> <span class="token string">'active'</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true"># Strategy:  Iterate over a copy</span>
<span class="token keyword">for</span> user<span class="token punctuation">,</span> status <span class="token keyword">in</span> users<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> status <span class="token operator">==</span> <span class="token string">'inactive'</span><span class="token punctuation">:</span>
        <span class="token keyword">del</span> users<span class="token punctuation">[</span>user<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># Strategy:  Create a new collection</span>
active_users <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">for</span> user<span class="token punctuation">,</span> status <span class="token keyword">in</span> users<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> status <span class="token operator">==</span> <span class="token string">'active'</span><span class="token punctuation">:</span>
        active_users<span class="token punctuation">[</span>user<span class="token punctuation">]</span> <span class="token operator">=</span> status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range() 函数"></a><code>range()</code> 函数</h3><p>内置函数 <code>range()</code> 常用于遍历数字序列，该函数可以生成算术级数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">0</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
<span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>生成的序列不包含给定的终止数值；<code>range(10)</code> 生成 10 个值，这是一个长度为 10 的序列，其中的元素索引都是合法的。range 可以不从 0 开始，还可以按指定幅度递增（递增幅度称为 ‘步进’，支持负数）：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">70</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>range()</code> 和 <code>len()</code> 组合在一起，可以按索引迭代序列：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Mary'</span><span class="token punctuation">,</span> <span class="token string">'had'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'little'</span><span class="token punctuation">,</span> <span class="token string">'lamb'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">0</span> Mary
<span class="token number">1</span> had
<span class="token number">2</span> a
<span class="token number">3</span> little
<span class="token number">4</span> lamb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不过，大多数情况下，<code>enumerate()</code> 函数更便捷 。</p>
<p>如果只输出 range，会出现意想不到的结果：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>range()</code> 返回对象的操作和列表很像，但其实这两种对象不是一回事。迭代时，该对象基于所需序列返回连续项，并没有生成真正的列表，从而节省了空间。</p>
<p>这种对象称为可迭代对象 iterable，函数或程序结构可通过该对象获取连续项，直到所有元素全部迭代完毕。<code>for</code> 语句就是这样的架构，<code>sum()</code> 是一种把可迭代对象作为参数的函数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sum<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 0 + 1 + 2 + 3</span>
<span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>下文将介绍更多返回可迭代对象或把可迭代对象当作参数的函数。 </p>
<h3 id="循环中的-break、continue-语句及-else-子句"><a href="#循环中的-break、continue-语句及-else-子句" class="headerlink" title="循环中的 break、continue 语句及 else 子句"></a>循环中的 <code>break</code>、<code>continue</code> 语句及 <code>else</code> 子句</h3><p><code>break</code> 语句和 C 中的类似，用于跳出最近的 <code>for</code> 或 <code>while</code> 循环。</p>
<p>循环语句支持 <code>else</code> 子句；<code>for</code> 循环中，可迭代对象中的元素全部循环完毕时，或 <code>while</code> 循环的条件为假时，执行该子句；<code>break</code> 语句终止循环时，不执行该子句。 请看下面这个查找素数的循环示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> n <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">if</span> n <span class="token operator">%</span> x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token string">'equals'</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">,</span> n<span class="token operator">//</span>x<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">break</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token comment" spellcheck="true"># loop fell through without finding a factor</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token string">'is a prime number'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">2</span> <span class="token keyword">is</span> a prime number
<span class="token number">3</span> <span class="token keyword">is</span> a prime number
<span class="token number">4</span> equals <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span>
<span class="token number">5</span> <span class="token keyword">is</span> a prime number
<span class="token number">6</span> equals <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">3</span>
<span class="token number">7</span> <span class="token keyword">is</span> a prime number
<span class="token number">8</span> equals <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">4</span>
<span class="token number">9</span> equals <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（没错，这段代码就是这么写。仔细看：<code>else</code> 子句属于 <code>for</code> 循环，<strong>不属于</strong> <code>if</code> 语句。）</p>
<p>与 <code>if</code> 语句相比，循环的 <code>else</code> 子句更像 <code>try</code> 的 <code>else</code> 子句： <code>try</code> 的 <code>else</code> 子句在未触发异常时执行，循环的 <code>else</code> 子句则在未运行 <code>break</code> 时执行。</p>
<p><code>continue</code> 语句也借鉴自 C 语言，表示继续执行循环的下一次迭代：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> num <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> num <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Found an even number"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">continue</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Found an odd number"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Found an even number <span class="token number">2</span>
Found an odd number <span class="token number">3</span>
Found an even number <span class="token number">4</span>
Found an odd number <span class="token number">5</span>
Found an even number <span class="token number">6</span>
Found an odd number <span class="token number">7</span>
Found an even number <span class="token number">8</span>
Found an odd number <span class="token number">9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a><code>pass</code> 语句</h3><p><code>pass</code> 语句不执行任何操作。语法上需要一个语句，但程序不实际执行任何动作时，可以使用该语句。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">pass</span>  <span class="token comment" spellcheck="true"># Busy-wait for keyboard interrupt (Ctrl+C)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>下面这段代码创建了一个最小的类：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">MyEmptyClass</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">pass</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>pass</code> 还可以用作函数或条件子句的占位符，让开发者聚焦更抽象的层次。此时，程序直接忽略 <code>pass</code>：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">initlog</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">pass</span>   <span class="token comment" spellcheck="true"># Remember to implement this!</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="match-语句"><a href="#match-语句" class="headerlink" title="match 语句"></a><code>match</code> 语句</h3><p>match 语句接受一个表达式并将它的值与以一个或多个 case 语句块形式给出的一系列模式进行比较。 这在表面上很类似 C, Java 或 JavaScript (以及许多其他语言) 中的 switch 语句，但它还能够从值中提取子部分 (序列元素或对象属性) 并赋值给变量。</p>
<p>最简单的形式是将一个目标值与一个或多个字面值进行比较:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">http_error</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">:</span>
    match status<span class="token punctuation">:</span>
        case <span class="token number">400</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token string">"Bad request"</span>
        case <span class="token number">404</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token string">"Not found"</span>
        case <span class="token number">418</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token string">"I'm a teapot"</span>
        case _<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token string">"Something's wrong with the internet"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意最后一个代码块: “变量名” <code>_</code> 被作为 <em>通配符</em> 并必定会匹配成功。 如果没有任何 case 语句匹配成功，则任何分支都不会被执行。</p>
<p>你可以使用 <code>|</code> （“ or ”）在一个模式中组合几个字面值:</p>
<pre class="line-numbers language-python"><code class="language-python">case <span class="token number">401</span> <span class="token operator">|</span> <span class="token number">403</span> <span class="token operator">|</span> <span class="token number">404</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">"Not allowed"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>模式的形式可以类似于解包赋值，并可被用于绑定变量:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># point is an (x, y) tuple</span>
match point<span class="token punctuation">:</span>
    case <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Origin"</span><span class="token punctuation">)</span>
    case <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Y={y}"</span><span class="token punctuation">)</span>
    case <span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"X={x}"</span><span class="token punctuation">)</span>
    case <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"X={x}, Y={y}"</span><span class="token punctuation">)</span>
    case _<span class="token punctuation">:</span>
        <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">"Not a point"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请仔细研究此代码！ 第一个模式有两个字面值，可以看作是上面所示字面值模式的扩展。 但接下来的两个模式结合了一个字面值和一个变量，而变量 <em>绑定</em> 了一个来自目标的值 (<code>point</code>)。 第四个模式捕获了两个值，这使得它在概念上类似于解包赋值 <code>(x, y) = point</code>。</p>
<p>如果你使用类来结构化你的数据，你可以使用类名之后跟一个类似于构造器的参数列表，这样能够捕获属性放入到变量中:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">:</span>
    x<span class="token punctuation">:</span> int
    y<span class="token punctuation">:</span> int
<span class="token keyword">def</span> <span class="token function">where_is</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span><span class="token punctuation">:</span>
    match point<span class="token punctuation">:</span>
        case Point<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Origin"</span><span class="token punctuation">)</span>
        case Point<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> y<span class="token operator">=</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Y={y}"</span><span class="token punctuation">)</span>
        case Point<span class="token punctuation">(</span>x<span class="token operator">=</span>x<span class="token punctuation">,</span> y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"X={x}"</span><span class="token punctuation">)</span>
        case Point<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Somewhere else"</span><span class="token punctuation">)</span>
        case _<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Not a point"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>你可以在某些为其属性提供了排序的内置类（例如 dataclass）中使用位置参数。 你也可以通过在你的类中设置 <code>__match_args__</code> 特殊属性来为模式中的属性定义一个专门的位置。 如果它被设为 (“x”, “y”)，则以下模式均为等价的（并且都是将 <code>y</code> 属性绑定到 <code>var</code> 变量）:</p>
<pre class="line-numbers language-python"><code class="language-python">Point<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> var<span class="token punctuation">)</span>
Point<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">=</span>var<span class="token punctuation">)</span>
Point<span class="token punctuation">(</span>x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">=</span>var<span class="token punctuation">)</span>
Point<span class="token punctuation">(</span>y<span class="token operator">=</span>var<span class="token punctuation">,</span> x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>读取模式的推荐方式是将它们看做是你会在赋值操作左侧放置的内容的扩展形式，以便理解各个变量将会被设置的值。 只有单独的名称 (例如上面的 <code>var</code>) 会被 match 语句所赋值。 带点号的名称 (例如 <code>foo.bar</code>)、属性名称 (例如上面的 <code>x=</code> 和 <code>y=</code>) 或类名称 (通过其后的 “(…)” 来识别，例如上面的 <code>Point</code>) 都绝不会被赋值。</p>
<p>模式可以任意地嵌套。 例如，如果我们有一个由点组成的短列表，则可以这样匹配它:</p>
<pre class="line-numbers language-python"><code class="language-python">match points<span class="token punctuation">:</span>
    case <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"No points"</span><span class="token punctuation">)</span>
    case <span class="token punctuation">[</span>Point<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"The origin"</span><span class="token punctuation">)</span>
    case <span class="token punctuation">[</span>Point<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Single point {x}, {y}"</span><span class="token punctuation">)</span>
    case <span class="token punctuation">[</span>Point<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">,</span> Point<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> y2<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Two on the Y axis at {y1}, {y2}"</span><span class="token punctuation">)</span>
    case _<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Something else"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们可以向一个模式添加 <code>if</code> 子句，称为“守护项”。 如果守护项为假值，则 <code>match</code> 将继续尝试下一个 case 语句块。 请注意值的捕获发生在守护项被求值之前。:</p>
<pre class="line-numbers language-python"><code class="language-python">match point<span class="token punctuation">:</span>
    case Point<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token keyword">if</span> x <span class="token operator">==</span> y<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Y=X at {x}"</span><span class="token punctuation">)</span>
    case Point<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Not on the diagonal"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此语句的一些其他关键特性:</p>
<ul>
<li><p>类似于解包赋值，元组和列表模式具有完全相同的含义并且实际上能匹配任意序列。 一个重要的例外是它们不能匹配迭代器或字符串。</p>
</li>
<li><p>序列模式支持扩展解包操作: <code>[x, y, *rest]</code> 和 <code>(x, y, *rest)</code> 的作用类似于解包赋值。 在 <code>*</code> 之后的名称也可以为 <code>_</code>，因此 <code>(x, y, *_)</code> 可以匹配包含至少两个条目的序列而不必绑定其余的条目。</p>
</li>
<li><p>映射模式: <code>{"bandwidth": b, "latency": l}</code> 会从一个字典中捕获 <code>"bandwidth"</code> 和 <code>"latency"</code> 的值。 与序列模式不同，额外的键会被忽略。 解包操作例如 <code>**rest</code> 也受到支持。 （但 <code>**_</code> 是冗余的，因而不被允许。）</p>
</li>
<li><p>子模式可使用 <code>as</code> 关键字来捕获:</p>
<pre class="line-numbers language-python"><code class="language-python">case <span class="token punctuation">(</span>Point<span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">,</span> Point<span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span> <span class="token keyword">as</span> p2<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>将把输入的第二个元素捕获为 <code>p2</code> (只要输入是包含两个点的序列)</p>
</li>
<li><p>大多数字面值是按相等性比较的，但是单例对象 <code>True</code>, <code>False</code> 和 <code>None</code> 则是按标识号比较的。</p>
</li>
<li><p>模式可以使用命名常量。 这些命名常量必须为带点号的名称以防止它们被解读为捕获变量:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> enum <span class="token keyword">import</span> Enum
<span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>
    RED <span class="token operator">=</span> <span class="token number">0</span>
    GREEN <span class="token operator">=</span> <span class="token number">1</span>
    BLUE <span class="token operator">=</span> <span class="token number">2</span>
match color<span class="token punctuation">:</span>
    case Color<span class="token punctuation">.</span>RED<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"I see red!"</span><span class="token punctuation">)</span>
    case Color<span class="token punctuation">.</span>GREEN<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Grass is green"</span><span class="token punctuation">)</span>
    case Color<span class="token punctuation">.</span>BLUE<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"I'm feeling the blues :("</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>下列代码创建一个可以输出限定数值内的斐波那契数列函数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># write Fibonacci series up to n</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token triple-quoted-string string">"""Print a Fibonacci series up to n."""</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">while</span> a <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a<span class="token operator">+</span>b
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Now call the function we just defined:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> fib<span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span>
<span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token number">13</span> <span class="token number">21</span> <span class="token number">34</span> <span class="token number">55</span> <span class="token number">89</span> <span class="token number">144</span> <span class="token number">233</span> <span class="token number">377</span> <span class="token number">610</span> <span class="token number">987</span> <span class="token number">1597</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>定义</em> 函数使用关键字 <code>def</code>，后跟函数名与括号内的形参列表。函数语句从下一行开始，并且必须缩进。</p>
<p>函数内的第一条语句是字符串时，该字符串就是文档字符串，也称为 <em>docstring</em>。利用文档字符串可以自动生成在线文档或打印版文档，还可以让开发者在浏览代码时直接查阅文档；Python 开发者最好养成在代码中加入文档字符串的好习惯。</p>
<p>函数在 <em>执行</em> 时使用函数局部变量符号表，所有函数变量赋值都存在局部符号表中；引用变量时，首先，在局部符号表里查找变量，然后，是外层函数局部符号表，再是全局符号表，最后是内置名称符号表。因此，尽管可以引用全局变量和外层函数的变量，但最好不要在函数内直接赋值（除非是 <code>global</code> 语句定义的全局变量，或 <code>nonlocal</code> 语句定义的外层函数变量）。</p>
<p>在调用函数时会将实际参数（实参）引入到被调用函数的局部符号表中；因此，实参是使用 <em>按值调用</em> 来传递的（其中的 <em>值</em> 始终是对象的 <em>引用</em> 而不是对象的值）。 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/2e6c373165c49a45.md#id2" target="_blank" rel="noopener">1</a> 当一个函数调用另外一个函数时，会为该调用创建一个新的局部符号表。</p>
<p>函数定义在当前符号表中把函数名与函数对象关联在一起。解释器把函数名指向的对象作为用户自定义函数。还可以使用其他名称指向同一个函数对象，并访问访该函数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fib
<span class="token operator">&lt;</span>function fib at <span class="token number">10042ed0</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> fib
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token number">13</span> <span class="token number">21</span> <span class="token number">34</span> <span class="token number">55</span> <span class="token number">89</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>fib</code> 不返回值，因此，其他语言不把它当作函数，而是当作过程。事实上，没有 <code>return</code> 语句的函数也返回值，只不过这个值比较是 <code>None</code> （是一个内置名称）。一般来说，解释器不会输出单独的返回值 <code>None</code> ，如需查看该值，可以使用 <code>print()</code>：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fib<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>fib<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
None<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>编写不直接输出斐波那契数列运算结果，而是返回运算结果列表的函数也非常简单：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">fib2</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># return Fibonacci series up to n</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token triple-quoted-string string">"""Return a list containing the Fibonacci series up to n."""</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">while</span> a <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># see below</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a<span class="token operator">+</span>b
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> result
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> f100 <span class="token operator">=</span> fib2<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># call it</span>
<span class="token operator">>></span><span class="token operator">></span> f100                <span class="token comment" spellcheck="true"># write the result</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>本例也新引入了一些 Python 功能：</p>
<ul>
<li><code>return</code> 语句返回函数的值。<code>return</code> 语句不带表达式参数时，返回 <code>None</code>。函数执行完毕退出也返回 <code>None</code>。</li>
<li><code>result.append(a)</code> 语句调用了列表对象 <code>result</code> 的 <em>方法</em> 。方法是“从属于”对象的函数，命名为 <code>obj.methodname</code>，<code>obj</code> 是对象（也可以是表达式），<code>methodname</code> 是对象类型定义的方法名。不同类型定义不同的方法，不同类型的方法名可以相同，且不会引起歧义。示例中的方法 <code>append()</code> 是为列表对象定义的，用于在列表末尾添加新元素。本例中，该方法相当于 <code>result = result + [a]</code> ，但更有效。</li>
</ul>
<h3 id="函数定义详解"><a href="#函数定义详解" class="headerlink" title="函数定义详解"></a>函数定义详解</h3><p>函数定义支持可变数量的参数。这里列出三种可以组合使用的形式。</p>
<h4 id="默认值参数"><a href="#默认值参数" class="headerlink" title="默认值参数"></a>默认值参数</h4><p>为参数指定默认值是非常有用的方式。调用函数时，可以使用比定义时更少的参数，例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">ask_ok</span><span class="token punctuation">(</span>prompt<span class="token punctuation">,</span> retries<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> reminder<span class="token operator">=</span><span class="token string">'Please try again!'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        ok <span class="token operator">=</span> input<span class="token punctuation">(</span>prompt<span class="token punctuation">)</span>
        <span class="token keyword">if</span> ok <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'ye'</span><span class="token punctuation">,</span> <span class="token string">'yes'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        <span class="token keyword">if</span> ok <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token string">'n'</span><span class="token punctuation">,</span> <span class="token string">'no'</span><span class="token punctuation">,</span> <span class="token string">'nop'</span><span class="token punctuation">,</span> <span class="token string">'nope'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        retries <span class="token operator">=</span> retries <span class="token operator">-</span> <span class="token number">1</span>
        <span class="token keyword">if</span> retries <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'invalid user response'</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>reminder<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该函数可以用以下方式调用：</p>
<ul>
<li>只给出必选实参：<code>ask_ok('Do you really want to quit?')</code></li>
<li>给出一个可选实参：<code>ask_ok('OK to overwrite the file?', 2)</code></li>
<li>给出所有实参：<code>ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')</code></li>
</ul>
<p>本例还使用了关键字 <code>in</code> ，用于确认序列中是否包含某个值。</p>
<p>默认值在 <em>定义</em> 作用域里的函数定义中求值，所以：</p>
<pre class="line-numbers language-python"><code class="language-python">i <span class="token operator">=</span> <span class="token number">5</span>
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>arg<span class="token operator">=</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
i <span class="token operator">=</span> <span class="token number">6</span>
f<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上例输出的是 <code>5</code>。</p>
<p><strong>重要警告：</strong> 默认值只计算一次。默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果。例如，下面的函数会累积后续调用时传递的参数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> L<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    L<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token keyword">return</span> L
<span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果如下：</p>
<pre><code>[1]
[1, 2]
[1, 2, 3]</code></pre><p>不想在后续调用之间共享默认值时，应以如下方式编写函数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> L<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> L <span class="token keyword">is</span> None<span class="token punctuation">:</span>
        L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    L<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token keyword">return</span> L<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p><code>kwarg=value</code> 形式的 关键字参数 也可以用于调用函数。函数示例如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">parrot</span><span class="token punctuation">(</span>voltage<span class="token punctuation">,</span> state<span class="token operator">=</span><span class="token string">'a stiff'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'voom'</span><span class="token punctuation">,</span> type<span class="token operator">=</span><span class="token string">'Norwegian Blue'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-- This parrot wouldn't"</span><span class="token punctuation">,</span> action<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"if you put"</span><span class="token punctuation">,</span> voltage<span class="token punctuation">,</span> <span class="token string">"volts through it."</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-- Lovely plumage, the"</span><span class="token punctuation">,</span> type<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-- It's"</span><span class="token punctuation">,</span> state<span class="token punctuation">,</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该函数接受一个必选参数（<code>voltage</code>）和三个可选参数（<code>state</code>, <code>action</code> 和 <code>type</code>）。该函数可用下列方式调用：</p>
<pre class="line-numbers language-python"><code class="language-python">parrot<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>                                          <span class="token comment" spellcheck="true"># 1 positional argument</span>
parrot<span class="token punctuation">(</span>voltage<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span>                                  <span class="token comment" spellcheck="true"># 1 keyword argument</span>
parrot<span class="token punctuation">(</span>voltage<span class="token operator">=</span><span class="token number">1000000</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'VOOOOOM'</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># 2 keyword arguments</span>
parrot<span class="token punctuation">(</span>action<span class="token operator">=</span><span class="token string">'VOOOOOM'</span><span class="token punctuation">,</span> voltage<span class="token operator">=</span><span class="token number">1000000</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># 2 keyword arguments</span>
parrot<span class="token punctuation">(</span><span class="token string">'a million'</span><span class="token punctuation">,</span> <span class="token string">'bereft of life'</span><span class="token punctuation">,</span> <span class="token string">'jump'</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># 3 positional arguments</span>
parrot<span class="token punctuation">(</span><span class="token string">'a thousand'</span><span class="token punctuation">,</span> state<span class="token operator">=</span><span class="token string">'pushing up the daisies'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 1 positional, 1 keyword</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以下调用函数的方式都无效：</p>
<pre class="line-numbers language-python"><code class="language-python">parrot<span class="token punctuation">(</span><span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true"># required argument missing</span>
parrot<span class="token punctuation">(</span>voltage<span class="token operator">=</span><span class="token number">5.0</span><span class="token punctuation">,</span> <span class="token string">'dead'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># non-keyword argument after a keyword argument</span>
parrot<span class="token punctuation">(</span><span class="token number">110</span><span class="token punctuation">,</span> voltage<span class="token operator">=</span><span class="token number">220</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># duplicate value for the same argument</span>
parrot<span class="token punctuation">(</span>actor<span class="token operator">=</span><span class="token string">'John Cleese'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># unknown keyword argument</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数调用时，关键字参数必须跟在位置参数后面。所有传递的关键字参数都必须匹配一个函数接受的参数（比如，<code>actor</code> 不是函数 <code>parrot</code> 的有效参数），关键字参数的顺序并不重要。这也包括必选参数，（比如，<code>parrot(voltage=1000)</code> 也有效）。不能对同一个参数多次赋值，下面就是一个因此限制而失败的例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">function</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">pass</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> function<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> function<span class="token punctuation">(</span><span class="token punctuation">)</span> got multiple values <span class="token keyword">for</span> argument <span class="token string">'a'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后一个形参为 <code>**name</code> 形式时，接收一个字典，该字典包含与函数中已定义形参对应之外的所有关键字参数。<code>**name</code> 形参可以与 <code>*name</code> 形参组合使用（<code>*name</code> 必须在 <code>**name</code> 前面）， <code>*name</code> 形参接收一个 元组，该元组包含形参列表之外的位置参数。例如，可以定义下面这样的函数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cheeseshop</span><span class="token punctuation">(</span>kind<span class="token punctuation">,</span> <span class="token operator">*</span>arguments<span class="token punctuation">,</span> <span class="token operator">**</span>keywords<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-- Do you have any"</span><span class="token punctuation">,</span> kind<span class="token punctuation">,</span> <span class="token string">"?"</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-- I'm sorry, we're all out of"</span><span class="token punctuation">,</span> kind<span class="token punctuation">)</span>
    <span class="token keyword">for</span> arg <span class="token keyword">in</span> arguments<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-"</span> <span class="token operator">*</span> <span class="token number">40</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> kw <span class="token keyword">in</span> keywords<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>kw<span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">,</span> keywords<span class="token punctuation">[</span>kw<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该函数可以用如下方式调用：</p>
<pre class="line-numbers language-python"><code class="language-python">cheeseshop<span class="token punctuation">(</span><span class="token string">"Limburger"</span><span class="token punctuation">,</span> <span class="token string">"It's very runny, sir."</span><span class="token punctuation">,</span>
           <span class="token string">"It's really very, VERY runny, sir."</span><span class="token punctuation">,</span>
           shopkeeper<span class="token operator">=</span><span class="token string">"Michael Palin"</span><span class="token punctuation">,</span>
           client<span class="token operator">=</span><span class="token string">"John Cleese"</span><span class="token punctuation">,</span>
           sketch<span class="token operator">=</span><span class="token string">"Cheese Shop Sketch"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span> Do you have any Limburger ?
<span class="token operator">-</span><span class="token operator">-</span> I<span class="token string">'m sorry, we'</span>re all out of Limburger
It's very runny<span class="token punctuation">,</span> sir<span class="token punctuation">.</span>
It's really very<span class="token punctuation">,</span> VERY runny<span class="token punctuation">,</span> sir<span class="token punctuation">.</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
shopkeeper <span class="token punctuation">:</span> Michael Palin
client <span class="token punctuation">:</span> John Cleese
sketch <span class="token punctuation">:</span> Cheese Shop Sketch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，关键字参数在输出结果中的顺序与调用函数时的顺序一致。</p>
<h4 id="特殊参数"><a href="#特殊参数" class="headerlink" title="特殊参数"></a>特殊参数</h4><p>默认情况下，参数可以按位置或显式关键字传递给 Python 函数。为了让代码易读、高效，最好限制参数的传递方式，这样，开发者只需查看函数定义，即可确定参数项是仅按位置、按位置或关键字，还是仅按关键字传递。</p>
<p>函数定义如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>pos1<span class="token punctuation">,</span> pos2<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">,</span> pos_or_kwd<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> kwd1<span class="token punctuation">,</span> kwd2<span class="token punctuation">)</span><span class="token punctuation">:</span>
      <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>    <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>     <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
        <span class="token operator">|</span>             <span class="token operator">|</span>                  <span class="token operator">|</span>
        <span class="token operator">|</span>        Positional <span class="token operator">or</span> keyword   <span class="token operator">|</span>
        <span class="token operator">|</span>                                <span class="token operator">-</span> Keyword only
         <span class="token operator">-</span><span class="token operator">-</span> Positional only<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>/</code> 和 <code>*</code> 是可选的。这些符号表明形参如何把参数值传递给函数：位置、位置或关键字、关键字。关键字形参也叫作命名形参。</p>
<p><strong>位置或关键字参数</strong></p>
<p>函数定义中未使用 <code>/</code> 和 <code>*</code> 时，参数可以按位置或关键字传递给函数。</p>
<p><strong>仅位置参数</strong></p>
<p>此处再介绍一些细节，特定形参可以标记为 <em>仅限位置<em>。</em>仅限位置</em> 时，形参的顺序很重要，且这些形参不能用关键字传递。仅限位置形参应放在 <code>/</code> （正斜杠）前。<code>/</code> 用于在逻辑上分割仅限位置形参与其它形参。如果函数定义中没有 <code>/</code>，则表示没有仅限位置形参。</p>
<p><code>/</code> 后可以是 <em>位置或关键字</em> 或 <em>仅限关键字</em> 形参。</p>
<p><strong>仅限关键字参数</strong></p>
<p>把形参标记为 <em>仅限关键字*，表明必须以关键字参数形式传递该形参，应在参数列表中第一个 *仅限关键字</em> 形参前添加 <code>*</code>。</p>
<p><strong>函数示例</strong></p>
<p>请看下面的函数定义示例，注意 <code>/</code> 和 <code>*</code> 标记：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">standard_arg</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">pos_only_arg</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">kwd_only_arg</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">combined_example</span><span class="token punctuation">(</span>pos_only<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">,</span> standard<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> kwd_only<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>pos_only<span class="token punctuation">,</span> standard<span class="token punctuation">,</span> kwd_only<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一个函数定义 <code>standard_arg</code> 是最常见的形式，对调用方式没有任何限制，可以按位置也可以按关键字传递参数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> standard_arg<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span> standard_arg<span class="token punctuation">(</span>arg<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>第二个函数 <code>pos_only_arg</code> 的函数定义中有 <code>/</code>，仅限使用位置形参：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pos_only_arg<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> pos_only_arg<span class="token punctuation">(</span>arg<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> pos_only_arg<span class="token punctuation">(</span><span class="token punctuation">)</span> got some positional<span class="token operator">-</span>only arguments passed <span class="token keyword">as</span> keyword arguments<span class="token punctuation">:</span> <span class="token string">'arg'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第三个函数 <code>kwd_only_args</code> 的函数定义通过 <code>*</code> 表明仅限关键字参数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> kwd_only_arg<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> kwd_only_arg<span class="token punctuation">(</span><span class="token punctuation">)</span> takes <span class="token number">0</span> positional arguments but <span class="token number">1</span> was given
<span class="token operator">>></span><span class="token operator">></span> kwd_only_arg<span class="token punctuation">(</span>arg<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后一个函数在同一个函数定义中，使用了全部三种调用惯例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> combined_example<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> combined_example<span class="token punctuation">(</span><span class="token punctuation">)</span> takes <span class="token number">2</span> positional arguments but <span class="token number">3</span> were given
<span class="token operator">>></span><span class="token operator">></span> combined_example<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> kwd_only<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> combined_example<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> standard<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> kwd_only<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> combined_example<span class="token punctuation">(</span>pos_only<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> standard<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> kwd_only<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> combined_example<span class="token punctuation">(</span><span class="token punctuation">)</span> got some positional<span class="token operator">-</span>only arguments passed <span class="token keyword">as</span> keyword arguments<span class="token punctuation">:</span> <span class="token string">'pos_only'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面的函数定义中，<code>kwds</code> 把 <code>name</code> 当作键，因此，可能与位置参数 <code>name</code> 产生潜在冲突：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token operator">**</span>kwds<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">'name'</span> <span class="token keyword">in</span> kwds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>调用该函数不可能返回 <code>True</code>，因为关键字 <code>'name'</code> 总与第一个形参绑定。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> foo<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">**</span><span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> foo<span class="token punctuation">(</span><span class="token punctuation">)</span> got multiple values <span class="token keyword">for</span> argument <span class="token string">'name'</span>
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>加上 <code>/</code> （仅限位置参数）后，就可以了。此时，函数定义把 <code>name</code> 当作位置参数，<code>'name'</code> 也可以作为关键字参数的键：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">,</span> <span class="token operator">**</span>kwds<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">'name'</span> <span class="token keyword">in</span> kwds
<span class="token operator">>></span><span class="token operator">></span> foo<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">**</span><span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>换句话说，仅限位置形参的名称可以在 <code>**kwds</code> 中使用，而不产生歧义。</p>
<p><strong>小结</strong></p>
<p>以下用例决定哪些形参可以用于函数定义：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>pos1<span class="token punctuation">,</span> pos2<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">,</span> pos_or_kwd<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> kwd1<span class="token punctuation">,</span> kwd2<span class="token punctuation">)</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>说明：</p>
<ul>
<li>使用仅限位置形参，可以让用户无法使用形参名。形参名没有实际意义时，强制调用函数的实参顺序时，或同时接收位置形参和关键字时，这种方式很有用。</li>
<li>当形参名有实际意义，且显式名称可以让函数定义更易理解时，阻止用户依赖传递实参的位置时，才使用关键字。</li>
<li>对于 API，使用仅限位置形参，可以防止未来修改形参名时造成破坏性的 API 变动。</li>
</ul>
<h4 id="任意实参列表"><a href="#任意实参列表" class="headerlink" title="任意实参列表"></a>任意实参列表</h4><p>调用函数时，使用任意数量的实参是最少见的选项。这些实参包含在元组中。在可变数量的实参之前，可能有若干个普通参数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">write_multiple_items</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> separator<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
    file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>separator<span class="token punctuation">.</span>join<span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>variadic</code> 实参用于采集传递给函数的所有剩余实参，因此，它们通常在形参列表的末尾。<code>*args</code> 形参后的任何形式参数只能是仅限关键字参数，即只能用作关键字参数，不能用作位置参数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> sep<span class="token punctuation">.</span>join<span class="token punctuation">(</span>args<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> concat<span class="token punctuation">(</span><span class="token string">"earth"</span><span class="token punctuation">,</span> <span class="token string">"mars"</span><span class="token punctuation">,</span> <span class="token string">"venus"</span><span class="token punctuation">)</span>
<span class="token string">'earth/mars/venus'</span>
<span class="token operator">>></span><span class="token operator">></span> concat<span class="token punctuation">(</span><span class="token string">"earth"</span><span class="token punctuation">,</span> <span class="token string">"mars"</span><span class="token punctuation">,</span> <span class="token string">"venus"</span><span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">"."</span><span class="token punctuation">)</span>
<span class="token string">'earth.mars.venus'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="解包实参列表"><a href="#解包实参列表" class="headerlink" title="解包实参列表"></a>解包实参列表</h4><p>函数调用要求独立的位置参数，但实参在列表或元组里时，要执行相反的操作。例如，内置的 <code>range()</code> 函数要求独立的 <em>start</em> 和 <em>stop</em> 实参。如果这些参数不是独立的，则要在调用函数时，用 <code>*</code> 操作符把实参从列表或元组解包出来：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># normal call with separate arguments</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># call with arguments unpacked from a list</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同样，字典可以用 <code>**</code> 操作符传递关键字参数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">parrot</span><span class="token punctuation">(</span>voltage<span class="token punctuation">,</span> state<span class="token operator">=</span><span class="token string">'a stiff'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'voom'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"-- This parrot wouldn't"</span><span class="token punctuation">,</span> action<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"if you put"</span><span class="token punctuation">,</span> voltage<span class="token punctuation">,</span> <span class="token string">"volts through it."</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"E's"</span><span class="token punctuation">,</span> state<span class="token punctuation">,</span> <span class="token string">"!"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"voltage"</span><span class="token punctuation">:</span> <span class="token string">"four million"</span><span class="token punctuation">,</span> <span class="token string">"state"</span><span class="token punctuation">:</span> <span class="token string">"bleedin' demised"</span><span class="token punctuation">,</span> <span class="token string">"action"</span><span class="token punctuation">:</span> <span class="token string">"VOOM"</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> parrot<span class="token punctuation">(</span><span class="token operator">**</span>d<span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span> This parrot wouldn<span class="token string">'t VOOM if you put four million volts through it. E'</span>s bleedin' demised !<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h4><p><code>lambda</code> 关键字用于创建小巧的匿名函数。<code>lambda a, b: a+b</code> 函数返回两个参数的和。Lambda 函数可用于任何需要函数对象的地方。在语法上，匿名函数只能是单个表达式。在语义上，它只是常规函数定义的语法糖。与嵌套函数定义一样，lambda 函数可以引用包含作用域中的变量：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">make_incrementor</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x <span class="token operator">+</span> n
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> make_incrementor<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token number">42</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">43</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上例用 lambda 表达式返回函数。还可以把匿名函数用作传递的实参：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pairs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'one'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> pairs<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> pair<span class="token punctuation">:</span> pair<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pairs
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'one'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h4><p>以下是文档字符串内容和格式的约定。</p>
<p>第一行应为对象用途的简短摘要。为保持简洁，不要在这里显式说明对象名或类型，因为可通过其他方式获取这些信息（除非该名称碰巧是描述函数操作的动词）。这一行应以大写字母开头，以句点结尾。</p>
<p>文档字符串为多行时，第二行应为空白行，在视觉上将摘要与其余描述分开。后面的行可包含若干段落，描述对象的调用约定、副作用等。</p>
<p>Python 解析器不会删除 Python 中多行字符串字面值的缩进，因此，文档处理工具应在必要时删除缩进。这项操作遵循以下约定：文档字符串第一行 <em>之后</em> 的第一个非空行决定了整个文档字符串的缩进量（第一行通常与字符串开头的引号相邻，其缩进在字符串中并不明显，因此，不能用第一行的缩进），然后，删除字符串中所有行开头处与此缩进“等价”的空白符。不能有比此缩进更少的行，但如果出现了缩进更少的行，应删除这些行的所有前导空白符。转化制表符后（通常为 8 个空格），应测试空白符的等效性。</p>
<p>下面是多行文档字符串的一个例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">my_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token triple-quoted-string string">"""Do nothing, but document it.
...
...     No, really, it doesn't do anything.
...     """</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">pass</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>my_function<span class="token punctuation">.</span>__doc__<span class="token punctuation">)</span>
Do nothing<span class="token punctuation">,</span> but document it<span class="token punctuation">.</span>
    No<span class="token punctuation">,</span> really<span class="token punctuation">,</span> it doesn't do anything<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h4><p>函数注解 是可选的用户自定义函数类型的元数据完整信息。</p>
<p>标注 以字典的形式存放在函数的 <code>__annotations__</code> 属性中，并且不会影响函数的任何其他部分。 形参标注的定义方式是在形参名后加冒号，后面跟一个表达式，该表达式会被求值为标注的值。 返回值标注的定义方式是加组合符号 <code>-&gt;</code>，后面跟一个表达式，该标注位于形参列表和表示 <code>def</code> 语句结束的冒号之间。 下面的示例有一个必须的参数，一个可选的关键字参数以及返回值都带有相应的标注:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>ham<span class="token punctuation">:</span> str<span class="token punctuation">,</span> eggs<span class="token punctuation">:</span> str <span class="token operator">=</span> <span class="token string">'eggs'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Annotations:"</span><span class="token punctuation">,</span> f<span class="token punctuation">.</span>__annotations__<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Arguments:"</span><span class="token punctuation">,</span> ham<span class="token punctuation">,</span> eggs<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> ham <span class="token operator">+</span> <span class="token string">' and '</span> <span class="token operator">+</span> eggs
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">)</span>
Annotations<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token string">'ham'</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token string">'return'</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token string">'eggs'</span><span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token punctuation">}</span>
Arguments<span class="token punctuation">:</span> spam eggs
<span class="token string">'spam and eggs'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h3><p>现在你将要写更长，更复杂的 Python 代码，是时候讨论一下 <em>代码风格</em> 了。 大多数语言都能以不同的风格被编写（或更准确地说，被格式化）；有些比其他的更具有可读性。 能让其他人轻松阅读你的代码总是一个好主意，采用一种好的编码风格对此有很大帮助。</p>
<p>Python 项目大多都遵循 <a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener"><strong>PEP 8</strong></a> 的风格指南；它推行的编码风格易于阅读、赏心悦目。Python 开发者均应抽时间悉心研读；以下是该提案中的核心要点：</p>
<ul>
<li><p>缩进，用 4 个空格，不要用制表符。</p>
<p>4 个空格是小缩进（更深嵌套）和大缩进（更易阅读）之间的折中方案。制表符会引起混乱，最好别用。</p>
</li>
<li><p>换行，一行不超过 79 个字符。</p>
<p>这样换行的小屏阅读体验更好，还便于在大屏显示器上并排阅读多个代码文件。</p>
</li>
<li><p>用空行分隔函数和类，及函数内较大的代码块。</p>
</li>
<li><p>最好把注释放到单独一行。</p>
</li>
<li><p>使用文档字符串。</p>
</li>
<li><p>运算符前后、逗号后要用空格，但不要直接在括号内使用： <code>a = f(1, 2) + g(3, 4)</code>。</p>
</li>
<li><p>类和函数的命名要一致；按惯例，命名类用 <code>UpperCamelCase</code>，命名函数与方法用 <code>lowercase_with_underscores</code>。命名方法中第一个参数总是用 <code>self</code>。</p>
</li>
<li><p>编写用于国际多语环境的代码时，不要用生僻的编码。Python 默认的 UTF-8 或纯 ASCII 可以胜任各种情况。</p>
</li>
<li><p>同理，就算多语阅读、维护代码的可能再小，也不要在标识符中使用非 ASCII 字符。</p>
</li>
</ul>
<h2 id="4-数据结构"><a href="#4-数据结构" class="headerlink" title="4. 数据结构"></a>4. 数据结构</h2><h3 id="列表详解"><a href="#列表详解" class="headerlink" title="列表详解"></a>列表详解</h3><p>列表数据类型支持很多方法，列表对象的所有方法所示如下：</p>
<p><code>list.append</code>(<em>x</em>)</p>
<p>在列表末尾添加一个元素，相当于 <code>a[len(a):] = [x]</code> 。</p>
<p><code>list.extend</code>(<em>iterable</em>)</p>
<p>用可迭代对象的元素扩展列表。相当于 <code>a[len(a):] = iterable</code> 。</p>
<p><code>list.insert</code>(<em>i</em>, <em>x</em>)</p>
<p>在指定位置插入元素。第一个参数是插入元素的索引，因此，<code>a.insert(0, x)</code> 在列表开头插入元素， <code>a.insert(len(a), x)</code> 等同于 <code>a.append(x)</code> 。</p>
<p><code>list.remove</code>(<em>x</em>)</p>
<p>从列表中删除第一个值为 <em>x</em> 的元素。未找到指定元素时，触发 <code>ValueError</code> 异常。</p>
<p><code>list.pop</code>([<em>i</em>])</p>
<p>删除列表中指定位置的元素，并返回被删除的元素。未指定位置时，<code>a.pop()</code> 删除并返回列表的最后一个元素。（方法签名中 <em>i</em> 两边的方括号表示该参数是可选的，不是要求输入方括号。这种表示法常见于 Python 参考库）。</p>
<p><code>list.clear</code>()</p>
<p>删除列表里的所有元素，相当于 <code>del a[:]</code> 。</p>
<p><code>list.index</code>(<em>x</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回列表中第一个值为 <em>x</em> 的元素的零基索引。未找到指定元素时，触发 <code>ValueError</code> 异常。</p>
<p>可选参数 <em>start</em> 和 <em>end</em> 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 <em>start</em> 参数。</p>
<p><code>list.count</code>(<em>x</em>)</p>
<p>返回列表中元素 <em>x</em> 出现的次数。</p>
<p><code>list.sort</code>(<em>**,</em> key=None<em>,</em> reverse=False*)</p>
<p>就地排序列表中的元素（要了解自定义排序参数，详见 <code>sorted()</code>）。</p>
<p><code>list.reverse</code>()</p>
<p>翻转列表中的元素。</p>
<p><code>list.copy</code>()</p>
<p>返回列表的浅拷贝。相当于 <code>a[:]</code> 。</p>
<p>多数列表方法示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token string">'kiwi'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'banana'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> fruits<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span>
<span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span> fruits<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">'tangerine'</span><span class="token punctuation">)</span>
<span class="token number">0</span>
<span class="token operator">>></span><span class="token operator">></span> fruits<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'banana'</span><span class="token punctuation">)</span>
<span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> fruits<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Find next banana starting a position 4</span>
<span class="token number">6</span>
<span class="token operator">>></span><span class="token operator">></span> fruits<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> fruits
<span class="token punctuation">[</span><span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'kiwi'</span><span class="token punctuation">,</span> <span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'orange'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> fruits<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'grape'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> fruits
<span class="token punctuation">[</span><span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'kiwi'</span><span class="token punctuation">,</span> <span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token string">'grape'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> fruits<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> fruits
<span class="token punctuation">[</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token string">'grape'</span><span class="token punctuation">,</span> <span class="token string">'kiwi'</span><span class="token punctuation">,</span> <span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token string">'pear'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> fruits<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'pear'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>insert</code>、<code>remove</code>、<code>sort</code> 等方法只修改列表，不输出返回值——返回的默认值为 <code>None</code> 。这是所有 Python 可变数据结构的设计原则。</p>
<p>还有，不是所有数据都可以排序或比较。例如，<code>[None, 'hello', 10]</code> 就不可排序，因为整数不能与字符串对比，而 <em>None</em> 不能与其他类型对比。有些类型根本就没有定义顺序关系，例如，<code>3+4j &lt; 5+7j</code> 这种对比操作就是无效的。</p>
<h4 id="用列表实现堆栈"><a href="#用列表实现堆栈" class="headerlink" title="用列表实现堆栈"></a>用列表实现堆栈</h4><p>使用列表方法实现堆栈非常容易，最后插入的最先取出（“后进先出”）。把元素添加到堆栈的顶端，使用 <code>append()</code> 。从堆栈顶部取出元素，使用 <code>pop()</code> ，不用指定索引。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> stack
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">7</span>
<span class="token operator">>></span><span class="token operator">></span> stack
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">6</span>
<span class="token operator">>></span><span class="token operator">></span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">5</span>
<span class="token operator">>></span><span class="token operator">></span> stack
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="用列表实现队列"><a href="#用列表实现队列" class="headerlink" title="用列表实现队列"></a>用列表实现队列</h4><p>列表也可以用作队列，最先加入的元素，最先取出（“先进先出”）；然而，列表作为队列的效率很低。因为，在列表末尾添加和删除元素非常快，但在列表开头插入或移除元素却很慢（因为所有其他元素都必须移动一位）。</p>
<p>实现队列最好用 <code>collections.deque</code>，可以快速从两端添加或删除元素。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
<span class="token operator">>></span><span class="token operator">></span> queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"Eric"</span><span class="token punctuation">,</span> <span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token string">"Michael"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"Terry"</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true"># Terry arrives</span>
<span class="token operator">>></span><span class="token operator">></span> queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"Graham"</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># Graham arrives</span>
<span class="token operator">>></span><span class="token operator">></span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true"># The first to arrive now leaves</span>
<span class="token string">'Eric'</span>
<span class="token operator">>></span><span class="token operator">></span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true"># The second to arrive now leaves</span>
<span class="token string">'John'</span>
<span class="token operator">>></span><span class="token operator">></span> queue                           <span class="token comment" spellcheck="true"># Remaining queue in order of arrival</span>
deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Michael'</span><span class="token punctuation">,</span> <span class="token string">'Terry'</span><span class="token punctuation">,</span> <span class="token string">'Graham'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h4><p>列表推导式创建列表的方式更简洁。常见的用法为，对序列或可迭代对象中的每个元素应用某种操作，用生成的结果创建新的列表；或用满足特定条件的元素创建子序列。</p>
<p>例如，创建平方值的列表：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> squares <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     squares<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> squares
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，这段代码创建（或覆盖）变量 <code>x</code>，该变量在循环结束后仍然存在。下述方法可以无副作用地计算平方列表：</p>
<pre class="line-numbers language-python"><code class="language-python">squares <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或等价于：</p>
<pre class="line-numbers language-python"><code class="language-python">squares <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>上面这种写法更简洁、易读。</p>
<p>列表推导式的方括号内包含以下内容：一个表达式，后面为一个 <code>for</code> 子句，然后，是零个或多个 <code>for</code> 或 <code>if</code> 子句。结果是由表达式依据 <code>for</code> 和 <code>if</code> 子句求值计算而得出一个新列表。 举例来说，以下列表推导式将两个列表中不相等的元素组合起来：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token keyword">for</span> y <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token keyword">if</span> x <span class="token operator">!=</span> y<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>等价于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> combs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> y <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">if</span> x <span class="token operator">!=</span> y<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             combs<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> combs
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，上面两段代码中，<code>for</code> 和 <code>if</code> 的顺序相同。</p>
<p>表达式是元组（例如上例的 <code>(x, y)</code>）时，必须加上括号：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> vec <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># create a new list with the values doubled</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>x<span class="token operator">*</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> vec<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># filter the list to exclude negative numbers</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> vec <span class="token keyword">if</span> x <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># apply a function to all the elements</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>abs<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> vec<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># call a method on each element</span>
<span class="token operator">>></span><span class="token operator">></span> freshfruit <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'  banana'</span><span class="token punctuation">,</span> <span class="token string">'  loganberry '</span><span class="token punctuation">,</span> <span class="token string">'passion fruit  '</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>weapon<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> weapon <span class="token keyword">in</span> freshfruit<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token string">'loganberry'</span><span class="token punctuation">,</span> <span class="token string">'passion fruit'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># create a list of 2-tuples like (number, square)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># the tuple must be parenthesized, otherwise an error is raised</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> x<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
    <span class="token punctuation">[</span>x<span class="token punctuation">,</span> x<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
               <span class="token operator">^</span>
SyntaxError<span class="token punctuation">:</span> invalid syntax
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># flatten a list using a listcomp with two 'for'</span>
<span class="token operator">>></span><span class="token operator">></span> vec <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>num <span class="token keyword">for</span> elem <span class="token keyword">in</span> vec <span class="token keyword">for</span> num <span class="token keyword">in</span> elem<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>列表推导式可以使用复杂的表达式和嵌套函数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> math <span class="token keyword">import</span> pi
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>str<span class="token punctuation">(</span>round<span class="token punctuation">(</span>pi<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">'3.1'</span><span class="token punctuation">,</span> <span class="token string">'3.14'</span><span class="token punctuation">,</span> <span class="token string">'3.142'</span><span class="token punctuation">,</span> <span class="token string">'3.1416'</span><span class="token punctuation">,</span> <span class="token string">'3.14159'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="嵌套的列表推导式"><a href="#嵌套的列表推导式" class="headerlink" title="嵌套的列表推导式"></a>嵌套的列表推导式</h4><p>列表推导式中的初始表达式可以是任何表达式，甚至可以是另一个列表推导式。</p>
<p>下面这个 3x4 矩阵，由 3 个长度为 4 的列表组成：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> matrix <span class="token operator">=</span> <span class="token punctuation">[</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面的列表推导式可以转置行列：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">[</span>row<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> matrix<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如上节所示，嵌套的列表推导式基于其后的 <code>for</code> 求值，所以这个例子等价于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> transposed <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     transposed<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>row<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> matrix<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> transposed
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>反过来说，也等价于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> transposed <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token comment" spellcheck="true"># the following 3 lines implement the nested listcomp</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     transposed_row <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> row <span class="token keyword">in</span> matrix<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         transposed_row<span class="token punctuation">.</span>append<span class="token punctuation">(</span>row<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     transposed<span class="token punctuation">.</span>append<span class="token punctuation">(</span>transposed_row<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> transposed
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实际应用中，最好用内置函数替代复杂的流程语句。此时，<code>zip()</code> 函数更好用：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>zip<span class="token punctuation">(</span><span class="token operator">*</span>matrix<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="del-语句"><a href="#del-语句" class="headerlink" title="del 语句"></a><code>del</code> 语句</h3><p><code>del</code> 语句按索引，而不是值从列表中移除元素。与返回值的 <code>pop()</code> 方法不同， <code>del</code> 语句也可以从列表中移除切片，或清空整个列表（之前是将空列表赋值给切片）。 例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">66.25</span><span class="token punctuation">,</span> <span class="token number">333</span><span class="token punctuation">,</span> <span class="token number">333</span><span class="token punctuation">,</span> <span class="token number">1234.5</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> a
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">66.25</span><span class="token punctuation">,</span> <span class="token number">333</span><span class="token punctuation">,</span> <span class="token number">333</span><span class="token punctuation">,</span> <span class="token number">1234.5</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> a
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">66.25</span><span class="token punctuation">,</span> <span class="token number">1234.5</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> a
<span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>del</code> 也可以用来删除整个变量：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>此后，再引用 <code>a</code> 就会报错（直到为它赋与另一个值）。后文会介绍 <code>del</code> 的其他用法。</p>
<h3 id="元组和序列"><a href="#元组和序列" class="headerlink" title="元组和序列"></a>元组和序列</h3><p>列表和字符串有很多共性，例如，索引和切片操作。这两种数据类型是 <em>序列</em> （参见 序列类型 —- list, tuple, range）。随着 Python 语言的发展，其他的序列类型也被加入其中。本节介绍另一种标准序列类型：<em>元组</em>。</p>
<p>元组由多个用逗号隔开的值组成，例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> <span class="token number">12345</span><span class="token punctuation">,</span> <span class="token number">54321</span><span class="token punctuation">,</span> <span class="token string">'hello!'</span>
<span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token number">12345</span>
<span class="token operator">>></span><span class="token operator">></span> t
<span class="token punctuation">(</span><span class="token number">12345</span><span class="token punctuation">,</span> <span class="token number">54321</span><span class="token punctuation">,</span> <span class="token string">'hello!'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Tuples may be nested:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> u <span class="token operator">=</span> t<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> u
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">12345</span><span class="token punctuation">,</span> <span class="token number">54321</span><span class="token punctuation">,</span> <span class="token string">'hello!'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Tuples are immutable:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">88888</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> <span class="token string">'tuple'</span> object does <span class="token operator">not</span> support item assignment
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># but they can contain mutable objects:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> v <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> v
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出时，元组都要由圆括号标注，这样才能正确地解释嵌套元组。输入时，圆括号可有可无，不过经常是必须的（如果元组是更大的表达式的一部分）。不允许为元组中的单个元素赋值，当然，可以创建含列表等可变对象的元组。</p>
<p>虽然，元组与列表很像，但使用场景不同，用途也不同。元组是 immutable （不可变的），一般可包含异质元素序列，通过解包（见本节下文）或索引访问（如果是 <code>namedtuples</code>，可以属性访问）。列表是 mutable （可变的），列表元素一般为同质类型，可迭代访问。</p>
<p>构造 0 个或 1 个元素的元组比较特殊：为了适应这种情况，对句法有一些额外的改变。用一对空圆括号就可以创建空元组；只有一个元素的元组可以通过在这个元素后添加逗号来构建（圆括号里只有一个值的话不够明确）。丑陋，但是有效。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> empty <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> singleton <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># &lt;-- note trailing comma</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>empty<span class="token punctuation">)</span>
<span class="token number">0</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>singleton<span class="token punctuation">)</span>
<span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> singleton
<span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>语句 <code>t = 12345, 54321, 'hello!'</code> 是 <em>元组打包</em> 的例子：值 <code>12345</code>, <code>54321</code> 和 <code>'hello!'</code> 一起被打包进元组。逆操作也可以：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z <span class="token operator">=</span> t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>称之为 <em>序列解包</em> 也是妥妥的，适用于右侧的任何序列。序列解包时，左侧变量与右侧序列元素的数量应相等。注意，多重赋值其实只是元组打包和序列解包的组合。</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Python 还支持 <em>集合</em> 这种数据类型。集合是由不重复元素组成的无序容器。基本用法包括成员检测、消除重复元素。集合对象支持合集、交集、差集、对称差分等数学运算。</p>
<p>创建集合用花括号或 <code>set()</code> 函数。注意，创建空集合只能用 <code>set()</code>，不能用 <code>{}</code>，<code>{}</code> 创建的是空字典。</p>
<p>以下是一些简单的示例</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> basket <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token string">'banana'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>basket<span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true"># show that duplicates have been removed</span>
<span class="token punctuation">{</span><span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'orange'</span> <span class="token keyword">in</span> basket                 <span class="token comment" spellcheck="true"># fast membership testing</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'crabgrass'</span> <span class="token keyword">in</span> basket
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Demonstrate set operations on unique letters from two words</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token string">'abracadabra'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token string">'alacazam'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a                                  <span class="token comment" spellcheck="true"># unique letters in a</span>
<span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">-</span> b                              <span class="token comment" spellcheck="true"># letters in a but not in b</span>
<span class="token punctuation">{</span><span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">|</span> b                              <span class="token comment" spellcheck="true"># letters in a or b or both</span>
<span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">&amp;</span> b                              <span class="token comment" spellcheck="true"># letters in both a and b</span>
<span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">^</span> b                              <span class="token comment" spellcheck="true"># letters in a or b but not both</span>
<span class="token punctuation">{</span><span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与 列表推导式 类似，集合也支持推导式：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">{</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token string">'abracadabra'</span> <span class="token keyword">if</span> x <span class="token operator">not</span> <span class="token keyword">in</span> <span class="token string">'abc'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> a
<span class="token punctuation">{</span><span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p><em>字典</em>  也是一种常用的 Python 內置数据类型。其他语言可能把字典称为 <em>联合内存</em> 或 <em>联合数组*。与以连续整数为索引的序列不同，字典以 *关键字</em> 为索引，关键字通常是字符串或数字，也可以是其他任意不可变类型。只包含字符串、数字、元组的元组，也可以用作关键字。但如果元组直接或间接地包含了可变对象，就不能用作关键字。列表不能当关键字，因为列表可以用索引、切片、<code>append()</code> 、<code>extend()</code> 等方法修改。</p>
<p>可以把字典理解为 <em>键值对</em> 的集合，但字典的键必须是唯一的。花括号 <code>{}</code> 用于创建空字典。另一种初始化字典的方式是，在花括号里输入逗号分隔的键值对，这也是字典的输出方式。</p>
<p>字典的主要用途是通过关键字存储、提取值。用 <code>del</code> 可以删除键值对。用已存在的关键字存储值，与该关键字关联的旧值会被取代。通过不存在的键提取值，则会报错。</p>
<p>对字典执行 <code>list(d)</code> 操作，返回该字典中所有键的列表，按插入次序排列（如需排序，请使用 <code>sorted(d)</code>）。检查字典里是否存在某个键，使用关键字 <code>in</code>。</p>
<p>以下是一些字典的简单示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> tel <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'jack'</span><span class="token punctuation">:</span> <span class="token number">4098</span><span class="token punctuation">,</span> <span class="token string">'sape'</span><span class="token punctuation">:</span> <span class="token number">4139</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> tel<span class="token punctuation">[</span><span class="token string">'guido'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4127</span>
<span class="token operator">>></span><span class="token operator">></span> tel
<span class="token punctuation">{</span><span class="token string">'jack'</span><span class="token punctuation">:</span> <span class="token number">4098</span><span class="token punctuation">,</span> <span class="token string">'sape'</span><span class="token punctuation">:</span> <span class="token number">4139</span><span class="token punctuation">,</span> <span class="token string">'guido'</span><span class="token punctuation">:</span> <span class="token number">4127</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> tel<span class="token punctuation">[</span><span class="token string">'jack'</span><span class="token punctuation">]</span>
<span class="token number">4098</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> tel<span class="token punctuation">[</span><span class="token string">'sape'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> tel<span class="token punctuation">[</span><span class="token string">'irv'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4127</span>
<span class="token operator">>></span><span class="token operator">></span> tel
<span class="token punctuation">{</span><span class="token string">'jack'</span><span class="token punctuation">:</span> <span class="token number">4098</span><span class="token punctuation">,</span> <span class="token string">'guido'</span><span class="token punctuation">:</span> <span class="token number">4127</span><span class="token punctuation">,</span> <span class="token string">'irv'</span><span class="token punctuation">:</span> <span class="token number">4127</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>tel<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'jack'</span><span class="token punctuation">,</span> <span class="token string">'guido'</span><span class="token punctuation">,</span> <span class="token string">'irv'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>tel<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'guido'</span><span class="token punctuation">,</span> <span class="token string">'irv'</span><span class="token punctuation">,</span> <span class="token string">'jack'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'guido'</span> <span class="token keyword">in</span> tel
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'jack'</span> <span class="token operator">not</span> <span class="token keyword">in</span> tel
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>dict()</code> 构造函数可以直接用键值对序列创建字典：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> dict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'sape'</span><span class="token punctuation">,</span> <span class="token number">4139</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'guido'</span><span class="token punctuation">,</span> <span class="token number">4127</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'jack'</span><span class="token punctuation">,</span> <span class="token number">4098</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">'sape'</span><span class="token punctuation">:</span> <span class="token number">4139</span><span class="token punctuation">,</span> <span class="token string">'guido'</span><span class="token punctuation">:</span> <span class="token number">4127</span><span class="token punctuation">,</span> <span class="token string">'jack'</span><span class="token punctuation">:</span> <span class="token number">4098</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>字典推导式可以用任意键值表达式创建字典：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">{</span>x<span class="token punctuation">:</span> x<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">:</span> <span class="token number">36</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>关键字是比较简单的字符串时，直接用关键字参数指定键值对更便捷：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> dict<span class="token punctuation">(</span>sape<span class="token operator">=</span><span class="token number">4139</span><span class="token punctuation">,</span> guido<span class="token operator">=</span><span class="token number">4127</span><span class="token punctuation">,</span> jack<span class="token operator">=</span><span class="token number">4098</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">'sape'</span><span class="token punctuation">:</span> <span class="token number">4139</span><span class="token punctuation">,</span> <span class="token string">'guido'</span><span class="token punctuation">:</span> <span class="token number">4127</span><span class="token punctuation">,</span> <span class="token string">'jack'</span><span class="token punctuation">:</span> <span class="token number">4098</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="循环的技巧"><a href="#循环的技巧" class="headerlink" title="循环的技巧"></a>循环的技巧</h3><p>在字典中循环时，用 <code>items()</code> 方法可同时取出键和对应的值：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> knights <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'gallahad'</span><span class="token punctuation">:</span> <span class="token string">'the pure'</span><span class="token punctuation">,</span> <span class="token string">'robin'</span><span class="token punctuation">:</span> <span class="token string">'the brave'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> knights<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
gallahad the pure
robin the brave<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在序列中循环时，用 <code>enumerate()</code> 函数可以同时取出位置索引和对应的值：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'tic'</span><span class="token punctuation">,</span> <span class="token string">'tac'</span><span class="token punctuation">,</span> <span class="token string">'toe'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">0</span> tic
<span class="token number">1</span> tac
<span class="token number">2</span> toe<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时循环两个或多个序列时，用 <code>zip()</code> 函数可以将其内的元素一一匹配：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> questions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'quest'</span><span class="token punctuation">,</span> <span class="token string">'favorite color'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> answers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'lancelot'</span><span class="token punctuation">,</span> <span class="token string">'the holy grail'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> q<span class="token punctuation">,</span> a <span class="token keyword">in</span> zip<span class="token punctuation">(</span>questions<span class="token punctuation">,</span> answers<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'What is your {0}?  It is {1}.'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>q<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
What <span class="token keyword">is</span> your name?  It <span class="token keyword">is</span> lancelot<span class="token punctuation">.</span>
What <span class="token keyword">is</span> your quest?  It <span class="token keyword">is</span> the holy grail<span class="token punctuation">.</span>
What <span class="token keyword">is</span> your favorite color?  It <span class="token keyword">is</span> blue<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>逆向循环序列时，先正向定位序列，然后调用 <code>reversed()</code> 函数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> i <span class="token keyword">in</span> reversed<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">9</span>
<span class="token number">7</span>
<span class="token number">5</span>
<span class="token number">3</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>按指定顺序循环序列，可以用 <code>sorted()</code> 函数，在不改动原序列的基础上，返回一个重新的序列：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> basket <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token string">'banana'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> i <span class="token keyword">in</span> sorted<span class="token punctuation">(</span>basket<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
apple
apple
banana
orange
orange
pear<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>set()</code> 去除序列中的重复元素。使用 <code>sorted()</code> 加 <code>set()</code> 则按排序后的顺序，循环遍历序列中的唯一元素：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> basket <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token string">'banana'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> f <span class="token keyword">in</span> sorted<span class="token punctuation">(</span>set<span class="token punctuation">(</span>basket<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
apple
banana
orange
pear<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一般来说，在循环中修改列表的内容时，创建新列表比较简单，且安全：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> math
<span class="token operator">>></span><span class="token operator">></span> raw_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">56.2</span><span class="token punctuation">,</span> float<span class="token punctuation">(</span><span class="token string">'NaN'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">51.7</span><span class="token punctuation">,</span> <span class="token number">55.3</span><span class="token punctuation">,</span> <span class="token number">52.5</span><span class="token punctuation">,</span> float<span class="token punctuation">(</span><span class="token string">'NaN'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">47.8</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> filtered_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> value <span class="token keyword">in</span> raw_data<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> <span class="token operator">not</span> math<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         filtered_data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> filtered_data
<span class="token punctuation">[</span><span class="token number">56.2</span><span class="token punctuation">,</span> <span class="token number">51.7</span><span class="token punctuation">,</span> <span class="token number">55.3</span><span class="token punctuation">,</span> <span class="token number">52.5</span><span class="token punctuation">,</span> <span class="token number">47.8</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="深入条件控制"><a href="#深入条件控制" class="headerlink" title="深入条件控制"></a>深入条件控制</h3><p><code>while</code> 和 <code>if</code> 条件句不只可以进行比较，还可以使用任意运算符。</p>
<p>比较运算符 <code>in</code> 和 <code>not in</code> 校验序列里是否存在某个值。运算符 <code>is</code> 和 <code>is not</code> 比较两个对象是否为同一个对象。所有比较运算符的优先级都一样，且低于数值运算符。</p>
<p>比较操作支持链式操作。例如，<code>a &lt; b == c</code> 校验 <code>a</code> 是否小于 <code>b</code>，且 <code>b</code> 是否等于 <code>c</code>。</p>
<p>比较操作可以用布尔运算符 <code>and</code> 和 <code>or</code> 组合，并且，比较操作（或其他布尔运算）的结果都可以用 <code>not</code> 取反。这些操作符的优先级低于比较操作符；<code>not</code> 的优先级最高， <code>or</code> 的优先级最低，因此，<code>A and not B or C</code> 等价于 <code>(A and (not B)) or C</code>。与其他运算符操作一样，此处也可以用圆括号表示想要的组合。</p>
<p>布尔运算符 <code>and</code> 和 <code>or</code> 也称为 <em>短路</em> 运算符：其参数从左至右解析，一旦可以确定结果，解析就会停止。例如，如果 <code>A</code> 和 <code>C</code> 为真，<code>B</code> 为假，那么 <code>A and B and C</code> 不会解析 <code>C</code>。用作普通值而不是布尔值时，短路操作符返回的值通常是最后一个变量。</p>
<p>还可以把比较操作或逻辑表达式的结果赋值给变量，例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> string1<span class="token punctuation">,</span> string2<span class="token punctuation">,</span> string3 <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'Trondheim'</span><span class="token punctuation">,</span> <span class="token string">'Hammer Dance'</span>
<span class="token operator">>></span><span class="token operator">></span> non_null <span class="token operator">=</span> string1 <span class="token operator">or</span> string2 <span class="token operator">or</span> string3
<span class="token operator">>></span><span class="token operator">></span> non_null
<span class="token string">'Trondheim'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，Python 与 C 不同，在表达式内部赋值必须显式使用 海象运算符 <code>:=</code>。 这避免了 C 程序中常见的问题：要在表达式中写 <code>==</code> 时，却写成了 <code>=</code>。</p>
<h3 id="序列和其他类型的比较"><a href="#序列和其他类型的比较" class="headerlink" title="序列和其他类型的比较"></a>序列和其他类型的比较</h3><p>序列对象可以与相同序列类型的其他对象比较。这种比较使用 <em>字典式</em> 顺序：首先，比较前两个对应元素，如果不相等，则可确定比较结果；如果相等，则比较之后的两个元素，以此类推，直到其中一个序列结束。如果要比较的两个元素本身是相同类型的序列，则递归地执行字典式顺序比较。如果两个序列中所有的对应元素都相等，则两个序列相等。如果一个序列是另一个的初始子序列，则较短的序列可被视为较小（较少）的序列。 对于字符串来说，字典式顺序使用 Unicode 码位序号排序单个字符。下面列出了一些比较相同类型序列的例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>              <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>              <span class="token operator">&lt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
<span class="token string">'ABC'</span> <span class="token operator">&lt;</span> <span class="token string">'C'</span> <span class="token operator">&lt;</span> <span class="token string">'Pascal'</span> <span class="token operator">&lt;</span> <span class="token string">'Python'</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>           <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>                 <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>             <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'aa'</span><span class="token punctuation">,</span> <span class="token string">'ab'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，对不同类型的对象来说，只要待比较的对象提供了合适的比较方法，就可以使用 <code>&lt;</code> 和 <code>&gt;</code> 进行比较。例如，混合数值类型通过数值进行比较，所以，0 等于 0.0，等等。否则，解释器不会随便给出一个对比结果，而是触发 <code>TypeError</code> 异常。</p>
<p>注：</p>
<ul>
<li>别的语言可能会返回可变对象，允许方法连续执行，例如，<code>d-&gt;insert("a")-&gt;remove("b")-&gt;sort();</code>。</li>
</ul>
<h2 id="5-模块"><a href="#5-模块" class="headerlink" title="5. 模块"></a>5. 模块</h2><p>退出 Python 解释器后，再次进入时，之前在 Python 解释器中定义的函数和变量就丢失了。因此，编写较长程序时，建议用文本编辑器代替解释器，执行文件中的输入内容，这就是编写 <em>脚本</em> 。随着程序越来越长，为了方便维护，最好把脚本拆分成多个文件。编写脚本还一个好处，不同程序调用同一个函数时，不用每次把函数复制到各个程序。</p>
<p>为实现这些需求，Python 把各种定义存入一个文件，在脚本或解释器的交互式实例中使用。这个文件就是 <em>模块</em> ；模块中的定义可以 <em>导入</em> 到其他模块或 <em>主</em> 模块（在顶层和计算器模式下，执行脚本中可访问的变量集）。</p>
<p>模块是包含 Python 定义和语句的文件。其文件名是模块名加后缀名 <code>.py</code> 。在模块内部，通过全局变量 <code>__name__</code> 可以获取模块名（即字符串）。例如，用文本编辑器在当前目录下创建 <code>fibo.py</code> 文件，输入以下内容：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Fibonacci numbers module</span>
<span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># write Fibonacci series up to n</span>
    a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>
    <span class="token keyword">while</span> a <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>
        a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a<span class="token operator">+</span>b
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">fib2</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true"># return Fibonacci series up to n</span>
    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span>
    <span class="token keyword">while</span> a <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>
        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
        a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> a<span class="token operator">+</span>b
    <span class="token keyword">return</span> result<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在，进入 Python 解释器，用以下命令导入该模块：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> fibo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这项操作不直接把 <code>fibo</code> 函数定义的名称导入到当前符号表，只导入模块名 <code>fibo</code> 。要使用模块名访问函数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fibo<span class="token punctuation">.</span>fib<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token number">13</span> <span class="token number">21</span> <span class="token number">34</span> <span class="token number">55</span> <span class="token number">89</span> <span class="token number">144</span> <span class="token number">233</span> <span class="token number">377</span> <span class="token number">610</span> <span class="token number">987</span>
<span class="token operator">>></span><span class="token operator">></span> fibo<span class="token punctuation">.</span>fib2<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> fibo<span class="token punctuation">.</span>__name__
<span class="token string">'fibo'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果经常使用某个函数，可以把它赋值给局部变量：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fib <span class="token operator">=</span> fibo<span class="token punctuation">.</span>fib
<span class="token operator">>></span><span class="token operator">></span> fib<span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>
<span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token number">13</span> <span class="token number">21</span> <span class="token number">34</span> <span class="token number">55</span> <span class="token number">89</span> <span class="token number">144</span> <span class="token number">233</span> <span class="token number">377</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="模块详解"><a href="#模块详解" class="headerlink" title="模块详解"></a>模块详解</h3><p>模块包含可执行语句及函数定义。这些语句用于初始化模块，且仅在 import 语句 <em>第一次</em> 遇到模块名时执行。<a href="https://www.bookstack.cn/read/python-3.10.0-zh/4cb19ebf7e8e5a86.md#id3" target="_blank" rel="noopener">1</a> (文件作为脚本运行时，也会执行这些语句。)</p>
<p>模块有自己的私有符号表，用作模块中所有函数的全局符号表。因此，在模块内使用全局变量时，不用担心与用户定义的全局变量发生冲突。另一方面，可以用与访问模块函数一样的标记法，访问模块的全局变量，<code>modname.itemname</code>。</p>
<p>可以把其他模块导入模块。按惯例，所有 <code>import</code> 语句都放在模块（或脚本）开头，但这不是必须的。导入的模块名存在导入模块的全局符号表里。</p>
<p><code>import</code> 语句有一个变体，可以直接把模块里的名称导入到另一个模块的符号表。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> fibo <span class="token keyword">import</span> fib<span class="token punctuation">,</span> fib2
<span class="token operator">>></span><span class="token operator">></span> fib<span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>
<span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token number">13</span> <span class="token number">21</span> <span class="token number">34</span> <span class="token number">55</span> <span class="token number">89</span> <span class="token number">144</span> <span class="token number">233</span> <span class="token number">377</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这段代码不会把模块名导入到局部符号表里（因此，本例没有定义 <code>fibo</code>）。</p>
<p>还有一种变体可以导入模块内定义的所有名称：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> fibo <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span> fib<span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>
<span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token number">13</span> <span class="token number">21</span> <span class="token number">34</span> <span class="token number">55</span> <span class="token number">89</span> <span class="token number">144</span> <span class="token number">233</span> <span class="token number">377</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这种方式会导入所有不以下划线（<code>_</code>）开头的名称。大多数情况下，不要用这个功能，这种方式向解释器导入了一批未知的名称，可能会覆盖已经定义的名称。</p>
<p>注意，一般情况下，不建议从模块或包内导入 <code>*</code>， 因为，这项操作经常让代码变得难以理解。不过，为了在交互式编译器中少打几个字，这么用也没问题。</p>
<p>模块名后使用 <code>as</code> 时，直接把 <code>as</code> 后的名称与导入模块绑定。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> fibo <span class="token keyword">as</span> fib
<span class="token operator">>></span><span class="token operator">></span> fib<span class="token punctuation">.</span>fib<span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>
<span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token number">13</span> <span class="token number">21</span> <span class="token number">34</span> <span class="token number">55</span> <span class="token number">89</span> <span class="token number">144</span> <span class="token number">233</span> <span class="token number">377</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>与 <code>import fibo</code> 一样，这种方式也可以有效地导入模块，唯一的区别是，导入的名称是 <code>fib</code>。</p>
<p><code>from</code> 中也可以使用这种方式，效果类似：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> fibo <span class="token keyword">import</span> fib <span class="token keyword">as</span> fibonacci
<span class="token operator">>></span><span class="token operator">></span> fibonacci<span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span>
<span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token number">13</span> <span class="token number">21</span> <span class="token number">34</span> <span class="token number">55</span> <span class="token number">89</span> <span class="token number">144</span> <span class="token number">233</span> <span class="token number">377</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>为了保证运行效率，每次解释器会话只导入一次模块。如果更改了模块内容，必须重启解释器；仅交互测试一个模块时，也可以使用 <code>importlib.reload()</code>，例如 <code>import importlib; importlib.reload(modulename)</code>。</p>
<h4 id="以脚本方式执行模块"><a href="#以脚本方式执行模块" class="headerlink" title="以脚本方式执行模块"></a>以脚本方式执行模块</h4><p>可以用以下方式运行 Python 模块：</p>
<pre><code>python fibo.py &lt;arguments&gt;</code></pre><p>这项操作将执行模块里的代码，和导入模块一样，但会把 <code>__name__</code> 赋值为 <code>"__main__"</code>。 也就是把下列代码添加到模块末尾：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    <span class="token keyword">import</span> sys
    fib<span class="token punctuation">(</span>int<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>既可以把这个文件当脚本使用，也可以用作导入的模块， 因为，解析命令行的代码只有在模块以 “main” 文件执行时才会运行：</p>
<pre><code>$ python fibo.py 500 
1 1 2 3 5 8 13 21 34</code></pre><p>导入模块时，不运行这些代码：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> fibo
<span class="token operator">>></span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这种操作常用于为模块提供便捷用户接口，或用于测试（把模块当作执行测试套件的脚本运行）。</p>
<h4 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h4><p>导入 <code>spam</code> 模块时，解释器首先查找名为 spam 的内置模块。如果没找到，解释器再从 <code>sys.path</code> 变量中的目录列表里查找 <code>spam.py</code> 文件。<code>sys.path</code> 初始化时包含以下位置：</p>
<ul>
<li>输入脚本的目录（或未指定文件时的当前目录）。</li>
<li><code>PYTHONPATH</code> （目录列表，与 shell 变量 <code>PATH</code> 的语法一样）。</li>
<li>The installation-dependent default (by convention including a <code>site-packages</code> directory, handled by the <code>site</code> module).</li>
</ul>
<p>注解</p>
<p>在支持 symlink 的文件系统中，输入脚本目录是在追加 symlink 后计算出来的。换句话说，包含 symlink 的目录并 <strong>没有</strong> 添加至模块搜索路径。</p>
<p>初始化后，Python 程序可以更改 <code>sys.path</code>。运行脚本的目录在标准库路径之前，置于搜索路径的开头。即，加载的是该目录里的脚本，而不是标准库的同名模块。 除非刻意替换，否则会报错。</p>
<h4 id="“已编译的”-Python-文件"><a href="#“已编译的”-Python-文件" class="headerlink" title="“已编译的” Python 文件"></a>“已编译的” Python 文件</h4><p>为了快速加载模块，Python 把模块的编译版缓存在 <code>__pycache__</code> 目录中，文件名为 <code>module.*version*.pyc</code>，version 对编译文件格式进行编码，一般是 Python 的版本号。例如，CPython 的 3.3 发行版中，spam.py 的编译版本缓存为 <code>__pycache__/spam.cpython-33.pyc</code>。使用这种命名惯例，可以让不同 Python 发行版及不同版本的已编译模块共存。</p>
<p>Python 对比编译版本与源码的修改日期，查看它是否已过期，是否要重新编译，此过程完全自动化。此外，编译模块与平台无关，因此，可在不同架构系统之间共享相同的支持库。</p>
<p>Python 在两种情况下不检查缓存。其一，从命令行直接载入模块，只重新编译，不存储编译结果；其二，没有源模块，就不会检查缓存。为了支持无源文件（仅编译）发行版本， 编译模块必须在源目录下，并且绝不能有源模块。</p>
<p>给专业人士的一些小建议：</p>
<ul>
<li>在 Python 命令中使用 <code>-O</code> 或 <code>-OO</code> 开关，可以减小编译模块的大小。<code>-O</code> 去除断言语句，<code>-OO</code> 去除断言语句和 <strong>doc</strong> 字符串。有些程序可能依赖于这些内容，因此，没有十足的把握，不要使用这两个选项。“优化过的”模块带有 <code>opt-</code> 标签，并且文件通常会一小些。将来的发行版或许会改进优化的效果。</li>
<li>从 <code>.pyc</code> 文件读取的程序不比从 <code>.py</code> 读取的执行速度快，<code>.pyc</code> 文件只是加载速度更快。</li>
<li><code>compileall</code> 模块可以为一个目录下的所有模块创建 .pyc 文件。</li>
<li>本过程的细节及决策流程图，详见 <a href="https://www.python.org/dev/peps/pep-3147" target="_blank" rel="noopener"><strong>PEP 3147</strong></a>。</li>
</ul>
<h3 id="标准模块"><a href="#标准模块" class="headerlink" title="标准模块"></a>标准模块</h3><p>Python 自带一个标准模块的库，它在 Python 库参考（此处以下称为”库参考” ）里另外描述。 一些模块是内嵌到编译器里面的， 它们给一些虽并非语言核心但却内嵌的操作提供接口，要么是为了效率，要么是给操作系统基础操作例如系统调入提供接口。 这些模块集是一个配置选项， 并且还依赖于底层的操作系统。 例如，<code>winreg</code> 模块只在 Windows 系统上提供。一个特别值得注意的模块 <code>sys</code>，它被内嵌到每一个 Python 编译器中。<code>sys.ps1</code> 和 <code>sys.ps2</code> 变量定义了一些字符，它们可以用作主提示符和辅助提示符:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> sys
<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>ps1
<span class="token string">'>>> '</span>
<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>ps2
<span class="token string">'... '</span>
<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>ps1 <span class="token operator">=</span> <span class="token string">'C> '</span>
C<span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Yuck!'</span><span class="token punctuation">)</span>
Yuck!
C<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只有解释器用于交互模式时，才定义这两个变量。</p>
<p>变量 <code>sys.path</code> 是字符串列表，用于确定解释器的模块搜索路径。该变量以环境变量 <code>PYTHONPATH</code> 提取的默认路径进行初始化，如未设置 <code>PYTHONPATH</code>，则使用内置的默认路径。可以用标准列表操作修改该变量：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> sys
<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>path<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'/ufs/guido/lib/python'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir() 函数"></a><code>dir()</code> 函数</h3><p>内置函数 <code>dir()</code> 用于查找模块定义的名称。返回结果是经过排序的字符串列表：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> fibo<span class="token punctuation">,</span> sys
<span class="token operator">>></span><span class="token operator">></span> dir<span class="token punctuation">(</span>fibo<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'__name__'</span><span class="token punctuation">,</span> <span class="token string">'fib'</span><span class="token punctuation">,</span> <span class="token string">'fib2'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> dir<span class="token punctuation">(</span>sys<span class="token punctuation">)</span>  
<span class="token punctuation">[</span><span class="token string">'__breakpointhook__'</span><span class="token punctuation">,</span> <span class="token string">'__displayhook__'</span><span class="token punctuation">,</span> <span class="token string">'__doc__'</span><span class="token punctuation">,</span> <span class="token string">'__excepthook__'</span><span class="token punctuation">,</span>
 <span class="token string">'__interactivehook__'</span><span class="token punctuation">,</span> <span class="token string">'__loader__'</span><span class="token punctuation">,</span> <span class="token string">'__name__'</span><span class="token punctuation">,</span> <span class="token string">'__package__'</span><span class="token punctuation">,</span> <span class="token string">'__spec__'</span><span class="token punctuation">,</span>
 <span class="token string">'__stderr__'</span><span class="token punctuation">,</span> <span class="token string">'__stdin__'</span><span class="token punctuation">,</span> <span class="token string">'__stdout__'</span><span class="token punctuation">,</span> <span class="token string">'__unraisablehook__'</span><span class="token punctuation">,</span>
 <span class="token string">'_clear_type_cache'</span><span class="token punctuation">,</span> <span class="token string">'_current_frames'</span><span class="token punctuation">,</span> <span class="token string">'_debugmallocstats'</span><span class="token punctuation">,</span> <span class="token string">'_framework'</span><span class="token punctuation">,</span>
 <span class="token string">'_getframe'</span><span class="token punctuation">,</span> <span class="token string">'_git'</span><span class="token punctuation">,</span> <span class="token string">'_home'</span><span class="token punctuation">,</span> <span class="token string">'_xoptions'</span><span class="token punctuation">,</span> <span class="token string">'abiflags'</span><span class="token punctuation">,</span> <span class="token string">'addaudithook'</span><span class="token punctuation">,</span>
 <span class="token string">'api_version'</span><span class="token punctuation">,</span> <span class="token string">'argv'</span><span class="token punctuation">,</span> <span class="token string">'audit'</span><span class="token punctuation">,</span> <span class="token string">'base_exec_prefix'</span><span class="token punctuation">,</span> <span class="token string">'base_prefix'</span><span class="token punctuation">,</span>
 <span class="token string">'breakpointhook'</span><span class="token punctuation">,</span> <span class="token string">'builtin_module_names'</span><span class="token punctuation">,</span> <span class="token string">'byteorder'</span><span class="token punctuation">,</span> <span class="token string">'call_tracing'</span><span class="token punctuation">,</span>
 <span class="token string">'callstats'</span><span class="token punctuation">,</span> <span class="token string">'copyright'</span><span class="token punctuation">,</span> <span class="token string">'displayhook'</span><span class="token punctuation">,</span> <span class="token string">'dont_write_bytecode'</span><span class="token punctuation">,</span> <span class="token string">'exc_info'</span><span class="token punctuation">,</span>
 <span class="token string">'excepthook'</span><span class="token punctuation">,</span> <span class="token string">'exec_prefix'</span><span class="token punctuation">,</span> <span class="token string">'executable'</span><span class="token punctuation">,</span> <span class="token string">'exit'</span><span class="token punctuation">,</span> <span class="token string">'flags'</span><span class="token punctuation">,</span> <span class="token string">'float_info'</span><span class="token punctuation">,</span>
 <span class="token string">'float_repr_style'</span><span class="token punctuation">,</span> <span class="token string">'get_asyncgen_hooks'</span><span class="token punctuation">,</span> <span class="token string">'get_coroutine_origin_tracking_depth'</span><span class="token punctuation">,</span>
 <span class="token string">'getallocatedblocks'</span><span class="token punctuation">,</span> <span class="token string">'getdefaultencoding'</span><span class="token punctuation">,</span> <span class="token string">'getdlopenflags'</span><span class="token punctuation">,</span>
 <span class="token string">'getfilesystemencodeerrors'</span><span class="token punctuation">,</span> <span class="token string">'getfilesystemencoding'</span><span class="token punctuation">,</span> <span class="token string">'getprofile'</span><span class="token punctuation">,</span>
 <span class="token string">'getrecursionlimit'</span><span class="token punctuation">,</span> <span class="token string">'getrefcount'</span><span class="token punctuation">,</span> <span class="token string">'getsizeof'</span><span class="token punctuation">,</span> <span class="token string">'getswitchinterval'</span><span class="token punctuation">,</span>
 <span class="token string">'gettrace'</span><span class="token punctuation">,</span> <span class="token string">'hash_info'</span><span class="token punctuation">,</span> <span class="token string">'hexversion'</span><span class="token punctuation">,</span> <span class="token string">'implementation'</span><span class="token punctuation">,</span> <span class="token string">'int_info'</span><span class="token punctuation">,</span>
 <span class="token string">'intern'</span><span class="token punctuation">,</span> <span class="token string">'is_finalizing'</span><span class="token punctuation">,</span> <span class="token string">'last_traceback'</span><span class="token punctuation">,</span> <span class="token string">'last_type'</span><span class="token punctuation">,</span> <span class="token string">'last_value'</span><span class="token punctuation">,</span>
 <span class="token string">'maxsize'</span><span class="token punctuation">,</span> <span class="token string">'maxunicode'</span><span class="token punctuation">,</span> <span class="token string">'meta_path'</span><span class="token punctuation">,</span> <span class="token string">'modules'</span><span class="token punctuation">,</span> <span class="token string">'path'</span><span class="token punctuation">,</span> <span class="token string">'path_hooks'</span><span class="token punctuation">,</span>
 <span class="token string">'path_importer_cache'</span><span class="token punctuation">,</span> <span class="token string">'platform'</span><span class="token punctuation">,</span> <span class="token string">'prefix'</span><span class="token punctuation">,</span> <span class="token string">'ps1'</span><span class="token punctuation">,</span> <span class="token string">'ps2'</span><span class="token punctuation">,</span> <span class="token string">'pycache_prefix'</span><span class="token punctuation">,</span>
 <span class="token string">'set_asyncgen_hooks'</span><span class="token punctuation">,</span> <span class="token string">'set_coroutine_origin_tracking_depth'</span><span class="token punctuation">,</span> <span class="token string">'setdlopenflags'</span><span class="token punctuation">,</span>
 <span class="token string">'setprofile'</span><span class="token punctuation">,</span> <span class="token string">'setrecursionlimit'</span><span class="token punctuation">,</span> <span class="token string">'setswitchinterval'</span><span class="token punctuation">,</span> <span class="token string">'settrace'</span><span class="token punctuation">,</span> <span class="token string">'stderr'</span><span class="token punctuation">,</span>
 <span class="token string">'stdin'</span><span class="token punctuation">,</span> <span class="token string">'stdout'</span><span class="token punctuation">,</span> <span class="token string">'thread_info'</span><span class="token punctuation">,</span> <span class="token string">'unraisablehook'</span><span class="token punctuation">,</span> <span class="token string">'version'</span><span class="token punctuation">,</span> <span class="token string">'version_info'</span><span class="token punctuation">,</span>
 <span class="token string">'warnoptions'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>没有参数时，<code>dir()</code> 列出当前定义的名称：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> fibo
<span class="token operator">>></span><span class="token operator">></span> fib <span class="token operator">=</span> fibo<span class="token punctuation">.</span>fib
<span class="token operator">>></span><span class="token operator">></span> dir<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'__builtins__'</span><span class="token punctuation">,</span> <span class="token string">'__name__'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'fib'</span><span class="token punctuation">,</span> <span class="token string">'fibo'</span><span class="token punctuation">,</span> <span class="token string">'sys'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，该函数列出所有类型的名称：变量、模块、函数等。</p>
<p><code>dir()</code> 不会列出内置函数和变量的名称。这些内容的定义在标准模块 <code>builtins</code> 里：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> builtins
<span class="token operator">>></span><span class="token operator">></span> dir<span class="token punctuation">(</span>builtins<span class="token punctuation">)</span>  
<span class="token punctuation">[</span><span class="token string">'ArithmeticError'</span><span class="token punctuation">,</span> <span class="token string">'AssertionError'</span><span class="token punctuation">,</span> <span class="token string">'AttributeError'</span><span class="token punctuation">,</span> <span class="token string">'BaseException'</span><span class="token punctuation">,</span>
 <span class="token string">'BlockingIOError'</span><span class="token punctuation">,</span> <span class="token string">'BrokenPipeError'</span><span class="token punctuation">,</span> <span class="token string">'BufferError'</span><span class="token punctuation">,</span> <span class="token string">'BytesWarning'</span><span class="token punctuation">,</span>
 <span class="token string">'ChildProcessError'</span><span class="token punctuation">,</span> <span class="token string">'ConnectionAbortedError'</span><span class="token punctuation">,</span> <span class="token string">'ConnectionError'</span><span class="token punctuation">,</span>
 <span class="token string">'ConnectionRefusedError'</span><span class="token punctuation">,</span> <span class="token string">'ConnectionResetError'</span><span class="token punctuation">,</span> <span class="token string">'DeprecationWarning'</span><span class="token punctuation">,</span>
 <span class="token string">'EOFError'</span><span class="token punctuation">,</span> <span class="token string">'Ellipsis'</span><span class="token punctuation">,</span> <span class="token string">'EnvironmentError'</span><span class="token punctuation">,</span> <span class="token string">'Exception'</span><span class="token punctuation">,</span> <span class="token string">'False'</span><span class="token punctuation">,</span>
 <span class="token string">'FileExistsError'</span><span class="token punctuation">,</span> <span class="token string">'FileNotFoundError'</span><span class="token punctuation">,</span> <span class="token string">'FloatingPointError'</span><span class="token punctuation">,</span>
 <span class="token string">'FutureWarning'</span><span class="token punctuation">,</span> <span class="token string">'GeneratorExit'</span><span class="token punctuation">,</span> <span class="token string">'IOError'</span><span class="token punctuation">,</span> <span class="token string">'ImportError'</span><span class="token punctuation">,</span>
 <span class="token string">'ImportWarning'</span><span class="token punctuation">,</span> <span class="token string">'IndentationError'</span><span class="token punctuation">,</span> <span class="token string">'IndexError'</span><span class="token punctuation">,</span> <span class="token string">'InterruptedError'</span><span class="token punctuation">,</span>
 <span class="token string">'IsADirectoryError'</span><span class="token punctuation">,</span> <span class="token string">'KeyError'</span><span class="token punctuation">,</span> <span class="token string">'KeyboardInterrupt'</span><span class="token punctuation">,</span> <span class="token string">'LookupError'</span><span class="token punctuation">,</span>
 <span class="token string">'MemoryError'</span><span class="token punctuation">,</span> <span class="token string">'NameError'</span><span class="token punctuation">,</span> <span class="token string">'None'</span><span class="token punctuation">,</span> <span class="token string">'NotADirectoryError'</span><span class="token punctuation">,</span> <span class="token string">'NotImplemented'</span><span class="token punctuation">,</span>
 <span class="token string">'NotImplementedError'</span><span class="token punctuation">,</span> <span class="token string">'OSError'</span><span class="token punctuation">,</span> <span class="token string">'OverflowError'</span><span class="token punctuation">,</span>
 <span class="token string">'PendingDeprecationWarning'</span><span class="token punctuation">,</span> <span class="token string">'PermissionError'</span><span class="token punctuation">,</span> <span class="token string">'ProcessLookupError'</span><span class="token punctuation">,</span>
 <span class="token string">'ReferenceError'</span><span class="token punctuation">,</span> <span class="token string">'ResourceWarning'</span><span class="token punctuation">,</span> <span class="token string">'RuntimeError'</span><span class="token punctuation">,</span> <span class="token string">'RuntimeWarning'</span><span class="token punctuation">,</span>
 <span class="token string">'StopIteration'</span><span class="token punctuation">,</span> <span class="token string">'SyntaxError'</span><span class="token punctuation">,</span> <span class="token string">'SyntaxWarning'</span><span class="token punctuation">,</span> <span class="token string">'SystemError'</span><span class="token punctuation">,</span>
 <span class="token string">'SystemExit'</span><span class="token punctuation">,</span> <span class="token string">'TabError'</span><span class="token punctuation">,</span> <span class="token string">'TimeoutError'</span><span class="token punctuation">,</span> <span class="token string">'True'</span><span class="token punctuation">,</span> <span class="token string">'TypeError'</span><span class="token punctuation">,</span>
 <span class="token string">'UnboundLocalError'</span><span class="token punctuation">,</span> <span class="token string">'UnicodeDecodeError'</span><span class="token punctuation">,</span> <span class="token string">'UnicodeEncodeError'</span><span class="token punctuation">,</span>
 <span class="token string">'UnicodeError'</span><span class="token punctuation">,</span> <span class="token string">'UnicodeTranslateError'</span><span class="token punctuation">,</span> <span class="token string">'UnicodeWarning'</span><span class="token punctuation">,</span> <span class="token string">'UserWarning'</span><span class="token punctuation">,</span>
 <span class="token string">'ValueError'</span><span class="token punctuation">,</span> <span class="token string">'Warning'</span><span class="token punctuation">,</span> <span class="token string">'ZeroDivisionError'</span><span class="token punctuation">,</span> <span class="token string">'_'</span><span class="token punctuation">,</span> <span class="token string">'__build_class__'</span><span class="token punctuation">,</span>
 <span class="token string">'__debug__'</span><span class="token punctuation">,</span> <span class="token string">'__doc__'</span><span class="token punctuation">,</span> <span class="token string">'__import__'</span><span class="token punctuation">,</span> <span class="token string">'__name__'</span><span class="token punctuation">,</span> <span class="token string">'__package__'</span><span class="token punctuation">,</span> <span class="token string">'abs'</span><span class="token punctuation">,</span>
 <span class="token string">'all'</span><span class="token punctuation">,</span> <span class="token string">'any'</span><span class="token punctuation">,</span> <span class="token string">'ascii'</span><span class="token punctuation">,</span> <span class="token string">'bin'</span><span class="token punctuation">,</span> <span class="token string">'bool'</span><span class="token punctuation">,</span> <span class="token string">'bytearray'</span><span class="token punctuation">,</span> <span class="token string">'bytes'</span><span class="token punctuation">,</span> <span class="token string">'callable'</span><span class="token punctuation">,</span>
 <span class="token string">'chr'</span><span class="token punctuation">,</span> <span class="token string">'classmethod'</span><span class="token punctuation">,</span> <span class="token string">'compile'</span><span class="token punctuation">,</span> <span class="token string">'complex'</span><span class="token punctuation">,</span> <span class="token string">'copyright'</span><span class="token punctuation">,</span> <span class="token string">'credits'</span><span class="token punctuation">,</span>
 <span class="token string">'delattr'</span><span class="token punctuation">,</span> <span class="token string">'dict'</span><span class="token punctuation">,</span> <span class="token string">'dir'</span><span class="token punctuation">,</span> <span class="token string">'divmod'</span><span class="token punctuation">,</span> <span class="token string">'enumerate'</span><span class="token punctuation">,</span> <span class="token string">'eval'</span><span class="token punctuation">,</span> <span class="token string">'exec'</span><span class="token punctuation">,</span> <span class="token string">'exit'</span><span class="token punctuation">,</span>
 <span class="token string">'filter'</span><span class="token punctuation">,</span> <span class="token string">'float'</span><span class="token punctuation">,</span> <span class="token string">'format'</span><span class="token punctuation">,</span> <span class="token string">'frozenset'</span><span class="token punctuation">,</span> <span class="token string">'getattr'</span><span class="token punctuation">,</span> <span class="token string">'globals'</span><span class="token punctuation">,</span> <span class="token string">'hasattr'</span><span class="token punctuation">,</span>
 <span class="token string">'hash'</span><span class="token punctuation">,</span> <span class="token string">'help'</span><span class="token punctuation">,</span> <span class="token string">'hex'</span><span class="token punctuation">,</span> <span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token string">'int'</span><span class="token punctuation">,</span> <span class="token string">'isinstance'</span><span class="token punctuation">,</span> <span class="token string">'issubclass'</span><span class="token punctuation">,</span>
 <span class="token string">'iter'</span><span class="token punctuation">,</span> <span class="token string">'len'</span><span class="token punctuation">,</span> <span class="token string">'license'</span><span class="token punctuation">,</span> <span class="token string">'list'</span><span class="token punctuation">,</span> <span class="token string">'locals'</span><span class="token punctuation">,</span> <span class="token string">'map'</span><span class="token punctuation">,</span> <span class="token string">'max'</span><span class="token punctuation">,</span> <span class="token string">'memoryview'</span><span class="token punctuation">,</span>
 <span class="token string">'min'</span><span class="token punctuation">,</span> <span class="token string">'next'</span><span class="token punctuation">,</span> <span class="token string">'object'</span><span class="token punctuation">,</span> <span class="token string">'oct'</span><span class="token punctuation">,</span> <span class="token string">'open'</span><span class="token punctuation">,</span> <span class="token string">'ord'</span><span class="token punctuation">,</span> <span class="token string">'pow'</span><span class="token punctuation">,</span> <span class="token string">'print'</span><span class="token punctuation">,</span> <span class="token string">'property'</span><span class="token punctuation">,</span>
 <span class="token string">'quit'</span><span class="token punctuation">,</span> <span class="token string">'range'</span><span class="token punctuation">,</span> <span class="token string">'repr'</span><span class="token punctuation">,</span> <span class="token string">'reversed'</span><span class="token punctuation">,</span> <span class="token string">'round'</span><span class="token punctuation">,</span> <span class="token string">'set'</span><span class="token punctuation">,</span> <span class="token string">'setattr'</span><span class="token punctuation">,</span> <span class="token string">'slice'</span><span class="token punctuation">,</span>
 <span class="token string">'sorted'</span><span class="token punctuation">,</span> <span class="token string">'staticmethod'</span><span class="token punctuation">,</span> <span class="token string">'str'</span><span class="token punctuation">,</span> <span class="token string">'sum'</span><span class="token punctuation">,</span> <span class="token string">'super'</span><span class="token punctuation">,</span> <span class="token string">'tuple'</span><span class="token punctuation">,</span> <span class="token string">'type'</span><span class="token punctuation">,</span> <span class="token string">'vars'</span><span class="token punctuation">,</span>
 <span class="token string">'zip'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包是一种用“点式模块名”构造 Python 模块命名空间的方法。例如，模块名 <code>A.B</code> 表示包 <code>A</code> 中名为 <code>B</code> 的子模块。正如模块可以区分不同模块之间的全局变量名称一样，点式模块名可以区分 NumPy 或 Pillow 等不同多模块包之间的模块名称。</p>
<p>假设要为统一处理声音文件与声音数据设计一个模块集（“包”）。声音文件的格式很多（通常以扩展名来识别，例如：<code>.wav</code>， <code>.aiff</code>， <code>.au</code>），因此，为了不同文件格式之间的转换，需要创建和维护一个不断增长的模块集合。为了实现对声音数据的不同处理（例如，混声、添加回声、均衡器功能、创造人工立体声效果），还要编写无穷无尽的模块流。下面这个分级文件树展示了这个包的架构：</p>
<pre><code>sound/                          Top-level package
      __init__.py               Initialize the sound package
      formats/                  Subpackage for file format conversions
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  Subpackage for sound effects
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  Subpackage for filters
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...</code></pre><p>导入包时，Python 搜索 <code>sys.path</code> 里的目录，查找包的子目录。</p>
<p>Python 只把含 <code>__init__.py</code> 文件的目录当成包。这样可以防止以 <code>string</code> 等通用名称命名的目录，无意中屏蔽出现在后方模块搜索路径中的有效模块。 最简情况下，<code>__init__.py</code> 只是一个空文件，但该文件也可以执行包的初始化代码，或设置 <code>__all__</code> 变量，详见下文。</p>
<p>还可以从包中导入单个模块，例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sound<span class="token punctuation">.</span>effects<span class="token punctuation">.</span>echo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这段代码加载子模块 <code>sound.effects.echo</code> ，但引用时必须使用子模块的全名：</p>
<pre class="line-numbers language-python"><code class="language-python">sound<span class="token punctuation">.</span>effects<span class="token punctuation">.</span>echo<span class="token punctuation">.</span>echofilter<span class="token punctuation">(</span>input<span class="token punctuation">,</span> output<span class="token punctuation">,</span> delay<span class="token operator">=</span><span class="token number">0.7</span><span class="token punctuation">,</span> atten<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>另一种导入子模块的方法是 ：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sound<span class="token punctuation">.</span>effects <span class="token keyword">import</span> echo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这段代码还可以加载子模块 <code>echo</code> ，不加包前缀也可以使用。因此，可以按如下方式使用：</p>
<pre class="line-numbers language-python"><code class="language-python">echo<span class="token punctuation">.</span>echofilter<span class="token punctuation">(</span>input<span class="token punctuation">,</span> output<span class="token punctuation">,</span> delay<span class="token operator">=</span><span class="token number">0.7</span><span class="token punctuation">,</span> atten<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>Import 语句的另一种变体是直接导入所需的函数或变量：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sound<span class="token punctuation">.</span>effects<span class="token punctuation">.</span>echo <span class="token keyword">import</span> echofilter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>同样，这样也会加载子模块 <code>echo</code>，但可以直接使用函数 <code>echofilter()</code>：</p>
<pre class="line-numbers language-python"><code class="language-python">echofilter<span class="token punctuation">(</span>input<span class="token punctuation">,</span> output<span class="token punctuation">,</span> delay<span class="token operator">=</span><span class="token number">0.7</span><span class="token punctuation">,</span> atten<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意，使用 <code>from package import item</code> 时，item 可以是包的子模块（或子包），也可以是包中定义的函数、类或变量等其他名称。<code>import</code> 语句首先测试包中是否定义了 item；如果未在包中定义，则假定 item 是模块，并尝试加载。如果找不到 item，则触发 <code>ImportError</code> 异常。</p>
<p>相反，使用 <code>import item.subitem.subsubitem</code> 句法时，除最后一项外，每个 item 都必须是包；最后一项可以是模块或包，但不能是上一项中定义的类、函数或变量。</p>
<h4 id="从包中导入"><a href="#从包中导入" class="headerlink" title="从包中导入 *"></a>从包中导入 *</h4><p>使用 <code>from sound.effects import *</code> 时会发生什么？理想情况下，该语句在文件系统查找并导入包的所有子模块。这项操作花费的时间较长，并且导入子模块可能会产生不必要的副作用，这种副作用只有在显式导入子模块时才会发生。</p>
<p>唯一的解决方案是提供包的显式索引。<code>import</code> 语句使用如下惯例：如果包的 <code>__init__.py</code> 代码定义了列表 <code>__all__</code>，运行 <code>from package import *</code> 时，它就是用于导入的模块名列表。发布包的新版本时，包的作者应更新此列表。如果包的作者认为没有必要在包中执行导入 * 操作，也可以不提供此列表。例如，<code>sound/effects/__init__.py</code> 文件包含以下代码：</p>
<pre class="line-numbers language-python"><code class="language-python">__all__ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"echo"</span><span class="token punctuation">,</span> <span class="token string">"surround"</span><span class="token punctuation">,</span> <span class="token string">"reverse"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>即，<code>from sound.effects import *</code> 将导入 <code>sound</code> 包中的这三个命名子模块。</p>
<p>如果没有定义 <code>__all__</code>，<code>from sound.effects import *</code> 语句 <em>不会</em> 把包 <code>sound.effects</code> 中所有子模块都导入到当前命名空间；该语句只确保导入包 <code>sound.effects</code> （可能还会运行 <code>__init__.py</code> 中的初始化代码），然后，再导入包中定义的名称。这些名称包括 <code>__init__.py</code> 中定义的任何名称（以及显式加载的子模块），还包括之前 <code>import</code> 语句显式加载的包里的子模块。请看以下代码：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sound<span class="token punctuation">.</span>effects<span class="token punctuation">.</span>echo
<span class="token keyword">import</span> sound<span class="token punctuation">.</span>effects<span class="token punctuation">.</span>surround
<span class="token keyword">from</span> sound<span class="token punctuation">.</span>effects <span class="token keyword">import</span> <span class="token operator">*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>本例中，执行 <code>from...import</code> 语句时，将把 <code>echo</code> 和 <code>surround</code> 模块导入至当前命名空间，因为，它们是在 <code>sound.effects</code> 包里定义的。（该导入操作在定义了 <code>__all__</code> 时也有效。）</p>
<p>虽然，可以把模块设计为用 <code>import *</code> 时只导出遵循指定模式的名称，但仍不提倡在生产代码中使用这种做法。</p>
<p>记住，使用 <code>from package import specific_submodule</code> 没有任何问题！ 实际上，除了导入模块使用不同包的同名子模块之外，这种方式是推荐用法。</p>
<h4 id="子包参考"><a href="#子包参考" class="headerlink" title="子包参考"></a>子包参考</h4><p>包中含有多个子包时（与示例中的 <code>sound</code> 包一样），可以使用绝对导入引用兄弟包中的子模块。例如，要在模块 <code>sound.filters.vocoder</code> 中使用 <code>sound.effects</code> 包的 <code>echo</code> 模块时，可以用 <code>from sound.effects import echo</code> 导入。</p>
<p>还可以用 import 语句的 <code>from module import name</code> 形式执行相对导入。这些导入语句使用前导句点表示相对导入中的当前包和父包。例如，相对于 <code>surround</code> 模块，可以使用：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> echo
<span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">import</span> formats
<span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>filters <span class="token keyword">import</span> equalizer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>注意，相对导入基于当前模块名。因为主模块名是 <code>"__main__"</code> ，所以 Python 程序的主模块必须始终使用绝对导入。</p>
<h4 id="多目录中的包"><a href="#多目录中的包" class="headerlink" title="多目录中的包"></a>多目录中的包</h4><p>包还支持特殊属性 <code>__path__</code>。该属性初始化为在包的 <code>__init__.py</code> 文件中的代码执行前所在的目录名列表。这个变量可以修改，但这样做会影响将来搜索包中模块和子包的操作。</p>
<p>这个功能虽然不常用，但可用于扩展包中的模块集。</p>
<p>注:</p>
<ul>
<li>实际上，函数定义也是“可执行”的“语句”；执行模块级函数定义时，函数名将被导入到模块的全局符号表。</li>
</ul>
<h2 id="6-输入与输出"><a href="#6-输入与输出" class="headerlink" title="6. 输入与输出"></a>6. 输入与输出</h2><h3 id="更复杂的输出格式"><a href="#更复杂的输出格式" class="headerlink" title="更复杂的输出格式"></a>更复杂的输出格式</h3><p>至此，我们已学习了两种写入值的方法：<em>表达式语句</em> 和 <code>print()</code> 函数。第三种方法是使用文件对象的 <code>write()</code> 方法；标准输出文件称为 <code>sys.stdout</code>。详见标准库参考。</p>
<p>对输出格式的控制不只是打印空格分隔的值，还需要更多方式。格式化输出包括以下几种方法。</p>
<ul>
<li><p>使用 格式化字符串字面值 ，要在字符串开头的引号/三引号前添加 <code>f</code> 或 <code>F</code> 。在这种字符串中，可以在 <code>{</code> 和 <code>}</code> 字符之间输入引用的变量，或字面值的 Python 表达式。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> year <span class="token operator">=</span> <span class="token number">2016</span>
<span class="token operator">>></span><span class="token operator">></span> event <span class="token operator">=</span> <span class="token string">'Referendum'</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">'Results of the {year} {event}'</span>
<span class="token string">'Results of the 2016 Referendum'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>字符串的 <code>str.format()</code> 方法需要更多手动操作。该方法也用 <code>{</code> 和 <code>}</code> 标记替换变量的位置，虽然这种方法支持详细的格式化指令，但需要提供格式化信息。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> yes_votes <span class="token operator">=</span> 42_572_654
<span class="token operator">>></span><span class="token operator">></span> no_votes <span class="token operator">=</span> 43_132_495
<span class="token operator">>></span><span class="token operator">></span> percentage <span class="token operator">=</span> yes_votes <span class="token operator">/</span> <span class="token punctuation">(</span>yes_votes <span class="token operator">+</span> no_votes<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:-9} YES votes  {:2.2%}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>yes_votes<span class="token punctuation">,</span> percentage<span class="token punctuation">)</span>
<span class="token string">' 42572654 YES votes  49.67%'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>最后，还可以用字符串切片和合并操作完成字符串处理操作，创建任何排版布局。字符串类型还支持将字符串按给定列宽进行填充，这些方法也很有用。</p>
</li>
</ul>
<p>如果不需要花哨的输出，只想快速显示变量进行调试，可以用 <code>repr()</code> 或 <code>str()</code> 函数把值转化为字符串。</p>
<p><code>str()</code> 函数返回供人阅读的值，<code>repr()</code> 则生成适于解释器读取的值（如果没有等效的语法，则强制执行 <code>SyntaxError</code>）。对于没有支持供人阅读展示结果的对象， <code>str()</code> 返回与 <code>repr()</code> 相同的值。一般情况下，数字、列表或字典等结构的值，使用这两个函数输出的表现形式是一样的。字符串有两种不同的表现形式。</p>
<p>示例如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">'Hello, world.'</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token string">'Hello, world.'</span>
<span class="token operator">>></span><span class="token operator">></span> repr<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token string">"'Hello, world.'"</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">7</span><span class="token punctuation">)</span>
<span class="token string">'0.14285714285714285'</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">3.25</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> <span class="token number">200</span> <span class="token operator">*</span> <span class="token number">200</span>
<span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">'The value of x is '</span> <span class="token operator">+</span> repr<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">', and y is '</span> <span class="token operator">+</span> repr<span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'...'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
The value of x <span class="token keyword">is</span> <span class="token number">32.5</span><span class="token punctuation">,</span> <span class="token operator">and</span> y <span class="token keyword">is</span> <span class="token number">40000</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># The repr() of a string adds string quotes and backslashes:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> hello <span class="token operator">=</span> <span class="token string">'hello, world\n'</span>
<span class="token operator">>></span><span class="token operator">></span> hellos <span class="token operator">=</span> repr<span class="token punctuation">(</span>hello<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>hellos<span class="token punctuation">)</span>
<span class="token string">'hello, world\n'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># The argument to repr() may be any Python object:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> repr<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'eggs'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">"(32.5, 40000, ('spam', 'eggs'))"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>string</code> 模块包含 <code>Template</code> 类，提供了将值替换为字符串的另一种方法。该类使用 <code>$x</code> 占位符，并用字典的值进行替换，但对格式控制的支持比较有限。</p>
<h4 id="格式化字符串字面值"><a href="#格式化字符串字面值" class="headerlink" title="格式化字符串字面值"></a>格式化字符串字面值</h4><p>格式化字符串字面值 （简称为 f-字符串）在字符串前加前缀 <code>f</code> 或 <code>F</code>，通过 <code>{expression}</code> 表达式，把 Python 表达式的值添加到字符串内。</p>
<p>格式说明符是可选的，写在表达式后面，可以更好地控制格式化值的方式。下例将 pi 舍入到小数点后三位：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> math
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'The value of pi is approximately {math.pi:.3f}.'</span><span class="token punctuation">)</span>
The value of pi <span class="token keyword">is</span> approximately <span class="token number">3.142</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 <code>':'</code> 后传递整数，为该字段设置最小字符宽度，常用于列对齐：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> table <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Sjoerd'</span><span class="token punctuation">:</span> <span class="token number">4127</span><span class="token punctuation">,</span> <span class="token string">'Jack'</span><span class="token punctuation">:</span> <span class="token number">4098</span><span class="token punctuation">,</span> <span class="token string">'Dcab'</span><span class="token punctuation">:</span> <span class="token number">7678</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> name<span class="token punctuation">,</span> phone <span class="token keyword">in</span> table<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'{name:10} ==> {phone:10d}'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Sjoerd     <span class="token operator">==</span><span class="token operator">></span>       <span class="token number">4127</span>
Jack       <span class="token operator">==</span><span class="token operator">></span>       <span class="token number">4098</span>
Dcab       <span class="token operator">==</span><span class="token operator">></span>       <span class="token number">7678</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还有一些修饰符可以在格式化前转换值。 <code>'!a'</code> 应用 <code>ascii()</code> ，<code>'!s'</code> 应用 <code>str()</code>，<code>'!r'</code> 应用 <code>repr()</code>：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> animals <span class="token operator">=</span> <span class="token string">'eels'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'My hovercraft is full of {animals}.'</span><span class="token punctuation">)</span>
My hovercraft <span class="token keyword">is</span> full of eels<span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'My hovercraft is full of {animals!r}.'</span><span class="token punctuation">)</span>
My hovercraft <span class="token keyword">is</span> full of <span class="token string">'eels'</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="字符串-format-方法"><a href="#字符串-format-方法" class="headerlink" title="字符串 format() 方法"></a>字符串 format() 方法</h4><p><code>str.format()</code> 方法的基本用法如下所示：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'We are the {} who say "{}!"'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'knights'</span><span class="token punctuation">,</span> <span class="token string">'Ni'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
We are the knights who say <span class="token string">"Ni!"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>花括号及之内的字符（称为格式字段）被替换为传递给 <code>str.format()</code> 方法的对象。花括号中的数字表示传递给 <code>str.format()</code> 方法的对象所在的位置。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'{0} and {1}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'eggs'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
spam <span class="token operator">and</span> eggs
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'{1} and {0}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'eggs'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
eggs <span class="token operator">and</span> spam<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>str.format()</code> 方法中使用关键字参数名引用值。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'This {food} is {adjective}.'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>       food<span class="token operator">=</span><span class="token string">'spam'</span><span class="token punctuation">,</span> adjective<span class="token operator">=</span><span class="token string">'absolutely horrible'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
This spam <span class="token keyword">is</span> absolutely horrible<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>位置参数和关键字参数可以任意组合：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'The story of {0}, {1}, and {other}.'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'Bill'</span><span class="token punctuation">,</span> <span class="token string">'Manfred'</span><span class="token punctuation">,</span>
                                                       other<span class="token operator">=</span><span class="token string">'Georg'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
The story of Bill<span class="token punctuation">,</span> Manfred<span class="token punctuation">,</span> <span class="token operator">and</span> Georg<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果不想分拆较长的格式字符串，最好按名称引用变量进行格式化，不要按位置。这项操作可以通过传递字典，并用方括号 <code>'[]'</code> 访问键来完成。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> table <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Sjoerd'</span><span class="token punctuation">:</span> <span class="token number">4127</span><span class="token punctuation">,</span> <span class="token string">'Jack'</span><span class="token punctuation">:</span> <span class="token number">4098</span><span class="token punctuation">,</span> <span class="token string">'Dcab'</span><span class="token punctuation">:</span> <span class="token number">8637678</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>       <span class="token string">'Dcab: {0[Dcab]:d}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>table<span class="token punctuation">)</span><span class="token punctuation">)</span>
Jack<span class="token punctuation">:</span> <span class="token number">4098</span><span class="token punctuation">;</span> Sjoerd<span class="token punctuation">:</span> <span class="token number">4127</span><span class="token punctuation">;</span> Dcab<span class="token punctuation">:</span> <span class="token number">8637678</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以用 ‘**‘ 符号，把 table 当作传递的关键字参数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> table <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'Sjoerd'</span><span class="token punctuation">:</span> <span class="token number">4127</span><span class="token punctuation">,</span> <span class="token string">'Jack'</span><span class="token punctuation">:</span> <span class="token number">4098</span><span class="token punctuation">,</span> <span class="token string">'Dcab'</span><span class="token punctuation">:</span> <span class="token number">8637678</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token operator">**</span>table<span class="token punctuation">)</span><span class="token punctuation">)</span>
Jack<span class="token punctuation">:</span> <span class="token number">4098</span><span class="token punctuation">;</span> Sjoerd<span class="token punctuation">:</span> <span class="token number">4127</span><span class="token punctuation">;</span> Dcab<span class="token punctuation">:</span> <span class="token number">8637678</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>与内置函数 <code>vars()</code> 结合使用时，这种方式非常实用，可以返回包含所有局部变量的字典。</p>
<p>例如，下面的代码生成一组整齐的列，包含给定整数及其平方与立方：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'{0:2d} {1:3d} {2:4d}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token operator">*</span>x<span class="token punctuation">,</span> x<span class="token operator">*</span>x<span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
 <span class="token number">1</span>   <span class="token number">1</span>    <span class="token number">1</span>
 <span class="token number">2</span>   <span class="token number">4</span>    <span class="token number">8</span>
 <span class="token number">3</span>   <span class="token number">9</span>   <span class="token number">27</span>
 <span class="token number">4</span>  <span class="token number">16</span>   <span class="token number">64</span>
 <span class="token number">5</span>  <span class="token number">25</span>  <span class="token number">125</span>
 <span class="token number">6</span>  <span class="token number">36</span>  <span class="token number">216</span>
 <span class="token number">7</span>  <span class="token number">49</span>  <span class="token number">343</span>
 <span class="token number">8</span>  <span class="token number">64</span>  <span class="token number">512</span>
 <span class="token number">9</span>  <span class="token number">81</span>  <span class="token number">729</span>
<span class="token number">10</span> <span class="token number">100</span> <span class="token number">1000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="手动格式化字符串"><a href="#手动格式化字符串" class="headerlink" title="手动格式化字符串"></a>手动格式化字符串</h4><p>下面是使用手动格式化方式实现的同一个平方和立方的表：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>rjust<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> repr<span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>rjust<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token comment" spellcheck="true"># Note use of 'end' on previous line</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span>rjust<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
 <span class="token number">1</span>   <span class="token number">1</span>    <span class="token number">1</span>
 <span class="token number">2</span>   <span class="token number">4</span>    <span class="token number">8</span>
 <span class="token number">3</span>   <span class="token number">9</span>   <span class="token number">27</span>
 <span class="token number">4</span>  <span class="token number">16</span>   <span class="token number">64</span>
 <span class="token number">5</span>  <span class="token number">25</span>  <span class="token number">125</span>
 <span class="token number">6</span>  <span class="token number">36</span>  <span class="token number">216</span>
 <span class="token number">7</span>  <span class="token number">49</span>  <span class="token number">343</span>
 <span class="token number">8</span>  <span class="token number">64</span>  <span class="token number">512</span>
 <span class="token number">9</span>  <span class="token number">81</span>  <span class="token number">729</span>
<span class="token number">10</span> <span class="token number">100</span> <span class="token number">1000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（注意，每列之间的空格是通过使用 <code>print()</code> 添加的：它总在其参数间添加空格。）</p>
<p>字符串对象的 <code>str.rjust()</code> 方法通过在左侧填充空格，对给定宽度字段中的字符串进行右对齐。同类方法还有 <code>str.ljust()</code> 和 <code>str.center()</code> 。这些方法不写入任何内容，只返回一个新字符串，如果输入的字符串太长，它们不会截断字符串，而是原样返回；虽然这种方式会弄乱列布局，但也比另一种方法好，后者在显示值时可能不准确（如果真的想截断字符串，可以使用 <code>x.ljust(n)[:n]</code> 这样的切片操作 。）</p>
<p>另一种方法是 <code>str.zfill()</code> ，该方法在数字字符串左边填充零，且能识别正负号：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'12'</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token string">'00012'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'-3.14'</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>
<span class="token string">'-003.14'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'3.14159265359'</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token string">'3.14159265359'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="旧式字符串格式化方法"><a href="#旧式字符串格式化方法" class="headerlink" title="旧式字符串格式化方法"></a>旧式字符串格式化方法</h4><p>% 运算符（求余符）也可用于字符串格式化。给定 <code>'string' % values</code>，则 <code>string</code> 中的 <code>%</code> 实例会以零个或多个 <code>values</code> 元素替换。此操作被称为字符串插值。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> math
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'The value of pi is approximately %5.3f.'</span> <span class="token operator">%</span> math<span class="token punctuation">.</span>pi<span class="token punctuation">)</span>
The value of pi <span class="token keyword">is</span> approximately <span class="token number">3.142</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p><code>open()</code> 返回 file object，最常用的参数有两个: <code>open(filename, mode)</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'workfile'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>第一个实参是文件名字符串。第二个实参是包含描述文件使用方式字符的字符串。<em>mode</em> 的值包括 <code>'r'</code> ，表示文件只能读取；<code>'w'</code> 表示只能写入（现有同名文件会被覆盖）；<code>'a'</code> 表示打开文件并追加内容，任何写入的数据会自动添加到文件末尾。<code>'r+'</code> 表示打开文件进行读写。<em>mode</em> 实参是可选的，省略时的默认值为 <code>'r'</code>。</p>
<p>通常，文件以 <em>text mode</em> 打开，即，从文件中读取或写入字符串时，都以指定编码方式进行编码。如未指定编码格式，默认值与平台相关 。在 mode 中追加的 <code>'b'</code> 则以 <em>binary mode</em> 打开文件：此时，数据以字节对象的形式进行读写。该模式用于所有不包含文本的文件。</p>
<p>在文本模式下读取文件时，默认把平台特定的行结束符（Unix 上为 <code>\n</code>, Windows 上为 <code>\r\n</code>）转换为 <code>\n</code>。在文本模式下写入数据时，默认把 <code>\n</code> 转换回平台特定结束符。这种操作方式在后台修改文件数据对文本文件来说没有问题，但会破坏 <code>JPEG</code> 或 <code>EXE</code> 等二进制文件中的数据。注意，在读写此类文件时，一定要使用二进制模式。</p>
<p>在处理文件对象时，最好使用 <code>with</code> 关键字。优点是，子句体结束后，文件会正确关闭，即便触发异常也可以。而且，使用 <code>with</code> 相比等效的 <code>try</code>-<code>finally</code> 代码块要简短得多：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'workfile'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     read_data <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># We can check that the file has been automatically closed.</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>closed
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果没有使用 <code>with</code> 关键字，则应调用 <code>f.close()</code> 关闭文件，即可释放文件占用的系统资源。</p>
<p>警告：</p>
<p>调用 <code>f.write()</code> 时，未使用 <code>with</code> 关键字，或未调用 <code>f.close()</code>，即使程序正常退出，也<strong>可能</strong> 导致 <code>f.write()</code> 的参数没有完全写入磁盘。</p>
<p>通过 <code>with</code> 语句，或调用 <code>f.close()</code> 关闭文件对象后，再次使用该文件对象将会失败。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ValueError<span class="token punctuation">:</span> I<span class="token operator">/</span>O operation on closed file<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="文件对象的方法"><a href="#文件对象的方法" class="headerlink" title="文件对象的方法"></a>文件对象的方法</h4><p>本节下文中的例子假定已创建 <code>f</code> 文件对象。</p>
<p><code>f.read(size)</code> 可用于读取文件内容，它会读取一些数据，并返回字符串（文本模式），或字节串对象（在二进制模式下）。 <em>size</em> 是可选的数值参数。省略 <em>size</em> 或 <em>size</em> 为负数时，读取并返回整个文件的内容；文件大小是内存的两倍时，会出现问题。<em>size</em> 取其他值时，读取并返回最多 <em>size</em> 个字符（文本模式）或 <em>size</em> 个字节（二进制模式）。如已到达文件末尾，<code>f.read()</code> 返回空字符串（<code>''</code>）。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'This is the entire file.\n'</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>f.readline()</code> 从文件中读取单行数据；字符串末尾保留换行符（<code>\n</code>），只有在文件不以换行符结尾时，文件的最后一行才会省略换行符。这种方式让返回值清晰明确；只要 <code>f.readline()</code> 返回空字符串，就表示已经到达了文件末尾，空行使用 <code>'\n'</code> 表示，该字符串只包含一个换行符。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'This is the first line of the file.\n'</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'Second line of the file\n'</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从文件中读取多行时，可以用循环遍历整个文件对象。这种操作能高效利用内存，快速，且代码简单：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
This <span class="token keyword">is</span> the first line of the file<span class="token punctuation">.</span>
Second line of the file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如需以列表形式读取文件中的所有行，可以用 <code>list(f)</code> 或 <code>f.readlines()</code>。</p>
<p><code>f.write(string)</code> 把 <em>string</em> 的内容写入文件，并返回写入的字符数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'This is a test\n'</span><span class="token punctuation">)</span>
<span class="token number">15</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>写入其他类型的对象前，要先把它们转化为字符串（文本模式）或字节对象（二进制模式）：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'the answer'</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> str<span class="token punctuation">(</span>value<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># convert the tuple to string</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token number">18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>f.tell()</code> 返回整数，给出文件对象在文件中的当前位置，表示为二进制模式下时从文件开始的字节数，以及文本模式下的意义不明的数字。</p>
<p><code>f.seek(offset, whence)</code> 可以改变文件对象的位置。通过向参考点添加 <em>offset</em> 计算位置；参考点由 <em>whence</em> 参数指定。 <em>whence</em> 值为 0 时，表示从文件开头计算，1 表示使用当前文件位置，2 表示使用文件末尾作为参考点。省略 <em>whence</em> 时，其默认值为 0，即使用文件开头作为参考点。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'workfile'</span><span class="token punctuation">,</span> <span class="token string">'rb+'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">'0123456789abcdef'</span><span class="token punctuation">)</span>
<span class="token number">16</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># Go to the 6th byte in the file</span>
<span class="token number">5</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
b<span class="token string">'5'</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Go to the 3rd byte before the end</span>
<span class="token number">13</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
b<span class="token string">'d'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在文本文件（模式字符串未使用 <code>b</code> 时打开的文件）中，只允许相对于文件开头搜索（使用 <code>seek(0, 2)</code> 搜索到文件末尾是个例外），唯一有效的 <em>offset</em> 值是能从 <code>f.tell()</code> 中返回的，或 0。其他 <em>offset</em> 值都会产生未定义的行为。</p>
<p>文件对象还支持 <code>isatty()</code> 和 <code>truncate()</code> 等方法，但不常用；文件对象的完整指南详见库参考。</p>
<h4 id="使用-json-保存结构化数据"><a href="#使用-json-保存结构化数据" class="headerlink" title="使用 json 保存结构化数据"></a>使用 <code>json</code> 保存结构化数据</h4><p>从文件写入或读取字符串很简单，数字则稍显麻烦，因为 <code>read()</code> 方法只返回字符串，这些字符串必须传递给 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#int" target="_blank" rel="noopener"><code>int()</code></a> 这样的函数，接受 <code>'123'</code> 这样的字符串，并返回数字值 123。保存嵌套列表、字典等复杂数据类型时，手动解析和序列化的操作非常复杂。</p>
<p>Python 支持 <a href="http://json.org/" target="_blank" rel="noopener">JSON (JavaScript Object Notation)</a> 这种流行数据交换格式，用户无需没完没了地编写、调试代码，才能把复杂的数据类型保存到文件。<code>json</code> 标准模块采用 Python 数据层次结构，并将之转换为字符串表示形式；这个过程称为 <em>serializing</em> （序列化）。从字符串表示中重建数据称为 <em>deserializing</em> （解序化）。在序列化和解序化之间，表示对象的字符串可能已经存储在文件或数据中，或通过网络连接发送到远方 的机器。</p>
<p>注解</p>
<p>JSON 格式通常用于现代应用程序的数据交换。程序员早已对它耳熟能详，可谓是交互操作的不二之选。</p>
<p>只需一行简单的代码即可查看某个对象的 JSON 字符串表现形式：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> json
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'simple'</span><span class="token punctuation">,</span> <span class="token string">'list'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> json<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token string">'[1, "simple", "list"]'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>dumps()</code> 函数还有一个变体， <code>dump()</code> ，它只将对象序列化为 text file 。因此，如果 <code>f</code> 是 text file 对象，可以这样做：</p>
<pre class="line-numbers language-python"><code class="language-python">json<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>x<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>要再次解码对象，如果 <code>f</code> 是已打开、供读取的 text file 对象：</p>
<pre class="line-numbers language-python"><code class="language-python">x <span class="token operator">=</span> json<span class="token punctuation">.</span>load<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这种简单的序列化技术可以处理列表和字典，但在 JSON 中序列化任意类的实例，则需要付出额外努力。<code>json</code> 模块的参考包含对此的解释。</p>
<p>注：</p>
<ul>
<li><code>pickle</code> - 封存模块：与 JSON 不同，<em>pickle</em> 是一种允许对复杂 Python 对象进行序列化的协议。因此，它为 Python 所特有，不能用于与其他语言编写的应用程序通信。默认情况下它也是不安全的：如果解序化的数据是由手段高明的攻击者精心设计的，这种不受信任来源的 pickle 数据可以执行任意代码。</li>
</ul>
<h2 id="7-错误和异常"><a href="#7-错误和异常" class="headerlink" title="7. 错误和异常"></a>7. 错误和异常</h2><h3 id="句法错误"><a href="#句法错误" class="headerlink" title="句法错误"></a>句法错误</h3><p>句法错误又称解析错误，是学习 Python 时最常见的错误：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">while</span> <span class="token boolean">True</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Hello world'</span><span class="token punctuation">)</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Hello world'</span><span class="token punctuation">)</span>
                   <span class="token operator">^</span>
SyntaxError<span class="token punctuation">:</span> invalid syntax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解析器会复现出现句法错误的代码行，并用小“箭头”指向行里检测到的第一个错误。错误是由箭头 <em>上方</em> 的 token 触发的（至少是在这里检测出的）：本例中，在 <code>print()</code> 函数中检测到错误，因为，在它前面缺少冒号（<code>':'</code>） 。错误信息还输出文件名与行号，在使用脚本文件时，就可以知道去哪里查错。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>即使语句或表达式使用了正确的语法，执行时仍可能触发错误。执行时检测到的错误称为 <em>异常</em>，异常不一定导致严重的后果：很快我们就能学会如何处理 Python 的异常。大多数异常不会被程序处理，而是显示下列错误信息：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ZeroDivisionError<span class="token punctuation">:</span> division by zero
<span class="token operator">>></span><span class="token operator">></span> <span class="token number">4</span> <span class="token operator">+</span> spam<span class="token operator">*</span><span class="token number">3</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
NameError<span class="token punctuation">:</span> name <span class="token string">'spam'</span> <span class="token keyword">is</span> <span class="token operator">not</span> defined
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'2'</span> <span class="token operator">+</span> <span class="token number">2</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> can only concatenate str <span class="token punctuation">(</span><span class="token operator">not</span> <span class="token string">"int"</span><span class="token punctuation">)</span> to str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>错误信息的最后一行说明程序遇到了什么类型的错误。异常有不同的类型，而类型名称会作为错误信息的一部分中打印出来：上述示例中的异常类型依次是：<code>ZeroDivisionError</code>， <code>NameError</code> 和 <code>TypeError</code>。作为异常类型打印的字符串是发生的内置异常的名称。对于所有内置异常都是如此，但对于用户定义的异常则不一定如此（虽然这种规范很有用）。标准的异常类型是内置的标识符（不是保留关键字）。</p>
<p>此行其余部分根据异常类型，结合出错原因，说明错误细节。</p>
<p>错误信息开头用堆栈回溯形式展示发生异常的语境。一般会列出源代码行的堆栈回溯；但不会显示从标准输入读取的行。</p>
<p>内置异常 列出了内置异常及其含义。</p>
<h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>可以编写程序处理选定的异常。下例会要求用户一直输入内容，直到输入有效的整数，但允许用户中断程序（使用 Control-C 或操作系统支持的其他操作）；注意，用户中断程序会触发 <code>KeyboardInterrupt</code> 异常。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         x <span class="token operator">=</span> int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">"Please enter a number: "</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">break</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">except</span> ValueError<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Oops!  That was no valid number.  Try again..."</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>try</code> 语句的工作原理如下：</p>
<ul>
<li>首先，执行 <em>try 子句</em> （<code>try</code> 和 <code>except</code> 关键字之间的（多行）语句）。</li>
<li>如果没有触发异常，则跳过 <em>except 子句</em>，<code>try</code> 语句执行完毕。</li>
<li>如果在执行 <code>try</code> 子句时发生了异常，则跳过该子句中剩下的部分。 如果异常的类型与 <code>except</code> 关键字后指定的异常相匹配，则会执行 <em>except 子句</em>，然后跳到 try/except 代码块之后继续执行。</li>
<li>如果发生的异常与 <em>except 子句</em> 中指定的异常不匹配，则它会被传递到外部的 <code>try</code> 语句中；如果没有找到处理程序，则它是一个 <em>未处理异常</em> 且执行将终止并输出如上所示的消息。</li>
</ul>
<p><code>try</code> 语句可以有多个 <em>except 子句</em> 来为不同的异常指定处理程序。 但最多只有一个处理程序会被执行。 处理程序只处理对应的 <em>try 子句</em> 中发生的异常，而不处理同一 <code>try</code> 语句内其他处理程序中的异常。 <em>except 子句</em> 可以用带圆括号的元组来指定多个异常，例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">except</span> <span class="token punctuation">(</span>RuntimeError<span class="token punctuation">,</span> TypeError<span class="token punctuation">,</span> NameError<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果发生的异常与 <code>except</code> 子句中的类是同一个类或是它的基类时，则该类与该异常相兼容（反之则不成立 —- 列出派生类的 <em>except 子句</em> 与基类不兼容）。 例如，下面的代码将依次打印 B, C, D:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">(</span>Exception<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
<span class="token keyword">for</span> cls <span class="token keyword">in</span> <span class="token punctuation">[</span>B<span class="token punctuation">,</span> C<span class="token punctuation">,</span> D<span class="token punctuation">]</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> cls<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> D<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> C<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> B<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意如果颠倒 <em>except 子句</em> 的顺序（把 <code>except B</code> 放在最前），则会输出 B, B, B —- 即触发了第一个匹配的 <em>except 子句</em>。</p>
<p>所有异常都继承自 <code>BaseException</code>，因此它可被用作通配符。 但这种用法要非常谨慎小心，因为它很容易掩盖真正的编程错误！ 它还可被用于打印错误消息然后重新引发异常（允许调用者再来处理该异常）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sys
<span class="token keyword">try</span><span class="token punctuation">:</span>
    f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'myfile.txt'</span><span class="token punctuation">)</span>
    s <span class="token operator">=</span> f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
    i <span class="token operator">=</span> int<span class="token punctuation">(</span>s<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> OSError <span class="token keyword">as</span> err<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"OS error: {0}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> ValueError<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Could not convert data to an integer."</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> BaseException <span class="token keyword">as</span> err<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Unexpected {err=}, {type(err)=}"</span><span class="token punctuation">)</span>
    <span class="token keyword">raise</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以选择让最后一个 except 子句省略异常名称，但在此之后异常值必须从 <code>sys.exc_info()[1]</code> 获取。</p>
<p><code>try</code> … <code>except</code> 语句具有可选的 <em>else 子句*，该子句如果存在，它必须放在所有 *except 子句</em> 之后。 它适用于 <em>try 子句</em> 没有引发异常但又必须要执行的代码。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> arg <span class="token keyword">in</span> sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        f <span class="token operator">=</span> open<span class="token punctuation">(</span>arg<span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> OSError<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'cannot open'</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> <span class="token string">'has'</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'lines'</span><span class="token punctuation">)</span>
        f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>else</code> 子句比向 <code>try</code> 子句添加额外的代码要好，可以避免意外捕获非 <code>try</code> … <code>except</code> 语句保护的代码触发的异常。</p>
<p>发生异常时，它可能具有关联值，即异常 <em>参数</em> 。是否需要参数，以及参数的类型取决于异常的类型。</p>
<p><em>except 子句</em> 可以在异常名称后面指定一个变量。 这个变量会绑定到一个异常实例并将参数存储在 <code>instance.args</code> 中。 为了方便起见，该异常实例定义了 <code>__str__()</code> 以便能直接打印参数而无需引用 <code>.args</code>。 也可以在引发异常之前先实例化一个异常并根据需要向其添加任何属性。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'eggs'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">except</span> Exception <span class="token keyword">as</span> inst<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>inst<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># the exception instance</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>inst<span class="token punctuation">.</span>args<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># arguments stored in .args</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>inst<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># __str__ allows args to be printed directly,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                          <span class="token comment" spellcheck="true"># but may be overridden in exception subclasses</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     x<span class="token punctuation">,</span> y <span class="token operator">=</span> inst<span class="token punctuation">.</span>args     <span class="token comment" spellcheck="true"># unpack args</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'x ='</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'y ='</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'Exception'</span><span class="token operator">></span>
<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'eggs'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'eggs'</span><span class="token punctuation">)</span>
x <span class="token operator">=</span> spam
y <span class="token operator">=</span> eggs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果异常有参数，则它们将作为未处理异常的消息的最后一部分（’详细信息’）打印。</p>
<p>异常处理程序不仅会处理在 <em>try 子句</em> 中发生的异常，还会处理在 <em>try 子句</em> 中调用（包括间接调用）的函数。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">this_fails</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     x <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     this_fails<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">except</span> ZeroDivisionError <span class="token keyword">as</span> err<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Handling run-time error:'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Handling run<span class="token operator">-</span>time error<span class="token punctuation">:</span> division by zero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="触发异常"><a href="#触发异常" class="headerlink" title="触发异常"></a>触发异常</h3><p><code>raise</code> 语句支持强制触发指定的异常。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">raise</span> NameError<span class="token punctuation">(</span><span class="token string">'HiThere'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
NameError<span class="token punctuation">:</span> HiThere<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>raise</code> 唯一的参数就是要触发的异常。这个参数必须是异常实例或异常类（派生自 <code>Exception</code> 类）。如果传递的是异常类，将通过调用没有参数的构造函数来隐式实例化：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">raise</span> ValueError  <span class="token comment" spellcheck="true"># shorthand for 'raise ValueError()'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果只想判断是否触发了异常，但并不打算处理该异常，则可以使用更简单的 <code>raise</code> 语句重新触发异常：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">raise</span> NameError<span class="token punctuation">(</span><span class="token string">'HiThere'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">except</span> NameError<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'An exception flew by!'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">raise</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
An exception flew by!
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
NameError<span class="token punctuation">:</span> HiThere<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h3><p><code>raise</code> 语句支持可选的 <code>from</code> 子句，该子句用于启用链式异常。 例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># exc must be exception instance or None.</span>
<span class="token keyword">raise</span> RuntimeError <span class="token keyword">from</span> exc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>转换异常时，这种方式很有用。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">raise</span> ConnectionError
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     func<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">except</span> ConnectionError <span class="token keyword">as</span> exc<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">raise</span> RuntimeError<span class="token punctuation">(</span><span class="token string">'Failed to open database'</span><span class="token punctuation">)</span> <span class="token keyword">from</span> exc
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">in</span> func
ConnectionError
The above exception was the direct cause of the following exception<span class="token punctuation">:</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">4</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
RuntimeError<span class="token punctuation">:</span> Failed to open database<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>异常链会在 <code>except</code> 或 <code>finally</code> 子句内部引发异常时自动生成。 这可以通过使用 <code>from None</code> 这样的写法来禁用:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     open<span class="token punctuation">(</span><span class="token string">'database.sqlite'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">except</span> OSError<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">raise</span> RuntimeError <span class="token keyword">from</span> None
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">4</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
RuntimeError<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h3><p>程序可以通过创建新的异常类命名自己的异常。不论是以直接还是间接的方式，异常都应从 <code>Exception</code> 类派生。</p>
<p>异常类和其他类一样，可以执行任何操作。但通常会比较简单，只提供让处理异常的程序提取错误信息的一些属性。创建能触发多个不同错误的模块时，一般只为该模块定义异常基类，然后再根据不同的错误条件，创建指定异常类的子类：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>Exception<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Base class for exceptions in this module."""</span>
    <span class="token keyword">pass</span>
<span class="token keyword">class</span> <span class="token class-name">InputError</span><span class="token punctuation">(</span>Error<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Exception raised for errors in the input.
    Attributes:
        expression -- input expression in which the error occurred
        message -- explanation of the error
    """</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> expression<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>expression <span class="token operator">=</span> expression
        self<span class="token punctuation">.</span>message <span class="token operator">=</span> message
<span class="token keyword">class</span> <span class="token class-name">TransitionError</span><span class="token punctuation">(</span>Error<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Raised when an operation attempts a state transition that's not
    allowed.
    Attributes:
        previous -- state at beginning of transition
        next -- attempted new state
        message -- explanation of why the specific transition is not allowed
    """</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> previous<span class="token punctuation">,</span> next<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>previous <span class="token operator">=</span> previous
        self<span class="token punctuation">.</span>next <span class="token operator">=</span> next
        self<span class="token punctuation">.</span>message <span class="token operator">=</span> message<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>大多数异常命名都以 “Error” 结尾，类似标准异常的命名。</p>
<p>许多标准模块都需要自定义异常，以报告由其定义的函数中出现的错误。</p>
<h3 id="定义清理操作"><a href="#定义清理操作" class="headerlink" title="定义清理操作"></a>定义清理操作</h3><p><code>try</code> 语句还有一个可选子句，用于定义在所有情况下都必须要执行的清理操作。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">raise</span> KeyboardInterrupt
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">finally</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Goodbye, world!'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Goodbye<span class="token punctuation">,</span> world!
KeyboardInterrupt
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果存在 <code>finally</code> 子句，则 <code>finally</code> 子句是 <code>try</code> 语句结束前执行的最后一项任务。不论 <code>try</code> 语句是否触发异常，都会执行 <code>finally</code> 子句。以下内容介绍了几种比较复杂的触发异常情景：</p>
<ul>
<li>如果执行 <code>try</code> 子句期间触发了某个异常，则某个 <code>except</code> 子句应处理该异常。如果该异常没有 <code>except</code> 子句处理，在 <code>finally</code> 子句执行后会被重新触发。</li>
<li><code>except</code> 或 <code>else</code> 子句执行期间也会触发异常。 同样，该异常会在 <code>finally</code> 子句执行之后被重新触发。</li>
<li>如果 <code>finally</code> 子句中包含 <code>break</code>、<code>continue</code> 或 <code>return</code> 等语句，异常将不会被重新引发。</li>
<li>如果执行 <code>try</code> 语句时遇到 <code>break</code>、<code>continue</code> 或 <code>return</code> 语句，则 <code>finally</code> 子句在执行 <code>break</code>、<code>continue</code> 或 <code>return</code> 语句之前执行。</li>
<li>如果 <code>finally</code> 子句中包含 <code>return</code> 语句，则返回值来自 <code>finally</code> 子句的某个 <code>return</code> 语句的返回值，而不是来自 <code>try</code> 子句的 <code>return</code> 语句的返回值。</li>
</ul>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">bool_return</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token boolean">True</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">finally</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token boolean">False</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> bool_return<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这是一个比较复杂的例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">divide</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         result <span class="token operator">=</span> x <span class="token operator">/</span> y
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">except</span> ZeroDivisionError<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"division by zero!"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"result is"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">finally</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"executing finally clause"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> divide<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
result <span class="token keyword">is</span> <span class="token number">2.0</span>
executing <span class="token keyword">finally</span> clause
<span class="token operator">>></span><span class="token operator">></span> divide<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
division by zero!
executing <span class="token keyword">finally</span> clause
<span class="token operator">>></span><span class="token operator">></span> divide<span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span>
executing <span class="token keyword">finally</span> clause
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">in</span> divide
TypeError<span class="token punctuation">:</span> unsupported operand type<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">for</span> <span class="token operator">/</span><span class="token punctuation">:</span> <span class="token string">'str'</span> <span class="token operator">and</span> <span class="token string">'str'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如上所示，任何情况下都会执行 <code>finally</code> 子句。<code>except</code> 子句不处理两个字符串相除触发的 <code>TypeError</code>，因此会在 <code>finally</code> 子句执行后被重新触发。</p>
<p>在实际应用程序中，<code>finally</code> 子句对于释放外部资源（例如文件或者网络连接）非常有用，无论是否成功使用资源。</p>
<h3 id="预定义的清理操作"><a href="#预定义的清理操作" class="headerlink" title="预定义的清理操作"></a>预定义的清理操作</h3><p>某些对象定义了不需要该对象时要执行的标准清理操作。无论使用该对象的操作是否成功，都会执行清理操作。比如，下例要打开一个文件，并输出文件内容：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> line <span class="token keyword">in</span> open<span class="token punctuation">(</span><span class="token string">"myfile.txt"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这个代码的问题在于，执行完代码后，文件在一段不确定的时间内处于打开状态。在简单脚本中这没有问题，但对于较大的应用程序来说可能会出问题。<code>with</code> 语句支持以及时、正确的清理的方式使用文件对象：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"myfile.txt"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>语句执行完毕后，即使在处理行时遇到问题，都会关闭文件 <em>f</em>。和文件一样，支持预定义清理操作的对象会在文档中指出这一点。</p>
<h2 id="8-类"><a href="#8-类" class="headerlink" title="8. 类"></a>8. 类</h2><p>类把数据与功能绑定在一起。创建新类就是创建新的对象 <em>类型*，从而创建该类型的新 *实例</em> 。类实例具有多种保持自身状态的属性。类实例还支持（由类定义的）修改自身状态的方法。</p>
<p>和其他编程语言相比，Python 只用了很少的新语法和语义就加入了类。Python 的类是 C++ 和 Modula-3 中类机制的结合体，而且支持所有面向对象编程（OOP）的标准特性：类继承机制支持多个基类，派生类可以覆盖基类的任何方法，类的方法可以调用基类中相同名称的方法。对象可以包含任意数量和类型的数据。和模块一样，类也拥有 Python 天然的动态特性：在运行时创建，创建后也可以修改。</p>
<p>在 C++ 术语中，通常类成员（包括数据成员）是 <em>public</em> ，所有成员函数都是 <em>virtual</em>。 与在 Modula-3 中一样，没有用于从对象的方法中引用对象成员的简写：方法函数在声明时，有一个显示的参数代表本对象，该参数由调用隐式提供。 与 Smalltalk 一样，类本身也是对象。 这为导入和重命名提供了语义。 与 C++ 和 Modula-3 不同，内置类型可以用作基类，供用户扩展。 此外，与 C++ 一样，大多数具有特殊语法（算术运算符，下标等）的内置运算符都可以为类实例而重新定义。</p>
<p>（由于缺乏关于类的公认术语，我会偶尔使用 Smalltalk、C++ 的术语，我还会使用 Modula-3 的术语，因为它的面向对象语义比 C++ 更接近 Python，但估计没几个读者听说过这门语言。）</p>
<h3 id="名称和对象"><a href="#名称和对象" class="headerlink" title="名称和对象"></a>名称和对象</h3><p>对象之间相互独立，多个名称（在多个作用域内）可以绑定到同一个对象。 其他语言称之为别名。Python 初学者通常不容易理解这个概念，处理数字、字符串、元组等不可变基本类型时，可以不必理会。 但是，对涉及可变对象，如列表、字典等大多数其他类型的 Python 代码的语义，别名可能会产生意料之外的效果。这样做，通常是为了让程序受益，因为别名在某些方面就像指针。例如，传递对象的代价很小，因为实现只传递一个指针；如果函数修改了作为参数传递的对象，调用者就可以看到更改 —- 无需 Pascal 用两个不同参数的传递机制。</p>
<h3 id="Python-作用域和命名空间"><a href="#Python-作用域和命名空间" class="headerlink" title="Python 作用域和命名空间"></a>Python 作用域和命名空间</h3><p>在介绍类之前，我首先要告诉你一些 Python 的作用域规则。类定义对命名空间有一些巧妙的技巧，你需要知道作用域和命名空间如何工作才能完全理解正在发生的事情。顺便说一下，关于这个主题的知识对任何高级 Python 程序员都很有用。</p>
<p>让我们从一些定义开始。</p>
<p><em>namespace</em> （命名空间）是一个从名字到对象的映射。 当前大部分命名空间都由 Python 字典实现，但一般情况下基本不会去关注它们（除了要面对性能问题时），而且也有可能在将来更改。 下面是几个命名空间的例子：存放内置函数的集合（包含 <code>abs()</code> 这样的函数，和内建的异常等）；模块中的全局名称；函数调用中的局部名称。 从某种意义上说，对象的属性集合也是一种命名空间的形式。 关于命名空间的重要一点是，不同命名空间中的名称之间绝对没有关系；例如，两个不同的模块都可以定义一个 <code>maximize</code> 函数而不会产生混淆 —- 模块的用户必须在其前面加上模块名称。</p>
<p>顺便说明一下，我把任何跟在一个点号之后的名称都称为 <em>属性</em> —- 例如，在表达式 <code>z.real</code> 中，<code>real</code> 是对象 <code>z</code> 的一个属性。按严格的说法，对模块中名称的引用属于属性引用：在表达式 <code>modname.funcname</code> 中，<code>modname</code> 是一个模块对象而 <code>funcname</code> 是它的一个属性。在此情况下在模块的属性和模块中定义的全局名称之间正好存在一个直观的映射：它们共享相同的命名空间！ </p>
<p>属性可以是只读或者可写的。如果为后者，那么对属性的赋值是可行的。模块属性是可写的，你可以写 <code>modname.the_answer = 42</code> 。可写的属性同样可以用 <code>del</code> 语句删除。例如， <code>del modname.the_answer</code> 将会从名为 <code>modname</code> 的对象中移除 <code>the_answer</code> 属性。</p>
<p>命名空间在不同时刻被创建，拥有不同的生存期。包含内置名称的命名空间是在 Python 解释器启动时创建的，永远不会被删除。模块的全局命名空间在模块定义被读入时创建；通常，模块命名空间也会持续到解释器退出。被解释器的顶层调用执行的语句，从一个脚本文件读取或交互式地读取，被认为是 <code>__main__</code> 模块调用的一部分，因此它们拥有自己的全局命名空间。（内置名称实际上也存在于一个模块中；这个模块被称作 <code>builtins</code> 。）</p>
<p>一个函数的本地命名空间在这个函数被调用时创建，并在函数返回或抛出一个不在函数内部处理的错误时被删除。（事实上，比起描述到底发生了什么，忘掉它更好。）当然，每次递归调用都会有它自己的本地命名空间。</p>
<p>一个 <em>作用域</em> 是一个命名空间可直接访问的 Python 程序的文本区域。 这里的 “可直接访问” 意味着对名称的非限定引用会尝试在命名空间中查找名称。</p>
<p>虽然作用域是静态地确定的，但它们会被动态地使用。 在执行期间的任何时刻，会有 3 或 4 个命名空间可被直接访问的嵌套作用域:</p>
<ul>
<li>最先搜索的最内部作用域包含局部名称</li>
<li>从最近的封闭作用域开始搜索的任何封闭函数的作用域包含非局部名称，也包括非全局名称</li>
<li>倒数第二个作用域包含当前模块的全局名称</li>
<li>最外面的作用域（最后搜索）是包含内置名称的命名空间</li>
</ul>
<p>如果一个名称被声明为全局变量，则所有引用和赋值将直接指向包含该模块的全局名称的中间作用域。 要重新绑定在最内层作用域以外找到的变量，可以使用 <code>nonlocal</code> 语句声明为非本地变量。 如果没有被声明为非本地变量，这些变量将是只读的（尝试写入这样的变量只会在最内层作用域中创建一个 <em>新的</em> 局部变量，而同名的外部变量保持不变）。</p>
<p>通常，当前局部作用域将（按字面文本）引用当前函数的局部名称。 在函数以外，局部作用域将引用与全局作用域相一致的命名空间：模块的命名空间。 类定义将在局部命名空间内再放置另一个命名空间。</p>
<p>重要的是应该意识到作用域是按字面文本来确定的：在一个模块内定义的函数的全局作用域就是该模块的命名空间，无论该函数从什么地方或以什么别名被调用。 另一方面，实际的名称搜索是在运行时动态完成的 —- 但是，Python 正在朝着“编译时静态名称解析”的方向发展，因此不要过于依赖动态名称解析！ （事实上，局部变量已经是被静态确定了。）</p>
<p>Python 的一个特殊规定是这样的 — 如果不存在生效的 <code>global</code> 或 <code>nonlocal</code> 语句 — 则对名称的赋值总是会进入最内层作用域。 赋值不会复制数据 —- 它们只是将名称绑定到对象。 删除也是如此：语句 <code>del x</code> 会从局部作用域所引用的命名空间中移除对 <code>x</code> 的绑定。 事实上，所有引入新名称的操作都是使用局部作用域：特别地，<code>import</code> 语句和函数定义会在局部作用域中绑定模块或函数名称。</p>
<p><code>global</code> 语句可被用来表明特定变量生存于全局作用域并且应当在其中被重新绑定；<code>nonlocal</code> 语句表明特定变量生存于外层作用域中并且应当在其中被重新绑定。</p>
<h4 id="作用域和命名空间示例"><a href="#作用域和命名空间示例" class="headerlink" title="作用域和命名空间示例"></a>作用域和命名空间示例</h4><p>这个例子演示了如何引用不同作用域和名称空间，以及 <code>global</code> 和 <code>nonlocal</code> 会如何影响变量绑定:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">scope_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">do_local</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        spam <span class="token operator">=</span> <span class="token string">"local spam"</span>
    <span class="token keyword">def</span> <span class="token function">do_nonlocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        nonlocal spam
        spam <span class="token operator">=</span> <span class="token string">"nonlocal spam"</span>
    <span class="token keyword">def</span> <span class="token function">do_global</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">global</span> spam
        spam <span class="token operator">=</span> <span class="token string">"global spam"</span>
    spam <span class="token operator">=</span> <span class="token string">"test spam"</span>
    do_local<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"After local assignment:"</span><span class="token punctuation">,</span> spam<span class="token punctuation">)</span>
    do_nonlocal<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"After nonlocal assignment:"</span><span class="token punctuation">,</span> spam<span class="token punctuation">)</span>
    do_global<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"After global assignment:"</span><span class="token punctuation">,</span> spam<span class="token punctuation">)</span>
scope_test<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"In global scope:"</span><span class="token punctuation">,</span> spam<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例代码的输出是：</p>
<pre class="line-numbers language-python"><code class="language-python">After local assignment<span class="token punctuation">:</span> test spam
After nonlocal assignment<span class="token punctuation">:</span> nonlocal spam
After <span class="token keyword">global</span> assignment<span class="token punctuation">:</span> nonlocal spam
In <span class="token keyword">global</span> scope<span class="token punctuation">:</span> <span class="token keyword">global</span> spam<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意 <em>局部</em> 赋值（这是默认状态）不会改变 <em>scope_test</em> 对 <em>spam</em> 的绑定。 <code>nonlocal</code> 赋值会改变 <em>scope_test</em> 对 <em>spam</em> 的绑定，而 <code>global</code> 赋值会改变模块层级的绑定。</p>
<p>您还可以发现在 <code>global</code> 赋值之前没有 <em>spam</em> 的绑定。</p>
<h3 id="初探类"><a href="#初探类" class="headerlink" title="初探类"></a>初探类</h3><p>类引入了一些新语法，三种新对象类型和一些新语义。</p>
<h4 id="类定义语法"><a href="#类定义语法" class="headerlink" title="类定义语法"></a>类定义语法</h4><p>最简单的类定义看起来像这样:</p>
<pre><code>class ClassName:
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;</code></pre><p>类定义与函数定义 (<code>def</code> 语句) 一样必须被执行才会起作用。 （你可以尝试将类定义放在 <code>if</code> 语句的一个分支或是函数的内部。）</p>
<p>在实践中，类定义内的语句通常都是函数定义，但也允许有其他语句，有时还很有用 —- 我们会稍后再回来说明这个问题。 在类内部的函数定义通常具有一种特别形式的参数列表，这是方法调用的约定规范所指明的 —- 这个问题也将在稍后再说明。</p>
<p>当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域 —- 因此，所有对局部变量的赋值都是在这个新命名空间之内。 特别的，函数定义会绑定到这里的新函数名称。</p>
<p>当（从结尾处）正常离开类定义时，将创建一个 <em>类对象</em>。 这基本上是一个包围在类定义所创建命名空间内容周围的包装器；我们将在下一节了解有关类对象的更多信息。 原始的（在进入类定义之前起作用的）局部作用域将重新生效，类对象将在这里被绑定到类定义头所给出的类名称 (在这个示例中为 <code>ClassName</code>)。</p>
<h4 id="Class-对象"><a href="#Class-对象" class="headerlink" title="Class 对象"></a>Class 对象</h4><p>类对象支持两种操作：属性引用和实例化。</p>
<p><em>属性引用</em> 使用 Python 中所有属性引用所使用的标准语法: <code>obj.name</code>。 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""A simple example class"""</span>
    i <span class="token operator">=</span> <span class="token number">12345</span>
    <span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'hello world'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么 <code>MyClass.i</code> 和 <code>MyClass.f</code> 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属性也可以被赋值，因此可以通过赋值来更改 <code>MyClass.i</code> 的值。 <code>__doc__</code> 也是一个有效的属性，将返回所属类的文档字符串: <code>"A simple example class"</code>。</p>
<p>类的 <em>实例化</em> 使用函数表示法。 可以把类对象视为是返回该类的一个新实例的不带参数的函数。 举例来说（假设使用上述的类）:</p>
<pre class="line-numbers language-python"><code class="language-python">x <span class="token operator">=</span> MyClass<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>创建类的新 <em>实例</em> 并将此对象分配给局部变量 <code>x</code>。</p>
<p>实例化操作（“调用”类对象）会创建一个空对象。 许多类喜欢创建带有特定初始状态的自定义实例。 为此类定义可能包含一个名为 <code>__init__()</code> 的特殊方法，就像这样:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>当一个类定义了 <code>__init__()</code> 方法时，类的实例化操作会自动为新创建的类实例发起调用 <code>__init__()</code>。 因此在这个示例中，可以通过以下语句获得一个经初始化的新实例:</p>
<pre class="line-numbers language-python"><code class="language-python">x <span class="token operator">=</span> MyClass<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当然，<code>__init__()</code> 方法还可以有额外参数以实现更高灵活性。 在这种情况下，提供给类实例化运算符的参数将被传递给 <code>__init__()</code>。 例如，:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Complex</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> realpart<span class="token punctuation">,</span> imagpart<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>r <span class="token operator">=</span> realpart
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>i <span class="token operator">=</span> imagpart
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> Complex<span class="token punctuation">(</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4.5</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>r<span class="token punctuation">,</span> x<span class="token punctuation">.</span>i
<span class="token punctuation">(</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4.5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h4><p>现在我们能用实例对象做什么？ 实例对象所能理解的唯一操作是属性引用。 有两种有效的属性名称：数据属性和方法。</p>
<p><em>数据属性</em> 对应于 Smalltalk 中的“实例变量”，以及 C++ 中的“数据成员”。 数据属性不需要声明；像局部变量一样，它们将在第一次被赋值时产生。 例如，如果 <code>x</code> 是上面创建的 <code>MyClass</code> 的实例，则以下代码段将打印数值 <code>16</code>，且不保留任何追踪信息:</p>
<pre class="line-numbers language-python"><code class="language-python">x<span class="token punctuation">.</span>counter <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">while</span> x<span class="token punctuation">.</span>counter <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">:</span>
    x<span class="token punctuation">.</span>counter <span class="token operator">=</span> x<span class="token punctuation">.</span>counter <span class="token operator">*</span> <span class="token number">2</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>counter<span class="token punctuation">)</span>
<span class="token keyword">del</span> x<span class="token punctuation">.</span>counter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另一类实例属性引用称为 <em>方法</em>。 方法是“从属于”对象的函数。 （在 Python 中，方法这个术语并不是类实例所特有的：其他对象也可以有方法。 例如，列表对象具有 append, insert, remove, sort 等方法。 然而，在以下讨论中，我们使用方法一词将专指类实例对象的方法，除非另外显式地说明。）</p>
<p>实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类中所有是函数对象的属性都是定义了其实例的相应方法。 因此在我们的示例中，<code>x.f</code> 是有效的方法引用，因为 <code>MyClass.f</code> 是一个函数，而 <code>x.i</code> 不是方法，因为 <code>MyClass.i</code> 不是函数。 但是 <code>x.f</code> 与 <code>MyClass.f</code> 并不是一回事 —- 它是一个 <em>方法对象</em>，不是函数对象。</p>
<h4 id="方法对象"><a href="#方法对象" class="headerlink" title="方法对象"></a>方法对象</h4><p>通常，方法在绑定后立即被调用:</p>
<pre class="line-numbers language-python"><code class="language-python">x<span class="token punctuation">.</span>f<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在 <code>MyClass</code> 示例中，这将返回字符串 <code>'hello world'</code>。 但是，立即调用一个方法并不是必须的: <code>x.f</code> 是一个方法对象，它可以被保存起来以后再调用。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python">xf <span class="token operator">=</span> x<span class="token punctuation">.</span>f
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>xf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>将持续打印 <code>hello world</code>，直到结束。</p>
<p>当一个方法被调用时到底发生了什么？ 你可能已经注意到上面调用 <code>x.f()</code> 时并没有带参数，虽然 <code>f()</code> 的函数定义指定了一个参数。 这个参数发生了什么事？ 当不带参数地调用一个需要参数的函数时 Python 肯定会引发异常 —- 即使参数实际未被使用…</p>
<p>实际上，你可能已经猜到了答案：方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。 在我们的示例中，调用 <code>x.f()</code> 其实就相当于 <code>MyClass.f(x)</code>。 总之，调用一个具有 <em>n</em> 个参数的方法就相当于调用再多一个参数的对应函数，这个参数值为方法所属实例对象，位置在其他参数之前。</p>
<p>如果你仍然无法理解方法的运作原理，那么查看实现细节可能会弄清楚问题。 当一个实例的非数据属性被引用时，将搜索实例所属的类。 如果被引用的属性名称表示一个有效的类属性中的函数对象，会通过打包（指向）查找到的实例对象和函数对象到一个抽象对象的方式来创建方法对象：这个抽象对象就是方法对象。 当附带参数列表调用方法对象时，将基于实例对象和参数列表构建一个新的参数列表，并使用这个新参数列表调用相应的函数对象。</p>
<h4 id="类和实例变量"><a href="#类和实例变量" class="headerlink" title="类和实例变量"></a>类和实例变量</h4><p>一般来说，实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">:</span>
    kind <span class="token operator">=</span> <span class="token string">'canine'</span>         <span class="token comment" spellcheck="true"># class variable shared by all instances</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token comment" spellcheck="true"># instance variable unique to each instance</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> Dog<span class="token punctuation">(</span><span class="token string">'Fido'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> e <span class="token operator">=</span> Dog<span class="token punctuation">(</span><span class="token string">'Buddy'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>kind                  <span class="token comment" spellcheck="true"># shared by all dogs</span>
<span class="token string">'canine'</span>
<span class="token operator">>></span><span class="token operator">></span> e<span class="token punctuation">.</span>kind                  <span class="token comment" spellcheck="true"># shared by all dogs</span>
<span class="token string">'canine'</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>name                  <span class="token comment" spellcheck="true"># unique to d</span>
<span class="token string">'Fido'</span>
<span class="token operator">>></span><span class="token operator">></span> e<span class="token punctuation">.</span>name                  <span class="token comment" spellcheck="true"># unique to e</span>
<span class="token string">'Buddy'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>正如 名称和对象 中已讨论过的，共享数据可能在涉及 mutable 对象例如列表和字典的时候导致令人惊讶的结果。 例如以下代码中的 <em>tricks</em> 列表不应该被用作类变量，因为所有的 <em>Dog</em> 实例将只共享一个单独的列表:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">:</span>
    tricks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>             <span class="token comment" spellcheck="true"># mistaken use of a class variable</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">def</span> <span class="token function">add_trick</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> trick<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>tricks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>trick<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> Dog<span class="token punctuation">(</span><span class="token string">'Fido'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> e <span class="token operator">=</span> Dog<span class="token punctuation">(</span><span class="token string">'Buddy'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>add_trick<span class="token punctuation">(</span><span class="token string">'roll over'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> e<span class="token punctuation">.</span>add_trick<span class="token punctuation">(</span><span class="token string">'play dead'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>tricks                <span class="token comment" spellcheck="true"># unexpectedly shared by all dogs</span>
<span class="token punctuation">[</span><span class="token string">'roll over'</span><span class="token punctuation">,</span> <span class="token string">'play dead'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>正确的类设计应该使用实例变量:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        self<span class="token punctuation">.</span>tricks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># creates a new empty list for each dog</span>
    <span class="token keyword">def</span> <span class="token function">add_trick</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> trick<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>tricks<span class="token punctuation">.</span>append<span class="token punctuation">(</span>trick<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> Dog<span class="token punctuation">(</span><span class="token string">'Fido'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> e <span class="token operator">=</span> Dog<span class="token punctuation">(</span><span class="token string">'Buddy'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>add_trick<span class="token punctuation">(</span><span class="token string">'roll over'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> e<span class="token punctuation">.</span>add_trick<span class="token punctuation">(</span><span class="token string">'play dead'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>tricks
<span class="token punctuation">[</span><span class="token string">'roll over'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> e<span class="token punctuation">.</span>tricks
<span class="token punctuation">[</span><span class="token string">'play dead'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>如果同样的属性名称同时出现在实例和类中，则属性查找会优先选择实例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Warehouse</span><span class="token punctuation">:</span>
        purpose <span class="token operator">=</span> <span class="token string">'storage'</span>
        region <span class="token operator">=</span> <span class="token string">'west'</span>
<span class="token operator">>></span><span class="token operator">></span> w1 <span class="token operator">=</span> Warehouse<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>w1<span class="token punctuation">.</span>purpose<span class="token punctuation">,</span> w1<span class="token punctuation">.</span>region<span class="token punctuation">)</span>
storage west
<span class="token operator">>></span><span class="token operator">></span> w2 <span class="token operator">=</span> Warehouse<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> w2<span class="token punctuation">.</span>region <span class="token operator">=</span> <span class="token string">'east'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>w2<span class="token punctuation">.</span>purpose<span class="token punctuation">,</span> w2<span class="token punctuation">.</span>region<span class="token punctuation">)</span>
storage east<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>数据属性可以被方法以及一个对象的普通用户（“客户端”）所引用。 换句话说，类不能用于实现纯抽象数据类型。 实际上，在 Python 中没有任何东西能强制隐藏数据 —- 它是完全基于约定的。 （而在另一方面，用 C 语言编写的 Python 实现则可以完全隐藏实现细节，并在必要时控制对象的访问；此特性可以通过用 C 编写 Python 扩展来使用。）</p>
<p>客户端应当谨慎地使用数据属性 —- 客户端可能通过直接操作数据属性的方式破坏由方法所维护的固定变量。 请注意客户端可以向一个实例对象添加他们自己的数据属性而不会影响方法的可用性，只要保证避免名称冲突 —- 再次提醒，在此使用命名约定可以省去许多令人头痛的麻烦。</p>
<p>在方法内部引用数据属性（或其他方法！）并没有简便方式。 我发现这实际上提升了方法的可读性：当浏览一个方法代码时，不会存在混淆局部变量和实例变量的机会。</p>
<p>方法的第一个参数常常被命名为 <code>self</code>。 这也不过就是一个约定: <code>self</code> 这一名称在 Python 中绝对没有特殊含义。 但是要注意，不遵循此约定会使得你的代码对其他 Python 程序员来说缺乏可读性，而且也可以想像一个 <em>类浏览器</em> 程序的编写可能会依赖于这样的约定。</p>
<p>任何一个作为类属性的函数都为该类的实例定义了一个相应方法。 函数定义的文本并非必须包含于类定义之内：将一个函数对象赋值给一个局部变量也是可以的。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Function defined outside the class</span>
<span class="token keyword">def</span> <span class="token function">f1</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> min<span class="token punctuation">(</span>x<span class="token punctuation">,</span> x<span class="token operator">+</span>y<span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
    f <span class="token operator">=</span> f1
    <span class="token keyword">def</span> <span class="token function">g</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'hello world'</span>
    h <span class="token operator">=</span> g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在 <code>f</code>, <code>g</code> 和 <code>h</code> 都是 <code>C</code> 类的引用函数对象的属性，因而它们就都是 <code>C</code> 的实例的方法 —- 其中 <code>h</code> 完全等同于 <code>g</code>。 但请注意，本示例的做法通常只会令程序的阅读者感到迷惑。</p>
<p>方法可以通过使用 <code>self</code> 参数的方法属性调用其他方法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Bag</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">addtwice</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>add<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>add<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>方法可以通过与普通函数相同的方式引用全局名称。 与方法相关联的全局作用域就是包含其定义的模块。 （类永远不会被作为全局作用域。） 虽然我们很少会有充分的理由在方法中使用全局作用域，但全局作用域存在许多合理的使用场景：举个例子，导入到全局作用域的函数和模块可以被方法所使用，在其中定义的函数和类也一样。 通常，包含该方法的类本身是在全局作用域中定义的，而在下一节中我们将会发现为何方法需要引用其所属类的很好的理由。</p>
<p>每个值都是一个对象，因此具有 <em>类</em> （也称为 <em>类型</em>），并存储为 <code>object.__class__</code> 。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>当然，如果不支持继承，语言特性就不值得称为“类”。派生类定义的语法如下所示:</p>
<pre><code>class DerivedClassName(BaseClassName):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;</code></pre><p>名称 <code>BaseClassName</code> 必须定义于包含派生类定义的作用域中。 也允许用其他任意表达式代替基类名称所在的位置。 这有时也可能会用得上，例如，当基类定义在另一个模块中的时候:</p>
<pre><code>class DerivedClassName(modname.BaseClassName):</code></pre><p>派生类定义的执行过程与基类相同。 当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。</p>
<p>派生类的实例化没有任何特殊之处: <code>DerivedClassName()</code> 会创建该类的一个新实例。 方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。</p>
<p>派生类可能会重写其基类的方法。 因为方法在调用同一对象的其他方法时没有特殊权限，所以调用同一基类中定义的另一方法的基类方法最终可能会调用覆盖它的派生类的方法。 （对 C++ 程序员的提示：Python 中所有的方法实际上都是 <code>virtual</code> 方法。）</p>
<p>在派生类中的重载方法实际上可能想要扩展而非简单地替换同名的基类方法。 有一种方式可以简单地直接调用基类方法：即调用 <code>BaseClassName.methodname(self, arguments)</code>。 有时这对客户端来说也是有用的。 （请注意仅当此基类可在全局作用域中以 <code>BaseClassName</code> 的名称被访问时方可使用此方式。）</p>
<p>Python有两个内置函数可被用于继承机制：</p>
<ul>
<li>使用 <code>isinstance()</code> 来检查一个实例的类型: <code>isinstance(obj, int)</code> 仅会在 <code>obj.__class__</code> 为 <code>int</code> 或某个派生自 <code>int</code> 的类时为 <code>True</code>。</li>
<li>使用 <code>issubclass()</code> 来检查类的继承关系: <code>issubclass(bool, int)</code> 为 <code>True</code>，因为 <code>bool</code> 是 <code>int</code> 的子类。 但是，<code>issubclass(float, int)</code> 为 <code>False</code>，因为 <code>float</code> 不是 <code>int</code> 的子类。</li>
</ul>
<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>Python 也支持一种多重继承。 带有多个基类的类定义语句如下所示:</p>
<pre><code>class DerivedClassName(Base1, Base2, Base3):
    &lt;statement-1&gt;
    .
    .
    .
    &lt;statement-N&gt;</code></pre><p>对于多数应用来说，在最简单的情况下，你可以认为搜索从父类所继承属性的操作是深度优先、从左至右的，当层次结构中存在重叠时不会在同一个类中搜索两次。 因此，如果某一属性在 <code>DerivedClassName</code> 中未找到，则会到 <code>Base1</code> 中搜索它，然后（递归地）到 <code>Base1</code> 的基类中搜索，如果在那里未找到，再到 <code>Base2</code> 中搜索，依此类推。</p>
<p>真实情况比这个更复杂一些；方法解析顺序会动态改变以支持对 <code>super()</code> 的协同调用。 这种方式在某些其他多重继承型语言中被称为后续方法调用，它比单继承型语言中的 super 调用更强大。</p>
<p>动态改变顺序是有必要的，因为所有多重继承的情况都会显示出一个或更多的菱形关联（即至少有一个父类可通过多条路径被最底层类所访问）。 例如，所有类都是继承自 <code>object</code>，因此任何多重继承的情况都提供了一条以上的路径可以通向 <code>object</code>。 为了确保基类不会被访问一次以上，动态算法会用一种特殊方式将搜索顺序线性化， 保留每个类所指定的从左至右的顺序，只调用每个父类一次，并且保持单调（即一个类可以被子类化而不影响其父类的优先顺序）。 总而言之，这些特性使得设计具有多重继承的可靠且可扩展的类成为可能。 要了解更多细节，请参阅 <a href="https://www.python.org/download/releases/2.3/mro/。" target="_blank" rel="noopener">https://www.python.org/download/releases/2.3/mro/。</a></p>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>那种仅限从一个对象内部访问的“私有”实例变量在 Python 中并不存在。 但是，大多数 Python 代码都遵循这样一个约定：带有一个下划线的名称 (例如 <code>_spam</code>) 应该被当作是 API 的非公有部分 (无论它是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。</p>
<p>由于存在对于类私有成员的有效使用场景（例如避免名称与子类所定义的名称相冲突），因此存在对此种机制的有限支持，称为 <em>名称改写</em>。 任何形式为 <code>__spam</code> 的标识符（至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 <code>_classname__spam</code>，其中 <code>classname</code> 为去除了前缀下划线的当前类名称。 这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。</p>
<p>名称改写有助于让子类重载方法而不破坏类内方法调用。例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Mapping</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>items_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        self<span class="token punctuation">.</span>__update<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> item <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>items_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">)</span>
    __update <span class="token operator">=</span> update   <span class="token comment" spellcheck="true"># private copy of original update() method</span>
<span class="token keyword">class</span> <span class="token class-name">MappingSubclass</span><span class="token punctuation">(</span>Mapping<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> keys<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># provides new signature for update()</span>
        <span class="token comment" spellcheck="true"># but does not break __init__()</span>
        <span class="token keyword">for</span> item <span class="token keyword">in</span> zip<span class="token punctuation">(</span>keys<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>items_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的示例即使在 <code>MappingSubclass</code> 引入了一个 <code>__update</code> 标识符的情况下也不会出错，因为它会在 <code>Mapping</code> 类中被替换为 <code>_Mapping__update</code> 而在 <code>MappingSubclass</code> 类中被替换为 <code>_MappingSubclass__update</code>。</p>
<p>请注意，改写规则的设计主要是为了避免意外冲突；访问或修改被视为私有的变量仍然是可能的。这在特殊情况下甚至会很有用，例如在调试器中。</p>
<p>请注意传递给 <code>exec()</code> 或 <code>eval()</code> 的代码不会将发起调用类的类名视作当前类；这类似于 <code>global</code> 语句的效果，因此这种效果仅限于同时经过字节码编译的代码。 同样的限制也适用于 <code>getattr()</code>, <code>setattr()</code> 和 <code>delattr()</code>，以及对于 <code>__dict__</code> 的直接引用。</p>
<h3 id="杂项说明"><a href="#杂项说明" class="headerlink" title="杂项说明"></a>杂项说明</h3><p>有时会需要使用类似于 Pascal 的“record”或 C 的“struct”这样的数据类型，将一些命名数据项捆绑在一起。 这种情况适合定义一个空类:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Employee</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
john <span class="token operator">=</span> Employee<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Create an empty employee record</span>
<span class="token comment" spellcheck="true"># Fill the fields of the record</span>
john<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'John Doe'</span>
john<span class="token punctuation">.</span>dept <span class="token operator">=</span> <span class="token string">'computer lab'</span>
john<span class="token punctuation">.</span>salary <span class="token operator">=</span> <span class="token number">1000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一段需要特定抽象数据类型的 Python 代码往往可以被传入一个模拟了该数据类型的方法的类作为替代。 例如，如果你有一个基于文件对象来格式化某些数据的函数，你可以定义一个带有 <code>read()</code> 和 <code>readline()</code> 方法从字符串缓存获取数据的类，并将其作为参数传入。</p>
<p>实例方法对象也具有属性: <code>m.__self__</code> 就是带有 <code>m()</code> 方法的实例对象，而 <code>m.__func__</code> 则是该方法所对应的函数对象。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>到目前为止，您可能已经注意到大多数容器对象都可以使用 <code>for</code> 语句:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> element <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>
<span class="token keyword">for</span> key <span class="token keyword">in</span> <span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token keyword">for</span> char <span class="token keyword">in</span> <span class="token string">"123"</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span>
<span class="token keyword">for</span> line <span class="token keyword">in</span> open<span class="token punctuation">(</span><span class="token string">"myfile.txt"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种访问风格清晰、简洁又方便。 迭代器的使用非常普遍并使得 Python 成为一个统一的整体。 在幕后，<code>for</code> 语句会在容器对象上调用 <code>iter()</code>。 该函数返回一个定义了 <code>__next__()</code> 方法的迭代器对象，此方法将逐一访问容器中的元素。 当元素用尽时，<code>__next__()</code> 将引发 <code>StopIteration</code> 异常来通知终止 <code>for</code> 循环。 你可以使用 <code>next()</code> 内置函数来调用 <code>__next__()</code> 方法；这个例子显示了它的运作方式:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">'abc'</span>
<span class="token operator">>></span><span class="token operator">></span> it <span class="token operator">=</span> iter<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> it
<span class="token operator">&lt;</span>iterator object at <span class="token number">0x00A1DB50</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
<span class="token string">'a'</span>
<span class="token operator">>></span><span class="token operator">></span> next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
<span class="token string">'b'</span>
<span class="token operator">>></span><span class="token operator">></span> next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
<span class="token string">'c'</span>
<span class="token operator">>></span><span class="token operator">></span> next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
    next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
StopIteration<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>看过迭代器协议的幕后机制，给你的类添加迭代器行为就很容易了。 定义一个 <code>__iter__()</code> 方法来返回一个带有 <code>__next__()</code> 方法的对象。 如果类已定义了 <code>__next__()</code>，则 <code>__iter__()</code> 可以简单地返回 <code>self</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Reverse</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Iterator for looping over a sequence backwards."""</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>data <span class="token operator">=</span> data
        self<span class="token punctuation">.</span>index <span class="token operator">=</span> len<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self
    <span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> StopIteration
        self<span class="token punctuation">.</span>index <span class="token operator">=</span> self<span class="token punctuation">.</span>index <span class="token operator">-</span> <span class="token number">1</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>self<span class="token punctuation">.</span>index<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> rev <span class="token operator">=</span> Reverse<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> iter<span class="token punctuation">(</span>rev<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Reverse object at <span class="token number">0x00A1DB50</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> char <span class="token keyword">in</span> rev<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
m
a
p
s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>生成器 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似于标准的函数，但当它们要返回数据时会使用 <code>yield</code> 语句。 每次在生成器上调用 <code>next()</code> 时，它会从上次离开的位置恢复执行（它会记住上次执行语句时的所有数据值）。 一个显示如何非常容易地创建生成器的示例如下:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">reverse</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">yield</span> data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> char <span class="token keyword">in</span> reverse<span class="token punctuation">(</span><span class="token string">'golf'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>char<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
f
l
o
g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以用生成器来完成的操作同样可以用前一节所描述的基于类的迭代器来完成。 但生成器的写法更为紧凑，因为它会自动创建 <code>__iter__()</code> 和 <code>__next__()</code> 方法。</p>
<p>另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存。 这使得该函数相比使用 <code>self.index</code> 和 <code>self.data</code> 这种实例变量的方式更易编写且更为清晰。</p>
<p>除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发 <code>StopIteration</code>。 这些特性结合在一起，使得创建迭代器能与编写常规函数一样容易。</p>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，但外层为圆括号而非方括号。 这种表达式被设计用于生成器将立即被外层函数所使用的情况。 生成器表达式相比完整的生成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sum<span class="token punctuation">(</span>i<span class="token operator">*</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true"># sum of squares</span>
<span class="token number">285</span>
<span class="token operator">>></span><span class="token operator">></span> xvec <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> yvec <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> sum<span class="token punctuation">(</span>x<span class="token operator">*</span>y <span class="token keyword">for</span> x<span class="token punctuation">,</span>y <span class="token keyword">in</span> zip<span class="token punctuation">(</span>xvec<span class="token punctuation">,</span> yvec<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># dot product</span>
<span class="token number">260</span>
<span class="token operator">>></span><span class="token operator">></span> unique_words <span class="token operator">=</span> set<span class="token punctuation">(</span>word <span class="token keyword">for</span> line <span class="token keyword">in</span> page  <span class="token keyword">for</span> word <span class="token keyword">in</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> valedictorian <span class="token operator">=</span> max<span class="token punctuation">(</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span>gpa<span class="token punctuation">,</span> student<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token keyword">for</span> student <span class="token keyword">in</span> graduates<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span> <span class="token string">'golf'</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注:</p>
<ul>
<li>存在一个例外。 模块对象有一个秘密的只读属性 <code>__dict__</code>，它返回用于实现模块命名空间的字典；<code>__dict__</code> 是属性但不是全局名称。 显然，使用这个将违反命名空间实现的抽象，应当仅被用于事后调试器之类的场合。</li>
</ul>
<h2 id="9-标准库简介"><a href="#9-标准库简介" class="headerlink" title="9. 标准库简介"></a>9. 标准库简介</h2><h3 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h3><p><code>os</code> 模块提供了许多与操作系统交互的函数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># Return the current working directory</span>
<span class="token string">'C:\\Python310'</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>chdir<span class="token punctuation">(</span><span class="token string">'/server/accesslogs'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Change current working directory</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">'mkdir today'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Run the command mkdir in the system shell</span>
<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一定要使用 <code>import os</code> 而不是 <code>from os import *</code> 。这将避免内建的 <code>open()</code> 函数被 <code>os.open()</code> 隐式替换掉，因为它们的使用方式大不相同。</p>
<p>内置的 <code>dir()</code> 和 <code>help()</code> 函数可用作交互式辅助工具，用于处理大型模块，如 <code>os</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> dir<span class="token punctuation">(</span>os<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>returns a list of all module functions<span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> help<span class="token punctuation">(</span>os<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>returns an extensive manual page created <span class="token keyword">from</span> the module's docstrings<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于日常文件和目录管理任务， <code>shutil</code> 模块提供了更易于使用的更高级别的接口:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> shutil
<span class="token operator">>></span><span class="token operator">></span> shutil<span class="token punctuation">.</span>copyfile<span class="token punctuation">(</span><span class="token string">'data.db'</span><span class="token punctuation">,</span> <span class="token string">'archive.db'</span><span class="token punctuation">)</span>
<span class="token string">'archive.db'</span>
<span class="token operator">>></span><span class="token operator">></span> shutil<span class="token punctuation">.</span>move<span class="token punctuation">(</span><span class="token string">'/build/executables'</span><span class="token punctuation">,</span> <span class="token string">'installdir'</span><span class="token punctuation">)</span>
<span class="token string">'installdir'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="文件通配符"><a href="#文件通配符" class="headerlink" title="文件通配符"></a>文件通配符</h3><p><code>glob</code> 模块提供了一个在目录中使用通配符搜索创建文件列表的函数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> glob
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'*.py'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'primes.py'</span><span class="token punctuation">,</span> <span class="token string">'random.py'</span><span class="token punctuation">,</span> <span class="token string">'quote.py'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>通用实用程序脚本通常需要处理命令行参数。这些参数作为列表存储在 <code>sys</code> 模块的 <em>argv</em> 属性中。例如，以下输出来自在命令行运行 <code>python demo.py one two three</code></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> sys
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'demo.py'</span><span class="token punctuation">,</span> <span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>argparse</code> 模块提供了一种更复杂的机制来处理命令行参数。 以下脚本可提取一个或多个文件名，并可选择要显示的行数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> argparse
parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span>prog <span class="token operator">=</span> <span class="token string">'top'</span><span class="token punctuation">,</span>
    description <span class="token operator">=</span> <span class="token string">'Show top lines from each file'</span><span class="token punctuation">)</span>
parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'filenames'</span><span class="token punctuation">,</span> nargs<span class="token operator">=</span><span class="token string">'+'</span><span class="token punctuation">)</span>
parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-l'</span><span class="token punctuation">,</span> <span class="token string">'--lines'</span><span class="token punctuation">,</span> type<span class="token operator">=</span>int<span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>
args <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当在通过 <code>python top.py --lines=5 alpha.txt beta.txt</code> 在命令行运行时，该脚本会将 <code>args.lines</code> 设为 <code>5</code> 并将 <code>args.filenames</code> 设为 <code>['alpha.txt', 'beta.txt']</code>。</p>
<h3 id="错误输出重定向和程序终止"><a href="#错误输出重定向和程序终止" class="headerlink" title="错误输出重定向和程序终止"></a>错误输出重定向和程序终止</h3><p><code>sys</code> 模块还具有 <em>stdin</em> ， <em>stdout</em> 和 <em>stderr</em> 的属性。后者对于发出警告和错误消息非常有用，即使在 <em>stdout</em> 被重定向后也可以看到它们:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>stderr<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'Warning, log file not found starting a new one\n'</span><span class="token punctuation">)</span>
Warning<span class="token punctuation">,</span> log file <span class="token operator">not</span> found starting a new one<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>终止脚本的最直接方法是使用 <code>sys.exit()</code> 。</p>
<h3 id="字符串模式匹配"><a href="#字符串模式匹配" class="headerlink" title="字符串模式匹配"></a>字符串模式匹配</h3><p><code>re</code> 模块为高级字符串处理提供正则表达式工具。对于复杂的匹配和操作，正则表达式提供简洁，优化的解决方案:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> re
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">'\bf[a-z]*'</span><span class="token punctuation">,</span> <span class="token string">'which foot or hand fell fastest'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'foot'</span><span class="token punctuation">,</span> <span class="token string">'fell'</span><span class="token punctuation">,</span> <span class="token string">'fastest'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">'(\b[a-z]+) \1'</span><span class="token punctuation">,</span> r<span class="token string">'\1'</span><span class="token punctuation">,</span> <span class="token string">'cat in the the hat'</span><span class="token punctuation">)</span>
<span class="token string">'cat in the hat'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当只需要简单的功能时，首选字符串方法因为它们更容易阅读和调试:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'tea for too'</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'too'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">)</span>
<span class="token string">'tea for two'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p><code>math</code> 模块提供对浮点数学的底层C库函数的访问:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> math
<span class="token operator">>></span><span class="token operator">></span> math<span class="token punctuation">.</span>cos<span class="token punctuation">(</span>math<span class="token punctuation">.</span>pi <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token number">0.70710678118654757</span>
<span class="token operator">>></span><span class="token operator">></span> math<span class="token punctuation">.</span>log<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token number">10.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>random</code> 模块提供了进行随机选择的工具:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> random
<span class="token operator">>></span><span class="token operator">></span> random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token string">'banana'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">'apple'</span>
<span class="token operator">>></span><span class="token operator">></span> random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># sampling without replacement</span>
<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">83</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">81</span><span class="token punctuation">,</span> <span class="token number">41</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># random float</span>
<span class="token number">0.17970987693706186</span>
<span class="token operator">>></span><span class="token operator">></span> random<span class="token punctuation">.</span>randrange<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># random integer chosen from range(6)</span>
<span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>statistics</code> 模块计算数值数据的基本统计属性（均值，中位数，方差等）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> statistics
<span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2.75</span><span class="token punctuation">,</span> <span class="token number">1.75</span><span class="token punctuation">,</span> <span class="token number">1.25</span><span class="token punctuation">,</span> <span class="token number">0.25</span><span class="token punctuation">,</span> <span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1.25</span><span class="token punctuation">,</span> <span class="token number">3.5</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> statistics<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token number">1.6071428571428572</span>
<span class="token operator">>></span><span class="token operator">></span> statistics<span class="token punctuation">.</span>median<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token number">1.25</span>
<span class="token operator">>></span><span class="token operator">></span> statistics<span class="token punctuation">.</span>variance<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token number">1.3720238095238095</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>SciPy项目 <a href="https://scipy.org/" target="_blank" rel="noopener">https://scipy.org</a>有许多其他模块用于数值计算。</p>
<h3 id="互联网访问"><a href="#互联网访问" class="headerlink" title="互联网访问"></a>互联网访问</h3><p>有许多模块可用于访问互联网和处理互联网协议。其中两个最简单的 <code>urllib.request</code> 用于从URL检索数据，以及 <code>smtplib</code> 用于发送邮件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> urllib<span class="token punctuation">.</span>request <span class="token keyword">import</span> urlopen
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> urlopen<span class="token punctuation">(</span><span class="token string">'http://tycho.usno.navy.mil/cgi-bin/timer.pl'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> response<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> line <span class="token keyword">in</span> response<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         line <span class="token operator">=</span> line<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Decoding the binary data to text.</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">if</span> <span class="token string">'EST'</span> <span class="token keyword">in</span> line <span class="token operator">or</span> <span class="token string">'EDT'</span> <span class="token keyword">in</span> line<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># look for Eastern Time</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>BR<span class="token operator">></span>Nov<span class="token punctuation">.</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">09</span><span class="token punctuation">:</span><span class="token number">43</span><span class="token punctuation">:</span><span class="token number">32</span> PM EST
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> smtplib
<span class="token operator">>></span><span class="token operator">></span> server <span class="token operator">=</span> smtplib<span class="token punctuation">.</span>SMTP<span class="token punctuation">(</span><span class="token string">'localhost'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> server<span class="token punctuation">.</span>sendmail<span class="token punctuation">(</span><span class="token string">'soothsayer@example.org'</span><span class="token punctuation">,</span> <span class="token string">'jcaesar@example.org'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token triple-quoted-string string">"""To: jcaesar@example.org
... From: soothsayer@example.org
...
... Beware the Ides of March.
... """</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> server<span class="token punctuation">.</span>quit<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（请注意，第二个示例需要在localhost上运行的邮件服务器。）</p>
<h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><p><code>datetime</code> 模块提供了以简单和复杂的方式操作日期和时间的类。虽然支持日期和时间算法，但实现的重点是有效的成员提取以进行输出格式化和操作。该模块还支持可感知时区的对象。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># dates are easily constructed and formatted</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> datetime <span class="token keyword">import</span> date
<span class="token operator">>></span><span class="token operator">></span> now <span class="token operator">=</span> date<span class="token punctuation">.</span>today<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> now
datetime<span class="token punctuation">.</span>date<span class="token punctuation">(</span><span class="token number">2003</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> now<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">"%m-%d-%y. %d %b %Y is a %A on the %d day of %B."</span><span class="token punctuation">)</span>
<span class="token string">'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># dates support calendar arithmetic</span>
<span class="token operator">>></span><span class="token operator">></span> birthday <span class="token operator">=</span> date<span class="token punctuation">(</span><span class="token number">1964</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">31</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> age <span class="token operator">=</span> now <span class="token operator">-</span> birthday
<span class="token operator">>></span><span class="token operator">></span> age<span class="token punctuation">.</span>days
<span class="token number">14368</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>常见的数据存档和压缩格式由模块直接支持，包括：<code>zlib</code>, <code>gzip</code>, <code>bz2</code>, <code>lzma</code>, <code>zipfile</code> 和 <code>tarfile</code>。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> zlib
<span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> b<span class="token string">'witch which has which witches wrist watch'</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token number">41</span>
<span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> zlib<span class="token punctuation">.</span>compress<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>t<span class="token punctuation">)</span>
<span class="token number">37</span>
<span class="token operator">>></span><span class="token operator">></span> zlib<span class="token punctuation">.</span>decompress<span class="token punctuation">(</span>t<span class="token punctuation">)</span>
b<span class="token string">'witch which has which witches wrist watch'</span>
<span class="token operator">>></span><span class="token operator">></span> zlib<span class="token punctuation">.</span>crc32<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token number">226805979</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="性能测量"><a href="#性能测量" class="headerlink" title="性能测量"></a>性能测量</h3><p>一些Python用户对了解同一问题的不同方法的相对性能产生了浓厚的兴趣。 Python提供了一种可以立即回答这些问题的测量工具。</p>
<p>例如，元组封包和拆包功能相比传统的交换参数可能更具吸引力。<code>timeit</code> 模块可以快速演示在运行效率方面一定的优势:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> timeit <span class="token keyword">import</span> Timer
<span class="token operator">>></span><span class="token operator">></span> Timer<span class="token punctuation">(</span><span class="token string">'t=a; a=b; b=t'</span><span class="token punctuation">,</span> <span class="token string">'a=1; b=2'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timeit<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">0.57535828626024577</span>
<span class="token operator">>></span><span class="token operator">></span> Timer<span class="token punctuation">(</span><span class="token string">'a,b = b,a'</span><span class="token punctuation">,</span> <span class="token string">'a=1; b=2'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>timeit<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">0.54962537085770791</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与 <code>timeit</code> 的精细粒度级别相反， <code>profile</code> 和 <code>pstats</code> 模块提供了用于在较大的代码块中识别时间关键部分的工具。</p>
<h3 id="质量控制"><a href="#质量控制" class="headerlink" title="质量控制"></a>质量控制</h3><p>开发高质量软件的一种方法是在开发过程中为每个函数编写测试，并在开发过程中经常运行这些测试。</p>
<p><code>doctest</code> 模块提供了一个工具，用于扫描模块并验证程序文档字符串中嵌入的测试。测试构造就像将典型调用及其结果剪切并粘贴到文档字符串一样简单。这通过向用户提供示例来改进文档，并且它允许doctest模块确保代码保持对文档的真实:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">average</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Computes the arithmetic mean of a list of numbers.
    >>> print(average([20, 30, 70]))
    40.0
    """</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">(</span>values<span class="token punctuation">)</span> <span class="token operator">/</span> len<span class="token punctuation">(</span>values<span class="token punctuation">)</span>
<span class="token keyword">import</span> doctest
doctest<span class="token punctuation">.</span>testmod<span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># automatically validate the embedded tests</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>unittest</code> 模块不像 <code>doctest</code> 模块那样易于使用，但它允许在一个单独的文件中维护更全面的测试集:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> unittest
<span class="token keyword">class</span> <span class="token class-name">TestStatisticalFunctions</span><span class="token punctuation">(</span>unittest<span class="token punctuation">.</span>TestCase<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">test_average</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>assertEqual<span class="token punctuation">(</span>average<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">40.0</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>assertEqual<span class="token punctuation">(</span>round<span class="token punctuation">(</span>average<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4.3</span><span class="token punctuation">)</span>
        <span class="token keyword">with</span> self<span class="token punctuation">.</span>assertRaises<span class="token punctuation">(</span>ZeroDivisionError<span class="token punctuation">)</span><span class="token punctuation">:</span>
            average<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">with</span> self<span class="token punctuation">.</span>assertRaises<span class="token punctuation">(</span>TypeError<span class="token punctuation">)</span><span class="token punctuation">:</span>
            average<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">)</span>
unittest<span class="token punctuation">.</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Calling from the command line invokes all tests</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="自带电池"><a href="#自带电池" class="headerlink" title="自带电池"></a>自带电池</h3><p>Python有“自带电池”的理念。通过其包的复杂和强大功能可以最好地看到这一点。例如:</p>
<ul>
<li><code>xmlrpc.client</code> 和 <code>xmlrpc.server</code> 模块使得实现远程过程调用变成了小菜一碟。 尽管存在于模块名称中，但用户不需要直接了解或处理 XML。</li>
<li><code>email</code> 包是一个用于管理电子邮件的库，包括MIME和其他符合 <a href="https://tools.ietf.org/html/rfc2822.html" target="_blank" rel="noopener"><strong>RFC 2822</strong></a> 规范的邮件文档。与 <code>smtplib</code> 和 <code>poplib</code> 不同（它们实际上做的是发送和接收消息），电子邮件包提供完整的工具集，用于构建或解码复杂的消息结构（包括附件）以及实现互联网编码和标头协议。</li>
<li><code>json</code> 包为解析这种流行的数据交换格式提供了强大的支持。 <code>csv</code> 模块支持以逗号分隔值格式直接读取和写入文件，这种格式通常为数据库和电子表格所支持。 XML 处理由 <code>xml.etree.ElementTree</code> ， <code>xml.dom</code> 和 <code>xml.sax</code> 包支持。这些模块和软件包共同大大简化了 Python 应用程序和其他工具之间的数据交换。</li>
<li><code>sqlite3</code> 模块是 SQLite 数据库库的包装器，提供了一个可以使用稍微非标准的 SQL 语法更新和访问的持久数据库。</li>
<li>国际化由许多模块支持，包括 <code>gettext</code> ， <code>locale</code> ，以及 <code>codecs</code> 包。</li>
</ul>
<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p><code>reprlib</code> 模块提供了一个定制化版本的 <code>repr()</code> 函数，用于缩略显示大型或深层嵌套的容器对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> reprlib
<span class="token operator">>></span><span class="token operator">></span> reprlib<span class="token punctuation">.</span>repr<span class="token punctuation">(</span>set<span class="token punctuation">(</span><span class="token string">'supercalifragilisticexpialidocious'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">"{'a', 'c', 'd', 'e', 'f', 'g', ...}"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>pprint</code> 模块提供了更加复杂的打印控制，其输出的内置对象和用户自定义对象能够被解释器直接读取。当输出结果过长而需要折行时，“美化输出机制”会添加换行符和缩进，以更清楚地展示数据结构:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> pprint
<span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'black'</span><span class="token punctuation">,</span> <span class="token string">'cyan'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'white'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'green'</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'magenta'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token string">'yellow'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> pprint<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>t<span class="token punctuation">,</span> width<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'black'</span><span class="token punctuation">,</span> <span class="token string">'cyan'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
   <span class="token string">'white'</span><span class="token punctuation">,</span>
   <span class="token punctuation">[</span><span class="token string">'green'</span><span class="token punctuation">,</span> <span class="token string">'red'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'magenta'</span><span class="token punctuation">,</span> <span class="token string">'yellow'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
   <span class="token string">'blue'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>textwrap</code> 模块能够格式化文本段落，以适应给定的屏幕宽度:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> textwrap
<span class="token operator">>></span><span class="token operator">></span> doc <span class="token operator">=</span> <span class="token triple-quoted-string string">"""The wrap() method is just like fill() except that it returns
... a list of strings instead of one big string with newlines to separate
... the wrapped lines."""</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>textwrap<span class="token punctuation">.</span>fill<span class="token punctuation">(</span>doc<span class="token punctuation">,</span> width<span class="token operator">=</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
The wrap<span class="token punctuation">(</span><span class="token punctuation">)</span> method <span class="token keyword">is</span> just like fill<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> that it returns a list of strings
instead of one big string <span class="token keyword">with</span> newlines
to separate the wrapped lines<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>locale</code> 模块处理与特定地域文化相关的数据格式。locale 模块的 format 函数包含一个 grouping 属性，可直接将数字格式化为带有组分隔符的样式:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> locale
<span class="token operator">>></span><span class="token operator">></span> locale<span class="token punctuation">.</span>setlocale<span class="token punctuation">(</span>locale<span class="token punctuation">.</span>LC_ALL<span class="token punctuation">,</span> <span class="token string">'English_United States.1252'</span><span class="token punctuation">)</span>
<span class="token string">'English_United States.1252'</span>
<span class="token operator">>></span><span class="token operator">></span> conv <span class="token operator">=</span> locale<span class="token punctuation">.</span>localeconv<span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># get a mapping of conventions</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token number">1234567.8</span>
<span class="token operator">>></span><span class="token operator">></span> locale<span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> grouping<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token string">'1,234,567'</span>
<span class="token operator">>></span><span class="token operator">></span> locale<span class="token punctuation">.</span>format_string<span class="token punctuation">(</span><span class="token string">"%s%.*f"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>conv<span class="token punctuation">[</span><span class="token string">'currency_symbol'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                      conv<span class="token punctuation">[</span><span class="token string">'frac_digits'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">,</span> grouping<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token string">'$1,234,567.80'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p><code>string</code> 模块包含一个通用的 <code>Template</code> 类，具有适用于最终用户的简化语法。它允许用户在不更改应用逻辑的情况下定制自己的应用。</p>
<p>上述格式化操作是通过占位符实现的，占位符由 <code>$</code> 加上合法的 Python 标识符（只能包含字母、数字和下划线）构成。一旦使用花括号将占位符括起来，就可以在后面直接跟上更多的字母和数字而无需空格分割。<code>$$</code> 将被转义成单个字符 <code>$</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> string <span class="token keyword">import</span> Template
<span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> Template<span class="token punctuation">(</span><span class="token string">'${village}folk send $$10 to $cause.'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>substitute<span class="token punctuation">(</span>village<span class="token operator">=</span><span class="token string">'Nottingham'</span><span class="token punctuation">,</span> cause<span class="token operator">=</span><span class="token string">'the ditch fund'</span><span class="token punctuation">)</span>
<span class="token string">'Nottinghamfolk send $10 to the ditch fund.'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果在字典或关键字参数中未提供某个占位符的值，那么 <code>substitute()</code> 方法将抛出 <code>KeyError</code>。对于邮件合并类型的应用，用户提供的数据有可能是不完整的，此时使用 <code>safe_substitute()</code> 方法更加合适 —— 如果数据缺失，它会直接将占位符原样保留。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> Template<span class="token punctuation">(</span><span class="token string">'Return the $item to $owner.'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> dict<span class="token punctuation">(</span>item<span class="token operator">=</span><span class="token string">'unladen swallow'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>substitute<span class="token punctuation">(</span>d<span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
KeyError<span class="token punctuation">:</span> <span class="token string">'owner'</span>
<span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">.</span>safe_substitute<span class="token punctuation">(</span>d<span class="token punctuation">)</span>
<span class="token string">'Return the unladen swallow to $owner.'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Template 的子类可以自定义分隔符。例如，以下是某个照片浏览器的批量重命名功能，采用了百分号作为日期、照片序号和照片格式的占位符:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> time<span class="token punctuation">,</span> os<span class="token punctuation">.</span>path
<span class="token operator">>></span><span class="token operator">></span> photofiles <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'img_1074.jpg'</span><span class="token punctuation">,</span> <span class="token string">'img_1076.jpg'</span><span class="token punctuation">,</span> <span class="token string">'img_1077.jpg'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">BatchRename</span><span class="token punctuation">(</span>Template<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     delimiter <span class="token operator">=</span> <span class="token string">'%'</span>
<span class="token operator">>></span><span class="token operator">></span> fmt <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">'Enter rename style (%d-date %n-seqnum %f-format):  '</span><span class="token punctuation">)</span>
Enter rename style <span class="token punctuation">(</span><span class="token operator">%</span>d<span class="token operator">-</span>date <span class="token operator">%</span>n<span class="token operator">-</span>seqnum <span class="token operator">%</span>f<span class="token operator">-</span>format<span class="token punctuation">)</span><span class="token punctuation">:</span>  Ashley_<span class="token operator">%</span>n<span class="token operator">%</span>f
<span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> BatchRename<span class="token punctuation">(</span>fmt<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> date <span class="token operator">=</span> time<span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%d%b%y'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> i<span class="token punctuation">,</span> filename <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>photofiles<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     base<span class="token punctuation">,</span> ext <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>splitext<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     newname <span class="token operator">=</span> t<span class="token punctuation">.</span>substitute<span class="token punctuation">(</span>d<span class="token operator">=</span>date<span class="token punctuation">,</span> n<span class="token operator">=</span>i<span class="token punctuation">,</span> f<span class="token operator">=</span>ext<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'{0} --> {1}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>filename<span class="token punctuation">,</span> newname<span class="token punctuation">)</span><span class="token punctuation">)</span>
img_1074<span class="token punctuation">.</span>jpg <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> Ashley_0<span class="token punctuation">.</span>jpg
img_1076<span class="token punctuation">.</span>jpg <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> Ashley_1<span class="token punctuation">.</span>jpg
img_1077<span class="token punctuation">.</span>jpg <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> Ashley_2<span class="token punctuation">.</span>jpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>模板的另一个应用是将程序逻辑与多样的格式化输出细节分离开来。这使得对 XML 文件、纯文本报表和 HTML 网络报表使用自定义模板成为可能。</p>
<h3 id="使用二进制数据记录格式"><a href="#使用二进制数据记录格式" class="headerlink" title="使用二进制数据记录格式"></a>使用二进制数据记录格式</h3><p><code>struct</code> 模块提供了 <code>pack()</code> 和 <code>unpack()</code> 函数，用于处理不定长度的二进制记录格式。下面的例子展示了在不使用 <code>zipfile</code> 模块的情况下，如何循环遍历一个 ZIP 文件的所有头信息。Pack 代码 <code>"H"</code> 和 <code>"I"</code> 分别代表两字节和四字节无符号整数。<code>"&lt;"</code> 代表它们是标准尺寸的小端字节序:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> struct
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'myfile.zip'</span><span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    data <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
start <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                      <span class="token comment" spellcheck="true"># show the first 3 file headers</span>
    start <span class="token operator">+=</span> <span class="token number">14</span>
    fields <span class="token operator">=</span> struct<span class="token punctuation">.</span>unpack<span class="token punctuation">(</span><span class="token string">'&lt;IIIHH'</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>start<span class="token punctuation">:</span>start<span class="token operator">+</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    crc32<span class="token punctuation">,</span> comp_size<span class="token punctuation">,</span> uncomp_size<span class="token punctuation">,</span> filenamesize<span class="token punctuation">,</span> extra_size <span class="token operator">=</span> fields
    start <span class="token operator">+=</span> <span class="token number">16</span>
    filename <span class="token operator">=</span> data<span class="token punctuation">[</span>start<span class="token punctuation">:</span>start<span class="token operator">+</span>filenamesize<span class="token punctuation">]</span>
    start <span class="token operator">+=</span> filenamesize
    extra <span class="token operator">=</span> data<span class="token punctuation">[</span>start<span class="token punctuation">:</span>start<span class="token operator">+</span>extra_size<span class="token punctuation">]</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> hex<span class="token punctuation">(</span>crc32<span class="token punctuation">)</span><span class="token punctuation">,</span> comp_size<span class="token punctuation">,</span> uncomp_size<span class="token punctuation">)</span>
    start <span class="token operator">+=</span> extra_size <span class="token operator">+</span> comp_size     <span class="token comment" spellcheck="true"># skip to the next header</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>线程是一种对于非顺序依赖的多个任务进行解耦的技术。多线程可以提高应用的响应效率，当接收用户输入的同时，保持其他任务在后台运行。一个有关的应用场景是，将 I/O 和计算运行在两个并行的线程中。</p>
<p>以下代码展示了高阶的 <code>threading</code> 模块如何在后台运行任务，且不影响主程序的继续运行:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token punctuation">,</span> zipfile
<span class="token keyword">class</span> <span class="token class-name">AsyncZip</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> infile<span class="token punctuation">,</span> outfile<span class="token punctuation">)</span><span class="token punctuation">:</span>
        threading<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>infile <span class="token operator">=</span> infile
        self<span class="token punctuation">.</span>outfile <span class="token operator">=</span> outfile
    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        f <span class="token operator">=</span> zipfile<span class="token punctuation">.</span>ZipFile<span class="token punctuation">(</span>self<span class="token punctuation">.</span>outfile<span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> zipfile<span class="token punctuation">.</span>ZIP_DEFLATED<span class="token punctuation">)</span>
        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>self<span class="token punctuation">.</span>infile<span class="token punctuation">)</span>
        f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Finished background zip of:'</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>infile<span class="token punctuation">)</span>
background <span class="token operator">=</span> AsyncZip<span class="token punctuation">(</span><span class="token string">'mydata.txt'</span><span class="token punctuation">,</span> <span class="token string">'myarchive.zip'</span><span class="token punctuation">)</span>
background<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'The main program continues to run in foreground.'</span><span class="token punctuation">)</span>
background<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Wait for the background task to finish</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Main program waited until background was done.'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>多线程应用面临的主要挑战是，相互协调的多个线程之间需要共享数据或其他资源。为此，threading 模块提供了多个同步操作原语，包括线程锁、事件、条件变量和信号量。</p>
<p>尽管这些工具非常强大，但微小的设计错误却可以导致一些难以复现的问题。因此，实现多任务协作的首选方法是将所有对资源的请求集中到一个线程中，然后使用 <code>queue</code> 模块向该线程供应来自其他线程的请求。 应用程序使用 <code>Queue</code> 对象进行线程间通信和协调，更易于设计，更易读，更可靠。</p>
<h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p><code>logging</code> 模块提供功能齐全且灵活的日志记录系统。在最简单的情况下，日志消息被发送到文件或 <code>sys.stderr</code></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> logging
logging<span class="token punctuation">.</span>debug<span class="token punctuation">(</span><span class="token string">'Debugging information'</span><span class="token punctuation">)</span>
logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'Informational message'</span><span class="token punctuation">)</span>
logging<span class="token punctuation">.</span>warning<span class="token punctuation">(</span><span class="token string">'Warning:config file %s not found'</span><span class="token punctuation">,</span> <span class="token string">'server.conf'</span><span class="token punctuation">)</span>
logging<span class="token punctuation">.</span>error<span class="token punctuation">(</span><span class="token string">'Error occurred'</span><span class="token punctuation">)</span>
logging<span class="token punctuation">.</span>critical<span class="token punctuation">(</span><span class="token string">'Critical error -- shutting down'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这会产生以下输出:</p>
<pre><code>WARNING:root:Warning:config file server.conf not found
ERROR:root:Error occurred
CRITICAL:root:Critical error -- shutting down</code></pre><p>默认情况下，informational 和 debugging 消息被压制，输出会发送到标准错误流。其他输出选项包括将消息转发到电子邮件，数据报，套接字或 HTTP 服务器。新的过滤器可以根据消息优先级选择不同的路由方式：<code>DEBUG</code>，<code>INFO</code>，<code>WARNING</code>，<code>ERROR</code>，和 <code>CRITICAL</code>。</p>
<p>日志系统可以直接从 Python 配置，也可以从用户配置文件加载，以便自定义日志记录而无需更改应用程序。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>Python 会自动进行内存管理（对大多数对象进行引用计数并使用 garbage collection 来清除循环引用）。 当某个对象的最后一个引用被移除后不久就会释放其所占用的内存。</p>
<p>此方式对大多数应用来说都适用，但偶尔也必须在对象持续被其他对象所使用时跟踪它们。 不幸的是，跟踪它们将创建一个会令其永久化的引用。 <code>weakref</code> 模块提供的工具可以不必创建引用就能跟踪对象。 当对象不再需要时，它将自动从一个弱引用表中被移除，并为弱引用对象触发一个回调。 典型应用包括对创建开销较大的对象进行缓存:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> weakref<span class="token punctuation">,</span> gc
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>value <span class="token operator">=</span> value
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>                   <span class="token comment" spellcheck="true"># create a reference</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> weakref<span class="token punctuation">.</span>WeakValueDictionary<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'primary'</span><span class="token punctuation">]</span> <span class="token operator">=</span> a            <span class="token comment" spellcheck="true"># does not create a reference</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'primary'</span><span class="token punctuation">]</span>                <span class="token comment" spellcheck="true"># fetch the object if it is still alive</span>
<span class="token number">10</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> a                       <span class="token comment" spellcheck="true"># remove the one reference</span>
<span class="token operator">>></span><span class="token operator">></span> gc<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># run garbage collection right away</span>
<span class="token number">0</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">'primary'</span><span class="token punctuation">]</span>                <span class="token comment" spellcheck="true"># entry was automatically removed</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
    d<span class="token punctuation">[</span><span class="token string">'primary'</span><span class="token punctuation">]</span>                <span class="token comment" spellcheck="true"># entry was automatically removed</span>
  File <span class="token string">"C:/python310/lib/weakref.py"</span><span class="token punctuation">,</span> line <span class="token number">46</span><span class="token punctuation">,</span> <span class="token keyword">in</span> __getitem__
    o <span class="token operator">=</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
KeyError<span class="token punctuation">:</span> <span class="token string">'primary'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="用于操作列表的工具"><a href="#用于操作列表的工具" class="headerlink" title="用于操作列表的工具"></a>用于操作列表的工具</h3><p>许多对于数据结构的需求可以通过内置列表类型来满足。 但是，有时也会需要具有不同效费比的替代实现。</p>
<p><code>array</code> 模块提供了一种 <code>array()</code> 对象，它类似于列表，但只能存储类型一致的数据且存储密集更高。 下面的例子演示了一个以两个字节为存储单元的无符号二进制数值的数组 (类型码为 <code>"H"</code>)，而对于普通列表来说，每个条目存储为标准 Python 的 int 对象通常要占用16 个字节:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> array <span class="token keyword">import</span> array
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> array<span class="token punctuation">(</span><span class="token string">'H'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">700</span><span class="token punctuation">,</span> <span class="token number">22222</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> sum<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token number">26932</span>
<span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>
array<span class="token punctuation">(</span><span class="token string">'H'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">700</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>collections</code> 模块提供了一种 <code>deque()</code> 对象，它类似于列表，但从左端添加和弹出的速度较快，而在中间查找的速度较慢。 此种对象适用于实现队列和广度优先树搜索:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"task1"</span><span class="token punctuation">,</span> <span class="token string">"task2"</span><span class="token punctuation">,</span> <span class="token string">"task3"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"task4"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Handling"</span><span class="token punctuation">,</span> d<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Handling task1

unsearched <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>starting_node<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">breadth_first_search</span><span class="token punctuation">(</span>unsearched<span class="token punctuation">)</span><span class="token punctuation">:</span>
    node <span class="token operator">=</span> unsearched<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> m <span class="token keyword">in</span> gen_moves<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> is_goal<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> m
        unsearched<span class="token punctuation">.</span>append<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在替代的列表实现以外，标准库也提供了其他工具，例如 <code>bisect</code> 模块具有用于操作有序列表的函数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> bisect
<span class="token operator">>></span><span class="token operator">></span> scores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">'perl'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token string">'tcl'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">'lua'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">'python'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> bisect<span class="token punctuation">.</span>insort<span class="token punctuation">(</span>scores<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> <span class="token string">'ruby'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> scores
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">'perl'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token string">'tcl'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> <span class="token string">'ruby'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">'lua'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">'python'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>heapq</code> 模块提供了基于常规列表来实现堆的函数。 最小值的条目总是保持在位置零。 这对于需要重复访问最小元素而不希望运行完整列表排序的应用来说非常有用:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> heapq <span class="token keyword">import</span> heapify<span class="token punctuation">,</span> heappop<span class="token punctuation">,</span> heappush
<span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> heapify<span class="token punctuation">(</span>data<span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true"># rearrange the list into heap order</span>
<span class="token operator">>></span><span class="token operator">></span> heappush<span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true"># add a new entry</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>heappop<span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># fetch the three smallest entries</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="十进制浮点运算"><a href="#十进制浮点运算" class="headerlink" title="十进制浮点运算"></a>十进制浮点运算</h3><p><code>decimal</code> 模块提供了一种 <code>Decimal</code> 数据类型用于十进制浮点运算。 相比内置的 <code>float</code> 二进制浮点实现，该类特别适用于</p>
<ul>
<li>财务应用和其他需要精确十进制表示的用途，</li>
<li>控制精度，</li>
<li>控制四舍五入以满足法律或监管要求，</li>
<li>跟踪有效小数位，或</li>
<li>用户期望结果与手工完成的计算相匹配的应用程序。</li>
</ul>
<p>例如，使用十进制浮点和二进制浮点数计算70美分手机和5％税的总费用，会产生的不同结果。如果结果四舍五入到最接近的分数差异会更大:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> decimal <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span> round<span class="token punctuation">(</span>Decimal<span class="token punctuation">(</span><span class="token string">'0.70'</span><span class="token punctuation">)</span> <span class="token operator">*</span> Decimal<span class="token punctuation">(</span><span class="token string">'1.05'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.74'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> round<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token number">70</span> <span class="token operator">*</span> <span class="token number">1.05</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token number">0.73</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Decimal</code> 表示的结果会保留尾部的零，并根据具有两个有效位的被乘数自动推出四个有效位。 Decimal 可以模拟手工运算来避免当二进制浮点数无法精确表示十进制数时会导致的问题。</p>
<p>精确表示特性使得 <code>Decimal</code> 类能够执行对于二进制浮点数来说不适用的模运算和相等性检测:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token string">'1.00'</span><span class="token punctuation">)</span> <span class="token operator">%</span> Decimal<span class="token punctuation">(</span><span class="token string">'.10'</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.00'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token number">1.00</span> <span class="token operator">%</span> <span class="token number">0.10</span>
<span class="token number">0.09999999999999995</span>
<span class="token operator">>></span><span class="token operator">></span> sum<span class="token punctuation">(</span><span class="token punctuation">[</span>Decimal<span class="token punctuation">(</span><span class="token string">'0.1'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">==</span> Decimal<span class="token punctuation">(</span><span class="token string">'1.0'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> sum<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1.0</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>decimal</code> 模块提供了运算所需要的足够精度:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> getcontext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prec <span class="token operator">=</span> <span class="token number">36</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> Decimal<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.142857142857142857142857142857142857'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="10-虚拟环境和包"><a href="#10-虚拟环境和包" class="headerlink" title="10. 虚拟环境和包"></a>10. 虚拟环境和包</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Python应用程序通常会使用不在标准库内的软件包和模块。应用程序有时需要特定版本的库，因为应用程序可能需要修复特定的错误，或者可以使用库的过时版本的接口编写应用程序。</p>
<p>这意味着一个Python安装可能无法满足每个应用程序的要求。如果应用程序A需要特定模块的1.0版本但应用程序B需要2.0版本，则需求存在冲突，安装版本1.0或2.0将导致某一个应用程序无法运行。</p>
<p>这个问题的解决方案是创建一个 virtual environment，一个目录树，其中安装有特定Python版本，以及许多其他包。</p>
<p>然后，不同的应用将可以使用不同的虚拟环境。 要解决先前需求相冲突的例子，应用程序 A 可以拥有自己的 安装了 1.0 版本的虚拟环境，而应用程序 B 则拥有安装了 2.0 版本的另一个虚拟环境。 如果应用程序 B 要求将某个库升级到 3.0 版本，也不会影响应用程序 A 的环境。</p>
<h3 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h3><p>用于创建和管理虚拟环境的模块称为 <code>venv</code>。<code>venv</code> 通常会安装你可用的最新版本的 Python。如果您的系统上有多个版本的 Python，您可以通过运行 <code>python3</code> 或您想要的任何版本来选择特定的Python版本。</p>
<p>要创建虚拟环境，请确定要放置它的目录，并将 <code>venv</code> 模块作为脚本运行目录路径:</p>
<pre><code>python3 -m venv tutorial-env</code></pre><p>这将创建 <code>tutorial-env</code> 目录，如果它不存在的话，并在其中创建包含 Python 解释器副本和各种支持文件的目录。</p>
<p>虚拟环境的常用目录位置是 <code>.venv</code>。 这个名称通常会令该目录在你的终端中保持隐藏，从而避免需要对所在目录进行额外解释的一般名称。 它还能防止与某些工具所支持的 <code>.env</code> 环境变量定义文件发生冲突。</p>
<p>创建虚拟环境后，您可以激活它。</p>
<p>在Windows上，运行:</p>
<pre><code>tutorial-env\Scripts\activate.bat</code></pre><p>在Unix或MacOS上，运行:</p>
<pre><code>source tutorial-env/bin/activate</code></pre><p>（这个脚本是为bash shell编写的。如果你使用 <strong>csh</strong> 或 <strong>fish</strong> shell，你应该改用 <code>activate.csh</code> 或 <code>activate.fish</code> 脚本。）</p>
<p>激活虚拟环境将改变你所用终端的提示符，以显示你正在使用的虚拟环境，并修改环境以使 <code>python</code> 命令所运行的将是已安装的特定 Python 版本。 例如：</p>
<pre><code>$ source ~/envs/tutorial-env/bin/activate
(tutorial-env) $ python
Python 3.5.1 (default, May  6 2016, 10:59:36)
  ...
&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['', '/usr/local/lib/python35.zip', ...,
'~/envs/tutorial-env/lib/python3.5/site-packages']
&gt;&gt;&gt;</code></pre><h3 id="使用pip管理包"><a href="#使用pip管理包" class="headerlink" title="使用pip管理包"></a>使用pip管理包</h3><p>你可以使用一个名为 <strong>pip</strong> 的程序来安装、升级和移除软件包。 默认情况下 <code>pip</code> 将从 Python Package Index <a href="https://pypi.org/" target="_blank" rel="noopener">https://pypi.org</a>安装软件包。 你可以在你的 web 浏览器中查看 Python Package Index。</p>
<p><code>pip</code> 有许多子命令: “install”, “uninstall”, “freeze” 等等。 </p>
<p>您可以通过指定包的名称来安装最新版本的包：</p>
<pre><code>(tutorial-env) $ python -m pip install novas
Collecting novas
  Downloading novas-3.1.1.3.tar.gz (136kB)
Installing collected packages: novas
  Running setup.py install for novas
Successfully installed novas-3.1.1.3</code></pre><p>您还可以通过提供包名称后跟 <code>==</code> 和版本号来安装特定版本的包：</p>
<pre><code>(tutorial-env) $ python -m pip install requests==2.6.0
Collecting requests==2.6.0
  Using cached requests-2.6.0-py2.py3-none-any.whl
Installing collected packages: requests
Successfully installed requests-2.6.0</code></pre><p>如果你重新运行这个命令，<code>pip</code> 会注意到已经安装了所请求的版本并且什么都不做。您可以提供不同的版本号来获取该版本，或者您可以运行 <code>pip install --upgrade</code> 将软件包升级到最新版本：</p>
<pre><code>(tutorial-env) $ python -m pip install --upgrade requests
Collecting requests
Installing collected packages: requests
  Found existing installation: requests 2.6.0
    Uninstalling requests-2.6.0:
      Successfully uninstalled requests-2.6.0
Successfully installed requests-2.7.0</code></pre><p><code>pip uninstall</code> 后跟一个或多个包名称将从虚拟环境中删除包。</p>
<p><code>pip show</code> 将显示有关特定包的信息：</p>
<pre><code>(tutorial-env) $ pip show requests
---
Metadata-Version: 2.0
Name: requests
Version: 2.7.0
Summary: Python HTTP for Humans.
Home-page: http://python-requests.org
Author: Kenneth Reitz
Author-email: me@kennethreitz.com
License: Apache 2.0
Location: /Users/akuchling/envs/tutorial-env/lib/python3.4/site-packages
Requires:</code></pre><p><code>pip list</code> 将显示虚拟环境中安装的所有软件包：</p>
<pre><code>(tutorial-env) $ pip list
novas (3.1.1.3)
numpy (1.9.2)
pip (7.0.3)
requests (2.7.0)
setuptools (16.0)</code></pre><p><code>pip freeze</code> 将生成一个类似的已安装包列表，但输出使用 <code>pip install</code> 期望的格式。一个常见的约定是将此列表放在 <code>requirements.txt</code> 文件中：</p>
<pre><code>(tutorial-env) $ pip freeze &gt; requirements.txt
(tutorial-env) $ cat requirements.txt
novas==3.1.1.3
numpy==1.9.2
requests==2.7.0</code></pre><p>然后可以将 <code>requirements.txt</code> 提交给版本控制并作为应用程序的一部分提供。然后用户可以使用 <code>install -r</code> 安装所有必需的包：</p>
<pre><code>(tutorial-env) $ python -m pip install -r requirements.txt
Collecting novas==3.1.1.3 (from -r requirements.txt (line 1))
  ...
Collecting numpy==1.9.2 (from -r requirements.txt (line 2))
  ...
Collecting requests==2.7.0 (from -r requirements.txt (line 3))
  ...
Installing collected packages: novas, numpy, requests
  Running setup.py install for novas
Successfully installed novas-3.1.1.3 numpy-1.9.2 requests-2.7.0</code></pre><h2 id="11-交互式编辑和编辑历史"><a href="#11-交互式编辑和编辑历史" class="headerlink" title="11. 交互式编辑和编辑历史"></a>11. 交互式编辑和编辑历史</h2><p>某些版本的 Python 解释器支持编辑当前输入行和编辑历史记录，类似 Korn shell 和 GNU Bash shell 的功能 。这个功能使用了 <a href="https://tiswww.case.edu/php/chet/readline/rltop.html" target="_blank" rel="noopener">GNU Readline</a> 来实现，一个支持多种编辑方式的库。这个库有它自己的文档，在这里我们就不重复说明了。</p>
<h3 id="Tab-补全和编辑历史"><a href="#Tab-补全和编辑历史" class="headerlink" title="Tab 补全和编辑历史"></a>Tab 补全和编辑历史</h3><p>在解释器启动的时候，补全变量和模块名的功能将 自动打开，以便在按下 Tab 键的时候调用补全函数。它会查看 Python 语句名称，当前局部变量和可用的模块名称。处理像 <code>string.a</code> 的表达式，它会求值在最后一个 <code>'.'</code> 之前的表达式，接着根据求值结果对象的属性给出补全建议。如果拥有 <code>__getattr__()</code> 方法的对象是表达式的一部分，注意这可能会执行程序定义的代码。默认配置下会把编辑历史记录保存在用户目录下名为 <code>.python_history</code> 的文件。在下一次 Python 解释器会话期间，编辑历史记录仍旧可用。</p>
<h3 id="默认交互式解释器的替代品"><a href="#默认交互式解释器的替代品" class="headerlink" title="默认交互式解释器的替代品"></a>默认交互式解释器的替代品</h3><p>Python 解释器与早期版本的相比，向前迈进了一大步；无论怎样，还有些希望的功能：如果能在编辑连续行时建议缩进（解析器知道接下来是否需要缩进符号），那将很棒。补全机制可以使用解释器的符号表。有命令去检查（甚至建议）括号，引号以及其他符号是否匹配。</p>
<p>一个可选的增强型交互式解释器是 <a href="https://ipython.org/" target="_blank" rel="noopener">IPython</a>，它已经存在了有一段时间，它具有 tab 补全，探索对象和高级历史记录管理功能。它还可以彻底定制并嵌入到其他应用程序中。另一个相似的增强型交互式环境是 <a href="https://www.bpython-interpreter.org/" target="_blank" rel="noopener">bpython</a>。</p>
<h2 id="12-浮点算术：争议和限制"><a href="#12-浮点算术：争议和限制" class="headerlink" title="12. 浮点算术：争议和限制"></a>12. 浮点算术：争议和限制</h2><p>浮点数在计算机硬件中表示为以 2 为基数（二进制）的小数。举例而言，十进制的小数</p>
<pre><code>0.125</code></pre><p>等于 1/10 + 2/100 + 5/1000 ，同理，二进制的小数</p>
<pre><code>0.001</code></pre><p>等于0/2 + 0/4 + 1/8。这两个小数具有相同的值，唯一真正的区别是第一个是以 10 为基数的小数表示法，第二个则是 2 为基数。</p>
<p>不幸的是，大多数的十进制小数都不能精确地表示为二进制小数。这导致在大多数情况下，你输入的十进制浮点数都只能近似地以二进制浮点数形式储存在计算机中。</p>
<p>用十进制来理解这个问题显得更加容易一些。考虑分数 1/3 。我们可以得到它在十进制下的一个近似值</p>
<pre><code>0.3</code></pre><p>或者，更近似的，:</p>
<pre><code>0.33</code></pre><p>或者，更近似的，:</p>
<pre><code>0.333</code></pre><p>以此类推。结果是无论你写下多少的数字，它都永远不会等于 1/3 ，只是更加更加地接近 1/3 。</p>
<p>同样的道理，无论你使用多少位以 2 为基数的数码，十进制的 0.1 都无法精确地表示为一个以 2 为基数的小数。 在以 2 为基数的情况下， 1/10 是一个无限循环小数</p>
<pre><code>0.0001100110011001100110011001100110011001100110011...</code></pre><p>在任何一个位置停下，你都只能得到一个近似值。因此，在今天的大部分架构上，浮点数都只能近似地使用二进制小数表示，对应分数的分子使用每 8 字节的前 53 位表示，分母则表示为 2 的幂次。在 1/10 这个例子中，相应的二进制分数是 <code>3602879701896397 / 2 ** 55</code> ，它很接近 1/10 ，但并不是 1/10 。</p>
<p>大部分用户都不会意识到这个差异的存在，因为 Python 只会打印计算机中存储的二进制值的十进制近似值。在大部分计算机中，如果 Python 想把 0.1 的二进制对应的精确十进制打印出来，将会变成这样</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token number">0.1</span>
<span class="token number">0.1000000000000000055511151231257827021181583404541015625</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这比大多数人认为有用的数字更多，因此Python通过显示舍入值来保持可管理的位数</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token number">10</span>
<span class="token number">0.1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>牢记，即使输出的结果看起来好像就是 1/10 的精确值，实际储存的值只是最接近 1/10 的计算机可表示的二进制分数。</p>
<p>有趣的是，有许多不同的十进制数共享相同的最接近的近似二进制小数。例如， <code>0.1</code> 、 <code>0.10000000000000001</code> 、 <code>0.1000000000000000055511151231257827021181583404541015625</code> 全都近似于 <code>3602879701896397 / 2 ** 55</code> 。由于所有这些十进制值都具有相同的近似值，因此可以显示其中任何一个，同时仍然保留不变的 <code>eval(repr(x)) == x</code> 。</p>
<p>在历史上，Python 提示符和内置的 <code>repr()</code> 函数会选择具有 17 位有效数字的来显示，即 <code>0.10000000000000001</code>。 从 Python 3.1 开始，Python（在大多数系统上）现在能够选择这些表示中最短的并简单地显示 <code>0.1</code> 。</p>
<p>请注意这种情况是二进制浮点数的本质特性：它不是 Python 的错误，也不是你代码中的错误。 你会在所有支持你的硬件中的浮点运算的语言中发现同样的情况（虽然某些语言在默认状态或所有输出模块下都不会 <em>显示</em> 这种差异）。</p>
<p>想要更美观的输出，你可能会希望使用字符串格式化来产生限定长度的有效位数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> format<span class="token punctuation">(</span>math<span class="token punctuation">.</span>pi<span class="token punctuation">,</span> <span class="token string">'.12g'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># give 12 significant digits</span>
<span class="token string">'3.14159265359'</span>
<span class="token operator">>></span><span class="token operator">></span> format<span class="token punctuation">(</span>math<span class="token punctuation">.</span>pi<span class="token punctuation">,</span> <span class="token string">'.2f'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># give 2 digits after the point</span>
<span class="token string">'3.14'</span>
<span class="token operator">>></span><span class="token operator">></span> repr<span class="token punctuation">(</span>math<span class="token punctuation">.</span>pi<span class="token punctuation">)</span>
<span class="token string">'3.141592653589793'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>必须重点了解的是，这在实际上只是一个假象：你只是将真正的机器码值进行了舍入操作再 <em>显示</em> 而已。</p>
<p>一个假象还可能导致另一个假象。 例如，由于这个 0.1 并非真正的 1/10，将三个 0.1 的值相加也不一定能恰好得到 0.3:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">.</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token punctuation">.</span><span class="token number">3</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>而且，由于这个 0.1 无法精确表示 1/10 的值而这个 0.3 也无法精确表示 3/10 的值，使用 <code>round()</code> 函数进行预先舍入也是没用的:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> round<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> round<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> round<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> round<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>虽然这些小数无法精确表示其所要代表的实际值，<code>round()</code> 函数还是可以用来“事后舍入”，使得实际的结果值可以做相互比较:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> round<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">==</span> round<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>二进制浮点运算会造成许多这样的“意外”。 </p>
<p>正如那篇文章的结尾所言，“对此问题并无简单的答案。” 但是也不必过于担心浮点数的问题！ Python 浮点运算中的错误是从浮点运算硬件继承而来，而在大多数机器上每次浮点运算得到的 2**53 数码位都会被作为 1 个整体来处理。 这对大多数任务来说都已足够，但你确实需要记住它并非十进制算术，且每次浮点运算都可能会导致新的舍入错误。</p>
<p>虽然病态的情况确实存在，但对于大多数正常的浮点运算使用来说，你只需简单地将最终显示的结果舍入为你期望的十进制数值即可得到你期望的结果。 <code>str()</code> 通常已足够。</p>
<p>对于需要精确十进制表示的使用场景，请尝试使用 <code>decimal</code> 模块，该模块实现了适合会计应用和高精度应用的十进制运算。</p>
<p>另一种形式的精确运算由 <code>fractions</code> 模块提供支持，该模块实现了基于有理数的算术运算（因此可以精确表示像 1/3 这样的数值）。</p>
<p>如果你是浮点运算的重度用户则你应当了解一下 NumPy 包以及由 SciPy 项目所提供的许多其他数字和统计运算包。 参见 <a href="https://scipy.org/" target="_blank" rel="noopener">https://scipy.org</a>。</p>
<p>Python 也提供了一些工具，可以在你真的 <em>想要</em> 知道一个浮点数精确值的少数情况下提供帮助。 例如 <code>float.as_integer_ratio()</code> 方法会将浮点数表示为一个分数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token number">3.14159</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>as_integer_ratio<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3537115888337719</span><span class="token punctuation">,</span> <span class="token number">1125899906842624</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>由于这是一个精确的比值，它可以被用来无损地重建原始值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">==</span> <span class="token number">3537115888337719</span> <span class="token operator">/</span> <span class="token number">1125899906842624</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>float.hex()</code> 方法会以十六进制（以 16 为基数）来表示浮点数，同样能给出保存在你的计算机中的精确值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'0x1.921f9f01b866ep+1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这种精确的十六进制表示法可被用来精确地重建浮点值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">==</span> float<span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token string">'0x1.921f9f01b866ep+1'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>由于这种表示法是精确的，它适用于跨越不同版本（平台无关）的 Python 移植数值，以及与支持相同格式的其他语言（例如 Java 和 C99）交换数据.</p>
<p>另一个有用的工具是 <code>math.fsum()</code> 函数，它有助于减少求和过程中的精度损失。 它会在数值被添加到总计值的时候跟踪“丢失的位”。 这可以很好地保持总计值的精确度， 使得错误不会积累到能影响结果总数的程度:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sum<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1.0</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> math<span class="token punctuation">.</span>fsum<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1.0</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="表示性错误"><a href="#表示性错误" class="headerlink" title="表示性错误"></a>表示性错误</h3><p>本小节将详细解释 “0.1” 的例子，并说明你可以怎样亲自对此类情况进行精确分析。 假定前提是已基本熟悉二进制浮点表示法。</p>
<p><em>表示性错误</em> 是指某些（其实是大多数）十进制小数无法以二进制（以 2 为基数的计数制）精确表示这一事实造成的错误。 这就是为什么 Python（或者 Perl、C、C++、Java、Fortran 以及许多其他语言）经常不会显示你所期待的精确十进制数值的主要原因。</p>
<p>为什么会这样？ 1/10 是无法用二进制小数精确表示的。 目前（2000年11月）几乎所有使用 IEEE-754 浮点运算标准的机器以及几乎所有系统平台都会将 Python 浮点数映射为 IEEE-754 “双精度类型”。 754 双精度类型包含 53 位精度，因此在输入时，计算会尽量将 0.1 转换为以 <em>J</em>/2<em>**N</em> 形式所能表示的最接近分数，其中 <em>J</em> 为恰好包含 53 个二进制位的整数。 重新将</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token number">1</span> <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">~</span><span class="token operator">=</span> J <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span>N<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>写为</p>
<pre class="line-numbers language-python"><code class="language-python">J <span class="token operator">~</span><span class="token operator">=</span> <span class="token number">2</span><span class="token operator">**</span>N <span class="token operator">/</span> <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>并且由于 <em>J</em> 恰好有 53 位 (即 <code>&gt;= 2**52</code> 但 <code>&lt; 2**53</code>)，<em>N</em> 的最佳值为 56:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">52</span> <span class="token operator">&lt;=</span>  <span class="token number">2</span><span class="token operator">**</span><span class="token number">56</span> <span class="token operator">//</span> <span class="token number">10</span>  <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token operator">**</span><span class="token number">53</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>也就是说，56 是唯一的 <em>N</em> 值能令 <em>J</em> 恰好有 53 位。 这样 <em>J</em> 的最佳可能值就是经过舍入的商:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">,</span> r <span class="token operator">=</span> divmod<span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span><span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> r
<span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>由于余数超过 10 的一半，最佳近似值可通过四舍五入获得:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> q<span class="token operator">+</span><span class="token number">1</span>
<span class="token number">7205759403792794</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这样在 754 双精度下 1/10 的最佳近似值为:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token number">7205759403792794</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">56</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>分子和分母都除以二则结果小数为:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token number">3602879701896397</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">55</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>请注意由于我们做了向上舍入，这个结果实际上略大于 1/10；如果我们没有向上舍入，则商将会略小于 1/10。 但无论如何它都不会是 <em>精确的</em> 1/10！</p>
<p>因此计算永远不会“看到”1/10：它实际看到的就是上面所给出的小数，它所能达到的最佳 754 双精度近似值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token number">0.1</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">55</span>
<span class="token number">3602879701896397.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果我们将该小数乘以 10**55，我们可以看到该值输出为 55 位的十进制数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token number">3602879701896397</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">**</span> <span class="token number">55</span> <span class="token operator">//</span> <span class="token number">2</span> <span class="token operator">**</span> <span class="token number">55</span>
<span class="token number">1000000000000000055511151231257827021181583404541015625</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这意味着存储在计算机中的确切数值等于十进制数值 0.1000000000000000055511151231257827021181583404541015625。 许多语言（包括较旧版本的 Python）都不会显示这个完整的十进制数值，而是将结果舍入为 17 位有效数字:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> format<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token string">'.17f'</span><span class="token punctuation">)</span>
<span class="token string">'0.10000000000000001'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>fractions</code> 和 <code>decimal</code> 模块可令进行此类计算更加容易:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> decimal <span class="token keyword">import</span> Decimal
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> fractions <span class="token keyword">import</span> Fraction
<span class="token operator">>></span><span class="token operator">></span> Fraction<span class="token punctuation">.</span>from_float<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>
Fraction<span class="token punctuation">(</span><span class="token number">3602879701896397</span><span class="token punctuation">,</span> <span class="token number">36028797018963968</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>as_integer_ratio<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3602879701896397</span><span class="token punctuation">,</span> <span class="token number">36028797018963968</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Decimal<span class="token punctuation">.</span>from_float<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span>
Decimal<span class="token punctuation">(</span><span class="token string">'0.1000000000000000055511151231257827021181583404541015625'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> format<span class="token punctuation">(</span>Decimal<span class="token punctuation">.</span>from_float<span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'.17'</span><span class="token punctuation">)</span>
<span class="token string">'0.10000000000000001'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="13-交互模式"><a href="#13-交互模式" class="headerlink" title="13. 交互模式"></a>13. 交互模式</h2><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>当发生错误时，解释器会打印错误信息和错误堆栈。在交互模式下，将返回到主命令提示符；如果输入内容来自文件，在打印错误堆栈之后，程序会以非零状态退出。（这里所说的错误不包括 <code>try</code> 语句中由 <code>except</code> 所捕获的异常。）有些错误是无条件致命的，会导致程序以非零状态退出；比如内部逻辑矛盾或内存耗尽。所有错误信息都会被写入标准错误流；而命令的正常输出则被写入标准输出流。</p>
<p>将中断字符（通常为 Control-C 或 Delete ）键入主要或辅助提示会取消输入并返回主提示符。 在执行命令时键入中断引发的 <code>KeyboardInterrupt</code> 异常，可以由 <code>try</code> 语句处理。</p>
<h3 id="可执行的Python脚本"><a href="#可执行的Python脚本" class="headerlink" title="可执行的Python脚本"></a>可执行的Python脚本</h3><p>在BSD等类Unix系统上，Python脚本可以直接执行，就像shell脚本一样，第一行添加:</p>
<pre><code>#!/usr/bin/env python3.5</code></pre><p>（假设解释器位于用户的 <code>PATH</code> ）脚本的开头，并将文件设置为可执行。 <code>#!</code> 必须是文件的前两个字符。在某些平台上，第一行必须以Unix样式的行结尾（<code>'\n'</code>）结束，而不是以Windows（<code>'\r\n'</code>）行结尾。请注意，散列或磅字符 <code>'#'</code> 在Python中代表注释开始。</p>
<p>可以使用 <strong>chmod</strong> 命令为脚本提供可执行模式或权限。</p>
<pre><code>$ chmod +x myscript.py</code></pre><p>在Windows系统上，没有“可执行模式”的概念。 Python安装程序自动将 <code>.py</code> 文件与 <code>python.exe</code> 相关联，这样双击Python文件就会将其作为脚本运行。扩展也可以是 <code>.pyw</code> ，在这种情况下，会隐藏通常出现的控制台窗口。</p>
<h3 id="交互式启动文件"><a href="#交互式启动文件" class="headerlink" title="交互式启动文件"></a>交互式启动文件</h3><p>当您以交互方式使用Python时，每次启动解释器时都会执行一些标准命令，这通常很方便。您可以通过将名为 <code>PYTHONSTARTUP</code> 的环境变量设置为包含启动命令的文件名来实现。这类似于Unix shell的 <code>.profile</code> 功能。</p>
<p>此文件只会在交互式会话时读取，而非在 Python 从脚本读取指令或是在给定 <code>/dev/tty</code> 为指令的明确来源时（后者反而表现得像是一个交互式会话）。 该文件执行时所在的命名空间与交互式指令相同，所以它定义或导入的对象可以在交互式会话中直接使用。 你也可以在该文件中更改提示符 <code>sys.ps1</code> 和 <code>sys.ps2</code>。</p>
<p>如果你想从当前目录中读取一个额外的启动文件，你可以使用像 <code>if os.path.isfile('.pythonrc.py'): exec(open('.pythonrc.py').read())</code> 这样的代码在全局启动文件中对它进行编程。如果要在脚本中使用启动文件，则必须在脚本中显式执行此操作:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os
filename <span class="token operator">=</span> os<span class="token punctuation">.</span>environ<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'PYTHONSTARTUP'</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> filename <span class="token operator">and</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isfile<span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> open<span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token keyword">as</span> fobj<span class="token punctuation">:</span>
        startup_file <span class="token operator">=</span> fobj<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">exec</span><span class="token punctuation">(</span>startup_file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="定制模块"><a href="#定制模块" class="headerlink" title="定制模块"></a>定制模块</h3><p>Python提供了两个钩子来让你自定义它：<code>sitecustomize</code> 和 <code>usercustomize</code>。要查看其工作原理，首先需要找到用户site-packages目录的位置。启动Python并运行此代码:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> site
<span class="token operator">>></span><span class="token operator">></span> site<span class="token punctuation">.</span>getusersitepackages<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'/home/user/.local/lib/python3.5/site-packages'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>现在，您可以在该目录中创建一个名为 <code>usercustomize.py</code> 的文件，并将所需内容放入其中。它会影响Python的每次启动，除非它以 <code>-s</code> 选项启动，以禁用自动导入。</p>
<p><code>sitecustomize</code> 以相同的方式工作，但通常由计算机管理员在全局 site-packages 目录中创建，并在 <code>usercustomize</code> 之前被导入。</p>
<h1 id="Python-语言参考手册"><a href="#Python-语言参考手册" class="headerlink" title="Python 语言参考手册"></a>Python 语言参考手册</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>我希望尽可能地保证内容精确无误，但还是选择使用自然词句进行描述，正式的规格定义仅用于句法和词法解析。这样应该能使文档对于普通人来说更易理解，但也可能导致一些歧义。因此，如果你是来自火星并且想凭借这份文档把 Python 重新实现一遍，也许有时需要自行猜测，实际上最终大概会得到一个十分不同的语言。而在另一方面，如果你正在使用 Python 并且想了解有关该语言特定领域的精确规则，你应该能够在这里找到它们。如果你希望查看对该语言更正式的定义，也许你可以花些时间自己写上一份 —- 或者发明一台克隆机器 :-)</p>
<p>在语言参考文档里加入过多的实现细节是很危险的 —- 具体实现可能发生改变，对同一语言的其他实现可能使用不同的方式。而在另一方面，CPython 是得到广泛使用的 Python 实现 (然而其他一些实现的拥护者也在增加)，其中的特殊细节有时也值得一提，特别是当其实现方式导致额外的限制时。因此，你会发现在正文里不时会跳出来一些简短的 “实现注释”。</p>
<p>每种 Python 实现都带有一些内置和标准的模块。少数内置模块也会在此提及，如果它们同语言描述存在明显的关联。</p>
<h3 id="1-1-其他实现"><a href="#1-1-其他实现" class="headerlink" title="1.1. 其他实现"></a>1.1. 其他实现</h3><p>虽然官方 Python 实现差不多得到最广泛的欢迎，但也有一些其他实现对特定领域的用户来说更具吸引力。</p>
<p>知名的实现包括:</p>
<p>CPython</p>
<p>这是最早出现并持续维护的 Python 实现，以 C 语言编写。新的语言特性通常在此率先添加。</p>
<p>Jython</p>
<p>以 Java 语言编写的 Python 实现。此实现可以作为 Java 应用的一个脚本语言，或者可以用来创建需要 Java 类库支持的应用。想了解更多信息可访问 <a href="http://www.jython.org/" target="_blank" rel="noopener">Jython 网站</a>。</p>
<p>Python for .NET</p>
<p>此实现实际上使用了 CPython 实现，但是属于 .NET 托管应用并且可以引入 .NET 类库。它的创造者是 Brian Lloyd。想了解详情可访问 <a href="https://pythonnet.github.io/" target="_blank" rel="noopener">Python for .NET 主页</a>。</p>
<p>IronPython</p>
<p>另一个 .NET 的 Python 实现，与 Python.NET 不同点在于它是生成 IL 的完全 Python 实现，并且将 Python 代码直接编译为 .NET 程序集。它的创造者就是当初创造 Jython 的 Jim Hugunin。想了解详情可访问 <a href="http://ironpython.net/" target="_blank" rel="noopener">IronPython 网站</a>。</p>
<p>PyPy</p>
<p>完全使用 Python 语言编写的 Python 实现。它支持多个其他实现所没有的高级特性，例如非栈式支持和 JIT 编译器等。此项目的目标之一是通过允许方便地修改解释器 (因为它是用 Python 编写的)，鼓励该对语言本身进行试验。想了解详情可访问 <a href="http://pypy.org/" target="_blank" rel="noopener">PyPy 项目主页</a>。</p>
<p>以上这些实现都可能在某些方面与此参考文档手册的描述有所差异，或是引入了超出标准 Python 文档范围的特定信息。请参考它们各自的专门文档，以确定你正在使用的这个实现有哪些你需要了解的东西。</p>
<h3 id="1-2-标注"><a href="#1-2-标注" class="headerlink" title="1.2. 标注"></a>1.2. 标注</h3><p>句法和词法解析的描述采用经过改进的 BNF 语法标注。这包含以下定义样式:</p>
<pre><code>name      ::=  lc_letter (lc_letter | "_")*
lc_letter ::=  "a"..."z"</code></pre><p>第一行表示 <code>name</code> 是 <code>lc_letter</code> 之后跟零个或多个 <code>lc_letter</code> 和下划线。而 <code>lc_letter</code> 则是任意单个 <code>'a'</code> 至 <code>'z'</code> 字符。(实际上在本文档中始终采用此规则来定义词法和语法规则的名称。)</p>
<p>每条规则的开头是一个名称 (即该规则所定义的名称) 加上 <code>::=</code>。 竖线 (<code>|</code>) 被用来分隔可选项，它是此标注中绑定程度最低的操作符。 星号 (<code>*</code>) 表示前一项的零次或多次重复，类似地，加号 (<code>+</code>) 表示一次或多次重复，而由方括号括起的内容 (<code>[ ]</code>) 表示出现零次或一次 (或者说，这部分内容是可选的)。 <code>*</code> 和 <code>+</code> 操作符的绑定是最紧密的，圆括号用于分组。 字符串字面值包含在引号内。 空格的作用仅限于分隔形符。 每条规则通常为一行，有许多个可选项的规则可能会以竖线为界分为多行。</p>
<p>在词法定义中 (如上述示例)，还额外使用了两个约定: 由三个点号分隔的两个字符字面值表示在指定 (闭) 区间范围内的任意单个 ASCII 字符。由尖括号 (<code>&lt;...&gt;</code>) 括起来的内容是对于所定义符号的非正式描述；即可以在必要时用来说明 ‘控制字符’ 的意图。</p>
<p>虽然所用的标注方式几乎相同，但是词法定义和句法定义是存在很大区别的: 词法定义作用于输入源中单独的字符，而句法定义则作用于由词法分析所生成的形符流。在下一章节 (“词法分析”) 中使用的 BNF 全部都是词法定义；在之后的章节中使用的则是句法定义。</p>
<h2 id="2-词法分析"><a href="#2-词法分析" class="headerlink" title="2. 词法分析"></a>2. 词法分析</h2><p>Python 程序由 <em>解析器</em> 读取，输入解析器的是 <em>词法分析器</em> 生成的 <em>形符</em> 流。本章介绍词法分析器怎样把文件拆成形符。</p>
<p>Python 将读取的程序文本转为 Unicode 代码点；编码声明用于指定源文件的编码，默认为 UTF-8，详见 <a href="https://www.python.org/dev/peps/pep-3120" target="_blank" rel="noopener"><strong>PEP 3120</strong></a>。源文件不能解码时，触发 <code>SyntaxError</code>。</p>
<h3 id="2-1-行结构"><a href="#2-1-行结构" class="headerlink" title="2.1. 行结构"></a>2.1. 行结构</h3><p>Python 程序可以拆分为多个 <em>逻辑行</em>。</p>
<h4 id="2-1-1-逻辑行"><a href="#2-1-1-逻辑行" class="headerlink" title="2.1.1. 逻辑行"></a>2.1.1. 逻辑行</h4><p>NEWLINE 形符表示结束逻辑行。语句不能超出逻辑行的边界，除非句法支持 NEWLINE （例如，复合语句中的多行子语句）。根据显式或隐式 <em>行拼接</em> 规则，一个或多个 <em>物理行</em> 可组成逻辑行。</p>
<h4 id="2-1-2-物理行"><a href="#2-1-2-物理行" class="headerlink" title="2.1.2. 物理行"></a>2.1.2. 物理行</h4><p>物理行是一序列字符，由行尾序列终止。源文件和字符串可使用任意标准平台行终止序列 - Unix ASCII 字符 LF （换行）、 Windows ASCII 字符序列 CR LF （回车换行）、或老式 Macintosh ASCII 字符 CR （回车）。不管在哪个平台，这些形式均可等价使用。输入结束也可以用作最终物理行的隐式终止符。</p>
<p>嵌入 Python 时，传入 Python API 的源码字符串应使用 C 标准惯例换行符（<code>\n</code>，代表 ASCII 字符 LF， 行终止符）。</p>
<h4 id="2-1-3-注释"><a href="#2-1-3-注释" class="headerlink" title="2.1.3. 注释"></a>2.1.3. 注释</h4><p>注释以井号 （<code>#</code>） 开头，在物理行末尾截止。注意，井号不是字符串字面值。除非应用隐式行拼接规则，否则，注释代表逻辑行结束。句法不解析注释。</p>
<h4 id="2-1-4-编码声明"><a href="#2-1-4-编码声明" class="headerlink" title="2.1.4. 编码声明"></a>2.1.4. 编码声明</h4><p>Python 脚本第一或第二行的注释匹配正则表达式 <code>coding[=:]\s*([-\w.]+)</code> 时，该注释会被当作编码声明；这个表达式的第一组指定了源码文件的编码。编码声明必须独占一行，在第二行时，则第一行必须也是注释。编码表达式的形式如下：</p>
<pre><code># -*- coding: &lt;encoding-name&gt; -*-</code></pre><p>这也是 GNU Emacs 认可的形式，此外，还支持如下形式：</p>
<pre><code># vim:fileencoding=&lt;encoding-name&gt;</code></pre><p>这是 Bram Moolenaar 的 VIM 认可的形式。</p>
<p>没有编码声明时，默认编码为 UTF-8。此外，如果文件的首字节为 UTF-8 字节顺序标志（<code>b'\xef\xbb\xbf'</code>），文件编码也声明为 UTF-8（这是 Microsoft 的 <strong>notepad</strong> 等软件支持的形式）。</p>
<p>声明的编码名称必须是 Python 能识别的。语义字符串、注释和标识符等词法分析都使用此编码。</p>
<h4 id="2-1-5-显式拼接行"><a href="#2-1-5-显式拼接行" class="headerlink" title="2.1.5. 显式拼接行"></a>2.1.5. 显式拼接行</h4><p>两个及两个以上的物理行可用反斜杠（<code>\</code>）拼接为一个逻辑行，规则如下：以不在字符串或注释内的反斜杠结尾时，物理行将与下一行拼接成一个逻辑行，并删除反斜杠及其后的换行符。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">if</span> <span class="token number">1900</span> <span class="token operator">&lt;</span> year <span class="token operator">&lt;</span> <span class="token number">2100</span> <span class="token operator">and</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> month <span class="token operator">&lt;=</span> <span class="token number">12</span> \
   <span class="token operator">and</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> day <span class="token operator">&lt;=</span> <span class="token number">31</span> <span class="token operator">and</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> hour <span class="token operator">&lt;</span> <span class="token number">24</span> \
   <span class="token operator">and</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> minute <span class="token operator">&lt;</span> <span class="token number">60</span> <span class="token operator">and</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> second <span class="token operator">&lt;</span> <span class="token number">60</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true"># Looks like a valid date</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>以反斜杠结尾的行，不能加注释；反斜杠也不能拼接注释。除字符串字面值外，反斜杠不能拼接形符（如，除字符串字面值外，不能用反斜杠把形符切分至两个物理行）。反斜杠只能在代码的字符串字面值里，在其他任何位置都是非法的。</p>
<h4 id="2-1-6-隐式拼接行"><a href="#2-1-6-隐式拼接行" class="headerlink" title="2.1.6. 隐式拼接行"></a>2.1.6. 隐式拼接行</h4><p>圆括号、方括号、花括号内的表达式可以分成多个物理行，不必使用反斜杠。例如：</p>
<pre class="line-numbers language-python"><code class="language-python">month_names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Januari'</span><span class="token punctuation">,</span> <span class="token string">'Februari'</span><span class="token punctuation">,</span> <span class="token string">'Maart'</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true"># These are the</span>
               <span class="token string">'April'</span><span class="token punctuation">,</span>   <span class="token string">'Mei'</span><span class="token punctuation">,</span>      <span class="token string">'Juni'</span><span class="token punctuation">,</span>       <span class="token comment" spellcheck="true"># Dutch names</span>
               <span class="token string">'Juli'</span><span class="token punctuation">,</span>    <span class="token string">'Augustus'</span><span class="token punctuation">,</span> <span class="token string">'September'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># for the months</span>
               <span class="token string">'Oktober'</span><span class="token punctuation">,</span> <span class="token string">'November'</span><span class="token punctuation">,</span> <span class="token string">'December'</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># of the year</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>隐式行拼接可含注释；后续行的缩进并不重要；还支持空的后续行。隐式拼接行之间没有 NEWLINE 形符。三引号字符串支持隐式拼接行（见下文），但不支持注释。</p>
<h4 id="2-1-7-空白行"><a href="#2-1-7-空白行" class="headerlink" title="2.1.7. 空白行"></a>2.1.7. 空白行</h4><p>只包含空格符、制表符、换页符、注释的逻辑行会被忽略（即不生成 NEWLINE 形符）。交互模式输入语句时，空白行的处理方式可能因读取 - 求值 - 打印循环（REPL）的具体实现方式而不同。标准交互模式解释器中，完全空白的逻辑行（即连空格或注释都没有）将结束多行复合语句。</p>
<h4 id="2-1-8-缩进"><a href="#2-1-8-缩进" class="headerlink" title="2.1.8. 缩进"></a>2.1.8. 缩进</h4><p>逻辑行开头的空白符（空格符和制表符）用于计算该行的缩进层级，决定语句组块。</p>
<p>制表符（从左至右）被替换为一至八个空格，缩进空格的总数是八的倍数（与 Unix 的规则保持一致）。首个非空字符前的空格数决定了该行的缩进层次。缩进不能用反斜杠进行多行拼接；首个反斜杠之前的空白符决定了缩进的层次。</p>
<p>源文件混用制表符和空格符缩进时，因空格数量与制表符相关，由此产生的不一致将导致不能正常识别缩进层次，从而触发 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#TabError" target="_blank" rel="noopener"><code>TabError</code></a>。</p>
<p><strong>跨平台兼容性说明：</strong> 鉴于非 UNIX 平台文本编辑器本身的特性，请勿在源文件中混用制表符和空格符。另外也请注意，不同平台有可能会显式限制最大缩进层级。</p>
<p>行首含换页符时，缩进计算将忽略该换页符。换页符在行首空白符内其他位置的效果未定义（例如，可能导致空格计数重置为零）。</p>
<p>连续行的缩进层级以堆栈形式生成 INDENT 和 DEDENT 形符，说明如下。</p>
<p>读取文件第一行前，先向栈推入一个零值，该零值不会被移除。推入栈的层级值从底至顶持续增加。每个逻辑行开头的行缩进层级将与栈顶行比较。如果相等，则不做处理。如果新行层级较高，则会被推入栈顶，并生成一个 INDENT 形符。如果新行层级较低，则 <em>应当</em> 是栈中的层级数值之一；栈中高于该层级的所有数值都将被移除，每移除一级数值生成一个 DEDENT 形符。文件末尾，栈中剩余的每个大于零的数值生成一个 DEDENT 形符。</p>
<p>下面的 Python 代码缩进示例虽然正确，但含混不清：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">perm</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># Compute the list of all permutations of l</span>
    <span class="token keyword">if</span> len<span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
                  <span class="token keyword">return</span> <span class="token punctuation">[</span>l<span class="token punctuation">]</span>
    r <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
             s <span class="token operator">=</span> l<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> l<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
             p <span class="token operator">=</span> perm<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
             <span class="token keyword">for</span> x <span class="token keyword">in</span> p<span class="token punctuation">:</span>
              r<span class="token punctuation">.</span>append<span class="token punctuation">(</span>l<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> x<span class="token punctuation">)</span>
    <span class="token keyword">return</span> r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下例展示了多种缩进错误：</p>
<pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">def</span> <span class="token function">perm</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span>                       <span class="token comment" spellcheck="true"># error: first line indented</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>             <span class="token comment" spellcheck="true"># error: not indented</span>
    s <span class="token operator">=</span> l<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> l<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
        p <span class="token operator">=</span> perm<span class="token punctuation">(</span>l<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> l<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># error: unexpected indent</span>
        <span class="token keyword">for</span> x <span class="token keyword">in</span> p<span class="token punctuation">:</span>
                r<span class="token punctuation">.</span>append<span class="token punctuation">(</span>l<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> x<span class="token punctuation">)</span>
            <span class="token keyword">return</span> r                <span class="token comment" spellcheck="true"># error: inconsistent dedent</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（实际上，解析器可以识别前三个错误；只有最后一个错误由词法分析器识别 —- <code>return r</code> 的缩进无法匹配从栈里移除的缩进层级。）</p>
<h4 id="2-1-9-形符间的空白字符"><a href="#2-1-9-形符间的空白字符" class="headerlink" title="2.1.9. 形符间的空白字符"></a>2.1.9. 形符间的空白字符</h4><p>除非在逻辑行开头或字符串内，空格符、制表符、换页符等空白符都可以分隔形符。要把两个相连形符解读为不同形符，需要用空白符分隔（例如，ab 是一个形符，a b 则是两个形符）。</p>
<h3 id="2-2-其他形符"><a href="#2-2-其他形符" class="headerlink" title="2.2. 其他形符"></a>2.2. 其他形符</h3><p>除 NEWLINE、INDENT、DEDENT 外，还有 <em>标识符<em>、</em>关键字<em>、</em>字面值<em>、</em>运算符</em> 、<em>分隔符</em> 等形符。 空白符（前述的行终止符除外）不是形符，可用于分隔形符。存在二义性时，将从左至右，读取尽量长的字符串组成合法形符。</p>
<h3 id="2-3-标识符和关键字"><a href="#2-3-标识符和关键字" class="headerlink" title="2.3. 标识符和关键字"></a>2.3. 标识符和关键字</h3><p>标识符（也称为 <em>名称</em>）的词法定义说明如下。</p>
<p>Python 标识符的句法基于 Unicode 标准附件 UAX-31，并加入了下文定义的细化与修改；详见 <a href="https://www.python.org/dev/peps/pep-3131" target="_blank" rel="noopener"><strong>PEP 3131</strong></a> 。</p>
<p>与 Python 2.x 一样，在 ASCII 范围内（U+0001..U+007F），有效标识符字符为： 大小写字母 <code>A</code> 至 <code>Z</code>、下划线 <code>_</code> 、数字 <code>0</code> 至 <code>9</code>，但不能以数字开头。</p>
<p>Python 3.0 引入了 ASCII 之外的更多字符（请参阅 <a href="https://www.python.org/dev/peps/pep-3131" target="_blank" rel="noopener"><strong>PEP 3131</strong></a>）。这些字符的分类使用 <code>unicodedata</code> 模块中的 Unicode 字符数据库版本。</p>
<p>标识符的长度没有限制，但区分大小写。</p>
<pre><code>identifier   ::=  xid_start xid_continue*
id_start     ::=  &lt;all characters in general categories Lu, Ll, Lt, Lm, Lo, Nl, the underscore, and characters with the Other_ID_Start property&gt;
id_continue  ::=  &lt;all characters in id_start, plus characters in the categories Mn, Mc, Nd, Pc and others with the Other_ID_Continue property&gt;
xid_start    ::=  &lt;all characters in id_start whose NFKC normalization is in "id_start xid_continue*"&gt;
xid_continue ::=  &lt;all characters in id_continue whose NFKC normalization is in "id_continue*"&gt;</code></pre><p>上述 Unicode 类别码的含义:</p>
<ul>
<li><em>Lu</em> - 大写字母</li>
<li><em>Ll</em> - 小写字母</li>
<li><em>Lt</em> - 词首大写字母</li>
<li><em>Lm</em> - 修饰符字母</li>
<li><em>Lo</em> - 其他字母</li>
<li><em>Nl</em> - 字母数字</li>
<li><em>Mn</em> - 非空白标识</li>
<li><em>Mc</em> - 含空白标识</li>
<li><em>Nd</em> - 十进制数字</li>
<li><em>Pc</em> - 连接标点</li>
<li><em>Other_ID_Start</em> - 由 <a href="https://www.unicode.org/Public/13.0.0/ucd/PropList.txt" target="_blank" rel="noopener">PropList.txt</a> 定义的显式字符列表，用于支持向后兼容</li>
<li><em>Other_ID_Continue</em> - 同上</li>
</ul>
<p>在解析时，所有标识符都会被转换为规范形式 NFKC；标识符的比较都是基于 NFKC。</p>
<p>Unicode 4.1 中所有可用的标识符字符详见此 HTML 文件 <a href="https://www.unicode.org/Public/13.0.0/ucd/DerivedCoreProperties.txt" target="_blank" rel="noopener">https://www.unicode.org/Public/13.0.0/ucd/DerivedCoreProperties.txt</a></p>
<h4 id="2-3-1-关键字"><a href="#2-3-1-关键字" class="headerlink" title="2.3.1. 关键字"></a>2.3.1. 关键字</h4><p>以下标识符为保留字，或称 <em>关键字</em>，不可用于普通标识符。关键字的拼写必须与这里列出的完全一致：</p>
<pre><code>False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield</code></pre><h4 id="2-3-2-软关键字"><a href="#2-3-2-软关键字" class="headerlink" title="2.3.2. 软关键字"></a>2.3.2. 软关键字</h4><p>3.10 新版功能.</p>
<p>某些标识符仅在特定上下文中被保留。 它们被称为 <em>软关键字</em>。 <code>match</code>, <code>case</code> 和 <code>_</code> 等标识符在模式匹配语句相关的上下文中具有相当于关键字的语义，但这种区分是在解析器层级完成，而不是在形符化的时候。</p>
<p>作为软关键字，它们能够与模式匹配一起使用，同时仍然保持与使用 <code>match</code>, <code>case</code> 和 <code>_</code> 作为标识符名称的现有代码的兼容性。</p>
<h4 id="2-3-3-保留的标识符类"><a href="#2-3-3-保留的标识符类" class="headerlink" title="2.3.3. 保留的标识符类"></a>2.3.3. 保留的标识符类</h4><p>某些标识符类（除了关键字）具有特殊含义。这些类的命名模式以下划线字符开头，并以下划线结尾：</p>
<pre><code>_*</code></pre><p><code>from module import *</code> 时，不会导入。交互式解释器中，特殊标识符 <code>_</code> 用于存储最近一次求值的结果；该标识符保存在 <code>builtins</code> 模块里。不处于交互模式时，<code>_</code> 没有特殊含义，也没有预定义。</p>
<p>注解</p>
<p><code>_</code> 常用于连接国际化文本。</p>
<pre><code>__*__</code></pre><p>系统定义的名称，通常简称为 “dunder” 。这些名称由解释器及其实现（包括标准库）定义。Python 未来版本中还将定义更多此类名称。任何情况下，<em>任何</em> 不显式遵从 <code>__*__</code> 名称的文档用法，都可能导致无警告提示的错误。</p>
<pre><code>__*</code></pre><p>类的私有名称。类定义时，此类名称以一种混合形式重写，以避免基类及派生类的 “私有” 属性之间产生名称冲突。</p>
<h3 id="2-4-字面值"><a href="#2-4-字面值" class="headerlink" title="2.4. 字面值"></a>2.4. 字面值</h3><p>字面值是内置类型常量值的表示法。</p>
<h4 id="2-4-1-字符串与字节串字面值"><a href="#2-4-1-字符串与字节串字面值" class="headerlink" title="2.4.1. 字符串与字节串字面值"></a>2.4.1. 字符串与字节串字面值</h4><p>字符串字面值的词法定义如下：</p>
<pre><code>stringliteral   ::=  [stringprefix](shortstring | longstring)
stringprefix    ::=  "r" | "u" | "R" | "U" | "f" | "F"
                     | "fr" | "Fr" | "fR" | "FR" | "rf" | "rF" | "Rf" | "RF"
shortstring     ::=  "'" shortstringitem* "'" | '"' shortstringitem* '"'
longstring      ::=  "'''" longstringitem* "'''" | '"""' longstringitem* '"""'
shortstringitem ::=  shortstringchar | stringescapeseq
longstringitem  ::=  longstringchar | stringescapeseq
shortstringchar ::=  &lt;any source character except "\" or newline or the quote&gt;
longstringchar  ::=  &lt;any source character except "\"&gt;
stringescapeseq ::=  "\" &lt;any source character&gt;

bytesliteral   ::=  bytesprefix(shortbytes | longbytes)
bytesprefix    ::=  "b" | "B" | "br" | "Br" | "bR" | "BR" | "rb" | "rB" | "Rb" | "RB"
shortbytes     ::=  "'" shortbytesitem* "'" | '"' shortbytesitem* '"'
longbytes      ::=  "'''" longbytesitem* "'''" | '"""' longbytesitem* '"""'
shortbytesitem ::=  shortbyteschar | bytesescapeseq
longbytesitem  ::=  longbyteschar | bytesescapeseq
shortbyteschar ::=  &lt;any ASCII character except "\" or newline or the quote&gt;
longbyteschar  ::=  &lt;any ASCII character except "\"&gt;
bytesescapeseq ::=  "\" &lt;any ASCII character&gt;</code></pre><p>上述产生式没有说明以下句法限制，<code>stringprefix</code> 或 <code>bytesprefix</code> 与其他字面值之间不允许有空白符。源字符集由编码声明定义；源文件没有编码声明时，默认为 UTF-8。</p>
<p>通俗地说：两种字面值都可以用单引号（<code>'</code>）或双引号（<code>"</code>） 标注。也可以用三个单引号或双引号标注（俗称 <em>三引号字符串</em>）。反斜杠（<code>\</code>）用于转义特殊字符，例如，换行符、反斜杠本身、引号等。</p>
<p>字节串字面值要加前缀 <code>'b'</code> 或 <code>'B'</code>；生成的是类型 <code>bytes</code> 的实例，不是类型 <code>str</code> 的实例；字节串只能包含 ASCII 字符；字节串数值大于等于 128 时，必须用转义表示。</p>
<p>字符串和字节串都可以加前缀 <code>'r'</code> 或 <code>'R'</code>，称为 <em>原始字符串</em>，原始字符串把反斜杠当作原义字符，不执行转义操作。因此，原始字符串不转义 <code>'\U'</code> 和 <code>'\u'</code>。与 Python 2.x 的原始 unicode 字面值操作不同，Python 3.x 现已不支持 <code>'ur'</code> 句法。</p>
<p>3.3 新版功能: 新增原始字节串 <code>'rb'</code> 前缀，是 <code>'br'</code> 的同义词。</p>
<p>3.3 新版功能: 支持 unicode 字面值（<code>u'value'</code>）遗留代码，简化 Python 2.x 和 3.x 并行代码库的维护工作。详见 <a href="https://www.python.org/dev/peps/pep-0414" target="_blank" rel="noopener"><strong>PEP 414</strong></a>。</p>
<p>前缀为 <code>'f'</code> 或 <code>'F'</code> 的字符串称为 <em>格式字符串</em>。<code>'f'</code> 可与 <code>'r'</code> 连用，但不能与 <code>'b'</code> 或 <code>'u'</code> 连用，因此，可以使用原始格式字符串，但不能使用格式字节串字面值。</p>
<p>三引号字面值可以包含未转义的换行和引号（原样保留），除了连在一起的，用于终止字面值的，未经转义的三个引号。（”引号” 是启用字面值的字符，可以是 <code>'</code>，也可以是 <code>"</code>。）</p>
<p>如未标注 <code>'r'</code> 或 <code>'R'</code> 前缀，字符串和字节串字面值中，转义序列以类似 C 标准的规则进行解释。可用的转义序列如下：</p>
<table>
<thead>
<tr>
<th align="left">转义序列</th>
<th align="left">含意</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>\newline</code></td>
<td align="left">忽略反斜杠与换行符</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\</code></td>
<td align="left">反斜杠（<code>\</code>）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\’</code></td>
<td align="left">单引号（<code>‘</code>）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\”</code></td>
<td align="left">双引号（<code>“</code>）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\a</code></td>
<td align="left">ASCII 响铃（BEL）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\b</code></td>
<td align="left">ASCII 退格符（BS）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\f</code></td>
<td align="left">ASCII 换页符（FF）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\n</code></td>
<td align="left">ASCII 换行符（LF）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\r</code></td>
<td align="left">ASCII 回车符（CR）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\t</code></td>
<td align="left">ASCII 水平制表符（TAB）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\v</code></td>
<td align="left">ASCII 垂直制表符（VT）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>\ooo</code></td>
<td align="left">八进制数 <em>ooo</em> 字符</td>
<td align="left">(1,3)</td>
</tr>
<tr>
<td align="left"><code>\xhh</code></td>
<td align="left">十六进制数 <em>hh</em> 字符</td>
<td align="left">(2,3)</td>
</tr>
</tbody></table>
<p>字符串字面值专用的转义序列：</p>
<table>
<thead>
<tr>
<th align="left">转义序列</th>
<th align="left">含意</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>\N{name}</code></td>
<td align="left">Unicode 数据库中名为 <em>name</em> 的字符</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>\uxxxx</code></td>
<td align="left">16 位十六进制数 <em>xxxx</em> 码位的字符</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>\Uxxxxxxxx</code></td>
<td align="left">32 位 16 进制数 <em>xxxxxxxx</em> 码位的字符</td>
<td align="left">(6)</td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li>与 C 标准一致，接受最多三个八进制数字。</li>
<li>与 C 标准不同，必须为两个十六进制数字。</li>
<li><em>字节串</em> 字面值中，十六进制数和八进制数的转义码以相应数值代表每个字节。<em>字符串</em> 字面值中，这些转义码以相应数值代表每个 Unicode 字符。</li>
<li>在 3.3 版更改: 加入了对<a href="https://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt" target="_blank" rel="noopener">别名的支持</a>。</li>
<li>必须为 4 个十六进制数码。</li>
<li>表示任意 Unicode 字符。必须为 8 个十六进制数码。</li>
</ol>
<p>与 C 标准不同，无法识别的转义序列在字符串里原样保留，即，<em>输出结果保留反斜杠</em>。（调试时，这种方式很有用：输错转义序列时，更容易在输出结果中识别错误。）注意，在字节串字面值内，字符串字面值专用的转义序列属于无法识别的转义序列。</p>
<blockquote>
<p>在 3.6 版更改: 无法识别的转义序列触发 <code>DeprecationWarning</code>。未来的 Python 发行版将改为触发 <code>SyntaxWarning</code>，最终会改为触发 <code>SyntaxError</code>。</p>
</blockquote>
<p>即使在原始字面值中，引号也可以用反斜杠转义，但反斜杠会保留在输出结果里；例如 <code>r"\""</code> 是由两个字符组成的有效字符串字面值：反斜杠和双引号；<code>r"\"</code> 则不是有效字符串字面值（原始字符串也不能以奇数个反斜杠结尾）。尤其是，<em>原始字面值不能以单个反斜杠结尾</em> （反斜杠会转义其后的引号)。还要注意，反斜杠加换行在字面值中被解释为两个字符，而 <em>不是</em> 连续行。</p>
<h4 id="2-4-2-字符串字面值合并"><a href="#2-4-2-字符串字面值合并" class="headerlink" title="2.4.2. 字符串字面值合并"></a>2.4.2. 字符串字面值合并</h4><p>以空白符分隔的多个相邻字符串或字节串字面值，可用不同引号标注，等同于合并操作。因此，<code>"hello" 'world'</code> 等价于 <code>"helloworld"</code>。此功能不需要反斜杠，即可将长字符串分为多个物理行，还可以为不同部分的字符串添加注释，例如：</p>
<pre><code>re.compile("[A-Za-z_]"       # letter or underscore
           "[A-Za-z0-9_]*"   # letter, digit or underscore
          )</code></pre><p>注意，此功能在句法层面定义，在编译时实现。在运行时，合并字符串表达式必须使用 ‘+’ 运算符。还要注意，字面值合并可以为每个部分应用不同的引号风格（甚至混用原始字符串和三引号字符串)，格式字符串字面值也可以与纯字符串字面值合并。</p>
<h4 id="2-4-3-格式字符串字面值"><a href="#2-4-3-格式字符串字面值" class="headerlink" title="2.4.3. 格式字符串字面值"></a>2.4.3. 格式字符串字面值</h4><p>3.6 新版功能.</p>
<p><em>格式字符串字面值</em> 或称 <em>f-string</em> 是标注了 <code>'f'</code> 或 <code>'F'</code> 前缀的字符串字面值。这种字符串可包含替换字段，即以 <code>{}</code> 标注的表达式。其他字符串字面值只是常量，格式字符串字面值则是可在运行时求值的表达式。</p>
<p>除非字面值标记为原始字符串，否则，与在普通字符串字面值中一样，转义序列也会被解码。解码后，用于字符串内容的语法如下：</p>
<pre><code>f_string          ::=  (literal_char | "{{" | "}}" | replacement_field)*
replacement_field ::=  "{" f_expression ["="] ["!" conversion] [":" format_spec] "}"
f_expression      ::=  (conditional_expression | "*" or_expr)
                         ("," conditional_expression | "," "*" or_expr)* [","]
                       | yield_expression
conversion        ::=  "s" | "r" | "a"
format_spec       ::=  (literal_char | NULL | replacement_field)*
literal_char      ::=  &lt;any code point except "{", "}" or NULL&gt;</code></pre><p>双花括号 <code>'` 或 `'</code> 被替换为单花括号，花括号外的字符串仍按字面值处理。单左花括号 <code>'{'</code> 标记以 Python 表达式开头的替换字段。在表达式后加等于号 <code>'='</code>，可在求值后，同时显示表达式文本及其结果（用于调试）。 随后是用叹号 <code>'!'</code> 标记的转换字段。还可以在冒号 <code>':'</code> 后附加格式说明符。替换字段以右花括号 <code>'}'</code> 为结尾。</p>
<p>格式字符串字面值中，表达式的处理与圆括号中的常规 Python 表达式基本一样，但也有一些不同的地方。不允许使用空表达式；<code>lambda</code> 和赋值表达式 <code>:=</code> 必须显式用圆括号标注；替换表达式可以包含换行（例如，三引号字符串中），但不能包含注释；在格式字符串字面值语境内，按从左至右的顺序，为每个表达式求值。</p>
<p>在 3.7 版更改: Python 3.7 以前， 因为实现的问题，不允许在格式字符串字面值表达式中使用 <code>await</code> 表达式与包含 <code>async for</code> 子句的推导式。</p>
<p>表达式里含等号 <code>'='</code> 时，输出内容包括表达式文本、<code>'='</code> 、求值结果。输出内容可以保留表达式中左花括号 <code>'{'</code> 后，及 <code>'='</code> 后的空格。没有指定格式时，<code>'='</code> 默认调用表达式的 <code>repr()</code>。指定了格式时，默认调用表达式的 <code>str()</code>，除非声明了转换字段 <code>'!r'</code>。</p>
<p>3.8 新版功能: 等号 <code>'='</code>。</p>
<p>指定了转换符时，表达式求值的结果会先转换，再格式化。转换符 <code>'!s'</code> 调用 <code>str()</code> 转换求值结果，<code>'!r'</code> 调用 <code>repr()</code>，<code>'!a'</code> 调用 <code>ascii()</code>。</p>
<p>输出结果的格式化使用 <code>format()</code> 协议。格式说明符传入表达式或转换结果的 <code>__format__()</code> 方法。省略格式说明符，则传入空字符串。然后，格式化结果包含在整个字符串的最终值里。</p>
<p>顶层格式说明符可以包含嵌套替换字段。嵌套字段也可以包含自己的转换字段和 格式说明符，但不可再包含更深层嵌套的替换字段。格式说明符微语言 与 <code>str.format()</code> 方法使用的微语言相同。</p>
<p>格式化字符串字面值可以拼接，但是一个替换字段不能拆分到多个字面值。</p>
<p>格式字符串字面值示例如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> name <span class="token operator">=</span> <span class="token string">"Fred"</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">"He said his name is {name!r}."</span>
<span class="token string">"He said his name is 'Fred'."</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">"He said his name is {repr(name)}."</span>  <span class="token comment" spellcheck="true"># repr() is equivalent to !r</span>
<span class="token string">"He said his name is 'Fred'."</span>
<span class="token operator">>></span><span class="token operator">></span> width <span class="token operator">=</span> <span class="token number">10</span>
<span class="token operator">>></span><span class="token operator">></span> precision <span class="token operator">=</span> <span class="token number">4</span>
<span class="token operator">>></span><span class="token operator">></span> value <span class="token operator">=</span> decimal<span class="token punctuation">.</span>Decimal<span class="token punctuation">(</span><span class="token string">"12.34567"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">"result: {value:{width}.{precision}}"</span>  <span class="token comment" spellcheck="true"># nested fields</span>
<span class="token string">'result:      12.35'</span>
<span class="token operator">>></span><span class="token operator">></span> today <span class="token operator">=</span> datetime<span class="token punctuation">(</span>year<span class="token operator">=</span><span class="token number">2017</span><span class="token punctuation">,</span> month<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> day<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">"{today:%B %d, %Y}"</span>  <span class="token comment" spellcheck="true"># using date format specifier</span>
<span class="token string">'January 27, 2017'</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">"{today=:%B %d, %Y}"</span> <span class="token comment" spellcheck="true"># using date format specifier and debugging</span>
<span class="token string">'today=January 27, 2017'</span>
<span class="token operator">>></span><span class="token operator">></span> number <span class="token operator">=</span> <span class="token number">1024</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">"{number:#0x}"</span>  # using integer format specifier
<span class="token string">'0x400'</span>
<span class="token operator">>></span><span class="token operator">></span> foo <span class="token operator">=</span> <span class="token string">"bar"</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">"{ foo = }"</span> <span class="token comment" spellcheck="true"># preserves whitespace</span>
<span class="token string">" foo = 'bar'"</span>
<span class="token operator">>></span><span class="token operator">></span> line <span class="token operator">=</span> <span class="token string">"The mill's closed"</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">"{line = }"</span>
<span class="token string">'line = "The mill\'s closed"'</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">"{line = :20}"</span>
<span class="token string">"line = The mill's closed   "</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">"{line = !r:20}"</span>
<span class="token string">'line = "The mill\'s closed" '</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与常规字符串字面值的语法一样，替换字段中的字符不能与外层格式字符串字面值的引号冲突：</p>
<pre class="line-numbers language-python"><code class="language-python">f<span class="token string">"abc {a["</span>x<span class="token string">"]} def"</span>    <span class="token comment" spellcheck="true"># error: outer string literal ended prematurely</span>
f<span class="token string">"abc {a['x']} def"</span>    <span class="token comment" spellcheck="true"># workaround: use different quoting</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>格式表达式中不能有反斜杠，否则会报错：</p>
<pre class="line-numbers language-python"><code class="language-python">f<span class="token string">"newline: {ord('\n')}"</span>  <span class="token comment" spellcheck="true"># raises SyntaxError</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>要使用反斜杠转义的值，则需创建临时变量。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> newline <span class="token operator">=</span> ord<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">"newline: {newline}"</span>
<span class="token string">'newline: 10'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>即便未包含表达式，格式字符串字面值也不能用作文档字符串。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     f<span class="token string">"Not a docstring"</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> foo<span class="token punctuation">.</span>__doc__ <span class="token keyword">is</span> None
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参阅 <a href="https://www.python.org/dev/peps/pep-0498" target="_blank" rel="noopener"><strong>PEP 498</strong></a>，了解格式字符串字面值的提案，以及与格式字符串机制相关的 <code>str.format()</code>。</p>
<h4 id="2-4-4-数值字面值"><a href="#2-4-4-数值字面值" class="headerlink" title="2.4.4. 数值字面值"></a>2.4.4. 数值字面值</h4><p>数值字面值有三种类型：整数、浮点数、虚数。没有复数字面值（复数由实数加虚数构成）。</p>
<p>注意，数值字面值不含正负号；实际上，<code>-1</code> 等负数是由一元运算符 ‘<code>-</code>‘ 和字面值 <code>1</code> 合成的。</p>
<h4 id="2-4-5-整数字面值"><a href="#2-4-5-整数字面值" class="headerlink" title="2.4.5. 整数字面值"></a>2.4.5. 整数字面值</h4><p>整数字面值词法定义如下：</p>
<pre><code>integer      ::=  decinteger | bininteger | octinteger | hexinteger
decinteger   ::=  nonzerodigit (["_"] digit)* | "0"+ (["_"] "0")*
bininteger   ::=  "0" ("b" | "B") (["_"] bindigit)+
octinteger   ::=  "0" ("o" | "O") (["_"] octdigit)+
hexinteger   ::=  "0" ("x" | "X") (["_"] hexdigit)+
nonzerodigit ::=  "1"..."9"
digit        ::=  "0"..."9"
bindigit     ::=  "0" | "1"
octdigit     ::=  "0"..."7"
hexdigit     ::=  digit | "a"..."f" | "A"..."F"</code></pre><p>整数字面值的长度没有限制，能一直大到占满可用内存。</p>
<p>确定数值时，会忽略字面值中的下划线。下划线只是为了分组数字，让数字更易读。下划线可在数字之间，也可在 <code>0x</code> 等基数说明符后。</p>
<p>注意，除了 0 以外，十进制数字的开头不允许有零。以免与 Python 3.0 版之前使用的 C 样式八进制字面值混淆。</p>
<p>整数字面值示例如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token number">7</span>     <span class="token number">2147483647</span>                        <span class="token number">0o177</span>    <span class="token number">0b100110111</span>
<span class="token number">3</span>     <span class="token number">79228162514264337593543950336</span>     <span class="token number">0o377</span>    <span class="token number">0xdeadbeef</span>
      100_000_000_000                   0b_1110_0101<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 3.6 版更改: 现已支持在字面值中，用下划线分组数字。</p>
<h4 id="2-4-6-浮点数字面值"><a href="#2-4-6-浮点数字面值" class="headerlink" title="2.4.6. 浮点数字面值"></a>2.4.6. 浮点数字面值</h4><p>浮点数字面值词法定义如下：</p>
<pre><code>floatnumber   ::=  pointfloat | exponentfloat
pointfloat    ::=  [digitpart] fraction | digitpart "."
exponentfloat ::=  (digitpart | pointfloat) exponent
digitpart     ::=  digit (["_"] digit)*
fraction      ::=  "." digitpart
exponent      ::=  ("e" | "E") ["+" | "-"] digitpart</code></pre><p>注意，解析时，整数和指数部分总以 10 为基数。例如，<code>077e010</code> 是合法的，表示的数值与 <code>77e10</code> 相同。浮点数字面值的支持范围取决于具体实现。整数字面值支持用下划线分组数字。</p>
<p>浮点数字面值示例如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token number">3.14</span>    <span class="token number">10</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token number">001</span>    <span class="token number">1e100</span>    <span class="token number">3.14e-10</span>    <span class="token number">0e0</span>    <span class="token number">3.</span>14_15_93<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在 3.6 版更改: 现已支持在字面值中，用下划线分组数字。</p>
<h4 id="2-4-7-虚数字面值"><a href="#2-4-7-虚数字面值" class="headerlink" title="2.4.7. 虚数字面值"></a>2.4.7. 虚数字面值</h4><p>虚数字面值词法定义如下：</p>
<pre><code>imagnumber ::=  (floatnumber | digitpart) ("j" | "J")</code></pre><p>虚数字面值生成实部为 0.0 的复数。复数由一对浮点数表示，它们的取值范围相同。创建实部不为零的复数，则需添加浮点数，例如 <code>(3+4j)</code>。虚数字面值示例如下：</p>
<pre><code>3.14j   10.j    10j     .001j   1e100j   3.14e-10j   3.14_15_93j</code></pre><h3 id="2-5-运算符"><a href="#2-5-运算符" class="headerlink" title="2.5. 运算符"></a>2.5. 运算符</h3><p>运算符如下所示：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">+</span>       <span class="token operator">-</span>       <span class="token operator">*</span>       <span class="token operator">**</span>      <span class="token operator">/</span>       <span class="token operator">//</span>      <span class="token operator">%</span>      @
<span class="token operator">&lt;&lt;</span>      <span class="token operator">>></span>      <span class="token operator">&amp;</span>       <span class="token operator">|</span>       <span class="token operator">^</span>       <span class="token operator">~</span>       <span class="token punctuation">:</span><span class="token operator">=</span>
<span class="token operator">&lt;</span>       <span class="token operator">></span>       <span class="token operator">&lt;=</span>      <span class="token operator">>=</span>      <span class="token operator">==</span>      <span class="token operator">!=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="2-6-分隔符"><a href="#2-6-分隔符" class="headerlink" title="2.6. 分隔符"></a>2.6. 分隔符</h3><p>以下形符在语法中为分隔符：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">(</span>       <span class="token punctuation">)</span>       <span class="token punctuation">[</span>       <span class="token punctuation">]</span>       <span class="token punctuation">{</span>       <span class="token punctuation">}</span>
<span class="token punctuation">,</span>       <span class="token punctuation">:</span>       <span class="token punctuation">.</span>       <span class="token punctuation">;</span>       @       <span class="token operator">=</span>       <span class="token operator">-</span><span class="token operator">></span>
<span class="token operator">+=</span>      <span class="token operator">-=</span>      <span class="token operator">*=</span>      <span class="token operator">/=</span>      <span class="token operator">//=</span>     <span class="token operator">%=</span>      @<span class="token operator">=</span>
<span class="token operator">&amp;</span><span class="token operator">=</span>      <span class="token operator">|</span><span class="token operator">=</span>      <span class="token operator">^</span><span class="token operator">=</span>      <span class="token operator">>></span><span class="token operator">=</span>     <span class="token operator">&lt;&lt;</span><span class="token operator">=</span>     <span class="token operator">**=</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>句点也可以用于浮点数和虚数字面值。三个连续句点表示省略符。列表后半部分是增强赋值操作符，用作词法分隔符，但也可以执行运算。</p>
<p>以下 ASCII 字符具有特殊含义，对词法分析器有重要意义：</p>
<pre class="line-numbers language-python"><code class="language-python">'       "       <span class="token comment" spellcheck="true">#       \</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>以下 ASCII 字符不用于 Python。在字符串字面值或注释外使用时，将直接报错：</p>
<pre class="line-numbers language-python"><code class="language-python">$       ?       `<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="3-数据模型"><a href="#3-数据模型" class="headerlink" title="3. 数据模型"></a>3. 数据模型</h2><h3 id="3-1-对象、值与类型"><a href="#3-1-对象、值与类型" class="headerlink" title="3.1. 对象、值与类型"></a>3.1. 对象、值与类型</h3><p><em>对象</em> 是 Python 中对数据的抽象。 Python 程序中的所有数据都是由对象或对象间关系来表示的。 （从某种意义上说，按照冯·诺依曼的“存储程序计算机”模型，代码本身也是由对象来表示的。）</p>
<p>每个对象都有各自的编号、类型和值。一个对象被创建后，它的 <em>编号</em> 就绝不会改变；你可以将其理解为该对象在内存中的地址。 ‘<code>is</code>‘ 运算符可以比较两个对象的编号是否相同；<code>id()</code> 函数能返回一个代表其编号的整型数。</p>
<p><strong>CPython implementation detail:</strong> 在 CPython 中，<code>id(x)</code> 就是存放 <code>x</code> 的内存的地址。</p>
<p>对象的类型决定该对象所支持的操作 (例如 “对象是否有长度属性？”) 并且定义了该类型的对象可能的取值。<code>type()</code> 函数能返回一个对象的类型 (类型本身也是对象)。与编号一样，一个对象的 <em>类型</em> 也是不可改变的。</p>
<p>有些对象的 <em>值</em> 可以改变。值可以改变的对象被称为 <em>可变的</em>；值不可以改变的对象就被称为 <em>不可变的</em>。(一个不可变容器对象如果包含对可变对象的引用，当后者的值改变时，前者的值也会改变；但是该容器仍属于不可变对象，因为它所包含的对象集是不会改变的。因此，不可变并不严格等同于值不能改变，实际含义要更微妙。) 一个对象的可变性是由其类型决定的；例如，数字、字符串和元组是不可变的，而字典和列表是可变的。</p>
<p>对象绝不会被显式地销毁；然而，当无法访问时它们可能会被作为垃圾回收。允许具体的实现推迟垃圾回收或完全省略此机制 —- 如何实现垃圾回收是实现的质量问题，只要可访问的对象不会被回收即可。</p>
<p><strong>CPython implementation detail:</strong> CPython 目前使用带有 (可选) 延迟检测循环链接垃圾的引用计数方案，会在对象不可访问时立即回收其中的大部分，但不保证回收包含循环引用的垃圾。请查看 <code>gc</code> 模块的文档了解如何控制循环垃圾的收集相关信息。其他实现会有不同的行为方式，CPython 现有方式也可能改变。不要依赖不可访问对象的立即终结机制 (所以你应当总是显式地关闭文件)。</p>
<p>注意：使用实现的跟踪或调试功能可能令正常情况下会被回收的对象继续存活。还要注意通过 ‘<code>try</code>…<code>except</code>‘ 语句捕捉异常也可能令对象保持存活。</p>
<p>有些对象包含对 “外部” 资源的引用，例如打开文件或窗口。当对象被作为垃圾回收时这些资源也应该会被释放，但由于垃圾回收并不确保发生，这些对象还提供了明确地释放外部资源的操作，通常为一个 <code>close()</code> 方法。强烈推荐在程序中显式关闭此类对象。’<code>try</code>…<code>finally</code>‘ 语句和 ‘<code>with</code>‘ 语句提供了进行此种操作的更便捷方式。</p>
<p>有些对象包含对其他对象的引用；它们被称为 <em>容器</em>。容器的例子有元组、列表和字典等。这些引用是容器对象值的组成部分。在多数情况下，当谈论一个容器的值时，我们是指所包含对象的值而不是其编号；但是，当我们谈论一个容器的可变性时，则仅指其直接包含的对象的编号。因此，如果一个不可变容器 (例如元组) 包含对一个可变对象的引用，则当该可变对象被改变时容器的值也会改变。</p>
<p>类型会影响对象行为的几乎所有方面。甚至对象编号的重要性也在某种程度上受到影响: 对于不可变类型，会得出新值的运算实际上会返回对相同类型和取值的任一现有对象的引用，而对于可变类型来说这是不允许的。例如在 <code>a = 1; b = 1</code> 之后，<code>a</code> 和 <code>b</code> 可能会也可能不会指向同一个值为一的对象，这取决于具体实现，但是在 <code>c = []; d = []</code> 之后，<code>c</code> 和 <code>d</code> 保证会指向两个不同、单独的新建空列表。(请注意 <code>c = d = []</code> 则是将同一个对象赋值给 <code>c</code> 和 <code>d</code>。)</p>
<h3 id="3-2-标准类型层级结构"><a href="#3-2-标准类型层级结构" class="headerlink" title="3.2. 标准类型层级结构"></a>3.2. 标准类型层级结构</h3><p>以下是 Python 内置类型的列表。扩展模块 (具体实现会以 C, Java 或其他语言编写) 可以定义更多的类型。未来版本的 Python 可能会加入更多的类型 (例如有理数、高效存储的整型数组等等)，不过新增类型往往都是通过标准库来提供的。</p>
<p>以下部分类型的描述中包含有 ‘特殊属性列表’ 段落。这些属性提供对具体实现的访问而非通常使用。它们的定义在未来可能会改变。</p>
<p>None</p>
<p>此类型只有一种取值。是一个具有此值的单独对象。此对象通过内置名称 <code>None</code> 访问。在许多情况下它被用来表示空值，例如未显式指明返回值的函数将返回 None。它的逻辑值为假。</p>
<p>NotImplemented</p>
<p>此类型只有一种取值。 是一个具有该值的单独对象。 此对象通过内置名称 <code>NotImplemented</code> 访问。 数值方法和丰富比较方法如未实现指定运算符表示的运算则应返回该值。 （解释器会根据具体运算符继续尝试反向运算或其他回退操作。） 它不应被解读为布尔值。</p>
<p>在 3.9 版更改: 作为布尔值来解读 <code>NotImplemented</code> 已被弃用。 虽然它目前会被解读为真值，但将同时发出 <code>DeprecationWarning</code>。 它将在未来的 Python 版本中引发 <code>TypeError</code>。</p>
<p>Ellipsis</p>
<p>此类型只有一种取值。是一个具有此值的单独对象。此对象通过字面值 <code>...</code> 或内置名称 <code>Ellipsis</code> 访问。它的逻辑值为真。</p>
<p><code>numbers.Number</code></p>
<p>此类对象由数字字面值创建，并会被作为算术运算符和算术内置函数的返回结果。数字对象是不可变的；一旦创建其值就不再改变。Python 中的数字当然非常类似数学中的数字，但也受限于计算机中的数字表示方法。</p>
<p>数字类的字符串表示形式，由 <code>__repr__()</code> 和 <code>__str__()</code> 算出，具有以下属性:</p>
<ul>
<li>它们是有效的数字字面值，当被传给它们的类构造器时，将会产生具有原数字值的对象。</li>
<li>表示形式会在可能的情况下采用 10 进制。</li>
<li>开头的零，除小数点前可能存在的单个零之外，将不会被显示。</li>
<li>末尾的零，除小数点后可能存在的单个零之外，将不会被显示。</li>
<li>正负号仅在当数字为负值时会被显示。</li>
</ul>
<p>Python 区分整型数、浮点型数和复数:</p>
<ul>
<li><p><code>numbers.Integral</code></p>
<p>此类对象表示数学中整数集合的成员 (包括正数和负数)。</p>
<p>整型数可细分为两种类型:</p>
<ul>
<li><p>整型 (<code>int</code>)</p>
<p>此类对象表示任意大小的数字，仅受限于可用的内存 (包括虚拟内存)。在变换和掩码运算中会以二进制表示，负数会以 2 的补码表示，看起来像是符号位向左延伸补满空位。</p>
<p>布尔型 (<code>bool</code>)</p>
<p>此类对象表示逻辑值 False 和 True。代表 <code>False</code> 和 <code>True</code> 值的两个对象是唯二的布尔对象。布尔类型是整型的子类型，两个布尔值在各种场合的行为分别类似于数值 0 和 1，例外情况只有在转换为字符串时分别返回字符串 <code>"False"</code> 或 <code>"True"</code>。</p>
</li>
</ul>
<p>整型数表示规则的目的是在涉及负整型数的变换和掩码运算时提供最为合理的解释。</p>
<p><code>numbers.Real</code> (<code>float</code>)</p>
<p>此类对象表示机器级的双精度浮点数。其所接受的取值范围和溢出处理将受制于底层的机器架构 (以及 C 或 Java 实现)。Python 不支持单精度浮点数；支持后者通常的理由是节省处理器和内存消耗，但这点节省相对于在 Python 中使用对象的开销来说太过微不足道，因此没有理由包含两种浮点数而令该语言变得复杂。</p>
<p><code>numbers.Complex</code> (<code>complex</code>)</p>
<p>此类对象以一对机器级的双精度浮点数来表示复数值。有关浮点数的附带规则对其同样有效。一个复数值 <code>z</code> 的实部和虚部可通过只读属性 <code>z.real</code> 和 <code>z.imag</code> 来获取。</p>
</li>
</ul>
<p>序列</p>
<p>此类对象表示以非负整数作为索引的有限有序集。内置函数 <code>len()</code> 可返回一个序列的条目数量。当一个序列的长度为 <em>n</em> 时，索引集包含数字 0, 1, …, <em>n</em>-1。序列 <em>a</em> 的条目 <em>i</em> 可通过 <code>a[i]</code> 选择。</p>
<p>序列还支持切片: <code>a[i:j]</code> 选择索引号为 <em>k</em> 的所有条目，<em>i</em> <code>&lt;=</code> <em>k</em> <code>&lt;</code> <em>j</em>。当用作表达式时，序列的切片就是一个与序列类型相同的新序列。新序列的索引还是从 0 开始。</p>
<p>有些序列还支持带有第三个 “step” 形参的 “扩展切片”: <code>a[i:j:k]</code> 选择 <em>a</em> 中索引号为 <em>x</em> 的所有条目，<code>x = i + n*k</code>, <em>n</em> <code>&gt;=</code> <code>0</code> 且 <em>i</em> <code>&lt;=</code> <em>x</em> <code>&lt;</code> <em>j</em>。</p>
<p>序列可根据其可变性来加以区分:</p>
<ul>
<li><p>不可变序列</p>
<p>不可变序列类型的对象一旦创建就不能再改变。(如果对象包含对其他对象的引用，其中的可变对象就是可以改变的；但是，一个不可变对象所直接引用的对象集是不能改变的。)</p>
<p>以下类型属于不可变对象:</p>
<ul>
<li><p>字符串</p>
<p>字符串是由 Unicode 码位值组成的序列。范围在 <code>U+0000 - U+10FFFF</code> 之内的所有码位值都可在字符串中使用。Python 没有 char 类型；而是将字符串中的每个码位表示为一个长度为 <code>1</code> 的字符串对象。内置函数 <code>ord()</code> 可将一个码位由字符串形式转换成一个范围在 <code>0 - 10FFFF</code> 之内的整型数；<code>chr()</code> 可将一个范围在 <code>0 - 10FFFF</code> 之内的整型数转换为长度为 <code>1</code> 的对应字符串对象。<code>str.encode()</code> 可以使用指定的文本编码将 <code>str</code> 转换为 <code>bytes</code>，而 <code>bytes.decode()</code> 则可以实现反向的解码。</p>
<p>元组</p>
<p>一个元组中的条目可以是任意 Python 对象。包含两个或以上条目的元组由逗号分隔的表达式构成。只有一个条目的元组 (‘单项元组’) 可通过在表达式后加一个逗号来构成 (一个表达式本身不能创建为元组，因为圆括号要用来设置表达式分组)。一个空元组可通过一对内容为空的圆括号创建。</p>
<p>字节串</p>
<p>字节串对象是不可变的数组。其中每个条目都是一个 8 位字节，以取值范围 0 &lt;= x &lt; 256 的整型数表示。字节串字面值 (例如 <code>b'abc'</code>) 和内置的 <code>bytes()</code> 构造器可被用来创建字节串对象。字节串对象还可以通过 <code>decode()</code> 方法解码为字符串。</p>
</li>
</ul>
</li>
<li><p>可变序列</p>
<p>可变序列在被创建后仍可被改变。下标和切片标注可被用作赋值和 <code>del</code> (删除) 语句的目标。</p>
<p>目前有两种内生可变序列类型:</p>
<ul>
<li><p>列表</p>
<p>列表中的条目可以是任意 Python 对象。列表由用方括号括起并由逗号分隔的多个表达式构成。(注意创建长度为 0 或 1 的列表无需使用特殊规则。)</p>
<p>字节数组</p>
<p>字节数组对象属于可变数组。可以通过内置的 <code>bytearray()</code> 构造器来创建。除了是可变的 (因而也是不可哈希的)，在其他方面字节数组提供的接口和功能都与不可变的 <code>bytes</code> 对象一致。</p>
</li>
</ul>
<p>扩展模块 <code>array</code> 提供了一个额外的可变序列类型示例，<code>collections</code> 模块也是如此。</p>
</li>
</ul>
<p>集合类型</p>
<p>此类对象表示由不重复且不可变对象组成的无序且有限的集合。因此它们不能通过下标来索引。但是它们可被迭代，也可用内置函数 <code>len()</code> 返回集合中的条目数。集合常见的用处是快速成员检测，去除序列中的重复项，以及进行交、并、差和对称差等数学运算。</p>
<p>对于集合元素所采用的不可变规则与字典的键相同。注意数字类型遵循正常的数字比较规则: 如果两个数字相等 (例如 <code>1</code> 和 <code>1.0</code>)，则同一集合中只能包含其中一个。</p>
<p>目前有两种内生集合类型:</p>
<ul>
<li><p>集合</p>
<p>此类对象表示可变集合。它们可通过内置的 <code>set()</code> 构造器创建，并且创建之后可以通过方法进行修改，例如 <code>add()</code>。</p>
<p>冻结集合</p>
<p>此类对象表示不可变集合。它们可通过内置的 <code>frozenset()</code> 构造器创建。由于 frozenset 对象不可变且 hashable，它可以被用作另一个集合的元素或是字典的键。</p>
</li>
</ul>
<p>映射</p>
<p>此类对象表示由任意索引集合所索引的对象的集合。通过下标 <code>a[k]</code> 可在映射 <code>a</code> 中选择索引为 <code>k</code> 的条目；这可以在表达式中使用，也可作为赋值或 <code>del</code> 语句的目标。内置函数 <code>len()</code> 可返回一个映射中的条目数。</p>
<p>目前只有一种内生映射类型:</p>
<ul>
<li><p>字典</p>
<p>此类对象表示由几乎任意值作为索引的有限个对象的集合。不可作为键的值类型只有包含列表或字典或其他可变类型，通过值而非对象编号进行比较的值，其原因在于高效的字典实现需要使用键的哈希值以保持一致性。用作键的数字类型遵循正常的数字比较规则: 如果两个数字相等 (例如 <code>1</code> 和 <code>1.0</code>) 则它们均可来用来索引同一个字典条目。</p>
<p>字典会保留插入顺序，这意味着键将以它们被添加的顺序在字典中依次产生。 替换某个现有的键不会改变其顺序，但是移除某个键再重新插入则会将其添加到末尾而不会保留其原有位置。</p>
<p>字典是可变的；它们可通过 <code>{...}</code> 标注来创建 。</p>
<p>扩展模块 <code>dbm.ndbm</code> 和 <code>dbm.gnu</code> 提供了额外的映射类型示例，<code>collections</code> 模块也是如此。</p>
<p>在 3.7 版更改: 在 Python 3.6 版之前字典不会保留插入顺序。 在 CPython 3.6 中插入顺序会被保留，但这在当时被当作是一个实现细节而非确定的语言特性。</p>
</li>
</ul>
<p>可调用类型</p>
<p>此类型可以被应用于函数调用操作 :</p>
<ul>
<li><p>用户定义函数</p>
<p>用户定义函数对象可通过函数定义来创建 。它被调用时应附带一个参数列表，其中包含的条目应与函数所定义的形参列表一致。</p>
<p>特殊属性:</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">含意</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>doc</code></td>
<td align="left">该函数的文档字符串，没有则为 <code>None</code>；不会被子类继承。</td>
<td align="left">可写</td>
</tr>
<tr>
<td align="left"><code>name</code></td>
<td align="left">该函数的名称。</td>
<td align="left">可写</td>
</tr>
<tr>
<td align="left"><code>qualname</code></td>
<td align="left">该函数的 qualified name。3.3 新版功能.</td>
<td align="left">可写</td>
</tr>
<tr>
<td align="left"><code>module</code></td>
<td align="left">该函数所属模块的名称，没有则为 <code>None</code>。</td>
<td align="left">可写</td>
</tr>
<tr>
<td align="left"><code>defaults</code></td>
<td align="left">由具有默认值的参数的默认参数值组成的元组，如无任何参数具有默认值则为 <code>None</code>。</td>
<td align="left">可写</td>
</tr>
<tr>
<td align="left"><code>code</code></td>
<td align="left">表示编译后的函数体的代码对象。</td>
<td align="left">可写</td>
</tr>
<tr>
<td align="left"><code>globals</code></td>
<td align="left">对存放该函数中全局变量的字典的引用 —- 函数所属模块的全局命名空间。</td>
<td align="left">只读</td>
</tr>
<tr>
<td align="left"><code>dict</code></td>
<td align="left">命名空间支持的函数属性。</td>
<td align="left">可写</td>
</tr>
<tr>
<td align="left"><code>closure</code></td>
<td align="left"><code>None</code> 或包含该函数可用变量的绑定的单元的元组。有关 <code>cell contents</code> <em>属性的详情见下。</em></td>
<td align="left">只读</td>
</tr>
<tr>
<td align="left"><code>annotations</code></td>
<td align="left">包含形参标注的字典。 字典的键是形参名，而如果提供了 <code>‘return’</code> 则是用于返回值标注。</td>
<td align="left">可写</td>
</tr>
<tr>
<td align="left"><code>_kwdefaults</code></td>
<td align="left">仅包含关键字参数默认值的字典。</td>
<td align="left">可写</td>
</tr>
</tbody></table>
<p>大部分标有 “Writable” 的属性均会检查赋值的类型。</p>
<p>函数对象也支持获取和设置任意属性，例如这可以被用来给函数附加元数据。使用正规的属性点号标注获取和设置此类属性。<em>注意当前实现仅支持用户定义函数属性。未来可能会增加支持内置函数属性。</em></p>
<p>单元对象具有 <code>cell_contents</code> 属性。这可被用来获取以及设置单元的值。</p>
<p>有关函数定义的额外信息可以从其代码对象中提取；参见下文对内部类型的描述。 <code>cell</code> 类型可以在 <code>types</code> 模块中访问。</p>
<p>实例方法</p>
<p>实例方法用于结合类、类实例和任何可调用对象 (通常为用户定义函数)。</p>
<p>特殊的只读属性: <code>__self__</code> 为类实例对象本身，<code>__func__</code> 为函数对象；<code>__doc__</code> 为方法的文档 (与 <code>__func__.__doc__</code> 作用相同)；<code>__name__</code> 为方法名称 (与 <code>__func__.__name__</code> 作用相同)；<code>__module__</code> 为方法所属模块的名称，没有则为 <code>None</code>。</p>
<p>方法还支持获取 (但不能设置) 下层函数对象的任意函数属性。</p>
<p>用户定义方法对象可在获取一个类的属性时被创建 (也可能通过该类的一个实例)，如果该属性为用户定义函数对象或类方法对象。</p>
<p>当通过从类实例获取一个用户定义函数对象的方式创建一个实例方法对象时，类实例对象的 <code>__self__</code> 属性即为该实例，并会绑定方法对象。该新建方法的 <code>__func__</code> 属性就是原来的函数对象。</p>
<p>当通过从类或实例获取一个类方法对象的方式创建一个实例对象时，实例对象的 <code>__self__</code> 属性为该类本身，其 <code>__func__</code> 属性为类方法对应的下层函数对象。</p>
<p>当一个实例方法对象被调用时，会调用对应的下层函数 (<code>__func__</code>)，并将类实例 (<code>__self__</code>) 插入参数列表的开头。例如，当 <code>C</code> 是一个包含了 <code>f()</code> 函数定义的类，而 <code>x</code> 是 <code>C</code> 的一个实例，则调用 <code>x.f(1)</code> 就等同于调用 <code>C.f(x, 1)</code>。</p>
<p>当一个实例方法对象是衍生自一个类方法对象时，保存在 <code>__self__</code> 中的 “类实例” 实际上会是该类本身，因此无论是调用 <code>x.f(1)</code> 还是 <code>C.f(1)</code> 都等同于调用 <code>f(C,1)</code>，其中 <code>f</code> 为对应的下层函数。</p>
<p>请注意从函数对象到实例方法对象的变换会在每一次从实例获取属性时发生。在某些情况下，一种高效的优化方式是将属性赋值给一个本地变量并调用该本地变量。还要注意这样的变换只发生于用户定义函数；其他可调用对象 (以及所有不可调用对象) 在被获取时都不会发生变换。还有一个需要关注的要点是作为一个类实例属性的用户定义函数不会被转换为绑定方法；这样的变换 <em>仅当</em> 函数是类属性时才会发生。</p>
<p>生成器函数</p>
<p>一个使用 <code>yield</code> 语句 的函数或方法被称作一个 <em>生成器函数</em>。 这样的函数在被调用时，总是返回一个可以执行函数体的迭代器对象：调用该迭代器的 <code>iterator.__next__()</code> 方法将会导致这个函数一直运行直到它使用 <code>yield</code> 语句提供了一个值为止。 当这个函数执行 <code>return</code> 语句或者执行到末尾时，将引发 <code>StopIteration</code> 异常并且这个迭代器将到达所返回的值集合的末尾。</p>
<p>协程函数</p>
<p>使用 <code>async def</code> 来定义的函数或方法就被称为 <em>协程函数</em>。这样的函数在被调用时会返回一个 coroutine 对象。它可能包含 <code>await</code> 表达式以及 <code>async with</code> 和 <code>async for</code> 语句。</p>
<p>异步生成器函数</p>
<p>使用 <code>async def</code> 来定义并包含 <code>yield</code> 语句的函数或方法就被称为 <em>异步生成器函数</em>。这样的函数在被调用时会返回一个异步迭代器对象，该对象可在 <code>async for</code> 语句中用来执行函数体。</p>
<p>调用异步迭代器的 <code>aiterator.__anext__()</code> 方法将会返回一个 awaitable，此对象会在被等待时执行直到使用 <code>yield</code> 表达式输出一个值。当函数执行时到空的 <code>return</code> 语句或是最后一条语句时，将会引发 <code>StopAsyncIteration</code> 异常，异步迭代器也会到达要输出的值集合的末尾。</p>
<p>内置函数</p>
<p>内置函数对象是对于 C 函数的外部封装。内置函数的例子包括 <code>len()</code> 和 <code>math.sin()</code> (<code>math</code> 是一个标准内置模块)。内置函数参数的数量和类型由 C 函数决定。特殊的只读属性: <code>__doc__</code> 是函数的文档字符串，如果没有则为 <code>None</code>; <code>__name__</code> 是函数的名称; <code>__self__</code> 设定为 <code>None</code> (参见下一条目); <code>__module__</code> 是函数所属模块的名称，如果没有则为 <code>None</code>。</p>
<p>内置方法</p>
<p>此类型实际上是内置函数的另一种形式，只不过还包含了一个传入 C 函数的对象作为隐式的额外参数。内置方法的一个例子是 <code>alist.append()</code>，其中 <em>alist</em> 为一个列表对象。在此示例中，特殊的只读属性 <code>__self__</code> 会被设为 <em>alist</em> 所标记的对象。</p>
<p>类</p>
<p>类是可调用的。此种对象通常是作为“工厂”来创建自身的实例，类也可以有重载 <code>__new__()</code> 的变体类型。调用的参数会传给 <code>__new__()</code>，而且通常也会传给 <code>__init__()</code> 来初始化新的实例。</p>
<p>类实例</p>
<p>任意类的实例通过在所属类中定义 <code>__call__()</code> 方法即能成为可调用的对象。</p>
</li>
</ul>
<p>模块</p>
<p>模块是 Python 代码的基本组织单元，由 导入系统 创建，由 <code>import</code> 语句发起调用，或者通过 <code>importlib.import_module()</code> 和内置的 <code>__import__()</code> 等函数发起调用。 模块对象具有由字典对象实现的命名空间（这是被模块中定义的函数的 <code>__globals__</code> 属性引用的字典）。 属性引用被转换为该字典中的查找，例如 <code>m.x</code> 相当于 <code>m.__dict__["x"]</code>。 模块对象不包含用于初始化模块的代码对象（因为初始化完成后不需要它）。</p>
<p>属性赋值会更新模块的命名空间字典，例如 <code>m.x = 1</code> 等同于 <code>m.__dict__["x"] = 1</code>。</p>
<p>预先定义的（可写）属性:</p>
<blockquote>
<ul>
<li><p><code>__name__</code></p>
<p>模块的名称。</p>
<p><code>__doc__</code></p>
<p>模块的文档字符串，如果不可用则为 <code>None</code>。</p>
<p><code>__file__</code></p>
<p>被加载模块所对应文件的路径名称，如果它是从文件加载的话。 对于某些类型的模块来说 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/e6a440f13a5f432a.md#file__" target="_blank" rel="noopener"><code>__file__</code></a> 属性可能是缺失的，例如被静态链接到解释器中的 C 模块。 对于从共享库动态加载的扩展模块来说，它将是共享库文件的路径名称。</p>
<p><code>__annotations__</code></p>
<p>包含在模块体执行期间收集的 变量标注 的字典。</p>
</li>
</ul>
</blockquote>
<p>特殊的只读属性: <code>__dict__</code> 为以字典对象表示的模块命名空间。</p>
<p><strong>CPython implementation detail:</strong> 由于 CPython 清理模块字典的设定，当模块离开作用域时模块字典将会被清理，即使该字典还有活动的引用。想避免此问题，可复制该字典或保持模块状态以直接使用其字典。</p>
<p>自定义类</p>
<p>自定义类这种类型一般通过类定义来创建。每个类都有通过一个字典对象实现的独立命名空间。类属性引用会被转化为在此字典中查找，例如 <code>C.x</code> 会被转化为 <code>C.__dict__["x"]</code> (不过也存在一些钩子对象以允许其他定位属性的方式)。当未在其中发现某个属性名称时，会继续在基类中查找。这种基类查找使用 C3 方法解析顺序，即使存在 ‘钻石形’ 继承结构即有多条继承路径连到一个共同祖先也能保持正确的行为。有关 Python 使用的 C3 MRO 的详情可查看配合 2.3 版发布的文档 <a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="noopener">https://www.python.org/download/releases/2.3/mro/</a>.</p>
<p>当一个类属性引用 (假设类名为 <code>C</code>) 会产生一个类方法对象时，它将转化为一个 <code>__self__</code> 属性为 <code>C</code> 的实例方法对象。当其会产生一个静态方法对象时，它将转化为该静态方法对象所封装的对象。</p>
<p>类属性赋值会更新类的字典，但不会更新基类的字典。</p>
<p>类对象可被调用 (见上文) 以产生一个类实例 (见下文)。</p>
<p>特殊属性:</p>
<blockquote>
<ul>
<li><p><code>__name__</code></p>
<p>类的名称。</p>
<p><code>__module__</code></p>
<p>类定义所在模块的名称。</p>
<p><code>__dict__</code></p>
<p>包含类命名空间的字典。</p>
<p><code>__bases__</code></p>
<p>包含基类的元组，按它们在基类列表中的出现先后排序。</p>
<p><code>__doc__</code></p>
<p>类的文档字符串，如果未定义则为 <code>None</code>。</p>
<p><code>__annotations__</code></p>
<p>包含在类体执行期间收集的 变量标注 的字典。</p>
</li>
</ul>
</blockquote>
<p>类实例</p>
<p>类实例可通过调用类对象来创建 (见上文)。每个类实例都有通过一个字典对象实现的独立命名空间，属性引用会首先在此字典中查找。当未在其中发现某个属性，而实例对应的类中有该属性时，会继续在类属性中查找。如果找到的类属性为一个用户定义函数对象，它会被转化为实例方法对象，其 <code>__self__</code> 属性即该实例。静态方法和类方法对象也会被转化；参见上文 “Classes” 一节。这样得到的属性可能与实际存放于类的 <code>__dict__</code> 中的对象不同。如果未找到类属性，而对象对应的类具有 <code>__getattr__()</code> 方法，则会调用该方法来满足查找要求。</p>
<p>属性赋值和删除会更新实例的字典，但不会更新对应类的字典。如果类具有 <code>__setattr__()</code> 或 <code>__delattr__()</code> 方法，则将调用方法而不再直接更新实例的字典。</p>
<p>如果类实例具有某些特殊名称的方法，就可以伪装为数字、序列或映射。</p>
<p>特殊属性: <code>__dict__</code> 为属性字典; <code>__class__</code> 为实例对应的类。</p>
<p>I/O 对象 (或称文件对象)</p>
<p>file object 表示一个打开的文件。有多种快捷方式可用来创建文件对象: <code>open()</code> 内置函数，以及 <code>os.popen()</code>, <code>os.fdopen()</code> 和 socket 对象的 <code>makefile()</code> 方法 (还可能使用某些扩展模块所提供的其他函数或方法)。</p>
<p><code>sys.stdin</code>, <code>sys.stdout</code> 和 <code>sys.stderr</code> 会初始化为对应于解释器标准输入、输出和错误流的文件对象；它们都会以文本模式打开，因此都遵循 <code>io.TextIOBase</code> 抽象类所定义的接口。</p>
<p>内部类型</p>
<p>某些由解释器内部使用的类型也被暴露给用户。它们的定义可能随未来解释器版本的更新而变化，为内容完整起见在此处一并介绍。</p>
<ul>
<li><p>代码对象</p>
<p>代码对象表示 <em>编译为字节的</em> 可执行 Python 代码，或称 bytecode。代码对象和函数对象的区别在于函数对象包含对函数全局对象 (函数所属的模块) 的显式引用，而代码对象不包含上下文；而且默认参数值会存放于函数对象而不是代码对象内 (因为它们表示在运行时算出的值)。与函数对象不同，代码对象不可变，也不包含对可变对象的引用 (不论是直接还是间接)。</p>
<p>特殊的只读属性: <code>co_name</code> 给出了函数名; <code>co_argcount</code> 为位置参数的总数量 (包括仅限位置参数和带有默认值的参数); <code>co_posonlyargcount</code> 为仅限位置参数的数量 (包括带有默认值的参数); <code>co_kwonlyargcount</code> 为仅限关键字参数的数量 (包括带有默认值的参数); <code>co_nlocals</code> 为函数使用的局部变量的数量 (包括参数); <code>co_varnames</code> 为一个包含局部变量名称的元组 (参数名排在最前面); <code>co_cellvars</code> 为一个包含被嵌套函数所引用的局部变量名称的元组; <code>co_freevars</code> 为一个包含自由变量名称的元组; <code>co_code</code> 为一个表示字节码指令序列的字符口中; <code>co_consts</code> 为一个包含字节码所使用的字面值的元组; <code>co_names</code> 为一个包含字节码所使用的名称的元组; <code>co_filename</code> 为被编码代码所在的文件名; <code>co_firstlineno</code> 为函数首行的行号; <code>co_lnotab</code> 为一个字符串，其中编码了从字节码偏移量到行号的映射 (详情参见解释器的源代码); <code>co_stacksize</code> 为要求的栈大小; <code>co_flags</code> 为一个整数，其中编码了解释器所用的多个旗标。</p>
<p>以下是可用于 <code>co_flags</code> 的标志位定义：如果函数使用 <code>*arguments</code> 语法来接受任意数量的位置参数，则 <code>0x04</code> 位被设置；如果函数使用 <code>**keywords</code> 语法来接受任意数量的关键字参数，则 <code>0x08</code> 位被设置；如果函数是一个生成器，则 <code>0x20</code> 位被设置。</p>
<p>未来特性声明 (<code>from __future__ import division</code>) 也使用 <code>co_flags</code> 中的标志位来指明代码对象的编译是否启用特定的特性: 如果函数编译时启用未来除法特性则设置 <code>0x2000</code> 位; 在更早的 Python 版本中则使用 <code>0x10</code> 和 <code>0x1000</code> 位。</p>
<p><code>co_flags</code> 中的其他位被保留为内部使用。</p>
<p>如果代码对象表示一个函数，<code>co_consts</code> 中的第一项将是函数的文档字符串，如果未定义则为 <code>None</code>。</p>
</li>
<li><p>帧对象</p>
<p>帧对象表示执行帧。它们可能出现在回溯对象中 (见下文)，还会被传递给注册跟踪函数。</p>
<p>特殊的只读属性: <code>f_back</code> 为前一堆栈帧 (指向调用者)，如是最底层堆栈帧则为 <code>None</code>; <code>f_code</code> 为此帧中所执行的代码对象; <code>f_locals</code> 为用于查找本地变量的字典; <code>f_globals</code> 则用于查找全局变量; <code>f_builtins</code> 用于查找内置 (固有) 名称; <code>f_lasti</code> 给出精确指令 (这是代码对象的字节码字符串的一个索引)。</p>
<p>访问 <code>f_code</code> 会引发一个 审计事件 <code>object.__getattr__</code>，附带参数 <code>obj</code> 和 <code>"f_code"</code>。</p>
<p>特殊的可写属性: <code>f_trace</code>，如果不为 <code>None</code>，则是在代码执行期间调用各类事件的函数 (由调试器使用)。通常每个新源码行会触发一个事件 - 这可以通过将 <code>f_trace_lines</code> 设为 <code>False</code> 来禁用。</p>
<p>具体的实现 <em>可能</em> 会通过将 <code>f_trace_opcodes</code> 设为 <code>True</code> 来允许按操作码请求事件。请注意如果跟踪函数引发的异常逃逸到被跟踪的函数中，这可能会导致未定义的解释器行为。</p>
<p><code>f_lineno</code> 为帧的当前行号 —- 在这里写入从一个跟踪函数内部跳转的指定行 (仅用于最底层的帧)。调试器可以通过写入 f_lineno 实现一个 Jump 命令 (即设置下一语句)。</p>
<p>帧对象支持一个方法:</p>
<ul>
<li><p><code>frame.clear</code>()</p>
<p>此方法清除该帧持有的全部对本地变量的引用。而且如果该帧属于一个生成器，生成器会被完成。这有助于打破包含帧对象的循环引用 (例如当捕获一个异常并保存其回溯在之后使用)。</p>
<p>如果该帧当前正在执行则会引发 <code>RuntimeError</code>。</p>
<p>3.4 新版功能.</p>
</li>
</ul>
</li>
<li><p>回溯对象</p>
<p>回溯对象表示一个异常的栈跟踪记录。当异常发生时会隐式地创建一个回溯对象，也可能通过调用 <code>types.TracebackType</code> 显式地创建。</p>
<p>对于隐式地创建的回溯对象，当查找异常句柄使得执行栈展开时，会在每个展开层级的当前回溯之前插入一个回溯对象。当进入一个异常句柄时，栈跟踪将对程序启用。 它可作为 <code>sys.exc_info()</code> 所返回的元组的第三项，以及所捕获异常的 <code>__traceback__</code> 属性被获取。</p>
<p>当程序不包含可用的句柄时，栈跟踪会 (以良好的格式) 写入标准错误流；如果解释器处于交互模式，它也可作为 <code>sys.last_traceback</code> 对用户启用。</p>
<p>对于显式创建的回溯对象，则由回溯对象的创建者来决定应该如何链接 <code>tb_next</code> 属性来构成完整的栈跟踪。</p>
<p>特殊的只读属性: <code>tb_frame</code> 指向当前层级的执行帧; <code>tb_lineno</code> 给出发生异常所在的行号; <code>tb_lasti</code> 标示具体指令。如果异常发生于没有匹配的 except 子句或有 finally 子句的 <code>try</code> 语句中，回溯对象中的行号和最后指令可能与相应帧对象中行号不同。</p>
<p>访问 <code>tb_frame</code> 会引发一个 审计事件 <code>object.__getattr__</code>，附带参数 <code>obj</code> 和 <code>"tb_frame"</code>。</p>
<p>特殊的可写属性: <code>tb_next</code> 为栈跟踪中的下一层级 (通往发生异常的帧)，如果没有下一层级则为 <code>None</code>。</p>
<p>在 3.7 版更改: 回溯对象现在可以使用 Python 代码显式地实例化，现有实例的 <code>tb_next</code> 属性可以被更新。</p>
<p>切片对象</p>
<p>切片对象用来表示 <code>__getitem__()</code> 方法用到的切片。 该对象也可使用内置的 <code>slice()</code> 函数来创建。</p>
<p>特殊的只读属性: <code>start</code> 为下界; <code>stop</code> 为上界; <code>step</code> 为步长值; 各值如省略则为 <code>None</code>。这些属性可具有任意类型。</p>
<p>切片对象支持一个方法:</p>
<ul>
<li><p><code>slice.indices</code>(<em>self</em>, <em>length</em>)</p>
<p>此方法接受一个整型参数 <em>length</em> 并计算在切片对象被应用到 <em>length</em> 指定长度的条目序列时切片的相关信息应如何描述。 其返回值为三个整型数组成的元组；这些数分别为切片的 <em>start</em> 和 <em>stop</em> 索引号以及 <em>step</em> 步长值。索引号缺失或越界则按照与正规切片相一致的方式处理。</p>
</li>
</ul>
<p>静态方法对象</p>
<p>静态方法对象提供了一种胜过上文所述将函数对象转换为方法对象的方式。 静态方法对象是对任意其他对象的包装器，通常用来包装用户自定义的方法对象。 当从类或类实例获取一个静态方法对象时，实际返回的是经过包装的对象，它不会被进一步转换。 静态方法对象也是可调用对象。 静态方法对象可通过内置的 <code>staticmethod()</code> 构造器来创建。</p>
<p>类方法对象</p>
<p>类方法对象和静态方法一样是对其他对象的封装，会改变从类或类实例获取该对象的方式。类方法对象在此类获取操作中的行为已在上文 “用户定义方法” 一节中描述。类方法对象可通过内置的 <code>classmethod()</code> 构造器来创建。</p>
</li>
</ul>
<h3 id="3-3-特殊方法名称"><a href="#3-3-特殊方法名称" class="headerlink" title="3.3. 特殊方法名称"></a>3.3. 特殊方法名称</h3><p>一个类可以通过定义具有特殊名称的方法来实现由特殊语法所引发的特定操作 (例如算术运算或下标与切片)。这是 Python 实现 <em>操作符重载</em> 的方式，允许每个类自行定义基于操作符的特定行为。例如，如果一个类定义了名为 <code>__getitem__()</code> 的方法，并且 <code>x</code> 为该类的一个实例，则 <code>x[i]</code> 基本就等同于 <code>type(x).__getitem__(x, i)</code>。除非有说明例外情况，在没有定义适当方法的情况下尝试执行一种操作将引发一个异常 (通常为 <code>AttributeError</code> 或 <code>TypeError</code>)。</p>
<p>将一个特殊方法设为 <code>None</code> 表示对应的操作不可用。例如，如果一个类将 <code>__iter__()</code> 设为 <code>None</code>，则该类就是不可迭代的，因此对其实例调用 <code>iter()</code> 将引发一个 <code>TypeError</code> (而不会回退至 <code>__getitem__()</code>).</p>
<p>在实现模拟任何内置类型的类时，很重要的一点是模拟的实现程度对于被模拟对象来说应当是有意义的。例如，提取单个元素的操作对于某些序列来说是适宜的，但提取切片可能就没有意义。(这种情况的一个实例是 W3C 的文档对象模型中的 <code>NodeList</code> 接口。)</p>
<h4 id="3-3-1-基本定制"><a href="#3-3-1-基本定制" class="headerlink" title="3.3.1. 基本定制"></a>3.3.1. 基本定制</h4><p><code>object.__new__</code>(<em>cls</em>[, <em>…</em>])</p>
<p>调用以创建一个 <em>cls</em> 类的新实例。<code>__new__()</code> 是一个静态方法 (因为是特例所以你不需要显式地声明)，它会将所请求实例所属的类作为第一个参数。其余的参数会被传递给对象构造器表达式 (对类的调用)。<code>__new__()</code> 的返回值应为新对象实例 (通常是 <em>cls</em> 的实例)。</p>
<p>典型的实现会附带适宜的参数使用 <code>super().__new__(cls[, ...])</code>，通过超类的 <code>__new__()</code> 方法来创建一个类的新实例，然后根据需要修改新创建的实例再将其返回。</p>
<p>If <code>__new__()</code> is invoked during object construction and it returns an instance of <em>cls</em>, then the new instance’s <code>__init__()</code> method will be invoked like <code>__init__(self[, ...])</code>, where <em>self</em> is the new instance and the remaining arguments are the same as were passed to the object constructor.</p>
<p>如果 <code>__new__()</code> 未返回一个 <em>cls</em> 的实例，则新实例的 <code>__init__()</code> 方法就不会被执行。</p>
<p><code>__new__()</code> 的目的主要是允许不可变类型的子类 (例如 int, str 或 tuple) 定制实例创建过程。它也常会在自定义元类中被重载以便定制类创建过程。</p>
<p><code>object.__init__</code>(<em>self</em>[, <em>…</em>])</p>
<p>在实例 (通过 <code>__new__()</code>) 被创建之后，返回调用者之前调用。其参数与传递给类构造器表达式的参数相同。一个基类如果有 <code>__init__()</code> 方法，则其所派生的类如果也有 <code>__init__()</code> 方法，就必须显式地调用它以确保实例基类部分的正确初始化；例如: <code>super().__init__([args...])</code>.</p>
<p>因为对象是由 <code>__new__()</code> 和 <code>__init__()</code> 协作构造完成的 (由 <code>__new__()</code> 创建，并由 <code>__init__()</code> 定制)，所以 <code>__init__()</code> 返回的值只能是 <code>None</code>，否则会在运行时引发 <code>TypeError</code>。</p>
<p><code>object.__del__</code>(<em>self</em>)</p>
<p>在实例将被销毁时调用。 这还被称为终结器或析构器（不适当）。 如果一个基类具有 <code>__del__()</code> 方法，则其所派生的类如果也有 <code>__del__()</code> 方法，就必须显式地调用它以确保实例基类部分的正确清除。</p>
<p><code>__del__()</code> 方法可以 (但不推荐!) 通过创建一个该实例的新引用来推迟其销毁。这被称为对象 <em>重生</em>。<code>__del__()</code> 是否会在重生的对象将被销毁时再次被调用是由具体实现决定的 ；当前的 CPython 实现只会调用一次。</p>
<p>当解释器退出时不会确保为仍然存在的对象调用 <code>__del__()</code> 方法。</p>
<p>注解</p>
<p><code>del x</code> 并不直接调用 <code>x.__del__()</code> —- 前者会将 <code>x</code> 的引用计数减一，而后者仅会在 <code>x</code> 的引用计数变为零时被调用。</p>
<p><strong>CPython implementation detail:</strong> It is possible for a reference cycle to prevent the reference count of an object from going to zero. In this case, the cycle will be later detected and deleted by the cyclic garbage collector. A common cause of reference cycles is when an exception has been caught in a local variable. The frame’s locals then reference the exception, which references its own traceback, which references the locals of all frames caught in the traceback.</p>
<p>警告</p>
<p>由于调用 <code>__del__()</code> 方法时周边状况已不确定，在其执行期间发生的异常将被忽略，改为打印一个警告到 <code>sys.stderr</code>。特别地：</p>
<ul>
<li><code>__del__()</code> 可在任意代码被执行时启用，包括来自任意线程的代码。如果 <code>__del__()</code> 需要接受锁或启用其他阻塞资源，可能会发生死锁，例如该资源已被为执行 <code>__del__()</code> 而中断的代码所获取。</li>
<li><code>__del__()</code> 可以在解释器关闭阶段被执行。因此，它需要访问的全局变量（包含其他模块）可能已被删除或设为 <code>None</code>。Python 会保证先删除模块中名称以单个下划线打头的全局变量再删除其他全局变量；如果已不存在其他对此类全局变量的引用，这有助于确保导入的模块在 <code>__del__()</code> 方法被调用时仍然可用。</li>
</ul>
<p><code>object.__repr__</code>(<em>self</em>)</p>
<p>由 <code>repr()</code> 内置函数调用以输出一个对象的“官方”字符串表示。如果可能，这应类似一个有效的 Python 表达式，能被用来重建具有相同取值的对象（只要有适当的环境）。如果这不可能，则应返回形式如 <code>&lt;...some useful description...&gt;</code> 的字符串。返回值必须是一个字符串对象。如果一个类定义了 <code>__repr__()</code> 但未定义 <code>__str__()</code>，则在需要该类的实例的“非正式”字符串表示时也会使用 <code>__repr__()</code>。</p>
<p>此方法通常被用于调试，因此确保其表示的内容包含丰富信息且无歧义是很重要的。</p>
<p><code>object.__str__</code>(<em>self</em>)</p>
<p>通过 <code>str(object)</code> 以及内置函数 <code>format()</code> 和 <code>print()</code> 调用以生成一个对象的“非正式”或格式良好的字符串表示。返回值必须为一个 字符串 对象。</p>
<p>此方法与 <code>object.__repr__()</code> 的不同点在于 <code>__str__()</code> 并不预期返回一个有效的 Python 表达式：可以使用更方便或更准确的描述信息。</p>
<p>内置类型 <code>object</code> 所定义的默认实现会调用 <code>object.__repr__()</code>。</p>
<p><code>object.__bytes__</code>(<em>self</em>)</p>
<p>通过 bytes 调用以生成一个对象的字节串表示。这应该返回一个 <code>bytes</code> 对象。</p>
<p><code>object.__format__</code>(<em>self</em>, <em>format_spec</em>)</p>
<p>通过 <code>format()</code> 内置函数、扩展、格式化字符串字面值 的求值以及 <code>str.format()</code> 方法调用以生成一个对象的“格式化”字符串表示。 <em>format_spec</em> 参数为包含所需格式选项描述的字符串。 <em>format_spec</em> 参数的解读是由实现 <code>__format__()</code> 的类型决定的，不过大多数类或是将格式化委托给某个内置类型，或是使用相似的格式化选项语法。</p>
<p>返回值必须为一个字符串对象。</p>
<p>在 3.4 版更改: <code>object</code> 本身的 <strong>format</strong> 方法如果被传入任何非空字符，将会引发一个 <code>TypeError</code>。</p>
<p>在 3.7 版更改: <code>object.__format__(x, '')</code> 现在等同于 <code>str(x)</code> 而不再是 <code>format(str(x), '')</code>。</p>
<p><code>object.__lt__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__le__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__eq__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__ne__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__gt__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__ge__</code>(<em>self</em>, <em>other</em>)</p>
<p>以上这些被称为“富比较”方法。运算符号与方法名称的对应关系如下：<code>x&lt;y</code> 调用 <code>x.__lt__(y)</code>、<code>x&lt;=y</code> 调用 <code>x.__le__(y)</code>、<code>x==y</code> 调用 <code>x.__eq__(y)</code>、<code>x!=y</code> 调用 <code>x.__ne__(y)</code>、<code>x&gt;y</code> 调用 <code>x.__gt__(y)</code>、<code>x&gt;=y</code> 调用 <code>x.__ge__(y)</code>。</p>
<p>如果指定的参数对没有相应的实现，富比较方法可能会返回单例对象 <code>NotImplemented</code>。按照惯例，成功的比较会返回 <code>False</code> 或 <code>True</code>。不过实际上这些方法可以返回任意值，因此如果比较运算符是要用于布尔值判断（例如作为 <code>if</code> 语句的条件），Python 会对返回值调用 <code>bool()</code> 以确定结果为真还是假。</p>
<p>在默认情况下，<code>object</code> 通过使用 <code>is</code> 来实现 <code>__eq__()</code>，并在比较结果为假值时返回 <code>NotImplemented</code>: <code>True if x is y else NotImplemented</code>。 对于 <code>__ne__()</code>，默认会委托给 <code>__eq__()</code> 并对结果取反，除非结果为 <code>NotImplemented</code>。 比较运算符之间没有其他隐含关系或默认实现；例如，<code>(x&lt;y or x==y)</code> 为真并不意味着 <code>x&lt;=y</code>。 </p>
<p>这些方法并没有对调参数版本（在左边参数不支持该操作但右边参数支持时使用）；而是 <code>__lt__()</code> 和 <code>__gt__()</code> 互为对方的反射， <code>__le__()</code> 和 <code>__ge__()</code> 互为对方的反射，而 <code>__eq__()</code> 和 <code>__ne__()</code> 则是它们自己的反射。如果两个操作数的类型不同，且右操作数类型是左操作数类型的直接或间接子类，则优先选择右操作数的反射方法，否则优先选择左操作数的方法。虚拟子类不会被考虑。</p>
<p><code>object.__hash__</code>(<em>self</em>)</p>
<p>通过内置函数 <code>hash()</code> 调用以对哈希集的成员进行操作，属于哈希集的类型包括 <code>set</code>、<code>frozenset</code> 以及 <code>dict</code>。<code>__hash__()</code> 应该返回一个整数。对象比较结果相同所需的唯一特征属性是其具有相同的哈希值；建议的做法是把参与比较的对象全部组件的哈希值混在一起，即将它们打包为一个元组并对该元组做哈希运算。例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__hash__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    
    <span class="token keyword">return</span> hash<span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span> self<span class="token punctuation">.</span>nick<span class="token punctuation">,</span> self<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注解</p>
<p><code>hash()</code> 会从一个对象自定义的 <code>__hash__()</code> 方法返回值中截断为 <code>Py_ssize_t</code> 的大小。通常对 64 位构建为 8 字节，对 32 位构建为 4 字节。如果一个对象的 <code>__hash__()</code> 必须在不同位大小的构建上进行互操作，请确保检查全部所支持构建的宽度。做到这一点的简单方法是使用 <code>python -c "import sys; print(sys.hash_info.width)"</code>。</p>
<p>如果一个类没有定义 <code>__eq__()</code> 方法，那么也不应该定义 <code>__hash__()</code> 操作；如果它定义了 <code>__eq__()</code> 但没有定义 <code>__hash__()</code>，则其实例将不可被用作可哈希集的项。如果一个类定义了可变对象并实现了 <code>__eq__()</code> 方法，则不应该实现 <code>__hash__()</code>，因为可哈希集的实现要求键的哈希集是不可变的（如果对象的哈希值发生改变，它将处于错误的哈希桶中）。</p>
<p>用户定义的类默认带有 <code>__eq__()</code> 和 <code>__hash__()</code> 方法；使用它们与任何对象（自己除外）比较必定不相等，并且 <code>x.__hash__()</code> 会返回一个恰当的值以确保 <code>x == y</code> 同时意味着 <code>x is y</code> 且 <code>hash(x) == hash(y)</code>。</p>
<p>一个类如果重载了 <code>__eq__()</code> 且没有定义 <code>__hash__()</code> 则会将其 <code>__hash__()</code> 隐式地设为 <code>None</code>。当一个类的 <code>__hash__()</code> 方法为 <code>None</code> 时，该类的实例将在一个程序尝试获取其哈希值时正确地引发 <code>TypeError</code>，并会在检测 <code>isinstance(obj, collections.abc.Hashable)</code> 时被正确地识别为不可哈希对象。</p>
<p>如果一个重载了 <code>__eq__()</code> 的类需要保留来自父类的 <code>__hash__()</code> 实现，则必须通过设置 <code>__hash__ = &lt;ParentClass&gt;.__hash__</code> 来显式地告知解释器。</p>
<p>如果一个没有重载 <code>__eq__()</code> 的类需要去掉哈希支持，则应该在类定义中包含 <code>__hash__ = None</code>。一个自定义了 <code>__hash__()</code> 以显式地引发 <code>TypeError</code> 的类会被 <code>isinstance(obj, collections.abc.Hashable)</code> 调用错误地识别为可哈希对象。</p>
<p>注解</p>
<p>在默认情况下，str 和 bytes 对象的 <code>__hash__()</code> 值会使用一个不可预知的随机值“加盐”。 虽然它们在一个单独 Python 进程中会保持不变，但它们的值在重复运行的 Python 间是不可预测的。</p>
<p>This is intended to provide protection against a denial-of-service caused by carefully-chosen inputs that exploit the worst case performance of a dict insertion, O(n2) complexity. See <a href="http://www.ocert.org/advisories/ocert-2011-003.html" target="_blank" rel="noopener">http://www.ocert.org/advisories/ocert-2011-003.html</a> for details.</p>
<p>改变哈希值会影响集合的迭代次序。Python 也从不保证这个次序不会被改变（通常它在 32 位和 64 位构建上是不一致的）。</p>
<p>在 3.3 版更改: 默认启用哈希随机化。</p>
<p><code>object.__bool__</code>(<em>self</em>)</p>
<p>调用此方法以实现真值检测以及内置的 <code>bool()</code> 操作；应该返回 <code>False</code> 或 <code>True</code>。如果未定义此方法，则会查找并调用 <code>__len__()</code> 并在其返回非零值时视对象的逻辑值为真。如果一个类既未定义 <code>__len__()</code> 也未定义 <code>__bool__()</code> 则视其所有实例的逻辑值为真。</p>
<h4 id="3-3-2-自定义属性访问"><a href="#3-3-2-自定义属性访问" class="headerlink" title="3.3.2. 自定义属性访问"></a>3.3.2. 自定义属性访问</h4><p>可以定义下列方法来自定义对类实例属性访问（<code>x.name</code> 的使用、赋值或删除）的具体含义.</p>
<p><code>object.__getattr__</code>(<em>self</em>, <em>name</em>)</p>
<p>当默认属性访问因引发 <code>AttributeError</code> 而失败时被调用 (可能是调用 <code>__getattribute__()</code> 时由于 <em>name</em> 不是一个实例属性或 <code>self</code> 的类关系树中的属性而引发了 <code>AttributeError</code>；或者是对 <em>name</em> 特性属性调用 <code>__get__()</code> 时引发了 <code>AttributeError</code>)。此方法应当返回（找到的）属性值或是引发一个 <code>AttributeError</code> 异常。</p>
<p>请注意如果属性是通过正常机制找到的，<code>__getattr__()</code> 就不会被调用。（这是在 <code>__getattr__()</code> 和 <code>__setattr__()</code> 之间故意设置的不对称性。）这既是出于效率理由也是因为不这样设置的话 <code>__getattr__()</code> 将无法访问实例的其他属性。要注意至少对于实例变量来说，你不必在实例属性字典中插入任何值（而是通过插入到其他对象）就可以模拟对它的完全控制。请参阅下面的 <code>__getattribute__()</code> 方法了解真正获取对属性访问的完全控制权的办法。</p>
<p><code>object.__getattribute__</code>(<em>self</em>, <em>name</em>)</p>
<p>此方法会无条件地被调用以实现对类实例属性的访问。如果类还定义了 <code>__getattr__()</code>，则后者不会被调用，除非 <code>__getattribute__()</code> 显式地调用它或是引发了 <code>AttributeError</code>。此方法应当返回（找到的）属性值或是引发一个 <code>AttributeError</code> 异常。为了避免此方法中的无限递归，其实现应该总是调用具有相同名称的基类方法来访问它所需要的任何属性，例如 <code>object.__getattribute__(self, name)</code>。</p>
<p>注解</p>
<p>此方法在作为通过特定语法或内置函数隐式地调用的结果的情况下查找特殊方法时仍可能会被跳过。</p>
<p>引发一个 审计事件 <code>object.__getattr__</code>，附带参数 <code>obj</code>, <code>name</code>。</p>
<p><code>object.__setattr__</code>(<em>self</em>, <em>name</em>, <em>value</em>)</p>
<p>此方法在一个属性被尝试赋值时被调用。这个调用会取代正常机制（即将值保存到实例字典）。 <em>name</em> 为属性名称， <em>value</em> 为要赋给属性的值。</p>
<p>如果 <code>__setattr__()</code> 想要赋值给一个实例属性，它应该调用同名的基类方法，例如 <code>object.__setattr__(self, name, value)</code>。</p>
<p>引发一个 审计事件 <code>object.__setattr__</code>，附带参数 <code>obj</code>, <code>name</code>, <code>value</code>。</p>
<p><code>object.__delattr__</code>(<em>self</em>, <em>name</em>)</p>
<p>类似于 <code>__setattr__()</code> 但其作用为删除而非赋值。此方法应该仅在 <code>del obj.name</code> 对于该对象有意义时才被实现。</p>
<p>引发一个 审计事件 <code>object.__delattr__</code>，附带参数 <code>obj</code>, <code>name</code>。</p>
<p><code>object.__dir__</code>(<em>self</em>)</p>
<p>此方法会在对相应对象调用 <code>dir()</code> 时被调用。返回值必须为一个序列。 <code>dir()</code> 会把返回的序列转换为列表并对其排序。</p>
<h5 id="3-3-2-1-自定义模块属性访问"><a href="#3-3-2-1-自定义模块属性访问" class="headerlink" title="3.3.2.1. 自定义模块属性访问"></a>3.3.2.1. 自定义模块属性访问</h5><p>特殊名称 <code>__getattr__</code> 和 <code>__dir__</code> 还可被用来自定义对模块属性的访问。模块层级的 <code>__getattr__</code> 函数应当接受一个参数，其名称为一个属性名，并返回计算结果值或引发一个 <code>AttributeError</code>。如果通过正常查找即 <code>object.__getattribute__()</code> 未在模块对象中找到某个属性，则 <code>__getattr__</code> 会在模块的 <code>__dict__</code> 中查找，未找到时会引发一个 <code>AttributeError</code>。如果找到，它会以属性名被调用并返回结果值。</p>
<p><code>__dir__</code> 函数应当不接受任何参数，并且返回一个表示模块中可访问名称的字符串序列。 此函数如果存在，将会重载一个模块中的标准 <code>dir()</code> 查找。</p>
<p>想要更细致地自定义模块的行为（设置属性和特性属性等待），可以将模块对象的 <code>__class__</code> 属性设置为一个 <code>types.ModuleType</code> 的子类。例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sys
<span class="token keyword">from</span> types <span class="token keyword">import</span> ModuleType
<span class="token keyword">class</span> <span class="token class-name">VerboseModule</span><span class="token punctuation">(</span>ModuleType<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> f<span class="token string">'Verbose {self.__name__}'</span>
    <span class="token keyword">def</span> <span class="token function">__setattr__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> attr<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'Setting {attr}...'</span><span class="token punctuation">)</span>
        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__setattr__<span class="token punctuation">(</span>attr<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
sys<span class="token punctuation">.</span>modules<span class="token punctuation">[</span>__name__<span class="token punctuation">]</span><span class="token punctuation">.</span>__class__ <span class="token operator">=</span> VerboseModule<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>定义模块的 <code>__getattr__</code> 和设置模块的 <code>__class__</code> 只会影响使用属性访问语法进行的查找 — 直接访问模块全局变量（不论是通过模块内的代码还是通过对模块全局字典的引用）是不受影响的。</p>
<p>在 3.5 版更改: <code>__class__</code> 模块属性改为可写。</p>
<p>3.7 新版功能: <code>__getattr__</code> 和 <code>__dir__</code> 模块属性。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0562" target="_blank" rel="noopener"><strong>PEP 562</strong></a> - 模块 <strong>getattr</strong> 和 <strong>dir</strong></p>
<p>描述用于模块的 <code>__getattr__</code> 和 <code>__dir__</code> 函数。</p>
<h5 id="3-3-2-2-实现描述器"><a href="#3-3-2-2-实现描述器" class="headerlink" title="3.3.2.2. 实现描述器"></a>3.3.2.2. 实现描述器</h5><p>以下方法仅当一个包含该方法的类（称为 <em>描述器</em> 类）的实例出现于一个 <em>所有者</em> 类中的时候才会起作用（该描述器必须在所有者类或其某个上级类的字典中）。在以下示例中，“属性”指的是名称为所有者类 <code>__dict__</code> 中的特征属性的键名的属性。</p>
<p><code>object.__get__</code>(<em>self</em>, <em>instance</em>, <em>owner=None</em>)</p>
<p>调用此方法以获取所有者类的属性（类属性访问）或该类的实例的属性（实例属性访问）。 可选的 <em>owner</em> 参数是所有者类而 <em>instance</em> 是被用来访问属性的实例，如果通过 <em>owner</em> 来访问属性则返回 <code>None</code>。</p>
<p>此方法应当返回计算得到的属性值或是引发 <code>AttributeError</code> 异常。</p>
<p><a href="https://www.python.org/dev/peps/pep-0252" target="_blank" rel="noopener"><strong>PEP 252</strong></a> 指明 <code>__get__()</code> 为带有一至二个参数的可调用对象。 Python 自身内置的描述器支持此规格定义；但是，某些第三方工具可能要求必须带两个参数。 Python 自身的 <code>__getattribute__()</code> 实现总是会传入两个参数，无论它们是否被要求提供。</p>
<p><code>object.__set__</code>(<em>self</em>, <em>instance</em>, <em>value</em>)</p>
<p>调用此方法以设置 <em>instance</em> 指定的所有者类的实例的属性为新值 <em>value</em>。</p>
<p>请注意，添加 <code>__set__()</code> 或 <code>__delete__()</code> 会将描述器变成“数据描述器”。 </p>
<p><code>object.__delete__</code>(<em>self</em>, <em>instance</em>)</p>
<p>调用此方法以删除 <em>instance</em> 指定的所有者类的实例的属性。</p>
<p>属性 <code>__objclass__</code> 会被 <code>inspect</code> 模块解读为指定此对象定义所在的类（正确设置此属性有助于动态类属性的运行时内省）。对于可调用对象来说，它可以指明预期或要求提供一个特定类型（或子类）的实例作为第一个位置参数（例如，CPython 会为实现于 C 中的未绑定方法设置此属性）。</p>
<h5 id="3-3-2-3-调用描述器"><a href="#3-3-2-3-调用描述器" class="headerlink" title="3.3.2.3. 调用描述器"></a>3.3.2.3. 调用描述器</h5><p>总的说来，描述器就是具有“绑定行为”的对象属性，其属性访问已被描述器协议中的方法所重载，包括 <code>__get__()</code>, <code>__set__()</code> 和 <code>__delete__()</code>。如果一个对象定义了以上方法中的任意一个，它就被称为描述器。</p>
<p>属性访问的默认行为是从一个对象的字典中获取、设置或删除属性。例如，<code>a.x</code> 的查找顺序会从 <code>a.__dict__['x']</code> 开始，然后是 <code>type(a).__dict__['x']</code>，接下来依次查找 <code>type(a)</code> 的上级基类，不包括元类。</p>
<p>但是，如果找到的值是定义了某个描述器方法的对象，则 Python 可能会重载默认行为并转而发起调用描述器方法。这具体发生在优先级链的哪个环节则要根据所定义的描述器方法及其被调用的方式来决定。</p>
<p>描述器发起调用的开始点是一个绑定 <code>a.x</code>。参数的组合方式依 <code>a</code> 而定:</p>
<p>直接调用</p>
<p>最简单但最不常见的调用方式是用户代码直接发起调用一个描述器方法: <code>x.__get__(a)</code>。</p>
<p>实例绑定</p>
<p>如果绑定到一个对象实例，<code>a.x</code> 会被转换为调用: <code>type(a).__dict__['x'].__get__(a, type(a))</code>。</p>
<p>类绑定</p>
<p>如果绑定到一个类，<code>A.x</code> 会被转换为调用: <code>A.__dict__['x'].__get__(None, A)</code>。</p>
<p>超绑定</p>
<p>如果 <code>a</code> 是 <code>super</code> 的一个实例，则绑定 <code>super(B, obj).m()</code> 会在 <code>obj.__class__.__mro__</code> 中搜索 <code>B</code> 的直接上级基类 <code>A</code> 然后通过以下调用发起调用描述器: <code>A.__dict__['m'].__get__(obj, obj.__class__)</code>。</p>
<p>对于实例绑定，发起描述器调用的优先级取决于定义了哪些描述器方法。 一个描述器可以定义 <code>__get__()</code>, <code>__set__()</code> 和 <code>__delete__()</code> 的任意组合。 如果它没有定义 <code>__get__()</code>，则访问属性将返回描述器对象自身，除非对象的实例字典中有相应属性值。 如果描述器定义了 <code>__set__()</code> 和/或 <code>__delete__()</code>，则它是一个数据描述器；如果以上两种都未定义，则它是一个非数据描述器。 通常，数据描述器会同时定义 <code>__get__()</code> 和 <code>__set__()</code>，而非数据描述器则只有 <code>__get__()</code> 方法。 定义了 <code>__get__()</code> 和 <code>__set__()</code> (和/或 <code>__delete__()</code>) 的数据描述器总是会重载实例字典中的定义。 与之相对地，非数据描述器则可被实例所重载。</p>
<p>Python 方法 (包括 <code>staticmethod()</code> 和 <code>classmethod()</code>) 都是作为非数据描述器来实现的。 因此实例可以重定义并重载方法。 这允许单个实例获得与相同类的其他实例不一样的行为。</p>
<p><code>property()</code> 函数是作为数据描述器来实现的。因此实例不能重载特性属性的行为。</p>
<h5 id="3-3-2-4-slots"><a href="#3-3-2-4-slots" class="headerlink" title="3.3.2.4. slots"></a>3.3.2.4. <strong>slots</strong></h5><p><em><strong>slots</strong></em> 允许我们显式地声明数据成员（例如特征属性）并禁止创建 <em><strong>dict</strong></em> 和 <em><strong>weakref</strong></em> (除非是在 <em><strong>slots</strong></em> 中显式地声明或是在父类中可用。)</p>
<p>相比使用 <em><strong>dict</strong></em> 此方式可以显著地节省空间。 属性查找速度也可得到显著的提升。</p>
<pre><code>object.__slots__</code></pre><p>这个类变量可赋值为字符串、可迭代对象或由实例使用的变量名构成的字符串序列。 <em><strong>slots</strong></em> 会为已声明的变量保留空间，并阻止自动为每个实例创建 <em><strong>dict</strong></em> 和 <em><strong>weakref</strong></em>。</p>
<p><strong>使用 slots 的注意事项</strong></p>
<ul>
<li>当继承自一个未定义 <em><strong>slots</strong></em> 的类时，实例的 <em><strong>dict</strong></em> 和 <em><strong>weakref</strong></em> 属性将总是可访问。</li>
<li>没有 <em><strong>dict</strong></em> 变量，实例就不能给未在 <em><strong>slots</strong></em> 定义中列出的新变量赋值。尝试给一个未列出的变量名赋值将引发 <code>AttributeError</code>。新变量需要动态赋值，就要将 <code>'__dict__'</code> 加入到 <em><strong>slots</strong></em> 声明的字符串序列中。</li>
<li>如果未给每个实例设置 <em><strong>weakref</strong></em> 变量，定义了 <em><strong>slots</strong></em> 的类就不支持对其实际的弱引用。如果需要弱引用支持，就要将 <code>'__weakref__'</code> 加入到 <em><strong>slots</strong></em> 声明的字符串序列中。</li>
<li><em><strong>slots</strong></em> 是通过为每个变量名创建描述器 (实现描述器) 在类层级上实现的。因此，类属性不能被用来为通过 <em><strong>slots</strong></em> 定义的实例变量设置默认值；否则，类属性就会覆盖描述器赋值。</li>
<li><em><strong>slots</strong></em> 声明的作用不只限于定义它的类。在父类中声明的 <em><strong>slots</strong></em> 在其子类中同样可用。不过，子类将会获得 <em><strong>dict</strong></em> 和 <em><strong>weakref</strong></em> 除非它们也定义了 <em><strong>slots</strong></em> (其中应该仅包含对任何 <em>额外</em> 名称的声明位置)。</li>
<li>如果一个类定义的位置在某个基类中也有定义，则由基类位置定义的实例变量将不可访问（除非通过直接从基类获取其描述器的方式）。这会使得程序的含义变成未定义。未来可能会添加一个防止此情况的检查。</li>
<li>非空的 <em><strong>slots</strong></em> 不适用于派生自“可变长度”内置类型例如 <code>int</code>、<code>bytes</code> 和 <code>tuple</code> 的派生类。</li>
<li>任何非字符串可迭代对象都可以被赋值给 <em><strong>slots</strong></em>。映射也可以被使用；不过，未来可能会分别赋给每个键具有特殊含义的值。</li>
<li><em><strong>class</strong></em> 赋值仅在两个类具有相同的 <em><strong>slots</strong></em> 时才会起作用。</li>
<li>带有多个父类声明位置的多重继承也是可用的，但仅允许一个父类具有由声明位置创建的属性（其他基类必须具有空的位置布局） —— 违反规则将引发 <code>TypeError</code>。</li>
<li>如果为 <em><strong>slots</strong></em> 使用了一个迭代器，则会为迭代器的每个值创建描述器。 但是 <em><strong>slots</strong></em> 属性将为一个空迭代器。</li>
</ul>
<h4 id="3-3-3-自定义类创建"><a href="#3-3-3-自定义类创建" class="headerlink" title="3.3.3. 自定义类创建"></a>3.3.3. 自定义类创建</h4><p>当一个类继承其他类时，那个类的 <em><strong>init_subclass</strong></em> 会被调用。这样就可以编写能够改变子类行为的类。这与类装饰器有紧密的关联，但是类装饰器是影响它们所应用的特定类，而 <code>__init_subclass__</code> 则只作用于定义了该方法的类所派生的子类。</p>
<p><em>classmethod</em> <code>object.__init_subclass__</code>(<em>cls</em>)</p>
<p>当所在类派生子类时此方法就会被调用。<em>cls</em> 将指向新的子类。如果定义为一个普通实例方法，此方法将被隐式地转换为类方法。</p>
<p>传入一个新类的关键字参数会被传给父类的 <code>__init_subclass__</code>。为了与其他使用 <code>__init_subclass__</code> 的类兼容，应当根据需要去掉部分关键字参数再将其余的传给基类，例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Philosopher</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init_subclass__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">,</span> default_name<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init_subclass__<span class="token punctuation">(</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
        cls<span class="token punctuation">.</span>default_name <span class="token operator">=</span> default_name
<span class="token keyword">class</span> <span class="token class-name">AustralianPhilosopher</span><span class="token punctuation">(</span>Philosopher<span class="token punctuation">,</span> default_name<span class="token operator">=</span><span class="token string">"Bruce"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>object.__init_subclass__</code> 的默认实现什么都不做，只在带任意参数调用时引发一个错误。</p>
<p>注解</p>
<p>元类提示 <code>metaclass</code> 将被其它类型机制消耗掉，并不会被传给 <code>__init_subclass__</code> 的实现。实际的元类（而非显式的提示）可通过 <code>type(cls)</code> 访问。</p>
<p>3.6 新版功能.</p>
<p>When a class is created, <code>type.__new__()</code> scans the class variables and makes callbacks to those with a <code>__set_name__()</code> hook.</p>
<p><code>object.__set_name__</code>(<em>self</em>, <em>owner</em>, <em>name</em>)</p>
<p>Automatically called at the time the owning class <em>owner</em> is created. The object has been assigned to <em>name</em> in that class:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>
    x <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Automatically calls: x.__set_name__(A, 'x')</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>If the class variable is assigned after the class is created, <code>__set_name__()</code> will not be called automatically. If needed, <code>__set_name__()</code> can be called directly:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>
   <span class="token keyword">pass</span>
c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span>
A<span class="token punctuation">.</span>x <span class="token operator">=</span> c                  <span class="token comment" spellcheck="true"># The hook is not called</span>
c<span class="token punctuation">.</span>__set_name__<span class="token punctuation">(</span>A<span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Manually invoke the hook</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.6 新版功能.</p>
<h5 id="3-3-3-1-元类"><a href="#3-3-3-1-元类" class="headerlink" title="3.3.3.1. 元类"></a>3.3.3.1. 元类</h5><p>默认情况下，类是使用 <code>type()</code> 来构建的。类体会在一个新的命名空间内执行，类名会被局部绑定到 <code>type(name, bases, namespace)</code> 的结果。</p>
<p>类创建过程可通过在定义行传入 <code>metaclass</code> 关键字参数，或是通过继承一个包含此参数的现有类来进行定制。在以下示例中，<code>MyClass</code> 和 <code>MySubclass</code> 都是 <code>Meta</code> 的实例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
<span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span>metaclass<span class="token operator">=</span>Meta<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
<span class="token keyword">class</span> <span class="token class-name">MySubclass</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在类定义内指定的任何其他关键字参数都会在下面所描述的所有元类操作中进行传递。</p>
<p>当一个类定义被执行时，将发生以下步骤:</p>
<ul>
<li>解析 MRO 条目；</li>
<li>确定适当的元类；</li>
<li>准备类命名空间；</li>
<li>执行类主体；</li>
<li>创建类对象。</li>
</ul>
<h5 id="3-3-3-2-解析-MRO-条目"><a href="#3-3-3-2-解析-MRO-条目" class="headerlink" title="3.3.3.2. 解析 MRO 条目"></a>3.3.3.2. 解析 MRO 条目</h5><p>如果在类定义中出现的基类不是 <code>type</code> 的实例，则使用 <code>__mro_entries__</code> 方法对其进行搜索，当找到结果时，它会以原始基类元组做参数进行调用。此方法必须返回类的元组以替代此基类被使用。元组可以为空，在此情况下原始基类将被忽略。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0560" target="_blank" rel="noopener"><strong>PEP 560</strong></a> - 对 typing 模块和泛型类型的核心支持</p>
<h5 id="3-3-3-3-确定适当的元类"><a href="#3-3-3-3-确定适当的元类" class="headerlink" title="3.3.3.3. 确定适当的元类"></a>3.3.3.3. 确定适当的元类</h5><p>为一个类定义确定适当的元类是根据以下规则:</p>
<ul>
<li>如果没有基类且没有显式指定元类，则使用 <code>type()</code>；</li>
<li>如果给出一个显式元类而且 <em>不是</em> <code>type()</code> 的实例，则其会被直接用作元类；</li>
<li>如果给出一个 <code>type()</code> 的实例作为显式元类，或是定义了基类，则使用最近派生的元类。</li>
</ul>
<p>最近派生的元类会从显式指定的元类（如果有）以及所有指定的基类的元类（即 <code>type(cls)</code>）中选取。最近派生的元类应为 <em>所有</em> 这些候选元类的一个子类型。如果没有一个候选元类符合该条件，则类定义将失败并抛出 <code>TypeError</code>。</p>
<h5 id="3-3-3-4-准备类命名空间"><a href="#3-3-3-4-准备类命名空间" class="headerlink" title="3.3.3.4. 准备类命名空间"></a>3.3.3.4. 准备类命名空间</h5><p>一旦确定了适当的元类，则将准备好类命名空间。 如果元类具有 <code>__prepare__</code> 属性，它会以 <code>namespace = metaclass.__prepare__(name, bases, **kwds)</code> 的形式被调用（其中如果有任何额外的关键字参数，则应当来自类定义）。 <code>__prepare__</code> 方法应该被实现为 <code>classmethod()</code>。 <code>__prepare__</code> 所返回的命名空间会被传入 <code>__new__</code>，但是当最终的类对象被创建时，该命名空间会被拷贝到一个新的 <code>dict</code> 中。</p>
<p>如果元类没有 <code>__prepare__</code> 属性，则类命名空间将初始化为一个空的有序映射。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-3115" target="_blank" rel="noopener"><strong>PEP 3115</strong></a> - Python 3000 中的元类</p>
<p>引入 <code>__prepare__</code> 命名空间钩子</p>
<h5 id="3-3-3-5-执行类主体"><a href="#3-3-3-5-执行类主体" class="headerlink" title="3.3.3.5. 执行类主体"></a>3.3.3.5. 执行类主体</h5><p>类主体会以（类似于） <code>exec(body, globals(), namespace)</code> 的形式被执行。普通调用与 <code>exec()</code> 的关键区别在于当类定义发生于函数内部时，词法作用域允许类主体（包括任何方法）引用来自当前和外部作用域的名称。</p>
<p>但是，即使当类定义发生于函数内部时，在类内部定义的方法仍然无法看到在类作用域层次上定义的名称。类变量必须通过实例的第一个形参或类方法来访问，或者是通过下一节中描述的隐式词法作用域的 <code>__class__</code> 引用。</p>
<h5 id="3-3-3-6-创建类对象"><a href="#3-3-3-6-创建类对象" class="headerlink" title="3.3.3.6. 创建类对象"></a>3.3.3.6. 创建类对象</h5><p>一旦执行类主体完成填充类命名空间，将通过调用 <code>metaclass(name, bases, namespace, **kwds)</code> 创建类对象（此处的附加关键字参数与传入 <code>__prepare__</code> 的相同）。</p>
<p>如果类主体中有任何方法引用了 <code>__class__</code> 或 <code>super</code>，这个类对象会通过零参数形式的 <code>super()</code>. <code>__class__</code> 所引用，这是由编译器所创建的隐式闭包引用。这使用零参数形式的 <code>super()</code> 能够正确标识正在基于词法作用域来定义的类，而被用于进行当前调用的类或实例则是基于传递给方法的第一个参数来标识的。</p>
<p><strong>CPython implementation detail:</strong> 在 CPython 3.6 及之后的版本中，<code>__class__</code> 单元会作为类命名空间中的 <code>__classcell__</code> 条目被传给元类。 如果存在，它必须被向上传播给 <code>type.__new__</code> 调用，以便能正确地初始化该类。 如果不这样做，在 Python 3.8 中将引发 <code>RuntimeError</code>。</p>
<p>When using the default metaclass <code>type</code>, or any metaclass that ultimately calls <code>type.__new__</code>, the following additional customization steps are invoked after creating the class object:</p>
<ol>
<li>The <code>type.__new__</code> method collects all of the attributes in the class namespace that define a <code>__set_name__()</code> method;</li>
<li>Those <code>__set_name__</code> methods are called with the class being defined and the assigned name of that particular attribute;</li>
<li>The <code>__init_subclass__()</code> hook is called on the immediate parent of the new class in its method resolution order.</li>
</ol>
<p>在类对象创建之后，它会被传给包含在类定义中的类装饰器（如果有的话），得到的对象将作为已定义的类绑定到局部命名空间。</p>
<p>当通过 <code>type.__new__</code> 创建一个新类时，提供以作为命名空间形参的对象会被复制到一个新的有序映射并丢弃原对象。这个新副本包装于一个只读代理中，后者则成为类对象的 <code>__dict__</code> 属性。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-3135" target="_blank" rel="noopener"><strong>PEP 3135</strong></a> - 新的超类型</p>
<p>描述隐式的 <code>__class__</code> 闭包引用</p>
<h5 id="3-3-3-7-元类的作用"><a href="#3-3-3-7-元类的作用" class="headerlink" title="3.3.3.7. 元类的作用"></a>3.3.3.7. 元类的作用</h5><p>元类的潜在作用非常广泛。已经过尝试的设想包括枚举、日志、接口检查、自动委托、自动特征属性创建、代理、框架以及自动资源锁定/同步等等。</p>
<h4 id="3-3-4-自定义实例及子类检查"><a href="#3-3-4-自定义实例及子类检查" class="headerlink" title="3.3.4. 自定义实例及子类检查"></a>3.3.4. 自定义实例及子类检查</h4><p>以下方法被用来重载 <code>isinstance()</code> 和 <code>issubclass()</code> 内置函数的默认行为。</p>
<p>特别地，元类 <code>abc.ABCMeta</code> 实现了这些方法以便允许将抽象基类（ABC）作为“虚拟基类”添加到任何类或类型（包括内置类型），包括其他 ABC 之中。</p>
<p><code>class.__instancecheck__</code>(<em>self</em>, <em>instance</em>)</p>
<p>如果 <em>instance</em> 应被视为 <em>class</em> 的一个（直接或间接）实例则返回真值。如果定义了此方法，则会被调用以实现 <code>isinstance(instance, class)</code>。</p>
<p><code>class.__subclasscheck__</code>(<em>self</em>, <em>subclass</em>)</p>
<p>Return true 如果 <em>subclass</em> 应被视为 <em>class</em> 的一个（直接或间接）子类则返回真值。如果定义了此方法，则会被调用以实现 <code>issubclass(subclass, class)</code>。</p>
<p>请注意这些方法的查找是基于类的类型（元类）。它们不能作为类方法在实际的类中被定义。这与基于实例被调用的特殊方法的查找是一致的，只有在此情况下实例本身被当作是类。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-3119" target="_blank" rel="noopener"><strong>PEP 3119</strong></a> - 引入抽象基类</p>
<p>新增功能描述，通过 <code>__instancecheck__()</code> 和 <code>__subclasscheck__()</code> 来定制 <code>isinstance()</code> 和 <code>issubclass()</code> 行为，加入此功能的动机是出于向该语言添加抽象基类的内容。</p>
<h4 id="3-3-5-模拟泛型类型"><a href="#3-3-5-模拟泛型类型" class="headerlink" title="3.3.5. 模拟泛型类型"></a>3.3.5. 模拟泛型类型</h4><p>通过定义一个特殊方法，可以实现由 <a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener"><strong>PEP 484</strong></a> 所规定的泛型类语法 (例如 <code>List[int]</code>):</p>
<p><em>classmethod</em> <code>object.__class_getitem__</code>(<em>cls</em>, <em>key</em>)</p>
<p>按照 <em>key</em> 参数指定的类型返回一个表示泛型类的专门化对象。</p>
<p>此方法的查找会基于对象自身，并且当定义于类体内部时，此方法将隐式地成为类方法。请注意，此机制主要是被保留用于静态类型提示，不鼓励在其他场合使用。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0560" target="_blank" rel="noopener"><strong>PEP 560</strong></a> - 对 typing 模块和泛型类型的核心支持</p>
<h4 id="3-3-6-模拟可调用对象"><a href="#3-3-6-模拟可调用对象" class="headerlink" title="3.3.6. 模拟可调用对象"></a>3.3.6. 模拟可调用对象</h4><p><code>object.__call__</code>(<em>self</em>[, <em>args…</em>])</p>
<p>此方法会在实例作为一个函数被“调用”时被调用；如果定义了此方法，则 <code>x(arg1, arg2, ...)</code> 就大致可以被改写为 <code>type(x).__call__(x, arg1, ...)</code>。</p>
<h4 id="3-3-7-模拟容器类型"><a href="#3-3-7-模拟容器类型" class="headerlink" title="3.3.7. 模拟容器类型"></a>3.3.7. 模拟容器类型</h4><p>可以定义下列方法来实现容器对象。 容器通常属于序列（如列表或元组）或映射（如字典），但也存在其他形式的容器。 前几个方法集被用于模拟序列或是模拟映射；两者的不同之处在于序列允许的键应为整数 <em>k</em> 且 <code>0 &lt;= k &lt; N</code> 其中 <em>N</em> 是序列或定义指定区间的项的切片对象的长度。 此外还建议让映射提供 <code>keys()</code>, <code>values()</code>, <code>items()</code>, <code>get()</code>, <code>clear()</code>, <code>setdefault()</code>, <code>pop()</code>, <code>popitem()</code>, <code>copy()</code> 以及 <code>update()</code> 等方法，它们的行为应与 Python 标准字典对象的相应方法类似。 此外 <code>collections.abc</code> 模块提供了一个 <code>MutableMapping</code> 抽象基类以便根据由 <code>__getitem__()</code>, <code>__setitem__()</code>, <code>__delitem__()</code>, 和 <code>keys()</code> 组成的基本集来创建所需的方法。 可变序列还应像 Python 标准列表对象那样提供 <code>append()</code>, <code>count()</code>, <code>index()</code>, <code>extend()</code>, <code>insert()</code>, <code>pop()</code>, <code>remove()</code>, <code>reverse()</code> 和 <code>sort()</code> 等方法。 最后，序列类型还应通过定义下文描述的 <code>__add__()</code>, <code>__radd__()</code>, <code>__iadd__()</code>, <code>__mul__()</code>, <code>__rmul__()</code> 和 <code>__imul__()</code> 等方法来实现加法（指拼接）和乘法（指重复）；它们不应定义其他数值运算符。 此外还建议映射和序列都实现 <code>__contains__()</code> 方法以允许高效地使用 <code>in</code> 运算符；对于映射，<code>in</code> 应该搜索映射的键；对于序列，则应搜索其中的值。 另外还建议映射和序列都实现 <code>__iter__()</code> 方法以允许高效地迭代容器中的条目；对于映射，<code>__iter__()</code> 应当迭代对象的键；对于序列，则应当迭代其中的值。</p>
<p><code>object.__len__</code>(<em>self</em>)</p>
<p>调用此方法以实现内置函数 <code>len()</code>。应该返回对象的长度，以一个 <code>&gt;=</code> 0 的整数表示。此外，如果一个对象未定义 <code>__bool__()</code> 方法而其 <code>__len__()</code> 方法返回值为零，则在布尔运算中会被视为假值。</p>
<p><strong>CPython implementation detail:</strong> 在 CPython 中，要求长度最大为 <code>sys.maxsize</code>。如果长度大于 <code>sys.maxsize</code> 则某些特性 (例如 <code>len()</code>) 可能会引发 <code>OverflowError</code>。要通过真值检测来防止引发 <code>OverflowError</code>，对象必须定义 <code>__bool__()</code> 方法。</p>
<p><code>object.__length_hint__</code>(<em>self</em>)</p>
<p>调用此方法以实现 <code>operator.length_hint()</code>。 应该返回对象长度的估计值（可能大于或小于实际长度）。 此长度应为一个 <code>&gt;=</code> 0 的整数。 返回值也可以为 <code>NotImplemented</code>，这会被视作与 <code>__length_hint__</code> 方法完全不存在时一样处理。 此方法纯粹是为了优化性能，并不要求正确无误。</p>
<p>3.4 新版功能.</p>
<p>注解</p>
<p>切片是通过下述三个专门方法完成的。以下形式的调用</p>
<pre class="line-numbers language-python"><code class="language-python">a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>会为转写为</p>
<pre class="line-numbers language-python"><code class="language-python">a<span class="token punctuation">[</span>slice<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其他形式以此类推。略去的切片项总是以 <code>None</code> 补全。</p>
<p><code>object.__getitem__</code>(<em>self</em>, <em>key</em>)</p>
<p>调用此方法以实现 <code>self[key]</code> 的求值。对于序列类型，接受的键应为整数和切片对象。请注意负数索引（如果类想要模拟序列类型）的特殊解读是取决于 <code>__getitem__()</code> 方法。如果 <em>key</em> 的类型不正确则会引发 <code>TypeError</code> 异常；如果为序列索引集范围以外的值（在进行任何负数索引的特殊解读之后）则应引发 <code>IndexError</code> 异常。对于映射类型，如果 <em>key</em> 找不到（不在容器中）则应引发 <code>KeyError</code> 异常。</p>
<p>注解</p>
<p><code>for</code> 循环在有不合法索引时会期待捕获 <code>IndexError</code> 以便正确地检测到序列的结束。</p>
<p><code>object.__setitem__</code>(<em>self</em>, <em>key</em>, <em>value</em>)</p>
<p>调用此方法以实现向 <code>self[key]</code> 赋值。注意事项与 <code>__getitem__()</code> 相同。为对象实现此方法应该仅限于需要映射允许基于键修改值或添加键，或是序列允许元素被替换时。不正确的 <em>key</em> 值所引发的异常应与 <code>__getitem__()</code> 方法的情况相同。</p>
<p><code>object.__delitem__</code>(<em>self</em>, <em>key</em>)</p>
<p>调用此方法以实现 <code>self[key]</code> 的删除。注意事项与 <code>__getitem__()</code> 相同。为对象实现此方法应该权限于需要映射允许移除键，或是序列允许移除元素时。不正确的 <em>key</em> 值所引发的异常应与 <code>__getitem__()</code> 方法的情况相同。</p>
<p><code>object.__missing__</code>(<em>self</em>, <em>key</em>)</p>
<p>此方法由 <code>dict</code>.<code>__getitem__()</code> 在找不到字典中的键时调用以实现 dict 子类的 <code>self[key]</code>。</p>
<p><code>object.__iter__</code>(<em>self</em>)</p>
<p>此方法在需要为容器创建迭代器时被调用。此方法应该返回一个新的迭代器对象，它能够逐个迭代容器中的所有对象。对于映射，它应该逐个迭代容器中的键。</p>
<p>迭代器对象也需要实现此方法；它们需要返回对象自身。</p>
<p><code>object.__reversed__</code>(<em>self</em>)</p>
<p>此方法（如果存在）会被 <code>reversed()</code> 内置函数调用以实现逆向迭代。它应当返回一个新的以逆序逐个迭代容器内所有对象的迭代器对象。</p>
<p>如果未提供 <code>__reversed__()</code> 方法，则 <code>reversed()</code> 内置函数将回退到使用序列协议 (<code>__len__()</code> 和 <code>__getitem__()</code>)。支持序列协议的对象应当仅在能够提供比 <code>reversed()</code> 所提供的实现更高效的实现时才提供 <code>__reversed__()</code> 方法。</p>
<p>成员检测运算符 (<code>in</code> 和 <code>not in</code>) 通常以对容器进行逐个迭代的方式来实现。 不过，容器对象可以提供以下特殊方法并采用更有效率的实现，这样也不要求对象必须为可迭代对象。</p>
<p><code>object.__contains__</code>(<em>self</em>, <em>item</em>)</p>
<p>调用此方法以实现成员检测运算符。如果 <em>item</em> 是 <em>self</em> 的成员则应返回真，否则返回假。对于映射类型，此检测应基于映射的键而不是值或者键值对。</p>
<p>对于未定义 <code>__contains__()</code> 的对象，成员检测将首先尝试通过 <code>__iter__()</code> 进行迭代，然后再使用 <code>__getitem__()</code> 的旧式序列迭代协议。</p>
<h4 id="3-3-8-模拟数字类型"><a href="#3-3-8-模拟数字类型" class="headerlink" title="3.3.8. 模拟数字类型"></a>3.3.8. 模拟数字类型</h4><p>定义以下方法即可模拟数字类型。特定种类的数字不支持的运算（例如非整数不能进行位运算）所对应的方法应当保持未定义状态。</p>
<p><code>object.__add__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__sub__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__mul__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__matmul__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__truediv__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__floordiv__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__mod__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__divmod__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__pow__</code>(<em>self</em>, <em>other</em>[, <em>modulo</em>])</p>
<p><code>object.__lshift__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__rshift__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__and__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__xor__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__or__</code>(<em>self</em>, <em>other</em>)</p>
<p>调用这些方法来实现二进制算术运算 (<code>+</code>, <code>-</code>, <code>*</code>, <code>@</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>divmod()</code>, <code>pow()</code>, <code>**</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>^</code>, <code>|</code>)。例如，求表达式 <code>x + y</code> 的值，其中 <em>x</em> 是具有 <code>__add__()</code> 方法的类的一个实例，则会调用 <code>x.__add__(y)</code>。<code>__divmod__()</code> 方法应该等价于使用 <code>__floordiv__()</code> 和 <code>__mod__()</code>，它不应该被关联到 <code>__truediv__()</code>。请注意如果要支持三元版本的内置 <code>pow()</code> 函数，则 <code>__pow__()</code> 的定义应该接受可选的第三个参数。</p>
<p>如果这些方法中的某一个不支持与所提供参数进行运算，它应该返回 <code>NotImplemented</code>。</p>
<p><code>object.__radd__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__rsub__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__rmul__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__rmatmul__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__rtruediv__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__rfloordiv__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__rmod__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__rdivmod__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__rpow__</code>(<em>self</em>, <em>other</em>[, <em>modulo</em>])</p>
<p><code>object.__rlshift__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__rrshift__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__rand__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__rxor__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__ror__</code>(<em>self</em>, <em>other</em>)</p>
<p>调用这些方法来实现具有反射（交换）操作数的二进制算术运算 (<code>+</code>, <code>-</code>, <code>*</code>, <code>@</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>divmod()</code>, <code>pow()</code>, <code>**</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>^</code>, <code>|</code>)。这些成员函数仅会在左操作数不支持相应运算且两个操作数类型不同时被调用。例如，求表达式 <code>x - y</code> 的值，其中 <em>y</em> 是具有 <code>__rsub__()</code> 方法的类的一个实例，则当 <code>x.__sub__(y)</code> 返回 <em>NotImplemented</em> 时会调用 <code>y.__rsub__(x)</code>。</p>
<p>请注意三元版的 <code>pow()</code> 并不会尝试调用 <code>__rpow__()</code> (因为强制转换规则会太过复杂)。</p>
<p>注解</p>
<p>如果右操作数类型为左操作数类型的一个子类，且该子类提供了指定运算的反射方法，则此方法将先于左操作数的非反射方法被调用。 此行为可允许子类重载其祖先类的运算符。</p>
<p><code>object.__iadd__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__isub__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__imul__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__imatmul__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__itruediv__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__ifloordiv__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__imod__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__ipow__</code>(<em>self</em>, <em>other</em>[, <em>modulo</em>])</p>
<p><code>object.__ilshift__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__irshift__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__iand__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__ixor__</code>(<em>self</em>, <em>other</em>)</p>
<p><code>object.__ior__</code>(<em>self</em>, <em>other</em>)</p>
<p>调用这些方法来实现扩展算术赋值 (<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>@=</code>, <code>/=</code>, <code>//=</code>, <code>%=</code>, <code>**=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code>)。这些方法应该尝试进行自身操作 (修改 <em>self</em>) 并返回结果 (结果应该但并非必须为 <em>self</em>)。如果某个方法未被定义，相应的扩展算术赋值将回退到普通方法。例如，如果 <em>x</em> 是具有 <code>__iadd__()</code> 方法的类的一个实例，则 <code>x += y</code> 就等价于 <code>x = x.__iadd__(y)</code>。否则就如 <code>x + y</code> 的求值一样选择 <code>x.__add__(y)</code> 和 <code>y.__radd__(x)</code>。在某些情况下，扩展赋值可导致未预期的错误，但此行为实际上是数据模型的一个组成部分。</p>
<p><code>object.__neg__</code>(<em>self</em>)</p>
<p><code>object.__pos__</code>(<em>self</em>)</p>
<p><code>object.__abs__</code>(<em>self</em>)</p>
<p><code>object.__invert__</code>(<em>self</em>)</p>
<p>调用此方法以实现一元算术运算 (<code>-</code>, <code>+</code>, <code>abs()</code> 和 <code>~</code>)。</p>
<p><code>object.__complex__</code>(<em>self</em>)</p>
<p><code>object.__int__</code>(<em>self</em>)</p>
<p><code>object.__float__</code>(<em>self</em>)</p>
<p>调用这些方法以实现内置函数 <code>complex()</code>, <code>int()</code> 和 <code>float()</code>。应当返回一个相应类型的值。</p>
<p><code>object.__index__</code>(<em>self</em>)</p>
<p>调用此方法以实现 <code>operator.index()</code> 以及 Python 需要无损地将数字对象转换为整数对象的场合（例如切片或是内置的 <code>bin()</code>, <code>hex()</code> 和 <code>oct()</code> 函数)。 存在此方法表明数字对象属于整数类型。 必须返回一个整数。</p>
<p>如果未定义 <code>__int__()</code>, <code>__float__()</code> 和 <code>__complex__()</code> 则相应的内置函数 <code>int()</code>, <code>float()</code> 和 <code>complex()</code> 将回退为 <code>__index__()</code>。</p>
<p><code>object.__round__</code>(<em>self</em>[, <em>ndigits</em>])</p>
<p><code>object.__trunc__</code>(<em>self</em>)</p>
<p><code>object.__floor__</code>(<em>self</em>)</p>
<p><code>object.__ceil__</code>(<em>self</em>)</p>
<p>调用这些方法以实现内置函数 <code>round()</code> 以及 <code>math</code> 函数 <code>trunc()</code>, <code>floor()</code> 和 <code>ceil()</code>。 除了将 <em>ndigits</em> 传给 <code>__round__()</code> 的情况之外这些方法的返回值都应当是原对象截断为 <code>Integral</code> (通常为 <code>int</code>)。</p>
<p>如果未定义 <code>__int__()</code> 则内置函数 <code>int()</code> 会回退到 <code>__trunc__()</code>。</p>
<h4 id="3-3-9-with-语句上下文管理器"><a href="#3-3-9-with-语句上下文管理器" class="headerlink" title="3.3.9. with 语句上下文管理器"></a>3.3.9. with 语句上下文管理器</h4><p><em>上下文管理器</em> 是一个对象，它定义了在执行 <code>with</code> 语句时要建立的运行时上下文。 上下文管理器处理进入和退出所需运行时上下文以执行代码块。 通常使用 <code>with</code> 语句（在 with 语句 中描述），但是也可以通过直接调用它们的方法来使用。</p>
<p>上下文管理器的典型用法包括保存和恢复各种全局状态，锁定和解锁资源，关闭打开的文件等等。</p>
<p><code>object.__enter__</code>(<em>self</em>)</p>
<p>进入与此对象相关的运行时上下文。 <code>with</code> 语句将会绑定这个方法的返回值到 <code>as</code> 子句中指定的目标，如果有的话。</p>
<p><code>object.__exit__</code>(<em>self</em>, <em>exc_type</em>, <em>exc_value</em>, <em>traceback</em>)</p>
<p>退出关联到此对象的运行时上下文。 各个参数描述了导致上下文退出的异常。 如果上下文是无异常地退出的，三个参数都将为 <code>None</code>。</p>
<p>如果提供了异常，并且希望方法屏蔽此异常（即避免其被传播），则应当返回真值。 否则的话，异常将在退出此方法时按正常流程处理。</p>
<p>请注意 <code>__exit__()</code> 方法不应该重新引发被传入的异常，这是调用者的责任。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0343" target="_blank" rel="noopener"><strong>PEP 343</strong></a> - “with” 语句</p>
<p>Python <code>with</code> 语句的规范描述、背景和示例。</p>
<h4 id="3-3-10-定制类模式匹配中的位置参数"><a href="#3-3-10-定制类模式匹配中的位置参数" class="headerlink" title="3.3.10. 定制类模式匹配中的位置参数"></a>3.3.10. 定制类模式匹配中的位置参数</h4><p>当在模式中使用类名称时，默认不允许模式中出现位置参数，例如 <code>case MyClass(x, y)</code> 通常是无效的，除非 <code>MyClass</code> 提供了特别支持。 要能使用这样的模式，类必须定义一个 <em><strong>match_args</strong></em> 属性。</p>
<pre><code>object.__match_args__</code></pre><p>该类变量可以被赋值为一个字符串元组。 当该类被用于带位置参数的类模式时，每个位置参数都将被转换为关键字参数，并使用 <em><strong>match_args</strong></em> 中的对应值作为关键字。 缺失此属性就等价于将其设为 <code>()</code>。</p>
<p>举例来说，如果 <code>MyClass.__match_args__</code> 为 <code>("left", "center", "right")</code> 则意味着 <code>case MyClass(x, y)</code> 就等价于 <code>case MyClass(left=x, center=y)</code>。 请注意模式中参数的数量必须小于等于 <em><strong>match_args</strong></em> 中元素的数量；如果前者大于后者，则尝试模式匹配时将引发 <code>TypeError</code>。</p>
<p>3.10 新版功能.</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0634" target="_blank" rel="noopener"><strong>PEP 634</strong></a> - 结构化模式匹配</p>
<p>有关 Python <code>match</code> 语句的规范说明。</p>
<h4 id="3-3-11-特殊方法查找"><a href="#3-3-11-特殊方法查找" class="headerlink" title="3.3.11. 特殊方法查找"></a>3.3.11. 特殊方法查找</h4><p>对于自定义类来说，特殊方法的隐式发起调用仅保证在其定义于对象类型中时能正确地发挥作用，而不能定义在对象实例字典中。 该行为就是以下代码会引发异常的原因。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">pass</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>__len__ <span class="token operator">=</span> <span class="token keyword">lambda</span><span class="token punctuation">:</span> <span class="token number">5</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>c<span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> object of type <span class="token string">'C'</span> has no len<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此行为背后的原理在于包括类型对象在内的所有对象都会实现的几个特殊方法，例如 <code>__hash__()</code> 和 <code>__repr__()</code>。 如果这些方法的隐式查找使用了传统的查找过程，它们会在对类型对象本身发起调用时失败:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token number">1</span> <span class="token punctuation">.</span>__hash__<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> hash<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">.</span>__hash__<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> hash<span class="token punctuation">(</span>int<span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> descriptor <span class="token string">'__hash__'</span> of <span class="token string">'int'</span> object needs an argument<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以这种方式不正确地尝试发起调用一个类的未绑定方法有时被称为‘元类混淆’，可以通过在查找特殊方法时绕过实例的方式来避免:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__hash__<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> hash<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>int<span class="token punctuation">)</span><span class="token punctuation">.</span>__hash__<span class="token punctuation">(</span>int<span class="token punctuation">)</span> <span class="token operator">==</span> hash<span class="token punctuation">(</span>int<span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了为了正确性而绕过任何实例属性之外，隐式特殊方法查找通常也会绕过 <code>__getattribute__()</code> 方法，甚至包括对象的元类:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Meta</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__getattribute__</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Metaclass getattribute invoked"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> type<span class="token punctuation">.</span>__getattribute__<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> metaclass<span class="token operator">=</span>Meta<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token number">10</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__getattribute__</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Class getattribute invoked"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> object<span class="token punctuation">.</span>__getattribute__<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>__len__<span class="token punctuation">(</span><span class="token punctuation">)</span>                 <span class="token comment" spellcheck="true"># Explicit lookup via instance</span>
Class <span class="token class-name">getattribute</span> invoked
<span class="token number">10</span>
<span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span>__len__<span class="token punctuation">(</span>c<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># Explicit lookup via type</span>
Metaclass getattribute invoked
<span class="token number">10</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>c<span class="token punctuation">)</span>                      <span class="token comment" spellcheck="true"># Implicit lookup</span>
<span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以这种方式绕过 <code>__getattribute__()</code> 机制为解析器内部的速度优化提供了显著的空间，其代价则是牺牲了处理特殊方法时的一些灵活性（特殊方法 <em>必须</em> 设置在类对象本身上以便始终一致地由解释器发起调用）。</p>
<h3 id="3-4-协程"><a href="#3-4-协程" class="headerlink" title="3.4. 协程"></a>3.4. 协程</h3><h4 id="3-4-1-可等待对象"><a href="#3-4-1-可等待对象" class="headerlink" title="3.4.1. 可等待对象"></a>3.4.1. 可等待对象</h4><p>awaitable 对象主要实现了 <code>__await__()</code> 方法。 从 <code>async def</code> 函数返回的 协程对象 即属于可等待对象。</p>
<p>注解</p>
<p>从带有 <code>types.coroutine()</code> 或 <code>asyncio.coroutine()</code> 装饰器的生成器返回的 generator iterator 对象也属于可等待对象，但它们并未实现 <code>__await__()</code>。</p>
<p><code>object.__await__</code>(<em>self</em>)</p>
<p>必须返回一个 iterator。 应当被用来实现 awaitable 对象。 例如，<code>asyncio.Future</code> 实现了此方法以与 <code>await</code> 表达式相兼容。</p>
<p>3.5 新版功能.</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 了解有关可等待对象的详细信息。</p>
<h4 id="3-4-2-协程对象"><a href="#3-4-2-协程对象" class="headerlink" title="3.4.2. 协程对象"></a>3.4.2. 协程对象</h4><p>协程对象 属于 awaitable 对象。 协程的执行可通过调用 <code>__await__()</code> 并迭代其结果来控制。 当协程结束执行并返回时，迭代器会引发 <code>StopIteration</code>，该异常的 <code>value</code> 属性将存放返回值。 如果协程引发了异常，它会被迭代器所传播。 协程不应直接引发未处理的 <code>StopIteration</code> 异常。</p>
<p>协程也具有下面列出的方法，它们类似于生成器的对应方法。 但是，与生成器不同，协程并不直接支持迭代。</p>
<p>在 3.5.2 版更改: 等待一个协程超过一次将引发 <code>RuntimeError</code>。</p>
<p><code>coroutine.send</code>(<em>value</em>)</p>
<p>开始或恢复协程的执行。 如果 <em>value</em> 为 <code>None</code>，则这相当于前往 <code>__await__()</code> 所返回迭代器的下一项。 如果 <em>value</em> 不为 <code>None</code>，此方法将委托给导致协程挂起的迭代器的 <code>send()</code> 方法。 其结果（返回值，<code>StopIteration</code> 或是其他异常）将与上述对 <code>__await__()</code> 返回值进行迭代的结果相同。</p>
<p><code>coroutine.throw</code>(<em>type</em>[, <em>value</em>[, <em>traceback</em>]])</p>
<p>在协程内引发指定的异常。 此方法将委托给导致协程挂起的迭代器的 <code>throw()</code> 方法，如果存在该方法。 否则的话，异常会在挂起点被引发。 其结果（返回值，<code>StopIteration</code> 或是其他异常）将与上述对 <code>__await__()</code> 返回值进行迭代的结果相同。 如果异常未在协程内被捕获，则将回传给调用者。</p>
<p><code>coroutine.close</code>()</p>
<p>此方法会使得协程清理自身并退出。 如果协程被挂起，此方法会先委托给导致协程挂起的迭代器的 <code>close()</code> 方法，如果存在该方法。 然后它会在挂起点引发 <code>GeneratorExit</code>，使得协程立即清理自身。 最后，协程会被标记为已结束执行，即使它根本未被启动。</p>
<p>当协程对象将要被销毁时，会使用以上处理过程来自动关闭。</p>
<h4 id="3-4-3-异步迭代器"><a href="#3-4-3-异步迭代器" class="headerlink" title="3.4.3. 异步迭代器"></a>3.4.3. 异步迭代器</h4><p><em>异步迭代器</em> 可以在其 <code>__anext__</code> 方法中调用异步代码。</p>
<p>异步迭代器可在 <code>async for</code> 语句中使用。</p>
<p><code>object.__aiter__</code>(<em>self</em>)</p>
<p>必须返回一个 <em>异步迭代器</em> 对象。</p>
<p><code>object.__anext__</code>(<em>self</em>)</p>
<p>必须返回一个 <em>可迭代对象</em> 输出迭代器的下一结果值。 当迭代结束时应该引发 <code>StopAsyncIteration</code> 错误。</p>
<p>异步可迭代对象的一个示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Reader</span><span class="token punctuation">:</span>
    <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">readline</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">def</span> <span class="token function">__aiter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self
    <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">__anext__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        val <span class="token operator">=</span> <span class="token keyword">await</span> self<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> val <span class="token operator">==</span> b<span class="token string">''</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> StopAsyncIteration
        <span class="token keyword">return</span> val<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p>在 3.7 版更改: 在 Python 3.7 之前，<code>__aiter__</code> 可以返回一个 <em>可迭代对象</em> 并解析为 异步迭代器。</p>
<p>从 Python 3.7 开始，<code>__aiter__</code> 必须 返回一个异步迭代器对象。 返回任何其他对象都将导致 <code>TypeError</code> 错误。</p>
<h4 id="3-4-4-异步上下文管理器"><a href="#3-4-4-异步上下文管理器" class="headerlink" title="3.4.4. 异步上下文管理器"></a>3.4.4. 异步上下文管理器</h4><p><em>异步上下文管理器</em> 是 <em>上下文管理器</em> 的一种，它能够在其 <code>__aenter__</code> 和 <code>__aexit__</code> 方法中暂停执行。</p>
<p>异步上下文管理器可在 <code>async with</code> 语句中使用。</p>
<p><code>object.__aenter__</code>(<em>self</em>)</p>
<p>在语义上类似于 <code>__enter__()</code>，仅有的区别是它必须返回一个 <em>可等待对象</em>。</p>
<p><code>object.__aexit__</code>(<em>self</em>, <em>exc_type</em>, <em>exc_value</em>, <em>traceback</em>)</p>
<p>在语义上类似于 <code>__exit__()</code>，仅有的区别是它必须返回一个 <em>可等待对象</em>。</p>
<p>异步上下文管理器类的一个示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">AsyncContextManager</span><span class="token punctuation">:</span>
    <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">__aenter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">await</span> log<span class="token punctuation">(</span><span class="token string">'entering context'</span><span class="token punctuation">)</span>
    <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">__aexit__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> exc_type<span class="token punctuation">,</span> exc<span class="token punctuation">,</span> tb<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">await</span> log<span class="token punctuation">(</span><span class="token string">'exiting context'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p>注：</p>
<ul>
<li>在某些情况下 <em>有可能</em> 基于可控的条件改变一个对象的类型。 但这通常不是个好主意，因为如果处理不当会导致一些非常怪异的行为。</li>
<li><code>__hash__()</code>, <code>__iter__()</code>, <code>__reversed__()</code> 以及 <code>__contains__()</code> 方法对此有特殊处理；其他方法仍会引发 <code>TypeError</code>，但可能依靠 <code>None</code> 属于不可调用对象的行为来做到这一点。</li>
<li>这里的“不支持”是指该类无此方法，或方法返回 <code>NotImplemented</code>。 如果你想强制回退到右操作数的反射方法，请不要设置方法为 <code>None</code> — 那会造成显式地 <em>阻塞</em> 此种回退的相反效果。</li>
<li>对于相同类型的操作数，如果非反射方法 — 例如 <code>__add__()</code> — 失败则会认为整个运算都不被支持，这就是反射方法未被调用的原因。</li>
</ul>
<h2 id="4-执行模型"><a href="#4-执行模型" class="headerlink" title="4. 执行模型"></a>4. 执行模型</h2><h3 id="4-1-程序的结构"><a href="#4-1-程序的结构" class="headerlink" title="4.1. 程序的结构"></a>4.1. 程序的结构</h3><p>Python 程序是由代码块构成的。 <em>代码块</em> 是被作为一个单元来执行的一段 Python 程序文本。 以下几个都属于代码块：模块、函数体和类定义。 交互式输入的每条命令都是代码块。 一个脚本文件（作为标准输入发送给解释器或是作为命令行参数发送给解释器的文件）也是代码块。 一条脚本命令（通过 <code>-c</code> 选项在解释器命令行中指定的命令）也是代码块。 通过在命令行中使用 <code>-m</code> 参数作为最高层级脚本（即 <code>__main__</code> 模块）运行的模块也是代码块。 传递给内置函数 <code>eval()</code> 和 <code>exec()</code> 的字符串参数也是代码块。</p>
<p>代码块在 <em>执行帧</em> 中被执行。 一个帧会包含某些管理信息（用于调试）并决定代码块执行完成后应前往何处以及如何继续执行。</p>
<h3 id="4-2-命名与绑定"><a href="#4-2-命名与绑定" class="headerlink" title="4.2. 命名与绑定"></a>4.2. 命名与绑定</h3><h4 id="4-2-1-名称的绑定"><a href="#4-2-1-名称的绑定" class="headerlink" title="4.2.1. 名称的绑定"></a>4.2.1. 名称的绑定</h4><p><em>名称</em> 用于指代对象。 名称是通过名称绑定操作来引入的。</p>
<p>以下构造会绑定名称：传给函数的正式形参，<code>import</code> 语句，类与函数定义（这会在定义的代码块中绑定类或函数名称）以及发生以标识符为目标的赋值，<code>for</code> 循环的开头，或 <code>with</code> 语句和 <code>except</code> 子句的 <code>as</code> 之后。 <code>import</code> 语句的 <code>from ... import *</code> 形式会绑定在被导入模块中定义的所有名称，那些以下划线开头的除外。 这种形式仅在模块层级上被使用。</p>
<p><code>del</code> 语句的目标也被视作一种绑定（虽然其实际语义为解除名称绑定）。</p>
<p>每条赋值或导入语句均发生于类或函数内部定义的代码块中，或是发生于模块层级（即最高层级的代码块）。</p>
<p>如果名称绑定在一个代码块中，则为该代码块的局部变量，除非声明为 <code>nonlocal</code> 或 <code>global</code>。 如果名称绑定在模块层级，则为全局变量。 (模块代码块的变量既为局部变量又为全局变量。) 如果变量在一个代码块中被使用但不是在其中定义，则为 <em>自由变量</em>。</p>
<p>每个在程序文本中出现的名称是指由以下名称解析规则所建立的对该名称的 <em>绑定</em>。</p>
<h4 id="4-2-2-名称的解析"><a href="#4-2-2-名称的解析" class="headerlink" title="4.2.2. 名称的解析"></a>4.2.2. 名称的解析</h4><p><em>作用域</em> 定义了一个代码块中名称的可见性。 如果代码块中定义了一个局部变量，则其作用域包含该代码块。 如果定义发生于函数代码块中，则其作用域会扩展到该函数所包含的任何代码块，除非有某个被包含代码块引入了对该名称的不同绑定。</p>
<p>当一个名称在代码块中被使用时，会由包含它的最近作用域来解析。 对一个代码块可见的所有这种作用域的集合称为该代码块的 <em>环境</em>。</p>
<p>当一个名称完全找不到时，将会引发 <code>NameError</code> 异常。 如果当前作用域为函数作用域，且该名称指向一个局部变量，而此变量在该名称被使用的时候尚未绑定到特定值，将会引发 <code>UnboundLocalError</code> 异常。 <code>UnboundLocalError</code> 为 <code>NameError</code> 的一个子类。</p>
<p>如果一个代码块内的任何位置发生名称绑定操作，则代码块内所有对该名称的使用会被认为是对当前代码块的引用。 当一个名称在其被绑定前就在代码块内被使用时则会导致错误。 这个一个很微妙的规则。 Python 缺少声明语法，并允许名称绑定操作发生于代码块内的任何位置。 一个代码块的局部变量可通过在整个代码块文本中扫描名称绑定操作来确定。</p>
<p>如果 <code>global</code> 语句出现在一个代码块中，则所有对该语句所指定名称的使用都是在最高层级命名空间内对该名称绑定的引用。 名称在最高层级命名内的解析是通过全局命名空间，也就是包含该代码块的模块的命名空间，以及内置命名空间即 <code>builtins</code> 模块的命名空间。 全局命名空间会先被搜索。 如果未在其中找到指定名称，再搜索内置命名空间。 <code>global</code> 语句必须位于所有对其所指定名称的使用之前。</p>
<p><code>global</code> 语句与同一代码块中名称绑定具有相同的作用域。 如果一个自由变量的最近包含作用域中有一条 global 语句，则该自由变量也会被当作是全局变量。</p>
<p><code>nonlocal</code> 语句会使得相应的名称指向之前在最近包含函数作用域中绑定的变量。 如果指定名称不存在于任何包含函数作用域中则将在编译时引发 <code>SyntaxError</code>。</p>
<p>模块的作用域会在模块第一次被导入时自动创建。 一个脚本的主模块总是被命名为 <code>__main__</code>。</p>
<p>类定义代码块以及传给 <code>exec()</code> 和 <code>eval()</code> 的参数是名称解析上下文中的特殊情况。 类定义是可能使用并定义名称的可执行语句。 这些引用遵循正常的名称解析规则，例外之处在于未绑定的局部变量将会在全局命名空间中查找。 类定义的命名空间会成为该类的属性字典。 在类代码块中定义的名称的作用域会被限制在类代码块中；它不会扩展到方法的代码块中 — 这也包括推导式和生成器表达式，因为它们都是使用函数作用域实现的。 这意味着以下代码将会失败:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>
    a <span class="token operator">=</span> <span class="token number">42</span>
    b <span class="token operator">=</span> list<span class="token punctuation">(</span>a <span class="token operator">+</span> i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="4-2-3-内置命名空间和受限的执行"><a href="#4-2-3-内置命名空间和受限的执行" class="headerlink" title="4.2.3. 内置命名空间和受限的执行"></a>4.2.3. 内置命名空间和受限的执行</h4><p><strong>CPython implementation detail:</strong> 用户不应该接触 <code>__builtins__</code>，严格说来它属于实现细节。 用户如果要重载内置命名空间中的值则应该 <code>import</code> <code>builtins</code> 并相应地修改该模块中的属性。</p>
<p>与一个代码块的执行相关联的内置命名空间实际上是通过在其全局命名空间中搜索名称 <code>__builtins__</code> 来找到的；这应该是一个字典或一个模块（在后一种情况下会使用该模块的字典）。 默认情况下，当在 <code>__main__</code> 模块中时，<code>__builtins__</code> 就是内置模块 <code>builtins</code>；当在任何其他模块中时，<code>__builtins__</code> 则是 <code>builtins</code> 模块自身的字典的一个别名。</p>
<h4 id="4-2-4-与动态特性的交互"><a href="#4-2-4-与动态特性的交互" class="headerlink" title="4.2.4. 与动态特性的交互"></a>4.2.4. 与动态特性的交互</h4><p>自由变量的名称解析发生于运行时而不是编译时。 这意味着以下代码将打印出 42:</p>
<pre class="line-numbers language-python"><code class="language-python">i <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
i <span class="token operator">=</span> <span class="token number">42</span>
f<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>eval()</code> 和 <code>exec()</code> 函数没有对完整环境的访问权限来解析名称。 名称可以在调用者的局部和全局命名空间中被解析。 自由变量的解析不是在最近包含命名空间中，而是在全局命名空间中。 <code>exec()</code> 和 <code>eval()</code> 函数有可选参数用来重载全局和局部命名空间。 如果只指定一个命名空间，则它会同时作用于两者。</p>
<h3 id="4-3-异常"><a href="#4-3-异常" class="headerlink" title="4.3. 异常"></a>4.3. 异常</h3><p>异常是中断代码块的正常控制流程以便处理错误或其他异常条件的一种方式。 异常会在错误被检测到的位置 <em>引发</em>，它可以被当前包围代码块或是任何直接或间接发起调用发生错误的代码块的其他代码块所 <em>处理</em>。</p>
<p>Python 解析器会在检测到运行时错误（例如零作为被除数）的时候引发异常。 Python 程序也可以通过 <code>raise</code> 语句显式地引发异常。 异常处理是通过 <code>try</code> … <code>except</code> 语句来指定的。 该语句的 <code>finally</code> 子句可被用来指定清理代码，它并不处理异常，而是无论之前的代码是否发生异常都会被执行。</p>
<p>Python 的错误处理采用的是“终止”模型：异常处理器可以找出发生了什么问题，并在外层继续执行，但它不能修复错误的根源并重试失败的操作（除非通过从顶层重新进入出错的代码片段）。</p>
<p>当一个异常完全未被处理时，解释器会终止程序的执行，或者返回交互模式的主循环。 无论是哪种情况，它都会打印栈回溯信息，除非是当异常为 <code>SystemExit</code> 的时候。</p>
<p>异常是通过类实例来标识的。 <code>except</code> 子句会依据实例的类来选择：它必须引用实例的类或是其所属的基类。 实例可通过处理器被接收，并可携带有关异常条件的附加信息。</p>
<p>注解</p>
<p>异常消息不是 Python API 的组成部分。 其内容可能在 Python 升级到新版本时不经警告地发生改变，不应该被需要在多版本解释器中运行的代码所依赖。</p>
<h2 id="5-导入系统"><a href="#5-导入系统" class="headerlink" title="5. 导入系统"></a>5. 导入系统</h2><p>一个 module 内的 Python 代码通过 importing 操作就能够访问另一个模块内的代码。 <code>import</code> 语句是发起调用导入机制的最常用方式，但不是唯一的方式。 <code>importlib.import_module()</code> 以及内置的 <code>__import__()</code> 等函数也可以被用来发起调用导入机制。</p>
<p><code>import</code> 语句结合了两个操作；它先搜索指定名称的模块，然后将搜索结果绑定到当前作用域中的名称。 <code>import</code> 语句的搜索操作被定义为对 <code>__import__()</code> 函数的调用并带有适当的参数。 <code>__import__()</code> 的返回值会被用于执行 <code>import</code> 语句的名称绑定操作。 请参阅 <code>import</code> 语句了解名称绑定操作的更多细节。</p>
<p>对 <code>__import__()</code> 的直接调用将仅执行模块搜索以及在找到时的模块创建操作。 不过也可能产生某些副作用，例如导入父包和更新各种缓存 (包括 <code>sys.modules</code>)，只有 <code>import</code> 语句会执行名称绑定操作。</p>
<p>当 <code>import</code> 语句被执行时，标准的内置 <code>__import__()</code> 函数会被调用。 其他发起调用导入系统的机制 (例如 <code>importlib.import_module()</code>) 可能会选择绕过 <code>__import__()</code> 并使用它们自己的解决方案来实现导入机制。</p>
<p>当一个模块首次被导入时，Python 会搜索该模块，如果找到就创建一个 module 对象 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/e6a440f13a5f432a.md#fnmo" target="_blank" rel="noopener">1</a> 并初始化它。 如果指定名称的模块未找到，则会引发 <code>ModuleNotFoundError</code>。 当发起调用导入机制时，Python 会实现多种策略来搜索指定名称的模块。 这些策略可以通过使用使用下文所描述的多种钩子来加以修改和扩展。</p>
<p>在 3.3 版更改: 导入系统已被更新以完全实现 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a> 中的第二阶段要求。 不会再有任何隐式的导入机制 —— 整个导入系统都通过 <code>sys.meta_path</code> 暴露出来。 此外，对原生命名空间包的支持也已被实现 (参见 <a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a>)。</p>
<h3 id="5-1-importlib"><a href="#5-1-importlib" class="headerlink" title="5.1. importlib"></a>5.1. <code>importlib</code></h3><p><code>importlib</code> 模块提供了一个丰富的 API 用来与导入系统进行交互。 例如 <code>importlib.import_module()</code> 提供了相比内置的 <code>__import__()</code> 更推荐、更简单的 API 用来发起调用导入机制。 </p>
<h3 id="5-2-包"><a href="#5-2-包" class="headerlink" title="5.2. 包"></a>5.2. 包</h3><p>Python 只有一种模块对象类型，所有模块都属于该类型，无论模块是用 Python、C 还是别的语言实现。 为了帮助组织模块并提供名称层次结构，Python 还引入了 包 的概念。</p>
<p>你可以把包看成是文件系统中的目录，并把模块看成是目录中的文件，但请不要对这个类比做过于字面的理解，因为包和模块不是必须来自于文件系统。 为了方便理解本文档，我们将继续使用这种目录和文件的类比。 与文件系统一样，包通过层次结构进行组织，在包之内除了一般的模块，还可以有子包。</p>
<p>要注意的一个重点概念是所有包都是模块，但并非所有模块都是包。 或者换句话说，包只是一种特殊的模块。 特别地，任何具有 <code>__path__</code> 属性的模块都会被当作是包。</p>
<p>所有模块都有自己的名字。 子包名与其父包名以点号分隔，与 Python 的标准属性访问语法一致。 例如你可能看到一个名为 <code>sys</code> 的模块以及一个名为 <code>email</code> 的包，这个包中又有一个名为 <code>email.mime</code> 的子包和该子包中的名为 <code>email.mime.text</code> 的子包。</p>
<h4 id="5-2-1-常规包"><a href="#5-2-1-常规包" class="headerlink" title="5.2.1. 常规包"></a>5.2.1. 常规包</h4><p>Python 定义了两种类型的包，常规包 和 命名空间包。 常规包是传统的包类型，它们在 Python 3.2 及之前就已存在。 常规包通常以一个包含 <code>__init__.py</code> 文件的目录形式实现。 当一个常规包被导入时，这个 <code>__init__.py</code> 文件会隐式地被执行，它所定义的对象会被绑定到该包命名空间中的名称。<code>__init__.py</code> 文件可以包含与任何其他模块中所包含的 Python 代码相似的代码，Python 将在模块被导入时为其添加额外的属性。</p>
<p>例如，以下文件系统布局定义了一个最高层级的 <code>parent</code> 包和三个子包:</p>
<pre><code>parent/
    __init__.py
    one/
        __init__.py
    two/
        __init__.py
    three/
        __init__.py</code></pre><p>导入 <code>parent.one</code> 将隐式地执行 <code>parent/__init__.py</code> 和 <code>parent/one/__init__.py</code>。 后续导入 <code>parent.two</code> 或 <code>parent.three</code> 则将分别执行 <code>parent/two/__init__.py</code> 和 <code>parent/three/__init__.py</code>。</p>
<h4 id="5-2-2-命名空间包"><a href="#5-2-2-命名空间包" class="headerlink" title="5.2.2. 命名空间包"></a>5.2.2. 命名空间包</h4><p>命名空间包是由多个 部分 构成的，每个部分为父包增加一个子包。 各个部分可能处于文件系统的不同位置。 部分也可能处于 zip 文件中、网络上，或者 Python 在导入期间可以搜索的其他地方。 命名空间包并不一定会直接对应到文件系统中的对象；它们有可能是无实体表示的虚拟模块。</p>
<p>命名空间包的 <code>__path__</code> 属性不使用普通的列表。 而是使用定制的可迭代类型，如果其父包的路径 (或者最高层级包的 <code>sys.path</code>) 发生改变，这种对象会在该包内的下一次导入尝试时自动执行新的对包部分的搜索。</p>
<p>命名空间包没有 <code>parent/__init__.py</code> 文件。 实际上，在导入搜索期间可能找到多个 <code>parent</code> 目录，每个都由不同的部分所提供。 因此 <code>parent/one</code> 的物理位置不一定与 <code>parent/two</code> 相邻。 在这种情况下，Python 将为顶级的 <code>parent</code> 包创建一个命名空间包，无论是它本身还是它的某个子包被导入。</p>
<p>另请参阅 <a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a> 了解对命名空间包的规格描述。</p>
<h3 id="5-3-搜索"><a href="#5-3-搜索" class="headerlink" title="5.3. 搜索"></a>5.3. 搜索</h3><p>为了开始搜索，Python 需要被导入模块（或者包，对于当前讨论来说两者没有差别）的完整 限定名称。 此名称可以来自 <code>import</code> 语句所带的各种参数，或者来自传给 <code>importlib.import_module()</code> 或 <code>__import__()</code> 函数的形参。</p>
<p>此名称会在导入搜索的各个阶段被使用，它也可以是指向一个子模块的带点号路径，例如 <code>foo.bar.baz</code>。 在这种情况下，Python 会先尝试导入 <code>foo</code>，然后是 <code>foo.bar</code>，最后是 <code>foo.bar.baz</code>。 如果这些导入中的任何一个失败，都会引发 <code>ModuleNotFoundError</code>。</p>
<h4 id="5-3-1-模块缓存"><a href="#5-3-1-模块缓存" class="headerlink" title="5.3.1. 模块缓存"></a>5.3.1. 模块缓存</h4><p>在导入搜索期间首先会被检查的地方是 <code>sys.modules</code>。 这个映射起到缓存之前导入的所有模块的作用（包括其中间路径）。 因此如果之前导入过 <code>foo.bar.baz</code>，则 <code>sys.modules</code> 将包含 <code>foo</code>, <code>foo.bar</code> 和 <code>foo.bar.baz</code> 条目。 每个键的值就是相应的模块对象。</p>
<p>在导入期间，会在 <code>sys.modules</code> 查找模块名称，如存在则其关联的值就是需要导入的模块，导入过程完成。 然而，如果值为 <code>None</code>，则会引发 <code>ModuleNotFoundError</code>。 如果找不到指定模块名称，Python 将继续搜索该模块。</p>
<p><code>sys.modules</code> 是可写的。删除键可能不会破坏关联的模块（因为其他模块可能会保留对它的引用），但它会使命名模块的缓存条目无效，导致 Python 在下次导入时重新搜索命名模块。键也可以赋值为 <code>None</code> ，强制下一次导入模块导致 <code>ModuleNotFoundError</code> 。</p>
<p>但是要小心，因为如果你还保有对某个模块对象的引用，同时停用其在 <code>sys.modules</code> 中的缓存条目，然后又再次导入该名称的模块，则前后两个模块对象将 <em>不是</em> 同一个。 相反地，<code>importlib.reload()</code> 将重用 <em>同一个</em> 模块对象，并简单地通过重新运行模块的代码来重新初始化模块内容。</p>
<h4 id="5-3-2-查找器和加载器"><a href="#5-3-2-查找器和加载器" class="headerlink" title="5.3.2. 查找器和加载器"></a>5.3.2. 查找器和加载器</h4><p>如果指定名称的模块在 <code>sys.modules</code> 找不到，则将发起调用 Python 的导入协议以查找和加载该模块。 此协议由两个概念性模块构成，即 查找器 和 加载器。 查找器的任务是确定是否能使用其所知的策略找到该名称的模块。 同时实现这两种接口的对象称为 导入器 —— 它们在确定能加载所需的模块时会返回其自身。</p>
<p>Python 包含了多个默认查找器和导入器。 第一个知道如何定位内置模块，第二个知道如何定位冻结模块。 第三个默认查找器会在 import path 中搜索模块。 import path 是一个由文件系统路径或 zip 文件组成的位置列表。 它还可以扩展为搜索任意可定位资源，例如由 URL 指定的资源。</p>
<p>导入机制是可扩展的，因此可以加入新的查找器以扩展模块搜索的范围和作用域。</p>
<p>查找器并不真正加载模块。 如果它们能找到指定名称的模块，会返回一个 <em>模块规格说明</em>，这是对模块导入相关信息的封装，供后续导入机制用于在加载模块时使用。</p>
<p>以下各节描述了有关查找器和加载器协议的更多细节，包括你应该如何创建并注册新的此类对象来扩展导入机制。</p>
<p>在 3.4 版更改: 在之前的 Python 版本中，查找器会直接返回 加载器，现在它们则返回模块规格说明，其中 <em>包含</em> 加载器。 加载器仍然在导入期间被使用，但负担的任务有所减少。</p>
<h4 id="5-3-3-导入钩子"><a href="#5-3-3-导入钩子" class="headerlink" title="5.3.3. 导入钩子"></a>5.3.3. 导入钩子</h4><p>导入机制被设计为可扩展；其中的基本机制是 <em>导入钩子*。 导入钩子有两种类型: *元钩子</em> 和 <em>导入路径钩子</em>。</p>
<p>元钩子在导入过程开始时被调用，此时任何其他导入过程尚未发生，但 <code>sys.modules</code> 缓存查找除外。 这允许元钩子重载 <code>sys.path</code> 过程、冻结模块甚至内置模块。 元钩子的注册是通过向 <code>sys.meta_path</code> 添加新的查找器对象，具体如下所述。</p>
<p>导入路径钩子是作为 <code>sys.path</code> (或 <code>package.__path__</code>) 过程的一部分，在遇到它们所关联的路径项的时候被调用。 导入路径钩子的注册是通过向 <code>sys.path_hooks</code> 添加新的可调用对象，具体如下所述。</p>
<h4 id="5-3-4-元路径"><a href="#5-3-4-元路径" class="headerlink" title="5.3.4. 元路径"></a>5.3.4. 元路径</h4><p>当指定名称的模块在 <code>sys.modules</code> 中找不到时，Python 会接着搜索 <code>sys.meta_path</code>，其中包含元路径查找器对象列表。 这些查找器按顺序被查询以确定它们是否知道如何处理该名称的模块。 元路径查找器必须实现名为 <code>find_spec()</code> 的方法，该方法接受三个参数：名称、导入路径和目标模块（可选）。 元路径查找器可使用任何策略来确定它是否能处理指定名称的模块。</p>
<p>如果元路径查找器知道如何处理指定名称的模块，它将返回一个说明对象。 如果它不能处理该名称的模块，则会返回 <code>None</code>。 如果 <code>sys.meta_path</code> 处理过程到达列表末尾仍未返回说明对象，则将引发 <code>ModuleNotFoundError</code>。 任何其他被引发异常将直接向上传播，并放弃导入过程。</p>
<p>元路径查找器的 <code>find_spec()</code> 方法调用带有两到三个参数。 第一个是被导入模块的完整限定名称，例如 <code>foo.bar.baz</code>。 第二个参数是供模块搜索使用的路径条目。 对于最高层级模块，第二个参数为 <code>None</code>，但对于子模块或子包，第二个参数为父包 <code>__path__</code> 属性的值。 如果相应的 <code>__path__</code> 属性无法访问，将引发 <code>ModuleNotFoundError</code>。 第三个参数是一个将被作为稍后加载目标的现有模块对象。 导入系统仅会在重加载期间传入一个目标模块。</p>
<p>对于单个导入请求可以多次遍历元路径。 例如，假设所涉及的模块都尚未被缓存，则导入 <code>foo.bar.baz</code> 将首先执行顶级的导入，在每个元路径查找器 (<code>mpf</code>) 上调用 <code>mpf.find_spec("foo", None, None)</code>。 在导入 <code>foo</code> 之后，<code>foo.bar</code> 将通过第二次遍历元路径来导入，调用 <code>mpf.find_spec("foo.bar", foo.__path__, None)</code>。 一旦 <code>foo.bar</code> 完成导入，最后一次遍历将调用 <code>mpf.find_spec("foo.bar.baz", foo.bar.__path__, None)</code>。</p>
<p>有些元路径查找器只支持顶级导入。 当把 <code>None</code> 以外的对象作为第三个参数传入时，这些导入器将总是返回 <code>None</code>。</p>
<p>Python 的默认 <code>sys.meta_path</code> 具有三种元路径查找器，一种知道如何导入内置模块，一种知道如何导入冻结模块，还有一种知道如何导入来自 import path 的模块 (即 path based finder)。</p>
<p>在 3.4 版更改: 元路径查找器的 <code>find_spec()</code> 方法替代了 <code>find_module()</code>，后者现已弃用，它将继续可用但不会再做改变，导入机制仅会在查找器未实现 <code>find_spec()</code> 时尝试使用它。</p>
<p>在 3.10 版更改: 导入系统使用 <code>find_module()</code> 现在将会引发 <code>ImportWarning</code>。</p>
<h3 id="5-4-加载"><a href="#5-4-加载" class="headerlink" title="5.4. 加载"></a>5.4. 加载</h3><p>当一个模块说明被找到时，导入机制将在加载该模块时使用它（及其所包含的加载器）。 下面是导入的加载部分所发生过程的简要说明:</p>
<pre class="line-numbers language-python"><code class="language-python">module <span class="token operator">=</span> None
<span class="token keyword">if</span> spec<span class="token punctuation">.</span>loader <span class="token keyword">is</span> <span class="token operator">not</span> None <span class="token operator">and</span> hasattr<span class="token punctuation">(</span>spec<span class="token punctuation">.</span>loader<span class="token punctuation">,</span> <span class="token string">'create_module'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># It is assumed 'exec_module' will also be defined on the loader.</span>
    module <span class="token operator">=</span> spec<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>create_module<span class="token punctuation">(</span>spec<span class="token punctuation">)</span>
<span class="token keyword">if</span> module <span class="token keyword">is</span> None<span class="token punctuation">:</span>
    module <span class="token operator">=</span> ModuleType<span class="token punctuation">(</span>spec<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># The import-related module attributes get set here:</span>
_init_module_attrs<span class="token punctuation">(</span>spec<span class="token punctuation">,</span> module<span class="token punctuation">)</span>
<span class="token keyword">if</span> spec<span class="token punctuation">.</span>loader <span class="token keyword">is</span> None<span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># unsupported</span>
    <span class="token keyword">raise</span> ImportError
<span class="token keyword">if</span> spec<span class="token punctuation">.</span>origin <span class="token keyword">is</span> None <span class="token operator">and</span> spec<span class="token punctuation">.</span>submodule_search_locations <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># namespace package</span>
    sys<span class="token punctuation">.</span>modules<span class="token punctuation">[</span>spec<span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> module
<span class="token keyword">elif</span> <span class="token operator">not</span> hasattr<span class="token punctuation">(</span>spec<span class="token punctuation">.</span>loader<span class="token punctuation">,</span> <span class="token string">'exec_module'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    module <span class="token operator">=</span> spec<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>load_module<span class="token punctuation">(</span>spec<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Set __loader__ and __package__ if missing.</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    sys<span class="token punctuation">.</span>modules<span class="token punctuation">[</span>spec<span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> module
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        spec<span class="token punctuation">.</span>loader<span class="token punctuation">.</span>exec_module<span class="token punctuation">(</span>module<span class="token punctuation">)</span>
    <span class="token keyword">except</span> BaseException<span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token keyword">del</span> sys<span class="token punctuation">.</span>modules<span class="token punctuation">[</span>spec<span class="token punctuation">.</span>name<span class="token punctuation">]</span>
        <span class="token keyword">except</span> KeyError<span class="token punctuation">:</span>
            <span class="token keyword">pass</span>
        <span class="token keyword">raise</span>
<span class="token keyword">return</span> sys<span class="token punctuation">.</span>modules<span class="token punctuation">[</span>spec<span class="token punctuation">.</span>name<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意以下细节:</p>
<blockquote>
<ul>
<li>如果在 <code>sys.modules</code> 中存在指定名称的模块对象，导入操作会已经将其返回。</li>
<li>在加载器执行模块代码之前，该模块将存在于 <code>sys.modules</code> 中。 这一点很关键，因为该模块代码可能（直接或间接地）导入其自身；预先将其添加到 <code>sys.modules</code> 可防止在最坏情况下的无限递归和最好情况下的多次加载。</li>
<li>如果加载失败，则该模块 — 只限加载失败的模块 — 将从 <code>sys.modules</code> 中移除。 任何已存在于 <code>sys.modules</code> 缓存的模块，以及任何作为附带影响被成功加载的模块仍会保留在缓存中。 这与重新加载不同，后者会把即使加载失败的模块也保留在 <code>sys.modules</code> 中。</li>
<li>在模块创建完成但还未执行之前，导入机制会设置导入相关模块属性（在上面的示例伪代码中为 “_init_module_attrs”）。</li>
<li>模块执行是加载的关键时刻，在此期间将填充模块的命名空间。 执行会完全委托给加载器，由加载器决定要填充的内容和方式。</li>
<li>在加载过程中创建并传递给 exec_module() 的模块并不一定就是在导入结束时返回的模块。</li>
</ul>
</blockquote>
<p>在 3.4 版更改: 导入系统已经接管了加载器建立样板的责任。 这些在以前是由 <code>importlib.abc.Loader.load_module()</code> 方法来执行的。</p>
<h4 id="5-4-1-加载器"><a href="#5-4-1-加载器" class="headerlink" title="5.4.1. 加载器"></a>5.4.1. 加载器</h4><p>模块加载器提供关键的加载功能：模块执行。 导入机制调用 <code>importlib.abc.Loader.exec_module()</code> 方法并传入一个参数来执行模块对象。 从 <code>exec_module()</code> 返回的任何值都将被忽略。</p>
<p>加载器必须满足下列要求:</p>
<blockquote>
<ul>
<li>如果模块是一个 Python 模块（而非内置模块或动态加载的扩展），加载器应该在模块的全局命名空间 (<code>module.__dict__</code>) 中执行模块的代码。</li>
<li>如果加载器无法执行指定模块，它应该引发 <code>ImportError</code>，不过在 <code>exec_module()</code> 期间引发的任何其他异常也会被传播。</li>
</ul>
</blockquote>
<p>在许多情况下，查找器和加载器可以是同一对象；在此情况下 <code>find_spec()</code> 方法将返回一个规格说明，其中加载器会被设为 <code>self</code>。</p>
<p>模块加载器可以选择通过实现 <code>create_module()</code> 方法在加载期间创建模块对象。 它接受一个参数，即模块规格说明，并返回新的模块对象供加载期间使用。 <code>create_module()</code> 不需要在模块对象上设置任何属性。 如果模块返回 <code>None</code>，导入机制将自行创建新模块。</p>
<p>3.4 新版功能: 加载器的 <code>create_module()</code> 方法。</p>
<p>在 3.4 版更改: <code>load_module()</code> 方法被 <code>exec_module()</code> 所替代，导入机制会对加载的所有样板责任作出假定。</p>
<p>为了与现有的加载器兼容，导入机制会使用导入器的 <code>load_module()</code> 方法，如果它存在且导入器也未实现 <code>exec_module()</code>。 但是，<code>load_module()</code> 现已弃用，加载器应该转而实现 <code>exec_module()</code>。</p>
<p>除了执行模块之外，<code>load_module()</code> 方法必须实现上文描述的所有样板加载功能。 所有相同的限制仍然适用，并带有一些附加规定:</p>
<blockquote>
<ul>
<li>如果 <code>sys.modules</code> 中存在指定名称的模块对象，加载器必须使用已存在的模块。 （否则 <code>importlib.reload()</code> 将无法正确工作。） 如果该名称模块不存在于 <code>sys.modules</code> 中，加载器必须创建一个新的模块对象并将其加入 <code>sys.modules</code>。</li>
<li>在加载器执行模块代码之前，模块 <em>必须</em> 存在于 <code>sys.modules</code> 之中，以防止无限递归或多次加载。</li>
<li>如果加载失败，加载器必须移除任何它已加入到 <code>sys.modules</code> 中的模块，但它必须 <strong>仅限</strong> 移除加载失败的模块，且所移除的模块应为加载器自身显式加载的。</li>
</ul>
</blockquote>
<p>在 3.5 版更改: 当 <code>exec_module()</code> 已定义但 <code>create_module()</code> 未定义时将引发 <code>DeprecationWarning</code>。</p>
<p>在 3.6 版更改: 当 <code>exec_module()</code> 已定义但 <code>create_module()</code> 未定义时将引发 <code>ImportError</code>。</p>
<p>在 3.10 版更改: 使用 <code>load_module()</code> 将引发 <code>ImportWarning</code>。</p>
<h4 id="5-4-2-子模块"><a href="#5-4-2-子模块" class="headerlink" title="5.4.2. 子模块"></a>5.4.2. 子模块</h4><p>当使用任意机制 (例如 <code>importlib</code> API, <code>import</code> 及 <code>import-from</code> 语句或者内置的 <code>__import__()</code>) 加载一个子模块时，父模块的命名空间中会添加一个对子模块对象的绑定。 例如，如果包 <code>spam</code> 有一个子模块 <code>foo</code>，则在导入 <code>spam.foo</code> 之后，<code>spam</code> 将具有一个 绑定到相应子模块的 <code>foo</code> 属性。 假如现在有如下的目录结构:</p>
<pre><code>spam/
    __init__.py
    foo.py
    bar.py</code></pre><p>并且 <code>spam/__init__.py</code> 中有如下几行内容:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> <span class="token punctuation">.</span>foo <span class="token keyword">import</span> Foo
<span class="token keyword">from</span> <span class="token punctuation">.</span>bar <span class="token keyword">import</span> Bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>则执行如下代码将在 <code>spam</code> 模块中添加对 <code>foo</code> 和 <code>bar</code> 的名称绑定:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> spam
<span class="token operator">>></span><span class="token operator">></span> spam<span class="token punctuation">.</span>foo
<span class="token operator">&lt;</span>module <span class="token string">'spam.foo'</span> <span class="token keyword">from</span> <span class="token string">'/tmp/imports/spam/foo.py'</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> spam<span class="token punctuation">.</span>bar
<span class="token operator">&lt;</span>module <span class="token string">'spam.bar'</span> <span class="token keyword">from</span> <span class="token string">'/tmp/imports/spam/bar.py'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>按照通常的 Python 名称绑定规则，这看起来可能会令人惊讶，但它实际上是导入系统的一个基本特性。 保持不变的一点是如果你有 <code>sys.modules['spam']</code> 和 <code>sys.modules['spam.foo']</code> (例如在上述导入之后就是如此)，则后者必须显示为前者的 <code>foo</code> 属性。</p>
<h4 id="5-4-3-模块规格说明"><a href="#5-4-3-模块规格说明" class="headerlink" title="5.4.3. 模块规格说明"></a>5.4.3. 模块规格说明</h4><p>导入机制在导入期间会使用有关每个模块的多种信息，特别是加载之前。 大多数信息都是所有模块通用的。 模块规格说明的目的是基于每个模块来封装这些导入相关信息。</p>
<p>在导入期间使用规格说明可允许状态在导入系统各组件之间传递，例如在创建模块规格说明的查找器和执行模块的加载器之间。 最重要的一点是，它允许导入机制执行加载的样板操作，在没有模块规格说明的情况下这是加载器的责任。</p>
<p>模块的规格说明会作为模块对象的 <code>__spec__</code> 属性对外公开。</p>
<p>3.4 新版功能.</p>
<h4 id="5-4-4-导入相关的模块属性"><a href="#5-4-4-导入相关的模块属性" class="headerlink" title="5.4.4. 导入相关的模块属性"></a>5.4.4. 导入相关的模块属性</h4><p>导入机制会在加载期间会根据模块的规格说明填充每个模块对象的这些属性，并在加载器执行模块之前完成。</p>
<pre><code>__name__</code></pre><p><code>__name__</code> 属性必须被设为模块的完整限定名称。 此名称被用来在导入系统中唯一地标识模块。</p>
<pre><code>__loader__</code></pre><p><code>__loader__</code> 属性必须被设为导入系统在加载模块时使用的加载器对象。 这主要是用于内省，但也可用于额外的加载器专用功能，例如获取关联到加载器的数据。</p>
<pre><code>__package__</code></pre><p>模块的 <code>__package__</code> 属性必须设定。 其取值必须为一个字符串，但可以与 <code>__name__</code> 取相同的值。 当模块是包时，其 <code>__package__</code> 值应该设为其 <code>__name__</code> 值。 当模块不是包时，对于最高层级模块 <code>__package__</code> 应该设为空字符串，对于子模块则应该设为其父包名。 更多详情可参阅 <a href="https://www.python.org/dev/peps/pep-0366" target="_blank" rel="noopener"><strong>PEP 366</strong></a>。</p>
<p>该属性取代 <code>__name__</code> 被用来为主模块计算显式相对导入，相关定义见 <a href="https://www.python.org/dev/peps/pep-0366" target="_blank" rel="noopener"><strong>PEP 366</strong></a>。 预期它与 <code>__spec__.parent</code> 具有相同的值。</p>
<p>在 3.6 版更改: <code>__package__</code> 预期与 <code>__spec__.parent</code> 具有相同的值。</p>
<pre><code>__spec__</code></pre><p><code>__spec__</code> 属性必须设为在导入模块时要使用的模块规格说明。 对 <code>__spec__</code> 的正确设定将同时作用于 解释器启动期间初始化的模块。 唯一的例外是 <code>__main__</code>，其中的 <code>__spec__</code> 会 在某些情况下设为 None.</p>
<p>当 <code>__package__</code> 未定义时， <code>__spec__.parent</code> 会被用作回退项。</p>
<p>3.4 新版功能.</p>
<p>在 3.6 版更改: 当 <code>__package__</code> 未定义时，<code>__spec__.parent</code> 会被用作回退项。</p>
<pre><code>__path__</code></pre><p>如果模块为包（不论是正规包还是命名空间包），则必须设置模块对象的 <code>__path__</code> 属性。 属性值必须为可迭代对象，但如果 <code>__path__</code> 没有进一步的用处则可以为空。 如果 <code>__path__</code> 不为空，则在迭代时它应该产生字符串。 </p>
<p>不是包的模块不应该具有 <code>__path__</code> 属性。</p>
<pre><code>__file__
__cached__</code></pre><p><code>__file__</code> 是可选项。 如果设置，此属性的值必须为字符串。 导入系统可以选择在其没有语法意义时不设置 <code>__file__</code> (例如从数据库加载的模块)。</p>
<p>如果设置了 <code>__file__</code>，则也可以再设置 <code>__cached__</code> 属性，后者取值为编译版本代码（例如字节码文件）所在的路径。 设置此属性不要求文件已存在；该路径可以简单地指向应该存放编译文件的位置 (参见 <a href="https://www.python.org/dev/peps/pep-3147" target="_blank" rel="noopener"><strong>PEP 3147</strong></a>)。</p>
<p>当未设置 <code>__file__</code> 时也可以设置 <code>__cached__</code>。 但是，那样的场景很不典型。 最终，加载器会使用 <code>__file__</code> 和/或 <code>__cached__</code>。 因此如果一个加载器可以从缓存加载模块但是不能从文件加载，那种非典型场景就是适当的。</p>
<h4 id="5-4-5-module-path"><a href="#5-4-5-module-path" class="headerlink" title="5.4.5. module.path"></a>5.4.5. module.<strong>path</strong></h4><p>根据定义，如果一个模块具有 <code>__path__</code> 属性，它就是包。</p>
<p>包的 <code>__path__</code> 属性会在导入其子包期间被使用。 在导入机制内部，它的功能与 <code>sys.path</code> 基本相同，即在导入期间提供一个模块搜索位置列表。 但是，<code>__path__</code> 通常会比 <code>sys.path</code> 受到更多限制。</p>
<p><code>__path__</code> 必须是由字符串组成的可迭代对象，但它也可以为空。 作用于 <code>sys.path</code> 的规则同样适用于包的 <code>__path__</code>，并且 <code>sys.path_hooks</code> 会在遍历包的 <code>__path__</code> 时被查询。</p>
<p>包的 <code>__init__.py</code> 文件可以设置或更改包的 <code>__path__</code> 属性，而且这是在 <a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a> 之前实现命名空间包的典型方式。 随着 <a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a> 的引入，命名空间包不再需要提供仅包含 <code>__path__</code> 操控代码的 <code>__init__.py</code> 文件；导入机制会自动为命名空间包正确地设置 <code>__path__</code>。</p>
<h4 id="5-4-6-模块的-repr"><a href="#5-4-6-模块的-repr" class="headerlink" title="5.4.6. 模块的 repr"></a>5.4.6. 模块的 repr</h4><p>默认情况下，全部模块都具有一个可用的 repr，但是你可以依据上述的属性设置，在模块的规格说明中更为显式地控制模块对象的 repr。</p>
<p>如果模块具有 spec (<code>__spec__</code>)，导入机制将尝试用它来生成一个 repr。 如果生成失败或找不到 spec，导入系统将使用模块中的各种可用信息来制作一个默认 repr。 它将尝试使用 <code>module.__name__</code>, <code>module.__file__</code> 以及 <code>module.__loader__</code> 作为 repr 的输入，并将任何丢失的信息赋为默认值。</p>
<p>以下是所使用的确切规则:</p>
<blockquote>
<ul>
<li>如果模块具有 <code>__spec__</code> 属性，其中的规格信息会被用来生成 repr。 被查询的属性有 “name”, “loader”, “origin” 和 “has_location” 等等。</li>
<li>如果模块具有 <code>__file__</code> 属性，这会被用作模块 repr 的一部分。</li>
<li>如果模块没有 <code>__file__</code> 但是有 <code>__loader__</code> 且取值不为 <code>None</code>，则加载器的 repr 会被用作模块 repr 的一部分。</li>
<li>对于其他情况，仅在 repr 中使用模块的 <code>__name__</code>。</li>
</ul>
</blockquote>
<p>在 3.4 版更改: <code>loader.module_repr()</code> 已弃用，导入机制现在使用模块规格说明来生成模块 repr。</p>
<p>为了向后兼容 Python 3.3，如果加载器定义了 <code>module_repr()</code> 方法，则会在尝试上述两种方式之前先调用该方法来生成模块 repr。 但请注意此方法已弃用。</p>
<p>在 3.10 版更改: 对 <code>module_repr()</code> 的调用现在会在尝试使用模块的 <code>__spec__</code> 属性之后但在回退至 <code>__file__</code> 之前发生。 <code>module_repr()</code> 的使用预定会在 Python 3.12 中停止。</p>
<h4 id="5-4-7-已缓存字节码的失效"><a href="#5-4-7-已缓存字节码的失效" class="headerlink" title="5.4.7. 已缓存字节码的失效"></a>5.4.7. 已缓存字节码的失效</h4><p>在 Python 从 <code>.pyc</code> 文件加载已缓存字节码之前，它会检查缓存是否由最新的 <code>.py</code> 源文件所生成。 默认情况下，Python 通过在所写入缓存文件中保存源文件的最新修改时间戳和大小来实现这一点。 在运行时，导入系统会通过比对缓存文件中保存的元数据和源文件的元数据确定该缓存的有效性。</p>
<p>Python 也支持“基于哈希的”缓存文件，即保存源文件内容的哈希值而不是其元数据。 存在两种基于哈希的 <code>.pyc</code> 文件：检查型和非检查型。 对于检查型基于哈希的 <code>.pyc</code> 文件，Python 会通过求哈希源文件并将结果哈希值与缓存文件中的哈希值比对来确定缓存有效性。 如果检查型基于哈希的缓存文件被确定为失效，Python 会重新生成并写入一个新的检查型基于哈希的缓存文件。 对于非检查型 <code>.pyc</code> 文件，只要其存在 Python 就会直接认定缓存文件有效。 确定基于哈希的 <code>.pyc</code> 文件有效性的行为可通过 <code>--check-hash-based-pycs</code> 旗标来重载。</p>
<p>在 3.7 版更改: 增加了基于哈希的 <code>.pyc</code> 文件。在此之前，Python 只支持基于时间戳来确定字节码缓存的有效性。</p>
<h3 id="5-5-基于路径的查找器"><a href="#5-5-基于路径的查找器" class="headerlink" title="5.5. 基于路径的查找器"></a>5.5. 基于路径的查找器</h3><p>在之前已经提及，Python 带有几种默认的元路径查找器。 其中之一是 path based finder (<code>PathFinder</code>)，它会搜索包含一个 路径条目 列表的 import path。 每个路径条目指定一个用于搜索模块的位置。</p>
<p>基于路径的查找器自身并不知道如何进行导入。 它只是遍历单独的路径条目，将它们各自关联到某个知道如何处理特定类型路径的路径条目查找器。</p>
<p>默认的路径条目查找器集合实现了在文件系统中查找模块的所有语义，可处理多种特殊文件类型例如 Python 源码 (<code>.py</code> 文件)，Python 字节码 (<code>.pyc</code> 文件) 以及共享库 (例如 <code>.so</code> 文件)。 在标准库中 <code>zipimport</code> 模块的支持下，默认路径条目查找器还能处理所有来自 zip 文件的上述文件类型。</p>
<p>路径条目不必仅限于文件系统位置。 它们可以指向 URL、数据库查询或可以用字符串指定的任何其他位置。</p>
<p>基于路径的查找器还提供了额外的钩子和协议以便能扩展和定制可搜索路径条目的类型。 例如，如果你想要支持网络 URL 形式的路径条目，你可以编写一个实现 HTTP 语义在网络上查找模块的钩子。 这个钩子（可调用对象）应当返回一个支持下述协议的 path entry finder，以被用来获取一个专门针对来自网络的模块的加载器。</p>
<p>预先的警告：本节和上节都使用了 <em>查找器</em> 这一术语，并通过 meta path finder 和 path entry finder 两个术语来明确区分它们。 这两种类型的查找器非常相似，支持相似的协议，且在导入过程中以相似的方式运作，但关键的一点是要记住它们是有微妙差异的。 特别地，元路径查找器作用于导入过程的开始，主要是启动 <code>sys.meta_path</code> 遍历。</p>
<p>相比之下，路径条目查找器在某种意义上说是基于路径的查找器的实现细节，实际上，如果需要从 <code>sys.meta_path</code> 移除基于路径的查找器，并不会有任何路径条目查找器被发起调用。</p>
<h4 id="5-5-1-路径条目查找器"><a href="#5-5-1-路径条目查找器" class="headerlink" title="5.5.1. 路径条目查找器"></a>5.5.1. 路径条目查找器</h4><p>path based finder 会负责查找和加载通过 path entry 字符串来指定位置的 Python 模块和包。 多数路径条目所指定的是文件系统中的位置，但它们并不必受限于此。</p>
<p>作为一种元路径查找器，path based finder 实现了上文描述的 <code>find_spec()</code> 协议，但是它还对外公开了一些附加钩子，可被用来定制模块如何从 import path 查找和加载。</p>
<p>有三个变量由 path based finder, <code>sys.path</code>, <code>sys.path_hooks</code> 和 <code>sys.path_importer_cache</code> 所使用。 包对象的 <code>__path__</code> 属性也会被使用。 它们提供了可用于定制导入机制的额外方式。</p>
<p><code>sys.path</code> 包含一个提供模块和包搜索位置的字符串列表。 它初始化自 <code>PYTHONPATH</code> 环境变量以及多种其他特定安装和实现的默认设置。 <code>sys.path</code> 条目可指定的名称有文件系统中的目录、zip 文件和其他可用于搜索模块的潜在“位置”，例如 URL 或数据库查询等。 在 <code>sys.path</code> 中只能出现字符串和字节串；所有其他数据类型都会被忽略。 字节串条目使用的编码由单独的 路径条目查找器 来确定。</p>
<p>path based finder 是一种 meta path finder，因此导入机制会通过调用上文描述的基于路径的查找器的 <code>find_spec()</code> 方法来启动 import path 搜索。 当要向 <code>find_spec()</code> 传入 <code>path</code> 参数时，它将是一个可遍历的字符串列表 —— 通常为用来在其内部进行导入的包的 <code>__path__</code> 属性。 如果 <code>path</code> 参数为 <code>None</code>，这表示最高层级的导入，将会使用 <code>sys.path</code>。</p>
<p>基于路径的查找器会迭代搜索路径中的每个条目，并且每次都查找与路径条目对应的 path entry finder (<code>PathEntryFinder</code>)。 因为这种操作可能很耗费资源（例如搜索会有 stat() 调用的开销），基于路径的查找器会维持一个缓存来将路径条目映射到路径条目查找器。 这个缓存放于 <code>sys.path_importer_cache</code> (尽管如此命名，但这个缓存实际存放的是查找器对象而非仅限于 importer 对象)。 通过这种方式，对特定 path entry 位置的 path entry finder 的高耗费搜索只需进行一次。 用户代码可以自由地从 <code>sys.path_importer_cache</code> 移除缓存条目，以强制基于路径的查找器再次执行路径条目搜索 。</p>
<p>如果路径条目不存在于缓存中，基于路径的查找器会迭代 <code>sys.path_hooks</code> 中的每个可调用对象。 对此列表中的每个 路径条目钩子 的调用会带有一个参数，即要搜索的路径条目。 每个可调用对象或是返回可处理路径条目的 path entry finder，或是引发 <code>ImportError</code>。 基于路径的查找器使用 <code>ImportError</code> 来表示钩子无法找到与 path entry 相对应的 path entry finder。 该异常会被忽略并继续进行 import path 的迭代。 每个钩子应该期待接收一个字符串或字节串对象；字节串对象的编码由钩子决定（例如可以是文件系统使用的编码 UTF-8 或其它编码），如果钩子无法解码参数，它应该引发 <code>ImportError</code>。</p>
<p>如果 <code>sys.path_hooks</code> 迭代结束时没有返回 path entry finder，则基于路径的查找器 <code>find_spec()</code> 方法将在 <code>sys.path_importer_cache</code> 中存入 <code>None</code> (表示此路径条目没有对应的查找器) 并返回 <code>None</code>，表示此 meta path finder 无法找到该模块。</p>
<p>如果 <code>sys.path_hooks</code> 中的某个 path entry hook 可调用对象的返回值 <em>是</em> 一个 path entry finder，则以下协议会被用来向查找器请求一个模块的规格说明，并在加载该模块时被使用。</p>
<p>当前工作目录 — 由一个空字符串表示 — 的处理方式与 <code>sys.path</code> 中的其他条目略有不同。 首先，如果发现当前工作目录不存在，则 <code>sys.path_importer_cache</code> 中不会存放任何值。 其次，每个模块查找会对当前工作目录的值进行全新查找。 第三，由 <code>sys.path_importer_cache</code> 所使用并由 <code>importlib.machinery.PathFinder.find_spec()</code> 所返回的路径将是实际的当前工作目录而非空字符串。</p>
<h4 id="5-5-2-路径条目查找器协议"><a href="#5-5-2-路径条目查找器协议" class="headerlink" title="5.5.2. 路径条目查找器协议"></a>5.5.2. 路径条目查找器协议</h4><p>为了支持模块和已初始化包的导入，也为了给命名空间包提供组成部分，路径条目查找器必须实现 <code>find_spec()</code> 方法。</p>
<p><code>find_spec()</code> 接受两个参数，即要导入模块的完整限定名称，以及（可选的）目标模块。 <code>find_spec()</code> 返回模块的完全填充好的规格说明。 这个规格说明总是包含“加载器”集合（但有一个例外）。</p>
<p>为了向导入机制提示该规格说明代表一个命名空间 portion，路径条目查找器会将 “submodule_search_locations” 设为一个包含该部分的列表。</p>
<p>在 3.4 版更改: <code>find_spec()</code> 替代了 <code>find_loader()</code> 和 <code>find_module()</code>，后两者现在都已弃用，但会在 <code>find_spec()</code> 未定义时被使用。</p>
<p>较旧的路径条目查找器可能会实现这两个已弃用的方法中的一个而没有实现 <code>find_spec()</code>。 为保持向后兼容，这两个方法仍会被接受。 但是，如果在路径条目查找器上实现了 <code>find_spec()</code>，这两个遗留方法就会被忽略。</p>
<p><code>find_loader()</code> 接受一个参数，即要导入模块的完整限定名称。 <code>find_loader()</code> 返回一个 2 元组，其中第一项是加载器而第二项是命名空间 portion。</p>
<p>为了向后兼容其他导入协议的实现，许多路径条目查找器也同样支持元路径查找器所支持的传统 <code>find_module()</code> 方法。 但是路径条目查找器 <code>find_module()</code> 方法的调用绝不会带有 <code>path</code> 参数（它们被期望记录来自对路径钩子初始调用的恰当路径信息）。</p>
<p>路径条目查找器的 <code>find_module()</code> 方法已弃用，因为它不允许路径条目查找器为命名空间包提供部分。 如果 <code>find_loader()</code> 和 <code>find_module()</code> 同时存在于一个路径条目查找器中，导入系统将总是调用 <code>find_loader()</code> 而不选择 <code>find_module()</code>。</p>
<p>在 3.10 版更改: 导入系统调用 <code>find_module()</code> 和 <code>find_loader()</code> 将引发 <code>ImportWarning</code>。</p>
<h3 id="5-6-替换标准导入系统"><a href="#5-6-替换标准导入系统" class="headerlink" title="5.6. 替换标准导入系统"></a>5.6. 替换标准导入系统</h3><p>替换整个导入系统的最可靠机制是移除 <code>sys.meta_path</code> 的默认内容，,将其完全替换为自定义的元路径钩子。</p>
<p>一个可行的方式是仅改变导入语句的行为而不影响访问导入系统的其他 API，那么替换内置的 <code>__import__()</code> 函数可能就够了。 这种技巧也可以在模块层级上运用，即只在某个模块内部改变导入语句的行为。</p>
<p>想要选择性地预先防止在元路径上从一个钩子导入某些模块（而不是完全禁用标准导入系统），只需直接从 <code>find_spec()</code> 引发 <code>ModuleNotFoundError</code> 而非返回 <code>None</code> 就足够了。 返回后者表示元路径搜索应当继续，而引发异常则会立即终止搜索。</p>
<h3 id="5-7-包相对导入"><a href="#5-7-包相对导入" class="headerlink" title="5.7. 包相对导入"></a>5.7. 包相对导入</h3><p>相对导入使用前缀点号。 一个前缀点号表示相对导入从当前包开始。 两个或更多前缀点号表示对当前包的上级包的相对导入，第一个点号之后的每个点号代表一级。 例如，给定以下的包布局结构:</p>
<pre><code>package/
    __init__.py
    subpackage1/
        __init__.py
        moduleX.py
        moduleY.py
    subpackage2/
        __init__.py
        moduleZ.py
    moduleA.py</code></pre><p>不论是在 <code>subpackage1/moduleX.py</code> 还是 <code>subpackage1/__init__.py</code> 中，以下导入都是有效的:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> <span class="token punctuation">.</span>moduleY <span class="token keyword">import</span> spam
<span class="token keyword">from</span> <span class="token punctuation">.</span>moduleY <span class="token keyword">import</span> spam <span class="token keyword">as</span> ham
<span class="token keyword">from</span> <span class="token punctuation">.</span> <span class="token keyword">import</span> moduleY
<span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>subpackage1 <span class="token keyword">import</span> moduleY
<span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>subpackage2<span class="token punctuation">.</span>moduleZ <span class="token keyword">import</span> eggs
<span class="token keyword">from</span> <span class="token punctuation">.</span><span class="token punctuation">.</span>moduleA <span class="token keyword">import</span> foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>绝对导入可以使用 <code>import &lt;&gt;</code> 或 <code>from &lt;&gt; import &lt;&gt;</code> 语法，但相对导入只能使用第二种形式；其中的原因在于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> XXX<span class="token punctuation">.</span>YYY<span class="token punctuation">.</span>ZZZ<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>应当提供 <code>XXX.YYY.ZZZ</code> 作为可用表达式，但 .moduleY 不是一个有效的表达式。</p>
<h3 id="5-8-有关-main-的特殊事项"><a href="#5-8-有关-main-的特殊事项" class="headerlink" title="5.8. 有关 main 的特殊事项"></a>5.8. 有关 <strong>main</strong> 的特殊事项</h3><p>对于 Python 的导入系统来说 <code>__main__</code> 模块是一个特殊情况。 <code>__main__</code> 模块是在解释器启动时直接初始化的，与 <code>sys</code> 和 <code>builtins</code> 很类似。 但是，与那两者不同，它并不被严格归类为内置模块。 这是因为 <code>__main__</code> 被初始化的方式依赖于发起调用解释器所附带的旗标和其他选项。</p>
<h4 id="5-8-1-main-spec"><a href="#5-8-1-main-spec" class="headerlink" title="5.8.1. main.spec"></a>5.8.1. <strong>main</strong>.<strong>spec</strong></h4><p>根据 <code>__main__</code> 被初始化的方式，<code>__main__.__spec__</code> 会被设置相应值或是 <code>None</code>。</p>
<p>当 Python 附加 <code>-m</code> 选项启动时，<code>__spec__</code> 会被设为相应模块或包的模块规格说明。 <code>__spec__</code> 也会在 <code>__main__</code> 模块作为执行某个目录，zip 文件或其它 <code>sys.path</code> 条目的一部分加载时被填充。</p>
<p>在 其余的情况 下 <code>__main__.__spec__</code> 会被设为 <code>None</code>，因为用于填充 <code>__main__</code> 的代码不直接与可导入的模块相对应:</p>
<ul>
<li>交互型提示</li>
<li><code>-c</code> 选项</li>
<li>从 stdin 运行</li>
<li>直接从源码或字节码文件运行</li>
</ul>
<p>请注意在最后一种情况中 <code>__main__.__spec__</code> 总是为 <code>None</code>，<em>即使</em> 文件从技术上说可以作为一个模块被导入。 如果想要让 <code>__main__</code> 中的元数据生效，请使用 <code>-m</code> 开关。</p>
<p>还要注意即使是在 <code>__main__</code> 对应于一个可导入模块且 <code>__main__.__spec__</code> 被相应地设定时，它们仍会被视为 <em>不同的</em> 模块。 这是由于以下事实：使用 <code>if __name__ == "__main__":</code> 检测来保护的代码块仅会在模块被用来填充 <code>__main__</code> 命名空间时而非普通的导入时被执行。</p>
<h3 id="5-9-开放问题项"><a href="#5-9-开放问题项" class="headerlink" title="5.9. 开放问题项"></a>5.9. 开放问题项</h3><p>XXX 最好是能增加一个图表。</p>
<p>XXX * (import_machinery.rst) 是否要专门增加一节来说明模块和包的属性，也许可以扩展或移植数据模型参考页中的相关条目？</p>
<p>XXX 库手册中的 runpy 和 pkgutil 等等应该都在页面顶端增加指向新的导入系统章节的“另请参阅”链接。</p>
<p>XXX 是否要增加关于初始化 <code>__main__</code> 的不同方式的更多解释？</p>
<p>XXX 增加更多有关 <code>__main__</code> 怪异/坑人特性的信息 (例如直接从 <a href="https://www.python.org/dev/peps/pep-0395" target="_blank" rel="noopener"><strong>PEP 395</strong></a> 复制)。</p>
<h3 id="5-10-参考文献"><a href="#5-10-参考文献" class="headerlink" title="5.10. 参考文献"></a>5.10. 参考文献</h3><p>导入机制自 Python 诞生之初至今已发生了很大的变化。 原始的 包规格说明 仍然可以查阅，但在撰写该文档之后许多相关细节已被修改。</p>
<p>原始的 <code>sys.meta_path</code> 规格说明见 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a>，后续的扩展说明见 <a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a>。</p>
<p><a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a> 为 Python 3.3 引入了 命名空间包。 <a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a> 还引入了 <code>find_loader()</code> 协议作为 <code>find_module()</code> 的替代。</p>
<p><a href="https://www.python.org/dev/peps/pep-0366" target="_blank" rel="noopener"><strong>PEP 366</strong></a> 描述了新增的 <code>__package__</code> 属性，用于在模块中的显式相对导入。</p>
<p><a href="https://www.python.org/dev/peps/pep-0328" target="_blank" rel="noopener"><strong>PEP 328</strong></a> 引入了绝对和显式相对导入，并初次提出了 <code>__name__</code> 语义，最终由 <a href="https://www.python.org/dev/peps/pep-0366" target="_blank" rel="noopener"><strong>PEP 366</strong></a> 为 <code>__package__</code> 加入规范描述。</p>
<p><a href="https://www.python.org/dev/peps/pep-0338" target="_blank" rel="noopener"><strong>PEP 338</strong></a> 定义了将模块作为脚本执行。</p>
<p><a href="https://www.python.org/dev/peps/pep-0451" target="_blank" rel="noopener"><strong>PEP 451</strong></a> 在 spec 对象中增加了对每个模块导入状态的封装。 它还将加载器的大部分样板责任移交回导入机制中。 这些改变允许弃用导入系统中的一些 API 并为查找器和加载器增加一些新的方法。</p>
<p>注：</p>
<ul>
<li>importlib 实现避免直接使用返回值。 而是通过在 <code>sys.modules</code> 中查找模块名称来获取模块对象。 这种方式的间接影响是被导入的模块可能在 <code>sys.modules</code> 中替换其自身。 这属于具体实现的特定行为，不保证能在其他 Python 实现中起作用。</li>
<li>在遗留代码中，有可能在 <code>sys.path_importer_cache</code> 中找到 <code>imp.NullImporter</code> 的实例。 建议将这些代码修改为使用 <code>None</code> 代替。</li>
</ul>
<h2 id="6-表达式"><a href="#6-表达式" class="headerlink" title="6. 表达式"></a>6. 表达式</h2><p>本章将解释 Python 中组成表达式的各种元素的的含义。</p>
<p><strong>语法注释:</strong> 在本章和后续章节中，会使用扩展 BNF 标注来描述语法而不是词法分析。 当（某种替代的）语法规则具有如下形式</p>
<pre><code>name ::=  othername</code></pre><p>并且没有给出语义，则这种形式的 <code>name</code> 在语法上与 <code>othername</code> 相同。</p>
<h3 id="6-1-算术转换"><a href="#6-1-算术转换" class="headerlink" title="6.1. 算术转换"></a>6.1. 算术转换</h3><p>当对下述某个算术运算符的描述中使用了“数值参数被转换为普通类型”这样的说法，这意味着内置类型的运算符实现采用了如下运作方式:</p>
<ul>
<li>如果任一参数为复数，另一参数会被转换为复数；</li>
<li>否则，如果任一参数为浮点数，另一参数会被转换为浮点数；</li>
<li>否则，两者应该都为整数，不需要进行转换。</li>
</ul>
<p>某些附加规则会作用于特定运算符（例如，字符串作为 ‘%’ 运算符的左运算参数）。 扩展必须定义它们自己的转换行为。</p>
<h3 id="6-2-原子"><a href="#6-2-原子" class="headerlink" title="6.2. 原子"></a>6.2. 原子</h3><p>“原子”指表达式的最基本构成元素。 最简单的原子是标识符和字面值。 以圆括号、方括号或花括号包括的形式在语法上也被归类为原子。 原子的句法为:</p>
<pre><code>atom      ::=  identifier | literal | enclosure
enclosure ::=  parenth_form | list_display | dict_display | set_display
               | generator_expression | yield_atom</code></pre><h4 id="6-2-1-标识符（名称）"><a href="#6-2-1-标识符（名称）" class="headerlink" title="6.2.1. 标识符（名称）"></a>6.2.1. 标识符（名称）</h4><p>作为原子出现的标识符叫做名称。 请参看 标识符和关键字 一节了解其词法定义，以及 命名与绑定 获取有关命名与绑定的文档。</p>
<p>当名称被绑定到一个对象时，对该原子求值将返回相应对象。 当名称未被绑定时，尝试对其求值将引发 <code>NameError</code> 异常。</p>
<p><strong>私有名称转换:</strong> 当以文本形式出现在类定义中的一个标识符以两个或更多下划线开头并且不以两个或更多下划线结尾，它会被视为该类的 <em>私有名称</em>。 私有名称会在为其生成代码之前被转换为一种更长的形式。 转换时会插入类名，移除打头的下划线再在名称前增加一个下划线。 例如，出现在一个名为 <code>Ham</code> 的类中的标识符 <code>__spam</code> 会被转换为 <code>_Ham__spam</code>。 这种转换独立于标识符所使用的相关句法。 如果转换后的名称太长（超过 255 个字符），可能发生由具体实现定义的截断。 如果类名仅由下划线组成，则不会进行转换。</p>
<h4 id="6-2-2-字面值"><a href="#6-2-2-字面值" class="headerlink" title="6.2.2. 字面值"></a>6.2.2. 字面值</h4><p>Python 支持字符串和字节串字面值，以及几种数字字面值:</p>
<pre><code>literal ::=  stringliteral | bytesliteral
             | integer | floatnumber | imagnumber</code></pre><p>对字面值求值将返回一个该值所对应类型的对象（字符串、字节串、整数、浮点数、复数）。 对于浮点数和虚数（复数）的情况，该值可能为近似值。 </p>
<p>所有字面值都对应与不可变数据类型，因此对象标识的重要性不如其实际值。 多次对具有相同值的字面值求值（不论是发生在程序文本的相同位置还是不同位置）可能得到相同对象或是具有相同值的不同对象。</p>
<h4 id="6-2-3-带圆括号的形式"><a href="#6-2-3-带圆括号的形式" class="headerlink" title="6.2.3. 带圆括号的形式"></a>6.2.3. 带圆括号的形式</h4><p>带圆括号的形式是包含在圆括号中的可选表达式列表。</p>
<pre><code>parenth_form ::=  "(" [starred_expression] ")"</code></pre><p>带圆括号的表达式列表将返回该表达式列表所产生的任何东西：如果该列表包含至少一个逗号，它会产生一个元组；否则，它会产生该表达式列表所对应的单一表达式。</p>
<p>一对内容为空的圆括号将产生一个空的元组对象。 由于元组是不可变对象，因此适用与字面值相同的规则（即两次出现的空元组产生的对象可能相同也可能不同）。</p>
<p>请注意元组并不是由圆括号构建，实际起作用的是逗号操作符。 例外情况是空元组，这时圆括号 <em>才是</em> 必须的 —- 允许在表达式中使用不带圆括号的 “空” 会导致歧义，并会造成常见输入错误无法被捕获。</p>
<h4 id="6-2-4-列表、集合与字典的显示"><a href="#6-2-4-列表、集合与字典的显示" class="headerlink" title="6.2.4. 列表、集合与字典的显示"></a>6.2.4. 列表、集合与字典的显示</h4><p>为了构建列表、集合或字典，Python 提供了名为“显示”的特殊句法，每个类型各有两种形式:</p>
<ul>
<li>第一种是显式地列出容器内容</li>
<li>第二种是通过一组循环和筛选指令计算出来，称为 <em>推导式</em>。</li>
</ul>
<p>推导式的常用句法元素为:</p>
<pre><code>comprehension ::=  assignment_expression comp_for
comp_for      ::=  ["async"] "for" target_list "in" or_test [comp_iter]
comp_iter     ::=  comp_for | comp_if
comp_if       ::=  "if" or_test [comp_iter]</code></pre><p>推导式的结构是一个单独表达式后面加至少一个 <code>for</code> 子句以及零个或更多个 <code>for</code> 或 <code>if</code> 子句。 在这种情况下，新容器的元素产生方式是将每个 <code>for</code> 或 <code>if</code> 子句视为一个代码块，按从左至右的顺序嵌套，然后每次到达最内层代码块时就对表达式进行求值以产生一个元素。</p>
<p>不过，除了最左边 <code>for</code> 子句中的可迭代表达式，推导式是在另一个隐式嵌套的作用域内执行的。 这能确保赋给目标列表的名称不会“泄露”到外层的作用域。</p>
<p>最左边的 <code>for</code> 子句中的可迭代对象表达式会直接在外层作用域中被求值，然后作为一个参数被传给隐式嵌套的作用域。 后续的 <code>for</code> 子句以及最左侧 <code>for</code> 子句中的任何筛选条件不能在外层作用域中被求值，因为它们可能依赖于从最左侧可迭代对象中获得的值。 例如: <code>[x*y for x in range(10) for y in range(x, x+10)]</code>。</p>
<p>为了确保推导式得出的结果总是一个类型正确的容器，在隐式嵌套作用域内禁止使用 <code>yield</code> 和 <code>yield from</code> 表达式。</p>
<p>从 Python 3.6 开始，在 <code>async def</code> 函数中可以使用 <code>async for</code> 子句来迭代 asynchronous iterator。 在 <code>async def</code> 函数中构建推导式可以通过在打头的表达式后加上 <code>for</code> 或 <code>async for</code> 子句，也可能包含额外的 <code>for</code> 或 <code>async for</code> 子句，还可能使用 <code>await</code> 表达式。 如果一个推导式包含 <code>async for</code> 子句或者 <code>await</code> 表达式，则被称为 <em>异步推导式</em>。 异步推导式可以暂停执行它所在的协程函数。 另请参阅 <a href="https://www.python.org/dev/peps/pep-0530" target="_blank" rel="noopener"><strong>PEP 530</strong></a>。</p>
<p>3.6 新版功能: 引入了异步推导式。</p>
<p>在 3.8 版更改: <code>yield</code> 和 <code>yield from</code> 在隐式嵌套的作用域中已被禁用。</p>
<h4 id="6-2-5-列表显示"><a href="#6-2-5-列表显示" class="headerlink" title="6.2.5. 列表显示"></a>6.2.5. 列表显示</h4><p>列表显示是一个用方括号括起来的可能为空的表达式系列:</p>
<pre><code>list_display ::=  "[" [starred_list | comprehension] "]"</code></pre><p>列表显示会产生一个新的列表对象，其内容通过一系列表达式或一个推导式来指定。 当提供由逗号分隔的一系列表达式时，其元素会从左至右被求值并按此顺序放入列表对象。 当提供一个推导式时，列表会根据推导式所产生的结果元素进行构建。</p>
<h4 id="6-2-6-集合显示"><a href="#6-2-6-集合显示" class="headerlink" title="6.2.6. 集合显示"></a>6.2.6. 集合显示</h4><p>集合显示是用花括号标明的，与字典显示的区别在于没有冒号分隔的键和值:</p>
<pre><code>set_display ::=  "{" (starred_list | comprehension) "}"</code></pre><p>集合显示会产生一个新的可变集合对象，其内容通过一系列表达式或一个推导式来指定。 当提供由逗号分隔的一系列表达式时，其元素会从左至右被求值并加入到集合对象。 当提供一个推导式时，集合会根据推导式所产生的结果元素进行构建。</p>
<p>空集合不能用 <code>{}</code> 来构建；该字面值所构建的是一个空字典。</p>
<h4 id="6-2-7-字典显示"><a href="#6-2-7-字典显示" class="headerlink" title="6.2.7. 字典显示"></a>6.2.7. 字典显示</h4><p>字典显示是一个用花括号括起来的可能为空的键/数据对系列:</p>
<pre><code>dict_display       ::=  "{" [key_datum_list | dict_comprehension] "}"
key_datum_list     ::=  key_datum ("," key_datum)* [","]
key_datum          ::=  expression ":" expression | "**" or_expr
dict_comprehension ::=  expression ":" expression comp_for</code></pre><p>字典显示会产生一个新的字典对象。</p>
<p>如果给出一个由逗号分隔的键/数据对序列，它们会从左至右被求值以定义字典的条目：每个键对象会被用作在字典中存放相应数据的键。 这意味着你可以在键/数据对序列中多次指定相同的键，最终字典的值将由最后一次给出的键决定。</p>
<p>双星号 <code>**</code> 表示 <em>字典拆包</em>。 它的操作数必须是一个 mapping。 每个映射项被会加入新的字典。 后续的值会替代先前的键/数据对和先前的字典拆包所设置的值。</p>
<p>3.5 新版功能: 拆包到字典显示，最初由 <a href="https://www.python.org/dev/peps/pep-0448" target="_blank" rel="noopener"><strong>PEP 448</strong></a> 提出。</p>
<p>字典推导式与列表和集合推导式有所不同，它需要以冒号分隔的两个表达式，后面带上标准的 “for” 和 “if” 子句。 当推导式被执行时，作为结果的键和值元素会按它们的产生顺序被加入新的字典。</p>
<p> (总的说来，键的类型应该为 hashable，这就把所有可变对象都排除在外。) 重复键之间的冲突不会被检测；指定键所保存的最后一个数据 (即在显示中排最右边的文本) 为最终有效数据。</p>
<p>在 3.8 版更改: 在 Python 3.8 之前的字典推导式中，并没有定义好键和值的求值顺序。 在 CPython 中，值会先于键被求值。 根据 <a href="https://www.python.org/dev/peps/pep-0572" target="_blank" rel="noopener"><strong>PEP 572</strong></a> 的提议，从 3.8 开始，键会先于值被求值。</p>
<h4 id="6-2-8-生成器表达式"><a href="#6-2-8-生成器表达式" class="headerlink" title="6.2.8. 生成器表达式"></a>6.2.8. 生成器表达式</h4><p>生成器表达式是用圆括号括起来的紧凑形式生成器标注。</p>
<pre><code>generator_expression ::=  "(" expression comp_for ")"</code></pre><p>生成器表达式会产生一个新的生成器对象。 其句法与推导式相同，区别在于它是用圆括号而不是用方括号或花括号括起来的。</p>
<p>在生成器表达式中使用的变量会在为生成器对象调用 <code>__next__()</code> 方法的时候以惰性方式被求值（即与普通生成器相同的方式）。 但是，最左侧 <code>for</code> 子句内的可迭代对象是会被立即求值的，因此它所造成的错误会在生成器表达式被定义时被检测到，而不是在获取第一个值时才出错。 后续的 <code>for</code> 子句以及最左侧 <code>for</code> 子句内的任何筛选条件无法在外层作用域内被求值，因为它们可能会依赖于从最左侧可迭代对象获取的值。 例如: <code>(x*y for x in range(10) for y in range(x, x+10))</code>.</p>
<p>圆括号在只附带一个参数的调用中可以被省略。 </p>
<p>为了避免干扰到生成器表达式本身的预期操作，禁止在隐式定义的生成器中使用 <code>yield</code> 和 <code>yield from</code> 表达式。</p>
<p>如果生成器表达式包含 <code>async for</code> 子句或 <code>await</code> 表达式，则称为 <em>异步生成器表达式</em>。 异步生成器表达式会返回一个新的异步生成器对象，此对象属于异步迭代器 。</p>
<p>3.6 新版功能: 引入了异步生成器表达式。</p>
<p>在 3.7 版更改: 在 Python 3.7 之前，异步生成器表达式只能在 <code>async def</code> 协和中出现。 从 3.7 开始，任何函数都可以使用异步生成器表达式。</p>
<p>在 3.8 版更改: <code>yield</code> 和 <code>yield from</code> 在隐式嵌套的作用域中已被禁用。</p>
<h4 id="6-2-9-yield-表达式"><a href="#6-2-9-yield-表达式" class="headerlink" title="6.2.9. yield 表达式"></a>6.2.9. yield 表达式</h4><pre><code>yield_atom       ::=  "(" yield_expression ")"
yield_expression ::=  "yield" [expression_list | "from" expression]</code></pre><p>yield 表达式在定义 generator 函数或是 asynchronous generator 的时候才会用到。 因此只能在函数定义的内部使用yield表达式。 在一个函数体内使用 yield 表达式会使这个函数变成一个生成器，并且在一个 <code>async def</code> 定义的函数体内使用 yield 表达式会让协程函数变成异步的生成器。 比如说:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># defines a generator function</span>
    <span class="token keyword">yield</span> <span class="token number">123</span>
<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">agen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># defines an asynchronous generator function</span>
    <span class="token keyword">yield</span> <span class="token number">123</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于它们会对外层作用域造成附带影响，<code>yield</code> 表达式不被允许作为用于实现推导式和生成器表达式的隐式定义作用域的一部分。</p>
<p>在 3.8 版更改: 禁止在实现推导式和生成器表达式的隐式嵌套作用域中使用 yield 表达式。</p>
<p>下面是对生成器函数的描述，异步生成器函数会在 异步生成器函数 一节中单独介绍。</p>
<p>当一个生成器函数被调用的时候，它返回一个迭代器，称为生成器。然后这个生成器来控制生成器函数的执行。当这个生成器的某一个方法被调用的时候，生成器函数开始执行。这时会一直执行到第一个 yield 表达式，在此执行再次被挂起，给生成器的调用者返回 <code>expression_list</code> 的值。挂起后，我们说所有局部状态都被保留下来，包括局部变量的当前绑定，指令指针，内部求值栈和任何异常处理的状态。通过调用生成器的某一个方法，生成器函数继续执行。此时函数的运行就和 yield 表达式只是一个外部函数调用的情况完全一致。恢复后 yield 表达式的值取决于调用的哪个方法来恢复执行。 如果用的是 <code>__next__()</code> (通常通过语言内置的 <code>for</code> 或是 <code>next()</code> 来调用) 那么结果就是 <code>None</code>. 否则，如果用 <code>send()</code>, 那么结果就是传递给send方法的值。</p>
<p>所有这些使生成器函数与协程非常相似；它们 yield 多次，它们具有多个入口点，并且它们的执行可以被挂起。唯一的区别是生成器函数不能控制在它在 yield 后交给哪里继续执行；控制权总是转移到生成器的调用者。</p>
<p>在 <code>try</code> 结构中的任何位置都允许yield表达式。如果生成器在(因为引用计数到零或是因为被垃圾回收)销毁之前没有恢复执行，将调用生成器-迭代器的 <code>close()</code> 方法. close 方法允许任何挂起的 <code>finally</code> 子句执行。</p>
<p>当使用 <code>yield from &lt;expr&gt;</code> 时，所提供的表达式必须是一个可迭代对象。 迭代该可迭代对象所产生的值会被直接传递给当前生成器方法的调用者。 任何通过 <code>send()</code> 传入的值以及任何通过 <code>throw()</code> 传入的异常如果有适当的方法则会被传给下层迭代器。 如果不是这种情况，那么 <code>send()</code> 将引发 <code>AttributeError</code> 或 <code>TypeError</code>，而 <code>throw()</code> 将立即引发所转入的异常。</p>
<p>当下层迭代器完成时，被引发的 <code>StopIteration</code> 实例的 <code>value</code> 属性会成为 yield 表达式的值。 它可以在引发 <code>StopIteration</code> 时被显式地设置，也可以在子迭代器是一个生成器时自动地设置（通过从子生成器返回一个值）。</p>
<blockquote>
<p>在 3.3 版更改: 添加 <code>yield from &lt;expr&gt;</code> 以委托控制流给一个子迭代器。</p>
</blockquote>
<p>当yield表达式是赋值语句右侧的唯一表达式时，括号可以省略。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0255" target="_blank" rel="noopener"><strong>PEP 255</strong></a> - 简单生成器</p>
<p>在 Python 中加入生成器和 <code>yield</code> 语句的提议。</p>
<p><a href="https://www.python.org/dev/peps/pep-0342" target="_blank" rel="noopener"><strong>PEP 342</strong></a> - 通过增强型生成器实现协程</p>
<p>增强生成器 API 和语法的提议，使其可以被用作简单的协程。</p>
<p><a href="https://www.python.org/dev/peps/pep-0380" target="_blank" rel="noopener"><strong>PEP 380</strong></a> - 委托给子生成器的语法</p>
<p>引入 <code>yield_from</code> 语法以方便地委托给子生成器的提议。</p>
<p><a href="https://www.python.org/dev/peps/pep-0525" target="_blank" rel="noopener"><strong>PEP 525</strong></a> - 异步生成器</p>
<p>通过给协程函数加入生成器功能对 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 进行扩展的提议。</p>
<h5 id="6-2-9-1-生成器-迭代器的方法"><a href="#6-2-9-1-生成器-迭代器的方法" class="headerlink" title="6.2.9.1. 生成器-迭代器的方法"></a>6.2.9.1. 生成器-迭代器的方法</h5><p>这个子小节描述了生成器迭代器的方法。 它们可被用于控制生成器函数的执行。</p>
<p>请注意在生成器已经在执行时调用以下任何方法都会引发 <code>ValueError</code> 异常。</p>
<p><code>generator.__next__</code>()</p>
<p>开始一个生成器函数的执行或是从上次执行的 yield 表达式位置恢复执行。 当一个生成器函数通过 <code>__next__()</code> 方法恢复执行时，当前的 yield 表达式总是取值为 <code>None</code>。 随后会继续执行到下一个 yield 表达式，其 <code>expression_list</code> 的值会返回给 <code>__next__()</code> 的调用者。 如果生成器没有产生下一个值就退出，则将引发 <code>StopIteration</code> 异常。</p>
<p>此方法通常是隐式地调用，例如通过 <code>for</code> 循环或是内置的 <code>next()</code> 函数。</p>
<p><code>generator.send</code>(<em>value</em>)</p>
<p>恢复执行并向生成器函数“发送”一个值。 <em>value</em> 参数将成为当前 yield 表达式的结果。 <code>send()</code> 方法会返回生成器所产生的下一个值，或者如果生成器没有产生下一个值就退出则会引发 <code>StopIteration</code>。 当调用 <code>send()</code> 来启动生成器时，它必须以 <code>None</code> 作为调用参数，因为这时没有可以接收值的 yield 表达式。</p>
<p><code>generator.throw</code>(<em>type</em>[, <em>value</em>[, <em>traceback</em>]])</p>
<p>在生成器暂停的位置引发 <code>type</code> 类型的异常，并返回该生成器函数所产生的下一个值。 如果生成器没有产生下一个值就退出，则将引发 <code>StopIteration</code> 异常。 如果生成器函数没有捕获传入的异常，或引发了另一个异常，则该异常会被传播给调用者。</p>
<p><code>generator.close</code>()</p>
<p>在生成器函数暂停的位置引发 <code>GeneratorExit</code>。 如果之后生成器函数正常退出、关闭或引发 <code>GeneratorExit</code> (由于未捕获该异常) 则关闭并返回其调用者。 如果生成器产生了一个值，关闭会引发 <code>RuntimeError</code>。 如果生成器引发任何其他异常，它会被传播给调用者。 如果生成器已经由于异常或正常退出则 <code>close()</code> 不会做任何事。</p>
<h5 id="6-2-9-2-例子"><a href="#6-2-9-2-例子" class="headerlink" title="6.2.9.2. 例子"></a>6.2.9.2. 例子</h5><p>这里是一个简单的例子，演示了生成器和生成器函数的行为:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">echo</span><span class="token punctuation">(</span>value<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Execution starts when 'next()' is called for the first time."</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">yield</span> value<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                 value <span class="token operator">=</span> e
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">finally</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Don't forget to clean up when 'close()' is called."</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> generator <span class="token operator">=</span> echo<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>generator<span class="token punctuation">)</span><span class="token punctuation">)</span>
Execution starts when <span class="token string">'next()'</span> <span class="token keyword">is</span> called <span class="token keyword">for</span> the first time<span class="token punctuation">.</span>
<span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>generator<span class="token punctuation">)</span><span class="token punctuation">)</span>
None
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>generator<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span> generator<span class="token punctuation">.</span>throw<span class="token punctuation">(</span>TypeError<span class="token punctuation">,</span> <span class="token string">"spam"</span><span class="token punctuation">)</span>
TypeError<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">,</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> generator<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
Don<span class="token string">'t forget to clean up when '</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>' <span class="token keyword">is</span> called<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="6-2-9-3-异步生成器函数"><a href="#6-2-9-3-异步生成器函数" class="headerlink" title="6.2.9.3. 异步生成器函数"></a>6.2.9.3. 异步生成器函数</h5><p>在一个使用 <code>async def</code> 定义的函数或方法中出现的 yield 表达式会进一步将该函数定义为一个 asynchronous generator 函数。</p>
<p>当一个异步生成器函数被调用时，它会返回一个名为异步生成器对象的异步迭代器。 此对象将在之后控制该生成器函数的执行。 异步生成器对象通常被用在协程函数的 <code>async for</code> 语句中，类似于在 <code>for</code> 语句中使用生成器对象。</p>
<p>调用异步生成器的方法之一将返回 awaitable 对象，执行会在此对象被等待时启动。 到那时，执行将前往第一个 yield 表达式，在那里它会再次暂停，将 <code>expression_list</code> 的值返回给等待中的协程。 与生成器一样，挂起意味着局部的所有状态会被保留，包括局部变量的当前绑定、指令的指针、内部求值的堆栈以及任何异常处理的状态。 当执行在等待异步生成器的方法返回下一个对象后恢复时，该函数可以从原状态继续进行，就仿佛 yield 表达式只是另一个外部调用。 恢复执行之后 yield 表达式的值取决于恢复执行所用的方法。 如果使用 <code>__anext__()</code> 则结果为 <code>None</code>。 否则的话，如果使用 <code>asend()</code> 则结果将是传递给该方法的值。</p>
<p>如果一个异步生成器恰好因 <code>break</code>、调用方任务被取消，或是其他异常而提前退出，生成器的异步清理代码将会运行并可能引发异常或访问意外上下文中的上下文变量 — 也许是在它所依赖的任务的生命周期之后，或是在异步生成器垃圾回收钩子被调用时的事件循环关闭期间。 为了防止这种情况，调用方必须通过调用 <code>aclose()</code> 方法来显式地关闭异步生成器以终结生成器并最终从事件循环中将其分离。</p>
<p>在异步生成器函数中，yield 表达式允许出现在 <code>try</code> 结构的任何位置。 但是，如果一个异步生成器在其被终结（由于引用计数达到零或被作为垃圾回收）之前未被恢复，则then a yield expression within a <code>try</code> 结构中的 yield 表达式可能导致挂起的 <code>finally</code> 子句执行失败。 在此情况下，应由运行该异步生成器的事件循环或任务调度器来负责调用异步生成器-迭代器的 <code>aclose()</code> 方法并运行所返回的协程对象，从而允许任何挂起的 <code>finally</code> 子句得以执行。</p>
<p>为了能在事件循环终结时执行最终化处理，事件循环应当定义一个 <em>终结器</em> 函数，它接受一个异步生成器迭代器并将调用 <code>aclose()</code> 且执行该协程。 这个 <em>终结器</em> 可以通过调用 <code>sys.set_asyncgen_hooks()</code> 来注册。 当首次迭代时，异步生成器迭代器将保存已注册的 <em>终结器</em> 以便在最终化时调用。 有关 <em>终结器</em> 方法的参考示例请查看在 Lib/asyncio/base_events.py 的中的 <code>asyncio.Loop.shutdown_asyncgens</code> 实现。</p>
<p><code>yield from &lt;expr&gt;</code> 表达式如果在异步生成器函数中使用会引发语法错误。</p>
<h5 id="6-2-9-4-异步生成器-迭代器方法"><a href="#6-2-9-4-异步生成器-迭代器方法" class="headerlink" title="6.2.9.4. 异步生成器-迭代器方法"></a>6.2.9.4. 异步生成器-迭代器方法</h5><p>这个子小节描述了异步生成器迭代器的方法，它们可被用于控制生成器函数的执行。</p>
<p><em>coroutine</em> <code>agen.__anext__</code>()</p>
<p>返回一个可等待对象，它在运行时会开始执行该异步生成器或是从上次执行的 yield 表达式位置恢复执行。 当一个异步生成器函数通过 <code>__anext__()</code> 方法恢复执行时，当前的 yield 表达式所返回的可等待对象总是取值为 <code>None</code>，它在运行时将继续执行到下一个 yield 表达式。 该 yield 表达式的 <code>expression_list</code> 的值会是完成的协程所引发的 <code>StopIteration</code> 异常的值。 如果异步生成器没有产生下一个值就退出，则该可等待对象将引发 <code>StopAsyncIteration</code> 异常，提示该异步迭代操作已完成。</p>
<p>此方法通常是通过 <code>async for</code> 循环隐式地调用。</p>
<p><em>coroutine</em> <code>agen.asend</code>(<em>value</em>)</p>
<p>返回一个可等待对象，它在运行时会恢复该异步生成器的执行。 与生成器的 <code>send()</code> 方法一样，此方法会“发送”一个值给异步生成器函数，其 <em>value</em> 参数会成为当前 yield 表达式的结果值。 <code>asend()</code> 方法所返回的可等待对象将返回生成器产生的下一个值，其值为所引发的 <code>StopIteration</code>，或者如果异步生成器没有产生下一个值就退出则引发 <code>StopAsyncIteration</code>。 当调用 <code>asend()</code> 来启动异步生成器时，它必须以 <code>None</code> 作为调用参数，因为这时没有可以接收值的 yield 表达式。</p>
<p><em>coroutine</em> <code>agen.athrow</code>(<em>type</em>[, <em>value</em>[, <em>traceback</em>]])</p>
<p>返回一个可等待对象，它会在异步生成器暂停的位置引发 <code>type</code> 类型的异常，并返回该生成器函数所产生的下一个值，其值为所引发的 <code>StopIteration</code> 异常。 如果异步生成器没有产生下一个值就退出，则将由该可等待对象引发 <code>StopAsyncIteration</code> 异步。 如果生成器函数没有捕获传入的异常，或引发了另一个异常，则当可等待对象运行时该异常会被传播给可等待对象的调用者。</p>
<p><em>coroutine</em> <code>agen.aclose</code>()</p>
<p>返回一个可等待对象，它会在运行时向异步生成器函数暂停的位置抛入一个 <code>GeneratorExit</code>。 如果该异步生成器函数正常退出、关闭或引发 <code>GeneratorExit</code> (由于未捕获该异常) 则返回的可等待对象将引发 <code>StopIteration</code> 异常。 后续调用异步生成器所返回的任何其他可等待对象将引发 <code>StopAsyncIteration</code> 异常。 如果异步生成器产生了一个值，该可等待对象会引发 <code>RuntimeError</code>。 如果异步生成器引发任何其他异常，它会被传播给可等待对象的调用者。 如果异步生成器已经由于异常或正常退出则后续调用 <code>aclose()</code> 将返回一个不会做任何事的可等待对象。</p>
<h3 id="6-3-原型"><a href="#6-3-原型" class="headerlink" title="6.3. 原型"></a>6.3. 原型</h3><p>原型代表编程语言中最紧密绑定的操作。 它们的句法如下:</p>
<pre><code>primary ::=  atom | attributeref | subscription | slicing | call</code></pre><h4 id="6-3-1-属性引用"><a href="#6-3-1-属性引用" class="headerlink" title="6.3.1. 属性引用"></a>6.3.1. 属性引用</h4><p>属性引用是后面带有一个句点加一个名称的原型:</p>
<pre><code>attributeref ::=  primary "." identifier</code></pre><p>此原型必须求值为一个支持属性引用的类型的对象，多数对象都支持属性引用。 随后该对象会被要求产生以指定标识符为名称的属性。 这个产生过程可通过重载 <code>__getattr__()</code> 方法来自定义。 如果这个属性不可用，则将引发 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/177bd954d1cc6696.md#AttributeError" target="_blank" rel="noopener"><code>AttributeError</code></a> 异常。 否则的话，所产生对象的类型和值会根据该对象来确定。 对同一属性引用的多次求值可能产生不同的对象。</p>
<h4 id="6-3-2-抽取"><a href="#6-3-2-抽取" class="headerlink" title="6.3.2. 抽取"></a>6.3.2. 抽取</h4><p>对序列（字符串、元组或列表）或映射（字典）对象的抽取操作通常就是从相应的多项集中选择一项:</p>
<pre><code>subscription ::=  primary "[" expression_list "]"</code></pre><p>此原型必须求值为一个支持抽取操作的对象（例如列表或字典）。 用户定义的对象可通过定义 <code>__getitem__()</code> 方法来支持抽取操作。</p>
<p>对于内置对象，有两种类型的对象支持抽取操作:</p>
<p>如果原型为映射，表达式列表必须求值为一个以该映射的键为值的对象，抽取操作会在映射中选出该键所对应的值。（表达式列表为一个元组，除非其中只有一项。）</p>
<p>如果原型为序列，表达式列表必须求值为一个整数或一个切片（详情见下节）。</p>
<p>正式句法规则并没有在序列中设置负标号的特殊保留条款；但是，内置序列所提供的 <code>__getitem__()</code> 方法都可通过在索引中添加序列长度来解析负标号 (这样 <code>x[-1]</code> 会选出 <code>x</code> 中的最后一项)。 结果值必须为一个小于序列中项数的非负整数，抽取操作会选出标号为该值的项（从零开始数）。 由于对负标号和切片的支持存在于对象的 <code>__getitem__()</code> 方法，重载此方法的子类需要显式地添加这种支持。</p>
<p>字符串的项是字符。 字符不是单独的数据类型而是仅有一个字符的字符串。</p>
<p>对特定 类 或 类型 的抽取操作会创建一个 泛型别名。 在此情况下，用户自定义类型可通过提供 <code>__class_getitem__()</code> 类方法来支持抽取操作。</p>
<h4 id="6-3-3-切片"><a href="#6-3-3-切片" class="headerlink" title="6.3.3. 切片"></a>6.3.3. 切片</h4><p>切片就是在序列对象（字符串、元组或列表）中选择某个范围内的项。 切片可被用作表达式以及赋值或 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/c8810d126a4a3f87.md#del" target="_blank" rel="noopener"><code>del</code></a> 语句的目标。 切片的句法如下:</p>
<pre><code>slicing      ::=  primary "[" slice_list "]"
slice_list   ::=  slice_item ("," slice_item)* [","]
slice_item   ::=  expression | proper_slice
proper_slice ::=  [lower_bound] ":" [upper_bound] [ ":" [stride] ]
lower_bound  ::=  expression
upper_bound  ::=  expression
stride       ::=  expression</code></pre><p>此处的正式句法中存在一点歧义：任何形似表达式列表的东西同样也会形似切片列表，因此任何抽取操作也可以被解析为切片。 为了不使句法更加复杂，于是通过定义将此情况解析为抽取优先于解析为切片来消除这种歧义（切片列表未包含正确的切片就属于此情况）。</p>
<p>切片的语义如下所述。 元型通过一个根据下面的切片列表来构造的键进行索引（与普通抽取一样使用 <code>__getitem__()</code> 方法）。 如果切片列表包含至少一个逗号，则键将是一个包含切片项转换的元组；否则的话，键将是单个切片项的转换。 切片项如为一个表达式，则其转换就是该表达式。 一个正确切片的转换就是一个切片对象，该对象的 <code>start</code>, <code>stop</code> 和 <code>step</code> 属性将分别为表达式所给出的下界、上界和步长值，省略的表达式将用 <code>None</code> 来替换。</p>
<h4 id="6-3-4-调用"><a href="#6-3-4-调用" class="headerlink" title="6.3.4. 调用"></a>6.3.4. 调用</h4><p>所谓调用就是附带可能为空的一系列 参数 来执行一个可调用对象 (例如 function):</p>
<pre><code>call                 ::=  primary "(" [argument_list [","] | comprehension] ")"
argument_list        ::=  positional_arguments ["," starred_and_keywords]
                            ["," keywords_arguments]
                          | starred_and_keywords ["," keywords_arguments]
                          | keywords_arguments
positional_arguments ::=  positional_item ("," positional_item)*
positional_item      ::=  assignment_expression | "*" expression
starred_and_keywords ::=  ("*" expression | keyword_item)
                          ("," "*" expression | "," keyword_item)*
keywords_arguments   ::=  (keyword_item | "**" expression)
                          ("," keyword_item | "," "**" expression)*
keyword_item         ::=  identifier "=" expression</code></pre><p>一个可选项为在位置和关键字参数后加上逗号而不影响语义。</p>
<p>此原型必须求值为一个可调用对象（用户定义的函数，内置函数，内置对象的方法，类对象，类实例的方法以及任何具有 <code>__call__()</code> 方法的对象都是可调用对象）。 所有参数表达式将在尝试调用前被求值。 </p>
<p>如果存在关键字参数，它们会先通过以下操作被转换为位置参数。 首先，为正式参数创建一个未填充空位的列表. 如果有 N 个位置参数，则将它们放入前 N 个空位。 然后，对于每个关键字参数，使用标识符来确定其对应的空位（如果标识符与第一个正式参数名相同则使用第一个个空位，依此类推）。 如果空位已被填充，则会引发 <code>TypeError</code> 异常。 否则，将参数值放入空位进行填充（即使表达式为 <code>None</code> 也会填充空位）。 当所有参数处理完毕时，尚未填充的空位将用来自函数定义的相应默认值来填充。 （函数一旦定义其参数默认值就会被计算；因此，当列表或字典这类可变对象被用作默认值时，将会被所有未指定相应空位参数值的调用所共享；这种情况通常应当避免。） 如果任何一个未填充空位没有指定默认值，则会引发 <code>TypeError</code> 异常。 否则的话，已填充空位的列表会被作为调用的参数列表。</p>
<p><strong>CPython implementation detail:</strong> 某些实现可能提供位置参数没有名称的内置函数，即使它们在文档说明的场合下有“命名”，因此不能以关键字形式提供参数。 在 CPython 中，以 C 编写并使用 <code>PyArg_ParseTuple()</code> 来解析其参数的函数实现就属于这种情况。</p>
<p>如果存在比正式参数空位多的位置参数，将会引发 <code>TypeError</code> 异常，除非有一个正式参数使用了 <code>*identifier</code> 句法；在此情况下，该正式参数将接受一个包含了多余位置参数的元组（如果没有多余位置参数则为一个空元组）。</p>
<p>如果任何关键字参数没有与之对应的正式参数名称，将会引发 <code>TypeError</code> 异常，除非有一个正式参数使用了 <code>**identifier</code> 句法，该正式参数将接受一个包含了多余关键字参数的字典（使用关键字作为键而参数值作为与键对应的值），如果没有多余关键字参数则为一个（新的）空字典。</p>
<p>如果函数调用中出现了 <code>*expression</code> 句法，<code>expression</code> 必须求值为一个 iterable。 来自该可迭代对象的元素会被当作是额外的位置参数。 对于 <code>f(x1, x2, *y, x3, x4)</code> 调用，如果 <em>y</em> 求值为一个序列 <em>y1</em>, …, <em>yM*，则它就等价于一个带有 M+4 个位置参数 *x1</em>, <em>x2</em>, <em>y1</em>, …, <em>yM</em>, <em>x3</em>, <em>x4</em> 的调用。</p>
<p>这样做的一个后果是虽然 <code>*expression</code> 句法可能出现于显式的关键字参数 <em>之后<em>，但它会在关键字参数（以及任何 `*</em>expression` 参数 — 见下文） *之前</em> 被处理。 因此:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">(</span>b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">2</span> <span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> f<span class="token punctuation">(</span><span class="token punctuation">)</span> got multiple values <span class="token keyword">for</span> keyword argument <span class="token string">'a'</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">1</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在同一个调用中同时使用关键字参数和 <code>*expression</code> 句法并不常见，因此实际上这样的混淆不会发生。</p>
<p>如果函数调用中出现了 <code>**expression</code> 句法，<code>expression</code> 必须求值为一个 mapping，其内容会被当作是额外的关键字参数。 如果一个关键字已存在（作为显式关键字参数，或来自另一个拆包），则将引发 <code>TypeError</code> 异常。</p>
<p>使用 <code>*identifier</code> 或 <code>**identifier</code> 句法的正式参数不能被用作位置参数空位或关键字参数名称。</p>
<p>在 3.5 版更改: 函数调用接受任意数量的 <code>*</code> 和 <code>**</code> 拆包，位置参数可能跟在可迭代对象拆包 (<code>*</code>) 之后，而关键字参数可能跟在字典拆包 (<code>**</code>) 之后。 由 <a href="https://www.python.org/dev/peps/pep-0448" target="_blank" rel="noopener"><strong>PEP 448</strong></a> 发起最初提议。</p>
<p>除非引发了异常，调用总是会有返回值，返回值也可能为 <code>None</code>。 返回值的计算方式取决于可调用对象的类型。</p>
<p>如果类型为—-</p>
<p>用户自定义函数:</p>
<p>函数的代码块会被执行，并向其传入参数列表。 代码块所做的第一件事是将正式形参绑定到对应参数。 当代码块执行 <code>return</code> 语句时，由其指定函数调用的返回值。</p>
<p>内置函数或方法:</p>
<p>具体结果依赖于解释器。</p>
<p>类对象:</p>
<p>返回该类的一个新实例。</p>
<p>类实例方法:</p>
<p>调用相应的用户自定义函数，向其传入的参数列表会比调用的参数列表多一项：该实例将成为第一个参数。</p>
<p>类实例:</p>
<p>该类必须定义有 <code>__call__()</code> 方法；作用效果将等价于调用该方法。</p>
<h3 id="6-4-await-表达式"><a href="#6-4-await-表达式" class="headerlink" title="6.4. await 表达式"></a>6.4. await 表达式</h3><p>挂起 coroutine 的执行以等待一个 awaitable 对象。 只能在 coroutine function 内部使用。</p>
<pre><code>await_expr ::=  "await" primary</code></pre><p>3.5 新版功能.</p>
<h3 id="6-5-幂运算符"><a href="#6-5-幂运算符" class="headerlink" title="6.5. 幂运算符"></a>6.5. 幂运算符</h3><p>幂运算符的绑定比在其左侧的一元运算符更紧密；但绑定紧密程度不及在其右侧的一元运算符。 句法如下:</p>
<pre><code>power ::=  (await_expr | primary) ["**" u_expr]</code></pre><p>因此，在一个未加圆括号的幂运算符和单目运算符序列中，运算符将从右向左求值（这不会限制操作数的求值顺序）: <code>-1**2</code> 结果将为 <code>-1</code>。</p>
<p>幂运算符与附带两个参数调用内置 <code>pow()</code> 函数具有相同的语义：结果为对其左参数进行其右参数所指定幂次的乘方运算。 数值参数会先转换为相同类型，结果也为转换后的类型。</p>
<p>对于 int 类型的操作数，结果将具有与操作数相同的类型，除非第二个参数为负数；在那种情况下，所有参数会被转换为 float 类型并输出 float 类型的结果。 例如，<code>10**2</code> 返回 <code>100</code>，而 <code>10**-2</code> 返回 <code>0.01</code>。</p>
<p>对 <code>0.0</code> 进行负数幂次运算将导致 <code>ZeroDivisionError</code>。 对负数进行分数幂次运算将返回 <code>complex</code> 数值。 （在早期版本中这将引发 <code>ValueError</code>。）</p>
<p>此运算符可使用特殊的 <code>__pow__()</code> 方法来自定义。</p>
<h3 id="6-6-一元算术和位运算"><a href="#6-6-一元算术和位运算" class="headerlink" title="6.6. 一元算术和位运算"></a>6.6. 一元算术和位运算</h3><p>所有算术和位运算具有相同的优先级:</p>
<pre><code>u_expr ::=  power | "-" u_expr | "+" u_expr | "~" u_expr</code></pre><p>一元的 <code>-</code> (负值) 运算符会产生其数字参数的负值；该运算可通过 <code>__neg__()</code> 特殊方法来重载。</p>
<p>一元的 <code>+</code> (正值) 运算符会原样输出其数字参数；该运算可通过 <code>__pos__()</code> 特殊方法来重载。</p>
<p>一元的 <code>~</code> (取反) 运算符会对其整数参数按位取反。 <code>x</code> 的按位取反被定义为 <code>-(x+1)</code>。 它只作用于整数或是重载了 <code>__invert__()</code> 特殊方法的自定义对象。</p>
<p>在所有三种情况下，如果参数的类型不正确，将引发 <code>TypeError</code> 异常。</p>
<h3 id="6-7-二元算术运算符"><a href="#6-7-二元算术运算符" class="headerlink" title="6.7. 二元算术运算符"></a>6.7. 二元算术运算符</h3><p>二元算术运算符遵循传统的优先级。 请注意某些此类运算符也作用于特定的非数字类型。 除幂运算符以外只有两个优先级别，一个作用于乘法型运算符，另一个作用于加法型运算符:</p>
<pre><code>m_expr ::=  u_expr | m_expr "*" u_expr | m_expr "@" m_expr |
            m_expr "//" u_expr | m_expr "/" u_expr |
            m_expr "%" u_expr
a_expr ::=  m_expr | a_expr "+" m_expr | a_expr "-" m_expr</code></pre><p>运算符 <code>*</code> (乘) 将输出其参数的乘积。 两个参数或者必须都为数字，或者一个参数必须为整数而另一个参数必须为序列。 在前一种情况下，两个数字将被转换为相同类型然后相乘。 在后一种情况下，将执行序列的重复；重复因子为负数将输出空序列。</p>
<p>此运算可使用特殊的 <code>__mul__()</code> 和 <code>__rmul__()</code> 方法来自定义。</p>
<p>运算符 <code>@</code> (at) 的目标是用于矩阵乘法。 没有内置 Python 类型实现此运算符。</p>
<p>3.5 新版功能.</p>
<p>运算符 <code>/</code> (除) 和 <code>//</code> (整除) 将输出其参数的商。 两个数字参数将先被转换为相同类型。 整数相除会输出一个 float 值，整数相整除的结果仍是整数；整除的结果就是使用 ‘floor’ 函数进行算术除法的结果。 除以零的运算将引发 <code>ZeroDivisionError</code> 异常。</p>
<p>This operation can be customized using the special <code>__truediv__()</code> and <code>__floordiv__()</code> methods.</p>
<p>运算符 <code>%</code> (模) 将输出第一个参数除以第二个参数的余数。 两个数字参数将先被转换为相同类型。 右参数为零将引发 <code>ZeroDivisionError</code> 异常。 参数可以为浮点数，例如 <code>3.14%0.7</code> 等于 <code>0.34</code> (因为 <code>3.14</code> 等于 <code>4*0.7 + 0.34</code>)。 模运算符的结果的正负总是与第二个操作数一致（或是为零）；结果的绝对值一定小于第二个操作数的绝对值 。</p>
<p>整除与模运算符的联系可通过以下等式说明: <code>x == (x//y)*y + (x%y)</code>。 此外整除与模也可通过内置函数 <code>divmod()</code> 来同时进行: <code>divmod(x, y) == (x//y, x%y)</code>。</p>
<p>除了对数字执行模运算，运算符 <code>%</code> 还被字符串对象重载用于执行旧式的字符串格式化（又称插值）。 字符串格式化句法的描述参见 Python 库参考的 printf 风格的字符串格式化 一节。</p>
<p><em>取余</em> 运算可使用特殊的 <code>__mod__()</code> 方法来自定义。</p>
<p>整除运算符，模运算符和 <code>divmod()</code> 函数未被定义用于复数。 如果有必要可以使用 <code>abs()</code> 函数将其转换为浮点数。</p>
<p>运算符 <code>+</code> (addition) 将输出其参数的和。 两个参数或者必须都为数字，或者都为相同类型的序列。 在前一种情况下，两个数字将被转换为相同类型然后相加。 在后一种情况下，将执行序列拼接操作。</p>
<p>此运算可使用特殊的 <code>__add__()</code> 和 <code>__radd__()</code> 方法来自定义。</p>
<p>运算符 <code>-</code> (减) 将输出其参数的差。 两个数字参数将先被转换为相同类型。</p>
<p>此运算可使用特殊的 <code>__sub__()</code> 方法来自定义。</p>
<h3 id="6-8-移位运算"><a href="#6-8-移位运算" class="headerlink" title="6.8. 移位运算"></a>6.8. 移位运算</h3><p>移位运算的优先级低于算术运算:</p>
<pre><code>shift_expr ::=  a_expr | shift_expr ("&lt;&lt;" | "&gt;&gt;") a_expr</code></pre><p>这些运算符接受整数参数。 它们会将第一个参数左移或右移第二个参数所指定的比特位数。</p>
<p>此运算可使用特殊的 <code>__lshift__()</code> 和 <code>__rshift__()</code> 方法来自定义。</p>
<p>右移 <em>n</em> 位被定义为被 <code>pow(2,n)</code> 整除。 左移 <em>n</em> 位被定义为乘以 <code>pow(2,n)</code>。</p>
<h3 id="6-9-二元位运算"><a href="#6-9-二元位运算" class="headerlink" title="6.9. 二元位运算"></a>6.9. 二元位运算</h3><p>三种位运算具有各不相同的优先级:</p>
<pre><code>and_expr ::=  shift_expr | and_expr "&amp;" shift_expr
xor_expr ::=  and_expr | xor_expr "^" and_expr
or_expr  ::=  xor_expr | or_expr "|" xor_expr</code></pre><p><code>&amp;</code> 运算符会对其参数执行按位 AND，参数必须都为整数或者其中之一必须为重载了 <code>__and__()</code> 或 <code>__rand__()</code> 特殊方法的自定义对象。</p>
<p><code>^</code> 运算符会对其参数执行按位 XOR (异 OR)，参数必须都为整数或者其中之一必须为重载了 <code>__xor__()</code> 或 <code>__rxor__()</code> 特殊方法的自定义对象。</p>
<p><code>|</code> 运算符会对其参数执行按位 (合并) OR，参数必须都为整数或者其中之一必须为重载了 <code>__or__()</code> 或 <code>__ror__()</code> 特殊方法的自定义对象。</p>
<h3 id="6-10-比较运算"><a href="#6-10-比较运算" class="headerlink" title="6.10. 比较运算"></a>6.10. 比较运算</h3><p>与 C 不同，Python 中所有比较运算的优先级相同，低于任何算术、移位或位运算。 另一个与 C 不同之处在于 <code>a &lt; b &lt; c</code> 这样的表达式会按传统算术法则来解读:</p>
<pre><code>comparison    ::=  or_expr (comp_operator or_expr)*
comp_operator ::=  "&lt;" | "&gt;" | "==" | "&gt;=" | "&lt;=" | "!="
                   | "is" ["not"] | ["not"] "in"</code></pre><p>比较运算会产生布尔值: <code>True</code> 或 <code>False</code>。 自定义的 <em>富比较方法</em> 可能返回非布尔值。 在此情况下 Python 将在布尔运算上下文中对该值调用 <code>bool()</code>。</p>
<p>比较运算可以任意串连，例如 <code>x &lt; y &lt;= z</code> 等价于 <code>x &lt; y and y &lt;= z</code>，除了 <code>y</code> 只被求值一次（但在两种写法下当 <code>x &lt; y</code> 值为假时 <code>z</code> 都不会被求值）。</p>
<p>正式的说法是这样：如果 <em>a</em>, <em>b</em>, <em>c</em>, …, <em>y</em>, <em>z</em> 为表达式而 <em>op1</em>, <em>op2</em>, …, <em>opN</em> 为比较运算符，则 <code>a op1 b op2 c ... y opN z</code> 就等价于 <code>a op1 b and b op2 c and ... y opN z</code>，不同点在于每个表达式最多只被求值一次。</p>
<p>请注意 <code>a op1 b op2 c</code> 不意味着在 <em>a</em> 和 <em>c</em> 之间进行任何比较，因此，如 <code>x &lt; y &gt; z</code> 这样的写法是完全合法的（虽然也许不太好看）。</p>
<h4 id="6-10-1-值比较"><a href="#6-10-1-值比较" class="headerlink" title="6.10.1. 值比较"></a>6.10.1. 值比较</h4><p>运算符 <code>&lt;</code>, <code>&gt;</code>, <code>==</code>, <code>&gt;=</code>, <code>&lt;=</code> 和 <code>!=</code> 将比较两个对象的值。 两个对象不要求为相同类型。</p>
<p> 对象值在 Python 中是一个相当抽象的概念：例如，对象值并没有一个规范的访问方法。 而且，对象值并不要求具有特定的构建方式，例如由其全部数据属性组成等。 比较运算符实现了一个特定的对象值概念。 人们可以认为这是通过实现对象比较间接地定义了对象值。</p>
<p>由于所有类型都是 <code>object</code> 的（直接或间接）子类型，它们都从 <code>object</code> 继承了默认的比较行为。 类型可以通过实现 <em>丰富比较方法</em> 例如 <code>__lt__()</code> 来定义自己的比较行为。</p>
<p>默认的一致性比较 (<code>==</code> 和 <code>!=</code>) 是基于对象的标识号。 因此，具有相同标识号的实例一致性比较结果为相等，具有不同标识号的实例一致性比较结果为不等。 规定这种默认行为的动机是希望所有对象都应该是自反射的 (即 <code>x is y</code> 就意味着 <code>x == y</code>)。</p>
<p>次序比较 (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> 和 <code>&gt;=</code>) 默认没有提供；如果尝试比较会引发 <code>TypeError</code>。 规定这种默认行为的原因是缺少与一致性比较类似的固定值。</p>
<p>按照默认的一致性比较行为，具有不同标识号的实例总是不相等，这可能不适合某些对象值需要有合理定义并有基于值的一致性的类型。 这样的类型需要定制自己的比较行为，实际上，许多内置类型都是这样做的。</p>
<p>以下列表描述了最主要内置类型的比较行为。</p>
<ul>
<li><p>内置数值类型 (数字类型 —- int, float, complex) 以及标准库类型 <code>fractions.Fraction</code> 和 <code>decimal.Decimal</code> 可进行类型内部和跨类型的比较，例外限制是复数不支持次序比较。 在类型相关的限制以内，它们会按数学（算法）规则正确进行比较且不会有精度损失。</p>
<p>非数字值 <code>float('NaN')</code> 和 <code>decimal.Decimal('NaN')</code> 属于特例。 任何数字与非数字值的排序比较均返回假值。 还有一个反直觉的结果是非数字值不等于其自身。 举例来说，如果 <code>x = float('NaN')</code> 则 <code>3 &lt; x</code>, <code>x &lt; 3</code> 和 <code>x == x</code> 均为假值，而 <code>x != x</code> 则为真值。 此行为是遵循 IEEE 754 标准的。</p>
</li>
<li><p><code>None</code> 和 <code>NotImplemented</code> 都是单例对象。 <a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener"><strong>PEP 8</strong></a> 建议单例对象的比较应当总是通过 <code>is</code> 或 <code>is not</code> 而不是等于运算符来进行。</p>
</li>
<li><p>二进制码序列 (<code>bytes</code> 或 <code>bytearray</code> 的实例) 可进行类型内部和跨类型的比较。 它们使用其元素的数字值按字典顺序进行比较。</p>
</li>
<li><p>字符串 (<code>str</code> 的实例) 使用其字符的 Unicode 码位数字值 (内置函数 <code>ord()</code> 的结果) 按字典顺序进行比较.</p>
<p>字符串和二进制码序列不能直接比较。</p>
</li>
<li><p>序列 (<code>tuple</code>, <code>list</code> 或 <code>range</code> 的实例) 只可进行类型内部的比较，range 还有一个限制是不支持次序比较。 以上对象的跨类型一致性比较结果将是不相等，跨类型次序比较将引发 <code>TypeError</code>。</p>
<p>序列比较是按字典序对相应元素进行逐个比较。 内置容器通常设定同一对象与其自身是相等的。 这使得它们能跳过同一对象的相等性检测以提升运行效率并保持它们的内部不变性。</p>
<p>内置多项集间的字典序比较规则如下:</p>
<ul>
<li>两个多项集若要相等，它们必须为相同类型、相同长度，并且每对相应的元素都必须相等（例如，<code>[1,2] == (1,2)</code> 为假值，因为类型不同）。</li>
<li>对于支持次序比较的多项集，排序与其第一个不相等元素的排序相同（例如 <code>[1,2,x] &lt;= [1,2,y]</code> 的值与<code>x &lt;= y</code> 相同）。 如果对应元素不存在，较短的多项集排序在前（例如 <code>[1,2] &lt; [1,2,3]</code> 为真值）。</li>
</ul>
</li>
<li><p>两个映射 (<code>dict</code> 的实例) 若要相等，必须当且仅当它们具有相同的 (键, 值) 对。 键和值的一致性比较强制规定自反射性。</p>
<p>次序比较 (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> 和 <code>&gt;=</code>) 将引发 <code>TypeError</code>。</p>
</li>
<li><p>集合 (<code>set</code> 或 <code>frozenset</code> 的实例) 可进行类型内部和跨类型的比较。</p>
<p>它们将比较运算符定义为子集和超集检测。 这类关系没有定义完全排序（例如 <code>{1,2}</code> 和 <code>{2,3}</code> 两个集合不相等，即不为彼此的子集，也不为彼此的超集。 相应地，集合不适宜作为依赖于完全排序的函数的参数（例如如果给出一个集合列表作为 <code>min()</code>, <code>max()</code> 和 <code>sorted()</code> 的输入将产生未定义的结果）。</p>
<p>集合的比较强制规定其元素的自反射性。</p>
</li>
<li><p>大多数其他内置类型没有实现比较方法，因此它们会继承默认的比较行为。</p>
</li>
</ul>
<p>在可能的情况下，用户定义类在定制其比较行为时应当遵循一些一致性规则:</p>
<ul>
<li><p>相等比较应该是自反射的。 换句话说，相同的对象比较时应该相等:</p>
<blockquote>
<p><code>x is y</code> 意味着 <code>x == y</code></p>
</blockquote>
</li>
<li><p>比较应该是对称的。 换句话说，下列表达式应该有相同的结果:</p>
<blockquote>
<p><code>x == y</code> 和 <code>y == x</code></p>
<p><code>x != y</code> 和 <code>y != x</code></p>
<p><code>x &lt; y</code> 和 <code>y &gt; x</code></p>
<p><code>x &lt;= y</code> 和 <code>y &gt;= x</code></p>
</blockquote>
</li>
<li><p>比较应该是可传递的。 下列（简要的）例子显示了这一点:</p>
<blockquote>
<p><code>x &gt; y and y &gt; z</code> 意味着 <code>x &gt; z</code></p>
<p><code>x &lt; y and y &lt;= z</code> 意味着 <code>x &lt; z</code></p>
</blockquote>
</li>
<li><p>反向比较应该导致布尔值取反。 换句话说，下列表达式应该有相同的结果:</p>
<blockquote>
<p><code>x == y</code> 和 <code>not x != y</code></p>
<p><code>x &lt; y</code> 和 <code>not x &gt;= y</code> (对于完全排序)</p>
<p><code>x &gt; y</code> 和 <code>not x &lt;= y</code> (对于完全排序)</p>
</blockquote>
<p>最后两个表达式适用于完全排序的多项集（即序列而非集合或映射）。 </p>
</li>
<li><p><code>hash()</code> 的结果应该与是否相等一致。 相等的对象应该或者具有相同的哈希值，或者标记为不可哈希。</p>
</li>
</ul>
<p>Python 并不强制要求这些一致性规则。 实际上，非数字值就是一个不遵循这些规则的例子。</p>
<h4 id="6-10-2-成员检测运算"><a href="#6-10-2-成员检测运算" class="headerlink" title="6.10.2. 成员检测运算"></a>6.10.2. 成员检测运算</h4><p>运算符 <code>in</code> 和 <code>not in</code> 用于成员检测。 如果 <em>x</em> 是 <em>s</em> 的成员则 <code>x in s</code> 求值为 <code>True</code>，否则为 <code>False</code>。 <code>x not in s</code> 返回 <code>x in s</code> 取反后的值。 所有内置序列和集合类型以及字典都支持此运算，对于字典来说 <code>in</code> 检测其是否有给定的键。 对于 list, tuple, set, frozenset, dict 或 collections.deque 这样的容器类型，表达式 <code>x in y</code> 等价于 <code>any(x is e or x == e for e in y)</code>。</p>
<p>对于字符串和字节串类型来说，当且仅当 <em>x</em> 是 <em>y</em> 的子串时 <code>x in y</code> 为 <code>True</code>。 一个等价的检测是 <code>y.find(x) != -1</code>。 空字符串总是被视为任何其他字符串的子串，因此 <code>"" in "abc"</code> 将返回 <code>True</code>。</p>
<p>对于定义了 <code>__contains__()</code> 方法的用户自定义类来说，如果 <code>y.__contains__(x)</code> 返回真值则 <code>x in y</code> 返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>对于未定义 <code>__contains__()</code> 但定义了 <code>__iter__()</code> 的用户自定义类来说，如果在对 <code>y</code> 进行迭代时产生了值 <code>z</code> 使得表达式 <code>x is z or x == z</code> 为真，则 <code>x in y</code> 为 <code>True</code>。 如果在迭代期间引发了异常，则等同于 <code>in</code> 引发了该异常。</p>
<p>最后将会尝试旧式的迭代协议：如果一个类定义了 <code>__getitem__()</code>，则当且仅当存在非负整数索引号 <em>i</em> 使得 <code>x is y[i] or x == y[i]</code> 并且没有更小的索引号引发 <code>IndexError</code> 异常时 <code>x in y</code> 为 <code>True</code>。 （如果引发了任何其他异常，则等同于 <code>in</code> 引发了该异常）。</p>
<p>运算符 <code>not in</code> 被定义为具有与 <code>in</code> 相反的逻辑值。</p>
<h4 id="6-10-3-标识号比较"><a href="#6-10-3-标识号比较" class="headerlink" title="6.10.3. 标识号比较"></a>6.10.3. 标识号比较</h4><p>运算符 <code>is</code> 和 <code>is not</code> 用于检测对象的标识号：当且仅当 <em>x</em> 和 <em>y</em> 是同一对象时 <code>x is y</code> 为真。 一个对象的标识号可使用 <code>id()</code> 函数来确定。 <code>x is not y</code> 会产生相反的逻辑值。 </p>
<h3 id="6-11-布尔运算"><a href="#6-11-布尔运算" class="headerlink" title="6.11. 布尔运算"></a>6.11. 布尔运算</h3><pre><code>or_test  ::=  and_test | or_test "or" and_test
and_test ::=  not_test | and_test "and" not_test
not_test ::=  comparison | "not" not_test</code></pre><p>在执行布尔运算的情况下，或是当表达式被用于流程控制语句时，以下值会被解析为假值: <code>False</code>, <code>None</code>, 所有类型的数字零，以及空字符串和空容器（包括字符串、元组、列表、字典、集合与冻结集合）。 所有其他值都会被解析为真值。 用户自定义对象可通过提供 <code>__bool__()</code> 方法来定制其逻辑值。</p>
<p>运算符 <code>not</code> 将在其参数为假值时产生 <code>True</code>，否则产生 <code>False</code>。</p>
<p>表达式 <code>x and y</code> 首先对 <em>x</em> 求值；如果 <em>x</em> 为假则返回该值；否则对 <em>y</em> 求值并返回其结果值。</p>
<p>表达式 <code>x or y</code> 首先对 <em>x</em> 求值；如果 <em>x</em> 为真则返回该值；否则对 <em>y</em> 求值并返回其结果值。</p>
<p>请注意 <code>and</code> 和 <code>or</code> 都不限制其返回的值和类型必须为 <code>False</code> 和 <code>True</code>，而是返回最终求值的参数。 此行为是有必要的，例如假设 <code>s</code> 为一个当其为空时应被替换为某个默认值的字符串，表达式 <code>s or 'foo'</code> 将产生希望的值。 由于 <code>not</code> 必须创建一个新值，不论其参数为何种类型它都会返回一个布尔值（例如，<code>not 'foo'</code> 结果为 <code>False</code> 而非 <code>''</code>。）</p>
<h3 id="6-12-赋值表达式"><a href="#6-12-赋值表达式" class="headerlink" title="6.12. 赋值表达式"></a>6.12. 赋值表达式</h3><pre><code>assignment_expression ::=  [identifier ":="] expression</code></pre><p>赋值表达式（有时又被叫做“命名表达式”或“海象表达式”）将一个 <code>expression</code> 赋值给一个 <code>identifier</code>，同时还返回 <code>expression</code> 的值。</p>
<p>一个常见用例是在处理匹配的正则表达式的时候:</p>
<pre><code>if matching := pattern.search(data):
    do_something(matching)</code></pre><p>或者是在处理分块的文件流的时候:</p>
<pre><code>while chunk := file.read(9000):
    process(chunk)</code></pre><p>3.8 新版功能: 请参阅 <a href="https://www.python.org/dev/peps/pep-0572" target="_blank" rel="noopener"><strong>PEP 572</strong></a> 了解有关赋值表达式的详情。</p>
<h3 id="6-13-条件表达式"><a href="#6-13-条件表达式" class="headerlink" title="6.13. 条件表达式"></a>6.13. 条件表达式</h3><pre><code>conditional_expression ::=  or_test ["if" or_test "else" expression]
expression             ::=  conditional_expression | lambda_expr</code></pre><p>条件表达式（有时称为“三元运算符”）在所有 Python 运算中具有最低的优先级。</p>
<p>表达式 <code>x if C else y</code> 首先是对条件 <em>C</em> 而非 <em>x</em> 求值。 如果 <em>C</em> 为真，<em>x</em> 将被求值并返回其值；否则将对 <em>y</em> 求值并返回其值。</p>
<p>请参阅 <a href="https://www.python.org/dev/peps/pep-0308" target="_blank" rel="noopener"><strong>PEP 308</strong></a> 了解有关条件表达式的详情。</p>
<h3 id="6-14-lambda-表达式"><a href="#6-14-lambda-表达式" class="headerlink" title="6.14. lambda 表达式"></a>6.14. lambda 表达式</h3><pre><code>lambda_expr ::=  "lambda" [parameter_list] ":" expression</code></pre><p>lambda 表达式（有时称为 lambda 构型）被用于创建匿名函数。 表达式 <code>lambda parameters: expression</code> 会产生一个函数对象 。 该未命名对象的行为类似于用以下方式定义的函数:</p>
<pre><code>def &lt;lambda&gt;(parameters):
    return expression</code></pre><p>请注意通过 lambda 表达式创建的函数不能包含语句或标注。</p>
<h3 id="6-15-表达式列表"><a href="#6-15-表达式列表" class="headerlink" title="6.15. 表达式列表"></a>6.15. 表达式列表</h3><pre><code>expression_list    ::=  expression ("," expression)* [","]
starred_list       ::=  starred_item ("," starred_item)* [","]
starred_expression ::=  expression | (starred_item ",")* [starred_item]
starred_item       ::=  assignment_expression | "*" or_expr</code></pre><p>除了作为列表或集合显示的一部分，包含至少一个逗号的表达式列表将生成一个元组。 元组的长度就是列表中表达式的数量。 表达式将从左至右被求值。</p>
<p>一个星号 <code>*</code> 表示 <em>可迭代拆包</em>。 其操作数必须为一个 iterable。 该可迭代对象将被拆解为迭代项的序列，并被包含于在拆包位置上新建的元组、列表或集合之中。</p>
<p>3.5 新版功能: 表达式列表中的可迭代对象拆包，最初由 <a href="https://www.python.org/dev/peps/pep-0448" target="_blank" rel="noopener"><strong>PEP 448</strong></a> 提出。</p>
<p>末尾的逗号仅在创建单独元组 (或称 <em>单例</em>) 时需要；在所有其他情况下都是可选项。 没有末尾逗号的单独表达式不会创建一个元组，而是产生该表达式的值。 （要创建一个空元组，应使用一对内容为空的圆括号: <code>()</code>。）</p>
<h3 id="6-16-求值顺序"><a href="#6-16-求值顺序" class="headerlink" title="6.16. 求值顺序"></a>6.16. 求值顺序</h3><p>Python 按从左至右的顺序对表达式求值。 但注意在对赋值操作求值时，右侧会先于左侧被求值。</p>
<p>在以下几行中，表达式将按其后缀的算术优先顺序被求值。:</p>
<pre><code>expr1, expr2, expr3, expr4
(expr1, expr2, expr3, expr4)
{expr1: expr2, expr3: expr4}
expr1 + expr2 * (expr3 - expr4)
expr1(expr2, expr3, *expr4, **expr5)
expr3, expr4 = expr1, expr2</code></pre><h3 id="6-17-运算符优先级"><a href="#6-17-运算符优先级" class="headerlink" title="6.17. 运算符优先级"></a>6.17. 运算符优先级</h3><p>下表对The following table summarizes the operator precedence in Python 中运算符的优先顺序进行了总结，从最高优先级（最先绑定）到最低优先级（最后绑定）。 相同单元格内的运算符具有相同优先级。 除非句法显式地给出，否则运算符均指二元运算。 相同单元格内的运算符从左至右分组（除了幂运算是从右至左分组）。</p>
<p>请注意比较、成员检测和标识号检测均为相同优先级。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>(expressions…)</code>,<code>[expressions…]</code>, <code>{key: value…}</code>, <code>{expressions…}</code></td>
<td align="left">绑定或加圆括号的表达式，列表显示，字典显示，集合显示</td>
</tr>
<tr>
<td align="left"><code>x[index]</code>, <code>x[index:index]</code>, <code>x(arguments…)</code>, <code>x.attribute</code></td>
<td align="left">抽取，切片，调用，属性引用</td>
</tr>
<tr>
<td align="left"><code>await</code> <code>x</code></td>
<td align="left">await 表达式</td>
</tr>
<tr>
<td align="left"><code>*</code></td>
<td align="left">乘方</td>
</tr>
<tr>
<td align="left"><code>+x</code>, <code>-x</code>, <code>~x</code></td>
<td align="left">正，负，按位非 NOT</td>
</tr>
<tr>
<td align="left">``, <code>@</code>, <code>/</code>, <code>//</code>, <code>%</code></td>
<td align="left">乘，矩阵乘，除，整除，取余</td>
</tr>
<tr>
<td align="left"><code>+</code>, <code>-</code></td>
<td align="left">加和减</td>
</tr>
<tr>
<td align="left"><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td>
<td align="left">移位</td>
</tr>
<tr>
<td align="left"><code>&amp;</code></td>
<td align="left">按位与 AND</td>
</tr>
<tr>
<td align="left"><code>^</code></td>
<td align="left">按位异或 XOR</td>
</tr>
<tr>
<td align="left">`</td>
<td align="left">`</td>
</tr>
<tr>
<td align="left"><code>in</code>, <code>not in</code>, <code>is</code>, <code>is not</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>!=</code>, <code>==</code></td>
<td align="left">比较运算，包括成员检测和标识号检测</td>
</tr>
<tr>
<td align="left"><code>not</code> <code>x</code></td>
<td align="left">布尔逻辑非 NOT</td>
</tr>
<tr>
<td align="left"><code>and</code></td>
<td align="left">布尔逻辑与 AND</td>
</tr>
<tr>
<td align="left"><code>or</code></td>
<td align="left">布尔逻辑或 OR</td>
</tr>
<tr>
<td align="left"><code>if</code> — <code>else</code></td>
<td align="left">条件表达式</td>
</tr>
<tr>
<td align="left"><code>lambda</code></td>
<td align="left">lambda 表达式</td>
</tr>
<tr>
<td align="left"><code>:=</code></td>
<td align="left">赋值表达式</td>
</tr>
</tbody></table>
<p>注：</p>
<ul>
<li><p>虽然 <code>abs(x%y) &lt; abs(y)</code> 在数学中必为真，但对于浮点数而言，由于舍入的存在，其在数值上未必为真。 例如，假设在某个平台上的 Python 浮点数为一个 IEEE 754 双精度数值，为了使 <code>-1e-100 % 1e100</code> 具有与 <code>1e100</code> 相同的正负性，计算结果将是 <code>-1e-100 + 1e100</code>，这在数值上正好等于 <code>1e100</code>。 函数 <code>math.fmod()</code> 返回的结果则会具有与第一个参数相同的正负性，因此在这种情况下将返回 <code>-1e-100</code>。 何种方式更适宜取决于具体的应用。</p>
</li>
<li><p>如果 x 恰好非常接近于 y 的整数倍，则由于舍入的存在 <code>x//y</code> 可能会比 <code>(x-x%y)//y</code> 大。 在这种情况下，Python 会返回后一个结果，以便保持令 <code>divmod(x,y)[0] * y + x % y</code> 尽量接近 <code>x</code>.</p>
</li>
<li><p>Unicode 标准明确区分 <em>码位</em> (例如 U+0041) 和 <em>抽象字符</em> (例如 “大写拉丁字母 A”)。 虽然 Unicode 中的大多数抽象字符都只用一个码位来代表，但也存在一些抽象字符可使用由多个码位组成的序列来表示。 例如，抽象字符 “带有下加符的大写拉丁字母 C” 可以用 U+00C7 码位上的单个 <em>预设字符</em> 来表示，也可以用一个 U+0043 码位上的 <em>基础字符</em> (大写拉丁字母 C) 加上一个 U+0327 码位上的 <em>组合字符</em> (组合下加符) 组成的序列来表示。</p>
<p>对于字符串，比较运算符会按 Unicode 码位级别进行比较。 这可能会违反人类的直觉。 例如，<code>"\u00C7" == "\u0043\u0327"</code> 为 <code>False</code>，虽然两个字符串都代表同一个抽象字符 “带有下加符的大写拉丁字母 C”。</p>
<p>要按抽象字符级别（即对人类来说更直观的方式）对字符串进行比较，应使用 <code>unicodedata.normalize()</code>。</p>
</li>
<li><p>由于存在自动垃圾收集、空闲列表以及描述器的动态特性，你可能会注意到在特定情况下使用 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/65eb63967e3f016e.md#is" target="_blank" rel="noopener"><code>is</code></a> 运算符会出现看似不正常的行为，例如涉及到实例方法或常量之间的比较时就是如此。 更多信息请查看有关它们的文档。</p>
</li>
<li><p>幂运算符 <code>**</code> 绑定的紧密程度低于在其右侧的算术或按位一元运算符，也就是说 <code>2**-1</code> 为 <code>0.5</code>。</p>
</li>
<li><p><code>%</code> 运算符也被用于字符串格式化；在此场合下会使用同样的优先级。</p>
</li>
</ul>
<h2 id="7-简单语句"><a href="#7-简单语句" class="headerlink" title="7. 简单语句"></a>7. 简单语句</h2><p>简单语句由一个单独的逻辑行构成。 多条简单语句可以存在于同一行内并以分号分隔。 简单语句的句法为:</p>
<pre><code>simple_stmt ::=  expression_stmt
                 | assert_stmt
                 | assignment_stmt
                 | augmented_assignment_stmt
                 | annotated_assignment_stmt
                 | pass_stmt
                 | del_stmt
                 | return_stmt
                 | yield_stmt
                 | raise_stmt
                 | break_stmt
                 | continue_stmt
                 | import_stmt
                 | future_stmt
                 | global_stmt
                 | nonlocal_stmt</code></pre><h3 id="7-1-表达式语句"><a href="#7-1-表达式语句" class="headerlink" title="7.1. 表达式语句"></a>7.1. 表达式语句</h3><p>表达式语句用于计算和写入值（大多是在交互模式下），或者（通常情况）调用一个过程 (过程就是不返回有意义结果的函数；在 Python 中，过程的返回值为 <code>None</code>)。 表达式语句的其他使用方式也是允许且有特定用处的。 表达式语句的句法为:</p>
<pre><code>expression_stmt ::=  starred_expression</code></pre><p>表达式语句会对指定的表达式列表（也可能为单一表达式）进行求值。</p>
<p>在交互模式下，如果结果值不为 <code>None</code>，它会通过内置的 <code>repr()</code> 函数转换为一个字符串，该结果字符串将以单独一行的形式写入标准输出（例外情况是如果结果为 <code>None</code>，则该过程调用不产生任何输出。）</p>
<h3 id="7-2-赋值语句"><a href="#7-2-赋值语句" class="headerlink" title="7.2. 赋值语句"></a>7.2. 赋值语句</h3><p>赋值语句用于将名称（重）绑定到特定值，以及修改属性或可变对象的成员项:</p>
<pre><code>assignment_stmt ::=  (target_list "=")+ (starred_expression | yield_expression)
target_list     ::=  target ("," target)* [","]
target          ::=  identifier
                     | "(" [target_list] ")"
                     | "[" [target_list] "]"
                     | attributeref
                     | subscription
                     | slicing
                     | "*" target</code></pre><p>赋值语句会对指定的表达式列表进行求值（注意这可能为单一表达式或是由逗号分隔的列表，后者将产生一个元组）并将单一结果对象从左至右逐个赋值给目标列表。</p>
<p>赋值是根据目标（列表）的格式递归地定义的。 当目标为一个可变对象（属性引用、抽取或切片）的组成部分时，该可变对象必须最终执行赋值并决定其有效性，如果赋值操作不可接受也可能引发异常。 各种类型可用的规则和引发的异常通过对象类型的定义给出.</p>
<p>对象赋值的目标对象可以包含于圆括号或方括号内，具体操作按以下方式递归地定义。</p>
<ul>
<li>如果目标列表为后面不带逗号、可以包含于圆括号内的单一目标，则将对象赋值给该目标。</li>
<li>否则：该对象必须为具有与目标列表相同项数的可迭代对象，这些项将按从左至右的顺序被赋值给对应的目标。<ul>
<li>如果目标列表包含一个带有星号前缀的目标，这称为“加星”目标：则该对象至少必须为与目标列表项数减一相同项数的可迭代对象。 该可迭代对象前面的项将按从左至右的顺序被赋值给加星目标之前的目标。 该可迭代对象末尾的项将被赋值给加星目标之后的目标。 然后该可迭代对象中剩余项的列表将被赋值给加星目标（该列表可以为空）。</li>
<li>否则：该对象必须为具有与目标列表相同项数的可迭代对象，这些项将按从左至右的顺序被赋值给对应的目标。</li>
</ul>
</li>
</ul>
<p>对象赋值给单个目标的操作按以下方式递归地定义。</p>
<ul>
<li><p>如果目标为标识符（名称）:</p>
<ul>
<li>如果该名称未出现于当前代码块的 <code>global</code> 或 <code>nonlocal</code> 语句中：该名称将被绑定到当前局部命名空间的对象。</li>
<li>否则：该名称将被分别绑定到全局命名空间或由 <code>nonlocal</code> 所确定的外层命名空间的对象。</li>
</ul>
<p>如果该名称已经被绑定则将被重新绑定。 这可能导致之前被绑定到该名称的对象的引用计数变为零，造成该对象进入释放过程并调用其析构器（如果存在）。</p>
</li>
<li><p>如果该对象为属性引用：引用中的原型表达式会被求值。 它应该产生一个具有可赋值属性的对象；否则将引发 <code>TypeError</code>。 该对象会被要求将可赋值对象赋值给指定的属性；如果它无法执行赋值，则会引发异常 (通常应为 <code>AttributeError</code> 但并不强制要求)。</p>
<p>注意：如果该对象为类实例并且属性引用在赋值运算符的两侧都出现，则右侧表达式 <code>a.x</code> 可以访问实例属性或（如果实例属性不存在）类属性。 左侧目标 <code>a.x</code> 将总是设定为实例属性，并在必要时创建该实例属性。 因此 <code>a.x</code> 的两次出现不一定指向相同的属性：如果右侧表达式指向一个类属性，则左侧会创建一个新的实例属性作为赋值的目标:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Cls</span><span class="token punctuation">:</span>
    x <span class="token operator">=</span> <span class="token number">3</span>             <span class="token comment" spellcheck="true"># class variable</span>
inst <span class="token operator">=</span> Cls<span class="token punctuation">(</span><span class="token punctuation">)</span>
inst<span class="token punctuation">.</span>x <span class="token operator">=</span> inst<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token number">1</span>   <span class="token comment" spellcheck="true"># writes inst.x as 4 leaving Cls.x as 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>此描述不一定作用于描述器属性，例如通过 <code>property()</code> 创建的特征属性。</p>
</li>
<li><p>如果目标为一个抽取项：引用中的原型表达式会被求值。 它应当产生一个可变序列对象（例如列表）或一个映射对象（例如字典）。 接下来，该抽取表达式会被求值。</p>
<p>如果原型为一个可变序列对象（例如列表），抽取应产生一个整数。 如其为负值，则再加上序列长度。 结果值必须为一个小于序列长度的非负整数，序列将把被赋值对象赋值给该整数指定索引号的项。 如果索引超出范围，将会引发 <code>IndexError</code> (给被抽取序列赋值不能向列表添加新项)。</p>
<p>如果原型为一个映射对象（例如字典），抽取必须具有与该映射的键类型相兼容的类型，然后映射中会创建一个将抽取映射到被赋值对象的键/值对。 这可以是替换一个现有键/值对并保持相同键值，也可以是插入一个新键/值对（如果具有相同值的键不存在）。</p>
<p>对于用户定义对象，会调用 <code>__setitem__()</code> 方法并附带适当的参数。</p>
</li>
<li><p>如果目标为一个切片：引用中的原型表达式会被求值。 它应当产生一个可变序列对象（例如列表）。 被赋值对象应当是一个相同类型的序列对象。 接下来，下界与上界表达式如果存在的话将被求值；默认值分别为零和序列长度。 上下边界值应当为整数。 如果某一边界为负值，则会加上序列长度。 求出的边界会被裁剪至介于零和序列长度的开区间中。 最后，将要求序列对象以被赋值序列的项替换该切片。 切片的长度可能与被赋值序列的长度不同，这会在目标序列允许的情况下改变目标序列的长度。</p>
</li>
</ul>
<p><strong>CPython implementation detail:</strong> 在当前实现中，目标的句法被当作与表达式的句法相同，无效的句法会在代码生成阶段被拒绝，导致不太详细的错误信息。</p>
<p>虽然赋值的定义意味着左手边与右手边的重叠是“同时”进行的（例如 <code>a, b = b, a</code> 会交换两个变量的值），但在赋值给变量的多项集 <em>之内</em> 的重叠是从左至右进行的，这有时会令人混淆。 例如，以下程序将会打印出 <code>[0, 2]</code>:</p>
<pre class="line-numbers language-python"><code class="language-python">x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
i <span class="token operator">=</span> <span class="token number">0</span>
i<span class="token punctuation">,</span> x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span>         <span class="token comment" spellcheck="true"># i is updated, then x[i] is updated</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-3132" target="_blank" rel="noopener"><strong>PEP 3132</strong></a> - 扩展的可迭代对象拆包</p>
<p>对 <code>*target</code> 特性的规范说明。</p>
<h4 id="7-2-1-增强赋值语句"><a href="#7-2-1-增强赋值语句" class="headerlink" title="7.2.1. 增强赋值语句"></a>7.2.1. 增强赋值语句</h4><p>增强赋值语句就是在单个语句中将二元运算和赋值语句合为一体:</p>
<pre><code>augmented_assignment_stmt ::=  augtarget augop (expression_list | yield_expression)
augtarget                 ::=  identifier | attributeref | subscription | slicing
augop                     ::=  "+=" | "-=" | "*=" | "@=" | "/=" | "//=" | "%=" | "**="
                               | "&gt;&gt;=" | "&lt;&lt;=" | "&amp;=" | "^=" | "|="</code></pre><p>增强赋值语句将对目标和表达式列表求值（与普通赋值语句不同的是，前者不能为可迭代对象拆包），对两个操作数相应类型的赋值执行指定的二元运算，并将结果赋值给原始目标。 目标仅会被求值一次。</p>
<p>增强赋值语句例如 <code>x += 1</code> 可以改写为 <code>x = x + 1</code> 获得类似但并非完全等价的效果。 在增强赋值的版本中，<code>x</code> 仅会被求值一次。 而且，在可能的情况下，实际的运算是 <em>原地</em> 执行的，也就是说并不是创建一个新对象并将其赋值给目标，而是直接修改原对象。</p>
<p>不同于普通赋值，增强赋值会在对右手边求值 <em>之前</em> 对左手边求值。 例如，<code>a[i] += f(x)</code> 首先查找 <code>a[i]</code>，然后对 <code>f(x)</code> 求值并执行加法操作，最后将结果写回到 <code>a[i]</code>。</p>
<p>除了在单个语句中赋值给元组和多个目标的例外情况，增强赋值语句的赋值操作处理方式与普通赋值相同。 类似地，除了可能存在 <em>原地</em> 操作行为的例外情况，增强赋值语句执行的二元运算也与普通二元运算相同。</p>
<p>对于属性引用类目标，针对常规赋值的 关于类和实例属性的警告 也同样适用。</p>
<h4 id="7-2-2-带标注的赋值语句"><a href="#7-2-2-带标注的赋值语句" class="headerlink" title="7.2.2. 带标注的赋值语句"></a>7.2.2. 带标注的赋值语句</h4><p>标注 赋值就是在单个语句中将变量或属性标注和可选的赋值语句合为一体:</p>
<pre><code>annotated_assignment_stmt ::=  augtarget ":" expression
                               ["=" (starred_expression | yield_expression)]</code></pre><p>与普通 赋值语句 的差别在于仅允许单个目标。</p>
<p>对于将简单名称作为赋值目标的情况，如果是在类或模块作用域中，标注会被求值并存入一个特殊的类或模块属性 <code>__annotations__</code> 中，这是一个将变量名称（如为私有会被移除）映射到被求值标注的字典。 此属性为可写并且在类或模块体开始执行时如果静态地发现标注就会自动创建。</p>
<p>对于将表达式作为赋值目标的情况，如果是在类或模块作用域中，标注会被求值，但不会保存。</p>
<p>如果一个名称在函数作用域内被标注，则该名称为该作用域的局部变量。 标注绝不会在函数作用域内被求值和保存。</p>
<p>如果存在右手边，带标注的赋值会在对标注求值之前（如果适用）执行实际的赋值。 如果用作表达式目标的右手边不存在，则解释器会对目标求值，但最后的 <code>__setitem__()</code> 或 <code>__setattr__()</code> 调用除外。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0526" target="_blank" rel="noopener"><strong>PEP 526</strong></a> - 变量标注的语法</p>
<p>该提议增加了标注变量（也包括类变量和实例变量）类型的语法，而不再是通过注释来进行表达。</p>
<p><a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener"><strong>PEP 484</strong></a> - 类型提示</p>
<p>该提议增加了 <code>typing</code> 模块以便为类型标注提供标准句法，可被静态分析工具和 IDE 所使用。</p>
<p>在 3.8 版更改: 现在带有标注的赋值允许在右边以同样的表达式作为常规赋值。 之前，某些表达式（例如未加圆括号的元组表达式）会导致语法错误。</p>
<h3 id="7-3-assert-语句"><a href="#7-3-assert-语句" class="headerlink" title="7.3. assert 语句"></a>7.3. <code>assert</code> 语句</h3><p>assert 语句是在程序中插入调试性断言的简便方式:</p>
<pre><code>assert_stmt ::=  "assert" expression ["," expression]</code></pre><p>简单形式 <code>assert expression</code> 等价于</p>
<pre><code>if __debug__:    if not expression: raise AssertionError</code></pre><p>扩展形式 <code>assert expression1, expression2</code> 等价于</p>
<pre><code>if __debug__:    if not expression1: raise AssertionError(expression2)</code></pre><p>以上等价形式假定 <code>__debug__</code> 和 <code>AssertionError</code> 指向具有指定名称的内置变量。 在当前实现中，内置变量 <code>__debug__</code> 在正常情况下为 <code>True</code>，在请求优化时为 <code>False</code> (对应命令行选项为 <code>-O</code>)。 如果在编译时请求优化，当前代码生成器不会为 assert 语句发出任何代码。 请注意不必在错误信息中包含失败表达式的源代码；它会被作为栈追踪的一部分被显示。</p>
<p>赋值给 <code>__debug__</code> 是非法的。 该内置变量的值会在解释器启动时确定。</p>
<h3 id="7-4-pass-语句"><a href="#7-4-pass-语句" class="headerlink" title="7.4. pass 语句"></a>7.4. <code>pass</code> 语句</h3><pre><code>pass_stmt ::=  "pass"</code></pre><p><code>pass</code> 是一个空操作 —- 当它被执行时，什么都不发生。 它适合当语法上需要一条语句但并不需要执行任何代码时用来临时占位，例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>    <span class="token comment" spellcheck="true"># a function that does nothing (yet)</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>       <span class="token comment" spellcheck="true"># a class with no methods (yet)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="7-5-del-语句"><a href="#7-5-del-语句" class="headerlink" title="7.5. del 语句"></a>7.5. <code>del</code> 语句</h3><pre><code>del_stmt ::=  "del" target_list</code></pre><p>删除是递归定义的，与赋值的定义方式非常类似。 此处不再详细说明，只给出一些提示。</p>
<p>目标列表的删除将从左至右递归地删除每一个目标。</p>
<p>名称的删除将从局部或全局命名空间中移除该名称的绑定，具体作用域的确定是看该名称是否有在同一代码块的 <code>global</code> 语句中出现。 如果该名称未被绑定，将会引发 <code>NameError</code>。</p>
<p>属性引用、抽取和切片的删除会被传递给相应的原型对象；删除一个切片基本等价于赋值为一个右侧类型的空切片（但即便这一点也是由切片对象决定的）。</p>
<p>在 3.2 版更改: 在之前版本中，如果一个名称作为被嵌套代码块中的自由变量出现，则将其从局部命名空间中删除是非法的。</p>
<h3 id="7-6-return-语句"><a href="#7-6-return-语句" class="headerlink" title="7.6. return 语句"></a>7.6. <code>return</code> 语句</h3><pre><code>return_stmt ::=  "return" [expression_list]</code></pre><p><code>return</code> 在语法上只会出现于函数定义所嵌套的代码，不会出现于类定义所嵌套的代码。</p>
<p>如果提供了表达式列表，它将被求值，否则以 <code>None</code> 替代。</p>
<p><code>return</code> 会离开当前函数调用，并以表达式列表 (或 <code>None</code>) 作为返回值。</p>
<p>当 <code>return</code> 将控制流传出一个带有 <code>finally</code> 子句的 <code>try</code> 语句时，该 <code>finally</code> 子句会先被执行然后再真正离开该函数。</p>
<p>在一个生成器函数中，<code>return</code> 语句表示生成器已完成并将导致 <code>StopIteration</code> 被引发。 返回值（如果有的话）会被当作一个参数用来构建 <code>StopIteration</code> 并成为 <code>StopIteration.value</code> 属性。</p>
<p>在一个异步生成器函数中，一个空的 <code>return</code> 语句表示异步生成器已完成并将导致 <code>StopAsyncIteration</code> 被引发。 一个非空的 <code>return</code> 语句在异步生成器函数中会导致语法错误。</p>
<h3 id="7-7-yield-语句"><a href="#7-7-yield-语句" class="headerlink" title="7.7. yield 语句"></a>7.7. <code>yield</code> 语句</h3><pre><code>yield_stmt ::=  yield_expression</code></pre><p><code>yield</code> 语句在语义上等同于 yield 表达式。 yield 语句可用来省略在使用等效的 yield 表达式语句时所必须的圆括号。 例如，以下 yield 语句</p>
<pre><code>yield &lt;expr&gt;
yield from &lt;expr&gt;</code></pre><p>等同于以下 yield 表达式语句</p>
<pre><code>(yield &lt;expr&gt;)
(yield from &lt;expr&gt;)</code></pre><p>yield 表达式和语句仅在定义 generator 函数时使用，并且仅被用于生成器函数的函数体内部。 在函数定义中使用 yield 就足以使得该定义创建的是生成器函数而非普通函数。</p>
<h3 id="7-8-raise-语句"><a href="#7-8-raise-语句" class="headerlink" title="7.8. raise 语句"></a>7.8. <code>raise</code> 语句</h3><pre><code>raise_stmt ::=  "raise" [expression ["from" expression]]</code></pre><p>如果不带表达式，<code>raise</code> 会重新引发当前作用域内最后一个激活的异常。 如果当前作用域内没有激活的异常，将会引发 <code>RuntimeError</code> 来提示错误。</p>
<p>否则的话，<code>raise</code> 会将第一个表达式求值为异常对象。 它必须为 <code>BaseException</code> 的子类或实例。 如果它是一个类，当需要时会通过不带参数地实例化该类来获得异常的实例。</p>
<p>异常的 <em>类型</em> 为异常实例的类，<em>值</em> 为实例本身。</p>
<p>当异常被引发时通常会自动创建一个回溯对象并将其关联到可写的 <code>__traceback__</code> 属性。 你可以创建一个异常并同时使用 <code>with_traceback()</code> 异常方法（该方法将返回同一异常实例，并将回溯对象设为其参数）设置自己的回溯，就像这样:</p>
<pre><code>raise Exception("foo occurred").with_traceback(tracebackobj)</code></pre><p><code>from</code> 子句用于异常串连：如果有该子句，则第二个 <em>表达式</em> 必须为另一个异常类或实例。 如果第二个表达式是一个异常实例，它将作为可写的 <code>__cause__</code> 属性被关联到所引发的异常。 如果该表达式是一个异常类，这个类将被实例化且所生成的异常实例将作为 <code>__cause__</code> 属性被关联到所引发的异常。 如果所引发的异常未被处理，则两个异常都将被打印出来:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">except</span> Exception <span class="token keyword">as</span> exc<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">raise</span> RuntimeError<span class="token punctuation">(</span><span class="token string">"Something bad happened"</span><span class="token punctuation">)</span> <span class="token keyword">from</span> exc
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ZeroDivisionError<span class="token punctuation">:</span> division by zero
The above exception was the direct cause of the following exception<span class="token punctuation">:</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">4</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
RuntimeError<span class="token punctuation">:</span> Something bad happened<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果一个异常在异常处理器或 <code>finally</code> clause: 中被引发，类似的机制会隐式地发挥作用，之前的异常将被关联到新异常的 <code>__context__</code> 属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">except</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">raise</span> RuntimeError<span class="token punctuation">(</span><span class="token string">"Something bad happened"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ZeroDivisionError<span class="token punctuation">:</span> division by zero
During handling of the above exception<span class="token punctuation">,</span> another exception occurred<span class="token punctuation">:</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">4</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
RuntimeError<span class="token punctuation">:</span> Something bad happened<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>异常串连可通过在 <code>from</code> 子句中指定 <code>None</code> 来显式地加以抑制:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">except</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">raise</span> RuntimeError<span class="token punctuation">(</span><span class="token string">"Something bad happened"</span><span class="token punctuation">)</span> <span class="token keyword">from</span> None
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">4</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
RuntimeError<span class="token punctuation">:</span> Something bad happened<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.3 版更改: <code>None</code> 现在允许被用作 <code>raise X from Y</code> 中的 <code>Y</code>。</p>
<p>3.3 新版功能: 使用 <code>__suppress_context__</code> 属性来抑制异常上下文的自动显示。</p>
<h3 id="7-9-break-语句"><a href="#7-9-break-语句" class="headerlink" title="7.9. break 语句"></a>7.9. <code>break</code> 语句</h3><pre><code>break_stmt ::=  "break"</code></pre><p><code>break</code> 在语法上只会出现于 <code>for</code> 或 <code>while</code> 循环所嵌套的代码，但不会出现于该循环内部的函数或类定义所嵌套的代码。</p>
<p>它会终结最近的外层循环，如果循环有可选的 <code>else</code> 子句，也会跳过该子句。</p>
<p>如果一个 <code>for</code> 循环被 <code>break</code> 所终结，该循环的控制目标会保持其当前值。</p>
<p>当 <code>break</code> 将控制流传出一个带有 <code>finally</code> 子句的 <code>try</code> 语句时，该 <code>finally</code> 子句会先被执行然后再真正离开该循环。</p>
<h3 id="7-10-continue-语句"><a href="#7-10-continue-语句" class="headerlink" title="7.10. continue 语句"></a>7.10. <code>continue</code> 语句</h3><pre><code>continue_stmt ::=  "continue"</code></pre><p><code>continue</code> 在语法上只会出现于 <code>for</code> 或 <code>while</code> 循环所嵌套的代码中，但不会出现于该循环内部的函数或类定义中。 它会继续执行最近的外层循环的下一个轮次。</p>
<p>当 <code>continue</code> 将控制流传出一个带有 <code>finally</code> 子句的 <code>try</code> 语句时，该 <code>finally</code> 子句会先被执行然后再真正开始循环的下一个轮次。</p>
<h3 id="7-11-import-语句"><a href="#7-11-import-语句" class="headerlink" title="7.11. import 语句"></a>7.11. <code>import</code> 语句</h3><pre><code>import_stmt     ::=  "import" module ["as" identifier] ("," module ["as" identifier])*
                     | "from" relative_module "import" identifier ["as" identifier]
                     ("," identifier ["as" identifier])*
                     | "from" relative_module "import" "(" identifier ["as" identifier]
                     ("," identifier ["as" identifier])* [","] ")"
                     | "from" relative_module "import" "*"
module          ::=  (identifier ".")* identifier
relative_module ::=  "."* module | "."+</code></pre><p>基本的 import 语句（不带 <code>from</code> 子句）会分两步执行:</p>
<ol>
<li>查找一个模块，如果有必要还会加载并初始化模块。</li>
<li>在局部命名空间中为 <code>import</code> 语句发生位置所处的作用域定义一个或多个名称。</li>
</ol>
<p>当语句包含多个子句（由逗号分隔）时这两个步骤将对每个子句分别执行，如同这些子句被分成独立的 import 语句一样。</p>
<p>第一个步骤即查找和加载模块，其中也描述了可被导入的多种类型的包和模块，以及可用于定制导入系统的所有钩子对象。 请注意这一步如果失败，则可能说明模块无法找到，<em>或者</em> 是在初始化模块，包括执行模块代码期间发生了错误。</p>
<p>如果成功获取到请求的模块，则可以通过以下三种方式一之在局部命名空间中使用它:</p>
<ul>
<li>模块名后使用 <code>as</code> 时，直接把 <code>as</code> 后的名称与导入模块绑定。</li>
<li>如果没有指定其他名称，且被导入的模块为最高层级模块，则模块的名称将被绑定到局部命名空间作为对所导入模块的引用。</li>
<li>如果被导入的模块 <em>不是</em> 最高层级模块，则包含该模块的最高层级包的名称将被绑定到局部命名空间作为对该最高层级包的引用。 所导入的模块必须使用其完整限定名称来访问而不能直接访问。</li>
</ul>
<p><code>from</code> 形式使用的过程略微繁复一些:</p>
<ol>
<li>查找 <code>from</code> 子句中指定的模块，如有必要还会加载并初始化模块；</li>
<li>对于 <code>import</code> 子句中指定的每个标识符：<ol>
<li>检查被导入模块是否有该名称的属性</li>
<li>如果没有，尝试导入具有该名称的子模块，然后再次检查被导入模块是否有该属性</li>
<li>如果未找到该属性，则引发 <code>ImportError</code>。</li>
<li>否则的话，将对该值的引用存入局部命名空间，如果有 <code>as</code> 子句则使用其指定的名称，否则使用该属性的名称</li>
</ol>
</li>
</ol>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> foo                 <span class="token comment" spellcheck="true"># foo imported and bound locally</span>
<span class="token keyword">import</span> foo<span class="token punctuation">.</span>bar<span class="token punctuation">.</span>baz         <span class="token comment" spellcheck="true"># foo.bar.baz imported, foo bound locally</span>
<span class="token keyword">import</span> foo<span class="token punctuation">.</span>bar<span class="token punctuation">.</span>baz <span class="token keyword">as</span> fbb  <span class="token comment" spellcheck="true"># foo.bar.baz imported and bound as fbb</span>
<span class="token keyword">from</span> foo<span class="token punctuation">.</span>bar <span class="token keyword">import</span> baz    <span class="token comment" spellcheck="true"># foo.bar.baz imported and bound as baz</span>
<span class="token keyword">from</span> foo <span class="token keyword">import</span> attr       <span class="token comment" spellcheck="true"># foo imported and foo.attr bound as attr</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果标识符列表改为一个星号 (<code>'*'</code>)，则在模块中定义的全部公有名称都将按 <code>import</code> 语句所在的作用域被绑定到局部命名空间。</p>
<p>一个模块所定义的 <em>公有名称</em> 是由在模块的命名空间中检测一个名为 <code>__all__</code> 的变量来确定的；如果有定义，它必须是一个字符串列表，其中的项为该模块所定义或导入的名称。 在 <code>__all__</code> 中所给出的名称都会被视为公有并且应当存在。 如果 <code>__all__</code> 没有被定义，则公有名称的集合将包含在模块的命名空间中找到的所有不以下划线字符 (<code>'_'</code>) 打头的名称。 <code>__all__</code> 应当包括整个公有 API。 它的目标是避免意外地导出不属于 API 的一部分的项（例如在模块内部被导入和使用的库模块）。</p>
<p>通配符形式的导入 —- <code>from module import *</code> —- 仅在模块层级上被允许。 尝试在类或函数定义中使用它将引发 <code>SyntaxError</code>。</p>
<p>当指定要导入哪个模块时，你不必指定模块的绝对名称。 当一个模块或包被包含在另一个包之中时，可以在同一个最高层级包中进行相对导入，而不必提及包名称。 通过在 <code>from</code> 之后指定的模块或包中使用前缀点号，你可以在不指定确切名称的情况下指明在当前包层级结构中要上溯多少级。 一个前缀点号表示是执行导入的模块所在的当前包，两个点号表示上溯一个包层级。 三个点号表示上溯两级，依此类推。 因此如果你执行 <code>from . import mod</code> 时所处位置为 <code>pkg</code> 包内的一个模块，则最终你将导入 <code>pkg.mod</code>。 如果你执行 <code>from ..subpkg2 import mod</code> 时所处位置为 <code>pkg.subpkg1</code> 则你将导入 <code>pkg.subpkg2.mod</code>。 有关相对导入的规范说明包含在 包相对导入 一节中。</p>
<p><code>importlib.import_module()</code> 被提供用来为动态地确定要导入模块的应用提供支持。</p>
<p>引发一个 审计事件 <code>import</code> 附带参数 <code>module</code>, <code>filename</code>, <code>sys.path</code>, <code>sys.meta_path</code>, <code>sys.path_hooks</code>。</p>
<h4 id="7-11-1-future-语句"><a href="#7-11-1-future-语句" class="headerlink" title="7.11.1. future 语句"></a>7.11.1. future 语句</h4><p><em>future 语句</em> 是一种针对编译器的指令，指明某个特定模块应当使用在特定的未来某个 Python 发行版中成为标准特性的语法或语义。</p>
<p>future 语句的目的是使得向在语言中引入了不兼容改变的 Python 未来版本的迁移更为容易。 它允许基于每个模块在某种新特性成为标准之前的发行版中使用该特性。</p>
<pre><code>future_stmt ::=  "from" "__future__" "import" feature ["as" identifier]
                 ("," feature ["as" identifier])*
                 | "from" "__future__" "import" "(" feature ["as" identifier]
                 ("," feature ["as" identifier])* [","] ")"
feature     ::=  identifier</code></pre><p>future 语句必须在靠近模块开头的位置出现。 可以出现在 future 语句之前行只有:</p>
<ul>
<li>模块的文档字符串（如果存在），</li>
<li>注释，</li>
<li>空行，以及</li>
<li>其他 future 语句。</li>
</ul>
<p>唯一需要使用 future 语句的特性是 <code>标注</code> (参见 <a href="https://www.python.org/dev/peps/pep-0563" target="_blank" rel="noopener"><strong>PEP 563</strong></a>)。</p>
<p>future 语句所启用的所有历史特性仍然为 Python 3 所认可。 其中包括 <code>absolute_import</code>, <code>division</code>, <code>generators</code>, <code>generator_stop</code>, <code>unicode_literals</code>, <code>print_function</code>, <code>nested_scopes</code> 和 <code>with_statement</code>。 它们都已成为冗余项，因为它们总是为已启用状态，保留它们只是为了向后兼容。</p>
<p>future 语句在编译时会被识别并做特殊对待：对核心构造语义的改变常常是通过生成不同的代码来实现。 新的特性甚至可能会引入新的不兼容语法（例如新的保留字），在这种情况下编译器可能需要以不同的方式来解析模块。 这样的决定不能推迟到运行时方才作出。</p>
<p>对于任何给定的发布版本，编译器要知道哪些特性名称已被定义，如果某个 future 语句包含未知的特性则会引发编译时错误。</p>
<p>直接运行时的语义与任何 import 语句相同：存在一个后文将详细说明的标准模块 <code>__future__</code>，它会在执行 future 语句时以通常的方式被导入。</p>
<p>相应的运行时语义取决于 future 语句所启用的指定特性。</p>
<p>请注意以下语句没有任何特别之处:</p>
<pre><code>import __future__ [as name]</code></pre><p>这并非 future 语句；它只是一条没有特殊语义或语法限制的普通 import 语句。</p>
<p>在默认情况下，通过对Code compiled by calls to the 内置函数 <code>exec()</code> 和 <code>compile()</code> 的调用所编译的代码如果出现于一个包含有 future 语句的模块 <code>M</code> 之中，就会使用 future 语句所关联的语法和语义。 此行为可以通过 <code>compile()</code> 的可选参数加以控制 —- 请参阅该函数的文档以了解详情。</p>
<p>在交互式解释器提示符中键入的 future 语句将在解释器会话此后的交互中有效。 如果一个解释器的启动使用了 <code>-i</code> 选项启动，并传入了一个脚本名称来执行，且该脚本包含 future 语句，它将在交互式会话开始执行脚本之后保持有效。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0236" target="_blank" rel="noopener"><strong>PEP 236</strong></a> - 回到 <strong>future</strong></p>
<p>有关 <strong>future</strong> 机制的最初提议。</p>
<h3 id="7-12-global-语句"><a href="#7-12-global-语句" class="headerlink" title="7.12. global 语句"></a>7.12. <code>global</code> 语句</h3><pre><code>global_stmt ::=  "global" identifier ("," identifier)*</code></pre><p><code>global</code> 语句是作用于整个当前代码块的声明。 它意味着所列出的标识符将被解读为全局变量。 要给全局变量赋值不可能不用到 <code>global</code> 关键字，不过自由变量也可以指向全局变量而不必声明为全局变量。</p>
<p>在 <code>global</code> 语句中列出的名称不得在同一代码块内该 <code>global</code> 语句之前的位置中使用。</p>
<p>在 <code>global</code> 语句中列出的名称不能被定义为形式参数，也不能被作为 <code>with</code> 语句或 <code>except</code> 子句的目标，以及 <code>for</code> 循环的目标列表、<code>class</code> 定义、函数定义、<code>import</code> 语句或变量标注等等。</p>
<p><strong>CPython implementation detail:</strong> 当前的实现并未强制要求所有的上述限制，但程序不应当滥用这样的自由，因为未来的实现可能会改为强制要求，并静默地改变程序的含义。</p>
<p><strong>程序员注意事项:</strong> <code>global</code> 是对解析器的指令。 它仅对与 <code>global</code> 语句同时被解析的代码起作用。 特别地，包含在提供给内置 <code>exec()</code> 函数字符串或代码对象中的 <code>global</code> 语句并不会影响 <em>包含</em> 该函数调用的代码块，而包含在这种字符串中的代码也不会受到包含该函数调用的代码中的 <code>global</code> 语句影响。 这同样适用于 <code>eval()</code> 和 <code>compile()</code> 函数。</p>
<h3 id="7-13-nonlocal-语句"><a href="#7-13-nonlocal-语句" class="headerlink" title="7.13. nonlocal 语句"></a>7.13. <code>nonlocal</code> 语句</h3><pre><code>nonlocal_stmt ::=  "nonlocal" identifier ("," identifier)*</code></pre><p><code>nonlocal</code> 语句会使得所列出的名称指向之前在最近的包含作用域中绑定的除全局变量以外的变量。 这种功能很重要，因为绑定的默认行为是先搜索局部命名空间。 这个语句允许被封装的代码重新绑定局部作用域以外且非全局（模块）作用域当中的变量。</p>
<p>与 <code>global</code> 语句中列出的名称不同，<code>nonlocal</code> 语句中列出的名称必须指向之前存在于包含作用域之中的绑定（在这个应当用来创建新绑定的作用域不能被无歧义地确定）。</p>
<p><code>nonlocal</code> 语句中列出的名称不得与之前存在于局部作用域中的绑定相冲突。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-3104" target="_blank" rel="noopener"><strong>PEP 3104</strong></a> - 访问外层作用域中的名称</p>
<p>有关 <code>nonlocal</code> 语句的规范说明。</p>
<h2 id="8-复合语句"><a href="#8-复合语句" class="headerlink" title="8. 复合语句"></a>8. 复合语句</h2><p>复合语句是包含其它语句（语句组）的语句；它们会以某种方式影响或控制所包含其它语句的执行。 通常，复合语句会跨越多行，虽然在某些简单形式下整个复合语句也可能包含于一行之内。</p>
<p><code>if</code>, <code>while</code> 和 <code>for</code> 语句用来实现传统的控制流程构造。 <code>try</code> 语句为一组语句指定异常处理和/和清理代码，而 <code>with</code> 语句允许在一个代码块周围执行初始化和终结化代码。 函数和类定义在语法上也属于复合语句。</p>
<p>一条复合语句由一个或多个‘子句’组成。 一个子句则包含一个句头和一个‘句体’。 特定复合语句的子句头都处于相同的缩进层级。 每个子句头以一个作为唯一标识的关键字开始并以一个冒号结束。 子句体是由一个子句控制的一组语句。 子句体可以是在子句头的冒号之后与其同处一行的一条或由分号分隔的多条简单语句，或者也可以是在其之后缩进的一行或多行语句。 只有后一种形式的子句体才能包含嵌套的复合语句；以下形式是不合法的，这主要是因为无法分清某个后续的 <code>else</code> 子句应该属于哪个 <code>if</code> 子句:</p>
<pre><code>if test1: if test2: print(x)</code></pre><p>还要注意的是在这种情形下分号的绑定比冒号更紧密，因此在以下示例中，所有 <code>print()</code> 调用或者都不执行，或者都执行:</p>
<pre><code>if x &lt; y &lt; z: print(x); print(y); print(z)</code></pre><p>总结:</p>
<pre><code>compound_stmt ::=  if_stmt
                   | while_stmt
                   | for_stmt
                   | try_stmt
                   | with_stmt
                   | match_stmt
                   | funcdef
                   | classdef
                   | async_with_stmt
                   | async_for_stmt
                   | async_funcdef
suite         ::=  stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT
statement     ::=  stmt_list NEWLINE | compound_stmt
stmt_list     ::=  simple_stmt (";" simple_stmt)* [";"]</code></pre><p>请注意语句总是以 <code>NEWLINE</code> 结束，之后可能跟随一个 <code>DEDENT</code>。 还要注意可选的后续子句总是以一个不能作为语句开头的关键字作为开头，因此不会产生歧义（‘悬空的 <code>else</code>’问题在 Python 中是通过要求嵌套的 <code>if</code> 语句必须缩进来解决的)。</p>
<p>为了保证清晰，以下各节中语法规则采用将每个子句都放在单独行中的格式。</p>
<h3 id="8-1-if-语句"><a href="#8-1-if-语句" class="headerlink" title="8.1. if 语句"></a>8.1. <code>if</code> 语句</h3><p><code>if</code> 语句用于有条件的执行:</p>
<pre><code>if_stmt ::=  "if" assignment_expression ":" suite
             ("elif" assignment_expression ":" suite)*
             ["else" ":" suite]</code></pre><p>它通过对表达式逐个求值直至找到一个真值在子句体中选择唯一匹配的一个；然后执行该子句体（而且 <code>if</code> 语句的其他部分不会被执行或求值）。 如果所有表达式均为假值，则如果 <code>else</code> 子句体如果存在就会被执行。</p>
<h3 id="8-2-while-语句"><a href="#8-2-while-语句" class="headerlink" title="8.2. while 语句"></a>8.2. <code>while</code> 语句</h3><p><code>while</code> 语句用于在表达式保持为真的情况下重复地执行:</p>
<pre><code>while_stmt ::=  "while" assignment_expression ":" suite
                ["else" ":" suite]</code></pre><p>这将重复地检验表达式，并且如果其值为真就执行第一个子句体；如果表达式值为假（这可能在第一次检验时就发生）则如果 <code>else</code> 子句体存在就会被执行并终止循环。</p>
<p>第一个子句体中的 <code>break</code> 语句在执行时将终止循环且不执行 <code>else</code> 子句体。 第一个子句体中的 <code>continue</code> 语句在执行时将跳过子句体中的剩余部分并返回检验表达式。</p>
<h3 id="8-3-for-语句"><a href="#8-3-for-语句" class="headerlink" title="8.3. for 语句"></a>8.3. <code>for</code> 语句</h3><p><code>for</code> 语句用于对序列（例如字符串、元组或列表）或其他可迭代对象中的元素进行迭代:</p>
<pre><code>for_stmt ::=  "for" target_list "in" expression_list ":" suite
              ["else" ":" suite]</code></pre><p>表达式列表会被求值一次；它应该产生一个可迭代对象。 系统将为 <code>expression_list</code> 的结果创建一个迭代器，然后将为迭代器所提供的每一项执行一次子句体，具体次序与迭代器的返回顺序一致。 每一项会按标准赋值规则被依次赋值给目标列表，然后子句体将被执行。 当所有项被耗尽时 (这会在序列为空或迭代器引发 <code>StopIteration</code> 异常时立刻发生)，<code>else</code> 子句的子句体如果存在将会被执行，并终止循环。</p>
<p>第一个子句体中的 <code>break</code> 语句在执行时将终止循环且不执行 <code>else</code> 子句体。 第一个子句体中的 <code>continue</code> 语句在执行时将跳过子句体中的剩余部分并转往下一项继续执行，或者在没有下一项时转往 <code>else</code> 子句执行。</p>
<p>for 循环会对目标列表中的变量进行赋值。 这将覆盖之前对这些变量的所有赋值，包括在 for 循环体中的赋值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    i <span class="token operator">=</span> <span class="token number">5</span>             <span class="token comment" spellcheck="true"># this will not affect the for-loop</span>
                      <span class="token comment" spellcheck="true"># because i will be overwritten with the next</span>
                      <span class="token comment" spellcheck="true"># index in the range</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>目标列表中的名称在循环结束时不会被删除，但如果序列为空，则它们根本不会被循环所赋值。 提示：内置函数 <code>range()</code> 会返回一个可迭代的整数序列，适用于模拟 Pascal 中的 <code>for i := a to b do</code> 这种效果；例如 <code>list(range(3))</code> 会返回列表 <code>[0, 1, 2]</code>。</p>
<p>注解</p>
<p>当序列在循环中被修改时会有一个微妙的问题（这只可能发生于可变序列例如列表中）。 会有一个内部计数器被用来跟踪下一个要使用的项，每次迭代都会使计数器递增。 当计数器值达到序列长度时循环就会终止。 这意味着如果语句体从序列中删除了当前（或之前）的一项，下一项就会被跳过（因为其标号将变成已被处理的当前项的标号）。 类似地，如果语句体在序列当前项的前面插入一个新项，当前项会在循环的下一轮中再次被处理。 这会导致麻烦的程序错误，避免此问题的办法是对整个序列使用切片来创建一个临时副本，例如</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> x <span class="token keyword">in</span> a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span> a<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="8-4-try-语句"><a href="#8-4-try-语句" class="headerlink" title="8.4. try 语句"></a>8.4. <code>try</code> 语句</h3><p><code>try</code> 语句可为一组语句指定异常处理器和/或清理代码:</p>
<pre class="line-numbers language-python"><code class="language-python">try_stmt  <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span>  try1_stmt <span class="token operator">|</span> try2_stmt
try1_stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span>  <span class="token string">"try"</span> <span class="token string">":"</span> suite
               <span class="token punctuation">(</span><span class="token string">"except"</span> <span class="token punctuation">[</span>expression <span class="token punctuation">[</span><span class="token string">"as"</span> identifier<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token string">":"</span> suite<span class="token punctuation">)</span><span class="token operator">+</span>
               <span class="token punctuation">[</span><span class="token string">"else"</span> <span class="token string">":"</span> suite<span class="token punctuation">]</span>
               <span class="token punctuation">[</span><span class="token string">"finally"</span> <span class="token string">":"</span> suite<span class="token punctuation">]</span>
try2_stmt <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">=</span>  <span class="token string">"try"</span> <span class="token string">":"</span> suite
               <span class="token string">"finally"</span> <span class="token string">":"</span> suite<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>except</code> 子句指定一个或多个异常处理程序。 当 <code>try</code> 子句中没有发生异常时，没有任何异常处理程序会被执行。 当 <code>try</code> 子句中发生异常时，将启动对异常处理程序的搜索。 此搜索会逐一检查 except 子句直至找到与该异常相匹配的子句。 如果存在无表达式的 except 子句，它必须是最后一个；它将匹配任何异常。 对于带有表达式的 except 子句，该表达式会被求值，如果结果对象与发生的异常“兼容”则该子句将匹配该异常。 如果一个对象是异常对象所属的类或基类，或者是包含兼容该异常的项的元组则两者就是兼容的。</p>
<p>如果没有 except 子句与异常相匹配，则会在周边代码和发起调用栈上继续搜索异常处理器。</p>
<p>如果在对 except 子句头中的表达式求值时引发了异常，则原来对处理器的搜索会被取消，并在周边代码和调用栈上启动对新异常的搜索（它会被视作是整个 <code>try</code> 语句所引发的异常）。</p>
<p>当找到一个匹配的 except 子句时，该异常将被赋值给该 except 子句在 <code>as</code> 关键字之后指定的目标，如果存在此关键字的话，并且该 except 子句体将被执行。 所有 except 子句都必须有可执行的子句体。 当到达子句体的末尾时，通常会转向整个 try 语句之后继续执行。 （这意味着如果对于同一异常存在有嵌套的两个处理器，而异常发生于内层处理器的 try 子句中，则外层处理器将不会处理该异常。）</p>
<p>当使用 <code>as</code> 将目标赋值为一个异常时，它将在 except 子句结束时被清除。 这就相当于</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">except</span> E <span class="token keyword">as</span> N<span class="token punctuation">:</span>
    foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>被转写为</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">except</span> E <span class="token keyword">as</span> N<span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        foo
    <span class="token keyword">finally</span><span class="token punctuation">:</span>
        <span class="token keyword">del</span> N<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这意味着异常必须赋值给一个不同的名称才能在 except 子句之后引用它。 异常会被清除是因为在附加了回溯信息的情况下，它们会形成堆栈帧的循环引用，使得所有局部变量保持存活直到发生下一次垃圾回收。</p>
<p>Before an except clause’s suite is executed, details about the exception are stored in the <code>sys</code> module and can be accessed via <code>sys.exc_info()</code>. <code>sys.exc_info()</code> returns a 3-tuple consisting of the exception class, the exception instance and a traceback object (see section 标准类型层级结构) identifying the point in the program where the exception occurred. The details about the exception accessed via <code>sys.exc_info()</code> are restored to their previous values when leaving an exception handler:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>exc_info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span>None<span class="token punctuation">,</span> None<span class="token punctuation">,</span> None<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">raise</span> TypeError
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">except</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>exc_info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>          <span class="token keyword">raise</span> ValueError
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">except</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>exc_info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>exc_info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'TypeError'</span><span class="token operator">></span><span class="token punctuation">,</span> TypeError<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>traceback object at <span class="token number">0x10efad080</span><span class="token operator">></span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'ValueError'</span><span class="token operator">></span><span class="token punctuation">,</span> ValueError<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>traceback object at <span class="token number">0x10efad040</span><span class="token operator">></span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'TypeError'</span><span class="token operator">></span><span class="token punctuation">,</span> TypeError<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>traceback object at <span class="token number">0x10efad080</span><span class="token operator">></span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>exc_info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span>None<span class="token punctuation">,</span> None<span class="token punctuation">,</span> None<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果控制流离开 <code>try</code> 子句体时没有引发异常，并且没有执行 <code>return</code>, <code>continue</code> 或 <code>break</code> 语句，可选的 <code>else</code> 子句将被执行。 <code>else</code> 语句中的异常不会由之前的 <code>except</code> 子句处理。</p>
<p>如果存在 <code>finally</code>，它将指定一个‘清理’处理程序。 <code>try</code> 子句会被执行，包括任何 <code>except</code> 和 <code>else</code> 子句。 如果在这些子句中发生任何未处理的异常，该异常会被临时保存。 <code>finally</code> 子句将被执行。 如果存在被保存的异常，它会在 <code>finally</code> 子句的末尾被重新引发。 如果 <code>finally</code> 子句引发了另一个异常，被保存的异常会被设为新异常的上下文。 如果 <code>finally</code> 子句执行了 <code>return</code>, <code>break</code> 或 <code>continue</code> 语句，则被保存的异常会被丢弃:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">finally</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token number">42</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">42</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>finally</code> 子句执行期间，程序不能获取异常信息。</p>
<p>当 <code>return</code>, <code>break</code> 或 <code>continue</code> 语句在一个 <code>try</code>…<code>finally</code> 语句的 <code>try</code> 子语句体中被执行时，<code>finally</code> 子语句也会‘在离开时’被执行。</p>
<p>函数的返回值是由最后被执行的 <code>return</code> 语句所决定的。 由于 <code>finally</code> 子句总是被执行，因此在 <code>finally</code> 子句中被执行的 <code>return</code> 语句总是最后被执行的:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token string">'try'</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">finally</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token string">'finally'</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> foo<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'finally'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.8 版更改: 在 Python 3.8 之前，<code>continue</code> 语句不允许在 <code>finally</code> 子句中使用，这是因为具体实现存在一个问题。</p>
<h3 id="8-5-with-语句"><a href="#8-5-with-语句" class="headerlink" title="8.5. with 语句"></a>8.5. <code>with</code> 语句</h3><p><code>with</code> 语句用于包装带有使用上下文管理器 定义的方法的代码块的执行。 这允许对普通的 <code>try</code>…<code>except</code>…<code>finally</code> 使用模式进行封装以方便地重用。</p>
<pre><code>with_stmt          ::=  "with" ( "(" with_stmt_contents ","? ")" | with_stmt_contents ) ":" suite
with_stmt_contents ::=  with_item ("," with_item)*
with_item          ::=  expression ["as" target]</code></pre><p>带有一个“项目”的 <code>with</code> 语句的执行过程如下:</p>
<ol>
<li><p>对上下文表达式 (在 <code>with_item</code> 中给出的表达式) 求值以获得一个上下文管理器。</p>
</li>
<li><p>载入上下文管理器的 <code>__enter__()</code> 以便后续使用。</p>
</li>
<li><p>载入上下文管理器的 <code>__exit__()</code> 以便后续使用。</p>
</li>
<li><p>发起调用上下文管理器的 <code>__enter__()</code> 方法。</p>
</li>
<li><p>如果 <code>with</code> 语句中包含一个目标，来自 <code>__enter__()</code> 的返回值将被赋值给它。</p>
<p>注解</p>
<p><code>with</code> 语句会保证如果 <code>__enter__()</code> 方法返回时未发生错误，则 <code>__exit__()</code> 将总是被调用。 因此，如果在对目标列表赋值期间发生错误，则会将其视为在语句体内部发生的错误。 参见下面的第 6 步。</p>
</li>
<li><p>执行语句体。</p>
</li>
<li><p>发起调用上下文管理器的 <code>__exit__()</code> 方法。 如果语句体的退出是由异常导致的，则其类型、值和回溯信息将被作为参数传递给 <code>__exit__()</code>。 否则的话，将提供三个 <code>None</code> 参数。</p>
<p>如果语句体的退出是由异常导致的，并且来自 <code>__exit__()</code> 方法的返回值为假，则该异常会被重新引发。 如果返回值为真，则该异常会被抑制，并会继续执行 <code>with</code> 语句之后的语句。</p>
<p>如果语句体由于异常以外的任何原因退出，则来自 <code>__exit__()</code> 的返回值会被忽略，并会在该类退出正常的发生位置继续执行。</p>
</li>
</ol>
<p>以下代码:</p>
<pre><code>with EXPRESSION as TARGET:
    SUITE</code></pre><p>在语义上等价于:</p>
<pre class="line-numbers language-python"><code class="language-python">manager <span class="token operator">=</span> <span class="token punctuation">(</span>EXPRESSION<span class="token punctuation">)</span>
enter <span class="token operator">=</span> type<span class="token punctuation">(</span>manager<span class="token punctuation">)</span><span class="token punctuation">.</span>__enter__
exit <span class="token operator">=</span> type<span class="token punctuation">(</span>manager<span class="token punctuation">)</span><span class="token punctuation">.</span>__exit__
value <span class="token operator">=</span> enter<span class="token punctuation">(</span>manager<span class="token punctuation">)</span>
hit_except <span class="token operator">=</span> <span class="token boolean">False</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    TARGET <span class="token operator">=</span> value
    SUITE
<span class="token keyword">except</span><span class="token punctuation">:</span>
    hit_except <span class="token operator">=</span> <span class="token boolean">True</span>
    <span class="token keyword">if</span> <span class="token operator">not</span> exit<span class="token punctuation">(</span>manager<span class="token punctuation">,</span> <span class="token operator">*</span>sys<span class="token punctuation">.</span>exc_info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span>
<span class="token keyword">finally</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token operator">not</span> hit_except<span class="token punctuation">:</span>
        exit<span class="token punctuation">(</span>manager<span class="token punctuation">,</span> None<span class="token punctuation">,</span> None<span class="token punctuation">,</span> None<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果有多个项目，则会视作存在多个 <code>with</code> 语句嵌套来处理多个上下文管理器:</p>
<pre><code>with A() as a, B() as b:    
    SUITE</code></pre><p>在语义上等价于:</p>
<pre><code>with A() as a:
    with B() as b:
        SUITE</code></pre><p>You can also write multi-item context managers in multiple lines if the items are surrounded by parentheses. For example:</p>
<pre><code>with (
    A() as a,
    B() as b,
):
    SUITE</code></pre><p>在 3.1 版更改: 支持多个上下文表达式。</p>
<p>在 3.10 版更改: Support for using grouping parentheses to break the statement in multiple lines.</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0343" target="_blank" rel="noopener"><strong>PEP 343</strong></a> - “with” 语句</p>
<p>Python <code>with</code> 语句的规范描述、背景和示例。</p>
<h3 id="8-6-The-match-statement"><a href="#8-6-The-match-statement" class="headerlink" title="8.6. The match statement"></a>8.6. The <code>match</code> statement</h3><p>3.10 新版功能.</p>
<p>The match statement is used for pattern matching. Syntax:</p>
<pre><code>match_stmt   ::=  'match' subject_expr ":" NEWLINE INDENT case_block+ DEDENT
subject_expr ::=  star_named_expression "," star_named_expressions?
                  | named_expression
case_block   ::=  'case' patterns [guard] ":" block</code></pre><p>注解</p>
<p>This section uses single quotes to denote soft keywords.</p>
<p>Pattern matching takes a pattern as input (following <code>case</code>) and a subject value (following <code>match</code>). The pattern (which may contain subpatterns) is matched against the subject value. The outcomes are:</p>
<ul>
<li>A match success or failure (also termed a pattern success or failure).</li>
<li>Possible binding of matched values to a name. The prerequisites for this are further discussed below.</li>
</ul>
<p>The <code>match</code> and <code>case</code> keywords are soft keywords.</p>
<p>参见</p>
<ul>
<li><a href="https://www.python.org/dev/peps/pep-0634" target="_blank" rel="noopener"><strong>PEP 634</strong></a> — Structural Pattern Matching: Specification</li>
<li><a href="https://www.python.org/dev/peps/pep-0636" target="_blank" rel="noopener"><strong>PEP 636</strong></a> — Structural Pattern Matching: Tutorial</li>
</ul>
<h4 id="8-6-1-概述"><a href="#8-6-1-概述" class="headerlink" title="8.6.1. 概述"></a>8.6.1. 概述</h4><p>Here’s an overview of the logical flow of a match statement:</p>
<ol>
<li><p>The subject expression <code>subject_expr</code> is evaluated and a resulting subject value obtained. If the subject expression contains a comma, a tuple is constructed using the standard rules.</p>
</li>
<li><p>Each pattern in a <code>case_block</code> is attempted to match with the subject value. The specific rules for success or failure are described below. The match attempt can also bind some or all of the standalone names within the pattern. The precise pattern binding rules vary per pattern type and are specified below. <strong>Name bindings made during a successful pattern match outlive the executed block and can be used after the match statement</strong>.</p>
<blockquote>
<p>注解</p>
<p>During failed pattern matches, some subpatterns may succeed. Do not rely on bindings being made for a failed match. Conversely, do not rely on variables remaining unchanged after a failed match. The exact behavior is dependent on implementation and may vary. This is an intentional decision made to allow different implementations to add optimizations.</p>
</blockquote>
</li>
<li><p>If the pattern succeeds, the corresponding guard (if present) is evaluated. In this case all name bindings are guaranteed to have happened.</p>
<ul>
<li>If the guard evaluates as true or is missing, the <code>block</code> inside <code>case_block</code> is executed.</li>
<li>Otherwise, the next <code>case_block</code> is attempted as described above.</li>
<li>If there are no further case blocks, the match statement is completed.</li>
</ul>
</li>
</ol>
<p>注解</p>
<p>Users should generally never rely on a pattern being evaluated. Depending on implementation, the interpreter may cache values or use other optimizations which skip repeated evaluations.</p>
<p>A sample match statement:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> flag <span class="token operator">=</span> <span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> match <span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    case <span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># Mismatch: 200 != 300</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Case 1'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    case <span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token keyword">if</span> flag<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># Successful match, but guard fails</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Case 2'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    case <span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># Matches and binds y to 200</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'Case 3, y: {y}'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    case _<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># Pattern not attempted</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Case 4, I match anything!'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
Case <span class="token number">3</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>In this case, <code>if flag</code> is a guard. Read more about that in the next section.</p>
<h4 id="8-6-2-Guards"><a href="#8-6-2-Guards" class="headerlink" title="8.6.2. Guards"></a>8.6.2. Guards</h4><pre><code>guard ::=  "if" named_expression</code></pre><p>A <code>guard</code> (which is part of the <code>case</code>) must succeed for code inside the <code>case</code> block to execute. It takes the form: <a href="https://www.bookstack.cn/read/python-3.10.0-zh/e64650a44ed4d418.md#if" target="_blank" rel="noopener"><code>if</code></a> followed by an expression.</p>
<p>The logical flow of a <code>case</code> block with a <code>guard</code> follows:</p>
<ol>
<li>Check that the pattern in the <code>case</code> block succeeded. If the pattern failed, the <code>guard</code> is not evaluated and the next <code>case</code> block is checked.</li>
<li>If the pattern succeeded, evaluate the <code>guard</code>.<ul>
<li>If the <code>guard</code> condition evaluates as true, the case block is selected.</li>
<li>If the <code>guard</code> condition evaluates as false, the case block is not selected.</li>
<li>If the <code>guard</code> raises an exception during evaluation, the exception bubbles up.</li>
</ul>
</li>
</ol>
<p>Guards are allowed to have side effects as they are expressions. Guard evaluation must proceed from the first to the last case block, one at a time, skipping case blocks whose pattern(s) don’t all succeed. (I.e., guard evaluation must happen in order.) Guard evaluation must stop once a case block is selected.</p>
<h4 id="8-6-3-Irrefutable-Case-Blocks"><a href="#8-6-3-Irrefutable-Case-Blocks" class="headerlink" title="8.6.3. Irrefutable Case Blocks"></a>8.6.3. Irrefutable Case Blocks</h4><p>An irrefutable case block is a match-all case block. A match statement may have at most one irrefutable case block, and it must be last.</p>
<p>A case block is considered irrefutable if it has no guard and its pattern is irrefutable. A pattern is considered irrefutable if we can prove from its syntax alone that it will always succeed. Only the following patterns are irrefutable:</p>
<ul>
<li>AS Patterns whose left-hand side is irrefutable</li>
<li>OR Patterns containing at least one irrefutable pattern</li>
<li>Capture Patterns</li>
<li>Wildcard Patterns</li>
<li>parenthesized irrefutable patterns</li>
</ul>
<h4 id="8-6-4-Patterns"><a href="#8-6-4-Patterns" class="headerlink" title="8.6.4. Patterns"></a>8.6.4. Patterns</h4><p>注解</p>
<p>This section uses grammar notations beyond standard EBNF:</p>
<ul>
<li>the notation <code>SEP.RULE+</code> is shorthand for <code>RULE (SEP RULE)*</code></li>
<li>the notation <code>!RULE</code> is shorthand for a negative lookahead assertion</li>
</ul>
<p>The top-level syntax for <code>patterns</code> is:</p>
<pre><code>patterns       ::=  open_sequence_pattern | pattern
pattern        ::=  as_pattern | or_pattern
closed_pattern ::=  | literal_pattern
                    | capture_pattern
                    | wildcard_pattern
                    | value_pattern
                    | group_pattern
                    | sequence_pattern
                    | mapping_pattern
                    | class_pattern</code></pre><p>The descriptions below will include a description “in simple terms” of what a pattern does for illustration purposes (credits to Raymond Hettinger for a document that inspired most of the descriptions). Note that these descriptions are purely for illustration purposes and <strong>may not</strong> reflect the underlying implementation. Furthermore, they do not cover all valid forms.</p>
<h5 id="8-6-4-1-OR-Patterns"><a href="#8-6-4-1-OR-Patterns" class="headerlink" title="8.6.4.1. OR Patterns"></a>8.6.4.1. OR Patterns</h5><p>An OR pattern is two or more patterns separated by vertical bars <code>|</code>. Syntax:</p>
<pre><code>or_pattern ::=  "|".closed_pattern+</code></pre><p>Only the final subpattern may be irrefutable, and each subpattern must bind the same set of names to avoid ambiguity.</p>
<p>An OR pattern matches each of its subpatterns in turn to the subject value, until one succeeds. The OR pattern is then considered successful. Otherwise, if none of the subpatterns succeed, the OR pattern fails.</p>
<p>In simple terms, <code>P1 | P2 | ...</code> will try to match <code>P1</code>, if it fails it will try to match <code>P2</code>, succeeding immediately if any succeeds, failing otherwise.</p>
<h5 id="8-6-4-2-AS-Patterns"><a href="#8-6-4-2-AS-Patterns" class="headerlink" title="8.6.4.2. AS Patterns"></a>8.6.4.2. AS Patterns</h5><p>An AS pattern matches an OR pattern on the left of the <code>as</code> keyword against a subject. Syntax:</p>
<pre><code>as_pattern ::=  or_pattern "as" capture_pattern</code></pre><p>If the OR pattern fails, the AS pattern fails. Otherwise, the AS pattern binds the subject to the name on the right of the as keyword and succeeds. <code>capture_pattern</code> cannot be a a <code>_</code>.</p>
<p>In simple terms <code>P as NAME</code> will match with <code>P</code>, and on success it will set <code>NAME = &lt;subject&gt;</code>.</p>
<h5 id="8-6-4-3-Literal-Patterns"><a href="#8-6-4-3-Literal-Patterns" class="headerlink" title="8.6.4.3. Literal Patterns"></a>8.6.4.3. Literal Patterns</h5><p>A literal pattern corresponds to most literals in Python. Syntax:</p>
<pre><code>literal_pattern ::=  signed_number
                     | signed_number "+" NUMBER
                     | signed_number "-" NUMBER
                     | strings
                     | "None"
                     | "True"
                     | "False"
                     | signed_number: NUMBER | "-" NUMBER</code></pre><p>The rule <code>strings</code> and the token <code>NUMBER</code> are defined in the standard Python grammar. Triple-quoted strings are supported. Raw strings and byte strings are supported. 格式字符串字面值 are not supported.</p>
<p>The forms <code>signed_number '+' NUMBER</code> and <code>signed_number '-' NUMBER</code> are for expressing complex numbers; they require a real number on the left and an imaginary number on the right. E.g. <code>3 + 4j</code>.</p>
<p>In simple terms, <code>LITERAL</code> will succeed only if <code>&lt;subject&gt; == LITERAL</code>. For the singletons <code>None</code>, <code>True</code> and <code>False</code>, the <code>is</code> operator is used.</p>
<h5 id="8-6-4-4-Capture-Patterns"><a href="#8-6-4-4-Capture-Patterns" class="headerlink" title="8.6.4.4. Capture Patterns"></a>8.6.4.4. Capture Patterns</h5><p>A capture pattern binds the subject value to a name. Syntax:</p>
<pre><code>capture_pattern ::=  !'_' NAME</code></pre><p>A single underscore <code>_</code> is not a capture pattern (this is what <code>!'_'</code> expresses). It is instead treated as a <code>wildcard_pattern</code>.</p>
<p>In a given pattern, a given name can only be bound once. E.g. <code>case x, x: ...</code> is invalid while <code>case [x] | x: ...</code> is allowed.</p>
<p>Capture patterns always succeed. The binding follows scoping rules established by the assignment expression operator in <a href="https://www.python.org/dev/peps/pep-0572" target="_blank" rel="noopener"><strong>PEP 572</strong></a>; the name becomes a local variable in the closest containing function scope unless there’s an applicable <code>global</code> or <code>nonlocal</code> statement.</p>
<p>In simple terms <code>NAME</code> will always succeed and it will set <code>NAME = &lt;subject&gt;</code>.</p>
<h5 id="8-6-4-5-Wildcard-Patterns"><a href="#8-6-4-5-Wildcard-Patterns" class="headerlink" title="8.6.4.5. Wildcard Patterns"></a>8.6.4.5. Wildcard Patterns</h5><p>A wildcard pattern always succeeds (matches anything) and binds no name. Syntax:</p>
<pre><code>wildcard_pattern ::=  '_'</code></pre><p><code>_</code> is a soft keyword within any pattern, but only within patterns. It is an identifier, as usual, even within <code>match</code> subject expressions, <code>guard</code>s, and <code>case</code> blocks.</p>
<p>In simple terms, <code>_</code> will always succeed.</p>
<h5 id="8-6-4-6-Value-Patterns"><a href="#8-6-4-6-Value-Patterns" class="headerlink" title="8.6.4.6. Value Patterns"></a>8.6.4.6. Value Patterns</h5><p>A value pattern represents a named value in Python. Syntax:</p>
<pre><code>value_pattern ::=  attr
attr          ::=  name_or_attr "." NAME
name_or_attr  ::=  attr | NAME</code></pre><p>The dotted name in the pattern is looked up using standard Python name resolution rules. The pattern succeeds if the value found compares equal to the subject value (using the <code>==</code> equality operator).</p>
<p>In simple terms <code>NAME1.NAME2</code> will succeed only if <code>&lt;subject&gt; == NAME1.NAME2</code></p>
<p>注解</p>
<p>If the same value occurs multiple times in the same match statement, the interpreter may cache the first value found and reuse it rather than repeat the same lookup. This cache is strictly tied to a given execution of a given match statement.</p>
<h5 id="8-6-4-7-Group-Patterns"><a href="#8-6-4-7-Group-Patterns" class="headerlink" title="8.6.4.7. Group Patterns"></a>8.6.4.7. Group Patterns</h5><p>A group pattern allows users to add parentheses around patterns to emphasize the intended grouping. Otherwise, it has no additional syntax. Syntax:</p>
<pre><code>group_pattern ::=  "(" pattern ")"</code></pre><p>In simple terms <code>(P)</code> has the same effect as <code>P</code>.</p>
<h5 id="8-6-4-8-Sequence-Patterns"><a href="#8-6-4-8-Sequence-Patterns" class="headerlink" title="8.6.4.8. Sequence Patterns"></a>8.6.4.8. Sequence Patterns</h5><p>A sequence pattern contains several subpatterns to be matched against sequence elements. The syntax is similar to the unpacking of a list or tuple.</p>
<pre><code>sequence_pattern       ::=  "[" [maybe_sequence_pattern] "]"
                            | "(" [open_sequence_pattern] ")"
open_sequence_pattern  ::=  maybe_star_pattern "," [maybe_sequence_pattern]
maybe_sequence_pattern ::=  ",".maybe_star_pattern+ ","?
maybe_star_pattern     ::=  star_pattern | pattern
star_pattern           ::=  "*" (capture_pattern | wildcard_pattern)</code></pre><p>There is no difference if parentheses or square brackets are used for sequence patterns (i.e. <code>(...)</code> vs <code>[...]</code> ).</p>
<p>注解</p>
<p>A single pattern enclosed in parentheses without a trailing comma (e.g. <code>(3 | 4)</code>) is a group pattern. While a single pattern enclosed in square brackets (e.g. <code>[3 | 4]</code>) is still a sequence pattern.</p>
<p>At most one star subpattern may be in a sequence pattern. The star subpattern may occur in any position. If no star subpattern is present, the sequence pattern is a fixed-length sequence pattern; otherwise it is a variable-length sequence pattern.</p>
<p>The following is the logical flow for matching a sequence pattern against a subject value:</p>
<ol>
<li><p>If the subject value is not a sequence, the sequence pattern fails.</p>
</li>
<li><p>If the subject value is an instance of <code>str</code>, <code>bytes</code> or <code>bytearray</code> the sequence pattern fails.</p>
</li>
<li><p>The subsequent steps depend on whether the sequence pattern is fixed or variable-length.</p>
<p>If the sequence pattern is fixed-length:</p>
<ol>
<li>If the length of the subject sequence is not equal to the number of subpatterns, the sequence pattern fails</li>
<li>Subpatterns in the sequence pattern are matched to their corresponding items in the subject sequence from left to right. Matching stops as soon as a subpattern fails. If all subpatterns succeed in matching their corresponding item, the sequence pattern succeeds.</li>
</ol>
<p>Otherwise, if the sequence pattern is variable-length:</p>
<ol>
<li>If the length of the subject sequence is less than the number of non-star subpatterns, the sequence pattern fails.</li>
<li>The leading non-star subpatterns are matched to their corresponding items as for fixed-length sequences.</li>
<li>If the previous step succeeds, the star subpattern matches a list formed of the remaining subject items, excluding the remaining items corresponding to non-star subpatterns following the star subpattern.</li>
<li>Remaining non-star subpatterns are matched to their corresponding subject items, as for a fixed-length sequence.</li>
</ol>
<p>注解</p>
<p>The length of the subject sequence is obtained via <code>len()</code> (i.e. via the <code>__len__()</code> protocol). This length may be cached by the interpreter in a similar manner as value patterns.</p>
</li>
</ol>
<p>In simple terms <code>[P1, P2, P3,</code> … <code>, P&lt;N&gt;]</code> matches only if all the following happens:</p>
<ul>
<li>check <code>&lt;subject&gt;</code> is a sequence</li>
<li><code>len(subject) == &lt;N&gt;</code></li>
<li><code>P1</code> matches <code>&lt;subject&gt;[0]</code> (note that this match can also bind names)</li>
<li><code>P2</code> matches <code>&lt;subject&gt;[1]</code> (note that this match can also bind names)</li>
<li>… and so on for the corresponding pattern/element.</li>
</ul>
<h5 id="8-6-4-9-Mapping-Patterns"><a href="#8-6-4-9-Mapping-Patterns" class="headerlink" title="8.6.4.9. Mapping Patterns"></a>8.6.4.9. Mapping Patterns</h5><p>A mapping pattern contains one or more key-value patterns. The syntax is similar to the construction of a dictionary. Syntax:</p>
<pre><code>mapping_pattern     ::=  "{" [items_pattern] "}"
items_pattern       ::=  ",".key_value_pattern+ ","?
key_value_pattern   ::=  (literal_pattern | value_pattern) ":" pattern
                         | double_star_pattern
double_star_pattern ::=  "**" capture_pattern</code></pre><p>At most one double star pattern may be in a mapping pattern. The double star pattern must be the last subpattern in the mapping pattern.</p>
<p>Duplicate keys in mapping patterns are disallowed. Duplicate literal keys will raise a <code>SyntaxError</code>. Two keys that otherwise have the same value will raise a <code>ValueError</code> at runtime.</p>
<p>The following is the logical flow for matching a mapping pattern against a subject value:</p>
<ol>
<li>If the subject value is not a mapping ,the mapping pattern fails.</li>
<li>If every key given in the mapping pattern is present in the subject mapping, and the pattern for each key matches the corresponding item of the subject mapping, the mapping pattern succeeds.</li>
<li>If duplicate keys are detected in the mapping pattern, the pattern is considered invalid. A <code>SyntaxError</code> is raised for duplicate literal values; or a <code>ValueError</code> for named keys of the same value.</li>
</ol>
<p>注解</p>
<p>Key-value pairs are matched using the two-argument form of the mapping subject’s <code>get()</code> method. Matched key-value pairs must already be present in the mapping, and not created on-the-fly via <code>__missing__()</code> or <code>__getitem__()</code>.</p>
<p>In simple terms <code>{KEY1: P1, KEY2: P2, ... }</code> matches only if all the following happens:</p>
<ul>
<li>check <code>&lt;subject&gt;</code> is a mapping</li>
<li><code>KEY1 in &lt;subject&gt;</code></li>
<li><code>P1</code> matches <code>&lt;subject&gt;[KEY1]</code></li>
<li>… and so on for the corresponding KEY/pattern pair.</li>
</ul>
<h5 id="8-6-4-10-Class-Patterns"><a href="#8-6-4-10-Class-Patterns" class="headerlink" title="8.6.4.10. Class Patterns"></a>8.6.4.10. Class Patterns</h5><p>A class pattern represents a class and its positional and keyword arguments (if any). Syntax:</p>
<pre><code>class_pattern       ::=  name_or_attr "(" [pattern_arguments ","?] ")"
pattern_arguments   ::=  positional_patterns ["," keyword_patterns]
                         | keyword_patterns
positional_patterns ::=  ",".pattern+
keyword_patterns    ::=  ",".keyword_pattern+
keyword_pattern     ::=  NAME "=" pattern</code></pre><p>The same keyword should not be repeated in class patterns.</p>
<p>The following is the logical flow for matching a mapping pattern against a subject value:</p>
<ol>
<li><p>If <code>name_or_attr</code> is not an instance of the builtin <code>type</code> , raise <code>TypeError</code>.</p>
</li>
<li><p>If the subject value is not an instance of <code>name_or_attr</code> (tested via <code>isinstance()</code>), the class pattern fails.</p>
</li>
<li><p>If no pattern arguments are present, the pattern succeeds. Otherwise, the subsequent steps depend on whether keyword or positional argument patterns are present.</p>
<p>For a number of built-in types (specified below), a single positional subpattern is accepted which will match the entire subject; for these types keyword patterns also work as for other types.</p>
<p>If only keyword patterns are present, they are processed as follows, one by one:</p>
<p>I. The keyword is looked up as an attribute on the subject.</p>
<blockquote>
<ul>
<li>If this raises an exception other than <code>AttributeError</code>, the exception bubbles up.</li>
<li>If this raises <code>AttributeError</code>, the class pattern has failed.</li>
<li>Else, the subpattern associated with the keyword pattern is matched against the subject’s attribute value. If this fails, the class pattern fails; if this succeeds, the match proceeds to the next keyword.</li>
</ul>
</blockquote>
<p>II. If all keyword patterns succeed, the class pattern succeeds.</p>
<p>If any positional patterns are present, they are converted to keyword patterns using the <code>__match_args__</code> attribute on the class <code>name_or_attr</code> before matching:</p>
<p>I. The equivalent of <code>getattr(cls, "__match_args__", ())</code> is called.</p>
<blockquote>
<ul>
<li>If this raises an exception, the exception bubbles up.</li>
<li>If the returned value is not a tuple, the conversion fails and <code>TypeError</code> is raised.</li>
<li>If there are more positional patterns than <code>len(cls.__match_args__)</code>, <code>TypeError</code> is raised.</li>
<li>Otherwise, positional pattern <code>i</code> is converted to a keyword pattern using <code>__match_args__[i]</code> as the keyword. <code>__match_args__[i]</code> must be a string; if not <code>TypeError</code> is raised.</li>
<li>If there are duplicate keywords, <code>TypeError</code> is raised.</li>
</ul>
</blockquote>
<p>II. Once all positional patterns have been converted to keyword patterns,</p>
<p>the match proceeds as if there were only keyword patterns.</p>
<p>For the following built-in types the handling of positional subpatterns is different:</p>
<ul>
<li><code>bool</code></li>
<li><code>bytearray</code></li>
<li><code>bytes</code></li>
<li><code>dict</code></li>
<li><code>float</code></li>
<li><code>frozenset</code></li>
<li><code>int</code></li>
<li><code>list</code></li>
<li><code>set</code></li>
<li><code>str</code></li>
<li><code>tuple</code></li>
</ul>
<p>These classes accept a single positional argument, and the pattern there is matched against the whole object rather than an attribute. For example <code>int(0|1)</code> matches the value <code>0</code>, but not the values <code>0.0</code> or <code>False</code>.</p>
</li>
</ol>
<p>In simple terms <code>CLS(P1, attr=P2)</code> matches only if the following happens:</p>
<ul>
<li><code>isinstance(&lt;subject&gt;, CLS)</code></li>
<li>convert <code>P1</code> to a keyword pattern using <code>CLS.__match_args__</code></li>
<li>For each keyword argument <code>attr=P2</code>:<ul>
<li><code>hasattr(&lt;subject&gt;, "attr")</code></li>
<li><code>P2</code> matches <code>&lt;subject&gt;.attr</code></li>
</ul>
</li>
<li>… and so on for the corresponding keyword argument/pattern pair.</li>
</ul>
<p>参见</p>
<ul>
<li><a href="https://www.python.org/dev/peps/pep-0634" target="_blank" rel="noopener"><strong>PEP 634</strong></a> — Structural Pattern Matching: Specification</li>
<li><a href="https://www.python.org/dev/peps/pep-0636" target="_blank" rel="noopener"><strong>PEP 636</strong></a> — Structural Pattern Matching: Tutorial</li>
</ul>
<h3 id="8-7-函数定义"><a href="#8-7-函数定义" class="headerlink" title="8.7. 函数定义"></a>8.7. 函数定义</h3><p>函数定义就是对用户自定义函数的定义:</p>
<pre><code>funcdef                   ::=  [decorators] "def" funcname "(" [parameter_list] ")"
                               ["-&gt;" expression] ":" suite
decorators                ::=  decorator+
decorator                 ::=  "@" assignment_expression NEWLINE
parameter_list            ::=  defparameter ("," defparameter)* "," "/" ["," [parameter_list_no_posonly]]
                                 | parameter_list_no_posonly
parameter_list_no_posonly ::=  defparameter ("," defparameter)* ["," [parameter_list_starargs]]
                               | parameter_list_starargs
parameter_list_starargs   ::=  "*" [parameter] ("," defparameter)* ["," ["**" parameter [","]]]
                               | "**" parameter [","]
parameter                 ::=  identifier [":" expression]
defparameter              ::=  parameter ["=" expression]
funcname                  ::=  identifier</code></pre><p>函数定义是一条可执行语句。 它执行时会在当前局部命名空间中将函数名称绑定到一个函数对象（函数可执行代码的包装器）。 这个函数对象包含对当前全局命名空间的引用，作为函数被调用时所使用的全局命名空间。</p>
<p>函数定义并不会执行函数体；只有当函数被调用时才会执行此操作。</p>
<p>一个函数定义可以被一个或多个 decorator 表达式所包装。 当函数被定义时将在包含该函数定义的作用域中对装饰器表达式求值。 求值结果必须是一个可调用对象，它会以该函数对象作为唯一参数被发起调用。 其返回值将被绑定到函数名称而非函数对象。 多个装饰器会以嵌套方式被应用。 例如以下代码</p>
<pre class="line-numbers language-python"><code class="language-python">@f1<span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
@f2
<span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>大致等价于</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>
func <span class="token operator">=</span> f1<span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">(</span>f2<span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>不同之处在于原始函数并不会被临时绑定到名称 <code>func</code>。</p>
<p>在 3.9 版更改: 函数可使用任何有效的 <code>assignment_expression</code> 来装饰。 在之前版本中，此语法则更为受限，详情参见 <a href="https://www.python.org/dev/peps/pep-0614" target="_blank" rel="noopener"><strong>PEP 614</strong></a>。</p>
<p>当一个或多个 形参 具有 <em>形参</em> <code>=</code> <em>表达式</em> 这样的形式时，该函数就被称为具有“默认形参值”。 对于一个具有默认值的形参，其对应的 argument 可以在调用中被省略，在此情况下会用形参的默认值来替代。 如果一个形参具有默认值，后续所有在 “<code>*</code>“ 之前的形参也必须具有默认值 —- 这个句法限制并未在语法中明确表达。</p>
<p><strong>Default parameter values are evaluated from left to right when the function definition is executed.</strong> This means that the expression is evaluated once, when the function is defined, and that the same “pre-computed” value is used for each call. This is especially important to understand when a default parameter value is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default parameter value is in effect modified. This is generally not what was intended. A way around this is to use <code>None</code> as the default, and explicitly test for it in the body of the function, e.g.:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">whats_on_the_telly</span><span class="token punctuation">(</span>penguin<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> penguin <span class="token keyword">is</span> None<span class="token punctuation">:</span>
        penguin <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    penguin<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">"property of the zoo"</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> penguin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数调用总是会给形参列表中列出的所有形参赋值，或是用位置参数，或是用关键字参数，或是用默认值。 如果存在 “<code>*identifier</code>“ 这样的形式，它会被初始化为一个元组来接收任何额外的位置参数，默认为一个空元组。 如果存在 “<code>**identifier</code>“ 这样的形式，它会被初始化为一个新的有序映射来接收任何额外的关键字参数，默认为一个相同类型的空映射。 在 “<code>*</code>“ 或 “<code>*identifier</code>“ 之后的形参都是仅限关键字形参因而只能通过关键字参数传入。 在 “<code>/</code>“ 之前的形参都是仅限位置形参因而只能通过位置参数传入。</p>
<p>在 3.8 版更改: 可以使用 <code>/</code> 函数形参语法来标示仅限位置形参。 请参阅 <a href="https://www.python.org/dev/peps/pep-0570" target="_blank" rel="noopener"><strong>PEP 570</strong></a> 了解详情。</p>
<p>形参可以带有 标注，其形式为在形参名称后加上 “<code>: expression</code>“。 任何形参都可以带有标注，甚至 <code>*identifier</code> 或 <code>**identifier</code> 这样的形参也可以。 函数可以带有“返回”标注，其形式为在形参列表后加上 “<code>-&gt; expression</code>“。 这些标注可以是任何有效的 Python 表达式。 标注的存在不会改变函数的语义。 标注值可以作为函数对象的 <code>__annotations__</code> 属性中以对应形参名称为键的字典值被访问。 如果使用了 <code>annotations</code> import from <code>__future__</code> 的方式，则标注会在运行时保存为字符串以启用延迟求值特性。 否则，它们会在执行函数定义时被求值。 在这种情况下，标注的求值顺序可能与它们在源代码中出现的顺序不同。</p>
<p>创建匿名函数（未绑定到一个名称的函数）以便立即在表达式中使用也是可能的。 这需要使用 lambda 表达式。 请注意 lambda 只是简单函数定义的一种简化写法；在 “<code>def</code>“ 语句中定义的函数也可以像用 lambda 表达式定义的函数一样被传递或赋值给其他名称。 “<code>def</code>“ 形式实际上更为强大，因为它允许执行多条语句和使用标注。</p>
<p><strong>程序员注意事项:</strong> 函数属于一类对象。 在一个函数内部执行的 “<code>def</code>“ 语句会定义一个局部函数并可被返回或传递。 在嵌套函数中使用的自由变量可以访问包含该 def 语句的函数的局部变量。 </p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-3107" target="_blank" rel="noopener"><strong>PEP 3107</strong></a> - 函数标注</p>
<p>最初的函数标注规范说明。</p>
<p><a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener"><strong>PEP 484</strong></a> - 类型提示</p>
<p>标注的标准含意定义：类型提示。</p>
<p><a href="https://www.python.org/dev/peps/pep-0526" target="_blank" rel="noopener"><strong>PEP 526</strong></a> - 变量标注的语法</p>
<p>变量声明的类型提示功能，包括类变量和实例变量</p>
<p><a href="https://www.python.org/dev/peps/pep-0563" target="_blank" rel="noopener"><strong>PEP 563</strong></a> - 延迟的标注求值</p>
<p>支持在运行时通过以字符串形式保存标注而非不是即求值来实现标注内部的向前引用。</p>
<h3 id="8-8-类定义"><a href="#8-8-类定义" class="headerlink" title="8.8. 类定义"></a>8.8. 类定义</h3><p>类定义就是对类对象的定义</p>
<pre><code>classdef    ::=  [decorators] "class" classname [inheritance] ":" suite
inheritance ::=  "(" [argument_list] ")"
classname   ::=  identifier</code></pre><p>类定义是一条可执行语句。 其中继承列表通常给出基类的列表 (进阶用法请参见 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/0f878f8da7da8dd7.md#metaclasses" target="_blank" rel="noopener">元类</a>)，列表中的每一项都应当被求值为一个允许子类的类对象。 没有继承列表的类默认继承自基类 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/343ac5efc1fa2896.md#object" target="_blank" rel="noopener"><code>object</code></a>；因此，:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>    
    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>等价于</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    
    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>随后类体将在一个新的执行帧中被执行，使用新创建的局部命名空间和原有的全局命名空间。 （通常，类体主要包含函数定义。） 当类体结束执行时，其执行帧将被丢弃而其局部命名空间会被保存。 一个类对象随后会被创建，其基类使用给定的继承列表，属性字典使用保存的局部命名空间。 类名称将在原有的全局命名空间中绑定到该类对象。</p>
<p>在类体内定义的属性的顺序保存在新类的 <code>__dict__</code> 中。 请注意此顺序的可靠性只限于类刚被创建时，并且只适用于使用定义语法所定义的类。</p>
<p>类的创建可使用 元类 进行重度定制。</p>
<p>类也可以被装饰：就像装饰函数一样，:</p>
<pre class="line-numbers language-python"><code class="language-python">@f1<span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
@f2
<span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span> <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>大致等价于</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>
Foo <span class="token operator">=</span> f1<span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">(</span>f2<span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>装饰器表达式的求值规则与函数装饰器相同。 结果随后会被绑定到类名称。</p>
<p>在 3.9 版更改: 类可使用任何有效的 <code>assignment_expression</code> 来装饰。 在之前版本中，此语法则更为受限，详情参见 <a href="https://www.python.org/dev/peps/pep-0614" target="_blank" rel="noopener"><strong>PEP 614</strong></a>。</p>
<p><strong>程序员注意事项:</strong> 在类定义内定义的变量是类属性；它们将被类实例所共享。 实例属性可通过 <code>self.name = value</code> 在方法中设定。 类和实例属性均可通过 “<code>self.name</code>“ 表示法来访问，当通过此方式访问时实例属性会隐藏同名的类属性。 类属性可被用作实例属性的默认值，但在此场景下使用可变值可能导致未预期的结果。 可以使用 描述器 来创建具有不同实现细节的实例变量。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-3115" target="_blank" rel="noopener"><strong>PEP 3115</strong></a> - Python 3000 中的元类</p>
<p>将元类声明修改为当前语法的提议，以及关于如何构建带有元类的类的语义描述。</p>
<p><a href="https://www.python.org/dev/peps/pep-3129" target="_blank" rel="noopener"><strong>PEP 3129</strong></a> - 类装饰器</p>
<p>增加类装饰器的提议。 函数和方法装饰器是在 <a href="https://www.python.org/dev/peps/pep-0318" target="_blank" rel="noopener"><strong>PEP 318</strong></a> 中被引入的。</p>
<h3 id="8-9-协程"><a href="#8-9-协程" class="headerlink" title="8.9. 协程"></a>8.9. 协程</h3><p>3.5 新版功能.</p>
<h4 id="8-9-1-协程函数定义"><a href="#8-9-1-协程函数定义" class="headerlink" title="8.9.1. 协程函数定义"></a>8.9.1. 协程函数定义</h4><pre><code>async_funcdef ::=  [decorators] "async" "def" funcname "(" [parameter_list] ")"
                   ["-&gt;" expression] ":" suite</code></pre><p>Execution of Python coroutines can be suspended and resumed at many points (see coroutine). <code>await</code> expressions, <code>async for</code> and <code>async with</code> can only be used in the body of a coroutine function.</p>
<p>使用 <code>async def</code> 语法定义的函数总是为协程函数，即使它们不包含 <code>await</code> 或 <code>async</code> 关键字。</p>
<p>在协程函数体中使用 <code>yield from</code> 表达式将引发 <code>SyntaxError</code>。</p>
<p>协程函数的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>param1<span class="token punctuation">,</span> param2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    do_stuff<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">await</span> some_coroutine<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 3.7 版更改: <code>await</code> and <code>async</code> are now keywords; previously they were only treated as such inside the body of a coroutine function.</p>
<h4 id="8-9-2-async-for-语句"><a href="#8-9-2-async-for-语句" class="headerlink" title="8.9.2. async for 语句"></a>8.9.2. <code>async for</code> 语句</h4><pre><code>async_for_stmt ::=  "async" for_stmt</code></pre><p>asynchronous iterable 提供了 <code>__aiter__</code> 方法，该方法会直接返回 asynchronous iterator，它可以在其 <code>__anext__</code> 方法中调用异步代码。</p>
<p><code>async for</code> 语句允许方便地对异步可迭代对象进行迭代。</p>
<p>以下代码:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">async</span> <span class="token keyword">for</span> TARGET <span class="token keyword">in</span> ITER<span class="token punctuation">:</span>
    SUITE
<span class="token keyword">else</span><span class="token punctuation">:</span>
    SUITE2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在语义上等价于:</p>
<pre class="line-numbers language-python"><code class="language-python">iter <span class="token operator">=</span> <span class="token punctuation">(</span>ITER<span class="token punctuation">)</span>
iter <span class="token operator">=</span> type<span class="token punctuation">(</span>iter<span class="token punctuation">)</span><span class="token punctuation">.</span>__aiter__<span class="token punctuation">(</span>iter<span class="token punctuation">)</span>
running <span class="token operator">=</span> <span class="token boolean">True</span>
<span class="token keyword">while</span> running<span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        TARGET <span class="token operator">=</span> <span class="token keyword">await</span> type<span class="token punctuation">(</span>iter<span class="token punctuation">)</span><span class="token punctuation">.</span>__anext__<span class="token punctuation">(</span>iter<span class="token punctuation">)</span>
    <span class="token keyword">except</span> StopAsyncIteration<span class="token punctuation">:</span>
        running <span class="token operator">=</span> <span class="token boolean">False</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        SUITE
<span class="token keyword">else</span><span class="token punctuation">:</span>
    SUITE2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在协程函数体之外使用 <code>async for</code> 语句将引发 <code>SyntaxError</code>。</p>
<h4 id="8-9-3-async-with-语句"><a href="#8-9-3-async-with-语句" class="headerlink" title="8.9.3. async with 语句"></a>8.9.3. <code>async with</code> 语句</h4><pre><code>async_with_stmt ::=  "async" with_stmt</code></pre><p>asynchronous context manager 是一种 context manager，能够在其 <em>enter</em> 和 <em>exit</em> 方法中暂停执行。</p>
<p>以下代码:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">async</span> <span class="token keyword">with</span> EXPRESSION <span class="token keyword">as</span> TARGET<span class="token punctuation">:</span>    
    SUITE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在语义上等价于:</p>
<pre class="line-numbers language-python"><code class="language-python">manager <span class="token operator">=</span> <span class="token punctuation">(</span>EXPRESSION<span class="token punctuation">)</span>
aenter <span class="token operator">=</span> type<span class="token punctuation">(</span>manager<span class="token punctuation">)</span><span class="token punctuation">.</span>__aenter__
aexit <span class="token operator">=</span> type<span class="token punctuation">(</span>manager<span class="token punctuation">)</span><span class="token punctuation">.</span>__aexit__
value <span class="token operator">=</span> <span class="token keyword">await</span> aenter<span class="token punctuation">(</span>manager<span class="token punctuation">)</span>
hit_except <span class="token operator">=</span> <span class="token boolean">False</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    TARGET <span class="token operator">=</span> value
    SUITE
<span class="token keyword">except</span><span class="token punctuation">:</span>
    hit_except <span class="token operator">=</span> <span class="token boolean">True</span>
    <span class="token keyword">if</span> <span class="token operator">not</span> <span class="token keyword">await</span> aexit<span class="token punctuation">(</span>manager<span class="token punctuation">,</span> <span class="token operator">*</span>sys<span class="token punctuation">.</span>exc_info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span>
<span class="token keyword">finally</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token operator">not</span> hit_except<span class="token punctuation">:</span>
        <span class="token keyword">await</span> aexit<span class="token punctuation">(</span>manager<span class="token punctuation">,</span> None<span class="token punctuation">,</span> None<span class="token punctuation">,</span> None<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另请参阅 <code>__aenter__()</code> 和 <code>__aexit__()</code> 了解详情。</p>
<p>在协程函数体之外使用 <code>async with</code> 语句将引发 <code>SyntaxError</code>。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> - 使用 async 和 await 语法实现协程</p>
<p>将协程作为 Python 中的一个正式的单独概念，并增加相应的支持语法。</p>
<p>注：</p>
<ul>
<li><p>异常会被传播给发起调用栈，除非存在一个 <code>finally</code> 子句正好引发了另一个异常。 新引发的异常将导致旧异常的丢失。</p>
</li>
<li><p>In pattern matching, a sequence is defined as one of the following:</p>
<blockquote>
<ul>
<li>a class that inherits from <code>collections.abc.Sequence</code></li>
<li>a Python class that has been registered as <code>collections.abc.Sequence</code></li>
<li>a builtin class that has its (CPython) <code>Py_TPFLAGS_SEQUENCE</code> bit set</li>
<li>a class that inherits from any of the above</li>
</ul>
</blockquote>
<p>The following standard library classes are sequences:</p>
<blockquote>
<ul>
<li><code>array.array</code></li>
<li><code>collections.deque</code></li>
<li><code>list</code></li>
<li><code>memoryview</code></li>
<li><code>range</code></li>
<li><code>tuple</code></li>
</ul>
</blockquote>
<p>注解</p>
<p>Subject values of type <code>str</code>, <code>bytes</code>, and <code>bytearray</code> do not match sequence patterns.</p>
</li>
<li><p>In pattern matching, a mapping is defined as one of the following:</p>
<blockquote>
<ul>
<li>a class that inherits from <code>collections.abc.Mapping</code></li>
<li>a Python class that has been registered as <code>collections.abc.Mapping</code></li>
<li>a builtin class that has its (CPython) <code>Py_TPFLAGS_MAPPING</code> bit set</li>
<li>a class that inherits from any of the above</li>
</ul>
</blockquote>
<p>The standard library classes <code>dict</code> and <code>types.MappingProxyType</code> are mappings.</p>
</li>
<li><p>作为函数体的第一条语句出现的字符串字面值会被转换为函数的 <code>__doc__</code> 属性，也就是该函数的 docstring。</p>
</li>
<li><p>作为类体的第一条语句出现的字符串字面值会被转换为命名空间的 <code>__doc__</code> 条目，也就是该类的 docstring。</p>
</li>
</ul>
<h2 id="9-顶级组件"><a href="#9-顶级组件" class="headerlink" title="9. 顶级组件"></a>9. 顶级组件</h2><p>Python 解释器可以从多种源获得输入：作为标准输入或程序参数传入的脚本，以交互方式键入的语句，导入的模块源文件等等。 这一章将给出在这些情况下所用的语法。</p>
<h3 id="9-1-完整的-Python-程序"><a href="#9-1-完整的-Python-程序" class="headerlink" title="9.1. 完整的 Python 程序"></a>9.1. 完整的 Python 程序</h3><p>虽然语言规范描述不必规定如何发起调用语言解释器，但对完整的 Python 程序加以说明还是很有用的。 一个完整的 Python 程序会在最小初始化环境中被执行：所有内置和标准模块均为可用，但均处于未初始化状态，只有 <code>sys</code> (各种系统服务), <code>builtins</code> (内置函数、异常以及 <code>None</code>) 和 <code>__main__</code> 除外。 最后一个模块用于为完整程序的执行提供局部和全局命名空间。</p>
<p>适用于一个完整 Python 程序的语法即下节所描述的文件输入。</p>
<p>解释器也可以通过交互模式被发起调用；在此情况下，它并不读取和执行一个完整程序，而是每次读取和执行一条语句（可能为复合语句）。 此时的初始环境与一个完整程序的相同；每条语句会在 <code>__main__</code> 的命名空间中被执行。</p>
<p>一个完整程序可通过三种形式被传递给解释器：使用 <code>-c</code> <em>字符串</em> 命令行选项，使用一个文件作为第一个命令行参数，或者使用标准输入。 如果文件或标准输入是一个 tty 设置，解释器会进入交互模式；否则的话，它会将文件当作一个完整程序来执行。</p>
<h3 id="9-2-文件输入"><a href="#9-2-文件输入" class="headerlink" title="9.2. 文件输入"></a>9.2. 文件输入</h3><p>所有从非交互式文件读取的输入都具有相同的形式:</p>
<pre><code>file_input ::=  (NEWLINE | statement)*</code></pre><p>此语法用于下列几种情况:</p>
<ul>
<li>解析一个完整 Python 程序时（从文件或字符串）；</li>
<li>解析一个模块时；</li>
<li>解析一个传递给 <code>exec()</code> 函数的字符串时；</li>
</ul>
<h3 id="9-3-交互式输入"><a href="#9-3-交互式输入" class="headerlink" title="9.3. 交互式输入"></a>9.3. 交互式输入</h3><p>交互模式下的输入使用以下语法进行解析:</p>
<pre><code>interactive_input ::=  [stmt_list] NEWLINE | compound_stmt NEWLINE</code></pre><p>请注意在交互模式下一条（最高层级）复合语句必须带有一个空行；这对于帮助解析器确定输入的结束是必须的。</p>
<h3 id="9-4-表达式输入"><a href="#9-4-表达式输入" class="headerlink" title="9.4. 表达式输入"></a>9.4. 表达式输入</h3><p><code>eval()</code> 被用于表达式输入。 它会忽略开头的空白。 传递给 <code>eval()</code> 的字符串参数必须具有以下形式:</p>
<pre><code>eval_input ::=  expression_list NEWLINE*</code></pre><h2 id="10-完整的语法规范"><a href="#10-完整的语法规范" class="headerlink" title="10. 完整的语法规范"></a>10. 完整的语法规范</h2><p>这是完整的 Python 语法规范，直接提取自用于生成 CPython 解析器的语法 。 这里显示的版本省略了有关代码生成和错误恢复的细节。</p>
<p>该标记法是 EBNF 和 PEG 的混合体。 特别地，<code>&amp;</code> 后跟一个符号、形符或带括号的分组来表示正向前视（即要求匹配但不会消耗掉），而 <code>!</code> 表示负向前视（即 <em>不要求</em> 匹配）。 我们使用 <code>|</code> 分隔符来表示 PEG 的“有序选择” (在传统 PEG 语法中写作 <code>/</code>)。 请参阅 <a href="https://www.python.org/dev/peps/pep-0617" target="_blank" rel="noopener"><strong>PEP 617</strong></a> 了解有关该语法规则的更多细节。</p>
<pre><code># PEG grammar for Python
file: [statements] ENDMARKER 
interactive: statement_newline 
eval: expressions NEWLINE* ENDMARKER 
func_type: '(' [type_expressions] ')' '-&gt;' expression NEWLINE* ENDMARKER 
fstring: star_expressions
# type_expressions allow */** but ignore them
type_expressions:
    | ','.expression+ ',' '*' expression ',' '**' expression 
    | ','.expression+ ',' '*' expression 
    | ','.expression+ ',' '**' expression 
    | '*' expression ',' '**' expression 
    | '*' expression 
    | '**' expression 
    | ','.expression+ 
statements: statement+ 
statement: compound_stmt  | simple_stmts 
statement_newline:
    | compound_stmt NEWLINE 
    | simple_stmts
    | NEWLINE 
    | ENDMARKER 
simple_stmts:
    | simple_stmt !';' NEWLINE  # Not needed, there for speedup
    | ';'.simple_stmt+ [';'] NEWLINE 
# NOTE: assignment MUST precede expression, else parsing a simple assignment
# will throw a SyntaxError.
simple_stmt:
    | assignment
    | star_expressions 
    | return_stmt
    | import_stmt
    | raise_stmt
    | 'pass' 
    | del_stmt
    | yield_stmt
    | assert_stmt
    | 'break' 
    | 'continue' 
    | global_stmt
    | nonlocal_stmt
compound_stmt:
    | function_def
    | if_stmt
    | class_def
    | with_stmt
    | for_stmt
    | try_stmt
    | while_stmt
    | match_stmt
# NOTE: annotated_rhs may start with 'yield'; yield_expr must start with 'yield'
assignment:
    | NAME ':' expression ['=' annotated_rhs ] 
    | ('(' single_target ')' 
         | single_subscript_attribute_target) ':' expression ['=' annotated_rhs ] 
    | (star_targets '=' )+ (yield_expr | star_expressions) !'=' [TYPE_COMMENT] 
    | single_target augassign ~ (yield_expr | star_expressions) 
augassign:
    | '+=' 
    | '-=' 
    | '*=' 
    | '@=' 
    | '/=' 
    | '%=' 
    | '&amp;=' 
    | '|=' 
    | '^=' 
    | '&lt;&lt;=' 
    | '&gt;&gt;=' 
    | '**=' 
    | '//=' 
global_stmt: 'global' ','.NAME+ 
nonlocal_stmt: 'nonlocal' ','.NAME+ 
yield_stmt: yield_expr 
assert_stmt: 'assert' expression [',' expression ] 
del_stmt:
    | 'del' del_targets &amp;(';' | NEWLINE) 
import_stmt: import_name | import_from
import_name: 'import' dotted_as_names 
# note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS
import_from:
    | 'from' ('.' | '...')* dotted_name 'import' import_from_targets 
    | 'from' ('.' | '...')+ 'import' import_from_targets 
import_from_targets:
    | '(' import_from_as_names [','] ')' 
    | import_from_as_names !','
    | '*' 
import_from_as_names:
    | ','.import_from_as_name+ 
import_from_as_name:
    | NAME ['as' NAME ] 
dotted_as_names:
    | ','.dotted_as_name+ 
dotted_as_name:
    | dotted_name ['as' NAME ] 
dotted_name:
    | dotted_name '.' NAME 
    | NAME
if_stmt:
    | 'if' named_expression ':' block elif_stmt 
    | 'if' named_expression ':' block [else_block] 
elif_stmt:
    | 'elif' named_expression ':' block elif_stmt 
    | 'elif' named_expression ':' block [else_block] 
else_block:
    | 'else' ':' block 
while_stmt:
    | 'while' named_expression ':' block [else_block] 
for_stmt:
    | 'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block [else_block] 
    | ASYNC 'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block [else_block] 
with_stmt:
    | 'with' '(' ','.with_item+ ','? ')' ':' block 
    | 'with' ','.with_item+ ':' [TYPE_COMMENT] block 
    | ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block 
    | ASYNC 'with' ','.with_item+ ':' [TYPE_COMMENT] block 
with_item:
    | expression 'as' star_target &amp;(',' | ')' | ':') 
    | expression 
try_stmt:
    | 'try' ':' block finally_block 
    | 'try' ':' block except_block+ [else_block] [finally_block] 
except_block:
    | 'except' expression ['as' NAME ] ':' block 
    | 'except' ':' block 
finally_block:
    | 'finally' ':' block 
match_stmt:
    | "match" subject_expr ':' NEWLINE INDENT case_block+ DEDENT 
subject_expr:
    | star_named_expression ',' star_named_expressions? 
    | named_expression
case_block:
    | "case" patterns guard? ':' block 
guard: 'if' named_expression 
patterns:
    | open_sequence_pattern 
    | pattern
pattern:
    | as_pattern
    | or_pattern
as_pattern:
    | or_pattern 'as' pattern_capture_target 
or_pattern:
    | '|'.closed_pattern+ 
closed_pattern:
    | literal_pattern
    | capture_pattern
    | wildcard_pattern
    | value_pattern
    | group_pattern
    | sequence_pattern
    | mapping_pattern
    | class_pattern
# Literal patterns are used for equality and identity constraints
literal_pattern:
    | signed_number !('+' | '-') 
    | complex_number 
    | strings 
    | 'None' 
    | 'True' 
    | 'False' 
# Literal expressions are used to restrict permitted mapping pattern keys
literal_expr:
    | signed_number !('+' | '-')
    | complex_number
    | strings
    | 'None' 
    | 'True' 
    | 'False' 
complex_number:
    | signed_real_number '+' imaginary_number 
    | signed_real_number '-' imaginary_number  
signed_number:
    | NUMBER
    | '-' NUMBER 
signed_real_number:
    | real_number
    | '-' real_number 
real_number:
    | NUMBER 
imaginary_number:
    | NUMBER 
capture_pattern:
    | pattern_capture_target 
pattern_capture_target:
    | !"_" NAME !('.' | '(' | '=') 
wildcard_pattern:
    | "_" 
value_pattern:
    | attr !('.' | '(' | '=') 
attr:
    | name_or_attr '.' NAME 
name_or_attr:
    | attr
    | NAME
group_pattern:
    | '(' pattern ')' 
sequence_pattern:
    | '[' maybe_sequence_pattern? ']' 
    | '(' open_sequence_pattern? ')' 
open_sequence_pattern:
    | maybe_star_pattern ',' maybe_sequence_pattern? 
maybe_sequence_pattern:
    | ','.maybe_star_pattern+ ','? 
maybe_star_pattern:
    | star_pattern
    | pattern
star_pattern:
    | '*' pattern_capture_target 
    | '*' wildcard_pattern 
mapping_pattern:
    | '{' '}' 
    | '{' double_star_pattern ','? '}' 
    | '{' items_pattern ',' double_star_pattern ','? '}' 
    | '{' items_pattern ','? '}' 
items_pattern:
    | ','.key_value_pattern+
key_value_pattern:
    | (literal_expr | attr) ':' pattern 
double_star_pattern:
    | '**' pattern_capture_target 
class_pattern:
    | name_or_attr '(' ')' 
    | name_or_attr '(' positional_patterns ','? ')' 
    | name_or_attr '(' keyword_patterns ','? ')' 
    | name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')' 
positional_patterns:
    | ','.pattern+ 
keyword_patterns:
    | ','.keyword_pattern+
keyword_pattern:
    | NAME '=' pattern 
return_stmt:
    | 'return' [star_expressions] 
raise_stmt:
    | 'raise' expression ['from' expression ] 
    | 'raise' 
function_def:
    | decorators function_def_raw 
    | function_def_raw
function_def_raw:
    | 'def' NAME '(' [params] ')' ['-&gt;' expression ] ':' [func_type_comment] block 
    | ASYNC 'def' NAME '(' [params] ')' ['-&gt;' expression ] ':' [func_type_comment] block 
func_type_comment:
    | NEWLINE TYPE_COMMENT &amp;(NEWLINE INDENT)   # Must be followed by indented block
    | TYPE_COMMENT
params:
    | parameters
parameters:
    | slash_no_default param_no_default* param_with_default* [star_etc] 
    | slash_with_default param_with_default* [star_etc] 
    | param_no_default+ param_with_default* [star_etc] 
    | param_with_default+ [star_etc] 
    | star_etc 
# Some duplication here because we can't write (',' | &amp;')'),
# which is because we don't support empty alternatives (yet).
#
slash_no_default:
    | param_no_default+ '/' ',' 
    | param_no_default+ '/' &amp;')' 
slash_with_default:
    | param_no_default* param_with_default+ '/' ',' 
    | param_no_default* param_with_default+ '/' &amp;')' 
star_etc:
    | '*' param_no_default param_maybe_default* [kwds] 
    | '*' ',' param_maybe_default+ [kwds] 
    | kwds 
kwds: '**' param_no_default 
# One parameter.  This *includes* a following comma and type comment.
#
# There are three styles:
# - No default
# - With default
# - Maybe with default
#
# There are two alternative forms of each, to deal with type comments:
# - Ends in a comma followed by an optional type comment
# - No comma, optional type comment, must be followed by close paren
# The latter form is for a final parameter without trailing comma.
#
param_no_default:
    | param ',' TYPE_COMMENT? 
    | param TYPE_COMMENT? &amp;')' 
param_with_default:
    | param default ',' TYPE_COMMENT? 
    | param default TYPE_COMMENT? &amp;')' 
param_maybe_default:
    | param default? ',' TYPE_COMMENT? 
    | param default? TYPE_COMMENT? &amp;')' 
param: NAME annotation? 
annotation: ':' expression 
default: '=' expression 
decorators: ('@' named_expression NEWLINE )+ 
class_def:
    | decorators class_def_raw 
    | class_def_raw
class_def_raw:
    | 'class' NAME ['(' [arguments] ')' ] ':' block 
block:
    | NEWLINE INDENT statements DEDENT 
    | simple_stmts
star_expressions:
    | star_expression (',' star_expression )+ [','] 
    | star_expression ',' 
    | star_expression
star_expression:
    | '*' bitwise_or 
    | expression
star_named_expressions: ','.star_named_expression+ [','] 
star_named_expression:
    | '*' bitwise_or 
    | named_expression
assigment_expression:
    | NAME ':=' ~ expression 
named_expression:
    | assigment_expression
    | expression !':='
annotated_rhs: yield_expr | star_expressions
expressions:
    | expression (',' expression )+ [','] 
    | expression ',' 
    | expression
expression:
    | disjunction 'if' disjunction 'else' expression 
    | disjunction
    | lambdef
lambdef:
    | 'lambda' [lambda_params] ':' expression 
lambda_params:
    | lambda_parameters
# lambda_parameters etc. duplicates parameters but without annotations
# or type comments, and if there's no comma after a parameter, we expect
# a colon, not a close parenthesis.  (For more, see parameters above.)
#
lambda_parameters:
    | lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* [lambda_star_etc] 
    | lambda_slash_with_default lambda_param_with_default* [lambda_star_etc] 
    | lambda_param_no_default+ lambda_param_with_default* [lambda_star_etc] 
    | lambda_param_with_default+ [lambda_star_etc] 
    | lambda_star_etc 
lambda_slash_no_default:
    | lambda_param_no_default+ '/' ',' 
    | lambda_param_no_default+ '/' &amp;':' 
lambda_slash_with_default:
    | lambda_param_no_default* lambda_param_with_default+ '/' ',' 
    | lambda_param_no_default* lambda_param_with_default+ '/' &amp;':' 
lambda_star_etc:
    | '*' lambda_param_no_default lambda_param_maybe_default* [lambda_kwds] 
    | '*' ',' lambda_param_maybe_default+ [lambda_kwds] 
    | lambda_kwds 
lambda_kwds: '**' lambda_param_no_default 
lambda_param_no_default:
    | lambda_param ',' 
    | lambda_param &amp;':' 
lambda_param_with_default:
    | lambda_param default ',' 
    | lambda_param default &amp;':' 
lambda_param_maybe_default:
    | lambda_param default? ',' 
    | lambda_param default? &amp;':' 
lambda_param: NAME 
disjunction:
    | conjunction ('or' conjunction )+ 
    | conjunction
conjunction:
    | inversion ('and' inversion )+ 
    | inversion
inversion:
    | 'not' inversion 
    | comparison
comparison:
    | bitwise_or compare_op_bitwise_or_pair+ 
    | bitwise_or
compare_op_bitwise_or_pair:
    | eq_bitwise_or
    | noteq_bitwise_or
    | lte_bitwise_or
    | lt_bitwise_or
    | gte_bitwise_or
    | gt_bitwise_or
    | notin_bitwise_or
    | in_bitwise_or
    | isnot_bitwise_or
    | is_bitwise_or
eq_bitwise_or: '==' bitwise_or 
noteq_bitwise_or:
    | ('!=' ) bitwise_or 
lte_bitwise_or: '&lt;=' bitwise_or 
lt_bitwise_or: '&lt;' bitwise_or 
gte_bitwise_or: '&gt;=' bitwise_or 
gt_bitwise_or: '&gt;' bitwise_or 
notin_bitwise_or: 'not' 'in' bitwise_or 
in_bitwise_or: 'in' bitwise_or 
isnot_bitwise_or: 'is' 'not' bitwise_or 
is_bitwise_or: 'is' bitwise_or 
bitwise_or:
    | bitwise_or '|' bitwise_xor 
    | bitwise_xor
bitwise_xor:
    | bitwise_xor '^' bitwise_and 
    | bitwise_and
bitwise_and:
    | bitwise_and '&amp;' shift_expr 
    | shift_expr
shift_expr:
    | shift_expr '&lt;&lt;' sum 
    | shift_expr '&gt;&gt;' sum 
    | sum
sum:
    | sum '+' term 
    | sum '-' term 
    | term
term:
    | term '*' factor 
    | term '/' factor 
    | term '//' factor 
    | term '%' factor 
    | term '@' factor 
    | factor
factor:
    | '+' factor 
    | '-' factor 
    | '~' factor 
    | power
power:
    | await_primary '**' factor 
    | await_primary
await_primary:
    | AWAIT primary 
    | primary
primary:
    | invalid_primary  # must be before 'primay genexp' because of invalid_genexp
    | primary '.' NAME 
    | primary genexp 
    | primary '(' [arguments] ')' 
    | primary '[' slices ']' 
    | atom
slices:
    | slice !',' 
    | ','.slice+ [','] 
slice:
    | [expression] ':' [expression] [':' [expression] ] 
    | named_expression 
atom:
    | NAME
    | 'True' 
    | 'False' 
    | 'None' 
    | strings
    | NUMBER
    | (tuple | group | genexp)
    | (list | listcomp)
    | (dict | set | dictcomp | setcomp)
    | '...' 
strings: STRING+ 
list:
    | '[' [star_named_expressions] ']' 
listcomp:
    | '[' named_expression for_if_clauses ']' 
tuple:
    | '(' [star_named_expression ',' [star_named_expressions]  ] ')' 
group:
    | '(' (yield_expr | named_expression) ')' 
genexp:
    | '(' ( assigment_expression | expression !':=') for_if_clauses ')' 
set: '{' star_named_expressions '}' 
setcomp:
    | '{' named_expression for_if_clauses '}' 
dict:
    | '{' [double_starred_kvpairs] '}' 
    | '{' invalid_double_starred_kvpairs '}'
dictcomp:
    | '{' kvpair for_if_clauses '}' 
double_starred_kvpairs: ','.double_starred_kvpair+ [','] 
double_starred_kvpair:
    | '**' bitwise_or 
    | kvpair
kvpair: expression ':' expression 
for_if_clauses:
    | for_if_clause+ 
for_if_clause:
    | ASYNC 'for' star_targets 'in' ~ disjunction ('if' disjunction )* 
    | 'for' star_targets 'in' ~ disjunction ('if' disjunction )* 
yield_expr:
    | 'yield' 'from' expression 
    | 'yield' [star_expressions] 
arguments:
    | args [','] &amp;')' 
args:
    | ','.(starred_expression | ( assigment_expression | expression !':=') !'=')+ [',' kwargs ] 
    | kwargs 
kwargs:
    | ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+ 
    | ','.kwarg_or_starred+
    | ','.kwarg_or_double_starred+
starred_expression:
    | '*' expression 
kwarg_or_starred:
    | NAME '=' expression 
    | starred_expression 
kwarg_or_double_starred:
    | NAME '=' expression 
    | '**' expression 
# NOTE: star_targets may contain *bitwise_or, targets may not.
star_targets:
    | star_target !',' 
    | star_target (',' star_target )* [','] 
star_targets_list_seq: ','.star_target+ [','] 
star_targets_tuple_seq:
    | star_target (',' star_target )+ [','] 
    | star_target ',' 
star_target:
    | '*' (!'*' star_target) 
    | target_with_star_atom
target_with_star_atom:
    | t_primary '.' NAME !t_lookahead 
    | t_primary '[' slices ']' !t_lookahead 
    | star_atom
star_atom:
    | NAME 
    | '(' target_with_star_atom ')' 
    | '(' [star_targets_tuple_seq] ')' 
    | '[' [star_targets_list_seq] ']' 
single_target:
    | single_subscript_attribute_target
    | NAME 
    | '(' single_target ')' 
single_subscript_attribute_target:
    | t_primary '.' NAME !t_lookahead 
    | t_primary '[' slices ']' !t_lookahead 
del_targets: ','.del_target+ [','] 
del_target:
    | t_primary '.' NAME !t_lookahead 
    | t_primary '[' slices ']' !t_lookahead 
    | del_t_atom
del_t_atom:
    | NAME 
    | '(' del_target ')' 
    | '(' [del_targets] ')' 
    | '[' [del_targets] ']' 
t_primary:
    | t_primary '.' NAME &amp;t_lookahead 
    | t_primary '[' slices ']' &amp;t_lookahead 
    | t_primary genexp &amp;t_lookahead 
    | t_primary '(' [arguments] ')' &amp;t_lookahead 
    | atom &amp;t_lookahead 
t_lookahead: '(' | '[' | '.'</code></pre><h1 id="分发与安装-Python-模块"><a href="#分发与安装-Python-模块" class="headerlink" title="分发与安装 Python 模块"></a>分发与安装 Python 模块</h1><h2 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h2><p>作为一个流行的开源开发项目，Python拥有一个活跃的贡献者和用户支持社区，这些社区也可以让他们的软件可供其他Python开发人员在开源许可条款下使用。</p>
<p>这允许Python用户有效地共享和协作，从其他人已经创建的解决方案中受益于常见（有时甚至是罕见的）问题，以及可以提供他们自己的解决方案。</p>
<h3 id="关键术语"><a href="#关键术语" class="headerlink" title="关键术语"></a>关键术语</h3><ul>
<li>the Python Package Index is a public repository of open source licensed packages made available for use by other Python users</li>
<li>Python Packaging Authority 是负责标准打包工具以及相关元数据和文件格式标准维护与改进的开发人员和文档作者团队。 他们基于 <a href="https://github.com/pypa" target="_blank" rel="noopener">GitHub</a> 和 <a href="https://bitbucket.org/pypa/" target="_blank" rel="noopener">Bitbucket</a> 这两个平台维护着各种工具、文档和问题追踪系统。</li>
<li><code>distutils</code> 是 1998 年首次添加到 Python 标准库的原始构建和分发系统。 虽然直接使用 <code>distutils</code> 正在逐步淘汰，但它仍然为当前的打包和分发基础架构奠定了基础它不仅仍然是标准库的一部分，而且它的名称还以其他方式存在（例如用于协调 Python 打包标准开发的邮件列表的名称）。</li>
<li><a href="https://setuptools.readthedocs.io/en/latest/" target="_blank" rel="noopener">setuptools</a> （在很大程度上）是作为 <code>distutils</code> 的取代者，于 2004 年首次发布。 它对未经修改的 <code>distutils</code> 工具最重要的补充是能够声明对其他包的依赖。 目前它被推荐用来替代 <code>distutils</code>，其更新更为频繁，在更为多样的 Python 版本之上为最新的打包标准提供持续支持。</li>
<li><a href="https://wheel.readthedocs.io/" target="_blank" rel="noopener">wheel</a> （在此上下文中）是一个将 <code>bdist_wheel</code> 命令添加到 <code>distutils</code>/setuptools 的项目。这产生了一个跨平台的二进制打包格式（称为“轮子”或“轮子文件”，并在 <a href="https://www.python.org/dev/peps/pep-0427" target="_blank" rel="noopener"><strong>PEP 427</strong></a> 中定义），它允许在系统上安装Python库，甚至包括二进制扩展的库，而不需在本地进行构建。</li>
</ul>
<h3 id="开源许可与协作"><a href="#开源许可与协作" class="headerlink" title="开源许可与协作"></a>开源许可与协作</h3><p>在世界上大多数地方，软件自动受版权保护。这意味着其他开发人员需要明确的权限来复制，使用，修改和重新分发软件。</p>
<p>开源许可是一种以相对一致的方式明确授予此类权限的方式，允许开发人员通过为各种问题免费提供通用解决方案来有效地共享和协作。这使得许多开发人员可以将更多时间用于关注他们特定情况相对独特的问题。</p>
<p>Python提供的分发工具旨在使开发人员选择开源时，可以合理地直接将其自己的贡献回馈到该公共软件池。</p>
<p>无论该软件是否作为开源软件发布，相同的分发工具也可用于在组织内分发软件。</p>
<h3 id="安装相关工具"><a href="#安装相关工具" class="headerlink" title="安装相关工具"></a>安装相关工具</h3><p>标准库不包括支持现代Python打包标准的构建工具，因为核心开发团队已经发现，即使在旧版本的Python上，使用一致工作的标准工具也很重要。</p>
<p>可以通过在命令行调用 <code>pip</code> 模块来安装当前推荐的构建和分发工具:</p>
<pre><code>python -m pip install setuptools wheel twine</code></pre><p>注解</p>
<p>For POSIX users (including macOS and Linux users), these instructions assume the use of a virtual environment.</p>
<p>对于Windows用户，这些说明假定在安装Python时选择了调整系统PATH环境变量的选项。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>作为一个流行的开源开发项目，Python拥有一个活跃的贡献者和用户支持社区，这些社区也可以让他们的软件可供其他Python开发人员在开源许可条款下使用。</p>
<p>这允许Python用户有效地共享和协作，从其他人已经创建的解决方案中受益于常见（有时甚至是罕见的）问题，以及可以提供他们自己的解决方案。</p>
<h3 id="关键术语-1"><a href="#关键术语-1" class="headerlink" title="关键术语"></a>关键术语</h3><ul>
<li><code>pip</code> 是首选的安装程序。从Python 3.4开始，它默认包含在Python二进制安装程序中。</li>
<li><em>virtual environment</em> 是一种半隔离的 Python 环境，允许为特定的应用安装各自的包，而不是安装到整个系统。</li>
<li><code>venv</code> 是创建虚拟环境的标准工具，从 Python 3.3 开始成为 Python 的组成部分。 从 Python 3.4 开始，它会默认安装 <code>pip</code> 到所创建的全部虚拟环境。</li>
<li><code>virtualenv</code> 是 <code>venv</code> 的第三方替代（及其前身）。 它允许在 Python 3.4 之前的版本中使用虚拟环境，那些版本或是完全不提供 <code>venv</code>，或是不会自动安装 <code>pip</code> 到所创建的虚拟环境。</li>
<li>The Python Package Index is a public repository of open source licensed packages made available for use by other Python users.</li>
<li>Python Packaging Authority 是负责标准打包工具以及相关元数据和文件格式标准维护与改进的开发人员和文档作者团队。 他们基于 <a href="https://github.com/pypa" target="_blank" rel="noopener">GitHub</a> 和 <a href="https://bitbucket.org/pypa/" target="_blank" rel="noopener">Bitbucket</a> 这两个平台维护着各种工具、文档和问题追踪系统。</li>
<li><code>distutils</code> 是最初的构建和分发系统，于 1998 年首次加入 Python 标准库。 虽然直接使用 <code>distutils</code> 的方式已被淘汰，它仍然是当前打包和分发架构的基础，而且它不仅仍然是标准库的一部分，这个名称还以其他方式存在（例如用于协调 Python 打包标准开发流程的邮件列表就以此命名）。</li>
</ul>
<p>在 3.5 版更改: 现在推荐使用 <code>venv</code> 来创建虚拟环境。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>标准打包工具完全是针对命令行使用方式来设计的。</p>
<p>The following command will install the latest version of a module and its dependencies from the Python Package Index:</p>
<pre><code>python -m pip install SomePackage</code></pre><p>注解</p>
<p>For POSIX users (including macOS and Linux users), the examples in this guide assume the use of a virtual environment.</p>
<p>对于 Windows 用户，本指南中的示例假定在安装 Python 时选择了修改系统 PATH 环境变量。</p>
<p>在命令行中指定一个准确或最小版本也是可以的。 当使用比较运算符例如 <code>&gt;</code>, <code>&lt;</code> 或其他某些可以被终端所解析的特殊字符时，包名称与版本号应当用双引号括起来:</p>
<pre><code>python -m pip install SomePackage==1.0.4    # specific version
python -m pip install "SomePackage&gt;=1.0.4"  # minimum version</code></pre><p>通常，如果一个匹配的模块已安装，尝试再次安装将不会有任何效果。 要升级现有模块必须显式地发出请求:</p>
<pre><code>python -m pip install --upgrade SomePackage</code></pre><p>虚拟环境的创建可使用 <code>venv</code> 模块来完成。 向已激活虚拟环境安装软件包可使用上文所介绍的命令。</p>
<h3 id="我应如何-…？"><a href="#我应如何-…？" class="headerlink" title="我应如何 …？"></a>我应如何 …？</h3><p>这是一些常见任务的快速解答或相关链接。</p>
<h4 id="…-在-Python-3-4-之前的-Python-版本中安装-pip-？"><a href="#…-在-Python-3-4-之前的-Python-版本中安装-pip-？" class="headerlink" title="… 在 Python 3.4 之前的 Python 版本中安装 pip ？"></a>… 在 Python 3.4 之前的 Python 版本中安装 <code>pip</code> ？</h4><p>Python 捆绑 <code>pip</code> 是从 Python 3.4 才开始的。 对于更早的版本，<code>pip</code> 需要“引导安装”，具体说明参见 Python 软件包用户指南。</p>
<h4 id="…-只为当前用户安装软件包？"><a href="#…-只为当前用户安装软件包？" class="headerlink" title="… 只为当前用户安装软件包？"></a>… 只为当前用户安装软件包？</h4><p>将 <code>--user</code> 选项传入 <code>python -m pip install</code> 将只为当前用户而非为系统中的所有用户安装软件包。</p>
<h4 id="…-安装科学计算类-Python-软件包？"><a href="#…-安装科学计算类-Python-软件包？" class="headerlink" title="… 安装科学计算类 Python 软件包？"></a>… 安装科学计算类 Python 软件包？</h4><p>许多科学计算类 Python 软件包都有复杂的二进制编译文件依赖，直接使用 <code>pip</code> 安装目前并不太容易。 在当前情况下，通过 其他方式 而非尝试用 <code>pip</code> 安装这些软件包对用户来说通常会更容易。</p>
<h4 id="…-使用并行安装的多个-Python-版本？"><a href="#…-使用并行安装的多个-Python-版本？" class="headerlink" title="… 使用并行安装的多个 Python 版本？"></a>… 使用并行安装的多个 Python 版本？</h4><p>On Linux, macOS, and other POSIX systems, use the versioned Python commands in combination with the <code>-m</code> switch to run the appropriate copy of <code>pip</code>:</p>
<pre><code>python2   -m pip install SomePackage  # default Python 2
python2.7 -m pip install SomePackage  # specifically Python 2.7
python3   -m pip install SomePackage  # default Python 3
python3.4 -m pip install SomePackage  # specifically Python 3.4</code></pre><p>也可以使用带特定版本号的 <code>pip</code> 命令。</p>
<p>在 Windows 中，使用 <code>py</code> Python 启动器命令配合 <code>-m</code> 开关选项:</p>
<pre><code>py -2   -m pip install SomePackage  # default Python 2
py -2.7 -m pip install SomePackage  # specifically Python 2.7
py -3   -m pip install SomePackage  # default Python 3
py -3.4 -m pip install SomePackage  # specifically Python 3.4</code></pre><h3 id="常见的安装问题"><a href="#常见的安装问题" class="headerlink" title="常见的安装问题"></a>常见的安装问题</h3><h4 id="在-Linux-的系统-Python-版本上安装"><a href="#在-Linux-的系统-Python-版本上安装" class="headerlink" title="在 Linux 的系统 Python 版本上安装"></a>在 Linux 的系统 Python 版本上安装</h4><p>Linux 系统通常会将某个 Python 版本作为发行版的一部分包含在内。 将软件包安装到这个 Python 版本上需要系统 root 权限，并可能会干扰到系统包管理器和其他系统组件的运作，如果这些组件在使用 <code>pip</code> 时被意外升级的话。</p>
<p>在这样的系统上，通过 <code>pip</code> 安装软件包通常最好是使用虚拟环境或分用户安装。</p>
<h4 id="未安装-pip"><a href="#未安装-pip" class="headerlink" title="未安装 pip"></a>未安装 pip</h4><p>默认情况下可能未安装 <code>pip</code>，一种可选解决方案是:</p>
<pre><code>python -m ensurepip --default-pip</code></pre><p>还有其他资源可用来 <a href="https://packaging.python.org/tutorials/installing-packages/#install-pip-setuptools-and-wheel" target="_blank" rel="noopener">安装 pip</a></p>
<h4 id="安装二进制编译扩展"><a href="#安装二进制编译扩展" class="headerlink" title="安装二进制编译扩展"></a>安装二进制编译扩展</h4><p>Python 通常非常依赖基于源代码的发布方式，也就是期望最终用户在安装过程中使用源码来编译生成扩展模块。</p>
<p>With the introduction of support for the binary <code>wheel</code> format, and the ability to publish wheels for at least Windows and macOS through the Python Package Index, this problem is expected to diminish over time, as users are more regularly able to install pre-built extensions rather than needing to build them themselves.</p>
<p>某些用来安装 <a href="https://packaging.python.org/science/" target="_blank" rel="noopener">科学计算类软件包</a> 的解决方案对于尚未提供预编译 <code>wheel</code> 文件的那些扩展模块来说，也有助于用户在无需进行本机编译的情况下获取二进制码扩展模块。</p>
<h1 id="Python-标准库"><a href="#Python-标准库" class="headerlink" title="Python 标准库"></a>Python 标准库</h1><ul>
<li><a href="https://docs.python.org/zh-cn/3/library/index.html" target="_blank" rel="noopener">标准库</a></li>
</ul>
<h1 id="Python-C-API-参考手册"><a href="#Python-C-API-参考手册" class="headerlink" title="Python/C API 参考手册"></a>Python/C API 参考手册</h1><ul>
<li><a href="https://docs.python.org/zh-cn/3/c-api/index.html" target="_blank" rel="noopener">Python/C API</a></li>
</ul>
<h1 id="术语对照表"><a href="#术语对照表" class="headerlink" title="术语对照表"></a>术语对照表</h1><pre><code>&gt;&gt;&gt;</code></pre><p>交互式终端中默认的 Python 提示符。往往会显示于能以交互方式在解释器里执行的样例代码之前。</p>
<pre><code>...</code></pre><p>具有以下含义：</p>
<ul>
<li>交互式终端中输入特殊代码行时默认的 Python 提示符，包括：缩进的代码块，成对的分隔符之内（圆括号、方括号、花括号或三重引号），或是指定一个装饰器之后。</li>
<li><code>Ellipsis</code> 内置常量。</li>
</ul>
<p>2to3</p>
<p>把 Python 2.x 代码转换为 Python 3.x 代码的工具，通过解析源码，遍历解析树，处理绝大多数检测到的不兼容问题。</p>
<p>2to3 包含在标准库中，模块名为 <code>lib2to3</code>；提供了独立入口点 <code>Tools/scripts/2to3</code>。</p>
<p>abstract base class — 抽象基类</p>
<p>抽象基类简称 ABC，是对 duck-typing 的补充，它提供了一种定义接口的新方式，相比之下其他技巧例如 <code>hasattr()</code> 显得过于笨拙或有微妙错误（例如使用 魔术方法）。ABC 引入了虚拟子类，这种类并非继承自其他类，但却仍能被 <code>isinstance()</code> 和 <code>issubclass()</code> 所认可；详见 <code>abc</code> 模块文档。Python 自带许多内置的 ABC 用于实现数据结构（在 <code>collections.abc</code> 模块中）、数字（在 <code>numbers</code> 模块中）、流（在 <code>io</code> 模块中）、导入查找器和加载器（在 <code>importlib.abc</code> 模块中）。你可以使用 <code>abc</code> 模块来创建自己的 ABC。</p>
<p>annotation — 标注</p>
<p>关联到某个变量、类属性、函数形参或返回值的标签，被约定作为 type hint 来使用。</p>
<p>局部变量的标注在运行时不可访问，但全局变量、类属性和函数的标注会分别存放模块、类和函数的 <code>__annotations__</code> 特殊属性中。</p>
<p>参见 variable annotation, function annotation, <a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener"><strong>PEP 484</strong></a> 和 <a href="https://www.python.org/dev/peps/pep-0526" target="_blank" rel="noopener"><strong>PEP 526</strong></a>，对此功能均有介绍。 </p>
<p>argument — 参数</p>
<p>在调用函数时传给 function （或 method ）的值。参数分为两种：</p>
<ul>
<li><p><em>关键字参数</em>: 在函数调用中前面带有标识符（例如 <code>name=</code>）或者作为包含在前面带有 <code>**</code> 的字典里的值传入。举例来说，<code>3</code> 和 <code>5</code> 在以下对 <code>complex()</code> 的调用中均属于关键字参数:</p>
<pre class="line-numbers language-python"><code class="language-python">complex<span class="token punctuation">(</span>real<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> imag<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>
complex<span class="token punctuation">(</span><span class="token operator">**</span><span class="token punctuation">{</span><span class="token string">'real'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'imag'</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p><em>位置参数</em>: 不属于关键字参数的参数。位置参数可出现于参数列表的开头以及/或者作为前面带有 <code>*</code> 的 iterable 里的元素被传入。举例来说，<code>3</code> 和 <code>5</code> 在以下调用中均属于位置参数:</p>
<pre class="line-numbers language-python"><code class="language-python">complex<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
complex<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ul>
<p>参数会被赋值给函数体中对应的局部变量。根据语法，任何表达式都可用来表示一个参数；最终算出的值会被赋给对应的局部变量。</p>
<p>asynchronous context manager — 异步上下文管理器</p>
<p>此种对象通过定义 <code>__aenter__()</code> 和 <code>__aexit__()</code> 方法来对 <code>async with</code> 语句中的环境进行控制。由 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 引入。</p>
<p>asynchronous generator — 异步生成器</p>
<p>返回值为 asynchronous generator iterator 的函数。它与使用 <code>async def</code> 定义的协程函数很相似，不同之处在于它包含 <code>yield</code> 表达式以产生一系列可在 <code>async for</code> 循环中使用的值。</p>
<p>此术语通常是指异步生成器函数，但在某些情况下则可能是指 <em>异步生成器迭代器</em>。如果需要清楚表达具体含义，请使用全称以避免歧义。</p>
<p>一个异步生成器函数可能包含 <code>await</code> 表达式或者 <code>async for</code> 以及 <code>async with</code> 语句。</p>
<p>asynchronous generator iterator — 异步生成器迭代器</p>
<p>asynchronous generator 函数所创建的对象。</p>
<p>此对象属于 asynchronous iterator，当使用 <code>__anext__()</code> 方法调用时会返回一个可等待对象来执行异步生成器函数的代码直到下一个 <code>yield</code> 表达式。</p>
<p>每个 <code>yield</code> 会临时暂停处理，记住当前位置执行状态 (包括局部变量和挂起的 try 语句)。当该 <em>异步生成器迭代器</em> 与其他 <code>__anext__()</code> 返回的可等待对象有效恢复时，它会从离开位置继续执行。参见 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 和 <a href="https://www.python.org/dev/peps/pep-0525" target="_blank" rel="noopener"><strong>PEP 525</strong></a>。</p>
<p>asynchronous iterable — 异步可迭代对象</p>
<p>可在 <code>async for</code> 语句中被使用的对象。必须通过它的 <code>__aiter__()</code> 方法返回一个 asynchronous iterator。由 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 引入。</p>
<p>asynchronous iterator — 异步迭代器</p>
<p>实现了 <code>__aiter__()</code> 和 <code>__anext__()</code> 方法的对象。<code>__anext__</code> 必须返回一个 awaitable 对象。<code>async for</code> 会处理异步迭代器的 <code>__anext__()</code> 方法所返回的可等待对象，直到其引发一个 <code>StopAsyncIteration</code> 异常。由 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 引入。</p>
<p>attribute — 属性</p>
<p>关联到一个对象的值，可以使用点号表达式通过其名称来引用。例如，如果一个对象 <em>o</em> 具有一个属性 <em>a</em>，就可以用 <em>o.a</em> 来引用它。</p>
<p>awaitable — 可等待对象</p>
<p>能在 <code>await</code> 表达式中使用的对象。可以是 coroutine 或是具有 <code>__await__()</code> 方法的对象。参见 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a>。</p>
<p>BDFL</p>
<p>“终身仁慈独裁者”的英文缩写，即 Guido van Rossum，Python 的创造者。</p>
<p>binary file — 二进制文件</p>
<p>file object 能够读写 字节类对象。二进制文件的例子包括以二进制模式（<code>'rb'</code>, <code>'wb'</code> or <code>'rb+'</code>）打开的文件、<code>sys.stdin.buffer</code>、<code>sys.stdout.buffer</code> 以及 <code>io.BytesIO</code> 和 <code>gzip.GzipFile</code> 的实例。</p>
<p>另请参见 text file 了解能够读写 <code>str</code> 对象的文件对象。</p>
<p>borrowed reference — 借入引用</p>
<p>在 Python 的 C API 中，借入引用是指一种对象引用。 它不会修改对象引用计数。 如果对象被销毁则它会成为一个无目标指针。 例如，垃圾回收器可以移除对象的最后一个 strong reference 来销毁它。</p>
<p>推荐在 borrowed reference 上调用 <code>Py_INCREF()</code> 以将其原地转换为 strong reference，除非是当该对象无法在借入引用的最后一次使用之前被销毁。 <code>Py_NewRef()</code> 函数可以被用来创建一个新的 strong reference。</p>
<p>bytes-like object — 字节类对象</p>
<p>支持 缓冲协议 并且能导出 C-contiguous 缓冲的对象。这包括所有 <code>bytes</code>、<code>bytearray</code> 和 <code>array.array</code> 对象，以及许多普通 <code>memoryview</code> 对象。字节类对象可在多种二进制数据操作中使用；这些操作包括压缩、保存为二进制文件以及通过套接字发送等。</p>
<p>某些操作需要可变的二进制数据。这种对象在文档中常被称为“可读写字节类对象”。可变缓冲对象的例子包括 <code>bytearray</code> 以及 <code>bytearray</code> 的 <code>memoryview</code>。其他操作要求二进制数据存放于不可变对象 (“只读字节类对象”)；这种对象的例子包括 <code>bytes</code> 以及 <code>bytes</code> 对象的 <code>memoryview</code>。</p>
<p>bytecode — 字节码</p>
<p>Python 源代码会被编译为字节码，即 CPython 解释器中表示 Python 程序的内部代码。字节码还会缓存在 <code>.pyc</code> 文件中，这样第二次执行同一文件时速度更快（可以免去将源码重新编译为字节码）。这种 “中间语言” 运行在根据字节码执行相应机器码的 virtual machine 之上。请注意不同 Python 虚拟机上的字节码不一定通用，也不一定能在不同 Python 版本上兼容。</p>
<p>callback — 回调</p>
<p>一个作为参数被传入以用以在未来的某个时刻被调用的子例程函数。</p>
<p>class — 类</p>
<p>用来创建用户定义对象的模板。类定义通常包含对该类的实例进行操作的方法定义。</p>
<p>class variable — 类变量</p>
<p>在类中定义的变量，并且仅限在类的层级上修改 (而不是在类的实例中修改)。</p>
<p>coercion — 强制类型转换</p>
<p>在包含两个相同类型参数的操作中，一种类型的实例隐式地转换为另一种类型。例如，<code>int(3.15)</code> 是将原浮点数转换为整型数 <code>3</code>，但在 <code>3+4.5</code> 中，参数的类型不一致（一个是 int, 一个是 float），两者必须转换为相同类型才能相加，否则将引发 <code>TypeError</code>。如果没有强制类型转换机制，程序员必须将所有可兼容参数归一化为相同类型，例如要写成 <code>float(3)+4.5</code> 而不是 <code>3+4.5</code>。</p>
<p>complex number — 复数</p>
<p>对普通实数系统的扩展，其中所有数字都被表示为一个实部和一个虚部的和。虚数是虚数单位（<code>-1</code> 的平方根）的实倍数，通常在数学中写为 <code>i</code>，在工程学中写为 <code>j</code>。Python 内置了对复数的支持，采用工程学标记方式；虚部带有一个 <code>j</code> 后缀，例如 <code>3+1j</code>。如果需要 <code>math</code> 模块内对象的对应复数版本，请使用 <code>cmath</code>，复数的使用是一个比较高级的数学特性。如果你感觉没有必要，忽略它们也几乎不会有任何问题。</p>
<p>context manager — 上下文管理器</p>
<p>在 <code>with</code> 语句中使用，通过定义 <code>__enter__()</code> 和 <code>__exit__()</code> 方法来控制环境状态的对象。参见 <a href="https://www.python.org/dev/peps/pep-0343" target="_blank" rel="noopener"><strong>PEP 343</strong></a>。</p>
<p>context variable — 上下文变量</p>
<p>一种根据其所属的上下文可以具有不同的值的变量。 这类似于在线程局部存储中每个执行线程可以具有不同的变量值。 不过，对于上下文变量来说，一个执行线程中可能会有多个上下文，而上下文变量的主要用途是对并发异步任务中变量进行追踪。 参见 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/bc3e5800946329f3.md#module-contextvars" target="_blank" rel="noopener"><code>contextvars</code></a>。</p>
<p>contiguous — 连续</p>
<p>一个缓冲如果是 <em>C 连续</em> 或 <em>Fortran 连续</em> 就会被认为是连续的。零维缓冲是 C 和 Fortran 连续的。在一维数组中，所有条目必须在内存中彼此相邻地排列，采用从零开始的递增索引顺序。在多维 C-连续数组中，当按内存地址排列时用最后一个索引访问条目时速度最快。但是在 Fortran 连续数组中则是用第一个索引最快。</p>
<p>coroutine — 协程</p>
<p>协程是子例程的更一般形式。 子例程可以在某一点进入并在另一点退出。 协程则可以在许多不同的点上进入、退出和恢复。 它们可通过 <code>async def</code> 语句来实现。 参见 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a>。</p>
<p>coroutine function — 协程函数</p>
<p>返回一个 coroutine 对象的函数。协程函数可通过 <code>async def</code> 语句来定义，并可能包含 <code>await</code>、<code>async for</code> 和 <code>async with</code> 关键字。这些特性是由 <a href="https://www.python.org/dev/peps/pep-0492" target="_blank" rel="noopener"><strong>PEP 492</strong></a> 引入的。</p>
<p>CPython</p>
<p>Python 编程语言的规范实现，在 <a href="https://www.python.org/" target="_blank" rel="noopener">python.org</a> 上发布。”CPython” 一词用于在必要时将此实现与其他实现例如 Jython 或 IronPython 相区别。</p>
<p>decorator — 装饰器</p>
<p>返回值为另一个函数的函数，通常使用 <code>@wrapper</code> 语法形式来进行函数变换。 装饰器的常见例子包括 <code>classmethod()</code> 和 <code>staticmethod()</code>。</p>
<p>装饰器语法只是一种语法糖，以下两个函数定义在语义上完全等价:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
f <span class="token operator">=</span> staticmethod<span class="token punctuation">(</span>f<span class="token punctuation">)</span>
@staticmethod
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同的样概念也适用于类，但通常较少这样使用。</p>
<p>descriptor — 描述器</p>
<p>任何定义了 <code>__get__()</code>, <code>__set__()</code> 或 <code>__delete__()</code> 方法的对象。当一个类属性为描述器时，它的特殊绑定行为就会在属性查找时被触发。通常情况下，使用 <em>a.b</em> 来获取、设置或删除一个属性时会在 <em>a</em> 的类字典中查找名称为 <em>b</em> 的对象，但如果 <em>b</em> 是一个描述器，则会调用对应的描述器方法。理解描述器的概念是更深层次理解 Python 的关键，因为这是许多重要特性的基础，包括函数、方法、属性、类方法、静态方法以及对超类的引用等等。</p>
<p>dictionary — 字典</p>
<p>一个关联数组，其中的任意键都映射到相应的值。键可以是任何具有 <code>__hash__()</code> 和 <code>__eq__()</code> 方法的对象。在 Perl 语言中称为 hash。</p>
<p>dictionary comprehension — 字典推导式</p>
<p>处理一个可迭代对象中的所有或部分元素并返回结果字典的一种紧凑写法。 <code>results = {n: n ** 2 for n in range(10)}</code> 将生成一个由键 <code>n</code> 到值 <code>n ** 2</code> 的映射构成的字典。</p>
<p>从 <code>dict.keys()</code>, <code>dict.values()</code> 和 <code>dict.items()</code> 返回的对象被称为字典视图。它们提供了字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。要将字典视图强制转换为真正的列表，可使用 <code>list(dictview)</code>。</p>
<p>docstring — 文档字符串</p>
<p>作为类、函数或模块之内的第一个表达式出现的字符串字面值。它在代码执行时会被忽略，但会被解释器识别并放入所在类、函数或模块的 <code>__doc__</code> 属性中。由于它可用于代码内省，因此是对象存放文档的规范位置。</p>
<p>duck-typing — 鸭子类型</p>
<p>指一种编程风格，它并不依靠查找对象类型来确定其是否具有正确的接口，而是直接调用或使用其方法或属性（“看起来像鸭子，叫起来也像鸭子，那么肯定就是鸭子。”）由于强调接口而非特定类型，设计良好的代码可通过允许多态替代来提升灵活性。鸭子类型避免使用 <code>type()</code> 或 <code>isinstance()</code> 检测。(但要注意鸭子类型可以使用 抽象基类 作为补充。) 而往往会采用 <code>hasattr()</code> 检测或是 EAFP 编程。</p>
<p>EAFP</p>
<p>“求原谅比求许可更容易”的英文缩写。这种 Python 常用代码编写风格会假定所需的键或属性存在，并在假定错误时捕获异常。这种简洁快速风格的特点就是大量运用 <code>try</code> 和 <code>except</code> 语句。于其相对的则是所谓 LBYL 风格，常见于 C 等许多其他语言。</p>
<p>expression — 表达式</p>
<p>可以求出某个值的语法单元。 换句话说，一个表达式就是表达元素例如字面值、名称、属性访问、运算符或函数调用的汇总，它们最终都会返回一个值。 与许多其他语言不同，并非所有语言构件都是表达式。 还存在不能被用作表达式的 statement，例如 <code>while</code>。 赋值也是属于语句而非表达式。</p>
<p>extension module — 扩展模块</p>
<p>以 C 或 C++ 编写的模块，使用 Python 的 C API 来与语言核心以及用户代码进行交互。</p>
<p>f-string — f-字符串</p>
<p>带有 <code>'f'</code> 或 <code>'F'</code> 前缀的字符串字面值通常被称为“f-字符串”即 格式化字符串字面值 的简写。参见 <a href="https://www.python.org/dev/peps/pep-0498" target="_blank" rel="noopener"><strong>PEP 498</strong></a>。</p>
<p>file object — 文件对象</p>
<p>对外提供面向文件 API 以使用下层资源的对象（带有 <code>read()</code> 或 <code>write()</code> 这样的方法）。根据其创建方式的不同，文件对象可以处理对真实磁盘文件，对其他类型存储，或是对通讯设备的访问（例如标准输入/输出、内存缓冲区、套接字、管道等等）。文件对象也被称为 <em>文件类对象</em> 或 <em>流</em>。</p>
<p>实际上共有三种类别的文件对象: 原始 二进制文件, 缓冲 二进制文件 以及 文本文件。它们的接口定义均在 <code>io</code> 模块中。创建文件对象的规范方式是使用 <code>open()</code> 函数。</p>
<p>file-like object — 文件类对象</p>
<p>file object 的同义词。</p>
<p>filesystem encoding and error handler — 文件系统编码格式与错误处理句柄</p>
<p>Python 用来从操作系统解码字节串和向操作系统编码 Unicode 的编码格式与错误处理句柄。</p>
<p>文件系统编码格式必须保证能成功解码长度在 128 以下的所有字节串。 如果文件系统编码格式无法提供此保证，则 API 函数可能会引发 <code>UnicodeError</code>。</p>
<p><code>sys.getfilesystemencoding()</code> 和 <code>sys.getfilesystemencodeerrors()</code> 函数可被用来获取文件系统编码格式与错误处理句柄。</p>
<p>filesystem encoding and error handler 是在 Python 启动时通过 <code>PyConfig_Read()</code> 函数来配置的</p>
<p>finder — 查找器</p>
<p>一种会尝试查找被导入模块的 loader 的对象。</p>
<p>从 Python 3.3 起存在两种类型的查找器: 元路径查找器 配合 <code>sys.meta_path</code> 使用，以及 path entry finders 配合 <code>sys.path_hooks</code> 使用。</p>
<p>更多详情可参见 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a>, <a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a> 和 <a href="https://www.python.org/dev/peps/pep-0451" target="_blank" rel="noopener"><strong>PEP 451</strong></a>。</p>
<p>floor division — 向下取整除法</p>
<p>向下舍入到最接近的整数的数学除法。向下取整除法的运算符是 <code>//</code> 。例如，表达式 <code>11 // 4</code> 的计算结果是 <code>2</code> ，而与之相反的是浮点数的真正除法返回 <code>2.75</code> 。注意 <code>(-11) // 4</code> 会返回 <code>-3</code> 因为这是 <code>-2.75</code> <em>向下</em> 舍入得到的结果。见 <a href="https://www.python.org/dev/peps/pep-0238" target="_blank" rel="noopener"><strong>PEP 238</strong></a> 。</p>
<p>function — 函数</p>
<p>可以向调用者返回某个值的一组语句。还可以向其传入零个或多个 参数 并在函数体执行中被使用。</p>
<p>即针对函数形参或返回值的 annotation 。</p>
<p>函数标注通常用于 类型提示：例如以下函数预期接受两个 <code>int</code> 参数并预期返回一个 <code>int</code> 值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sum_two_numbers</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> int<span class="token punctuation">,</span> b<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>
   <span class="token keyword">return</span> a <span class="token operator">+</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener"><strong>PEP 484</strong></a>描述了此功能。</p>
<p><strong>future</strong></p>
<p>future 语句, <code>from __future__ import &lt;feature&gt;</code> 指示编译器使用将在未来的 Python 发布版中成为标准的语法和语义来编译当前模块。 <code>__future__</code> 模块文档记录了可能 的 <em>feature</em> 取值。 通过导入此模块并对其变量求值，你可以看到每项新特性在何时被首次加入到该语言中以及它将（或已）在何时成为默认:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> __future__
<span class="token operator">>></span><span class="token operator">></span> __future__<span class="token punctuation">.</span>division
_Feature<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'alpha'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'alpha'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">8192</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>garbage collection — 垃圾回收</p>
<p>释放不再被使用的内存空间的过程。Python 是通过引用计数和一个能够检测和打破循环引用的循环垃圾回收器来执行垃圾回收的。可以使用 <code>gc</code> 模块来控制垃圾回收器。</p>
<p>generator — 生成器</p>
<p>返回一个 generator iterator 的函数。它看起来很像普通函数，不同点在于其包含 <code>yield</code> 表达式以便产生一系列值供给 for-循环使用或是通过 <code>next()</code> 函数逐一获取。</p>
<p>通常是指生成器函数，但在某些情况下也可能是指 <em>生成器迭代器</em>。如果需要清楚表达具体含义，请使用全称以避免歧义。</p>
<p>generator iterator — 生成器迭代器</p>
<p>generator 函数所创建的对象。</p>
<p>每个 <code>yield</code> 会临时暂停处理，记住当前位置执行状态（包括局部变量和挂起的 try 语句）。当该 <em>生成器迭代器</em> 恢复时，它会从离开位置继续执行（这与每次调用都从新开始的普通函数差别很大）。</p>
<p>generator expression — 生成器表达式</p>
<p>返回一个迭代器的表达式。 它看起来很像普通表达式后面带有定义了一个循环变量、范围的 <code>for</code> 子句，以及一个可选的 <code>if</code> 子句。 以下复合表达式会为外层函数生成一系列值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sum<span class="token punctuation">(</span>i<span class="token operator">*</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true"># sum of squares 0, 1, 4, ... 81</span>
<span class="token number">285</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>generic function — 泛型函数</p>
<p>为不同的类型实现相同操作的多个函数所组成的函数。在调用时会由调度算法来确定应该使用哪个实现。</p>
<p>generic type — 泛型类型</p>
<p>可以被形参化的 type；通常为容器类型例如 <code>list</code>。 可用于 类型提示 和 标注。</p>
<p>请参阅 <a href="https://www.python.org/dev/peps/pep-0483" target="_blank" rel="noopener"><strong>PEP 483</strong></a> 来了解详情。</p>
<p>GIL</p>
<p>参见 global interpreter lock。</p>
<p>global interpreter lock — 全局解释器锁</p>
<p>CPython 解释器所采用的一种机制，它确保同一时刻只有一个线程在执行 Python bytecode。此机制通过设置对象模型（包括 <code>dict</code> 等重要内置类型）针对并发访问的隐式安全简化了 CPython 实现。给整个解释器加锁使得解释器多线程运行更方便，其代价则是牺牲了在多处理器上的并行性。</p>
<p>不过，某些标准库或第三方库的扩展模块被设计为在执行计算密集型任务如压缩或哈希时释放 GIL。此外，在执行 I/O 操作时也总是会释放 GIL。</p>
<p>创建一个（以更精细粒度来锁定共享数据的）“自由线程”解释器的努力从未获得成功，因为这会牺牲在普通单处理器情况下的性能。据信克服这种性能问题的措施将导致实现变得更复杂，从而更难以维护。</p>
<p>hash-based pyc — 基于哈希的 pyc</p>
<p>使用对应源文件的哈希值而非最后修改时间来确定其有效性的字节码缓存文件。</p>
<p>hashable — 可哈希</p>
<p>一个对象的哈希值如果在其生命周期内绝不改变，就被称为 <em>可哈希</em> （它需要具有 <code>__hash__()</code> 方法），并可以同其他对象进行比较（它需要具有 <code>__eq__()</code> 方法）。可哈希对象必须具有相同的哈希值比较结果才会相同。</p>
<p>可哈希性使得对象能够作为字典键或集合成员使用，因为这些数据结构要在内部使用哈希值。</p>
<p>大多数 Python 中的不可变内置对象都是可哈希的；可变容器（例如列表或字典）都不可哈希；不可变容器（例如元组和 frozenset）仅当它们的元素均为可哈希时才是可哈希的。 用户定义类的实例对象默认是可哈希的。 它们在比较时一定不相同（除非是与自己比较），它们的哈希值的生成是基于它们的 <code>id()</code>。</p>
<p>IDLE</p>
<p>Python 的 IDE，“集成开发与学习环境”的英文缩写。是 Python 标准发行版附带的基本编辑器和解释器环境。</p>
<p>immutable — 不可变</p>
<p>具有固定值的对象。不可变对象包括数字、字符串和元组。这样的对象不能被改变。如果必须存储一个不同的值，则必须创建新的对象。它们在需要常量哈希值的地方起着重要作用，例如作为字典中的键。</p>
<p>import path — 导入路径</p>
<p>由多个位置（或 路径条目）组成的列表，会被模块的 path based finder 用来查找导入目标。在导入时，此位置列表通常来自 <code>sys.path</code>，但对次级包来说也可能来自上级包的 <code>__path__</code> 属性。</p>
<p>importing — 导入</p>
<p>令一个模块中的 Python 代码能为另一个模块中的 Python 代码所使用的过程。</p>
<p>importer — 导入器</p>
<p>查找并加载模块的对象；此对象既属于 finder 又属于 loader。</p>
<p>interactive — 交互</p>
<p>Python 带有一个交互式解释器，即你可以在解释器提示符后输入语句和表达式，立即执行并查看其结果。只需不带参数地启动 <code>python</code> 命令（也可以在你的计算机开始菜单中选择相应菜单项）。在测试新想法或检验模块和包的时候用这种方式会非常方便（请记得使用 <code>help(x)</code>）。</p>
<p>interpreted — 解释型</p>
<p>Python 一是种解释型语言，与之相对的是编译型语言，虽然两者的区别由于字节码编译器的存在而会有所模糊。这意味着源文件可以直接运行而不必显式地创建可执行文件再运行。解释型语言通常具有比编译型语言更短的开发/调试周期，但是其程序往往运行得更慢。参见 interactive。</p>
<p>interpreter shutdown — 解释器关闭</p>
<p>当被要求关闭时，Python 解释器将进入一个特殊运行阶段并逐步释放所有已分配资源，例如模块和各种关键内部结构等。它还会多次调用 垃圾回收器。这会触发用户定义析构器或弱引用回调中的代码执行。在关闭阶段执行的代码可能会遇到各种异常，因为其所依赖的资源已不再有效（常见的例子有库模块或警告机制等）。</p>
<p>解释器需要关闭的主要原因有 <code>__main__</code> 模块或所运行的脚本已完成执行。</p>
<p>iterable — 可迭代对象</p>
<p>能够逐一返回其成员项的对象。 可迭代对象的例子包括所有序列类型 (例如 <code>list</code>, <code>str</code> 和 <code>tuple</code>) 以及某些非序列类型例如 <code>dict</code>, 文件对象 以及定义了 <code>__iter__()</code> 方法或是实现了 序列 语义的 <code>__getitem__()</code> 方法的任意自定义类对象。</p>
<p>可迭代对象被可用于 <code>for</code> 循环以及许多其他需要一个序列的地方（<code>zip()</code>、<code>map()</code> …）。当一个可迭代对象作为参数传给内置函数 <code>iter()</code> 时，它会返回该对象的迭代器。这种迭代器适用于对值集合的一次性遍历。在使用可迭代对象时，你通常不需要调用 <code>iter()</code> 或者自己处理迭代器对象。<code>for</code> 语句会为你自动处理那些操作，创建一个临时的未命名变量用来在循环期间保存迭代器。</p>
<p>iterator — 迭代器</p>
<p>用来表示一连串数据流的对象。重复调用迭代器的 <code>__next__()</code> 方法（或将其传给内置函数 <code>next()</code>）将逐个返回流中的项。当没有数据可用时则将引发 <code>StopIteration</code> 异常。到这时迭代器对象中的数据项已耗尽，继续调用其 <code>__next__()</code> 方法只会再次引发 <code>StopIteration</code> 异常。迭代器必须具有 <code>__iter__()</code> 方法用来返回该迭代器对象自身，因此迭代器必定也是可迭代对象，可被用于其他可迭代对象适用的大部分场合。一个显著的例外是那些会多次重复访问迭代项的代码。容器对象（例如 <code>list</code>）在你每次向其传入 <code>iter()</code> 函数或是在 <code>for</code> 循环中使用它时都会产生一个新的迭代器。如果在此情况下你尝试用迭代器则会返回在之前迭代过程中被耗尽的同一迭代器对象，使其看起来就像是一个空容器。</p>
<p>key function — 键函数</p>
<p>键函数或称整理函数，是能够返回用于排序或排位的值的可调用对象。例如，<code>locale.strxfrm()</code> 可用于生成一个符合特定区域排序约定的排序键。</p>
<p>Python 中有许多工具都允许用键函数来控制元素的排位或分组方式。其中包括 <code>min()</code>, <code>max()</code>, <code>sorted()</code>, <code>list.sort()</code>, <code>heapq.merge()</code>, <code>heapq.nsmallest()</code>, <code>heapq.nlargest()</code> 以及 <code>itertools.groupby()</code>。</p>
<p>要创建一个键函数有多种方式。例如，<code>str.lower()</code> 方法可以用作忽略大小写排序的键函数。另外，键函数也可通过 <code>lambda</code> 表达式来创建，例如 <code>lambda r: (r[0], r[2])</code>。还有 <code>operator</code> 模块提供了三个键函数构造器：<code>attrgetter()</code>、<code>itemgetter()</code> 和 <code>methodcaller()</code>。</p>
<p>keyword argument — 关键字参数</p>
<p>参见 argument。</p>
<p>lambda</p>
<p>由一个单独 expression 构成的匿名内联函数，表达式会在调用时被求值。创建 lambda 函数的句法为 <code>lambda [parameters]: expression</code></p>
<p>LBYL</p>
<p>“先查看后跳跃”的英文缩写。这种代码编写风格会在进行调用或查找之前显式地检查前提条件。此风格与 EAFP 方式恰成对比，其特点是大量使用 <code>if</code> 语句。</p>
<p>在多线程环境中，LBYL 方式会导致“查看”和“跳跃”之间发生条件竞争风险。例如，以下代码 <code>if key in mapping: return mapping[key]</code> 可能由于在检查操作之后其他线程从 <em>mapping</em> 中移除了 <em>key</em> 而出错。这种问题可通过加锁或使用 EAFP 方式来解决。</p>
<p>locale encoding — 语言区域编码格式</p>
<p>在 Unix 上，它是 LC_CTYPE 语言区域的编码格式。 它可以通过 <code>locale.setlocale(locale.LC_CTYPE, new_locale)</code> 来设置。</p>
<p>在 Windows 上，它是 ANSI 代码页 (例如: <code>cp1252</code>)。</p>
<p><code>locale.getpreferredencoding(False)</code> 可被用来获取语言区域编码格式。</p>
<p>Python 使用 filesystem encoding and error handler 在 Unicode 文件名和字节串文件名之间进行转换。</p>
<p>list — 列表</p>
<p>Python 内置的一种 sequence。虽然名为列表，但更类似于其他语言中的数组而非链接列表，因为访问元素的时间复杂度为 O(1)。</p>
<p>list comprehension — 列表推导式</p>
<p>处理一个序列中的所有或部分元素并返回结果列表的一种紧凑写法。<code>result = ['{:#04x}'.format(x) for x in range(256) if x % 2 == 0]</code> 将生成一个 0 到 255 范围内的十六进制偶数对应字符串（0x..）的列表。其中 <code>if</code> 子句是可选的，如果省略则 <code>range(256)</code> 中的所有元素都会被处理。</p>
<p>loader — 加载器</p>
<p>负责加载模块的对象。它必须定义名为 <code>load_module()</code> 的方法。加载器通常由一个 finder 返回。详情参见 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a>，对于 abstract base class 可参见 <code>importlib.abc.Loader</code>。</p>
<p>magic method — 魔术方法</p>
<p>special method 的非正式同义词 。</p>
<p>mapping — 映射</p>
<p>一种支持任意键查找并实现了 <code>Mapping</code> 或 <code>MutableMapping</code> 抽象基类 中所规定方法的容器对象。 此类对象的例子包括 <code>dict</code>, <code>collections.defaultdict</code>, <code>collections.OrderedDict</code> 以及 <code>collections.Counter</code>。</p>
<p>meta path finder — 元路径查找器</p>
<p><code>sys.meta_path</code> 的搜索所返回的 finder。元路径查找器与 path entry finders 存在关联但并不相同。</p>
<p>metaclass — 元类</p>
<p>一种用于创建类的类。类定义包含类名、类字典和基类列表。元类负责接受上述三个参数并创建相应的类。大部分面向对象的编程语言都会提供一个默认实现。Python 的特别之处在于可以创建自定义元类。大部分用户永远不需要这个工具，但当需要出现时，元类可提供强大而优雅的解决方案。它们已被用于记录属性访问日志、添加线程安全性、跟踪对象创建、实现单例，以及其他许多任务。</p>
<p>method — 方法</p>
<p>在类内部定义的函数。如果作为该类的实例的一个属性来调用，方法将会获取实例对象作为其第一个 argument (通常命名为 <code>self</code>)。</p>
<p>method resolution order — 方法解析顺序</p>
<p>方法解析顺序就是在查找成员时搜索全部基类所用的先后顺序。</p>
<p>module — 模块</p>
<p>此对象是 Python 代码的一种组织单位。各模块具有独立的命名空间，可包含任意 Python 对象。模块可通过 importing 操作被加载到 Python 中。</p>
<p>module spec — 模块规格</p>
<p>一个命名空间，其中包含用于加载模块的相关导入信息。是 <code>importlib.machinery.ModuleSpec</code> 的实例。</p>
<p>MRO</p>
<p>参见 method resolution order。</p>
<p>mutable — 可变</p>
<p>可变对象可以在其 <code>id()</code> 保持固定的情况下改变其取值。</p>
<p>named tuple — 具名元组</p>
<p>术语“具名元组”可用于任何继承自元组，并且其中的可索引元素还能使用名称属性来访问的类型或类。 这样的类型或类还可能拥有其他特性。</p>
<p>有些内置类型属于具名元组，包括 <code>time.localtime()</code> 和 <code>os.stat()</code> 的返回值。 另一个例子是 <code>sys.float_info</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>float_info<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>                   <span class="token comment" spellcheck="true"># indexed access</span>
<span class="token number">1024</span>
<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>float_info<span class="token punctuation">.</span>max_exp              <span class="token comment" spellcheck="true"># named field access</span>
<span class="token number">1024</span>
<span class="token operator">>></span><span class="token operator">></span> isinstance<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>float_info<span class="token punctuation">,</span> tuple<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># kind of tuple</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有些具名元组是内置类型（例如上面的例子）。 此外，具名元组还可通过常规类定义从 <code>tuple</code> 继承并定义名称字段的方式来创建。 这样的类可以手工编写，或者使用工厂函数 <code>collections.namedtuple()</code> 创建。 后一种方式还会添加一些手工编写或内置具名元组所没有的额外方法。</p>
<p>namespace — 命名空间</p>
<p>命名空间是存放变量的场所。命名空间有局部、全局和内置的，还有对象中的嵌套命名空间（在方法之内）。命名空间通过防止命名冲突来支持模块化。例如，函数 <code>builtins.open</code> 与 <code>os.open()</code> 可通过各自的命名空间来区分。命名空间还通过明确哪个模块实现那个函数来帮助提高可读性和可维护性。例如，<code>random.seed()</code> 或 <code>itertools.islice()</code> 这种写法明确了这些函数是由 <code>random</code> 与 <code>itertools</code> 模块分别实现的。</p>
<p>namespace package — 命名空间包</p>
<p><a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a> 所引入的一种仅被用作子包的容器的 package，命名空间包可以没有实体表示物，其描述方式与 regular package 不同，因为它们没有 <code>__init__.py</code> 文件。</p>
<p>nested scope — 嵌套作用域</p>
<p>在一个定义范围内引用变量的能力。例如，在另一函数之内定义的函数可以引用前者的变量。请注意嵌套作用域默认只对引用有效而对赋值无效。局部变量的读写都受限于最内层作用域。类似的，全局变量的读写则作用于全局命名空间。通过 <code>nonlocal</code> 关键字可允许写入外层作用域。</p>
<p>new-style class — 新式类</p>
<p>对于目前已被应于所有类对象的类形式的旧称谓。在早先的 Python 版本中，只有新式类能够使用 Python 新增的更灵活特性，例如 <code>__slots__</code>、描述符、特征属性、<code>__getattribute__()</code>、类方法和静态方法等。</p>
<p>object — 对象</p>
<p>任何具有状态（属性或值）以及预定义行为（方法）的数据。object 也是任何 new-style class 的最顶层基类名。</p>
<p>package — 包</p>
<p>一种可包含子模块或递归地包含子包的 Python module。从技术上说，包是带有 <code>__path__</code> 属性的 Python 模块。</p>
<p>parameter — 形参</p>
<p>function （或方法）定义中的命名实体，它指定函数可以接受的一个 argument （或在某些情况下，多个实参）。有五种形参：</p>
<ul>
<li><p><em>positional-or-keyword*：位置或关键字，指定一个可以作为 位置参数 传入也可以作为 关键字参数 传入的实参。这是默认的形参类型，例如下面的 *foo</em> 和 <em>bar</em>:</p>
<pre><code>def func(foo, bar=None): ...</code></pre></li>
<li><p><em>positional-only*：仅限位置，指定一个只能通过位置传入的参数。 仅限位置形参可通过在函数定义的形参列表中它们之后包含一个 <code>/</code> 字符来定义，例如下面的 *posonly1</em> 和 <em>posonly2</em>:</p>
<pre><code>def func(posonly1, posonly2, /, positional_or_keyword): ...</code></pre></li>
<li><p><em>keyword-only<em>：仅限关键字，指定一个只能通过关键字传入的参数。仅限关键字形参可通过在函数定义的形参列表中包含单个可变位置形参或者在多个可变位置形参之前放一个 `</em>` 来定义，例如下面的 *kw_only1</em> 和 <em>kw_only2</em>:</p>
<pre><code>def func(arg, *, kw_only1, kw_only2): ...</code></pre></li>
<li><p><em>var-positional<em>：可变位置，指定可以提供由一个任意数量的位置参数构成的序列（附加在其他形参已接受的位置参数之后）。这种形参可通过在形参名称前加缀 `</em>` 来定义，例如下面的 *args</em>:</p>
<pre><code>def func(*args, **kwargs): ...</code></pre></li>
<li><p><em>var-keyword</em>：可变关键字，指定可以提供任意数量的关键字参数（附加在其他形参已接受的关键字参数之后）。这种形参可通过在形参名称前加缀 <code>**</code> 来定义，例如上面的 <em>kwargs</em>。</p>
</li>
</ul>
<p>形参可以同时指定可选和必选参数，也可以为某些可选参数指定默认值。</p>
<p>path entry — 路径入口</p>
<p>import path 中的一个单独位置，会被 path based finder 用来查找要导入的模块。</p>
<p>path entry finder — 路径入口查找器</p>
<p>任一可调用对象使用 <code>sys.path_hooks</code> (即 path entry hook) 返回的 finder，此种对象能通过 path entry 来定位模块。</p>
<p>path entry hook — 路径入口钩子</p>
<p>一种可调用对象，在知道如何查找特定 path entry 中的模块的情况下能够使用 <code>sys.path_hook</code> 列表返回一个 path entry finder。</p>
<p>path based finder — 基于路径的查找器</p>
<p>默认的一种 元路径查找器，可在一个 import path 中查找模块。</p>
<p>path-like object — 路径类对象</p>
<p>代表一个文件系统路径的对象。类路径对象可以是一个表示路径的 <code>str</code> 或者 <code>bytes</code> 对象，还可以是一个实现了 <code>os.PathLike</code> 协议的对象。一个支持 <code>os.PathLike</code> 协议的对象可通过调用 <code>os.fspath()</code> 函数转换为 <code>str</code> 或者 <code>bytes</code> 类型的文件系统路径；<code>os.fsdecode()</code> 和 <code>os.fsencode()</code> 可被分别用来确保获得 <code>str</code> 或 <code>bytes</code> 类型的结果。此对象是由 <a href="https://www.python.org/dev/peps/pep-0519" target="_blank" rel="noopener"><strong>PEP 519</strong></a> 引入的。</p>
<p>PEP</p>
<p>“Python 增强提议”的英文缩写。一个 PEP 就是一份设计文档，用来向 Python 社区提供信息，或描述一个 Python 的新增特性及其进度或环境。PEP 应当提供精确的技术规格和所提议特性的原理说明。</p>
<p>PEP 应被作为提出主要新特性建议、收集社区对特定问题反馈以及为必须加入 Python 的设计决策编写文档的首选机制。PEP 的作者有责任在社区内部建立共识，并应将不同意见也记入文档。</p>
<p>参见 <a href="https://www.python.org/dev/peps/pep-0001" target="_blank" rel="noopener"><strong>PEP 1</strong></a>。</p>
<p>portion — 部分</p>
<p>构成一个命名空间包的单个目录内文件集合（也可能存放于一个 zip 文件内），具体定义见 <a href="https://www.python.org/dev/peps/pep-0420" target="_blank" rel="noopener"><strong>PEP 420</strong></a>。</p>
<p>positional argument — 位置参数</p>
<p>参见 argument。</p>
<p>provisional API — 暂定 API</p>
<p>暂定 API 是指被有意排除在标准库的向后兼容性保证之外的应用编程接口。虽然此类接口通常不会再有重大改变，但只要其被标记为暂定，就可能在核心开发者确定有必要的情况下进行向后不兼容的更改（甚至包括移除该接口）。此种更改并不会随意进行 — 仅在 API 被加入之前未考虑到的严重基础性缺陷被发现时才可能会这样做。</p>
<p>即便是对暂定 API 来说，向后不兼容的更改也会被视为“最后的解决方案” —— 任何问题被确认时都会尽可能先尝试找到一种向后兼容的解决方案。</p>
<p>这种处理过程允许标准库持续不断地演进，不至于被有问题的长期性设计缺陷所困。详情见 <a href="https://www.python.org/dev/peps/pep-0411" target="_blank" rel="noopener"><strong>PEP 411</strong></a>。</p>
<p>provisional package — 暂定包</p>
<p>参见 provisional API。</p>
<p>Python 3000</p>
<p>Python 3.x 发布路线的昵称（这个名字在版本 3 的发布还遥遥无期的时候就已出现了）。有时也被缩写为“Py3k”。</p>
<p>Pythonic</p>
<p>指一个思路或一段代码紧密遵循了 Python 语言最常用的风格和理念，而不是使用其他语言中通用的概念来实现代码。例如，Python 的常用风格是使用 <code>for</code> 语句循环来遍历一个可迭代对象中的所有元素。许多其他语言没有这样的结构，因此不熟悉 Python 的人有时会选择使用一个数字计数器:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>food<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>food<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>而相应的更简洁更 Pythonic 的方法是这样的:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">for</span> piece <span class="token keyword">in</span> food<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>piece<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>qualified name — 限定名称</p>
<p>一个以点号分隔的名称，显示从模块的全局作用域到该模块中定义的某个类、函数或方法的“路径”，相关定义见 <a href="https://www.python.org/dev/peps/pep-3155" target="_blank" rel="noopener"><strong>PEP 3155</strong></a>。对于最高层级的函数和类，限定名称与对象名称一致:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">def</span> <span class="token function">meth</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>             <span class="token keyword">pass</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> C<span class="token punctuation">.</span>__qualname__
<span class="token string">'C'</span>
<span class="token operator">>></span><span class="token operator">></span> C<span class="token punctuation">.</span>D<span class="token punctuation">.</span>__qualname__
<span class="token string">'C.D'</span>
<span class="token operator">>></span><span class="token operator">></span> C<span class="token punctuation">.</span>D<span class="token punctuation">.</span>meth<span class="token punctuation">.</span>__qualname__
<span class="token string">'C.D.meth'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当被用于引用模块时，<em>完整限定名称</em> 意为标示该模块的以点号分隔的整个路径，其中包含其所有的父包，例如 <code>email.mime.text</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> email<span class="token punctuation">.</span>mime<span class="token punctuation">.</span>text
<span class="token operator">>></span><span class="token operator">></span> email<span class="token punctuation">.</span>mime<span class="token punctuation">.</span>text<span class="token punctuation">.</span>__name__
<span class="token string">'email.mime.text'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>reference count — 引用计数</p>
<p>对特定对象的引用的数量。当一个对象的引用计数降为零时，所分配资源将被释放。引用计数对 Python 代码来说通常是不可见的，但它是 CPython 实现的一个关键元素。<code>sys</code> 模块定义了一个 <code>getrefcount()</code> 函数，程序员可调用它来返回特定对象的引用计数。</p>
<p>regular package — 常规包</p>
<p>传统型的 package，例如包含有一个 <code>__init__.py</code> 文件的目录。</p>
<p><strong>slots</strong></p>
<p>一种写在类内部的声明，通过预先声明实例属性等对象并移除实例字典来节省内存。虽然这种技巧很流行，但想要用好却并不容易，最好是只保留在少数情况下采用，例如极耗内存的应用程序，并且其中包含大量实例。</p>
<p>sequence — 序列</p>
<p>一种 iterable，它支持通过 <code>__getitem__()</code> 特殊方法来使用整数索引进行高效的元素访问，并定义了一个返回序列长度的 <code>__len__()</code> 方法。内置的序列类型有 <code>list</code>、<code>str</code>、<code>tuple</code> 和 <code>bytes</code>。注意虽然 <code>dict</code> 也支持 <code>__getitem__()</code> 和 <code>__len__()</code>，但它被认为属于映射而非序列，因为它查找时使用任意的 immutable 键而非整数。</p>
<p><code>collections.abc.Sequence</code> 抽象基类定义了一个更丰富的接口，它在 <code>__getitem__()</code> 和 <code>__len__()</code> 之外又添加了 <code>count()</code>, <code>index()</code>, <code>__contains__()</code> 和 <code>__reversed__()</code>。 实现此扩展接口的类型可以使用 <code>register()</code> 来显式地注册。</p>
<p>set comprehension — 集合推导式</p>
<p>处理一个可迭代对象中的所有或部分元素并返回结果集合的一种紧凑写法。 <code>results = {c for c in 'abracadabra' if c not in 'abc'}</code> 将生成字符串集合 <code>{'r', 'd'}</code>。 </p>
<p>single dispatch — 单分派</p>
<p>一种 generic function 分派形式，其实现是基于单个参数的类型来选择的。</p>
<p>slice — 切片</p>
<p>通常只包含了特定 sequence 的一部分的对象。切片是通过使用下标标记来创建的，在 <code>[]</code> 中给出几个以冒号分隔的数字，例如 <code>variable_name[1:3:5]</code>。方括号（下标）标记在内部使用 <code>slice</code> 对象。</p>
<p>special method — 特殊方法</p>
<p>一种由 Python 隐式调用的方法，用来对某个类型执行特定操作例如相加等等。这种方法的名称的首尾都为双下划线。</p>
<p>statement — 语句</p>
<p>语句是程序段（一个代码“块”）的组成单位。一条语句可以是一个 expression 或某个带有关键字的结构，例如 <code>if</code>、<code>while</code> 或 <code>for</code>。</p>
<p>strong reference — 强引用</p>
<p>在 Python 的 C API 中，强引用是对象引用的一种，当它被创建时将会增加对象引用计数而当它被删除时则会减少对象引用计数。</p>
<p><code>Py_NewRef()</code> 函数可被用于创建一个对象的强引用。 通常，必须在退出某个强引用的作用域时在该强引用上调用 <code>Py_DECREF()</code> 函数，以避免引用的泄漏。</p>
<p>text encoding — 文本编码</p>
<p>用于将Unicode字符串编码为字节串的编码器。</p>
<p>text file — 文本文件</p>
<p>一种能够读写 <code>str</code> 对象的 file object。通常一个文本文件实际是访问一个面向字节的数据流并自动处理 text encoding。文本文件的例子包括以文本模式（<code>'r'</code> 或 <code>'w'</code>）打开的文件、<code>sys.stdin</code>、<code>sys.stdout</code> 以及 <code>io.StringIO</code> 的实例。</p>
<p>triple-quoted string — 三引号字符串</p>
<p>首尾各带三个连续双引号（”）或者单引号（’）的字符串。它们在功能上与首尾各用一个引号标注的字符串没有什么不同，但是有多种用处。它们允许你在字符串内包含未经转义的单引号和双引号，并且可以跨越多行而无需使用连接符，在编写文档字符串时特别好用。</p>
<p>type — 类型</p>
<p>类型决定一个 Python 对象属于什么种类；每个对象都具有一种类型。要知道对象的类型，可以访问它的 <code>__class__</code> 属性，或是通过 <code>type(obj)</code> 来获取。</p>
<p>type alias — 类型别名</p>
<p>一个类型的同义词，创建方式是把类型赋值给特定的标识符。</p>
<p>类型别名的作用是简化 类型提示。例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">remove_gray_shades</span><span class="token punctuation">(</span>
        colors<span class="token punctuation">:</span> list<span class="token punctuation">[</span>tuple<span class="token punctuation">[</span>int<span class="token punctuation">,</span> int<span class="token punctuation">,</span> int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> list<span class="token punctuation">[</span>tuple<span class="token punctuation">[</span>int<span class="token punctuation">,</span> int<span class="token punctuation">,</span> int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以这样提高可读性:</p>
<pre class="line-numbers language-python"><code class="language-python">Color <span class="token operator">=</span> tuple<span class="token punctuation">[</span>int<span class="token punctuation">,</span> int<span class="token punctuation">,</span> int<span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">remove_gray_shades</span><span class="token punctuation">(</span>colors<span class="token punctuation">:</span> list<span class="token punctuation">[</span>Color<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> list<span class="token punctuation">[</span>Color<span class="token punctuation">]</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>type hint — 类型提示</p>
<p>annotation 为变量、类属性、函数的形参或返回值指定预期的类型。</p>
<p>类型提示属于可选项，Python 不要求提供，但其可对静态类型分析工具起作用，并可协助 IDE 实现代码补全与重构。</p>
<p>全局变量、类属性和函数的类型提示可以使用 <code>typing.get_type_hints()</code> 来访问，但局部变量则不可以。</p>
<p>universal newlines — 通用换行</p>
<p>一种解读文本流的方式，将以下所有符号都识别为行结束标志：Unix 的行结束约定 <code>'\n'</code>、Windows 的约定 <code>'\r\n'</code> 以及旧版 Macintosh 的约定 <code>'\r'</code>。参见 <a href="https://www.python.org/dev/peps/pep-0278" target="_blank" rel="noopener"><strong>PEP 278</strong></a> 和 <a href="https://www.python.org/dev/peps/pep-3116" target="_blank" rel="noopener"><strong>PEP 3116</strong></a> 和 <code>bytes.splitlines()</code> 了解更多用法说明。</p>
<p>variable annotation — 变量标注</p>
<p>对变量或类属性的 annotation。</p>
<p>在标注变量或类属性时，还可选择为其赋值:</p>
<pre><code>class C:    field: 'annotation'</code></pre><p>变量标注通常被用作 类型提示：例如以下变量预期接受 <code>int</code> 类型的值:</p>
<pre><code>count: int = 0</code></pre><p>参见 function annotation, <a href="https://www.python.org/dev/peps/pep-0484" target="_blank" rel="noopener"><strong>PEP 484</strong></a> 和 <a href="https://www.python.org/dev/peps/pep-0526" target="_blank" rel="noopener"><strong>PEP 526</strong></a>，其中描述了此功能。 </p>
<p>virtual environment — 虚拟环境</p>
<p>一种采用协作式隔离的运行时环境，允许 Python 用户和应用程序在安装和升级 Python 分发包时不会干扰到同一系统上运行的其他 Python 应用程序的行为。</p>
<p>virtual machine — 虚拟机</p>
<p>一台完全通过软件定义的计算机。Python 虚拟机可执行字节码编译器所生成的 bytecode。</p>
<p>Zen of Python — Python 之禅</p>
<p>列出 Python 设计的原则与哲学，有助于理解与使用这种语言。查看其具体内容可在交互模式提示符中输入 “<code>import this</code>“。</p>
<h1 id="Python版本变化"><a href="#Python版本变化" class="headerlink" title="Python版本变化"></a>Python版本变化</h1><ul>
<li><a href="https://blog.csdn.net/qq_35952638/article/details/103101820" target="_blank" rel="noopener">python版本特性简介</a></li>
<li><a href="https://www.bookstack.cn/read/python-3.10.0-zh/4c1b23ec18d093c1.md" target="_blank" rel="noopener">版本变化大全</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io" rel="external nofollow noreferrer">杰克成</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io/posts/Language-Python.html">https://jackhcc.github.io/posts/Language-Python.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Python/">
                                    <span class="chip bg-color">Python</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/aliqr.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/wxqr.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '3821a0bbb773038a51fc',
        clientSecret: '4b30b507d67ec5497ec0e77f43f80cb3e0d7dd3a',
        repo: 'JackHCC.github.io',
        owner: 'JackHCC',
        admin: "JackHCC",
        id: '2021-11-08T14-19-37',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/posts/Language-Python.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/1.jpg" class="responsive-img" alt="Python全解析">
                        
                        <span class="card-title">Python全解析</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Python3.10语言手册
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Language/" class="post-category">
                                    Language
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Python/">
                        <span class="chip bg-color">Python</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/dl-series17.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/8.jpg" class="responsive-img" alt="DL专栏17>网络可视化">
                        
                        <span class="card-title">DL专栏17>网络可视化</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            深度学习模型网络可视化概述
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-05
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Deep-Learning/" class="post-category">
                                    Deep Learning
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Deep-Learning/">
                        <span class="chip bg-color">Deep Learning</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('4'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">2182.8k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "2";
                    var startDate = "27";
                    var startHour = "6";
                    var startMinute = "30";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/JackHCC" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:jackcc0701@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://www.facebook.com/profile.php?id=100046343443643" class="tooltipped" target="_blank" data-tooltip="关注我的Facebook: https://www.facebook.com/profile.php?id=100046343443643" data-position="top" data-delay="50">
        <i class="fab fa-facebook-f"></i>
    </a>



    <a href="https://twitter.com/JackChe66021834" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/JackChe66021834" data-position="top" data-delay="50">
        <i class="fab fa-twitter"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2508074836" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2508074836" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/6885584679" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/6885584679" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/matery.js"></script>

    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script type="text/javascript" src="/js/fireworks.js"></script>

    <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>'); }
    </script>

    <!-- weather -->
	<script type="text/javascript">
	WIDGET = {FID: 'TToslpmkVO'}
	</script>
	<script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>


    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

    
    
    <script async src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    
        <script src="//code.tidio.co/kqhlkxviiccyoa0czpfpu4ijuey9hfre.js"></script>
        <script> 
            $(document).ready(function () {
                setInterval(change_Tidio, 50);  
                function change_Tidio() { 
                    var tidio=$("#tidio-chat iframe");
                    if(tidio.css("display")=="block"&& $(window).width()>977 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" &&$(window).width()>977)>0? "-40px" : ($("div.toc-title").length&&$(window).width()>977)>0?"85px":"20px";   
                        document.getElementById("tidio-chat-iframe").style.right="-15px";   
                        document.getElementById("tidio-chat-iframe").style.height=parseInt(tidio.css("height"))>=520?"520px":tidio.css("height");
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    } 
                    else if(tidio.css("display")=="block"&&$(window).width()>601 &&$(window).width()<992 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && 601< $(window).width()<992)>0? "-40px":"20px" ;   
                        document.getElementById("tidio-chat-iframe").style.right="-15px"; 
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    else if(tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))<230){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && $(window).width()<601)>0? "-10px":"45px" ;   
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    if( tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))>=230){
                        document.getElementById("tidio-chat-iframe").style.zIndex="998";
                    }
                } 
            }); 
        </script>
    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/instantpage/instantpage.js" type="module"></script>
    
<script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script>
        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        $('a').each(function() {
          const $this = $(this);
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'your_domain' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script></body>

</html>

