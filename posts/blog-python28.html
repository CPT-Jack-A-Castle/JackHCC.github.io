<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Python-Standard Library, JackHCC">
    <meta name="description" content="Python标准库详解">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Python-Standard Library | JackHCC</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my.css">
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="JackHCC" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-hopscotch.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JackHCC</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">JackHCC</div>
        <div class="logo-desc">
            
            Make the world betterrrr!!!
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JackHCC/JackHCC.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JackHCC/JackHCC.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/7.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Python-Standard Library</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 30px;
        bottom: 146px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Python/">
                                <span class="chip bg-color">Python</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Python/" class="post-category">
                                Python
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-11-03
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-11-11
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    105.4k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    411 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Python-标准库"><a href="#Python-标准库" class="headerlink" title="Python 标准库"></a>Python 标准库</h1><ul>
<li>概述<ul>
<li>可用性注释</li>
</ul>
</li>
<li>内置函数</li>
<li>内置常量<ul>
<li>由 <code>site</code> 模块添加的常量</li>
</ul>
</li>
<li>内置类型<ul>
<li>逻辑值检测</li>
<li>布尔运算 —- <code>and</code>, <code>or</code>, <code>not</code></li>
<li>比较运算</li>
<li>数字类型 —- <code>int</code>, <code>float</code>, <code>complex</code></li>
<li>迭代器类型</li>
<li>序列类型 —- <code>list</code>, <code>tuple</code>, <code>range</code></li>
<li>文本序列类型 —- <code>str</code></li>
<li>二进制序列类型 —- <code>bytes</code>, <code>bytearray</code>, <code>memoryview</code></li>
<li>集合类型 —- <code>set</code>, <code>frozenset</code></li>
<li>映射类型 —- <code>dict</code></li>
<li>上下文管理器类型</li>
<li>Type Annotation Types —- Generic Alias, Union</li>
<li>其他内置类型</li>
<li>特殊属性</li>
</ul>
</li>
<li>内置异常<ul>
<li>基类</li>
<li>具体异常</li>
<li>警告</li>
<li>异常层次结构</li>
</ul>
</li>
<li>文本处理服务<ul>
<li><code>string</code> —- 常见的字符串操作</li>
<li><code>re</code> —- 正则表达式操作</li>
<li><code>difflib</code> —- 计算差异的辅助工具</li>
<li><code>textwrap</code> —- 文本自动换行与填充</li>
<li><code>unicodedata</code> —- Unicode 数据库</li>
<li><code>stringprep</code> —- 因特网字符串预备</li>
<li><code>readline</code> —- GNU readline 接口</li>
<li><code>rlcompleter</code> —- GNU readline 的补全函数</li>
</ul>
</li>
<li>二进制数据服务<ul>
<li><code>struct</code> —- 将字节串解读为打包的二进制数据</li>
<li><code>codecs</code> —- 编解码器注册和相关基类</li>
</ul>
</li>
<li>数据类型<ul>
<li><code>datetime</code> —- 基本日期和时间类型</li>
<li><code>zoneinfo</code> —- IANA 时区支持</li>
<li><code>calendar</code> —- 日历相关函数</li>
<li><code>collections</code> —- 容器数据类型</li>
<li><code>collections.abc</code> —- 容器的抽象基类</li>
<li><code>heapq</code> —- 堆队列算法</li>
<li><code>bisect</code> —- 数组二分查找算法</li>
<li><code>array</code> —- 高效的数值数组</li>
<li><code>weakref</code> —- 弱引用</li>
<li><code>types</code> —- 动态类型创建和内置类型名称</li>
<li><code>copy</code> —- 浅层 (shallow) 和深层 (deep) 复制操作</li>
<li><code>pprint</code> —- 数据美化输出</li>
<li><code>reprlib</code> —- 另一种 <code>repr()</code> 实现</li>
<li><code>enum</code> —- 对枚举的支持</li>
<li><code>graphlib</code> —- 操作类似图的结构的功能</li>
</ul>
</li>
<li>数字和数学模块<ul>
<li><code>numbers</code> —- 数字的抽象基类</li>
<li><code>math</code> —- 数学函数</li>
<li><code>cmath</code> —- 关于复数的数学函数</li>
<li><code>decimal</code> —- 十进制定点和浮点运算</li>
<li><code>fractions</code> —- 分数</li>
<li><code>random</code> —- 生成伪随机数</li>
<li><code>statistics</code> —- 数学统计函数</li>
</ul>
</li>
<li>函数式编程模块<ul>
<li><code>itertools</code> —- 为高效循环而创建迭代器的函数</li>
<li><code>functools</code> —- 高阶函数和可调用对象上的操作</li>
<li><code>operator</code> —- 标准运算符替代函数</li>
</ul>
</li>
<li>文件和目录访问<ul>
<li><code>pathlib</code> —- 面向对象的文件系统路径</li>
<li><code>os.path</code> —- 常用路径操作</li>
<li><code>fileinput</code> —- 迭代来自多个输入流的行</li>
<li><code>stat</code> —- 解析 <code>stat()</code> 结果</li>
<li><code>filecmp</code> —- 文件及目录的比较</li>
<li><code>tempfile</code> —- 生成临时文件和目录</li>
<li><code>glob</code> —- Unix 风格路径名模式扩展</li>
<li><code>fnmatch</code> —- Unix 文件名模式匹配</li>
<li><code>linecache</code> —- 随机读写文本行</li>
<li><code>shutil</code> —- 高阶文件操作</li>
</ul>
</li>
<li>数据持久化<ul>
<li><code>pickle</code> —- Python 对象序列化</li>
<li><code>copyreg</code> —- 注册配合 <code>pickle</code> 模块使用的函数</li>
<li><code>shelve</code> —- Python 对象持久化</li>
<li><code>marshal</code> —- 内部 Python 对象序列化</li>
<li><code>dbm</code> —- Unix “数据库” 接口</li>
<li><code>sqlite3</code> —- SQLite 数据库 DB-API 2.0 接口模块</li>
</ul>
</li>
<li>数据压缩和存档<ul>
<li><code>zlib</code> —- 与 <strong>gzip</strong> 兼容的压缩</li>
<li><code>gzip</code> —- 对 <strong>gzip</strong> 格式的支持</li>
<li><code>bz2</code> —- 对 <strong>bzip2</strong> 压缩算法的支持</li>
<li><code>lzma</code> —- 用 LZMA 算法压缩</li>
<li><code>zipfile</code> —- 使用ZIP存档</li>
<li><code>tarfile</code> —- 读写tar归档文件</li>
</ul>
</li>
<li>文件格式<ul>
<li><code>csv</code> —- CSV 文件读写</li>
<li><code>configparser</code> —- 配置文件解析器</li>
<li><code>netrc</code> —- netrc 文件处理</li>
<li><code>xdrlib</code> —- 编码与解码 XDR 数据</li>
<li><code>plistlib</code> —- 生成与解析 Apple <code>.plist</code> 文件</li>
</ul>
</li>
<li>加密服务<ul>
<li><code>hashlib</code> —- 安全哈希与消息摘要</li>
<li><code>hmac</code> —- 基于密钥的消息验证</li>
<li><code>secrets</code> —- 生成管理密码的安全随机数</li>
</ul>
</li>
<li>通用操作系统服务<ul>
<li><code>os</code> —- 多种操作系统接口</li>
<li><code>io</code> —- 处理流的核心工具</li>
<li><code>time</code> —- 时间的访问和转换</li>
<li><code>argparse</code> —- 命令行选项、参数和子命令解析器</li>
<li><code>getopt</code> —- C 风格的命令行选项解析器</li>
<li><code>logging</code> —- Python 的日志记录工具</li>
<li><code>logging.config</code> —- 日志记录配置</li>
<li><code>logging.handlers</code> —- 日志处理程序</li>
<li><code>getpass</code> —- 便携式密码输入工具</li>
<li><code>curses</code> —- 终端字符单元显示的处理</li>
<li><code>curses.textpad</code> —- 用于 curses 程序的文本输入控件</li>
<li><code>curses.ascii</code> —- 用于 ASCII 字符的工具</li>
<li><code>curses.panel</code> —- curses 的面板栈扩展</li>
<li><code>platform</code> —- 获取底层平台的标识数据</li>
<li><code>errno</code> —- 标准 errno 系统符号</li>
<li><code>ctypes</code> —- Python 的外部函数库</li>
</ul>
</li>
<li>并发执行<ul>
<li><code>threading</code> —- 基于线程的并行</li>
<li><code>multiprocessing</code> —- 基于进程的并行</li>
<li><code>multiprocessing.shared_memory</code> —- 可从进程直接访问的共享内存</li>
<li><code>concurrent</code> 包</li>
<li><code>concurrent.futures</code> —- 启动并行任务</li>
<li><code>subprocess</code> —- 子进程管理</li>
<li><code>sched</code> —- 事件调度器</li>
<li><code>queue</code> —- 一个同步的队列类</li>
<li><code>contextvars</code> —- 上下文变量</li>
<li><code>_thread</code> —- 底层多线程 API</li>
</ul>
</li>
<li>网络和进程间通信<ul>
<li><code>asyncio</code> —- 异步 I/O</li>
<li><code>socket</code> —- 底层网络接口</li>
<li><code>ssl</code> —- 套接字对象的 TLS/SSL 包装器</li>
<li><code>select</code> —- 等待 I/O 完成</li>
<li><code>selectors</code> —- 高级 I/O 复用库</li>
<li><code>asyncore</code> —- 异步套接字处理器</li>
<li><code>asynchat</code> —- 异步套接字指令/响应处理程序</li>
<li><code>signal</code> —- 设置异步事件处理程序</li>
<li><code>mmap</code> —- 内存映射文件支持</li>
</ul>
</li>
<li>互联网数据处理<ul>
<li><code>email</code> —- 电子邮件与 MIME 处理包</li>
<li><code>json</code> —- JSON 编码和解码器</li>
<li><code>mailcap</code> —- Mailcap 文件处理</li>
<li><code>mailbox</code> —- 操作多种格式的邮箱</li>
<li><code>mimetypes</code> —- 映射文件名到 MIME 类型</li>
<li><code>base64</code> —- Base16, Base32, Base64, Base85 数据编码</li>
<li><code>binhex</code> —- 对binhex4文件进行编码和解码</li>
<li><code>binascii</code> —- 二进制和 ASCII 码互转</li>
<li><code>quopri</code> —- 编码与解码经过 MIME 转码的可打印数据</li>
<li><code>uu</code> —- 对 uuencode 文件进行编码与解码</li>
</ul>
</li>
<li>结构化标记处理工具<ul>
<li><code>html</code> —- 超文本标记语言支持</li>
<li><code>html.parser</code> —- 简单的 HTML 和 XHTML 解析器</li>
<li><code>html.entities</code> —- HTML 一般实体的定义</li>
<li>XML处理模块</li>
<li><code>xml.etree.ElementTree</code> —- ElementTree XML API</li>
<li><code>xml.dom</code> —- 文档对象模型 API</li>
<li><code>xml.dom.minidom</code> —- 最小化的 DOM 实现</li>
<li><code>xml.dom.pulldom</code> —- 支持构建部分 DOM 树</li>
<li><code>xml.sax</code> —- 支持 SAX2 解析器</li>
<li><code>xml.sax.handler</code> —- SAX 处理句柄的基类</li>
<li><code>xml.sax.saxutils</code> —- SAX 工具集</li>
<li><code>xml.sax.xmlreader</code> —- 用于 XML 解析器的接口</li>
<li><code>xml.parsers.expat</code> —- 使用 Expat 的快速 XML 解析</li>
</ul>
</li>
<li>互联网协议和支持<ul>
<li><code>webbrowser</code> —- 方便的 Web 浏览器控制工具</li>
<li><code>cgi</code> —- 通用网关接口支持</li>
<li><code>cgitb</code> —- 用于 CGI 脚本的回溯管理器</li>
<li><code>wsgiref</code> —- WSGI 工具和参考实现</li>
<li><code>urllib</code> —- URL 处理模块</li>
<li><code>urllib.request</code> —- 用于打开 URL 的可扩展库</li>
<li><code>urllib.response</code> —- urllib 使用的 Response 类</li>
<li><code>urllib.parse</code> 用于解析 URL</li>
<li><code>urllib.error</code> —- urllib.request 引发的异常类</li>
<li><code>urllib.robotparser</code> —- robots.txt 语法分析程序</li>
<li><code>http</code> —- HTTP 模块</li>
<li><code>http.client</code> —- HTTP 协议客户端</li>
<li><code>ftplib</code> —- FTP 协议客户端</li>
<li><code>poplib</code> —- POP3 协议客户端</li>
<li><code>imaplib</code> —- IMAP4 协议客户端</li>
<li><code>nntplib</code> —- NNTP protocol client</li>
<li><code>smtplib</code> —-SMTP协议客户端</li>
<li><code>smtpd</code> —- SMTP 服务器</li>
<li><code>telnetlib</code> — Telnet 客户端</li>
<li><code>uuid</code> —- UUID objects according to <strong>RFC 4122</strong></li>
<li><code>socketserver</code> —- A framework for network servers</li>
<li><code>http.server</code> —- HTTP 服务器</li>
<li><code>http.cookies</code> —- HTTP状态管理</li>
<li><code>http.cookiejar</code> —— HTTP 客户端的 Cookie 处理</li>
<li><code>xmlrpc</code> —- XMLRPC 服务端与客户端模块</li>
<li><code>xmlrpc.client</code> —- XML-RPC 客户端访问</li>
<li><code>xmlrpc.server</code> —- 基本 XML-RPC 服务器</li>
<li><code>ipaddress</code> —- IPv4/IPv6 操作库</li>
</ul>
</li>
<li>多媒体服务<ul>
<li><code>audioop</code> —- 处理原始音频数据</li>
<li><code>aifc</code> —- 读写 AIFF 和 AIFC 文件</li>
<li><code>sunau</code> —- 读写 Sun AU 文件</li>
<li><code>wave</code> —- 读写WAV格式文件</li>
<li><code>chunk</code> —- 读取 IFF 分块数据</li>
<li><code>colorsys</code> —- 颜色系统间的转换</li>
<li><code>imghdr</code> —- 推测图像类型</li>
<li><code>sndhdr</code> —- 推测声音文件的类型</li>
<li><code>ossaudiodev</code> —- 访问兼容OSS的音频设备</li>
</ul>
</li>
<li>国际化<ul>
<li><code>gettext</code> —- 多语种国际化服务</li>
<li><code>locale</code> —- 国际化服务</li>
</ul>
</li>
<li>程序框架<ul>
<li><code>turtle</code> —- 海龟绘图</li>
<li><code>cmd</code> —- 支持面向行的命令解释器</li>
<li><code>shlex</code> —— 简单的词法分析</li>
</ul>
</li>
<li>Tk图形用户界面(GUI)<ul>
<li><code>tkinter</code> —- Tcl/Tk的Python接口</li>
<li><code>tkinter.colorchooser</code> —- 颜色选择对话框</li>
<li><code>tkinter.font</code> —- Tkinter 字体封装</li>
<li>Tkinter 对话框</li>
<li><code>tkinter.messagebox</code> —- Tkinter 消息提示</li>
<li><code>tkinter.scrolledtext</code> —- 滚动文字控件</li>
<li><code>tkinter.dnd</code> —- 拖放操作支持</li>
<li><code>tkinter.ttk</code> —- Tk主题部件</li>
<li><code>tkinter.tix</code> —- TK扩展包</li>
<li>IDLE</li>
</ul>
</li>
<li>开发工具<ul>
<li><code>typing</code> —- 类型提示支持</li>
<li><code>pydoc</code> —- 文档生成器和在线帮助系统</li>
<li>Python Development Mode</li>
<li>Effects of the Python Development Mode</li>
<li>ResourceWarning Example</li>
<li>Bad file descriptor error example</li>
<li><code>doctest</code> —- 测试交互性的Python示例</li>
<li><code>unittest</code> —- 单元测试框架</li>
<li><code>unittest.mock</code> —- 模拟对象库</li>
<li><code>unittest.mock</code> 上手指南</li>
<li>2to3 - 自动将 Python 2 代码转为 Python 3 代码</li>
<li><code>test</code> —- Python回归测试包</li>
<li><code>test.support</code> —- Utilities for the Python test suite</li>
<li><code>test.support.socket_helper</code> —- Utilities for socket tests</li>
<li><code>test.support.script_helper</code> —- Utilities for the Python execution tests</li>
<li><code>test.support.bytecode_helper</code> —- Support tools for testing correct bytecode generation</li>
<li><code>test.support.threading_helper</code> —- Utilities for threading tests</li>
<li><code>test.support.os_helper</code> —- Utilities for os tests</li>
<li><code>test.support.import_helper</code> —- Utilities for import tests</li>
<li><code>test.support.warnings_helper</code> —- Utilities for warnings tests</li>
</ul>
</li>
<li>调试和分析<ul>
<li>审计事件表</li>
<li><code>bdb</code> —- Debugger framework</li>
<li><code>faulthandler</code> —- Dump the Python traceback</li>
<li><code>pdb</code> —- Python 的调试器</li>
<li>Python Profilers 分析器</li>
<li><code>timeit</code> —- 测量小代码片段的执行时间</li>
<li><code>trace</code> —- 跟踪Python语句的执行</li>
<li><code>tracemalloc</code> —- 跟踪内存分配</li>
</ul>
</li>
<li>软件打包和分发<ul>
<li><code>distutils</code> —- 构建和安装 Python 模块</li>
<li><code>ensurepip</code> —- Bootstrapping the <code>pip</code> installer</li>
<li><code>venv</code> —- 创建虚拟环境</li>
<li><code>zipapp</code> —- Manage executable Python zip archives</li>
</ul>
</li>
<li>Python运行时服务<ul>
<li><code>sys</code> —- 系统相关的参数和函数</li>
<li><code>sysconfig</code> —- Provide access to Python’s configuration information</li>
<li><code>builtins</code> —- 内建对象</li>
<li><code>__main__</code> —- Top-level code environment</li>
<li><code>warnings</code> —— 警告信息的控制</li>
<li><code>dataclasses</code> —- 数据类</li>
<li><code>contextlib</code> —- 为 <code>with</code>语句上下文提供的工具</li>
<li><code>abc</code> —- 抽象基类</li>
<li><code>atexit</code> —- 退出处理器</li>
<li><code>traceback</code> —- 打印或检索堆栈回溯</li>
<li><code>__future__</code> —- Future 语句定义</li>
<li><code>gc</code> —- 垃圾回收器接口</li>
<li><code>inspect</code> —- 检查对象</li>
<li><code>site</code> —— 指定域的配置钩子</li>
</ul>
</li>
<li>自定义 Python 解释器<ul>
<li><code>code</code> —- 解释器基类</li>
<li><code>codeop</code> —- 编译Python代码</li>
</ul>
</li>
<li>导入模块<ul>
<li><code>zipimport</code> —- 从 Zip 存档中导入模块</li>
<li><code>pkgutil</code> —- 包扩展工具</li>
<li><code>modulefinder</code> —- 查找脚本使用的模块</li>
<li><code>runpy</code> ——查找并执行 Python 模块</li>
<li><code>importlib</code> —- <code>import</code> 的实现</li>
<li>Using <code>importlib.metadata</code></li>
</ul>
</li>
<li>Python 语言服务<ul>
<li><code>ast</code> —- 抽象语法树</li>
<li><code>symtable</code> —- Access to the compiler’s symbol tables</li>
<li><code>token</code> —- 与Python解析树一起使用的常量</li>
<li><code>keyword</code> —- 检验Python关键字</li>
<li><code>tokenize</code> —- 对 Python 代码使用的标记解析器</li>
<li><code>tabnanny</code> —- 模糊缩进检测</li>
<li><code>pyclbr</code> —- Python 模块浏览器支持</li>
<li><code>py_compile</code> —- 编译 Python 源文件</li>
<li><code>compileall</code> —- Byte-compile Python libraries</li>
<li><code>dis</code> —- Python 字节码反汇编器</li>
<li><code>pickletools</code> —- pickle 开发者工具集</li>
</ul>
</li>
<li>Windows系统相关模块<ul>
<li><code>msilib</code> —- Read and write Microsoft Installer files</li>
<li><code>msvcrt</code> —- 来自 MS VC++ 运行时的有用例程</li>
<li><code>winreg</code> —- 访问 Windows 注册表</li>
<li><code>winsound</code> —— Windows 系统的音频播放接口</li>
</ul>
</li>
<li>Unix 专有服务<ul>
<li><code>posix</code> —- 最常见的 POSIX 系统调用</li>
<li><code>pwd</code> —- 用户密码数据库</li>
<li><code>spwd</code> —- The shadow password database</li>
<li><code>grp</code> —- 组数据库</li>
<li><code>crypt</code> —— 验证 Unix 口令的函数</li>
<li><code>termios</code> —- POSIX 风格的 tty 控制</li>
<li><code>tty</code> —- 终端控制功能</li>
<li><code>pty</code> —- 伪终端工具</li>
<li><code>fcntl</code> —— 系统调用 <code>fcntl</code> 和 <code>ioctl</code></li>
<li><code>pipes</code> —- 终端管道接口</li>
<li><code>resource</code> —- Resource usage information</li>
<li><code>nis</code> —- Sun 的 NIS (黄页) 接口</li>
<li>Unix syslog 库例程</li>
</ul>
</li>
<li>被取代的模块<ul>
<li><code>optparse</code> —- 解析器的命令行选项</li>
<li><code>imp</code> —- Access the import internals</li>
</ul>
</li>
<li>未创建文档的模块<ul>
<li>平台特定模块</li>
</ul>
</li>
<li>Security Considerations</li>
</ul>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>“Python 库”中包含了几种不同的组件。</p>
<p>它包含通常被视为语言“核心”中的一部分的数据类型，例如数字和列表。对于这些类型，Python语言核心定义了文字的形式，并对它们的语义设置了一些约束，但没有完全定义语义。（另一方面，语言核心确实定义了语法属性，如操作符的拼写和优先级。）</p>
<p>这个库也包含了内置函数和异常 —- 不需要 <code>import</code> 语句就可以在所有Python代码中使用的对象。有一些是由语言核心定义的，但是许多对于核心语义不是必需的，并且仅在这里描述。</p>
<p>不过这个库主要是由一系列的模块组成。这些模块集可以不同方式分类。有些模块是用 C 编写并内置于 Python 解释器中；另一些模块则是用 Python 编写并以源码形式导入。有些模块提供专用于 Python 的接口，例如打印栈追踪信息；有些模块提供专用于特定操作系统的接口，例如操作特定的硬件；另一些模块则提供针对特定应用领域的接口，例如万维网。有些模块在所有更新和移植版本的 Python 中可用；另一些模块仅在底层系统支持或要求时可用；还有些模块则仅当编译和安装 Python 时选择了特定配置选项时才可用。</p>
<h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><p>Python 解释器内置了很多函数和类型，任何时候都能使用。以下按字母顺序给出列表。</p>
<ul>
<li><code>abs</code>(<em>x</em>)</li>
</ul>
<p>返回一个数的绝对值。 参数可以是整数、浮点数或任何实现了 <code>__abs__()</code> 的对象。 如果参数是一个复数，则返回它的模。</p>
<ul>
<li><code>aiter</code>(<em>async_iterable</em>)</li>
</ul>
<p>返回 asynchronous iterable 的 asynchronous iterator 。相当于调用 <code>x.__aiter__()</code>。</p>
<ul>
<li><code>aiter(x)</code> 本身带有 <code>__aiter__()</code> 方法，返回 <code>x</code>，所以 <code>aiter(aiter(x))</code> 与 <code>aiter(x)</code> 相同。</li>
</ul>
<p>注意：与 <code>iter()</code> 不同，<code>aiter()</code> 没有两个参数的版本。</p>
<p>3.10 新版功能.</p>
<ul>
<li><code>all</code>(<em>iterable</em>)</li>
</ul>
<p>如果 <em>iterable</em> 的所有元素均为真值（或可迭代对象为空）则返回 <code>True</code> 。 等价于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">all</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> element <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> element<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><em>awaitable</em> <code>anext</code>(<em>async_iterator</em>[, <em>default</em>])</li>
</ul>
<p>当进入 await 状态时，从给定 asynchronous iterator 返回下一数据项，迭代完毕则返回 <em>default</em>。</p>
<p>这是内置函数 <code>next()</code> 的异步版本，类似于：</p>
<p>调用 <em>async_iterator</em> 的 <code>__anext__()</code> 方法，返回一个 awaitable。等待返回迭代器的下一个值。若有给出 <em>default</em>，则在迭代完毕后会返回给出的值，否则会触发 <code>StopAsyncIteration</code>。</p>
<p>3.10 新版功能.</p>
<ul>
<li><code>any</code>(<em>iterable</em>)</li>
</ul>
<p>如果 <em>iterable</em> 的任一元素为真值则返回 <code>True</code>。 如果可迭代对象为空，返回 <code>False</code>。 等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">any</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> element <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
        <span class="token keyword">if</span> element<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
    <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>ascii</code>(<em>object</em>)</li>
</ul>
<p>与 <code>repr()</code> 类似，返回一个字符串，表示对象的可打印形式，但在 <code>repr()</code> 返回的字符串中，非 ASCII 字符会用 <code>\x</code>、<code>\u</code> 和 <code>\U</code> 进行转义。生成的字符串类似于 Python 2 中 <code>repr()</code> 的返回结果。</p>
<ul>
<li><code>bin</code>(<em>x</em>)</li>
</ul>
<p>将整数转变为以“0b”前缀的二进制字符串。结果是一个合法的 Python 表达式。如果 <em>x</em> 不是 Python 的 <code>int</code> 对象，它必须定义 <code>__index__()</code> 方法，以便返回整数值。下面是一些例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> bin<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token string">'0b11'</span>
<span class="token operator">>></span><span class="token operator">></span> bin<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token string">'-0b1010'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>若要控制是否显示前缀“0b”，可以采用以下两种方案：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> format<span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token string">'#b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> format<span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'0b1110'</span><span class="token punctuation">,</span><span class="token string">'1110'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">'{14:#b}'</span><span class="token punctuation">,</span> f<span class="token string">'{14:b}'</span>
<span class="token punctuation">(</span><span class="token string">'0b1110'</span><span class="token punctuation">,</span><span class="token string">'1110'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>另见 <code>format()</code> 获取更多信息。</p>
<ul>
<li><em>class</em> <code>bool</code>([<em>x</em>])</li>
</ul>
<p>返回布尔值，<code>True</code> 或 <code>False</code>。<em>x</em> 用标准的 真值测试过程 进行转换。如果 <em>x</em> 为 False 或省略，则返回 <code>False</code>；否则返回 <code>True</code>。 <code>bool</code> 类是 <code>int</code> 的子类。它不能再被继承。它唯一的实例就是 <code>False</code> 和 <code>True</code> 。</p>
<p>在 3.7 版更改: <em>x</em> 现在只能作为位置参数。</p>
<ul>
<li><code>breakpoint</code>(<em>\</em>args<em>,</em> <em>*kws</em>)</li>
</ul>
<p>此函数会在调用时将你陷入调试器中。具体来说，它调用 <code>sys.breakpointhook()</code> ，直接传递 <code>args</code> 和 <code>kws</code> 。默认情况下， <code>sys.breakpointhook()</code> 调用 <code>pdb.set_trace()</code> 且没有参数。在这种情况下，它纯粹是一个便利函数，因此您不必显式导入 <code>pdb</code> 且键入尽可能少的代码即可进入调试器。但是， <code>sys.breakpointhook()</code> 可以设置为其他一些函数并被 <code>breakpoint()</code> 自动调用，以允许进入你想用的调试器。</p>
<p>引发一个 审计事件<code>builtins.breakpoint</code> 并附带参数 <code>breakpointhook</code>。</p>
<p>3.7 新版功能.</p>
<ul>
<li><em>class</em> <code>bytearray</code>([<em>source</em>[, <em>encoding</em>[, <em>errors</em>]]])</li>
</ul>
<p>返回一个新的 bytes 数组。 <code>bytearray</code> 类是一个可变序列，包含范围为 0 &lt;= x &lt; 256 的整数。它有可变序列大部分常见的方法，见 可变序列类型 的描述；同时有 <code>bytes</code> 类型的大部分方法。</p>
<p>可选形参 <em>source</em> 可以用不同的方式来初始化数组：</p>
<ul>
<li>如果是一个 <em>string*，您必须提供 *encoding</em> 参数（<em>errors</em> 参数仍是可选的）；<code>bytearray()</code> 会使用 <code>str.encode()</code> 方法来将 string 转变成 bytes。</li>
<li>如果是一个 <em>integer</em>，会初始化大小为该数字的数组，并使用 null 字节填充。</li>
<li>如果是一个遵循 缓冲区接口 的对象，该对象的只读缓冲区将被用来初始化字节数组。</li>
<li>如果是一个 <em>iterable</em> 可迭代对象，它的元素的范围必须是 <code>0 &lt;= x &lt; 256</code> 的整数，它会被用作数组的初始内容。</li>
</ul>
<p>如果没有实参，则创建大小为 0 的数组。</p>
<ul>
<li><em>class</em> <code>bytes</code>([<em>source</em>[, <em>encoding</em>[, <em>errors</em>]]])</li>
</ul>
<p>返回一个新的“bytes”对象，这是一个不可变序列，包含范围为 <code>0 &lt;= x &lt; 256</code> 的整数。<code>bytes</code> 是 <code>bytearray</code> 的不可变版本——带有同样不改变序列的方法，支持同样的索引、切片操作。</p>
<p>因此，构造函数的实参和 <code>bytearray()</code> 相同。</p>
<ul>
<li><code>callable</code>(<em>object</em>)</li>
</ul>
<p>如果参数 <em>object</em> 是可调用的就返回 <code>True</code>，否则返回 <code>False</code>。 如果返回 <code>True</code>，调用仍可能失败，但如果返回 <code>False</code>，则调用 <em>object</em> 将肯定不会成功。 请注意类是可调用的（调用类将返回一个新的实例）；如果实例所属的类有 <code>__call__()</code> 则它就是可调用的。</p>
<p>3.2 新版功能: 这个函数一开始在 Python 3.0 被移除了，但在 Python 3.2 被重新加入。</p>
<ul>
<li><code>chr</code>(<em>i</em>)</li>
</ul>
<p>返回 Unicode 码位为整数 <em>i</em> 的字符的字符串格式。例如，<code>chr(97)</code> 返回字符串 <code>'a'</code>，<code>chr(8364)</code> 返回字符串 <code>'€'</code>。这是 <code>ord()</code> 的逆函数。</p>
<p>实参的合法范围是 0 到 1,114,111（16 进制表示是 0x10FFFF）。如果 <em>i</em> 超过这个范围，会触发 <code>ValueError</code> 异常。</p>
<ul>
<li><code>@classmethod</code></li>
</ul>
<p>把一个方法封装成类方法。</p>
<p>类方法隐含的第一个参数就是类，就像实例方法接收实例作为参数一样。要声明一个类方法，按惯例请使用以下方案：</p>
<pre><code>class C:
@classmethod
def f(cls, arg1, arg2,...):...</code></pre><p><code>@classmethod</code> 这样的形式称为函数的 decorator 。</p>
<p>类方法的调用可以在类上进行 (例如 <code>C.f()</code>) 也可以在实例上进行 (例如 <code>C().f()</code>)。 其所属类以外的类实例会被忽略。 如果类方法在其所属类的派生类上调用，则该派生类对象会被作为隐含的第一个参数被传入。</p>
<p>类方法与 C++ 或 Java 中的静态方法不同。 </p>
<p>在 3.9 版更改: 类方法现在可以包装其他 描述器 例如 <code>property()</code>。</p>
<p>在 3.10 版更改: 类方法现在继承了方法的属性（<code>__module__</code>、<code>__name__</code>、<code>__qualname__</code>、<code>__doc__</code> 和 <code>__annotations__</code>），并拥有一个新的<code>__wrapped__</code> 属性。</p>
<ul>
<li><code>compile</code>(<em>source</em>, <em>filename</em>, <em>mode</em>, <em>flags=0</em>, <em>dont_inherit=False</em>, <em>optimize=- 1</em>)</li>
</ul>
<p>将 <em>source</em> 编译成代码或 AST 对象。代码对象可以被 <code>exec()</code> 或 <code>eval()</code> 执行。<em>source</em> 可以是常规的字符串、字节字符串，或者 AST 对象。</p>
<p><em>filename</em> 实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用 <code>'&lt;string&gt;'</code>）。</p>
<p><em>mode</em> 实参指定了编译代码必须用的模式。如果 <em>source</em> 是语句序列，可以是 <code>'exec'</code>；如果是单一表达式，可以是 <code>'eval'</code>；如果是单个交互式语句，可以是 <code>'single'</code>。（在最后一种情况下，如果表达式执行结果不是 <code>None</code> 将会被打印出来。）</p>
<p>可选参数 <em>flags</em> 和 <em>dont_inherit</em> 控制应当激活哪个 编译器选项 以及应当允许哪个 future 特性。 如果两者都未提供 (或都为零) 则代码会应用与调用 <code>compile()</code> 的代码相同的旗标来编译。 如果给出了 <em>flags</em> 参数而未给出 <em>dont_inherit</em> (或者为零) 则会在无论如何都将被使用的旗标之外还会额外使用 <em>flags</em> 参数所指定的编译器选项和 future 语句。 如果 <em>dont_inherit</em> 为非零整数，则只使用 <em>flags</em> 参数 — 外围代码中的旗标 (future 特性和编译器选项) 会被忽略。</p>
<p>编译器选项和 future 语句是由比特位来指明的。 比特位可以通过一起按位 OR 来指明多个选项。 指明特定 future 特性所需的比特位可以在 <code>__future__</code> 模块的 <code>_Feature</code> 实例的 <code>compiler_flag</code> 属性中找到。 编译器旗标 可以在 <code>ast</code> 模块中查找带有 <code>PyCF_</code> 前缀的名称。</p>
<p><em>optimize</em> 实参指定编译器的优化级别；默认值 <code>-1</code> 选择与解释器的 <code>-O</code> 选项相同的优化级别。显式级别为 <code>0</code> （没有优化；<code>__debug__</code> 为真）、<code>1</code> （断言被删除， <code>__debug__</code> 为假）或 <code>2</code> （文档字符串也被删除）。</p>
<p>如果编译的源码不合法，此函数会触发 <code>SyntaxError</code> 异常；如果源码包含 null 字节，则会触发 <code>ValueError</code> 异常。</p>
<p>引发一个 审计事件<code>compile</code> 附带参数 <code>source</code>, <code>filename</code>。</p>
<p>注解</p>
<p>在 <code>'single'</code> 或 <code>'eval'</code> 模式编译多行代码字符串时，输入必须以至少一个换行符结尾。 这使 <code>code</code> 模块更容易检测语句的完整性。</p>
<p>警告</p>
<p>在将足够大或者足够复杂的字符串编译成 AST 对象时，Python 解释器有可能因为 Python AST 编译器的栈深度限制而崩溃。</p>
<p>在 3.2 版更改: Windows 和 Mac 的换行符均可使用。而且在 <code>'exec'</code> 模式下的输入不必再以换行符结尾了。另增加了 <em>optimize</em> 参数。</p>
<p>在 3.5 版更改: 之前 <em>source</em> 中包含 null 字节的话会触发 <code>TypeError</code> 异常。</p>
<p>3.8 新版功能: <code>ast.PyCF_ALLOW_TOP_LEVEL_AWAIT</code> 现在可在旗标中传入以启用对最高层级 <code>await</code>, <code>async for</code> 和 <code>async with</code> 的支持。</p>
<ul>
<li><em>class<em><code>complex</code>([</em>real</em>[, <em>imag</em>]])</li>
</ul>
<p>返回值为 <em>real</em> + <em>imag</em>j 的复数，或将字符串或数字转换为复数。如果第一个形参是字符串，则它被解释为一个复数，并且函数调用时必须没有第二个形参。第二个形参不能是字符串。每个实参都可以是任意的数值类型（包括复数）。如果省略了 <em>imag</em>，则默认值为零，构造函数会像 <code>int</code> 和 <code>float</code> 一样进行数值转换。如果两个实参都省略，则返回 <code>0j</code>。</p>
<p>对于一个普通 Python 对象 <code>x</code>，<code>complex(x)</code> 会委托给 <code>x.__complex__()</code>。 如果 <code>__complex__()</code> 未定义则将回退至 <code>__float__()</code>。 如果 <code>__float__()</code> 未定义则将回退至 <code>__index__()</code>。</p>
<p>注解</p>
<p>当从字符串转换时，字符串在 <code>+</code> 或 <code>-</code> 的周围必须不能有空格。例如 <code>complex('1+2j')</code> 是合法的，但 <code>complex('1 + 2j')</code> 会触发 <code>ValueError</code> 异常。</p>
<p>在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。</p>
<p>在 3.8 版更改: 如果 <code>__complex__()</code> 和 <code>__float__()</code> 未定义则回退至 <code>__index__()</code>。</p>
<ul>
<li><code>delattr</code>(<em>object</em>, <em>name</em>)</li>
</ul>
<p><code>setattr()</code> 相关的函数。实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。例如 <code>delattr(x, 'foobar')</code> 等价于 <code>del x.foobar</code> 。</p>
<ul>
<li><em>class<em><code>dict</code>(</em>**kwarg</em>)*</li>
<li>class<em><code>dict</code>(*mapping</em>, <em>**kwarg</em>)</li>
</ul>
<ul>
<li>class<em><code>dict</code>(*iterable</em>, <em>**kwarg</em>)</li>
</ul>
<p>创建一个新的字典。<code>dict</code> 对象是一个字典类。</p>
<ul>
<li><code>dir</code>([<em>object</em>])</li>
</ul>
<p>如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。</p>
<p>如果对象有一个名为 <code>__dir__()</code> 的方法，那么该方法将被调用，并且必须返回一个属性列表。这允许实现自定义 <code>__getattr__()</code> 或 <code>__getattribute__()</code> 函数的对象能够自定义 <code>dir()</code> 来报告它们的属性。</p>
<p>如果对象未提供 <code>__dir__()</code> 方法，该函数会尽量从对象的 <code>__dict__</code> 属性和其类型对象中收集信息。得到的列表不一定是完整，如果对象带有自定义 <code>__getattr__()</code> 方法时，结果可能不准确。</p>
<p>默认的 <code>dir()</code> 机制对不同类型的对象行为不同，它会试图返回最相关而不是最全的信息：</p>
<ul>
<li>如果对象是模块对象，则列表包含模块的属性名称。</li>
<li>如果对象是类型或类对象，则列表包含它们的属性名称，并且递归查找所有基类的属性。</li>
<li>否则，列表包含对象的属性名称，它的类属性名称，并且递归查找它的类的所有基类的属性。</li>
</ul>
<p>返回的列表按字母表排序。例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">import</span> struct
<span class="token operator">>></span><span class="token operator">></span> dir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># show the names in the module namespace  </span>
<span class="token punctuation">[</span><span class="token string">'__builtins__'</span><span class="token punctuation">,</span><span class="token string">'__name__'</span><span class="token punctuation">,</span><span class="token string">'struct'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> dir<span class="token punctuation">(</span>struct<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># show the names in the struct module </span>
<span class="token punctuation">[</span><span class="token string">'Struct'</span><span class="token punctuation">,</span><span class="token string">'__all__'</span><span class="token punctuation">,</span><span class="token string">'__builtins__'</span><span class="token punctuation">,</span><span class="token string">'__cached__'</span><span class="token punctuation">,</span><span class="token string">'__doc__'</span><span class="token punctuation">,</span><span class="token string">'__file__'</span><span class="token punctuation">,</span>
<span class="token string">'__initializing__'</span><span class="token punctuation">,</span><span class="token string">'__loader__'</span><span class="token punctuation">,</span><span class="token string">'__name__'</span><span class="token punctuation">,</span><span class="token string">'__package__'</span><span class="token punctuation">,</span>
<span class="token string">'_clearcache'</span><span class="token punctuation">,</span><span class="token string">'calcsize'</span><span class="token punctuation">,</span><span class="token string">'error'</span><span class="token punctuation">,</span><span class="token string">'pack'</span><span class="token punctuation">,</span><span class="token string">'pack_into'</span><span class="token punctuation">,</span>
<span class="token string">'unpack'</span><span class="token punctuation">,</span><span class="token string">'unpack_from'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Shape</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">def</span> __dir__<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">return</span><span class="token punctuation">[</span><span class="token string">'area'</span><span class="token punctuation">,</span><span class="token string">'perimeter'</span><span class="token punctuation">,</span><span class="token string">'location'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span>Shape<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> dir<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'area'</span><span class="token punctuation">,</span><span class="token string">'location'</span><span class="token punctuation">,</span><span class="token string">'perimeter'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>因为 <code>dir()</code> 主要是为了便于在交互式时使用，所以它会试图返回人们感兴趣的名字集合，而不是试图保证结果的严格性或一致性，它具体的行为也可能在不同版本之间改变。例如，当实参是一个类时，metaclass 的属性不包含在结果列表中。</p>
<ul>
<li><code>divmod</code>(<em>a</em>, <em>b</em>)</li>
</ul>
<p>以两个（非复数）数字为参数，在作整数除法时，返回商和余数。若操作数为混合类型，则适用二进制算术运算符的规则。对于整数而言，结果与 <code>(a // b, a % b)</code> 相同。对于浮点数则结果为<code>(q, a % b)</code>，其中 <em>q</em> 通常为 <code>math.floor(a / b)</code>，但可能比它小 1。在任何情况下，<code>q * b + a % b</code> 都非常接近 <em>a</em>，如果 <code>a % b</code> 非零，则结果符号与 <em>b</em> 相同，并且 <code>0 &lt;= abs(a % b) &lt; abs(b)</code>。</p>
<ul>
<li><code>enumerate</code>(<em>iterable</em>, <em>start=0</em>)</li>
</ul>
<p>返回一个枚举对象。<em>iterable</em> 必须是一个序列，或 iterator，或其他支持迭代的对象。 <code>enumerate()</code> 返回的迭代器的 <code>__next__()</code> 方法返回一个元组，里面包含一个计数值（从 <em>start</em> 开始，默认为 0）和通过迭代 <em>iterable</em> 获得的值。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> seasons <span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'Spring'</span><span class="token punctuation">,</span><span class="token string">'Summer'</span><span class="token punctuation">,</span><span class="token string">'Fall'</span><span class="token punctuation">,</span><span class="token string">'Winter'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>enumerate<span class="token punctuation">(</span>seasons<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'Spring'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'Summer'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'Fall'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Winter'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>enumerate<span class="token punctuation">(</span>seasons<span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'Spring'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'Summer'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Fall'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'Winter'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">enumerate</span><span class="token punctuation">(</span>sequence<span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> start
<span class="token keyword">for</span> elem <span class="token keyword">in</span> sequence<span class="token punctuation">:</span>
    <span class="token keyword">yield</span> n<span class="token punctuation">,</span> elem
    n <span class="token operator">+=</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>eval</code>(<em>expression</em>[, <em>globals</em>[, <em>locals</em>]])</li>
</ul>
<p>实参是一个字符串，以及可选的 globals 和 locals。<em>globals</em> 实参必须是一个字典。<em>locals</em> 可以是任何映射对象。</p>
<p>表达式解析参数 <em>expression</em> 并作为 Python 表达式进行求值（从技术上说是一个条件列表），采用 <em>globals</em> 和 <em>locals</em> 字典作为全局和局部命名空间。 如果存在 <em>globals</em> 字典，并且不包含 <code>__builtins__</code> 键的值，则在解析 <em>expression</em> 之前会插入以该字符串为键以对内置模块 <code>builtins</code> 的字典的引用为值的项。 这样就可以在将 <em>globals</em> 传给 <code>eval()</code> 之前通过向其传入你自己的 <code>__builtins__</code> 字典来控制可供被执行代码可以使用哪些内置模块。 如果 <em>locals</em> 字典被省略则它默认为 <em>globals</em> 字典。 如果两个字典都被省略，则将使用调用 <code>eval()</code> 的环境中的 <em>globals</em> 和 <em>locals</em> 来执行该表达式。 注意，<em>eval()</em> 无法访问闭包环境中的 嵌套作用域 (非局部变量)。</p>
<p>返回值就是表达式的求值结果。 语法错误将作为异常被报告。 例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span><span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span>eval<span class="token punctuation">(</span><span class="token string">'x+1'</span><span class="token punctuation">)</span>
<span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>该函数还可用于执行任意代码对象（比如由 <code>compile()</code> 创建的对象）。 这时传入的是代码对象，而非一个字符串了。如果代码对象已用参数为 <em>mode</em> 的 <code>'exec'</code> 进行了编译，那么 <code>eval()</code> 的返回值将为 <code>None</code>。</p>
<p>提示： <code>exec()</code> 函数支持语句的动态执行。 <code>globals()</code> 和 <code>locals()</code> 函数分别返回当前的全局和本地字典，可供传给 <code>eval()</code> 或 <code>exec()</code> 使用。</p>
<p>如果给出的源数据是个字符串，那么其前后的空格和制表符将被剔除。</p>
<p>引发一个 审计事件<code>exec</code> 附带参数 <code>code_object</code>。</p>
<ul>
<li><code>exec</code>(<em>object</em>[, <em>globals</em>[, <em>locals</em>]])</li>
</ul>
<p>这个函数支持动态执行 Python 代码。 <em>object</em> 必须是字符串或者代码对象。 如果是字符串，那么该字符串将被解析为一系列 Python 语句并执行（除非发生语法错误）。 如果是代码对象，它将被直接执行。 在任何情况下，被执行的代码都应当是有效的文件输入（见参考手册中的“文件输入”一节）。 请注意即使在传递给 <code>exec()</code> 函数的代码的上下文中，<code>nonlocal</code>, <code>yield</code> 和 <code>return</code> 语句也不能在函数定义以外使用。 该函数的返回值是 <code>None</code>。</p>
<p>无论在什么情况下，如果省略了可选部分，代码将运行于当前作用域中。如果只提供了 <em>globals*，则必须为字典对象（而不能是字典的子类），同时用于存放全局变量和局部变量。如果提供了 *globals</em> 和 <em>locals<em>，则将分别用于全局变量和局部变量。</em>locals</em> 可以是任意字典映射对象。请记住，在模块级别，globals 和 locals 是同一个字典。如果 exec 获得两个独立的对象作为 <em>globals</em> 和 <em>locals</em>，代码执行起来就像嵌入到某个类定义中一样。</p>
<p>如果 <em>globals</em> 字典不包含 <code>__builtins__</code> 键值，则将为该键插入对内建 <code>builtins</code> 模块字典的引用。因此，在将执行的代码传递给 <code>exec()</code> 之前，可以通过将自己的 <code>__builtins__</code> 字典插入到 <em>globals</em> 中来控制可以使用哪些内置代码。</p>
<p>引发一个 审计事件<code>exec</code> 附带参数 <code>code_object</code>。</p>
<p>注解</p>
<p>内置 <code>globals()</code> 和 <code>locals()</code> 函数各自返回当前的全局和本地字典，因此可以将它们传递给 <code>exec()</code> 的第二个和第三个实参。</p>
<p>注解</p>
<p>默认情况下，<em>locals</em> 的行为如下面 <code>locals()</code> 函数描述的一样：不要试图改变默认的 <em>locals</em> 字典。如果您想在 <code>exec()</code> 函数返回时知道代码对 <em>locals</em> 的变动，请明确地传递 <em>locals</em> 字典。</p>
<ul>
<li><code>filter</code>(<em>function</em>, <em>iterable</em>)</li>
</ul>
<p>用 <em>iterable</em> 中函数 <em>function</em> 返回真的那些元素，构建一个新的迭代器。<em>iterable</em> 可以是一个序列，一个支持迭代的容器，或一个迭代器。如果 <em>function</em> 是 <code>None</code> ，则会假设它是一个身份函数，即 <em>iterable</em> 中所有返回假的元素会被移除。</p>
<p>请注意， <code>filter(function, iterable)</code> 相当于一个生成器表达式，当 function 不是 <code>None</code> 的时候为 <code>(item for item in iterable if function(item))</code>；function 是 <code>None</code> 的时候为 <code>(item for item in iterable if item)</code> 。</p>
<p>请参阅 <code>itertools.filterfalse()</code> 了解，只有 <em>function</em> 返回 false 时才选取 <em>iterable</em> 中元素的补充函数。</p>
<ul>
<li><em>class</em> <code>float</code>([<em>x</em>])</li>
</ul>
<p>返回从数字或字符串 <em>x</em> 生成的浮点数。</p>
<p>如果参数是个字符串，则应包含一个十进制数字，前面可选带上符号，也可选前后带有空白符。符号可以是<code>‘+’</code> 或 <code>'-'</code>；<code>'+'</code> 符号对值没有影响。参数也可以是一个代表 NaN（非数字）或正负无穷大的字符串。更确切地说，在去除前导和尾部的空白符后，输入参数必须符合以下语法：</p>
<pre><code>sign          ::="+"|"-"
infinity      ::="Infinity"|"inf"
nan           ::="nan"
numeric_value ::=floatnumber|infinity|nan
numeric_string::=[sign]numeric_value</code></pre><p>这里的 <code>floatnumber</code> 是指 Python 的浮点数格式，在 浮点数字面值 中有介绍。大小写没有关系，所以“inf”、“Inf”、“INFINITY”、“iNfINity”都可接受为正无穷的拼写形式。</p>
<p>另一方面，如果实参是整数或浮点数，则返回具有相同值（在 Python 浮点精度范围内）的浮点数。如果实参在 Python 浮点精度范围外，则会触发 <code>OverflowError</code>。</p>
<p>对于一个普通 Python 对象 <code>x</code>，<code>float(x)</code> 会委托给 <code>x.__float__()</code>。 如果 <code>__float__()</code> 未定义则将回退至 <code>__index__()</code>。</p>
<p>如果没有实参，则返回 <code>0.0</code> 。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span>float<span class="token punctuation">(</span><span class="token string">'+1.23'</span><span class="token punctuation">)</span>
<span class="token number">1.23</span>
<span class="token operator">>></span><span class="token operator">></span>float<span class="token punctuation">(</span><span class="token string">'   -12345\n'</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token number">12345.0</span>
<span class="token operator">>></span><span class="token operator">></span>float<span class="token punctuation">(</span><span class="token string">'1e-003'</span><span class="token punctuation">)</span>
<span class="token number">0.001</span>
<span class="token operator">>></span><span class="token operator">></span>float<span class="token punctuation">(</span><span class="token string">'+1E6'</span><span class="token punctuation">)</span>
<span class="token number">1000000.0</span>
<span class="token operator">>></span><span class="token operator">></span>float<span class="token punctuation">(</span><span class="token string">'-Infinity'</span><span class="token punctuation">)</span>
<span class="token operator">-</span>inf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。</p>
<p>在 3.7 版更改: <em>x</em> 现在只能作为位置参数。</p>
<p>在 3.8 版更改: 如果 <code>__float__()</code> 未定义则回退至 <code>__index__()</code>。</p>
<ul>
<li><code>format</code>(<em>value</em>[, <em>format_spec</em>])</li>
</ul>
<p>将 <em>value</em> 转换为“格式化后”的形式，格式由 <em>format_spec</em> 进行控制。<em>format_spec</em> 的解释方式取决于 <em>value</em> 参数的类型；但大多数内置类型使用一种标准的格式化语法： 格式规格迷你语言。</p>
<p>默认的 <em>format_spec</em> 是一个空字符串，它通常给出与调用 <code>str(value)</code> 相同的结果。</p>
<p>调用 <code>format(value, format_spec)</code> 会转换成 <code>type(value).__format__(value, format_spec)</code> ，所以实例字典中的 <code>__format__()</code> 方法将不会调用。如果方法搜索回退到 <code>object</code> 类但 <em>format_spec</em> 不为空，或者如果 <em>format_spec</em> 或返回值不是字符串，则会触发 <code>TypeError</code> 异常。</p>
<p>在 3.4 版更改: 当 <em>format_spec</em> 不是空字符串时， <code>object().__format__(format_spec)</code> 会触发 <code>TypeError</code>。</p>
<ul>
<li><em>class</em> <code>frozenset</code>([<em>iterable</em>])</li>
</ul>
<p>返回一个新的 <code>frozenset</code> 对象，它包含可选参数 <em>iterable</em> 中的元素。 <code>frozenset</code> 是一个内置的类。</p>
<ul>
<li><code>getattr</code>(<em>object</em>, <em>name</em>[, <em>default</em>])</li>
</ul>
<p>返回对象命名属性的值。<em>name</em> 必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。例如， <code>getattr(x, 'foobar')</code> 等同于 <code>x.foobar</code>。如果指定的属性不存在，且提供了 <em>default</em> 值，则返回它，否则触发 <code>AttributeError</code>。</p>
<p>注解</p>
<p>由于 私有名称混合 发生在编译时，因此必须 手动混合私有属性（以两个下划线打头的属性）名称以使使用 <code>getattr()</code> 来提取它。</p>
<ul>
<li><code>globals</code>()</li>
</ul>
<p>返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。</p>
<ul>
<li><code>hasattr</code>(<em>object</em>, <em>name</em>)</li>
</ul>
<p>该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 <code>True</code>，否则返回 <code>False</code>。（此功能是通过调用 <code>getattr(object, name)</code> 看是否有 <code>AttributeError</code> 异常来实现的。）</p>
<ul>
<li><code>hash</code>(<em>object</em>)</li>
</ul>
<p>返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。</p>
<p>注解</p>
<p>如果对象实现了自己的 <code>__hash__()</code> 方法，请注意，<code>hash()</code> 根据机器的字长来截断返回值。</p>
<ul>
<li><code>help</code>([<em>object</em>])</li>
</ul>
<p>启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动交互式帮助系统。如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。如果实参是其他任意对象，则会生成该对象的帮助页。</p>
<p>请注意，如果在调用 <code>help()</code> 时，目标函数的形参列表中存在斜杠（/），则意味着斜杠之前的参数只能是位置参数。</p>
<p>该函数通过 <code>site</code> 模块加入到内置命名空间。</p>
<p>在 3.4 版更改: <code>pydoc</code> 和 <code>inspect</code> 的变更使得可调用对象的签名信息更加全面和一致。</p>
<ul>
<li><code>hex</code>(<em>x</em>)</li>
</ul>
<p>将整数转换为以“0x”为前缀的小写十六进制字符串。如果 <em>x</em> 不是 Python <code>int</code> 对象，则必须定义返回整数的 <code>__index__()</code> 方法。一些例子：</p>
<pre><code>&gt;&gt;&gt; hex(255)
'0xff'
&gt;&gt;&gt; hex(-42)
'-0x2a'</code></pre><p>如果要将整数转换为大写或小写的十六进制字符串，并可选择有无“0x”前缀，则可以使用如下方法：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token string">'%#x'</span><span class="token operator">%</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token string">'%x'</span><span class="token operator">%</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token string">'%X'</span><span class="token operator">%</span><span class="token number">255</span>
<span class="token punctuation">(</span><span class="token string">'0xff'</span><span class="token punctuation">,</span><span class="token string">'ff'</span><span class="token punctuation">,</span><span class="token string">'FF'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> format<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token string">'#x'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> format<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> format<span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token string">'X'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'0xff'</span><span class="token punctuation">,</span><span class="token string">'ff'</span><span class="token punctuation">,</span><span class="token string">'FF'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">'{255:#x}'</span><span class="token punctuation">,</span> f<span class="token string">'{255:x}'</span><span class="token punctuation">,</span> f<span class="token string">'{255:X}'</span>
<span class="token punctuation">(</span><span class="token string">'0xff'</span><span class="token punctuation">,</span><span class="token string">'ff'</span><span class="token punctuation">,</span><span class="token string">'FF'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>如果要获取浮点数的十六进制字符串形式，请使用 <code>float.hex()</code> 方法。</p>
<ul>
<li><code>id</code>(<em>object</em>)</li>
</ul>
<p>返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生命期不重叠的对象可能具有相同的 <code>id()</code> 值。</p>
<p><strong>CPython implementation detail:</strong> This is the address of the object in memory.</p>
<p>引发一个 审计事件<code>builtins.id</code>，附带参数 <code>id</code>。</p>
<ul>
<li><code>input</code>([<em>prompt</em>])</li>
</ul>
<p>如果存在 <em>prompt</em> 实参，则将其写入标准输出，末尾不带换行符。接下来，该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返回。当读取到 EOF 时，则触发 <code>EOFError</code>。例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">'--> '</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span>MontyPython's Flying Circus
<span class="token operator">>></span><span class="token operator">></span> s  
<span class="token string">"Monty Python's FlyingCircus"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果加载了 <code>readline</code> 模块，<code>input()</code> 将使用它来提供复杂的行编辑和历史记录功能。</p>
<p>引发一个 审计事件<code>builtins.input</code> 附带参数 <code>prompt</code>。</p>
<p>在成功读取输入之后引发一个审计事件 <code>builtins.input/result</code> 附带结果。</p>
<ul>
<li><p><em>class</em> <code>int</code>([<em>x</em>])</p>
</li>
<li><p><em>class</em> <code>int</code>(<em>x</em>, <em>base=10</em>)</p>
</li>
</ul>
<p>返回一个基于数字或字符串 <em>x</em> 构造的整数对象，或者在未给出参数时返回 <code>0</code>。 如果 <em>x</em> 定义了 <code>__int__()</code>，<code>int(x)</code> 将返回 <code>x.__int__()</code>。 如果 <em>x</em> 定义了 <code>__index__()</code>，它将返回 <code>x.__index__()</code>。 如果 <em>x</em> 定义了 <code>__trunc__()</code>，它将返回 <code>x.__trunc__()</code>。 对于浮点数，它将向零舍入。</p>
<p>如果 <em>x</em> 不是数字，或者有 <em>base</em> 参数，<em>x</em> 必须是字符串、<code>bytes</code>、表示进制为 <em>base</em> 的 整数字面值 的 <code>bytearray</code> 实例。该文字前可以有 <code>+</code> 或 <code>-</code> （中间不能有空格），前后可以有空格。一个进制为 n 的数字包含 0 到 n-1 的数，其中 <code>a</code> 到 <code>z</code> （或 <code>A</code> 到 <code>Z</code> ）表示 10 到 35。默认的 <em>base</em> 为 10 ，允许的进制有 0、2-36。2、8、16 进制的数字可以在代码中用 <code>0b</code>/<code>0B</code> 、 <code>0o</code>/<code>0O</code> 、 <code>0x</code>/<code>0X</code> 前缀来表示。进制为 0 将安照代码的字面量来精确解释，最后的结果会是 2、8、10、16 进制中的一个。所以 <code>int('010', 0)</code> 是非法的，但 <code>int('010')</code> 和 <code>int('010', 8)</code> 是合法的。</p>
<p>在 3.4 版更改: 如果 <em>base</em> 不是 <code>int</code> 的实例，但 <em>base</em> 对象有 <code>base.__index__</code> 方法，则会调用该方法来获取进制数。以前的版本使用 <code>base.__int__</code> 而不是 <code>base.__index__</code>。</p>
<p>在 3.6 版更改: 您可以使用下划线将代码文字中的数字进行分组。</p>
<p>在 3.7 版更改: <em>x</em> 现在只能作为位置参数。</p>
<p>在 3.8 版更改: 如果 <code>__int__()</code> 未定义则回退至 <code>__index__()</code>。</p>
<ul>
<li><code>isinstance</code>(<em>object</em>, <em>classinfo</em>)</li>
</ul>
<p>如果 <em>object</em> 参数是 <em>classinfo</em> 参数的实例，或其（直接、间接或 virtual ）子类的实例，则返回 <code>True</code>。 如果 <em>object</em> 不是给定类型的对象，则总是返回 <code>False</code>。如果 <em>classinfo</em> 是类型对象的元组（或由该类元组递归生成）或多个类型的 Union Type，那么当 <em>object</em> 是其中任一类型的实例时就会返回 <code>True</code>。如果 <em>classinfo</em> 不是某个类型或类型元组，将会触发 <code>TypeError</code> 异常。</p>
<p>在 3.10 版更改: <em>classinfo</em> 可以是一个 Union Type。</p>
<ul>
<li><code>issubclass</code>(<em>class</em>, <em>classinfo</em>)</li>
</ul>
<p>Return <code>True</code> if <em>class</em> is a subclass (direct, indirect, or virtual) of <em>classinfo</em>. A class is considered a subclass of itself. <em>classinfo</em> may be a tuple of class objects or a Union Type, in which case return <code>True</code> if <em>class</em> is a subclass of any entry in <em>classinfo</em>. In any other case, a <code>TypeError</code> exception is raised.</p>
<p>在 3.10 版更改: <em>classinfo</em> 可以是一个 Union Type。</p>
<ul>
<li><code>iter</code>(<em>object</em>[, <em>sentinel</em>])</li>
</ul>
<p>返回一个 iterator 对象。根据是否存在第二个实参，第一个实参的解释是非常不同的。如果没有第二个实参，<em>object</em> 必须是支持迭代协议（有 <code>__iter__()</code> 方法）的集合对象，或必须支持序列协议（有 <code>__getitem__()</code> 方法，且数字参数从 <code>0</code> 开始）。如果它不支持这些协议，会触发 <code>TypeError</code>。如果有第二个实参 <em>sentinel*，那么 *object</em> 必须是可调用的对象。这种情况下生成的迭代器，每次迭代调用它的 <code>__next__()</code> 方法时都会不带实参地调用 <em>object*；如果返回的结果是 *sentinel</em> 则触发 <code>StopIteration</code>，否则返回调用结果。</p>
<p>适合 <code>iter()</code> 的第二种形式的应用之一是构建块读取器。 例如，从二进制数据库文件中读取固定宽度的块，直至到达文件的末尾:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> functools importpartial
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'mydata.db'</span><span class="token punctuation">,</span><span class="token string">'rb'</span><span class="token punctuation">)</span><span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token keyword">for</span> block <span class="token keyword">in</span> iter<span class="token punctuation">(</span>partial<span class="token punctuation">(</span>f<span class="token punctuation">.</span>read<span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        process_block<span class="token punctuation">(</span>block<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>len</code>(<em>s</em>)</li>
</ul>
<p>返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）。</p>
<p><strong>CPython implementation detail:</strong><code>len</code> 对于大于 <code>sys.maxsize</code> 的长度如 <code>range(2 ** 100)</code> 会引发 <code>OverflowError</code>。</p>
<ul>
<li><em>class</em><code>list</code>([<em>iterable</em>])</li>
</ul>
<p>虽然被称为函数，<code>list</code> 实际上是一种可变序列类型。</p>
<ul>
<li><code>locals</code>()</li>
</ul>
<p>更新并返回表示当前本地符号表的字典。 在函数代码块但不是类代码块中调用 <code>locals()</code> 时将返回自由变量。 请注意在模块层级上，<code>locals()</code> 和 <code>globals()</code> 是同一个字典。</p>
<p>注解</p>
<p>不要更改此字典的内容；更改不会影响解释器使用的局部变量或自由变量的值。</p>
<ul>
<li><code>map</code>(<em>function</em>, <em>iterable</em>, <em>…</em>)</li>
</ul>
<p>返回一个将 <em>function</em> 应用于 <em>iterable</em> 中每一项并输出其结果的迭代器。 如果传入了额外的 <em>iterable</em> 参数，<em>function</em> 必须接受相同个数的实参并被应用于从所有可迭代对象中并行获取的项。 当有多个可迭代对象时，最短的可迭代对象耗尽则整个迭代就将结束。 对于函数的输入已经是参数元组的情况。</p>
<ul>
<li><p><code>max</code>(<em>iterable</em>, <em>**[,</em> key<em>,</em> default*])</p>
</li>
<li><p><code>max</code>(<em>arg1</em>, <em>arg2</em>, <em>\</em>args<em>[,</em> key*])</p>
</li>
</ul>
<p>返回可迭代对象中最大的元素，或者返回两个及以上实参中最大的。</p>
<p>如果只提供了一个位置参数，它必须是非空 iterable，返回可迭代对象中最大的元素；如果提供了两个及以上的位置参数，则返回最大的位置参数。</p>
<p>有两个可选只能用关键字的实参。<em>key</em> 实参指定排序函数用的参数，如传给 <code>list.sort()</code> 的。<em>default</em> 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 <em>default</em> ，则会触发 <code>ValueError</code>。</p>
<p>如果有多个最大元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 <code>sorted(iterable, key=keyfunc, reverse=True)[0]</code> 和 <code>heapq.nlargest(1, iterable, key=keyfunc)</code> 保持一致。</p>
<p>3.4 新版功能: keyword-only 实参 <em>default</em> 。</p>
<p>在 3.8 版更改: <em>key</em> 可以为 <code>None</code>。</p>
<ul>
<li><em>class</em> <code>memoryview</code>(<em>object</em>)</li>
</ul>
<p>返回由给定实参创建的“内存视图”对象。</p>
<ul>
<li><p><code>min</code>(<em>iterable</em>, <em>**[,</em> key<em>,</em> default*])</p>
</li>
<li><p><code>min</code>(<em>arg1</em>, <em>arg2</em>, <em>\</em>args<em>[,</em> key*])</p>
</li>
</ul>
<p>返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。</p>
<p>如果只提供了一个位置参数，它必须是 iterable，返回可迭代对象中最小的元素；如果提供了两个及以上的位置参数，则返回最小的位置参数。</p>
<p>有两个可选只能用关键字的实参。<em>key</em> 实参指定排序函数用的参数，如传给 <code>list.sort()</code> 的。<em>default</em> 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 <em>default</em> ，则会触发 <code>ValueError</code>。</p>
<p>如果有多个最小元素，则此函数将返回第一个找到的。这和其他稳定排序工具如 <code>sorted(iterable, key=keyfunc)[0]</code> 和 <code>heapq.nsmallest(1, iterable, key=keyfunc)</code> 保持一致。</p>
<p>3.4 新版功能: keyword-only 实参 <em>default</em> 。</p>
<p>在 3.8 版更改: <em>key</em> 可以为 <code>None</code>。</p>
<ul>
<li><code>next</code>(<em>iterator</em>[, <em>default</em>])</li>
</ul>
<p>通过调用 <em>iterator</em> 的 <code>__next__()</code> 方法获取下一个元素。如果迭代器耗尽，则返回给定的 <em>default</em>，如果没有默认值则触发 <code>StopIteration</code>。</p>
<ul>
<li><em>class</em><code>object</code></li>
</ul>
<p>返回一个不带特征的新对象。<code>object</code> 是所有类的基类。它带有所有 Python 类实例均通用的方法。本函数不接受任何参数。</p>
<p>注解</p>
<p>由于 <code>object</code> 没有 <code>__dict__</code>，因此无法将任意属性赋给 <code>object</code> 的实例。</p>
<ul>
<li><code>oct</code>(<em>x</em>)</li>
</ul>
<p>将一个整数转变为一个前缀为“0o”的八进制字符串。结果是一个合法的 Python 表达式。如果 <em>x</em> 不是 Python 的 <code>int</code> 对象，那它需要定义 <code>__index__()</code> 方法返回一个整数。一些例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> oct<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>
<span class="token string">'0o10'</span>
<span class="token operator">>></span><span class="token operator">></span> oct<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">56</span><span class="token punctuation">)</span>
<span class="token string">'-0o70'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>若要将整数转换为八进制字符串，并可选择是否带有“0o”前缀，可采用如下方法：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token string">'%#o'</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'%o'</span><span class="token operator">%</span><span class="token number">10</span>
<span class="token punctuation">(</span><span class="token string">'0o12'</span><span class="token punctuation">,</span><span class="token string">'12'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> format<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'#o'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> format<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'0o12'</span><span class="token punctuation">,</span><span class="token string">'12'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token string">'{10:#o}'</span><span class="token punctuation">,</span> f<span class="token string">'{10:o}'</span>
<span class="token punctuation">(</span><span class="token string">'0o12'</span><span class="token punctuation">,</span><span class="token string">'12'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><code>open</code>(<em>file</em>, <em>mode=’r’</em>, <em>buffering=- 1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>closefd=True</em>, <em>opener=None</em>)</li>
</ul>
<p>打开 <em>file</em> 并返回对应的 file object。 如果该文件不能被打开，则引发 <code>OSError</code>。 </p>
<p><em>file</em> 是一个 path-like object，表示将要打开的文件的路径（绝对路径或者相对当前工作目录的路径），也可以是要封装文件对应的整数类型文件描述符。（如果给出的是文件描述符，则当返回的 I/O 对象关闭时它也会关闭，除非将 <em>closefd</em> 设为 <code>False</code> 。）</p>
<p><em>mode</em> 是可选的字符串，用于指定打开文件的模式。默认值是 <code>'r'</code> ，表示以文本模式打开并读取文件。其他常见模式有：写入模式 <code>'w'</code> （已存在文件会被清空）、独占创建模式 <code>'x'</code> 、追加写入模式 <code>'a'</code> （在 <em>某些</em> Unix 系统中，无论当前文件指针在什么位置，<em>所有</em> 的写入操作都会追加到文件末尾）。在文本模式，如果未指定 <em>encoding</em> ，则会根据当前平台决定编码格式：调用 <code>locale.getpreferredencoding(False)</code> 获取当前地区的编码。若要读写原生字节格式，请使用二进制模式且不要指定 <em>encoding</em>。可用的模式有：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘r’</code></td>
<td align="left">读取（默认）</td>
</tr>
<tr>
<td align="left"><code>‘w’</code></td>
<td align="left">写入，并先截断文件</td>
</tr>
<tr>
<td align="left"><code>‘x’</code></td>
<td align="left">排它性创建，如果文件已存在则失败</td>
</tr>
<tr>
<td align="left"><code>‘a’</code></td>
<td align="left">打开文件用于写入，如果文件存在则在末尾追加</td>
</tr>
<tr>
<td align="left"><code>‘b’</code></td>
<td align="left">二进制模式</td>
</tr>
<tr>
<td align="left"><code>‘t’</code></td>
<td align="left">文本模式（默认）</td>
</tr>
<tr>
<td align="left"><code>‘+’</code></td>
<td align="left">打开用于更新（读取与写入）</td>
</tr>
</tbody></table>
<p>默认模式为 <code>'r'</code> （打开文件用于读取文本，与 <code>'rt'</code> 同义）。<code>'w+'</code> 和 <code>'w+b'</code> 模式将打开文件并清空内容。而 <code>'r+'</code> 和 <code>'r+b'</code> 模式将打开文件但不清空内容。</p>
<p>正如在 概述 中提到的，Python区分二进制和文本I/O。以二进制模式打开的文件（包括 <em>mode</em> 参数中的 <code>'b'</code> ）返回的内容为 <code>bytes</code> 对象，不进行任何解码。在文本模式下（默认情况下，或者在 <em>mode</em> 参数中包含 <code>'t'</code> ）时，文件内容返回为 <code>str</code> ，首先使用指定的 <em>encoding</em> （如果给定）或者使用平台默认的的字节编码解码。</p>
<p>另外还有一种模式字符 <code>'U'</code> 可用，不过它已失效，并视作弃用。以前它会在文本模式中启用 universal newlines，这在 Python 3.0 已成为默认行为。详情请参阅 newline 形参的文档。</p>
<p>注解</p>
<p>Python不依赖于底层操作系统的文本文件概念;所有处理都由Python本身完成，因此与平台无关。</p>
<p><em>buffering</em> 是一个可选的整数，用于设置缓冲策略。传递0以切换缓冲关闭（仅允许在二进制模式下），1选择行缓冲（仅在文本模式下可用），并且&gt;1的整数以指示固定大小的块缓冲区的大小（以字节为单位）。如果没有给出 <em>buffering</em> 参数，则默认缓冲策略的工作方式如下:</p>
<ul>
<li>二进制文件以固定大小的块进行缓冲；使用启发式方法选择缓冲区的大小，尝试确定底层设备的“块大小”或使用 <code>io.DEFAULT_BUFFER_SIZE</code>。在许多系统上，缓冲区的长度通常为4096或8192字节。</li>
<li>“交互式”文本文件（ <code>isatty()</code> 返回 <code>True</code> 的文件）使用行缓冲。其他文本文件使用上述策略用于二进制文件。</li>
</ul>
<p><em>encoding</em> 是用于解码或编码文件的编码的名称。这应该只在文本模式下使用。默认编码是依赖于平台的（不 管 <code>locale.getpreferredencoding()</code> 返回何值），但可以使用任何Python支持的 text encoding 。有关支持的编码列表，请参阅 <code>codecs</code> 模块。</p>
<p><em>errors</em> 是一个可选的字符串参数，用于指定如何处理编码和解码错误 - 这不能在二进制模式下使用。可以使用各种标准错误处理程序，但是使用 <code>codecs.register_error()</code> 注册的任何错误处理名称也是有效的。标准名称包括:</p>
<ul>
<li>如果存在编码错误，<code>'strict'</code> 会引发 <code>ValueError</code> 异常。 默认值 <code>None</code> 具有相同的效果。</li>
<li><code>'ignore'</code> 忽略错误。请注意，忽略编码错误可能会导致数据丢失。</li>
<li><code>'replace'</code> 会将替换标记（例如 <code>'?'</code> ）插入有错误数据的地方。</li>
<li><code>'surrogateescape'</code> 将把任何不正确的字节表示为 U+DC80 至 U+DCFF 范围内的下方替代码位。 当在写入数据时使用 <code>surrogateescape</code> 错误处理句柄时这些替代码位会被转回到相同的字节。 这适用于处理具有未知编码格式的文件。</li>
<li>只有在写入文件时才支持 <code>'xmlcharrefreplace'</code>。编码不支持的字符将替换为相应的XML字符引用 <code>&amp;#nnn;</code>。</li>
<li><code>'backslashreplace'</code> 用Python的反向转义序列替换格式错误的数据。</li>
<li><code>'namereplace'</code> （也只在编写时支持）用 <code>\N{...}</code> 转义序列替换不支持的字符。</li>
</ul>
<p><em>newline</em> 控制 universal newlines 模式如何生效（它仅适用于文本模式）。它可以是 <code>None</code>，<code>''</code>，<code>'\n'</code>，<code>'\r'</code> 和 <code>'\r\n'</code>。它的工作原理:</p>
<ul>
<li>从流中读取输入时，如果 <em>newline</em> 为 <code>None</code>，则启用通用换行模式。输入中的行可以以 <code>'\n'</code>，<code>'\r'</code> 或 <code>'\r\n'</code> 结尾，这些行被翻译成 <code>'\n'</code> 在返回呼叫者之前。如果它是 <code>''</code>，则启用通用换行模式，但行结尾将返回给调用者未翻译。如果它具有任何其他合法值，则输入行仅由给定字符串终止，并且行结尾将返回给未调用的调用者。</li>
<li>将输出写入流时，如果 <em>newline</em> 为 <code>None</code>，则写入的任何 <code>'\n'</code> 字符都将转换为系统默认行分隔符 <code>os.linesep</code>。如果 <em>newline</em> 是 <code>''</code> 或 <code>'\n'</code>，则不进行翻译。如果 <em>newline</em> 是任何其他合法值，则写入的任何 <code>'\n'</code> 字符将被转换为给定的字符串。</li>
</ul>
<p>如果 <em>closefd</em> 为 <code>False</code> 且给出的不是文件名而是文件描述符，那么当文件关闭时，底层文件描述符将保持打开状态。如果给出的是文件名，则 <em>closefd</em> 必须为 <code>True</code> （默认值），否则将触发错误。</p>
<p>可以通过传递可调用的 <em>opener</em> 来使用自定义开启器。然后通过使用参数（ <em>file<em>，</em>flags</em> ）调用 <em>opener</em> 获得文件对象的基础文件描述符。 <em>opener</em> 必须返回一个打开的文件描述符（使用 <code>os.open</code> as <em>opener</em> 时与传递 <code>None</code> 的效果相同）。</p>
<p>新创建的文件是 不可继承的。</p>
<p>下面的示例使用 <code>os.open()</code> 函数的 dir_fd 的形参，从给定的目录中用相对路径打开文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> dir_fd <span class="token operator">=</span> os<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'somedir'</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_RDONLY<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">def</span> opener<span class="token punctuation">(</span>path<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">return</span> os<span class="token punctuation">.</span>open<span class="token punctuation">(</span>path<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> dir_fd<span class="token operator">=</span>dir_fd<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'spamspam.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span> opener<span class="token operator">=</span>opener<span class="token punctuation">)</span><span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'This will be written to somedir/spamspam.txt'</span><span class="token punctuation">,</span> file<span class="token operator">=</span>f<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>close<span class="token punctuation">(</span>dir_fd<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># don't leak a file descriptor</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>open()</code> 函数所返回的 file object 类型取决于所用模式。 当使用 <code>open()</code> 以文本模式 (<code>'w'</code>, <code>'r'</code>, <code>'wt'</code>, <code>'rt'</code> 等) 打开文件时，它将返回 <code>io.TextIOBase</code> (特别是 <code>io.TextIOWrapper</code>) 的一个子类。 当使用缓冲以二进制模式打开文件时，返回的类是 <code>io.BufferedIOBase</code> 的一个子类。 具体的类会有多种：在只读的二进制模式下，它将返回 <code>io.BufferedReader</code>；在写入二进制和追加二进制模式下，它将返回 <code>io.BufferedWriter</code>，而在读/写模式下，它将返回 <code>io.BufferedRandom</code>。 当禁用缓冲时，则会返回原始流，即 <code>io.RawIOBase</code> 的一个子类 <code>io.FileIO</code>。</p>
<p>引发一个 审计事件<code>open</code> 附带参数 <code>file</code>, <code>mode</code>, <code>flags</code>。</p>
<p><code>mode</code> 与 <code>flags</code> 参数可以在原始调用的基础上被修改或传递。</p>
<blockquote>
<p>在 3.3 版更改:</p>
<ul>
<li>增加了 <em>opener</em> 形参。</li>
<li>增加了 <code>'x'</code> 模式。</li>
<li>过去触发的 <code>IOError</code>，现在是 <code>OSError</code> 的别名。</li>
<li>如果文件已存在但使用了排它性创建模式（ <code>'x'</code> ），现在会触发 <code>FileExistsError</code>。</li>
</ul>
<p>在 3.4 版更改:</p>
<ul>
<li>文件现在禁止继承。</li>
</ul>
</blockquote>
<p>Deprecated since version 3.4, removed in version 3.10: <code>'U'</code> 模式。</p>
<blockquote>
<p>在 3.5 版更改:</p>
<ul>
<li>如果系统调用被中断，但信号处理程序没有触发异常，此函数现在会重试系统调用，而不是触发 <code>InterruptedError</code> 异常 (原因详见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>)。</li>
<li>增加了 <code>'namereplace'</code> 错误处理接口。</li>
</ul>
<p>在 3.6 版更改:</p>
<ul>
<li>增加对实现了 <code>os.PathLike</code> 对象的支持。</li>
<li>在 Windows 上，打开一个控制台缓冲区将返回 <code>io.RawIOBase</code> 的子类，而不是 <code>io.FileIO</code>。</li>
</ul>
</blockquote>
<ul>
<li><code>ord</code>(<em>c</em>)</li>
</ul>
<p>对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。例如 <code>ord('a')</code> 返回整数 <code>97</code>， <code>ord('€')</code> （欧元符号）返回 <code>8364</code> 。这是 <code>chr()</code> 的逆函数。</p>
<ul>
<li><code>pow</code>(<em>base</em>, <em>exp</em>[, <em>mod</em>])</li>
</ul>
<p>返回 <em>base</em> 的 <em>exp</em> 次幂；如果 <em>mod</em> 存在，则返回 <em>base</em> 的 <em>exp</em> 次幂对 <em>mod</em> 取余（比 <code>pow(base, exp) % mod</code> 更高效）。 两参数形式 <code>pow(base, exp)</code> 等价于乘方运算符: <code>base**exp</code>。</p>
<p>The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For <code>int</code> operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, <code>pow(10, 2)</code> returns <code>100</code>, but <code>pow(10, -2)</code> returns <code>0.01</code>.</p>
<p>对于 <code>int</code> 操作数 <em>base</em> 和 <em>exp<em>，如果给出 *mod</em>，则 *mod</em> 必须为整数类型并且 <em>mod</em> 必须不为零。 如果给出 <em>mod</em> 并且 <em>exp</em> 为负值，则 <em>base</em> 必须相对于 <em>mod</em> 不可整除。 在这种情况下，将会返回 <code>pow(inv_base, -exp, mod)</code>，其中 <em>inv_base</em> 为 <em>base</em> 的倒数对 <em>mod</em> 取余。</p>
<p>下面的例子是 <code>38</code> 的倒数对 <code>97</code> 取余:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pow<span class="token punctuation">(</span><span class="token number">38</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> mod<span class="token operator">=</span><span class="token number">97</span><span class="token punctuation">)</span>
<span class="token number">23</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token number">23</span><span class="token operator">*</span><span class="token number">38</span><span class="token operator">%</span><span class="token number">97</span><span class="token operator">==</span><span class="token number">1</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.8 版更改: 对于 <code>int</code> 操作数，三参数形式的 <code>pow</code> 现在允许第二个参数为负值，即可以计算倒数的余数。</p>
<p>在 3.8 版更改: 允许关键字参数。 之前只支持位置参数。</p>
<ul>
<li><code>print</code>(<em>\</em>objects<em>,</em> sep=’ ‘<em>,</em> end=’\n’<em>,</em> file=sys.stdout<em>,</em> flush=False*)</li>
</ul>
<p>将 <em>objects</em> 打印输出至 <em>file</em> 指定的文本流，以 <em>sep</em> 分隔并在末尾加上 <em>end*。 *sep</em> 、 <em>end</em> 、 <em>file</em> 和 <em>flush</em> 必须以关键字参数的形式给出。</p>
<p>所有非关键字参数都会被转换为字符串，就像是执行了 <code>str()</code> 一样，并会被写入到流，以 <em>sep</em> 且在末尾加上 <em>end*。 *sep</em> 和 <em>end</em> 都必须为字符串；它们也可以为 <code>None</code>，这意味着使用默认值。 如果没有给出 <em>objects</em>，则 <code>print()</code> 将只写入 <em>end</em>。</p>
<p><em>file</em> 参数必须是一个具有 <code>write(string)</code> 方法的对象；如果参数不存在或为 <code>None</code>，则将使用 <code>sys.stdout</code>。 由于要打印的参数会被转换为文本字符串，因此 <code>print()</code> 不能用于二进制模式的文件对象。 对于这些对象，应改用 <code>file.write(...)</code>。</p>
<p>输出是否缓存通常取决于 <em>file*，但如果 *flush</em> 关键字参数为 True，输出流会被强制刷新。</p>
<p>在 3.3 版更改: 增加了 <em>flush</em> 关键字参数。</p>
<ul>
<li><em>class</em> <code>property</code>(<em>fget=None</em>, <em>fset=None</em>, <em>fdel=None</em>, <em>doc=None</em>)</li>
</ul>
<p>返回 property 属性。</p>
<p><em>fget</em> 是获取属性值的函数。 <em>fset</em> 是用于设置属性值的函数。 <em>fdel</em> 是用于删除属性值的函数。并且 <em>doc</em> 为属性对象创建文档字符串。</p>
<p>一个典型的用法是定义一个托管属性 <code>x</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>_x <span class="token operator">=</span>None
<span class="token keyword">def</span> <span class="token function">getx</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> self<span class="token punctuation">.</span>_x
<span class="token keyword">def</span> <span class="token function">setx</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>_x <span class="token operator">=</span> value
<span class="token keyword">def</span> <span class="token function">delx</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    delself<span class="token punctuation">.</span>_x
    x <span class="token operator">=</span>property<span class="token punctuation">(</span>getx<span class="token punctuation">,</span> setx<span class="token punctuation">,</span> delx<span class="token punctuation">,</span><span class="token string">"I'm the 'x' property."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>c</em> 为 <em>C</em> 的实例，<code>c.x</code> 将调用 getter，<code>c.x = value</code> 将调用 setter， <code>del c.x</code> 将调用 deleter。</p>
<p>如果给出，<em>doc</em> 将成为该 property 属性的文档字符串。 否则该 property 将拷贝 <em>fget</em> 的文档字符串（如果存在）。 这令使用 <code>property()</code> 作为 decorator 来创建只读的特征属性可以很容易地实现:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Parrot</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>_voltage <span class="token operator">=</span><span class="token number">100000</span>
@property
<span class="token keyword">def</span> <span class="token function">voltage</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Get the current voltage."""</span>
    <span class="token keyword">return</span> self<span class="token punctuation">.</span>_voltage<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上 <code>@property</code> 装饰器会将 <code>voltage()</code> 方法转化为一个具有相同名称的只读属性的 “getter”，并将 <em>voltage</em> 的文档字符串设置为 “Get the current voltage.”</p>
<p>特征属性对象具有 <code>getter</code>, <code>setter</code> 以及 <code>deleter</code> 方法，它们可用作装饰器来创建该特征属性的副本，并将相应的访问函数设为所装饰的函数。 这最好是用一个例子来解释:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>_x <span class="token operator">=</span>None
@property
<span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""I'm the 'x' property."""</span>
    <span class="token keyword">return</span> self<span class="token punctuation">.</span>_x
@x<span class="token punctuation">.</span>setter
<span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
    self<span class="token punctuation">.</span>_x <span class="token operator">=</span> value
@x<span class="token punctuation">.</span>deleter
<span class="token keyword">def</span> <span class="token function">x</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    delself<span class="token punctuation">.</span>_x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述代码与第一个例子完全等价。 注意一定要给附加函数与原始的特征属性相同的名称 (在本例中为 <code>x</code>。)</p>
<p>返回的特征属性对象同样具有与构造器参数相对应的属性 <code>fget</code>, <code>fset</code> 和 <code>fdel</code>。</p>
<p>在 3.5 版更改: 特征属性对象的文档字符串现在是可写的。</p>
<ul>
<li><p><em>class<em><code>range</code>(</em>stop</em>)</p>
</li>
<li><p><em>class<em><code>range</code>(</em>start</em>, <em>stop</em>[, <em>step</em>])</p>
</li>
</ul>
<p>虽然被称为函数，但 <code>range</code> 实际上是一个不可变的序列类型。</p>
<ul>
<li><code>repr</code>(<em>object</em>)</li>
</ul>
<p>返回对象的可打印形式字符串。对于很多类型而言，本函数试图返回的字符串，会与将对象传给 <code>eval()</code> 所生成的结果相同；不然，结果就是一个尖括号包裹的字符串，包含了对象类型名称及其附加信息，附加信息通常包括对象的名称和内存地址。通过定义 <code>__repr__()</code> 方法，类可以控制本函数将为实例返回的内容。</p>
<ul>
<li><code>reversed</code>(<em>seq</em>)</li>
</ul>
<p>返回一个反向的 iterator。 <em>seq</em> 必须是一个具有 <code>__reversed__()</code> 方法的对象或者是支持该序列协议（具有从 <code>0</code> 开始的整数类型参数的 <code>__len__()</code> 方法和 <code>__getitem__()</code> 方法）。</p>
<ul>
<li><code>round</code>(<em>number</em>[, <em>ndigits</em>])</li>
</ul>
<p>返回 <em>number</em> 舍入到小数点后 <em>ndigits</em> 位精度的值。 如果 <em>ndigits</em> 被省略或为 <code>None</code>，则返回最接近输入值的整数。</p>
<p>对于支持 <code>round()</code> 方法的内置类型，结果值会舍入至最接近的 10 的负 <em>ndigits</em> 次幂的倍数；如果与两个倍数同样接近，则选用偶数。因此，<code>round(0.5)</code> 和 <code>round(-0.5)</code> 均得出 <code>0</code> 而 <code>round(1.5)</code> 则为 <code>2</code>。<em>ndigits</em> 可为任意整数值（正数、零或负数）。如果省略了 <em>ndigits</em> 或为 <code>None</code> ，则返回值将为整数。否则返回值与 <em>number</em> 的类型相同。</p>
<p>对于一般的 Python 对象 <code>number</code>, <code>round</code> 将委托给 <code>number.__round__</code>。</p>
<p>注解</p>
<p>对浮点数执行 <code>round()</code> 的行为可能会令人惊讶：例如，<code>round(2.675, 2)</code> 将给出 <code>2.67</code> 而不是期望的 <code>2.68</code>。 这不算是程序错误：这一结果是由于大多数十进制小数实际上都不能以浮点数精确地表示。 </p>
<ul>
<li><em>class</em><code>set</code>([<em>iterable</em>])</li>
</ul>
<p>返回一个新的 <code>set</code> 对象，可以选择带有从 <em>iterable</em> 获取的元素。 <code>set</code> 是一个内置类型。</p>
<ul>
<li><code>setattr</code>(<em>object</em>, <em>name</em>, <em>value</em>)</li>
</ul>
<p>本函数与 <code>getattr()</code> 相对应。其参数为一个对象、一个字符串和一个任意值。字符串可以为某现有属性的名称，或为新属性。只要对象允许，函数会将值赋给属性。如 <code>setattr(x, 'foobar', 123)</code> 等价于 <code>x.foobar = 123</code>。</p>
<p>注解</p>
<p>由于 私有名称混合 发生在编译时，因此必须手动混合私有属性（以两个下划线打头的属性）名称以便使用 <code>setattr()</code> 来设置它。</p>
<ul>
<li><p><em>class<em><code>slice</code>(</em>stop</em>)</p>
</li>
<li><p><em>class<em><code>slice</code>(</em>start</em>, <em>stop</em>[, <em>step</em>])</p>
</li>
</ul>
<p>返回一个 slice 对象，代表由 <code>range(start, stop, step)</code> 指定索引集的切片。 其中参数 <em>start</em> 和 <em>step</em> 的默认值为 <code>None</code>。切片对象具有只读数据属性 <code>start</code> 、<code>stop</code> 和 <code>step</code>，只是返回对应的参数值（或默认值）。这几个属性没有其他明确的功能；不过 NumPy 和其他第三方扩展会用到。在使用扩展索引语法时，也会生成切片对象。例如： <code>a[start:stop:step]</code> 或 <code>a[start:stop, i]</code>。 另一种方案是返回迭代器对象。</p>
<ul>
<li><code>sorted</code>(<em>iterable</em>, <em>**,</em> key=None<em>,</em> reverse=False*)</li>
</ul>
<p>根据 <em>iterable</em> 中的项返回一个新的已排序列表。</p>
<p>具有两个可选参数，它们都必须指定为关键字参数。</p>
<p><em>key</em> 指定带有单个参数的函数，用于从 <em>iterable</em> 的每个元素中提取用于比较的键 (例如 <code>key=str.lower</code>)。 默认值为 <code>None</code> (直接比较元素)。</p>
<p><em>reverse</em> 为一个布尔值。 如果设为 <code>True</code>，则每个列表元素将按反向顺序比较进行排序。</p>
<p>使用 <code>functools.cmp_to_key()</code> 可将老式的 <em>cmp</em> 函数转换为 <em>key</em> 函数。</p>
<p>内置的 <code>sorted()</code> 确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 —- 这有利于进行多重排序（例如先按部门、再按薪级排序）。</p>
<p>The sort algorithm uses only <code>&lt;</code> comparisons between items. While defining an <code>__lt__()</code> method will suffice for sorting, <a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener"><strong>PEP 8</strong></a> recommends that all six rich comparisons be implemented. This will help avoid bugs when using the same data with other ordering tools such as <code>max()</code> that rely on a different underlying method. Implementing all six comparisons also helps avoid confusion for mixed type comparisons which can call reflected the <code>__gt__()</code> method.</p>
<ul>
<li><code>@staticmethod</code></li>
</ul>
<p>将方法转换为静态方法。</p>
<p>静态方法不会接收隐式的第一个参数。要声明一个静态方法，请使用此语法</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
@staticmethod
<span class="token keyword">def</span> <span class="token function">f</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>@staticmethod</code> 这样的形式称为函数的 decorator 。</p>
<p>静态方法既可以由类中调用（如 <code>C.f()</code>），也可以由实例中调用（如```C().f()<code>）。此外，还可以作为普通的函数进行调用（如</code>f()``）。</p>
<p>Python 的静态方法与 Java 或 C++ 类似。，可用于创建另一种类构造函数。</p>
<p>像所有装饰器一样，也可以像常规函数一样调用 <code>staticmethod</code> ，并对其结果执行某些操作。比如某些情况下需要从类主体引用函数并且您希望避免自动转换为实例方法。对于这些情况，请使用此语法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">regular_function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
    method <span class="token operator">=</span> staticmethod<span class="token punctuation">(</span>regular_function<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.10 版更改: 静态方法继承了方法的多个属性（<code>__module__</code>、<code>__name__</code>、<code>__qualname__</code>、<code>__doc__</code> 和 <code>__annotations__</code>），还拥有一个新的<code>__wrapped__</code> 属性，并且现在还可以作为普通函数进行调用。</p>
<ul>
<li><p><em>class<em><code>str</code>(</em>object=’’</em>)</p>
</li>
<li><p><em>class<em><code>str</code>(</em>object=b’’</em>, <em>encoding=’utf-8’</em>, <em>errors=’strict’</em>)</p>
</li>
</ul>
<p>返回一个 <code>str</code> 版本的 <em>object</em> 。</p>
<p><code>str</code> 是内置字符串 class 。</p>
<ul>
<li><code>sum</code>(<em>iterable</em>, <em>/</em>, <em>start=0</em>)</li>
</ul>
<p>从 <em>start</em> 开始自左向右对 <em>iterable</em> 的项求和并返回总计值。 <em>iterable</em> 的项通常为数字，而 start 值则不允许为字符串。</p>
<p>对某些用例来说，存在 <code>sum()</code> 的更好替代。 拼接字符串序列的更好更快方式是调用 <code>''.join(sequence)</code>。 </p>
<p>在 3.8 版更改: <em>start</em> 形参可用关键字参数形式来指定。</p>
<ul>
<li><em>class<em><code>super</code>([</em>type</em>[, <em>object-or-type</em>]])</li>
</ul>
<p>返回一个代理对象，它会将方法调用委托给 <em>type</em> 的父类或兄弟类。 这对于访问已在类中被重载的继承方法很有用。</p>
<p><em>object-or-type</em> 确定用于搜索的 method resolution order。 搜索会从 <em>type</em> 之后的类开始。</p>
<p>举例来说，如果 <em>object-or-type</em> 的 <code>__mro__</code> 为 <code>D -&gt; B -&gt; C -&gt; A -&gt; object</code> 并且 <em>type</em> 的值为 <code>B</code>，则 <code>super()</code> 将会搜索 <code>C -&gt; A -&gt; object</code>。</p>
<p><em>object-or-type</em> 的 <code>__mro__</code> 属性列出了 <code>getattr()</code> 和 <code>super()</code> 所共同使用的方法解析搜索顺序。 该属性是动态的，可以在任何继承层级结构发生更新的时候被改变。</p>
<p>如果省略第二个参数，则返回的超类对象是未绑定的。 如果第二个参数为一个对象，则 <code>isinstance(obj, type)</code> 必须为真值。 如果第二个参数为一个类型，则 <code>issubclass(type2, type)</code> 必须为真值（这适用于类方法）。</p>
<p><em>super</em> 有两个典型用例。 在具有单继承的类层级结构中，<em>super</em> 可用来引用父类而不必显式地指定它们的名称，从而令代码更易维护。 这种用法与其他编程语言中 <em>super</em> 的用法非常相似。</p>
<p>第二个用例是在动态执行环境中支持协作多重继承。 此用例为 Python 所独有而不存在于静态编码语言或仅支持单继承的语言当中。 这使用实现“菱形图”成为可能，即有多个基类实现相同的方法。 好的设计强制要求这样的方法在每个情况下都具有相同的调用签名（因为调用顺序是在运行时确定的，也因为这个顺序要适应类层级结构的更改，还因为这个顺序可能包括在运行时之前未知的兄弟类）。</p>
<p>对于以上两个用例，典型的超类调用看起来是这样的:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">method</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">:</span>
super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>method<span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># This does the same thing as:</span>
<span class="token comment" spellcheck="true"># super(C, self).method(arg)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了方法查找之外，<code>super()</code> 也可用于属性查找。 一个可能的应用场合是在上级或同级类中调用 描述器。</p>
<p>请注意 <code>super()</code> 是作为显式加点属性查找的绑定过程的一部分来实现的，例如 <code>super().__getitem__(name)</code>。 它做到这一点是通过实现自己的 <code>__getattribute__()</code> 方法，这样就能以可预测的顺序搜索类，并且支持协作多重继承。 对应地，<code>super()</code> 在像 <code>super()[name]</code> 这样使用语句或操作符进行隐式查找时则未被定义。</p>
<p>还要注意的是，除了零个参数的形式以外，<code>super()</code> 并不限于在方法内部使用。 两个参数的形式明确指定参数并进行相应的引用。 零个参数的形式仅适用于类定义内部，因为编译器需要填入必要的细节以正确地检索到被定义的类，还需要让普通方法访问当前实例。</p>
<p>对于有关如何使用 <code>super()</code> 来如何设计协作类的实用建议。</p>
<ul>
<li><em>class</em><code>tuple</code>([<em>iterable</em>])</li>
</ul>
<p>虽然被称为函数，但 <code>tuple</code> 实际上是一个不可变的序列类型</p>
<ul>
<li><p><em>class<em><code>type</code>(</em>object</em>)</p>
</li>
<li><p><em>class<em><code>type</code>(</em>name</em>, <em>bases</em>, <em>dict</em>, <em>**kwds</em>)</p>
</li>
</ul>
<p>传入一个参数时，返回 <em>object</em> 的类型。 返回值是一个 type 对象，通常与 <code>object.__class__</code> 所返回的对象相同。</p>
<p>推荐使用 <code>isinstance()</code> 内置函数来检测对象的类型，因为它会考虑子类的情况。</p>
<p>传入三个参数时，返回一个新的 type 对象。 这在本质上是 <code>class</code> 语句的一种动态形式，<em>name</em> 字符串即类名并会成为 <code>__name__</code> 属性；<em>bases</em> 元组包含基类并会成为 <code>__bases__</code> 属性；如果为空则会添加所有类的终极基类 <code>object</code>。 <em>dict</em> 字典包含类主体的属性和方法定义；它在成为 <code>__dict__</code> 属性之前可能会被拷贝或包装。 下面两条语句会创建相同的 <code>type</code> 对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     a <span class="token operator">=</span><span class="token number">1</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> X <span class="token operator">=</span> type<span class="token punctuation">(</span><span class="token string">'X'</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dict<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>提供给三参数形式的关键字参数会被传递给适当的元类机制 (通常为 <code>__init_subclass__()</code>)，相当于类定义中关键字 (除了 <em>metaclass</em>) 的行为方式。</p>
<p>在 3.6 版更改: <code>type</code> 的子类如果未重载 <code>type.__new__</code>，将不再能使用一个参数的形式来获取对象的类型。</p>
<ul>
<li><code>vars</code>([<em>object</em>])</li>
</ul>
<p>返回模块、类、实例或任何其它具有 <code>__dict__</code> 属性的对象的 <code>__dict__</code> 属性。</p>
<p>模块和实例这样的对象具有可更新的 <code>__dict__</code> 属性；但是，其它对象的 <code>__dict__</code> 属性可能会设为限制写入（例如，类会使用 <code>types.MappingProxyType</code> 来防止直接更新字典）。</p>
<p>不带参数时，<code>vars()</code> 的行为类似 <code>locals()</code>。 请注意，locals 字典仅对于读取起作用，因为对 locals 字典的更新会被忽略。</p>
<p>如果指定了一个对象但它没有 <code>__dict__</code> 属性（例如，当它所属的类定义了 <code>__slots__</code> 属性时）则会引发 <code>TypeError</code> 异常。</p>
<ul>
<li><code>zip</code>(<em>\</em>iterables<em>,</em> strict=False*)</li>
</ul>
<p>在多个迭代器上并行迭代，从每个迭代器返回一个数据项组成元组。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">for</span> item <span class="token keyword">in</span> zip<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'sugar'</span><span class="token punctuation">,</span><span class="token string">'spice'</span><span class="token punctuation">,</span><span class="token string">'everything nice'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'sugar'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'spice'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'everything nice'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>更正式的说法： <code>zip()</code> 返回元组的迭代器，其中第 <em>i</em> 个元组包含的是每个参数迭代器的第 <em>i</em> 个元素。</p>
<p>不妨换一种方式认识 <code>zip()</code> ：它会把行变成列，把列变成行。这类似于 矩阵转置 。</p>
<p><code>zip()</code> 是延迟执行的：直至迭代时才会对元素进行处理，比如 <code>for</code> 循环或放入 <code>list</code> 中。</p>
<p>值得考虑的是，传给 <code>zip()</code> 的可迭代对象可能长度不同；有时是有意为之，有时是因为准备这些对象的代码存在错误。Python 提供了三种不同的处理方案：</p>
<ul>
<li><p>默认情况下，<code>zip()</code> 在最短的迭代完成后停止。较长可迭代对象中的剩余项将被忽略，结果会裁切至最短可迭代对象的长度：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'fee'</span><span class="token punctuation">,</span><span class="token string">'fi'</span><span class="token punctuation">,</span><span class="token string">'fo'</span><span class="token punctuation">,</span><span class="token string">'fum'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'fee'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'fi'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'fo'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>通常 <code>zip()</code> 用于可迭代对象等长的情况下。这时建议用 <code>strict=True</code> 的选项。输出与普通的 <code>zip()</code> 相同：。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>zip<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> strict<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>与默认行为不同的是，它会检查可迭代对象的长度是否相同，如果不相同则触发 <code>ValueError</code> 。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'fee'</span><span class="token punctuation">,</span><span class="token string">'fi'</span><span class="token punctuation">,</span><span class="token string">'fo'</span><span class="token punctuation">,</span><span class="token string">'fum'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> strict<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Traceback<span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ValueError<span class="token punctuation">:</span> zip<span class="token punctuation">(</span><span class="token punctuation">)</span> argument 2is longer than argument <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果未指定 <code>strict=True</code> 参数，所有导致可迭代对象长度不同的错误都会被抑制，这可能会在程序的其他地方表现为难以发现的错误。</p>
</li>
<li><p>为了让所有的可迭代对象具有相同的长度，长度较短的可用常量进行填充。这可由 <code>itertools.zip_longest()</code> 来完成。</p>
</li>
</ul>
<p>极端例子是只有一个可迭代对象参数，<code>zip()</code> 会返回一个一元组的迭代器。如果未给出参数，则返回一个空的迭代器。</p>
<p>小技巧：</p>
<ul>
<li><p>可确保迭代器的求值顺序是从左到右的。这样就能用 <code>zip(*[iter(s)]*n, strict=True)</code> 将数据列表按长度 n 进行分组。这将重复 <em>相同</em> 的迭代器 <code>n</code> 次，输出的每个元组都包含 <code>n</code> 次调用迭代器的结果。这样做的效果是把输入拆分为长度为 n 的块。</p>
</li>
<li><p><code>zip()</code> 与 <code>*</code> 运算符相结合可以用来拆解一个列表:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>zip<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> x2<span class="token punctuation">,</span> y2 <span class="token operator">=</span> zip<span class="token punctuation">(</span><span class="token operator">*</span>zip<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">==</span> list<span class="token punctuation">(</span>x2<span class="token punctuation">)</span> <span class="token operator">and</span> y <span class="token operator">==</span> list<span class="token punctuation">(</span>y2<span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<p>在 3.10 版更改: 增加了 <code>strict</code> 参数。</p>
<ul>
<li><code>__import__</code>(<em>name</em>, <em>globals=None</em>, <em>locals=None</em>, <em>fromlist=()</em>, <em>level=0</em>)</li>
</ul>
<p>注解</p>
<p>与 <code>importlib.import_module()</code> 不同，这是一个日常 Python 编程中不需要用到的高级函数。</p>
<p>此函数会由 <code>import</code> 语句发起调用。 它可以被替换 (通过导入 <code>builtins</code> 模块并赋值给 <code>builtins.__import__</code>) 以便修改 <code>import</code> 语句的语义，但是 <strong>强烈</strong> 不建议这样做，因为使用导入钩子 (参见 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a>) 通常更容易实现同样的目标，并且不会导致代码问题，因为许多代码都会假定所用的是默认实现。 同样也不建议直接使用 <code>__import__()</code> 而应该用 <code>importlib.import_module()</code>。</p>
<p>本函数会导入模块 <em>name*，利用 *globals</em> 和 <em>locals</em> 来决定如何在包的上下文中解释该名称。<em>fromlist</em> 给出了应从 <em>name</em> 模块中导入的对象或子模块的名称。标准的实现代码完全不会用到 <em>locals</em> 参数，只用到了 <em>globals</em> 用于确定 <code>import</code> 语句所在的包上下文。</p>
<p><em>level</em> 指定是使用绝对还是相对导入。 <code>0</code> (默认值) 意味着仅执行绝对导入。 <em>level</em> 为正数值表示相对于模块调用 <code>__import__()</code> 的目录，将要搜索的父目录层数 (详情参见 <a href="https://www.python.org/dev/peps/pep-0328" target="_blank" rel="noopener"><strong>PEP 328</strong></a>)。</p>
<p>当 <em>name</em> 变量的形式为 <code>package.module</code> 时，通常将会返回最高层级的包（第一个点号之前的名称），而 <em>不是</em> 以 <em>name</em> 命名的模块。 但是，当给出了非空的 <em>fromlist</em> 参数时，则将返回以 <em>name</em> 命名的模块。</p>
<p>例如，语句 <code>import spam</code> 的结果将为与以下代码作用相同的字节码:</p>
<pre class="line-numbers language-python"><code class="language-python">spam <span class="token operator">=</span> __import__<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">,</span> globals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>语句 <code>import spam.ham</code> 的结果将为以下调用:</p>
<pre class="line-numbers language-python"><code class="language-python">spam <span class="token operator">=</span> __import__<span class="token punctuation">(</span><span class="token string">'spam.ham'</span><span class="token punctuation">,</span> globals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>请注意在这里 <code>__import__()</code> 是如何返回顶层模块的，因为这是通过 <code>import</code> 语句被绑定到特定名称的对象。</p>
<p>另一方面，语句 <code>from spam.ham import eggs, sausage as saus</code> 的结果将为</p>
<pre class="line-numbers language-python"><code class="language-python">_temp <span class="token operator">=</span> __import__<span class="token punctuation">(</span><span class="token string">'spam.ham'</span><span class="token punctuation">,</span> globals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'eggs'</span><span class="token punctuation">,</span><span class="token string">'sausage'</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
eggs <span class="token operator">=</span> _temp<span class="token punctuation">.</span>eggs
saus <span class="token operator">=</span> _temp<span class="token punctuation">.</span>sausage<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在这里， <code>spam.ham</code> 模块会由 <code>__import__()</code> 返回。 要导入的对象将从此对象中提取并赋值给它们对应的名称。</p>
<p>如果您只想按名称导入模块（可能在包中），请使用 <code>importlib.import_module()</code></p>
<p>在 3.3 版更改: <em>level</em> 的值不再支持负数（默认值也修改为0）。</p>
<p>在 3.9 版更改: 当使用了命令行参数 <code>-E</code> 或 <code>-I</code> 时，环境变量 <code>PYTHONCASEOK</code> 现在将被忽略。</p>
<h1 id="内置常量"><a href="#内置常量" class="headerlink" title="内置常量"></a>内置常量</h1><p>有少数的常量存在于内置命名空间中。 它们是：</p>
<pre><code>False</code></pre><p><code>bool</code> 类型的假值。 给 <code>False</code> 赋值是非法的并会引发 <code>SyntaxError</code>。</p>
<pre><code>True</code></pre><p><code>bool</code> 类型的真值。 给 <code>True</code> 赋值是非法的并会引发 <code>SyntaxError</code>。</p>
<pre><code>None</code></pre><p>通常被用来代表空值的对象，例如在未向某个函数传入默认参数时。 给 <code>None</code> 赋值是非法的并会引发 <code>SyntaxError</code>。 <code>None</code> 是 <code>NoneType</code> 类型的唯一实例。</p>
<pre><code>NotImplemented</code></pre><p>应当由双目运算特殊方法（如 <code>__eq__()</code>, <code>__lt__()</code>, <code>__add__()</code>, <code>__rsub__()</code> 等）返回的特殊值，用于表明运算没有针对其他类型的实现；也可由原地双目运算特殊方法（如 <code>__imul__()</code>, <code>__iand__()</code> 等）出于同样的目的而返回。 它不应在布尔运算中被求值。 <code>NotImplemented</code> 是 <code>types.NotImplementedType</code> 类型的唯一实例。</p>
<p>注解</p>
<p>当二进制（或就地）方法返回<code>NotImplemented</code>时，解释器将尝试对另一种类型（或其他一些回滚操作，取决于运算符）的反射操作。 如果所有尝试都返回<code>NotImplemented</code>，则解释器将引发适当的异常。 错误返回的<code>NotImplemented</code>将导致误导性错误消息或返回到Python代码中的<code>NotImplemented</code>值。</p>
<p>注解</p>
<p><code>NotImplementedError</code> 和 <code>NotImplemented</code> 不可互换，即使它们有相似的名称和用途。 </p>
<p>在 3.9 版更改: 作为布尔值来解读 <code>NotImplemented</code> 已被弃用。 虽然它目前会被解读为真值，但将同时发出 <code>DeprecationWarning</code>。 它将在未来的 Python 版本中引发 <code>TypeError</code>。</p>
<pre><code>Ellipsis</code></pre><p>与省略号字面值 “<code>...</code>“ 相同。 该特殊值主要是与用户定义的容器数据类型的扩展切片语法结合使用。 <code>Ellipsis</code> 是 <code>types.EllipsisType</code> 类型的唯一实例。</p>
<pre><code>__debug__</code></pre><p>如果 Python 没有以 <code>-O</code> 选项启动，则此常量为真值。 </p>
<p>注解</p>
<p>变量名 <code>None</code>，<code>False</code>，<code>True</code> 和 <code>__ debug__</code> 无法重新赋值（赋值给它们，即使是属性名，将引发 <code>SyntaxError</code> ），所以它们可以被认为是“真正的”常数。</p>
<h2 id="由-site-模块添加的常量"><a href="#由-site-模块添加的常量" class="headerlink" title="由 site 模块添加的常量"></a>由 <code>site</code> 模块添加的常量</h2><p><code>site</code> 模块（在启动期间自动导入，除非给出 <code>-S</code> 命令行选项）将几个常量添加到内置命名空间。 它们对交互式解释器 shell 很有用，并且不应在程序中使用。</p>
<ul>
<li><p><code>quit</code>(<em>code=None</em>)</p>
</li>
<li><p><code>exit</code>(<em>code=None</em>)</p>
</li>
</ul>
<p>当打印此对象时，会打印出一条消息，例如“Use quit() or Ctrl-D (i.e. EOF) to exit”，当调用此对象时，将使用指定的退出代码来引发 <code>SystemExit</code>。</p>
<pre><code>copyright
credits</code></pre><p>打印或调用的对象分别打印版权或作者的文本。</p>
<pre><code>license</code></pre><p>当打印此对象时，会打印出一条消息“Type license() to see the full license text”，当调用此对象时，将以分页形式显示完整的许可证文本（每次显示一屏）。</p>
<h1 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h1><p>以下部分描述了解释器中内置的标准类型。</p>
<p>主要内置类型有数字、序列、映射、类、实例和异常。</p>
<p>有些多项集类是可变的。 它们用于添加、移除或重排其成员的方法将原地执行，并不返回特定的项，绝对不会返回多项集实例自身而是返回 <code>None</code>。</p>
<p>有些操作受多种对象类型的支持；特别地，实际上所有对象都可以比较是否相等、检测逻辑值，以及转换为字符串（使用 <code>repr()</code> 函数或略有差异的 <code>str()</code> 函数）。 后一个函数是在对象由 <code>print()</code> 函数输出时被隐式地调用的。</p>
<h2 id="逻辑值检测"><a href="#逻辑值检测" class="headerlink" title="逻辑值检测"></a>逻辑值检测</h2><p>任何对象都可以进行逻辑值的检测，以便在 <code>if</code> 或 <code>while</code> 作为条件或是作为下文所述布尔运算的操作数来使用。</p>
<p>一个对象在默认情况下均被视为真值，除非当该对象被调用时其所属类定义了 <code>__bool__()</code> 方法且返回 <code>False</code> 或是定义了 <code>__len__()</code> 方法且返回零。 下面基本完整地列出了会被视为假值的内置对象:</p>
<ul>
<li>被定义为假值的常量: <code>None</code> 和 <code>False</code>。</li>
<li>任何数值类型的零: <code>0</code>, <code>0.0</code>, <code>0j</code>, <code>Decimal(0)</code>, <code>Fraction(0, 1)</code></li>
<li>空的序列和多项集: <code>''</code>, <code>()</code>, <code>[]</code>, <code>{}</code>, <code>set()</code>, <code>range(0)</code></li>
</ul>
<p>产生布尔值结果的运算和内置函数总是返回 <code>0</code> 或 <code>False</code> 作为假值，<code>1</code> 或 <code>True</code> 作为真值，除非另行说明。 （重要例外：布尔运算 <code>or</code> 和 <code>and</code> 总是返回其中一个操作数。）</p>
<h2 id="布尔运算-—-and-or-not"><a href="#布尔运算-—-and-or-not" class="headerlink" title="布尔运算 —- and, or, not"></a>布尔运算 —- <code>and</code>, <code>or</code>, <code>not</code></h2><p>这些属于布尔运算，按优先级升序排列:</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>x or y</code></td>
<td align="left">if <em>x</em> is false, then <em>y</em>, else <em>x</em></td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>x and y</code></td>
<td align="left">if <em>x</em> is false, then <em>x</em>, else <em>y</em></td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>not x</code></td>
<td align="left">if <em>x</em> is false, then <code>True</code>, else <code>False</code></td>
<td align="left">(3)</td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li>这是个短路运算符，因此只有在第一个参数为假值时才会对第二个参数求值。</li>
<li>这是个短路运算符，因此只有在第一个参数为真值时才会对第二个参数求值。</li>
<li><code>not</code> 的优先级比非布尔运算符低，因此 <code>not a == b</code> 会被解读为 <code>not (a == b)</code> 而 <code>a == not b</code> 会引发语法错误。</li>
</ol>
<h2 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h2><p>在 Python 中有八种比较运算符。 它们的优先级相同（比布尔运算的优先级高）。 比较运算可以任意串连；例如，<code>x &lt; y &lt;= z</code> 等价于 <code>x &lt; y and y &lt;= z</code>，前者的不同之处在于 <em>y</em> 只被求值一次（但在两种情况下当 <code>x &lt; y</code> 结果为假值时 <em>z</em> 都不会被求值）。</p>
<p>此表格汇总了比较运算:</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&lt;</code></td>
<td align="left">严格小于</td>
</tr>
<tr>
<td align="left"><code>&lt;=</code></td>
<td align="left">小于或等于</td>
</tr>
<tr>
<td align="left"><code>&gt;</code></td>
<td align="left">严格大于</td>
</tr>
<tr>
<td align="left"><code>&gt;=</code></td>
<td align="left">大于或等于</td>
</tr>
<tr>
<td align="left"><code>==</code></td>
<td align="left">等于</td>
</tr>
<tr>
<td align="left"><code>!=</code></td>
<td align="left">不等于</td>
</tr>
<tr>
<td align="left"><code>is</code></td>
<td align="left">对象标识</td>
</tr>
<tr>
<td align="left"><code>is not</code></td>
<td align="left">否定的对象标识</td>
</tr>
</tbody></table>
<p>除不同的数字类型外，不同类型的对象不能进行相等比较。<code>==</code> 运算符总有定义，但对于某些对象类型（例如，类对象），它等于 <code>is</code> 。其他 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code> 和 <code>&gt;=</code> 运算符仅在有意义的地方定义。例如，当参与比较的参数之一为复数时，它们会抛出 <code>TypeError</code> 异常。</p>
<p>具有不同标识的类的实例比较结果通常为不相等，除非类定义了 <code>__eq__()</code> 方法。</p>
<p>一个类实例不能与相同类或的其他实例或其他类型的对象进行排序，除非该类定义了足够多的方法，包括 <code>__lt__()</code>, <code>__le__()</code>, <code>__gt__()</code> 以及 <code>__ge__()</code> (而如果你想实现常规意义上的比较操作，通常只要有 <code>__lt__()</code> 和 <code>__eq__()</code> 就可以了)。</p>
<p><code>is</code> 和 <code>is not</code> 运算符无法自定义；并且它们可以被应用于任意两个对象而不会引发异常。</p>
<p>还有两种具有相同语法优先级的运算 <code>in</code> 和 <code>not in</code>，它们被 iterable 或实现了 <code>__contains__()</code> 方法的类型所支持。</p>
<h2 id="数字类型-—-int-float-complex"><a href="#数字类型-—-int-float-complex" class="headerlink" title="数字类型 —- int, float, complex"></a>数字类型 —- <code>int</code>, <code>float</code>, <code>complex</code></h2><p>存在三种不同的数字类型: <em>整数</em>, <em>浮点数</em> 和 <em>复数*。 此外，布尔值属于整数的子类型。 整数具有无限的精度。 浮点数通常使用 C 中的 double 来实现；有关你的程序运行所在机器上浮点数的精度和内部表示法可在 <code>sys.float_info</code> 中查看。 复数包含实部和虚部，分别以一个浮点数表示。 要从一个复数 *z</em> 中提取这两个部分，可使用 <code>z.real</code> 和 <code>z.imag</code>。 （标准库包含附加的数字类型，如表示有理数的 <code>fractions.Fraction</code> 以及以用户定制精度表示浮点数的 <code>decimal.Decimal</code>。）</p>
<p>数字是由数字字面值或内置函数与运算符的结果来创建的。 不带修饰的整数字面值（包括十六进制、八进制和二进制数）会生成整数。 包含小数点或幂运算符的数字字面值会生成浮点数。 在数字字面值末尾加上 <code>'j'</code> 或 <code>'J'</code> 会生成虚数（实部为零的复数），你可以将其与整数或浮点数相加来得到具有实部和虚部的复数。</p>
<p>Python 完全支持混合运算：当一个二元算术运算符的操作数有不同数值类型时，”较窄”类型的操作数会拓宽到另一个操作数的类型，其中整数比浮点数窄，浮点数比复数窄。不同类型的数字之间的比较，同比较这些数字的精确值一样。</p>
<p>构造函数 <code>int()</code>、 <code>float()</code> 和 <code>complex()</code> 可以用来构造特定类型的数字。</p>
<p>所有数字类型（复数除外）都支持下列运算:</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
<th align="left">备注</th>
<th align="left">完整文档</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>x + y</code></td>
<td align="left"><em>x</em> 和 <em>y</em> 的和</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>x - y</code></td>
<td align="left"><em>x</em> 和 <em>y</em> 的差</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>x * y</code></td>
<td align="left"><em>x</em> 和 <em>y</em> 的乘积</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>x / y</code></td>
<td align="left"><em>x</em> 和 <em>y</em> 的商</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>x // y</code></td>
<td align="left"><em>x</em> 和 <em>y</em> 的商数</td>
<td align="left">(1)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>x % y</code></td>
<td align="left"><code>x / y</code> 的余数</td>
<td align="left">(2)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>-x</code></td>
<td align="left"><em>x</em> 取反</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>+x</code></td>
<td align="left"><em>x</em> 不变</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>abs(x)</code></td>
<td align="left"><em>x</em> 的绝对值或大小</td>
<td align="left"></td>
<td align="left"><code>abs()</code></td>
</tr>
<tr>
<td align="left"><code>int(x)</code></td>
<td align="left">将 <em>x</em> 转换为整数</td>
<td align="left">(3)(6)</td>
<td align="left"><code>int()</code></td>
</tr>
<tr>
<td align="left"><code>float(x)</code></td>
<td align="left">将 <em>x</em> 转换为浮点数</td>
<td align="left">(4)(6)</td>
<td align="left"><code>float()</code></td>
</tr>
<tr>
<td align="left"><code>complex(re, im)</code></td>
<td align="left">一个带有实部 <em>re</em> 和虚部 <em>im</em> 的复数。<em>im</em> 默认为0。</td>
<td align="left">(6)</td>
<td align="left"><code>complex()</code></td>
</tr>
<tr>
<td align="left"><code>c.conjugate()</code></td>
<td align="left">复数 <em>c</em> 的共轭</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>divmod(x, y)</code></td>
<td align="left"><code>(x // y, x % y)</code></td>
<td align="left">(2)</td>
<td align="left"><code>divmod()</code></td>
</tr>
<tr>
<td align="left"><code>pow(x, y)</code></td>
<td align="left"><em>x</em> 的 <em>y</em> 次幂</td>
<td align="left">(5)</td>
<td align="left"><code>pow()</code></td>
</tr>
<tr>
<td align="left"><code>x ** y</code></td>
<td align="left"><em>x</em> 的 <em>y</em> 次幂</td>
<td align="left">(5)</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p>也称为整数除法。 结果值是一个整数，但结果的类型不一定是 int。 运算结果总是向负无穷的方向舍入: <code>1//2</code> 为 <code>0</code>, <code>(-1)//2</code> 为 <code>-1</code>, <code>1//(-2)</code> 为 <code>-1</code> 而 <code>(-1)//(-2)</code> 为 <code>0</code>。</p>
</li>
<li><p>不可用于复数。 而应在适当条件下使用 <code>abs()</code> 转换为浮点数。</p>
</li>
<li><p>从浮点数转换为整数会被舍入或是像在 C 语言中一样被截断。</p>
</li>
<li><p>float 也接受字符串 “nan” 和附带可选前缀 “+” 或 “-“ 的 “inf” 分别表示非数字 (NaN) 以及正或负无穷。</p>
</li>
<li><p>Python 将 <code>pow(0, 0)</code> 和 <code>0 ** 0</code> 定义为 <code>1</code>，这是编程语言的普遍做法。</p>
</li>
<li><p>接受的数字字面值包括数码 <code>0</code> 到 <code>9</code> 或任何等效的 Unicode 字符（具有 <code>Nd</code> 特征属性的代码点）。</p>
<p>请参阅 <a href="https://www.unicode.org/Public/13.0.0/ucd/extracted/DerivedNumericType.txt" target="_blank" rel="noopener">https://www.unicode.org/Public/13.0.0/ucd/extracted/DerivedNumericType.txt</a> 查看具有 <code>Nd</code> 特征属性的代码点的完整列表。</p>
</li>
</ol>
<p>所有 <code>numbers.Real</code> 类型 (<code>int</code> 和 <code>float</code>) 还包括下列运算:</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>math.trunc(x)</code></td>
<td align="left"><em>x</em> 截断为 <code>Integral</code></td>
</tr>
<tr>
<td align="left"><code>round(x[, n\])</code></td>
<td align="left"><em>x</em> 舍入到 <em>n</em> 位小数，半数值会舍入到偶数。 如果省略 <em>n</em>，则默认为 0。</td>
</tr>
<tr>
<td align="left"><code>math.floor(x)</code></td>
<td align="left">&lt;= <em>x</em> 的最大 <code>Integral</code></td>
</tr>
<tr>
<td align="left"><code>math.ceil(x)</code></td>
<td align="left">&gt;= <em>x</em> 的最小 <code>Integral</code></td>
</tr>
</tbody></table>
<h3 id="整数类型的按位运算"><a href="#整数类型的按位运算" class="headerlink" title="整数类型的按位运算"></a>整数类型的按位运算</h3><p>按位运算只对整数有意义。 计算按位运算的结果，就相当于使用无穷多个二进制符号位对二的补码执行操作。</p>
<p>二进制按位运算的优先级全都低于数字运算，但又高于比较运算；一元运算 <code>~</code> 具有与其他一元算术运算 (<code>+</code> and <code>-</code>) 相同的优先级。</p>
<p>此表格是以优先级升序排序的按位运算列表:</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">`x</td>
<td align="left">y`</td>
<td align="left"><em>x</em> 和 <em>y</em> 按位 <em>或</em></td>
</tr>
<tr>
<td align="left"><code>x ^ y</code></td>
<td align="left"><em>x</em> 和 <em>y</em> 按位 <em>异或</em></td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>x &amp; y</code></td>
<td align="left"><em>x</em> 和 <em>y</em> 按位 <em>与</em></td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>x &lt;&lt; n</code></td>
<td align="left"><em>x</em> 左移 <em>n</em> 位</td>
<td align="left">(1)(2)</td>
</tr>
<tr>
<td align="left"><code>x &gt;&gt; n</code></td>
<td align="left"><em>x</em> 右移 <em>n</em> 位</td>
<td align="left">(1)(3)</td>
</tr>
<tr>
<td align="left"><code>~x</code></td>
<td align="left"><em>x</em> 逐位取反</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li>负的移位数是非法的，会导致引发 <code>ValueError</code>。</li>
<li>左移 <em>n</em> 位等价于乘以 <code>pow(2, n)</code> 。</li>
<li>右移 <em>n</em> 位等价于除以 <code>pow(2, n)</code> ，作向下取整除法。</li>
<li>使用带有至少一个额外符号扩展位的有限个二进制补码表示（有效位宽度为 <code>1 + max(x.bit_length(), y.bit_length())</code> 或以上）执行这些计算就足以获得相当于有无数个符号位时的同样结果。</li>
</ol>
<h3 id="整数类型的附加方法"><a href="#整数类型的附加方法" class="headerlink" title="整数类型的附加方法"></a>整数类型的附加方法</h3><p>int 类型实现了 <code>numbers.Integral</code> abstract base class。 此外，它还提供了其他几个方法:</p>
<p><code>int.bit_length</code>()</p>
<p>返回以二进制表示一个整数所需要的位数，不包括符号位和前面的零:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> n <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">37</span>
<span class="token operator">>></span><span class="token operator">></span> bin<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
<span class="token string">'-0b100101'</span>
<span class="token operator">>></span><span class="token operator">></span> n<span class="token punctuation">.</span>bit_length<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>更准确地说，如果 <code>x</code> 非零，则 <code>x.bit_length()</code> 是使得 <code>2**(k-1) &lt;= abs(x) &lt; 2**k</code> 的唯一正整数 <code>k</code>。 同样地，当 <code>abs(x)</code> 小到足以具有正确的舍入对数时，则 <code>k = 1 + int(log(abs(x), 2))</code>。 如果 <code>x</code> 为零，则 <code>x.bit_length()</code> 返回 <code>0</code>。</p>
<p>等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bit_length</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
    s <span class="token operator">=</span> bin<span class="token punctuation">(</span>self<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># binary representation:  bin(-37) --> '-0b100101'</span>
    s <span class="token operator">=</span> s<span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token string">'-0b'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># remove leading zeros and minus sign</span>
    <span class="token keyword">return</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># len('100101') --> 6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.1 新版功能.</p>
<p><code>int.bit_count</code>()</p>
<p>Return the number of ones in the binary representation of the absolute value of the integer. This is also known as the population count. Example:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> n <span class="token operator">=</span> <span class="token number">19</span>
<span class="token operator">>></span><span class="token operator">></span> bin<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
<span class="token string">'0b10011'</span>
<span class="token operator">>></span><span class="token operator">></span> n<span class="token punctuation">.</span>bit_count<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">-</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span>bit_count<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bit_count</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    
    <span class="token keyword">return</span> bin<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.10 新版功能.</p>
<p><code>int.to_bytes</code>(<em>length</em>, <em>byteorder</em>, <em>**,</em> signed=False*)</p>
<p>返回表示一个整数的字节数组。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'big'</span><span class="token punctuation">)</span>
b<span class="token string">'\x04\x00'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'big'</span><span class="token punctuation">)</span>
b<span class="token string">'\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'big'</span><span class="token punctuation">,</span> signed<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
b<span class="token string">'\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00'</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> <span class="token number">1000</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>to_bytes<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>bit_length<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">8</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'little'</span><span class="token punctuation">)</span>
b<span class="token string">'\xe8\x03'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>整数会使用 <em>length</em> 个字节来表示。 如果整数不能用给定的字节数来表示则会引发 <code>OverflowError</code>。</p>
<p><em>byteorder</em> 参数确定用于表示整数的字节顺序。 如果 <em>byteorder</em> 为 <code>"big"</code>，则最高位字节放在字节数组的开头。 如果 <em>byteorder</em> 为 <code>"little"</code>，则最高位字节放在字节数组的末尾。 要请求主机系统上的原生字节顺序，请使用 <code>sys.byteorder</code> 作为字节顺序值。</p>
<p><em>signed</em> 参数确定是否使用二的补码来表示整数。 如果 <em>signed</em> 为 <code>False</code> 并且给出的是负整数，则会引发 <code>OverflowError</code>。 <em>signed</em> 的默认值为 <code>False</code>。</p>
<p>3.2 新版功能.</p>
<p><em>classmethod</em> <code>int.from_bytes</code>(<em>bytes</em>, <em>byteorder</em>, <em>**,</em> signed=False*)</p>
<p>返回由给定字节数组所表示的整数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span>b<span class="token string">'\x00\x10'</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'big'</span><span class="token punctuation">)</span>
<span class="token number">16</span>
<span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span>b<span class="token string">'\x00\x10'</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'little'</span><span class="token punctuation">)</span>
<span class="token number">4096</span>
<span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span>b<span class="token string">'\xfc\x00'</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'big'</span><span class="token punctuation">,</span> signed<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token number">1024</span>
<span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span>b<span class="token string">'\xfc\x00'</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'big'</span><span class="token punctuation">,</span> signed<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token number">64512</span>
<span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">.</span>from_bytes<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> byteorder<span class="token operator">=</span><span class="token string">'big'</span><span class="token punctuation">)</span>
<span class="token number">16711680</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>bytes</em> 参数必须为一个 bytes-like object 或是生成字节的可迭代对象。</p>
<p><em>byteorder</em> 参数确定用于表示整数的字节顺序。 如果 <em>byteorder</em> 为 <code>"big"</code>，则最高位字节放在字节数组的开头。 如果 <em>byteorder</em> 为 <code>"little"</code>，则最高位字节放在字节数组的末尾。 要请求主机系统上的原生字节顺序，请使用 <code>sys.byteorder</code> 作为字节顺序值。</p>
<p><em>signed</em> 参数指明是否使用二的补码来表示整数。</p>
<p>3.2 新版功能.</p>
<p><code>int.as_integer_ratio</code>()</p>
<p>返回一对整数，其比率正好等于原整数并且分母为正数。 整数的比率总是用这个整数本身作为分子，<code>1</code> 作为分母。</p>
<p>3.8 新版功能.</p>
<h3 id="浮点类型的附加方法"><a href="#浮点类型的附加方法" class="headerlink" title="浮点类型的附加方法"></a>浮点类型的附加方法</h3><p>float 类型实现了 <code>numbers.Real</code> abstract base class。 float 还具有以下附加方法。</p>
<p><code>float.as_integer_ratio</code>()</p>
<p>返回一对整数，其比率正好等于原浮点数并且分母为正数。 无穷大会引发 <code>OverflowError</code> 而 NaN 则会引发 <code>ValueError</code>。</p>
<p><code>float.is_integer</code>()</p>
<p>如果 float 实例可用有限位整数表示则返回 <code>True</code>，否则返回 <code>False</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_integer<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token number">3.2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_integer<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>两个方法均支持与十六进制数字符串之间的转换。 由于 Python 浮点数在内部存储为二进制数，因此浮点数与 <em>十进制数</em> 字符串之间的转换往往会导致微小的舍入错误。 而十六进制数字符串却允许精确地表示和描述浮点数。 这在进行调试和数值工作时非常有用。</p>
<p><code>float.hex</code>()</p>
<p>以十六进制字符串的形式返回一个浮点数表示。 对于有限浮点数，这种表示法将总是包含前导的 <code>0x</code> 和尾随的 <code>p</code> 加指数。</p>
<p><em>classmethod</em> <code>float.fromhex</code>(<em>s</em>)</p>
<p>返回以十六进制字符串 <em>s</em> 表示的浮点数的类方法。 字符串 <em>s</em> 可以带有前导和尾随的空格。</p>
<p>请注意 <code>float.hex()</code> 是实例方法，而 <code>float.fromhex()</code> 是类方法。</p>
<p>十六进制字符串采用的形式为:</p>
<pre><code>[sign] ['0x'] integer ['.' fraction] ['p' exponent]</code></pre><p>可选的 <code>sign</code> 可以是 <code>+</code> 或 <code>-</code>，<code>integer</code> 和 <code>fraction</code> 是十六进制数码组成的字符串，<code>exponent</code> 是带有可选前导符的十进制整数。 大小写没有影响，在 integer 或 fraction 中必须至少有一个十六进制数码。 此语法类似于 C99 标准的 6.4.4.2 小节中所描述的语法，也是 Java 1.5 以上所使用的语法。 特别地，<code>float.hex()</code> 的输出可以用作 C 或 Java 代码中的十六进制浮点数字面值，而由 C 的 <code>%a</code> 格式字符或 Java 的 <code>Double.toHexString</code> 所生成的十六进制数字符串由为 <code>float.fromhex()</code> 所接受。</p>
<p>请注意 exponent 是十进制数而非十六进制数，它给出要与系数相乘的 2 的幂次。 例如，十六进制数字符串 <code>0x3.a7p10</code> 表示浮点数 <code>(3 + 10./16 + 7./16**2) * 2.0**10</code> 即 <code>3740.0</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> float<span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token string">'0x3.a7p10'</span><span class="token punctuation">)</span>
<span class="token number">3740.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对 <code>3740.0</code> 应用反向转换会得到另一个代表相同数值的十六进制数字符串:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> float<span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token number">3740.0</span><span class="token punctuation">)</span>
<span class="token string">'0x1.d380000000000p+11'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="数字类型的哈希运算"><a href="#数字类型的哈希运算" class="headerlink" title="数字类型的哈希运算"></a>数字类型的哈希运算</h3><p>对于可能为不同类型的数字 <code>x</code> 和 <code>y</code>，要求 <code>x == y</code> 时必定 <code>hash(x) == hash(y)</code>。 为了便于在各种数字类型 (包括 <code>int</code>, <code>float</code>, <code>decimal.Decimal</code> 和 <code>fractions.Fraction</code>) 上实现并保证效率，Python 对数字类型的哈希运算是基于为任意有理数定义统一的数学函数，因此该运算对 <code>int</code> 和 <code>fractions.Fraction</code> 的全部实例，以及 <code>float</code> 和 <code>decimal.Decimal</code> 的全部有限实例均可用。 从本质上说，此函数是通过以一个固定质数 <code>P</code> 进行 <code>P</code> 降模给出的。 <code>P</code> 的值在 Python 中可以 <code>sys.hash_info</code> 的 <code>modulus</code> 属性的形式被访问。</p>
<p><strong>CPython implementation detail:</strong> 目前所用的质数设定，在 C long 为 32 位的机器上 <code>P = 2**31 - 1</code> 而在 C long 为 64 位的机器上 <code>P = 2**61 - 1</code>。</p>
<p>详细规则如下所述:</p>
<ul>
<li>如果 <code>x = m / n</code> 是一个非负的有理数且 <code>n</code> 不可被 <code>P</code> 整除，则定义 <code>hash(x)</code> 为 <code>m * invmod(n, P) % P</code>，其中 <code>invmod(n, P)</code> 是对 <code>n</code> 模 <code>P</code> 取反。</li>
<li>如果 <code>x = m / n</code> 是一个非负的有理数且 <code>n</code> 可被 <code>P</code> 整除（但 <code>m</code> 不能）则 <code>n</code> 不能对 <code>P</code> 降模，以上规则不适用；在此情况下则定义 <code>hash(x)</code> 为常数值 <code>sys.hash_info.inf</code>。</li>
<li>如果 <code>x = m / n</code> 是一个负的有理数则定义 <code>hash(x)</code> 为 <code>-hash(-x)</code>。 如果结果哈希值为 <code>-1</code> 则将其替换为 <code>-2</code>。</li>
<li>The particular values <code>sys.hash_info.inf</code> and <code>-sys.hash_info.inf</code> are used as hash values for positive infinity or negative infinity (respectively).</li>
<li>对于一个 <code>complex</code> 值 <code>z</code>，会通过计算 <code>hash(z.real) + sys.hash_info.imag * hash(z.imag)</code> 将实部和虚部的哈希值结合起来，并进行降模 <code>2**sys.hash_info.width</code> 以使其处于 <code>range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))</code> 范围之内。 同样地，如果结果为 <code>-1</code> 则将其替换为 <code>-2</code>。</li>
</ul>
<p>为了阐明上述规则，这里有一些等价于内置哈希算法的 Python 代码示例，可用于计算有理数、<code>float</code> 或 <code>complex</code> 的哈希值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token punctuation">,</span> math
<span class="token keyword">def</span> <span class="token function">hash_fraction</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Compute the hash of a rational number m / n.
    Assumes m and n are integers, with n positive.
    Equivalent to hash(fractions.Fraction(m, n)).
    """</span>
    P <span class="token operator">=</span> sys<span class="token punctuation">.</span>hash_info<span class="token punctuation">.</span>modulus
    <span class="token comment" spellcheck="true"># Remove common factors of P.  (Unnecessary if m and n already coprime.)</span>
    <span class="token keyword">while</span> m <span class="token operator">%</span> P <span class="token operator">==</span> n <span class="token operator">%</span> P <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        m<span class="token punctuation">,</span> n <span class="token operator">=</span> m <span class="token operator">//</span> P<span class="token punctuation">,</span> n <span class="token operator">//</span> P
    <span class="token keyword">if</span> n <span class="token operator">%</span> P <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        hash_value <span class="token operator">=</span> sys<span class="token punctuation">.</span>hash_info<span class="token punctuation">.</span>inf
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># Fermat's Little Theorem: pow(n, P-1, P) is 1, so</span>
        <span class="token comment" spellcheck="true"># pow(n, P-2, P) gives the inverse of n modulo P.</span>
        hash_value <span class="token operator">=</span> <span class="token punctuation">(</span>abs<span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token operator">%</span> P<span class="token punctuation">)</span> <span class="token operator">*</span> pow<span class="token punctuation">(</span>n<span class="token punctuation">,</span> P <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> P<span class="token punctuation">)</span> <span class="token operator">%</span> P
    <span class="token keyword">if</span> m <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        hash_value <span class="token operator">=</span> <span class="token operator">-</span>hash_value
    <span class="token keyword">if</span> hash_value <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
        hash_value <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span>
    <span class="token keyword">return</span> hash_value
<span class="token keyword">def</span> <span class="token function">hash_float</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Compute the hash of a float x."""</span>
    <span class="token keyword">if</span> math<span class="token punctuation">.</span>isnan<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> object<span class="token punctuation">.</span>__hash__<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token keyword">elif</span> math<span class="token punctuation">.</span>isinf<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> sys<span class="token punctuation">.</span>hash_info<span class="token punctuation">.</span>inf <span class="token keyword">if</span> x <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token operator">-</span>sys<span class="token punctuation">.</span>hash_info<span class="token punctuation">.</span>inf
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> hash_fraction<span class="token punctuation">(</span><span class="token operator">*</span>x<span class="token punctuation">.</span>as_integer_ratio<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">hash_complex</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">"""Compute the hash of a complex number z."""</span>
    hash_value <span class="token operator">=</span> hash_float<span class="token punctuation">(</span>z<span class="token punctuation">.</span>real<span class="token punctuation">)</span> <span class="token operator">+</span> sys<span class="token punctuation">.</span>hash_info<span class="token punctuation">.</span>imag <span class="token operator">*</span> hash_float<span class="token punctuation">(</span>z<span class="token punctuation">.</span>imag<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># do a signed reduction modulo 2**sys.hash_info.width</span>
    M <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">**</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>hash_info<span class="token punctuation">.</span>width <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    hash_value <span class="token operator">=</span> <span class="token punctuation">(</span>hash_value <span class="token operator">&amp;</span> <span class="token punctuation">(</span>M <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>hash_value <span class="token operator">&amp;</span> M<span class="token punctuation">)</span>
    <span class="token keyword">if</span> hash_value <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
        hash_value <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span>
    <span class="token keyword">return</span> hash_value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="迭代器类型"><a href="#迭代器类型" class="headerlink" title="迭代器类型"></a>迭代器类型</h2><p>Python 支持在容器中进行迭代的概念。 这是通过使用两个单独方法来实现的；它们被用于允许用户自定义类对迭代的支持。 将在下文中详细描述的序列总是支持迭代方法。</p>
<p>容器对象要提供迭代支持，必须定义一个方法:</p>
<p><code>container.__iter__</code>()</p>
<p>返回一个迭代器对象。 该对象需要支持下文所述的迭代器协议。 如果容器支持不同的迭代类型，则可以提供额外的方法来专门地请求不同迭代类型的迭代器。 （支持多种迭代形式的对象的例子有同时支持广度优先和深度优先遍历的树结构。） 此方法对应于 Python/C API 中 Python 对象类型结构体的 <code>tp_iter</code> 槽位。</p>
<p>迭代器对象自身需要支持以下两个方法，它们共同组成了 <em>迭代器协议</em>:</p>
<p><code>iterator.__iter__</code>()</p>
<p>返回迭代器对象本身。 这是同时允许容器和迭代器配合 <code>for</code> 和 <code>in</code> 语句使用所必须的。 此方法对应于 Python/C API 中 Python 对象类型结构体的 <code>tp_iter</code> 槽位。</p>
<p><code>iterator.__next__</code>()</p>
<p>从容器中返回下一项。 如果已经没有项可返回，则会引发 <code>StopIteration</code> 异常。 此方法对应于 Python/C API 中 Python 对象类型结构体的 <code>tp_iternext</code> 槽位。</p>
<p>Python 定义了几种迭代器对象以支持对一般和特定序列类型、字典和其他更特别的形式进行迭代。 除了迭代器协议的实现，特定类型的其他性质对迭代操作来说都不重要。</p>
<p>一旦迭代器的 <code>__next__()</code> 方法引发了 <code>StopIteration</code>，它必须一直对后续调用引发同样的异常。 不遵循此行为特性的实现将无法正常使用。</p>
<h3 id="生成器类型"><a href="#生成器类型" class="headerlink" title="生成器类型"></a>生成器类型</h3><p>Python 的 generator 提供了一种实现迭代器协议的便捷方式。 如果容器对象 <code>__iter__()</code> 方法被实现为一个生成器，它将自动返回一个迭代器对象（从技术上说是一个生成器对象），该对象提供 <code>__iter__()</code> 和 <code>__next__()</code> 方法。 </p>
<h2 id="序列类型-—-list-tuple-range"><a href="#序列类型-—-list-tuple-range" class="headerlink" title="序列类型 —- list, tuple, range"></a>序列类型 —- <code>list</code>, <code>tuple</code>, <code>range</code></h2><p>有三种基本序列类型：list, tuple 和 range 对象。 </p>
<h3 id="通用序列操作"><a href="#通用序列操作" class="headerlink" title="通用序列操作"></a>通用序列操作</h3><p>大多数序列类型，包括可变类型和不可变类型都支持下表中的操作。 <code>collections.abc.Sequence</code> ABC 被提供用来更容易地在自定义序列类型上正确地实现这些操作。</p>
<p>此表按优先级升序列出了序列操作。 在表格中，<em>s</em> 和 <em>t</em> 是具有相同类型的序列，<em>n</em>, <em>i</em>, <em>j</em> 和 <em>k</em> 是整数而 <em>x</em> 是任何满足 <em>s</em> 所规定的类型和值限制的任意对象。</p>
<p><code>in</code> 和 <code>not in</code> 操作具有与比较操作相同的优先级。 <code>+</code> (拼接) 和 <code>*</code> (重复) 操作具有与对应数值运算相同的优先级。</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>x in s</code></td>
<td align="left">如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code>True</code>，否则为 <code>False</code></td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>x not in s</code></td>
<td align="left">如果 <em>s</em> 中的某项等于 <em>x</em> 则结果为 <code>False</code>，否则为 <code>True</code></td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>s + t</code></td>
<td align="left"><em>s</em> 与 <em>t</em> 相拼接</td>
<td align="left">(6)(7)</td>
</tr>
<tr>
<td align="left"><code>s * n</code> <em>或 <code>n</code></em><code>s</code></td>
<td align="left">相当于 <em>s</em> 与自身进行 <em>n</em> 次拼接</td>
<td align="left">(2)(7)</td>
</tr>
<tr>
<td align="left"><code>s[i]</code></td>
<td align="left"><em>s</em> 的第 <em>i</em> 项，起始为 0</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>s[i:j]</code></td>
<td align="left"><em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片</td>
<td align="left">(3)(4)</td>
</tr>
<tr>
<td align="left"><code>s[i:j:k]</code></td>
<td align="left"><em>s</em> 从 <em>i</em> 到 <em>j</em> 步长为 <em>k</em> 的切片</td>
<td align="left">(3)(5)</td>
</tr>
<tr>
<td align="left"><code>len(s)</code></td>
<td align="left"><em>s</em> 的长度</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>min(s)</code></td>
<td align="left"><em>s</em> 的最小项</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>max(s)</code></td>
<td align="left"><em>s</em> 的最大项</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s.index(x[, i[, j]])</code></td>
<td align="left"><em>x</em> 在 <em>s</em> 中首次出现项的索引号（索引号在 <em>i</em> 或其后且在 <em>j</em> 之前）</td>
<td align="left">(8)</td>
</tr>
<tr>
<td align="left"><code>s.count(x)</code></td>
<td align="left"><em>x</em> 在 <em>s</em> 中出现的总次数</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>相同类型的序列也支持比较。 特别地，tuple 和 list 的比较是通过比较对应元素的字典顺序。 这意味着想要比较结果相等，则每个元素比较结果都必须相等，并且两个序列长度必须相同。 </p>
<p>注释：</p>
<ol>
<li><p>虽然 <code>in</code> 和 <code>not in</code> 操作在通常情况下仅被用于简单的成员检测，某些专门化序列 (例如 <code>str</code>, <code>bytes</code> 和 <code>bytearray</code>) 也使用它们进行子序列检测:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"gg"</span> <span class="token keyword">in</span> <span class="token string">"eggs"</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>小于 <code>0</code> 的 <em>n</em> 值会被当作 <code>0</code> 来处理 (生成一个与 <em>s</em> 同类型的空序列)。 请注意序列 <em>s</em> 中的项并不会被拷贝；它们会被多次引用。 这一点经常会令 Python 编程新手感到困扰；例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> lists <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> lists
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> lists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> lists
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>具体的原因在于 <code>[[]]</code> 是一个包含了一个空列表的单元素列表，所以 <code>[[]] * 3</code> 结果中的三个元素都是对这一个空列表的引用。 修改 <code>lists</code> 中的任何一个元素实际上都是对这一个空列表的修改。 你可以用以下方式创建以不同列表为元素的列表:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> lists <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> lists<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> lists<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> lists<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> lists
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>如果 <em>i</em> 或 <em>j</em> 为负值，则索引顺序是相对于序列 <em>s</em> 的末尾: 索引号会被替换为 <code>len(s) + i</code> 或 <code>len(s) + j</code>。 但要注意 <code>-0</code> 仍然为 <code>0</code>。</p>
</li>
<li><p><em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片被定义为所有满足 <code>i &lt;= k &lt; j</code> 的索引号 <em>k</em> 的项组成的序列。 如果 <em>i</em> 或 <em>j</em> 大于 <code>len(s)</code>，则使用 <code>len(s)</code>。 如果 <em>i</em> 被省略或为 <code>None</code>，则使用 <code>0</code>。 如果 <em>j</em> 被省略或为 <code>None</code>，则使用 <code>len(s)</code>。 如果 <em>i</em> 大于等于 <em>j</em>，则切片为空。</p>
</li>
<li><p><em>s</em> 从 <em>i</em> 到 <em>j</em> 步长为 <em>k</em> 的切片被定义为所有满足 <code>0 &lt;= n &lt; (j-i)/k</code> 的索引号 <code>x = i + n*k</code> 的项组成的序列。 换句话说，索引号为 <code>i</code>, <code>i+k</code>, <code>i+2*k</code>, <code>i+3*k</code>，以此类推，当达到 <em>j</em> 时停止 (但一定不包括 <em>j</em>)。 当 <em>k</em> 为正值时，<em>i</em> 和 <em>j</em> 会被减至不大于 <code>len(s)</code>。 当 <em>k</em> 为负值时，<em>i</em> 和 <em>j</em> 会被减至不大于 <code>len(s) - 1</code>。 如果 <em>i</em> 或 <em>j</em> 被省略或为 <code>None</code>，它们会成为“终止”值 (是哪一端的终止值则取决于 <em>k</em> 的符号)。 请注意，<em>k</em> 不可为零。 如果 <em>k</em> 为 <code>None</code>，则当作 <code>1</code> 处理。</p>
</li>
<li><p>拼接不可变序列总是会生成新的对象。 这意味着通过重复拼接来构建序列的运行时开销将会基于序列总长度的乘方。 想要获得线性的运行时开销，你必须改用下列替代方案之一：</p>
<ul>
<li>如果拼接 <code>str</code> 对象，你可以构建一个列表并在最后使用 <code>str.join()</code> 或是写入一个 <code>io.StringIO</code> 实例并在结束时获取它的值</li>
<li>如果拼接 <code>bytes</code> 对象，你可以类似地使用 <code>bytes.join()</code> 或 <code>io.BytesIO</code>，或者你也可以使用 <code>bytearray</code> 对象进行原地拼接。 <code>bytearray</code> 对象是可变的，并且具有高效的重分配机制</li>
<li>如果拼接 <code>tuple</code> 对象，请改为扩展 <code>list</code> 类</li>
<li>对于其它类型，请查看相应的文档</li>
</ul>
</li>
<li><p>某些序列类型 (例如 <code>range</code>) 仅支持遵循特定模式的项序列，因此并不支持序列拼接或重复。</p>
</li>
<li><p>当 <em>x</em> 在 <em>s</em> 中找不到时 <code>index</code> 会引发 <code>ValueError</code>。 不是所有实现都支持传入额外参数 <em>i</em> 和 <em>j</em>。 这两个参数允许高效地搜索序列的子序列。 传入这两个额外参数大致相当于使用 <code>s[i:j].index(x)</code>，但是不会复制任何数据，并且返回的索引是相对于序列的开头而非切片的开头。</p>
</li>
</ol>
<h3 id="不可变序列类型"><a href="#不可变序列类型" class="headerlink" title="不可变序列类型"></a>不可变序列类型</h3><p>不可变序列类型普遍实现而可变序列类型未实现的唯一操作就是对 <code>hash()</code> 内置函数的支持。</p>
<p>这种支持允许不可变类型，例如 <code>tuple</code> 实例被用作 <code>dict</code> 键，以及存储在 <code>set</code> 和 <code>frozenset</code> 实例中。</p>
<p>尝试对包含有不可哈希值的不可变序列进行哈希运算将会导致 <code>TypeError</code>。</p>
<h3 id="可变序列类型"><a href="#可变序列类型" class="headerlink" title="可变序列类型"></a>可变序列类型</h3><p>以下表格中的操作是在可变序列类型上定义的。 <code>collections.abc.MutableSequence</code> ABC 被提供用来更容易地在自定义序列类型上正确实现这些操作。</p>
<p>表格中的 <em>s</em> 是可变序列类型的实例，<em>t</em> 是任意可迭代对象，而 <em>x</em> 是符合对 <em>s</em> 所规定类型与值限制的任何对象 (例如，<code>bytearray</code> 仅接受满足 <code>0 &lt;= x &lt;= 255</code> 值限制的整数)。</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>s[i] = x</code></td>
<td align="left">将 <em>s</em> 的第 <em>i</em> 项替换为 <em>x</em></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s[i:j] = t</code></td>
<td align="left">将 <em>s</em> 从 <em>i</em> 到 <em>j</em> 的切片替换为可迭代对象 <em>t</em> 的内容</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>del s[i:j]</code></td>
<td align="left">等同于 <code>s[i:j] = []</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s[i:j:k] = t</code></td>
<td align="left">将 <code>s[i:j:k]</code> 的元素替换为 <em>t</em> 的元素</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>del s[i:j:k]</code></td>
<td align="left">从列表中移除 <code>s[i:j:k]</code> 的元素</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s.append(x)</code></td>
<td align="left">将 <em>x</em> 添加到序列的末尾 (等同于 <code>s[len(s):len(s)] = [x]</code>)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s.clear()</code></td>
<td align="left">从 <em>s</em> 中移除所有项 (等同于 <code>del s[:]</code>)</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>s.copy()</code></td>
<td align="left">创建 <em>s</em> 的浅拷贝 (等同于 <code>s[:]</code>)</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>s.extend(t)</code> 或 <code>s += t</code></td>
<td align="left">用 <em>t</em> 的内容扩展 <em>s</em> (基本上等同于 <code>s[len(s):len(s)] = t</code>)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s *= n</code></td>
<td align="left">使用 <em>s</em> 的内容重复 <em>n</em> 次来对其进行更新</td>
<td align="left">(6)</td>
</tr>
<tr>
<td align="left"><code>s.insert(i, x)</code></td>
<td align="left">在由 <em>i</em> 给出的索引位置将 <em>x</em> 插入 <em>s</em> (等同于 <code>s[i:i] = [x]</code>)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>s.pop()</code> or <code>s.pop(i)</code></td>
<td align="left">提取在 <em>i</em> 位置上的项，并将其从 <em>s</em> 中移除</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>s.remove(x)</code></td>
<td align="left">删除 <em>s</em> 中第一个 <code>s[i]</code> 等于 <em>x</em> 的项目。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>s.reverse()</code></td>
<td align="left">就地将列表中的元素逆序。</td>
<td align="left">(4)</td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p><em>t</em> 必须与它所替换的切片具有相同的长度。</p>
</li>
<li><p>可选参数 <em>i</em> 默认为 <code>-1</code>，因此在默认情况下会移除并返回最后一项。</p>
</li>
<li><p>当在 <em>s</em> 中找不到 <em>x</em> 时 <code>remove()</code> 操作会引发 <code>ValueError</code>。</p>
</li>
<li><p>当反转大尺寸序列时 <code>reverse()</code> 方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通过间接影响进行的，它并不会返回反转后的序列。</p>
</li>
<li><p>包括 <code>clear()</code> 和 <code>copy()</code> 是为了与不支持切片操作的可变容器 (例如 <code>dict</code> 和 <code>set</code>) 的接口保持一致。 <code>copy()</code> 不是 <code>collections.abc.MutableSequence</code> ABC 的一部分，但大多数具体的可变序列类都提供了它。</p>
<p>3.3 新版功能: <code>clear()</code> 和 <code>copy()</code> 方法。</p>
</li>
<li><p><em>n</em> 值为一个整数，或是一个实现了 <code>__index__()</code> 的对象。 <em>n</em> 值为零或负数将清空序列。 序列中的项不会被拷贝；它们会被多次引用，正如 通用序列操作 中有关 <code>s * n</code> 的说明。</p>
</li>
</ol>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表是可变序列，通常用于存放同类项目的集合（其中精确的相似程度将根据应用而变化）。</p>
<p><em>class</em> <code>list</code>([<em>iterable</em>])</p>
<p>可以用多种方式构建列表：</p>
<ul>
<li>使用一对方括号来表示空列表: <code>[]</code></li>
<li>使用方括号，其中的项以逗号分隔: <code>[a]</code>, <code>[a, b, c]</code></li>
<li>使用列表推导式: <code>[x for x in iterable]</code></li>
<li>使用类型的构造器: <code>list()</code> 或 <code>list(iterable)</code></li>
</ul>
<p>构造器将构造一个列表，其中的项与 <em>iterable</em> 中的项具有相同的的值与顺序。 <em>iterable</em> 可以是序列、支持迭代的容器或其它可迭代对象。 如果 <em>iterable</em> 已经是一个列表，将创建并返回其副本，类似于 <code>iterable[:]</code>。 例如，<code>list('abc')</code> 返回 <code>['a', 'b', 'c']</code> 而 <code>list( (1, 2, 3) )</code> 返回 <code>[1, 2, 3]</code>。 如果没有给出参数，构造器将创建一个空列表 <code>[]</code>。</p>
<p>其它许多操作也会产生列表，包括 <code>sorted()</code> 内置函数。</p>
<p>列表实现了所有 一般 和 可变 序列的操作。 列表还额外提供了以下方法：</p>
<ul>
<li><p><code>sort</code>(<em>**,</em> key=None<em>,</em> reverse=False*)</p>
<p>此方法会对列表进行原地排序，只使用 <code>&lt;</code> 来进行各项间比较。 异常不会被屏蔽 —— 如果有任何比较操作失败，整个排序操作将失败（而列表可能会处于被部分修改的状态）。</p>
<p><code>sort()</code> 接受两个仅限以关键字形式传入的参数 (仅限关键字参数):</p>
<p><em>key</em> 指定带有一个参数的函数，用于从每个列表元素中提取比较键 (例如 <code>key=str.lower</code>)。 对应于列表中每一项的键会被计算一次，然后在整个排序过程中使用。 默认值 <code>None</code> 表示直接对列表项排序而不计算一个单独的键值。</p>
<p>可以使用 <code>functools.cmp_to_key()</code> 将 2.x 风格的 <em>cmp</em> 函数转换为 <em>key</em> 函数。</p>
<p><em>reverse</em> 为一个布尔值。 如果设为 <code>True</code>，则每个列表元素将按反向顺序比较进行排序。</p>
<p>当顺序大尺寸序列时此方法会原地修改该序列以保证空间经济性。 为提醒用户此操作是通过间接影响进行的，它并不会返回排序后的序列（请使用 <code>sorted()</code> 显示地请求一个新的已排序列表实例）。</p>
<p><code>sort()</code> 方法确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 —- 这有利于进行多重排序（例如先按部门、再接薪级排序）。</p>
<p><strong>CPython implementation detail:</strong> 在一个列表被排序期间，尝试改变甚至进行检测也会造成未定义的影响。 Python 的 C 实现会在排序期间将列表显示为空，如果发现列表在排序期间被改变将会引发 <code>ValueError</code>。</p>
</li>
</ul>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组是不可变序列，通常用于储存异构数据的多项集（例如由 <code>enumerate()</code> 内置函数所产生的二元组）。 元组也被用于需要同构数据的不可变序列的情况（例如允许存储到 <code>set</code> 或 <code>dict</code> 的实例）。</p>
<p><em>class</em> <code>tuple</code>([<em>iterable</em>])</p>
<p>可以用多种方式构建元组：</p>
<ul>
<li>使用一对圆括号来表示空元组: <code>()</code></li>
<li>使用一个后缀的逗号来表示单元组: <code>a,</code> 或 <code>(a,)</code></li>
<li>使用以逗号分隔的多个项: <code>a, b, c</code> or <code>(a, b, c)</code></li>
<li>使用内置的 <code>tuple()</code>: <code>tuple()</code> 或 <code>tuple(iterable)</code></li>
</ul>
<p>构造器将构造一个元组，其中的项与 <em>iterable</em> 中的项具有相同的值与顺序。 <em>iterable</em> 可以是序列、支持迭代的容器或其他可迭代对象。 如果 <em>iterable</em> 已经是一个元组，会不加改变地将其返回。 例如，<code>tuple('abc')</code> 返回 <code>('a', 'b', 'c')</code> 而 <code>tuple( [1, 2, 3] )</code> 返回 <code>(1, 2, 3)</code>。 如果没有给出参数，构造器将创建一个空元组 <code>()</code>。</p>
<p>请注意决定生成元组的其实是逗号而不是圆括号。 圆括号只是可选的，生成空元组或需要避免语法歧义的情况除外。 例如，<code>f(a, b, c)</code> 是在调用函数时附带三个参数，而 <code>f((a, b, c))</code> 则是在调用函数时附带一个三元组。</p>
<p>元组实现了所有 一般 序列的操作。</p>
<p>对于通过名称访问相比通过索引访问更清晰的异构数据多项集，<code>collections.namedtuple()</code> 可能是比简单元组对象更为合适的选择。</p>
<h3 id="range-对象"><a href="#range-对象" class="headerlink" title="range 对象"></a>range 对象</h3><p><code>range</code> 类型表示不可变的数字序列，通常用于在 <code>for</code> 循环中循环指定的次数。</p>
<p><em>class</em> <code>range</code>(<em>stop</em>)</p>
<p><em>class</em> <code>range</code>(<em>start</em>, <em>stop</em>[, <em>step</em>])</p>
<p>range 构造器的参数必须为整数（可以是内置的 <code>int</code> 或任何实现了 <code>__index__</code> 特殊方法的对象）。 如果省略 <em>step</em> 参数，其默认值为 <code>1</code>。 如果省略 <em>start</em> 参数，其默认值为 <code>0</code>，如果 <em>step</em> 为零则会引发 <code>ValueError</code>。</p>
<p>如果 <em>step</em> 为正值，确定 range <code>r</code> 内容的公式为 <code>r[i] = start + step*i</code> 其中 <code>i &gt;= 0</code> 且 <code>r[i] &lt; stop</code>。</p>
<p>如果 <em>step</em> 为负值，确定 range 内容的公式仍然为 <code>r[i] = start + step*i</code>，但限制条件改为 <code>i &gt;= 0</code> 且 <code>r[i] &gt; stop</code>.</p>
<p>如果 <code>r[0]</code> 不符合值的限制条件，则该 range 对象为空。 range 对象确实支持负索引，但是会将其解读为从正索引所确定的序列的末尾开始索引。</p>
<p>元素绝对值大于 <code>sys.maxsize</code> 的 range 对象是被允许的，但某些特性 (例如 <code>len()</code>) 可能引发 <code>OverflowError</code>。</p>
<p>一些 range 对象的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>range 对象实现了 一般 序列的所有操作，但拼接和重复除外（这是由于 range 对象只能表示符合严格模式的序列，而重复和拼接通常都会违反这样的模式）。</p>
<ul>
<li><p><code>start</code></p>
<p><em>start</em> 形参的值 (如果该形参未提供则为 <code>0</code>)</p>
</li>
<li><p><code>stop</code></p>
<p><em>stop</em> 形参的值</p>
</li>
<li><p><code>step</code></p>
<p><em>step</em> 形参的值 (如果该形参未提供则为 <code>1</code>)</p>
</li>
</ul>
<p><code>range</code> 类型相比常规 <code>list</code> 或 <code>tuple</code> 的优势在于一个 <code>range</code> 对象总是占用固定数量的（较小）内存，不论其所表示的范围有多大（因为它只保存了 <code>start</code>, <code>stop</code> 和 <code>step</code> 值，并会根据需要计算具体单项或子范围的值）。</p>
<p>range 对象实现了 <code>collections.abc.Sequence</code> ABC，提供如包含检测、元素索引查找、切片等特性，并支持负索引 :</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> r <span class="token operator">=</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> r
range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token number">11</span> <span class="token keyword">in</span> r
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token number">10</span> <span class="token keyword">in</span> r
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token number">5</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token number">10</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>
range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>==</code> 和 <code>!=</code> 检测 range 对象是否相等是将其作为序列来比较。 也就是说，如果两个 range 对象表示相同的值序列就认为它们是相等的。 （请注意比较结果相等的两个 range 对象可能会具有不同的 <code>start</code>, <code>stop</code> 和 <code>step</code> 属性，例如 <code>range(0) == range(2, 1, 3)</code> 而 <code>range(0, 3, 2) == range(0, 4, 2)</code>。）</p>
<p>在 3.2 版更改: 实现 Sequence ABC。 支持切片和负数索引。 使用 <code>int</code> 对象在固定时间内进行成员检测，而不是逐一迭代所有项。</p>
<p>在 3.3 版更改: 定义 ‘==’ 和 ‘!=’ 以根据 range 对象所定义的值序列来进行比较（而不是根据对象的标识）。</p>
<p>3.3 新版功能: <code>start</code>, <code>stop</code> 和 <code>step</code> 属性。</p>
<p>参见</p>
<ul>
<li>linspace recipe 演示了如何实现一个延迟求值版本的适合浮点数应用的 range 对象。</li>
</ul>
<h2 id="文本序列类型-—-str"><a href="#文本序列类型-—-str" class="headerlink" title="文本序列类型 —- str"></a>文本序列类型 —- <code>str</code></h2><p>在 Python 中处理文本数据是使用 <code>str</code> 对象，也称为 <em>字符串</em>。 字符串是由 Unicode 码位构成的不可变 序列。 字符串字面值有多种不同的写法：</p>
<ul>
<li>单引号: <code>'允许包含有 "双" 引号'</code></li>
<li>双引号: <code>"允许包含有 '单' 引号"</code>。</li>
<li>三重引号: <code>'''三重单引号'''</code>, <code>"""三重双引号"""</code></li>
</ul>
<p>使用三重引号的字符串可以跨越多行 —— 其中所有的空白字符都将包含在该字符串字面值中。</p>
<p>作为单一表达式组成部分，之间只由空格分隔的多个字符串字面值会被隐式地转换为单个字符串字面值。 也就是说，<code>("spam " "eggs") == "spam eggs"</code>。</p>
<p>使用 <code>r</code> (“raw”) 前缀来禁用大多数转义序列的处理。</p>
<p>字符串也可以通过使用 <code>str</code> 构造器从其他对象创建。</p>
<p>由于不存在单独的“字符”类型，对字符串做索引操作将产生一个长度为 1 的字符串。 也就是说，对于一个非空字符串 <em>s</em>, <code>s[0] == s[0:1]</code>。</p>
<p>不存在可变的字符串类型，但是 <code>str.join()</code> 或 <code>io.StringIO</code> 可以被被用来根据多个片段高效率地构建字符串。</p>
<p>在 3.3 版更改: 为了与 Python 2 系列的向下兼容，再次允许字符串字面值使用 <code>u</code> 前缀。 它对字符串字面值的含义没有影响，并且不能与 <code>r</code> 前缀同时出现。</p>
<p><em>class</em> <code>str</code>(<em>object=’’</em>)</p>
<p><em>class</em> <code>str</code>(<em>object=b’’</em>, <em>encoding=’utf-8’</em>, <em>errors=’strict’</em>)</p>
<p>返回 <em>object</em> 的 字符串 版本。 如果未提供 <em>object</em> 则返回空字符串。 在其他情况下 <code>str()</code> 的行为取决于 <em>encoding</em> 或 <em>errors</em> 是否有给出，具体见下。</p>
<p>如果 <em>encoding</em> 或 <em>errors</em> 均未给出，<code>str(object)</code> 返回 <code>object.__str__()</code>，这是 <em>object</em> 的“非正式”或格式良好的字符串表示。 对于字符串对象，这是该字符串本身。 如果 <em>object</em> 没有 <code>__str__()</code> 方法，则 <code>str()</code> 将回退为返回 <code>repr(object)</code>。</p>
<p>如果 <em>encoding</em> 或 <em>errors</em> 至少给出其中之一，则 <em>object</em> 应该是一个 bytes-like object (例如 <code>bytes</code> 或 <code>bytearray</code>)。 在此情况下，如果 <em>object</em> 是一个 <code>bytes</code> (或 <code>bytearray</code>) 对象，则 <code>str(bytes, encoding, errors)</code> 等价于 <code>bytes.decode(encoding, errors)</code>。 否则的话，会在调用 <code>bytes.decode()</code> 之前获取缓冲区对象下层的 bytes 对象。 </p>
<p>将一个 <code>bytes</code> 对象传入 <code>str()</code> 而不给出 <em>encoding</em> 或 <em>errors</em> 参数的操作属于第一种情况， 将返回非正式的字符串表示（另请参阅 Python 的 <code>-b</code> 命令行选项）。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>b<span class="token string">'Zoot!'</span><span class="token punctuation">)</span>
<span class="token string">"b'Zoot!'"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h3><p>字符串实现了所有 一般 序列的操作，还额外提供了以下列出的一些附加方法。</p>
<p>字符串还支持两种字符串格式化样式，一种提供了很大程度的灵活性和可定制性 而另一种是基于 C <code>printf</code> 样式的格式化，它可处理的类型范围较窄，并且更难以正确使用，但对于它可处理的情况往往会更为快速 (printf 风格的字符串格式化)。</p>
<p>标准库的 文本处理服务 部分涵盖了许多其他模块，提供各种文本相关工具（例如包含于 <code>re</code> 模块中的正则表达式支持）。</p>
<p><code>str.capitalize</code>()</p>
<p>返回原字符串的副本，其首个字符大写，其余为小写。</p>
<p>在 3.8 版更改: 第一个字符现在被放入了 titlecase 而不是 uppercase。 这意味着复合字母类字符将只有首个字母改为大写，而再不是全部字符大写。</p>
<p><code>str.casefold</code>()</p>
<p>返回原字符串消除大小写的副本。 消除大小写的字符串可用于忽略大小写的匹配。</p>
<p>消除大小写类似于转为小写，但是更加彻底一些，因为它会移除字符串中的所有大小写变化形式。 例如，德语小写字母 <code>'ß'</code> 相当于 <code>"ss"</code>。 由于它已经是小写了，<code>lower()</code> 不会对 <code>'ß'</code> 做任何改变；而 <code>casefold()</code> 则会将其转换为 <code>"ss"</code>。</p>
<p>消除大小写算法的描述请参见 Unicode 标准的 3.13 节。</p>
<p>3.3 新版功能.</p>
<p><code>str.center</code>(<em>width</em>[, <em>fillchar</em>])</p>
<p>返回长度为 <em>width</em> 的字符串，原字符串在其正中。 使用指定的 <em>fillchar</em> 填充两边的空位（默认使用 ASCII 空格符）。 如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</p>
<p><code>str.count</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回子字符串 <em>sub</em> 在 [<em>start</em>, <em>end*] 范围内非重叠出现的次数。 可选参数 *start</em> 与 <em>end</em> 会被解读为切片表示法。</p>
<p><code>str.encode</code>(<em>encoding=’utf-8’</em>, <em>errors=’strict’</em>)</p>
<p>返回原字符串编码为字节串对象的版本。 默认编码为 <code>'utf-8'</code>。 可以给出 <em>errors</em> 来设置不同的错误处理方案。 <em>errors</em> 的默认值为 <code>'strict'</code>，表示编码错误会引发 <code>UnicodeError</code>。 其他可用的值为 <code>'ignore'</code>, <code>'replace'</code>, <code>'xmlcharrefreplace'</code>, <code>'backslashreplace'</code> 以及任何其他通过 <code>codecs.register_error()</code> 注册的值。 要查看可用的编码列表。</p>
<p>By default, the <em>errors</em> argument is not checked for best performances, but only used at the first encoding error. Enable the Python Development Mode, or use a debug build to check <em>errors</em>.</p>
<p>在 3.1 版更改: 加入了对关键字参数的支持。</p>
<p>在 3.9 版更改: The <em>errors</em> is now checked in development mode and in debug mode.</p>
<p><code>str.endswith</code>(<em>suffix</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>如果字符串以指定的 <em>suffix</em> 结束返回 <code>True</code>，否则返回 <code>False</code>。 <em>suffix</em> 也可以为由多个供查找的后缀构成的元组。 如果有可选项 <em>start</em>，将从所指定位置开始检查。 如果有可选项 <em>end</em>，将在所指定位置停止比较。</p>
<p><code>str.expandtabs</code>(<em>tabsize=8</em>)</p>
<p>返回字符串的副本，其中所有的制表符会由一个或多个空格替换，具体取决于当前列位置和给定的制表符宽度。 每 <em>tabsize</em> 个字符设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依次类推）。 要展开字符串，当前列将被设为零并逐一检查字符串中的每个字符。 如果字符为制表符 (<code>\t</code>)，则会在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本身不会被复制。） 如果字符为换行符 (<code>\n</code>) 或回车符 (<code>\r</code>)，它会被复制并将当前列重设为零。 任何其他字符会被不加修改地复制并将当前列加一，不论该字符在被打印时会如何显示。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'01\t012\t0123\t01234'</span><span class="token punctuation">.</span>expandtabs<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'01      012     0123    01234'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'01\t012\t0123\t01234'</span><span class="token punctuation">.</span>expandtabs<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token string">'01  012 0123    01234'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>str.find</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回子字符串 <em>sub</em> 在 <code>s[start:end]</code> 切片内被找到的最小索引。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果 <em>sub</em> 未被找到则返回 <code>-1</code>。</p>
<p>注解</p>
<p><code>find()</code> 方法应该只在你需要知道 <em>sub</em> 所在位置时使用。 要检查 <em>sub</em> 是否为子字符串，请使用 <code>in</code> 操作符:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Py'</span> <span class="token keyword">in</span> <span class="token string">'Python'</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>str.format</code>(<em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>执行字符串格式化操作。 调用此方法的字符串可以包含字符串字面值或者以花括号 <code>{}</code> 括起来的替换域。 每个替换域可以包含一个位置参数的数字索引，或者一个关键字参数的名称。 返回的字符串副本中每个替换域都会被替换为对应参数的字符串值。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"The sum of 1 + 2 is {0}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token string">'The sum of 1 + 2 is 3'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>请参阅 格式字符串语法 了解有关可以在格式字符串中指定的各种格式选项的说明。</p>
<p>注解</p>
<p>当使用 <code>n</code> 类型 (例如: <code>'{:n}'.format(1234)</code>) 来格式化数字 (<code>int</code>, <code>float</code>, <code>complex</code>, <code>decimal.Decimal</code> 及其子类) 的时候，该函数会临时性地将 <code>LC_CTYPE</code> 区域设置为 <code>LC_NUMERIC</code> 区域以解码 <code>localeconv()</code> 的 <code>decimal_point</code> 和 <code>thousands_sep</code> 字段，如果它们是非 ASCII 字符或长度超过 1 字节的话，并且 <code>LC_NUMERIC</code> 区域会与 <code>LC_CTYPE</code> 区域不一致。 这个临时更改会影响其他线程。</p>
<p>在 3.7 版更改: 当使用 <code>n</code> 类型格式化数字时，该函数在某些情况下会临时性地将 <code>LC_CTYPE</code> 区域设置为 <code>LC_NUMERIC</code> 区域。</p>
<p><code>str.format_map</code>(<em>mapping</em>)</p>
<p>类似于 <code>str.format(**mapping)</code>，不同之处在于 <code>mapping</code> 会被直接使用而不是复制到一个 <code>dict</code>。 适宜使用此方法的一个例子是当 <code>mapping</code> 为 dict 的子类的情况：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Default</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__missing__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> key
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{name} was born in {country}'</span><span class="token punctuation">.</span>format_map<span class="token punctuation">(</span>Default<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'Guido'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'Guido was born in country'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
<p><code>str.index</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>类似于 <code>find()</code>，但在找不到子类时会引发 <code>ValueError</code>。</p>
<p><code>str.isalnum</code>()</p>
<p>如果字符串中的所有字符都是字母或数字且至少有一个字符，则返回 <code>True</code> ， 否则返回 <code>False</code> 。 如果 <code>c.isalpha()</code> ， <code>c.isdecimal()</code> ， <code>c.isdigit()</code> ，或 <code>c.isnumeric()</code> 之中有一个返回 <code>True</code> ，则字符<code>c</code>是字母或数字。</p>
<p><code>str.isalpha</code>()</p>
<p>如果字符串中的所有字符都是字母，并且至少有一个字符，返回 <code>True</code> ，否则返回 <code>False</code> 。字母字符是指那些在 Unicode 字符数据库中定义为 “Letter” 的字符，即那些具有 “Lm”、”Lt”、”Lu”、”Ll” 或 “Lo” 之一的通用类别属性的字符。 注意，这与 Unicode 标准中定义的”字母”属性不同。</p>
<p><code>str.isascii</code>()</p>
<p>如果字符串为空或字符串中的所有字符都是 ASCII ，返回 <code>True</code> ，否则返回 <code>False</code> 。ASCII 字符的码点范围是 U+0000-U+007F 。</p>
<p>3.7 新版功能.</p>
<p><code>str.isdecimal</code>()</p>
<p>如果字符串中的所有字符都是十进制字符且该字符串至少有一个字符，则返回 <code>True</code> ， 否则返回 <code>False</code> 。十进制字符指那些可以用来组成10进制数字的字符，例如 U+0660 ，即阿拉伯字母数字0 。 严格地讲，十进制字符是 Unicode 通用类别 “Nd” 中的一个字符。</p>
<p><code>str.isdigit</code>()</p>
<p>如果字符串中的所有字符都是数字，并且至少有一个字符，返回 <code>True</code> ，否则返回 <code>False</code> 。 数字包括十进制字符和需要特殊处理的数字，如兼容性上标数字。这包括了不能用来组成 10 进制数的数字，如 Kharosthi 数。 严格地讲，数字是指属性值为 Numeric_Type=Digit 或 Numeric_Type=Decimal 的字符。</p>
<p><code>str.isidentifier</code>()</p>
<p>如果字符串是有效的标识符，返回 <code>True</code> ，依据语言定义， 标识符和关键字 节。</p>
<p>调用 <code>keyword.iskeyword()</code> 来检测字符串 <code>s</code> 是否为保留标识符，例如 <code>def</code> 和 <code>class</code>。</p>
<p>示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> keyword <span class="token keyword">import</span> iskeyword
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'hello'</span><span class="token punctuation">.</span>isidentifier<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> iskeyword<span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'def'</span><span class="token punctuation">.</span>isidentifier<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> iskeyword<span class="token punctuation">(</span><span class="token string">'def'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>str.islower</code>()</p>
<p>如果字符串中至少有一个区分大小写的字符 且此类字符均为小写则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p><code>str.isnumeric</code>()</p>
<p>如果字符串中至少有一个字符且所有字符均为数值字符则返回 <code>True</code> ，否则返回 <code>False</code> 。 数值字符包括数字字符，以及所有在 Unicode 中设置了数值特性属性的字符，例如 U+2155, VULGAR FRACTION ONE FIFTH。 正式的定义为：数值字符就是具有特征属性值 Numeric_Type=Digit, Numeric_Type=Decimal 或 Numeric_Type=Numeric 的字符。</p>
<p><code>str.isprintable</code>()</p>
<p>如果字符串中所有字符均为可打印字符或字符串为空则返回 <code>True</code> ，否则返回 <code>False</code> 。 不可打印字符是在 Unicode 字符数据库中被定义为 “Other” 或 “Separator” 的字符，例外情况是 ASCII 空格字符 (0x20) 被视作可打印字符。 （请注意在此语境下可打印字符是指当对一个字符串发起调用 <code>repr()</code> 时不必被转义的字符。 它们与字符串写入 <code>sys.stdout</code> 或 <code>sys.stderr</code> 时所需的处理无关。）</p>
<p><code>str.isspace</code>()</p>
<p>如果字符串中只有空白字符且至少有一个字符则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p><em>空白</em> 字符是指在 Unicode 字符数据库 中主要类别为 <code>Zs</code> (“Separator, space”) 或所属双向类为 <code>WS</code>, <code>B</code> 或 <code>S</code> 的字符。</p>
<p><code>str.istitle</code>()</p>
<p>如果字符串中至少有一个字符且为标题字符串则返回 <code>True</code> ，例如大写字符之后只能带非大写字符而小写字符必须有大写字符打头。 否则返回 <code>False</code> 。</p>
<p><code>str.isupper</code>()</p>
<p>如果字符串中至少有一个区分大小写的字符 且此类字符均为大写则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'BANANA'</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'banana'</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'baNana'</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">' '</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>str.join</code>(<em>iterable</em>)</p>
<p>返回一个由 <em>iterable</em> 中的字符串拼接而成的字符串。 如果 <em>iterable</em> 中存在任何非字符串值包括 <code>bytes</code> 对象则会引发 <code>TypeError</code>。 调用该方法的字符串将作为元素之间的分隔。</p>
<p><code>str.ljust</code>(<em>width</em>[, <em>fillchar</em>])</p>
<p>返回长度为 <em>width</em> 的字符串，原字符串在其中靠左对齐。 使用指定的 <em>fillchar</em> 填充空位 (默认使用 ASCII 空格符)。 如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</p>
<p><code>str.lower</code>()</p>
<p>返回原字符串的副本，其所有区分大小写的字符 均转换为小写。</p>
<p>所用转换小写算法的描述请参见 Unicode 标准的 3.13 节。</p>
<p><code>str.lstrip</code>([<em>chars</em>])</p>
<p>返回原字符串的副本，移除其中的前导字符。 <em>chars</em> 参数为指定要移除字符的字符串。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除空白符。 实际上 <em>chars</em> 参数并非指定单个前缀；而是会移除参数值的所有组合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'   spacious   '</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'spacious   '</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'www.example.com'</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token string">'cmowz.'</span><span class="token punctuation">)</span>
<span class="token string">'example.com'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>参见 <code>str.removeprefix()</code> ，该方法将删除单个前缀字符串，而不是全部给定集合中的字符。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Arthur: three!'</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token string">'Arthur: '</span><span class="token punctuation">)</span>
<span class="token string">'ee!'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Arthur: three!'</span><span class="token punctuation">.</span>removeprefix<span class="token punctuation">(</span><span class="token string">'Arthur: '</span><span class="token punctuation">)</span>
<span class="token string">'three!'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>static</em> <code>str.maketrans</code>(<em>x</em>[, <em>y</em>[, <em>z</em>]])</p>
<p>此静态方法返回一个可供 <code>str.translate()</code> 使用的转换对照表。</p>
<p>如果只有一个参数，则它必须是一个将 Unicode 码位序号（整数）或字符（长度为 1 的字符串）映射到 Unicode 码位序号、（任意长度的）字符串或 <code>None</code> 的字典。 字符键将会被转换为码位序号。</p>
<p>如果有两个参数，则它们必须是两个长度相等的字符串，并且在结果字典中，x 中每个字符将被映射到 y 中相同位置的字符。 如果有第三个参数，它必须是一个字符串，其中的字符将在结果中被映射到 <code>None</code>。</p>
<p><code>str.partition</code>(<em>sep</em>)</p>
<p>在 <em>sep</em> 首次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含字符本身以及两个空字符串。</p>
<p><code>str.removeprefix</code>(<em>prefix</em>, <em>/</em>)</p>
<p>如果字符串以 <em>前缀</em> 字符串开头，返回 <code>string[len(prefix):]</code> 。否则，返回原始字符串的副本：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'TestHook'</span><span class="token punctuation">.</span>removeprefix<span class="token punctuation">(</span><span class="token string">'Test'</span><span class="token punctuation">)</span>
<span class="token string">'Hook'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'BaseTestCase'</span><span class="token punctuation">.</span>removeprefix<span class="token punctuation">(</span><span class="token string">'Test'</span><span class="token punctuation">)</span>
<span class="token string">'BaseTestCase'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>str.removesuffix</code>(<em>suffix</em>, <em>/</em>)</p>
<p>如果字符串以 <em>后缀</em> 字符串结尾，并且 <em>后缀</em> 非空，返回 <code>string[:-len(suffix)]</code> 。否则，返回原始字符串的副本：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'MiscTests'</span><span class="token punctuation">.</span>removesuffix<span class="token punctuation">(</span><span class="token string">'Tests'</span><span class="token punctuation">)</span>
<span class="token string">'Misc'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'TmpDirMixin'</span><span class="token punctuation">.</span>removesuffix<span class="token punctuation">(</span><span class="token string">'Tests'</span><span class="token punctuation">)</span>
<span class="token string">'TmpDirMixin'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>str.replace</code>(<em>old</em>, <em>new</em>[, <em>count</em>])</p>
<p>返回字符串的副本，其中出现的所有子字符串 <em>old</em> 都将被替换为 <em>new<em>。 如果给出了可选参数 *count</em>，则只替换前 *count</em> 次出现。</p>
<p><code>str.rfind</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回子字符串 <em>sub</em> 在字符串内被找到的最大（最右）索引，这样 <em>sub</em> 将包含在 <code>s[start:end]</code> 当中。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果未找到则返回 <code>-1</code>。</p>
<p><code>str.rindex</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>类似于 <code>rfind()</code>，但在子字符串 <em>sub</em> 未找到时会引发 <code>ValueError</code>。</p>
<p><code>str.rjust</code>(<em>width</em>[, <em>fillchar</em>])</p>
<p>返回长度为 <em>width</em> 的字符串，原字符串在其中靠右对齐。 使用指定的 <em>fillchar</em> 填充空位 (默认使用 ASCII 空格符)。 如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</p>
<p><code>str.rpartition</code>(<em>sep</em>)</p>
<p>在 <em>sep</em> 最后一次出现的位置拆分字符串，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空字符串以及字符串本身。</p>
<p><code>str.rsplit</code>(<em>sep=None</em>, <em>maxsplit=- 1</em>)</p>
<p>返回一个由字符串内单词组成的列表，使用 <em>sep</em> 作为分隔字符串。 如果给出了 <em>maxsplit*，则最多进行 *maxsplit</em> 次拆分，从 <em>最右边</em> 开始。 如果 <em>sep</em> 未指定或为 <code>None</code>，任何空白字符串都会被作为分隔符。 除了从右边开始拆分，<code>rsplit()</code> 的其他行为都类似于下文所述的 <code>split()</code>。</p>
<p><code>str.rstrip</code>([<em>chars</em>])</p>
<p>返回原字符串的副本，移除其中的末尾字符。 <em>chars</em> 参数为指定要移除字符的字符串。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除空白符。 实际上 <em>chars</em> 参数并非指定单个后缀；而是会移除参数值的所有组合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'   spacious   '</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'   spacious'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'mississippi'</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">'ipz'</span><span class="token punctuation">)</span>
<span class="token string">'mississ'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要删除单个后缀字符串，而不是全部给定集合中的字符。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Monty Python'</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token string">' Python'</span><span class="token punctuation">)</span>
<span class="token string">'M'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Monty Python'</span><span class="token punctuation">.</span>removesuffix<span class="token punctuation">(</span><span class="token string">' Python'</span><span class="token punctuation">)</span>
<span class="token string">'Monty'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>str.split</code>(<em>sep=None</em>, <em>maxsplit=- 1</em>)</p>
<p>返回一个由字符串内单词组成的列表，使用 <em>sep</em> 作为分隔字符串。 如果给出了 <em>maxsplit*，则最多进行 *maxsplit</em> 次拆分（因此，列表最多会有 <code>maxsplit+1</code> 个元素）。 如果 <em>maxsplit</em> 未指定或为 <code>-1</code>，则不限制拆分次数（进行所有可能的拆分）。</p>
<p>如果给出了 <em>sep*，则连续的分隔符不会被组合在一起而是被视为分隔空字符串 (例如 <code>'1,,2'.split(',')</code> 将返回 <code>['1', '', '2']</code>)。 *sep</em> 参数可能由多个字符组成 (例如 <code>'1&lt;&gt;2&lt;&gt;3'.split('&lt;&gt;')</code> 将返回 <code>['1', '2', '3']</code>)。 使用指定的分隔符拆分空字符串将返回 <code>['']</code>。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'1,2,3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'1,2,3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">,</span> maxsplit<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2,3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'1,2,,3,'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>sep</em> 未指定或为 <code>None</code>，则会应用另一种拆分算法：连续的空格会被视为单个分隔符，其结果将不包含开头或末尾的空字符串，如果字符串包含前缀或后缀空格的话。 因此，使用 <code>None</code> 拆分空字符串或仅包含空格的字符串将返回 <code>[]</code>。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'1 2 3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'1 2 3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>maxsplit<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2 3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'   1   2   3   '</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>str.splitlines</code>([<em>keepends</em>])</p>
<p>返回由原字符串中各行组成的列表，在行边界的位置拆分。 结果列表中不包含行边界，除非给出了 <em>keepends</em> 且为真值。</p>
<p>此方法会以下列行边界进行拆分。 特别地，行边界是 universal newlines 的一个超集。</p>
<table>
<thead>
<tr>
<th align="left">表示符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>\n</code></td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left"><code>\r</code></td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left"><code>\r\n</code></td>
<td align="left">回车 + 换行</td>
</tr>
<tr>
<td align="left"><code>\v</code> 或 <code>\x0b</code></td>
<td align="left">行制表符</td>
</tr>
<tr>
<td align="left"><code>\f</code> 或 <code>\x0c</code></td>
<td align="left">换表单</td>
</tr>
<tr>
<td align="left"><code>\x1c</code></td>
<td align="left">文件分隔符</td>
</tr>
<tr>
<td align="left"><code>\x1d</code></td>
<td align="left">组分隔符</td>
</tr>
<tr>
<td align="left"><code>\x1e</code></td>
<td align="left">记录分隔符</td>
</tr>
<tr>
<td align="left"><code>\x85</code></td>
<td align="left">下一行 (C1 控制码)</td>
</tr>
<tr>
<td align="left"><code>\u2028</code></td>
<td align="left">行分隔符</td>
</tr>
<tr>
<td align="left"><code>\u2029</code></td>
<td align="left">段分隔符</td>
</tr>
</tbody></table>
<p>在 3.2 版更改: <code>\v</code> 和 <code>\f</code> 被添加到行边界列表</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'ab c\n\nde fg\rkl\r\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'ab c'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'de fg'</span><span class="token punctuation">,</span> <span class="token string">'kl'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'ab c\n\nde fg\rkl\r\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'ab c\n'</span><span class="token punctuation">,</span> <span class="token string">'\n'</span><span class="token punctuation">,</span> <span class="token string">'de fg\r'</span><span class="token punctuation">,</span> <span class="token string">'kl\r\n'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>不同于 <code>split()</code>，当给出了分隔字符串 <em>sep</em> 时，对于空字符串此方法将返回一个空列表，而末尾的换行不会令结果中增加额外的行:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">""</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">"One line\n"</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'One line'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>作为比较，<code>split('\n')</code> 的结果为:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">''</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Two lines\n'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'Two lines'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>str.startswith</code>(<em>prefix</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>如果字符串以指定的 <em>prefix</em> 开始则返回 <code>True</code>，否则返回 <code>False</code>。 <em>prefix</em> 也可以为由多个供查找的前缀构成的元组。 如果有可选项 <em>start</em>，将从所指定位置开始检查。 如果有可选项 <em>end</em>，将在所指定位置停止比较。</p>
<p><code>str.strip</code>([<em>chars</em>])</p>
<p>返回原字符串的副本，移除其中的前导和末尾字符。 <em>chars</em> 参数为指定要移除字符的字符串。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除空白符。 实际上 <em>chars</em> 参数并非指定单个前缀或后缀；而是会移除参数值的所有组合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'   spacious   '</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'spacious'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'www.example.com'</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token string">'cmowz.'</span><span class="token punctuation">)</span>
<span class="token string">'example'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>最外侧的前导和末尾 <em>chars</em> 参数值将从字符串中移除。 开头端的字符的移除将在遇到一个未包含于 <em>chars</em> 所指定字符集的字符时停止。 类似的操作也将在结尾端发生。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> comment_string <span class="token operator">=</span> <span class="token string">'#....... Section 3.2.1 Issue #32 .......'</span>
<span class="token operator">>></span><span class="token operator">></span> comment_string<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token string">'.#! '</span><span class="token punctuation">)</span>
<span class="token string">'Section 3.2.1 Issue #32'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>str.swapcase</code>()</p>
<p>返回原字符串的副本，其中大写字符转换为小写，反之亦然。 请注意 <code>s.swapcase().swapcase() == s</code> 并不一定为真值。</p>
<p><code>str.title</code>()</p>
<p>返回原字符串的标题版本，其中每个单词第一个字母为大写，其余字母为小写。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Hello world'</span><span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'Hello World'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。 该定义在多数情况下都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望的结果:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"they're bill's friends from the UK"</span><span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">"They'Re Bill'S Friends From The Uk"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以使用正则表达式来构建针对撇号的特别处理:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> re
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">titlecase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">"[A-Za-z]+('[A-Za-z]+)?"</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                   <span class="token keyword">lambda</span> mo<span class="token punctuation">:</span> mo<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>capitalize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                   s<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> titlecase<span class="token punctuation">(</span><span class="token string">"they're bill's friends."</span><span class="token punctuation">)</span>
<span class="token string">"They're Bill's Friends."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>str.translate</code>(<em>table</em>)</p>
<p>返回原字符串的副本，其中每个字符按给定的转换表进行映射。 转换表必须是一个使用 <code>__getitem__()</code> 来实现索引操作的对象，通常为 mapping 或 sequence。 当以 Unicode 码位序号（整数）为索引时，转换表对象可以做以下任何一种操作：返回 Unicode 序号或字符串，将字符映射为一个或多个字符；返回 <code>None</code>，将字符从结果字符串中删除；或引发 <code>LookupError</code> 异常，将字符映射为其自身。</p>
<p>你可以使用 <code>str.maketrans()</code> 基于不同格式的字符到字符映射来创建一个转换映射表。</p>
<p><code>str.upper</code>()</p>
<p>返回原字符串的副本，其中所有区分大小写的字符 均转换为大写。 请注意如果 <code>s</code> 包含不区分大小写的字符或者如果结果字符的 Unicode 类别不是 “Lu” (Letter, uppercase) 而是 “Lt” (Letter, titlecase) 则 <code>s.upper().isupper()</code> 有可能为 <code>False</code>。</p>
<p>所用转换大写算法的描述请参见 Unicode 标准的 3.13 节。</p>
<p><code>str.zfill</code>(<em>width</em>)</p>
<p>返回原字符串的副本，在左边填充 ASCII <code>'0'</code> 数码使其长度变为 <em>width*。 正负值前缀 (<code>'+'</code>/<code>'-'</code>) 的处理方式是在正负符号 *之后</em> 填充而非在之前。 如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原字符串的副本。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"42"</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token string">'00042'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">"-42"</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token string">'-0042'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="printf-风格的字符串格式化"><a href="#printf-风格的字符串格式化" class="headerlink" title="printf 风格的字符串格式化"></a><code>printf</code> 风格的字符串格式化</h3><p>注解</p>
<p>此处介绍的格式化操作具有多种怪异特性，可能导致许多常见错误（例如无法正确显示元组和字典）。 使用较新的 格式化字符串字面值，<code>str.format()</code> 接口或 模板字符串 有助于避免这样的错误。 这些替代方案中的每一种都更好地权衡并提供了简单、灵活以及可扩展性优势。</p>
<p>字符串具有一种特殊的内置操作：使用 <code>%</code> (取模) 运算符。 这也被称为字符串的 <em>格式化</em> 或 <em>插值</em> 运算符。 对于 <code>format % values</code> (其中 <em>format</em> 为一个字符串)，在 <em>format</em> 中的 <code>%</code> 转换标记符将被替换为零个或多个 <em>values</em> 条目。 其效果类似于在 C 语言中使用 <code>sprintf()</code>。</p>
<p>如果 <em>format</em> 要求一个单独参数，则 <em>values</em> 可以为一个非元组对象。 否则的话，<em>values</em> 必须或者是一个包含项数与格式字符串中指定的转换符项数相同的元组，或者是一个单独映射对象（例如字典）。</p>
<p>转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：</p>
<ol>
<li><code>'%'</code> 字符，用于标记转换符的起始。</li>
<li>映射键（可选），由加圆括号的字符序列组成 (例如 <code>(somename)</code>)。</li>
<li>转换旗标（可选），用于影响某些转换类型的结果。</li>
<li>最小字段宽度（可选）。 如果指定为 <code>'*'</code> (星号)，则实际宽度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。</li>
<li>精度（可选），以在 <code>'.'</code> (点号) 之后加精度值的形式给出。 如果指定为 <code>'*'</code> (星号)，则实际精度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为精度之后的元素。</li>
<li>长度修饰符（可选）。</li>
<li>转换类型。</li>
</ol>
<p>当右边的参数为一个字典（或其他映射类型）时，字符串中的格式 <em>必须</em> 包含加圆括号的映射键，对应 <code>'%'</code> 字符之后字典中的每一项。 映射键将从映射中选取要格式化的值。 例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%(language)s has %(number)03d quote types.'</span> <span class="token operator">%</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>       <span class="token punctuation">{</span><span class="token string">'language'</span><span class="token punctuation">:</span> <span class="token string">"Python"</span><span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
Python has <span class="token number">002</span> quote types<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在此情况下格式中不能出现 <code>*</code> 标记符（因其需要一个序列类的参数列表）。</p>
<p>转换旗标为：</p>
<table>
<thead>
<tr>
<th align="left">旗标</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘#’</code></td>
<td align="left">值的转换将使用“替代形式”（具体定义见下文）。</td>
</tr>
<tr>
<td align="left"><code>‘0’</code></td>
<td align="left">转换将为数字值填充零字符。</td>
</tr>
<tr>
<td align="left"><code>‘-‘</code></td>
<td align="left">转换值将靠左对齐（如果同时给出 <code>‘0’</code> 转换，则会覆盖后者）。</td>
</tr>
<tr>
<td align="left"><code>‘ ‘</code></td>
<td align="left">(空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。</td>
</tr>
<tr>
<td align="left"><code>‘+’</code></td>
<td align="left">符号字符 (<code>‘+’</code> 或 <code>‘-‘</code>) 将显示于转换结果的开头（会覆盖 “空格” 旗标）。</td>
</tr>
</tbody></table>
<p>可以给出长度修饰符 (<code>h</code>, <code>l</code> 或 <code>L</code>)，但会被忽略，因为对 Python 来说没有必要 — 所以 <code>%ld</code> 等价于 <code>%d</code>。</p>
<p>转换类型为：</p>
<table>
<thead>
<tr>
<th align="left">转换符</th>
<th align="left">含意</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘d’</code></td>
<td align="left">有符号十进制整数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘i’</code></td>
<td align="left">有符号十进制整数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘o’</code></td>
<td align="left">有符号八进制数。</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>‘u’</code></td>
<td align="left">过时类型 — 等价于 <code>‘d’</code>。</td>
<td align="left">(6)</td>
</tr>
<tr>
<td align="left"><code>‘x’</code></td>
<td align="left">有符号十六进制数（小写）。</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>‘X’</code></td>
<td align="left">有符号十六进制数（大写）。</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>‘e’</code></td>
<td align="left">浮点指数格式（小写）。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘E’</code></td>
<td align="left">浮点指数格式（大写）。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘f’</code></td>
<td align="left">浮点十进制格式。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘F’</code></td>
<td align="left">浮点十进制格式。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘g’</code></td>
<td align="left">浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制格式。</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>‘G’</code></td>
<td align="left">浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制格式。</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>‘c’</code></td>
<td align="left">单个字符（接受整数或单个字符的字符串）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘r’</code></td>
<td align="left">字符串（使用 <code>repr()</code> 转换任何 Python 对象）。</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>‘s’</code></td>
<td align="left">字符串（使用 <code>str()</code> 转换任何 Python 对象）。</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>‘a’</code></td>
<td align="left">字符串（使用 <code>ascii()</code> 转换任何 Python 对象）。</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>‘%’</code></td>
<td align="left">不转换参数，在结果中输出一个 <code>‘%’</code> 字符。</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p>此替代形式会在第一个数码之前插入标示八进制数的前缀 (<code>'0o'</code>)。</p>
</li>
<li><p>此替代形式会在第一个数码之前插入 <code>'0x'</code> 或 <code>'0X'</code> 前缀（取决于是使用 <code>'x'</code> 还是 <code>'X'</code> 格式）。</p>
</li>
<li><p>此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。</p>
<p>小数点后的数码位数由精度决定，默认为 6。</p>
</li>
<li><p>此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。</p>
<p>小数点前后的有效数码位数由精度决定，默认为 6。</p>
</li>
<li><p>如果精度为 <code>N</code>，输出将截短为 <code>N</code> 个字符。</p>
</li>
<li><p>参见 <a href="https://www.python.org/dev/peps/pep-0237" target="_blank" rel="noopener"><strong>PEP 237</strong></a>。</p>
</li>
</ol>
<p>由于 Python 字符串显式指明长度，<code>%s</code> 转换不会将 <code>'\0'</code> 视为字符串的结束。</p>
<p>在 3.1 版更改: 绝对值超过 1e50 的 <code>%f</code> 转换不会再被替换为 <code>%g</code> 转换。</p>
<h2 id="二进制序列类型-—-bytes-bytearray-memoryview"><a href="#二进制序列类型-—-bytes-bytearray-memoryview" class="headerlink" title="二进制序列类型 —- bytes, bytearray, memoryview"></a>二进制序列类型 —- <code>bytes</code>, <code>bytearray</code>, <code>memoryview</code></h2><p>操作二进制数据的核心内置类型是 <code>bytes</code> 和 <code>bytearray</code>。 它们由 <code>memoryview</code> 提供支持，该对象使用 缓冲区协议 来访问其他二进制对象所在内存，不需要创建对象的副本。</p>
<p><code>array</code> 模块支持高效地存储基本数据类型，例如 32 位整数和 IEEE754 双精度浮点值。</p>
<h3 id="bytes-对象"><a href="#bytes-对象" class="headerlink" title="bytes 对象"></a>bytes 对象</h3><p>bytes 对象是由单个字节构成的不可变序列。 由于许多主要二进制协议都基于 ASCII 文本编码，因此 bytes 对象提供了一些仅在处理 ASCII 兼容数据时可用，并且在许多特性上与字符串对象紧密相关的方法。</p>
<p><em>class</em> <code>bytes</code>([<em>source</em>[, <em>encoding</em>[, <em>errors</em>]]])</p>
<p>首先，表示 bytes 字面值的语法与字符串字面值的大致相同，只是添加了一个 <code>b</code> 前缀：</p>
<ul>
<li>单引号: <code>b'同样允许嵌入 "双" 引号'</code>。</li>
<li>双引号: <code>b"同样允许嵌入 '单' 引号"</code>。</li>
<li>三重引号: <code>b'''三重单引号'''</code>, <code>b"""三重双引号"""</code></li>
</ul>
<p>bytes 字面值中只允许 ASCII 字符（无论源代码声明的编码为何）。 任何超出 127 的二进制值必须使用相应的转义序列形式加入 bytes 字面值。</p>
<p>像字符串字面值一样，bytes 字面值也可以使用 <code>r</code> 前缀来禁用转义序列处理。 </p>
<p>虽然 bytes 字面值和表示法是基于 ASCII 文本的，但 bytes 对象的行为实际上更像是不可变的整数序列，序列中的每个值的大小被限制为 <code>0 &lt;= x &lt; 256</code> (如果违反此限制将引发 <code>ValueError</code>)。 这种限制是有意设计用以强调以下事实，虽然许多二进制格式都包含基于 ASCII 的元素，可以通过某些面向文本的算法进行有用的操作，但情况对于任意二进制数据来说通常却并非如此（盲目地将文本处理算法应用于不兼容 ASCII 的二进制数据格式往往将导致数据损坏）。</p>
<p>除了字面值形式，bytes 对象还可以通过其他几种方式来创建：</p>
<ul>
<li>指定长度的以零值填充的 bytes 对象: <code>bytes(10)</code></li>
<li>通过由整数组成的可迭代对象: <code>bytes(range(20))</code></li>
<li>通过缓冲区协议复制现有的二进制数据: <code>bytes(obj)</code></li>
</ul>
<p>由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相应地，bytes 类型具有从此种格式读取数据的附加类方法：</p>
<ul>
<li><p><em>classmethod</em> <code>fromhex</code>(<em>string</em>)</p>
<p>此 <code>bytes</code> 类方法返回一个解码给定字符串的 bytes 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> bytes<span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token string">'2Ef0 F1f2  '</span><span class="token punctuation">)</span>
b<span class="token string">'.\xf0\xf1\xf2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.7 版更改: <code>bytes.fromhex()</code> 现在会忽略所有 ASCII 空白符而不只是空格符。</p>
</li>
</ul>
<p>存在一个反向转换函数，可以将 bytes 对象转换为对应的十六进制表示。</p>
<ul>
<li><p><code>hex</code>([<em>sep</em>[, <em>bytes_per_sep</em>]])</p>
<p>返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'\xf0\xf1\xf2'</span><span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'f0f1f2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果你希望令十六进制数字符串更易读，你可以指定单个字符分隔符作为 <em>sep</em> 形参包含于输出中。 默认会放在每个字节之间。 第二个可选的 <em>bytes_per_sep</em> 形参控制间距。 正值会从右开始计算分隔符的位置，负值则是从左开始。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> value <span class="token operator">=</span> b<span class="token string">'\xf0\xf1\xf2'</span>
<span class="token operator">>></span><span class="token operator">></span> value<span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token string">'-'</span><span class="token punctuation">)</span>
<span class="token string">'f0-f1-f2'</span>
<span class="token operator">>></span><span class="token operator">></span> value<span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token string">'_'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token string">'f0_f1f2'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'UUDDLRLRAB'</span><span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token string">'55554444 4c524c52 4142'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p>在 3.8 版更改: <code>bytes.hex()</code> 现在支持可选的 <em>sep</em> 和 <em>bytes_per_sep</em> 形参以在十六进制输出的字节之间插入分隔符。</p>
</li>
</ul>
<p>由于 bytes 对象是由整数构成的序列（类似于元组），因此对于一个 bytes 对象 <em>b</em>，<code>b[0]</code> 将为一个整数，而 <code>b[0:1]</code> 将为一个长度为 1 的 bytes 对象。 （这与文本字符串不同，索引和切片所产生的将都是一个长度为 1 的字符串）。</p>
<p>bytes 对象的表示使用字面值格式 (<code>b'...'</code>)，因为它通常都要比像 <code>bytes([46, 46, 46])</code> 这样的格式更好用。 你总是可以使用 <code>list(b)</code> 将 bytes 对象转换为一个由整数构成的列表。</p>
<p>注解</p>
<p>针对 Python 2.x 用户的说明：在 Python 2.x 系列中，允许 8 位字符串（ 2.x 所提供的最接近内置二进制数据类型的对象）与 Unicode 字符串进行各种隐式转换。 这是为了实现向下兼容的变通做法，以适应 Python 最初只支持 8 位文本而 Unicode 文本是后来才被加入这一事实。 在 Python 3.x 中，这些隐式转换已被取消 —— 8 位二进制数据与 Unicode 文本间的转换必须显式地进行，bytes 与字符串对象的比较结果将总是不相等。</p>
<h3 id="bytearray-对象"><a href="#bytearray-对象" class="headerlink" title="bytearray 对象"></a>bytearray 对象</h3><p><code>bytearray</code> 对象是 <code>bytes</code> 对象的可变对应物。</p>
<p><em>class</em> <code>bytearray</code>([<em>source</em>[, <em>encoding</em>[, <em>errors</em>]]])</p>
<p>bytearray 对象没有专属的字面值语法，它们总是通过调用构造器来创建：</p>
<ul>
<li>创建一个空实例: <code>bytearray()</code></li>
<li>创建一个指定长度的以零值填充的实例: <code>bytearray(10)</code></li>
<li>通过由整数组成的可迭代对象: <code>bytearray(range(20))</code></li>
<li>通过缓冲区协议复制现有的二进制数据: <code>bytearray(b'Hi!')</code></li>
</ul>
<p>由于 bytearray 对象是可变的，该对象除了 bytes 和 bytearray 操作 中所描述的 bytes 和 bytearray 共有操作之外，还支持 可变 序列操作。</p>
<p>由于两个十六进制数码精确对应一个字节，因此十六进制数是描述二进制数据的常用格式。 相应地，bytearray 类型具有从此种格式读取数据的附加类方法：</p>
<ul>
<li><p><em>classmethod</em> <code>fromhex</code>(<em>string</em>)</p>
<p><code>bytearray</code> 类方法返回一个解码给定字符串的 bytearray 对象。 字符串必须由表示每个字节的两个十六进制数码构成，其中的 ASCII 空白符会被忽略。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> bytearray<span class="token punctuation">.</span>fromhex<span class="token punctuation">(</span><span class="token string">'2Ef0 F1f2  '</span><span class="token punctuation">)</span>
bytearray<span class="token punctuation">(</span>b<span class="token string">'.\xf0\xf1\xf2'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.7 版更改: <code>bytearray.fromhex()</code> 现在会忽略所有 ASCII 空白符而不只是空格符。</p>
</li>
</ul>
<p>存在一个反向转换函数，可以将 bytearray 对象转换为对应的十六进制表示。</p>
<ul>
<li><p><code>hex</code>([<em>sep</em>[, <em>bytes_per_sep</em>]])</p>
<p>返回一个字符串对象，该对象包含实例中每个字节的两个十六进制数字。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> bytearray<span class="token punctuation">(</span>b<span class="token string">'\xf0\xf1\xf2'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'f0f1f2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p>在 3.8 版更改: 与 <code>bytes.hex()</code> 相似， <code>bytearray.hex()</code> 现在支持可选的 <em>sep</em> 和 <em>bytes_per_sep</em> 参数以在十六进制输出的字节之间插入分隔符。</p>
</li>
</ul>
<p>由于 bytearray 对象是由整数构成的序列（类似于列表），因此对于一个 bytearray 对象 <em>b</em>，<code>b[0]</code> 将为一个整数，而 <code>b[0:1]</code> 将为一个长度为 1 的 bytearray 对象。 （这与文本字符串不同，索引和切片所产生的将都是一个长度为 1 的字符串）。</p>
<p>bytearray 对象的表示使用 bytes 对象字面值格式 (<code>bytearray(b'...')</code>)，因为它通常都要比 <code>bytearray([46, 46, 46])</code> 这样的格式更好用。 你总是可以使用 <code>list(b)</code> 将 bytearray 对象转换为一个由整数构成的列表。</p>
<h3 id="bytes-和-bytearray-操作"><a href="#bytes-和-bytearray-操作" class="headerlink" title="bytes 和 bytearray 操作"></a>bytes 和 bytearray 操作</h3><p>bytes 和 bytearray 对象都支持 通用 序列操作。 它们不仅能与相同类型的操作数，也能与任何 bytes-like object 进行互操作。 由于这样的灵活性，它们可以在操作中自由地混合而不会导致错误。 但是，操作结果的返回值类型可能取决于操作数的顺序。</p>
<p>注解</p>
<p>bytes 和 bytearray 对象的方法不接受字符串作为其参数，就像字符串的方法不接受 bytes 对象作为其参数一样。 例如，你必须使用以下写法:</p>
<pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token string">"abc"</span>
b <span class="token operator">=</span> a<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"f"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>和:</p>
<pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> b<span class="token string">"abc"</span>
b <span class="token operator">=</span> a<span class="token punctuation">.</span>replace<span class="token punctuation">(</span>b<span class="token string">"a"</span><span class="token punctuation">,</span> b<span class="token string">"f"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>某些 bytes 和 bytearray 操作假定使用兼容 ASCII 的二进制格式，因此在处理任意二进数数据时应当避免使用。 这些限制会在下文中说明。</p>
<p>注解</p>
<p>使用这些基于 ASCII 的操作来处理未以基于 ASCII 的格式存储的二进制数据可能会导致数据损坏。</p>
<p>bytes 和 bytearray 对象的下列方法可以用于任意二进制数据。</p>
<p><code>bytes.count</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p><code>bytearray.count</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回子序列 <em>sub</em> 在 [<em>start</em>, <em>end*] 范围内非重叠出现的次数。 可选参数 *start</em> 与 <em>end</em> 会被解读为切片表示法。</p>
<p>要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。</p>
<p>在 3.3 版更改: 也接受 0 至 255 范围内的整数作为子序列。</p>
<p><code>bytes.removeprefix</code>(<em>prefix</em>, <em>/</em>)</p>
<p><code>bytearray.removeprefix</code>(<em>prefix</em>, <em>/</em>)</p>
<p>如果二进制数据以 <em>前缀</em> 字符串开头，返回 <code>bytes[len(prefix):]</code> 。否则，返回原始二进制数据的副本：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'TestHook'</span><span class="token punctuation">.</span>removeprefix<span class="token punctuation">(</span>b<span class="token string">'Test'</span><span class="token punctuation">)</span>
b<span class="token string">'Hook'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'BaseTestCase'</span><span class="token punctuation">.</span>removeprefix<span class="token punctuation">(</span>b<span class="token string">'Test'</span><span class="token punctuation">)</span>
b<span class="token string">'BaseTestCase'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>前缀可以是任意 bytes-like object。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p>3.9 新版功能.</p>
<p><code>bytes.removesuffix</code>(<em>suffix</em>, <em>/</em>)</p>
<p><code>bytearray.removesuffix</code>(<em>suffix</em>, <em>/</em>)</p>
<p>如果二进制数据以 <em>后缀</em> 字符串结尾，并且 <em>后缀</em> 非空，返回 <code>bytes[:-len(suffix)]</code> 。否则，返回原始二进制数据的副本：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'MiscTests'</span><span class="token punctuation">.</span>removesuffix<span class="token punctuation">(</span>b<span class="token string">'Tests'</span><span class="token punctuation">)</span>
b<span class="token string">'Misc'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'TmpDirMixin'</span><span class="token punctuation">.</span>removesuffix<span class="token punctuation">(</span>b<span class="token string">'Tests'</span><span class="token punctuation">)</span>
b<span class="token string">'TmpDirMixin'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>后缀可以是任意 bytes-like object。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p>3.9 新版功能.</p>
<p><code>bytes.decode</code>(<em>encoding=’utf-8’</em>, <em>errors=’strict’</em>)</p>
<p><code>bytearray.decode</code>(<em>encoding=’utf-8’</em>, <em>errors=’strict’</em>)</p>
<p>返回从给定 bytes 解码出来的字符串。 默认编码为 <code>'utf-8'</code>。 可以给出 <em>errors</em> 来设置不同的错误处理方案。 <em>errors</em> 的默认值为 <code>'strict'</code>，表示编码错误会引发 <code>UnicodeError</code>。 其他可用的值为 <code>'ignore'</code>, <code>'replace'</code> 以及任何其他通过 <code>codecs.register_error()</code> 注册的名称。</p>
<p>By default, the <em>errors</em> argument is not checked for best performances, but only used at the first decoding error. Enable the Python Development Mode, or use a debug build to check <em>errors</em>.</p>
<p>注解</p>
<p>将 <em>encoding</em> 参数传给 <code>str</code> 允许直接解码任何 bytes-like object，无须创建临时的 bytes 或 bytearray 对象。</p>
<p>在 3.1 版更改: 加入了对关键字参数的支持。</p>
<p>在 3.9 版更改: The <em>errors</em> is now checked in development mode and in debug mode.</p>
<p><code>bytes.endswith</code>(<em>suffix</em>[, <em>start</em>[, <em>end</em>]])</p>
<p><code>bytearray.endswith</code>(<em>suffix</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>如果二进制数据以指定的 <em>suffix</em> 结束则返回 <code>True</code>，否则返回 <code>False</code>。 <em>suffix</em> 也可以为由多个供查找的后缀构成的元组。 如果有可选项 <em>start</em>，将从所指定位置开始检查。 如果有可选项 <em>end</em>，将在所指定位置停止比较。</p>
<p>要搜索的后缀可以是任意 bytes-like object。</p>
<p><code>bytes.find</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p><code>bytearray.find</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回子序列 <em>sub</em> 在数据中被找到的最小索引，<em>sub</em> 包含于切片 <code>s[start:end]</code> 之内。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果 <em>sub</em> 未被找到则返回 <code>-1</code>。</p>
<p>要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。</p>
<p>注解</p>
<p><code>find()</code> 方法应该只在你需要知道 <em>sub</em> 所在位置时使用。 要检查 <em>sub</em> 是否为子串，请使用 <code>in</code> 操作符:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Py'</span> <span class="token keyword">in</span> b<span class="token string">'Python'</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.3 版更改: 也接受 0 至 255 范围内的整数作为子序列。</p>
<p><code>bytes.index</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p><code>bytearray.index</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>类似于 <code>find()</code>，但在找不到子序列时会引发 <code>ValueError</code>。</p>
<p>要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。</p>
<p>在 3.3 版更改: 也接受 0 至 255 范围内的整数作为子序列。</p>
<p><code>bytes.join</code>(<em>iterable</em>)</p>
<p><code>bytearray.join</code>(<em>iterable</em>)</p>
<p>返回一个由 <em>iterable</em> 中的二进制数据序列拼接而成的 bytes 或 bytearray 对象。 如果 <em>iterable</em> 中存在任何非 字节类对象 包括存在 <code>str</code> 对象值则会引发 <code>TypeError</code>。 提供该方法的 bytes 或 bytearray 对象的内容将作为元素之间的分隔。</p>
<p><em>static</em> <code>bytes.maketrans</code>(<em>from</em>, <em>to</em>)</p>
<p><em>static</em> <code>bytearray.maketrans</code>(<em>from</em>, <em>to</em>)</p>
<p>此静态方法返回一个可用于 <code>bytes.translate()</code> 的转换对照表，它将把 <em>from</em> 中的每个字符映射为 <em>to</em> 中相同位置上的字符；<em>from</em> 与 <em>to</em> 必须都是 字节类对象 并且具有相同的长度。</p>
<p>3.1 新版功能.</p>
<p><code>bytes.partition</code>(<em>sep</em>)</p>
<p><code>bytearray.partition</code>(<em>sep</em>)</p>
<p>在 <em>sep</em> 首次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分、分隔符本身或其 bytearray 副本，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含原序列以及两个空的 bytes 或 bytearray 对象。</p>
<p>要搜索的分隔符可以是任意 bytes-like object。</p>
<p><code>bytes.replace</code>(<em>old</em>, <em>new</em>[, <em>count</em>])</p>
<p><code>bytearray.replace</code>(<em>old</em>, <em>new</em>[, <em>count</em>])</p>
<p>返回序列的副本，其中出现的所有子序列 <em>old</em> 都将被替换为 <em>new<em>。 如果给出了可选参数 *count</em>，则只替换前 *count</em> 次出现。</p>
<p>要搜索的子序列及其替换序列可以是任意 bytes-like object。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.rfind</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p><code>bytearray.rfind</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>返回子序列 <em>sub</em> 在序列内被找到的最大（最右）索引，这样 <em>sub</em> 将包含在 <code>s[start:end]</code> 当中。 可选参数 <em>start</em> 与 <em>end</em> 会被解读为切片表示法。 如果未找到则返回 <code>-1</code>。</p>
<p>要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。</p>
<p>在 3.3 版更改: 也接受 0 至 255 范围内的整数作为子序列。</p>
<p><code>bytes.rindex</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p><code>bytearray.rindex</code>(<em>sub</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>类似于 <code>rfind()</code>，但在子序列 <em>sub</em> 未找到时会引发 <code>ValueError</code>。</p>
<p>要搜索的子序列可以是任意 bytes-like object 或是 0 至 255 范围内的整数。</p>
<p>在 3.3 版更改: 也接受 0 至 255 范围内的整数作为子序列。</p>
<p><code>bytes.rpartition</code>(<em>sep</em>)</p>
<p><code>bytearray.rpartition</code>(<em>sep</em>)</p>
<p>在 <em>sep</em> 最后一次出现的位置拆分序列，返回一个 3 元组，其中包含分隔符之前的部分，分隔符本身或其 bytearray 副本，以及分隔符之后的部分。 如果分隔符未找到，则返回的 3 元组中包含两个空的 bytes 或 bytearray 对象以及原序列的副本。</p>
<p>要搜索的分隔符可以是任意 bytes-like object。</p>
<p><code>bytes.startswith</code>(<em>prefix</em>[, <em>start</em>[, <em>end</em>]])</p>
<p><code>bytearray.startswith</code>(<em>prefix</em>[, <em>start</em>[, <em>end</em>]])</p>
<p>如果二进制数据以指定的 <em>prefix</em> 开头则返回 <code>True</code>，否则返回 <code>False</code>。 <em>prefix</em> 也可以为由多个供查找的前缀构成的元组。 如果有可选项 <em>start</em>，将从所指定位置开始检查。 如果有可选项 <em>end</em>，将在所指定位置停止比较。</p>
<p>要搜索的前缀可以是任意 bytes-like object。</p>
<p><code>bytes.translate</code>(<em>table</em>, <em>/</em>, <em>delete=b’’</em>)</p>
<p><code>bytearray.translate</code>(<em>table</em>, <em>/</em>, <em>delete=b’’</em>)</p>
<p>返回原 bytes 或 bytearray 对象的副本，移除其中所有在可选参数 <em>delete</em> 中出现的 bytes，其余 bytes 将通过给定的转换表进行映射，该转换表必须是长度为 256 的 bytes 对象。</p>
<p>你可以使用 <code>bytes.maketrans()</code> 方法来创建转换表。</p>
<p>对于仅需移除字符的转换，请将 <em>table</em> 参数设为 <code>None</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'read this short text'</span><span class="token punctuation">.</span>translate<span class="token punctuation">(</span>None<span class="token punctuation">,</span> b<span class="token string">'aeiou'</span><span class="token punctuation">)</span>
b<span class="token string">'rd ths shrt txt'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.6 版更改: 现在支持将 <em>delete</em> 作为关键字参数。</p>
<p>以下 bytes 和 bytearray 对象的方法的默认行为会假定使用兼容 ASCII 的二进制格式，但通过传入适当的参数仍然可用于任意二进制数据。 请注意本小节中所有的 bytearray 方法都 <em>不是</em> 原地执行操作，而是会产生新的对象。</p>
<p><code>bytes.center</code>(<em>width</em>[, <em>fillbyte</em>])</p>
<p><code>bytearray.center</code>(<em>width</em>[, <em>fillbyte</em>])</p>
<p>返回原对象的副本，在长度为 <em>width</em> 的序列内居中，使用指定的 <em>fillbyte</em> 填充两边的空位（默认使用 ASCII 空格符）。 对于 <code>bytes</code> 对象，如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原序列的副本。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.ljust</code>(<em>width</em>[, <em>fillbyte</em>])</p>
<p><code>bytearray.ljust</code>(<em>width</em>[, <em>fillbyte</em>])</p>
<p>返回原对象的副本，在长度为 <em>width</em> 的序列中靠左对齐。 使用指定的 <em>fillbyte</em> 填充空位（默认使用 ASCII 空格符）。 对于 <code>bytes</code> 对象，如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原序列的副本。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.lstrip</code>([<em>chars</em>])</p>
<p><code>bytearray.lstrip</code>([<em>chars</em>])</p>
<p>返回原序列的副本，移除指定的前导字节。 <em>chars</em> 参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于 ASCII 字符。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除 ASCII 空白符。 <em>chars</em> 参数并非指定单个前缀；而是会移除参数值的所有组合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'   spacious   '</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'spacious   '</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'www.example.com'</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span>b<span class="token string">'cmowz.'</span><span class="token punctuation">)</span>
b<span class="token string">'example.com'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要移除的二进制序列可以是任意 bytes-like object 。 要删除单个前缀字符串，而不是全部给定集合中的字符，请参见 <code>str.removeprefix()</code> 方法。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Arthur: three!'</span><span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span>b<span class="token string">'Arthur: '</span><span class="token punctuation">)</span>
b<span class="token string">'ee!'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Arthur: three!'</span><span class="token punctuation">.</span>removeprefix<span class="token punctuation">(</span>b<span class="token string">'Arthur: '</span><span class="token punctuation">)</span>
b<span class="token string">'three!'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.rjust</code>(<em>width</em>[, <em>fillbyte</em>])</p>
<p><code>bytearray.rjust</code>(<em>width</em>[, <em>fillbyte</em>])</p>
<p>返回原对象的副本，在长度为 <em>width</em> 的序列中靠右对齐。 使用指定的 <em>fillbyte</em> 填充空位（默认使用 ASCII 空格符）。 对于 <code>bytes</code> 对象，如果 <em>width</em> 小于等于 <code>len(s)</code> 则返回原序列的副本。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.rsplit</code>(<em>sep=None</em>, <em>maxsplit=- 1</em>)</p>
<p><code>bytearray.rsplit</code>(<em>sep=None</em>, <em>maxsplit=- 1</em>)</p>
<p>将二进制序列拆分为相同类型的子序列，使用 <em>sep</em> 作为分隔符。 如果给出了 <em>maxsplit*，则最多进行 *maxsplit</em> 次拆分，从 <em>最右边</em> 开始。 如果 <em>sep</em> 未指定或为 <code>None</code>，任何只包含 ASCII 空白符的子序列都会被作为分隔符。 除了从右边开始拆分，<code>rsplit()</code> 的其他行为都类似于下文所述的 <code>split()</code>。</p>
<p><code>bytes.rstrip</code>([<em>chars</em>])</p>
<p><code>bytearray.rstrip</code>([<em>chars</em>])</p>
<p>返回原序列的副本，移除指定的末尾字节。 <em>chars</em> 参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于 ASCII 字符。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除 ASCII 空白符。 <em>chars</em> 参数并非指定单个后缀；而是会移除参数值的所有组合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'   spacious   '</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'   spacious'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'mississippi'</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span>b<span class="token string">'ipz'</span><span class="token punctuation">)</span>
b<span class="token string">'mississ'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要移除的二进制序列可以是任意 bytes-like object 。 要删除单个后缀字符串，而不是全部给定集合中的字符，请参见 <code>str.removesuffix()</code> 方法。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Monty Python'</span><span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span>b<span class="token string">' Python'</span><span class="token punctuation">)</span>
b<span class="token string">'M'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Monty Python'</span><span class="token punctuation">.</span>removesuffix<span class="token punctuation">(</span>b<span class="token string">' Python'</span><span class="token punctuation">)</span>
b<span class="token string">'Monty'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.split</code>(<em>sep=None</em>, <em>maxsplit=- 1</em>)</p>
<p><code>bytearray.split</code>(<em>sep=None</em>, <em>maxsplit=- 1</em>)</p>
<p>将二进制序列拆分为相同类型的子序列，使用 <em>sep</em> 作为分隔符。 如果给出了 <em>maxsplit</em> 且非负值，则最多进行 <em>maxsplit</em> 次拆分（因此，列表最多会有 <code>maxsplit+1</code> 个元素）。 如果 <em>maxsplit</em> 未指定或为 <code>-1</code>，则不限制拆分次数（进行所有可能的拆分）。</p>
<p>如果给出了 <em>sep*，则连续的分隔符不会被组合在一起而是被视为分隔空子序列 (例如 <code>b'1,,2'.split(b',')</code> 将返回 <code>[b'1', b'', b'2']</code>)。 *sep</em> 参数可能为一个多字节序列 (例如 <code>b'1&lt;&gt;2&lt;&gt;3'.split(b'&lt;&gt;')</code> 将返回 <code>[b'1', b'2', b'3']</code>)。 使用指定的分隔符拆分空序列将返回 <code>[b'']</code> 或 <code>[bytearray(b'')]</code>，具体取决于被拆分对象的类型。 <em>sep</em> 参数可以是任意 bytes-like object。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'1,2,3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>b<span class="token string">','</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'1'</span><span class="token punctuation">,</span> b<span class="token string">'2'</span><span class="token punctuation">,</span> b<span class="token string">'3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'1,2,3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>b<span class="token string">','</span><span class="token punctuation">,</span> maxsplit<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'1'</span><span class="token punctuation">,</span> b<span class="token string">'2,3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'1,2,,3,'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>b<span class="token string">','</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'1'</span><span class="token punctuation">,</span> b<span class="token string">'2'</span><span class="token punctuation">,</span> b<span class="token string">''</span><span class="token punctuation">,</span> b<span class="token string">'3'</span><span class="token punctuation">,</span> b<span class="token string">''</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>sep</em> 未指定或为 <code>None</code>，则会应用另一种拆分算法：连续的 ASCII 空白符会被视为单个分隔符，其结果将不包含序列开头或末尾的空白符。 因此，在不指定分隔符的情况下对空序列或仅包含 ASCII 空白符的序列进行拆分将返回 <code>[]</code>。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'1 2 3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'1'</span><span class="token punctuation">,</span> b<span class="token string">'2'</span><span class="token punctuation">,</span> b<span class="token string">'3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'1 2 3'</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>maxsplit<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'1'</span><span class="token punctuation">,</span> b<span class="token string">'2 3'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'   1   2   3   '</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'1'</span><span class="token punctuation">,</span> b<span class="token string">'2'</span><span class="token punctuation">,</span> b<span class="token string">'3'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>bytes.strip</code>([<em>chars</em>])</p>
<p><code>bytearray.strip</code>([<em>chars</em>])</p>
<p>返回原序列的副本，移除指定的开头和末尾字节。 <em>chars</em> 参数为指定要移除字节值集合的二进制序列 —— 这个名称表明此方法通常是用于 ASCII 字符。 如果省略或为 <code>None</code>，则 <em>chars</em> 参数默认移除 ASCII 空白符。 <em>chars</em> 参数并非指定单个前缀或后缀；而是会移除参数值的所有组合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'   spacious   '</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'spacious'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'www.example.com'</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span>b<span class="token string">'cmowz.'</span><span class="token punctuation">)</span>
b<span class="token string">'example'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要移除的字节值二进制序列可以是任意 bytes-like object。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p>以下 bytes 和 bytearray 对象的方法会假定使用兼容 ASCII 的二进制格式，不应当被应用于任意二进制数据。 请注意本小节中所有的 bytearray 方法都 <em>不是</em> 原地执行操作，而是会产生新的对象。</p>
<p><code>bytes.capitalize</code>()</p>
<p><code>bytearray.capitalize</code>()</p>
<p>返回原序列的副本，其中每个字节将都将被解读为一个 ASCII 字符，并且第一个字节的字符大写而其余的小写。 非 ASCII 字节值将保持原样不变。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.expandtabs</code>(<em>tabsize=8</em>)</p>
<p><code>bytearray.expandtabs</code>(<em>tabsize=8</em>)</p>
<p>返回序列的副本，其中所有的 ASCII 制表符会由一个或多个 ASCII 空格替换，具体取决于当前列位置和给定的制表符宽度。 每 <em>tabsize</em> 个字节设为一个制表位（默认值 8 时设定的制表位在列 0, 8, 16 依次类推）。 要展开序列，当前列位置将被设为零并逐一检查序列中的每个字节。 如果字节为 ASCII 制表符 (<code>b'\t'</code>)，则并在结果中插入一个或多个空格符，直到当前列等于下一个制表位。 （制表符本身不会被复制。） 如果当前字节为 ASCII 换行符 (<code>b'\n'</code>) 或回车符 (<code>b'\r'</code>)，它会被复制并将当前列重设为零。 任何其他字节会被不加修改地复制并将当前列加一，不论该字节值在被打印时会如何显示:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'01\t012\t0123\t01234'</span><span class="token punctuation">.</span>expandtabs<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'01      012     0123    01234'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'01\t012\t0123\t01234'</span><span class="token punctuation">.</span>expandtabs<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
b<span class="token string">'01  012 0123    01234'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.isalnum</code>()</p>
<p><code>bytearray.isalnum</code>()</p>
<p>如果序列中所有字节都是字母类 ASCII 字符或 ASCII 十进制数码并且序列非空则返回 <code>True</code> ，否则返回 <code>False</code> 。 字母类 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。 ASCII 十进制数码就是字节值包含在序列 <code>b'0123456789'</code> 中的字符。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'ABCabc1'</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'ABC abc1'</span><span class="token punctuation">.</span>isalnum<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>bytes.isalpha</code>()</p>
<p><code>bytearray.isalpha</code>()</p>
<p>如果序列中所有字节都是字母类 ASCII 字符并且序列不非空则返回 <code>True</code> ，否则返回 <code>False</code> 。 字母类 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'ABCabc'</span><span class="token punctuation">.</span>isalpha<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'ABCabc1'</span><span class="token punctuation">.</span>isalpha<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>bytes.isascii</code>()</p>
<p><code>bytearray.isascii</code>()</p>
<p>如果序列为空或序列中所有字节都是 ASCII 字节则返回 <code>True</code> ，否则返回 <code>False</code> 。 ASCII 字节的取值范围是 0-0x7F。</p>
<p>3.7 新版功能.</p>
<p><code>bytes.isdigit</code>()</p>
<p><code>bytearray.isdigit</code>()</p>
<p>如果序列中所有字节都是 ASCII 十进制数码并且序列非空则返回 <code>True</code> ，否则返回 <code>False</code> 。 ASCII 十进制数码就是字节值包含在序列 <code>b'0123456789'</code> 中的字符。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'1234'</span><span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'1.23'</span><span class="token punctuation">.</span>isdigit<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>bytes.islower</code>()</p>
<p><code>bytearray.islower</code>()</p>
<p>如果序列中至少有一个小写的 ASCII 字符并且没有大写的 ASCII 字符则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'hello world'</span><span class="token punctuation">.</span>islower<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello world'</span><span class="token punctuation">.</span>islower<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyz'</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。</p>
<p><code>bytes.isspace</code>()</p>
<p><code>bytearray.isspace</code>()</p>
<p>如果序列中所有字节都是 ASCII 空白符并且序列非空则返回 <code>True</code> ，否则返回 <code>False</code> 。 ASCII 空白符就是字节值包含在序列 <code>b' \t\n\r\x0b\f'</code> (空格, 制表, 换行, 回车, 垂直制表, 进纸) 中的字符。</p>
<p><code>bytes.istitle</code>()</p>
<p><code>bytearray.istitle</code>()</p>
<p>如果序列为 ASCII 标题大小写形式并且序列非空则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello World'</span><span class="token punctuation">.</span>istitle<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello world'</span><span class="token punctuation">.</span>istitle<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>bytes.isupper</code>()</p>
<p><code>bytearray.isupper</code>()</p>
<p>如果序列中至少有一个大写字母 ASCII 字符并且没有小写 ASCII 字符则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'HELLO WORLD'</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello world'</span><span class="token punctuation">.</span>isupper<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyz'</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。</p>
<p><code>bytes.lower</code>()</p>
<p><code>bytearray.lower</code>()</p>
<p>返回原序列的副本，其所有大写 ASCII 字符均转换为对应的小写形式。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello World'</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'hello world'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyz'</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.splitlines</code>(<em>keepends=False</em>)</p>
<p><code>bytearray.splitlines</code>(<em>keepends=False</em>)</p>
<p>返回由原二进制序列中各行组成的列表，在 ASCII 行边界符的位置拆分。 此方法使用 universal newlines 方式来分行。 结果列表中不包含换行符，除非给出了 <em>keepends</em> 且为真值。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'ab c\n\nde fg\rkl\r\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'ab c'</span><span class="token punctuation">,</span> b<span class="token string">''</span><span class="token punctuation">,</span> b<span class="token string">'de fg'</span><span class="token punctuation">,</span> b<span class="token string">'kl'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'ab c\n\nde fg\rkl\r\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>b<span class="token string">'ab c\n'</span><span class="token punctuation">,</span> b<span class="token string">'\n'</span><span class="token punctuation">,</span> b<span class="token string">'de fg\r'</span><span class="token punctuation">,</span> b<span class="token string">'kl\r\n'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>不同于 <code>split()</code>，当给出了分隔符 <em>sep</em> 时，对于空字符串此方法将返回一个空列表，而末尾的换行不会令结果中增加额外的行:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">""</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>b<span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token string">"Two lines\n"</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span>b<span class="token string">'\n'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span>b<span class="token string">''</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token string">'Two lines'</span><span class="token punctuation">,</span> b<span class="token string">''</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">""</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> b<span class="token string">"One line\n"</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token string">'One line'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>bytes.swapcase</code>()</p>
<p><code>bytearray.swapcase</code>()</p>
<p>返回原序列的副本，其所有小写 ASCII 字符均转换为对应的大写形式，反之亦反。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello World'</span><span class="token punctuation">.</span>swapcase<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'hELLO wORLD'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyz'</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。</p>
<p>不同于 <code>str.swapcase()</code>，在些二进制版本下 <code>bin.swapcase().swapcase() == bin</code> 总是成立。 大小写转换在 ASCII 中是对称的，即使其对于任意 Unicode 码位来说并不总是成立。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.title</code>()</p>
<p><code>bytearray.title</code>()</p>
<p>返回原二进制序列的标题版本，其中每个单词以一个大写 ASCII 字符为开头，其余字母为小写。 不区别大小写的字节值将保持原样不变。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello world'</span><span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'Hello World'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyz'</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。 所有其他字节值都不区分大小写。</p>
<p>该算法使用一种简单的与语言无关的定义，将连续的字母组合视为单词。 该定义在多数情况下都很有效，但它也意味着代表缩写形式与所有格的撇号也会成为单词边界，这可能导致不希望的结果:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">"they're bill's friends from the UK"</span><span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">"They'Re Bill'S Friends From The Uk"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以使用正则表达式来构建针对撇号的特别处理:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> re
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">titlecase</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>rb<span class="token string">"[A-Za-z]+('[A-Za-z]+)?"</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                   <span class="token keyword">lambda</span> mo<span class="token punctuation">:</span> mo<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                              mo<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                   s<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> titlecase<span class="token punctuation">(</span>b<span class="token string">"they're bill's friends."</span><span class="token punctuation">)</span>
b<span class="token string">"They're Bill's Friends."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.upper</code>()</p>
<p><code>bytearray.upper</code>()</p>
<p>返回原序列的副本，其所有小写 ASCII 字符均转换为对应的大写形式。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">'Hello World'</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'HELLO WORLD'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>小写 ASCII 字符就是字节值包含在序列 <code>b'abcdefghijklmnopqrstuvwxyz'</code> 中的字符。 大写 ASCII 字符就是字节值包含在序列 <code>b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</code> 中的字符。</p>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p><code>bytes.zfill</code>(<em>width</em>)</p>
<p><code>bytearray.zfill</code>(<em>width</em>)</p>
<p>返回原序列的副本，在左边填充 <code>b'0'</code> 数码使序列长度为 <em>width*。 正负值前缀 (<code>b'+'</code>/ <code>b'-'</code>) 的处理方式是在正负符号 *之后</em> 填充而非在之前。 对于 <code>bytes</code> 对象，如果 <em>width</em> 小于等于 <code>len(seq)</code> 则返回原序列。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b<span class="token string">"42"</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
b<span class="token string">'00042'</span>
<span class="token operator">>></span><span class="token operator">></span> b<span class="token string">"-42"</span><span class="token punctuation">.</span>zfill<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
b<span class="token string">'-0042'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<h3 id="printf-风格的字节串格式化"><a href="#printf-风格的字节串格式化" class="headerlink" title="printf 风格的字节串格式化"></a><code>printf</code> 风格的字节串格式化</h3><p>注解</p>
<p>此处介绍的格式化操作具有多种怪异特性，可能导致许多常见错误（例如无法正确显示元组和字典）。 如果要打印的值可能为元组或字典，请将其放入一个元组中。</p>
<p>字节串对象 (<code>bytes</code>/<code>bytearray</code>) 具有一种特殊的内置操作：使用 <code>%</code> (取模) 运算符。 这也被称为字节串的 <em>格式化</em> 或 <em>插值</em> 运算符。 对于 <code>format % values</code> (其中 <em>format</em> 为一个字节串对象)，在 <em>format</em> 中的 <code>%</code> 转换标记符将被替换为零个或多个 <em>values</em> 条目。 其效果类似于在 C 语言中使用 <code>sprintf()</code>。</p>
<p>如果 <em>format</em> 要求一个单独参数，则 <em>values</em> 可以为一个非元组对象。否则的话，<em>values</em> 必须或是是一个包含项数与格式字节串对象中指定的转换符项数相同的元组，或者是一个单独的映射对象（例如元组）。</p>
<p>转换标记符包含两个或更多字符并具有以下组成，且必须遵循此处规定的顺序：</p>
<ol>
<li><code>'%'</code> 字符，用于标记转换符的起始。</li>
<li>映射键（可选），由加圆括号的字符序列组成 (例如 <code>(somename)</code>)。</li>
<li>转换旗标（可选），用于影响某些转换类型的结果。</li>
<li>最小字段宽度（可选）。 如果指定为 <code>'*'</code> (星号)，则实际宽度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为最小字段宽度和可选的精度之后的元素。</li>
<li>精度（可选），以在 <code>'.'</code> (点号) 之后加精度值的形式给出。 如果指定为 <code>'*'</code> (星号)，则实际精度会从 <em>values</em> 元组的下一元素中读取，要转换的对象则为精度之后的元素。</li>
<li>长度修饰符（可选）。</li>
<li>转换类型。</li>
</ol>
<p>当右边的参数为一个字典（或其他映射类型）时，字节串对象中的格式 <em>必须</em> 包含加圆括号的映射键，对应 <code>'%'</code> 字符之后字典中的每一项。 映射键将从映射中选取要格式化的值。 例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token string">'%(language)s has %(number)03d quote types.'</span> <span class="token operator">%</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>       <span class="token punctuation">{</span>b<span class="token string">'language'</span><span class="token punctuation">:</span> b<span class="token string">"Python"</span><span class="token punctuation">,</span> b<span class="token string">"number"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
b<span class="token string">'Python has 002 quote types.'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在此情况下格式中不能出现 <code>*</code> 标记符（因其需要一个序列类的参数列表）。</p>
<p>转换旗标为：</p>
<table>
<thead>
<tr>
<th align="left">旗标</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘#’</code></td>
<td align="left">值的转换将使用“替代形式”（具体定义见下文）。</td>
</tr>
<tr>
<td align="left"><code>‘0’</code></td>
<td align="left">转换将为数字值填充零字符。</td>
</tr>
<tr>
<td align="left"><code>‘-‘</code></td>
<td align="left">转换值将靠左对齐（如果同时给出 <code>‘0’</code> 转换，则会覆盖后者）。</td>
</tr>
<tr>
<td align="left"><code>‘ ‘</code></td>
<td align="left">(空格) 符号位转换产生的正数（或空字符串）前将留出一个空格。</td>
</tr>
<tr>
<td align="left"><code>‘+’</code></td>
<td align="left">符号字符 (<code>‘+’</code> 或 <code>‘-‘</code>) 将显示于转换结果的开头（会覆盖 “空格” 旗标）。</td>
</tr>
</tbody></table>
<p>可以给出长度修饰符 (<code>h</code>, <code>l</code> 或 <code>L</code>)，但会被忽略，因为对 Python 来说没有必要 — 所以 <code>%ld</code> 等价于 <code>%d</code>。</p>
<p>转换类型为：</p>
<table>
<thead>
<tr>
<th align="left">转换符</th>
<th align="left">含意</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘d’</code></td>
<td align="left">有符号十进制整数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘i’</code></td>
<td align="left">有符号十进制整数。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘o’</code></td>
<td align="left">有符号八进制数。</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>‘u’</code></td>
<td align="left">过时类型 — 等价于 <code>‘d’</code>。</td>
<td align="left">(8)</td>
</tr>
<tr>
<td align="left"><code>‘x’</code></td>
<td align="left">有符号十六进制数（小写）。</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>‘X’</code></td>
<td align="left">有符号十六进制数（大写）。</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>‘e’</code></td>
<td align="left">浮点指数格式（小写）。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘E’</code></td>
<td align="left">浮点指数格式（大写）。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘f’</code></td>
<td align="left">浮点十进制格式。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘F’</code></td>
<td align="left">浮点十进制格式。</td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>‘g’</code></td>
<td align="left">浮点格式。 如果指数小于 -4 或不小于精度则使用小写指数格式，否则使用十进制格式。</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>‘G’</code></td>
<td align="left">浮点格式。 如果指数小于 -4 或不小于精度则使用大写指数格式，否则使用十进制格式。</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>‘c’</code></td>
<td align="left">单个字节（接受整数或单个字节对象）。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>‘b’</code></td>
<td align="left">字节串（任何遵循 缓冲区协议 或是具有 <code>**bytes**()</code> 的对象）。</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>‘s’</code></td>
<td align="left"><code>‘s’</code> 是 <code>‘b’</code> 的一个别名，只应当在基于 Python2/3 的代码中使用。</td>
<td align="left">(6)</td>
</tr>
<tr>
<td align="left"><code>‘a’</code></td>
<td align="left">字节串（使用 <code>repr(obj).encode(‘ascii’,’backslashreplace)</code> 转换任何 Python 对象）。</td>
<td align="left">(5)</td>
</tr>
<tr>
<td align="left"><code>‘r’</code></td>
<td align="left"><code>‘r’</code> 是 <code>‘a’</code> 的一个别名，只应当在基于 Python2/3 的代码中使用。</td>
<td align="left">(7)</td>
</tr>
<tr>
<td align="left"><code>‘%’</code></td>
<td align="left">不转换参数，在结果中输出一个 <code>‘%’</code> 字符。</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>注释：</p>
<ol>
<li><p>此替代形式会在第一个数码之前插入标示八进制数的前缀 (<code>'0o'</code>)。</p>
</li>
<li><p>此替代形式会在第一个数码之前插入 <code>'0x'</code> 或 <code>'0X'</code> 前缀（取决于是使用 <code>'x'</code> 还是 <code>'X'</code> 格式）。</p>
</li>
<li><p>此替代形式总是会在结果中包含一个小数点，即使其后并没有数码。</p>
<p>小数点后的数码位数由精度决定，默认为 6。</p>
</li>
<li><p>此替代形式总是会在结果中包含一个小数点，末尾各位的零不会如其他情况下那样被移除。</p>
<p>小数点前后的有效数码位数由精度决定，默认为 6。</p>
</li>
<li><p>如果精度为 <code>N</code>，输出将截短为 <code>N</code> 个字符。</p>
</li>
<li><p><code>b'%s'</code> 已弃用，但在 3.x 系列中将不会被移除。</p>
</li>
<li><p><code>b'%r'</code> 已弃用，但在 3.x 系列中将不会被移除。</p>
</li>
<li><p>参见 <a href="https://www.python.org/dev/peps/pep-0237" target="_blank" rel="noopener"><strong>PEP 237</strong></a>。</p>
</li>
</ol>
<p>注解</p>
<p>此方法的 bytearray 版本 <em>并非</em> 原地操作 —— 它总是产生一个新对象，即便没有做任何改变。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0461" target="_blank" rel="noopener"><strong>PEP 461</strong></a> - 为 bytes 和 bytearray 添加 % 格式化</p>
<p>3.5 新版功能.</p>
<h3 id="内存视图"><a href="#内存视图" class="headerlink" title="内存视图"></a>内存视图</h3><p><code>memoryview</code> 对象允许 Python 代码访问一个对象的内部数据，只要该对象支持 缓冲区协议 而无需进行拷贝。</p>
<p><em>class</em> <code>memoryview</code>(<em>object</em>)</p>
<p>创建一个引用 <em>object</em> 的 <code>memoryview</code> 。 <em>object</em> 必须支持缓冲区协议。支持缓冲区协议的内置对象有 <code>bytes</code> 和 <code>bytearray</code> 。</p>
<p><code>memoryview</code> 有 <strong>元素</strong> 的概念， <strong>元素</strong> 指由原始 <em>object</em> 处理的原子内存单元。对于许多简单的类型，如 <code>bytes</code> 和 <code>bytearray</code> ，一个元素是一个字节，但其他类型，如 <code>array.array</code> 可能有更大的元素。</p>
<p><code>len(view)</code> 与 <code>tolist</code> 的长度相等。 如果 <code>view.ndim = 0</code>，则其长度为 1。 如果 <code>view.ndim = 1</code>，则其长度等于 view 中元素的数量。 对于更高的维度，其长度等于表示 view 的嵌套列表的长度。 <code>itemsize</code> 属性可向你给出单个元素所占的字节数。</p>
<p><code>memoryview</code> 支持通过切片和索引访问其元素。 一维切片的结果将是一个子视图:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> v <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token string">'abcefg'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">98</span>
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">103</span>
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token operator">&lt;</span>memory at <span class="token number">0x7f3ddc9f4350</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> bytes<span class="token punctuation">(</span>v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
b<span class="token string">'bce'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <code>format</code> 是一个来自于 <code>struct</code> 模块的原生格式说明符，则也支持使用整数或由整数构成的元组进行索引，并返回具有正确类型的单个 <em>元素*。 一维内存视图可以使用一个整数或由一个整数构成的元组进行索引。 多维内存视图可以使用由恰好 *ndim</em> 个整数构成的元素进行索引，<em>ndim</em> 即其维度。 零维内存视图可以使用空元组进行索引。</p>
<p>这里是一个使用非字节格式的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> array
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">11111111</span><span class="token punctuation">,</span> <span class="token number">22222222</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">33333333</span><span class="token punctuation">,</span> <span class="token number">44444444</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token operator">-</span><span class="token number">11111111</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">44444444</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">11111111</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">33333333</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果下层对象是可写的，则内存视图支持一维切片赋值。 改变大小则不被允许:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span> bytearray<span class="token punctuation">(</span>b<span class="token string">'abcefg'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> v <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">.</span>readonly
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> ord<span class="token punctuation">(</span>b<span class="token string">'z'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> data
bytearray<span class="token punctuation">(</span>b<span class="token string">'zbcefg'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">'123'</span>
<span class="token operator">>></span><span class="token operator">></span> data
bytearray<span class="token punctuation">(</span>b<span class="token string">'z123fg'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">'spam'</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ValueError<span class="token punctuation">:</span> memoryview assignment<span class="token punctuation">:</span> lvalue <span class="token operator">and</span> rvalue have different structures
<span class="token operator">>></span><span class="token operator">></span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">'spam'</span>
<span class="token operator">>></span><span class="token operator">></span> data
bytearray<span class="token punctuation">(</span>b<span class="token string">'z1spam'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由带有格式符号 ‘B’, ‘b’ 或 ‘c’ 的可哈希（只读）类型构成的一维内存视图同样是可哈希的。 哈希定义为 <code>hash(m) == hash(m.tobytes())</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> v <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token string">'abcefg'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> hash<span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">==</span> hash<span class="token punctuation">(</span>b<span class="token string">'abcefg'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> hash<span class="token punctuation">(</span>v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> hash<span class="token punctuation">(</span>b<span class="token string">'ce'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> hash<span class="token punctuation">(</span>v<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> hash<span class="token punctuation">(</span>b<span class="token string">'abcefg'</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.3 版更改: 一维内存视图现在可以被切片。 带有格式符号 ‘B’, ‘b’ 或 ‘c’ 的一维内存视图现在是可哈希的。</p>
<p>在 3.4 版更改: 内存视图现在会自动注册为 <code>collections.abc.Sequence</code></p>
<p>在 3.5 版更改: 内存视图现在可使用整数元组进行索引。</p>
<p><code>memoryview</code> 具有以下一些方法：</p>
<ul>
<li><p><code>__eq__</code>(<em>exporter</em>)</p>
<p>memoryview 与 <a href="https://www.python.org/dev/peps/pep-3118" target="_blank" rel="noopener"><strong>PEP 3118</strong></a> 中的导出器这两者如果形状相同，并且如果当使用 <code>struct</code> 语法解读操作数的相应格式代码时所有对应值都相同，则它们就是等价的。</p>
<p>对于 <code>tolist()</code> 当前所支持的 <code>struct</code> 格式字符串子集，如果 <code>v.tolist() == w.tolist()</code> 则 <code>v</code> 和 <code>w</code> 相等:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> array
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'I'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">==</span> a <span class="token operator">==</span> y <span class="token operator">==</span> b
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> a<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> y<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> b<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> z <span class="token operator">=</span> y<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> z <span class="token operator">==</span> c
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> z<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> c<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果两边的格式字符串都不被 <code>struct</code> 模块所支持，则两对象比较结果总是不相等（即使格式字符串和缓冲区内容相同）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> ctypes <span class="token keyword">import</span> BigEndianStructure<span class="token punctuation">,</span> c_long
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">BEPoint</span><span class="token punctuation">(</span>BigEndianStructure<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     _fields_ <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">,</span> c_long<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"y"</span><span class="token punctuation">,</span> c_long<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> point <span class="token operator">=</span> BEPoint<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>point<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>point<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">==</span> point
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">==</span> b
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意，与浮点数的情况一样，对于内存视图对象来说，<code>v is w</code> 也 <em>并不</em> 意味着 <code>v == w</code>。</p>
<p>在 3.3 版更改: 之前的版本比较原始内存时会忽略条目的格式与逻辑数组结构。</p>
</li>
<li><p><code>tobytes</code>(<em>order=None</em>)</p>
<p>将缓冲区中的数据作为字节串返回。 这相当于在内存视图上调用 <code>bytes</code> 构造器。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token string">"abc"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>tobytes<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'abc'</span>
<span class="token operator">>></span><span class="token operator">></span> bytes<span class="token punctuation">(</span>m<span class="token punctuation">)</span>
b<span class="token string">'abc'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于非连续数组，结果等于平面化表示的列表，其中所有元素都转换为字节串。 <code>tobytes()</code> 支持所有格式字符串，不符合 <code>struct</code> 模块语法的那些也包括在内。</p>
<p>3.8 新版功能: <em>order</em> 可以为 {‘C’, ‘F’, ‘A’}。 当 <em>order</em> 为 ‘C’ 或 ‘F’ 时，原始数组的数据会被转换至 C 或 Fortran 顺序。 对于连续视图，’A’ 会返回物理内存的精确副本。 特别地，内存中的 Fortran 顺序会被保留。对于非连续视图，数据会先被转换为 C 形式。 <em>order=None</em> 与 <em>order=’C’</em> 是相同的。</p>
</li>
<li><p><code>hex</code>([<em>sep</em>[, <em>bytes_per_sep</em>]])</p>
<p>返回一个字符串对象，其中分别以两个十六进制数码表示缓冲区里的每个字节。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token string">"abc"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>hex<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'616263'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p>在 3.8 版更改: 与 <code>bytes.hex()</code> 相似， <code>memoryview.hex()</code> 现在支持可选的 <em>sep</em> 和 <em>bytes_per_sep</em> 参数以在十六进制输出的字节之间插入分隔符。</p>
</li>
<li><p><code>tolist</code>()</p>
<p>将缓冲区内的数据以一个元素列表的形式返回。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> memoryview<span class="token punctuation">(</span>b<span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">97</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> array
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">,</span> <span class="token number">3.3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">2.2</span><span class="token punctuation">,</span> <span class="token number">3.3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.3 版更改: <code>tolist()</code> 现在支持 <code>struct</code> 模块语法中的所有单字符原生格式以及多维表示形式。</p>
</li>
<li><p><code>toreadonly</code>()</p>
<p>返回 memoryview 对象的只读版本。 原始的 memoryview 对象不会被改变。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>bytearray<span class="token punctuation">(</span>b<span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> mm <span class="token operator">=</span> m<span class="token punctuation">.</span>toreadonly<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> mm<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> mm<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> cannot modify read<span class="token operator">-</span>only memory
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">43</span>
<span class="token operator">>></span><span class="token operator">></span> mm<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">43</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.8 新版功能.</p>
</li>
<li><p><code>release</code>()</p>
<p>释放由内存视图对象所公开的底层缓冲区。 许多对象在被视图所获取时都会采取特殊动作（例如，<code>bytearray</code> 将会暂时禁止调整大小）；因此，调用 release() 可以方便地尽早去除这些限制（并释放任何多余的资源）。</p>
<p>在此方法被调用后，任何对视图的进一步操作将引发 <code>ValueError</code> (<code>release()</code> 本身除外，它可以被多次调用):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token string">'abc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ValueError<span class="token punctuation">:</span> operation forbidden on released memoryview object<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>with</code> 语句，可以通过上下文管理协议达到类似的效果:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> memoryview<span class="token punctuation">(</span>b<span class="token string">'abc'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> m<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">97</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ValueError<span class="token punctuation">:</span> operation forbidden on released memoryview object<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
</li>
<li><p><code>cast</code>(<em>format</em>[, <em>shape</em>])</p>
<p>将内存视图转化为新的格式或形状。 <em>shape</em> 默认为 <code>[byte_length//new_itemsize]</code>，这意味着结果视图将是一维的。 返回值是一个新的内存视图，但缓冲区本身不会被复制。 支持的转化有 1D -&gt; C-contiguous 和 C-contiguous -&gt; 1D。</p>
<p>目标格式仅限于 <code>struct</code> 语法中的单一元素原生格式。 其中一种格式必须为字节格式 (‘B’, ‘b’ 或 ‘c’)。 结果的字节长度必须与原始长度相同。</p>
<p>将 1D/long 转换为 1D/unsigned bytes:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> array
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>format
<span class="token string">'l'</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>itemsize
<span class="token number">8</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">.</span>nbytes
<span class="token number">24</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> x<span class="token punctuation">.</span>cast<span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>format
<span class="token string">'B'</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>itemsize
<span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
<span class="token number">24</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>nbytes
<span class="token number">24</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 1D/unsigned bytes 转换为 1D/char:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> bytearray<span class="token punctuation">(</span>b<span class="token string">'zyz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">'a'</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ValueError<span class="token punctuation">:</span> memoryview<span class="token punctuation">:</span> invalid value <span class="token keyword">for</span> format <span class="token string">"B"</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> x<span class="token punctuation">.</span>cast<span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">'a'</span>
<span class="token operator">>></span><span class="token operator">></span> b
bytearray<span class="token punctuation">(</span>b<span class="token string">'ayz'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 1D/bytes 转换为 3D/ints 再转换为 1D/signed char:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> struct
<span class="token operator">>></span><span class="token operator">></span> buf <span class="token operator">=</span> struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">"i"</span><span class="token operator">*</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token operator">*</span>list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> x<span class="token punctuation">.</span>cast<span class="token punctuation">(</span><span class="token string">'i'</span><span class="token punctuation">,</span> shape<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>format
<span class="token string">'i'</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>itemsize
<span class="token number">4</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
<span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>nbytes
<span class="token number">48</span>
<span class="token operator">>></span><span class="token operator">></span> z <span class="token operator">=</span> y<span class="token punctuation">.</span>cast<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> z<span class="token punctuation">.</span>format
<span class="token string">'b'</span>
<span class="token operator">>></span><span class="token operator">></span> z<span class="token punctuation">.</span>itemsize
<span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>z<span class="token punctuation">)</span>
<span class="token number">48</span>
<span class="token operator">>></span><span class="token operator">></span> z<span class="token punctuation">.</span>nbytes
<span class="token number">48</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将 1D/unsigned long 转换为 2D/unsigned long:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> buf <span class="token operator">=</span> struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">"L"</span><span class="token operator">*</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token operator">*</span>list<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> x<span class="token punctuation">.</span>cast<span class="token punctuation">(</span><span class="token string">'L'</span><span class="token punctuation">,</span> shape<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
<span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>nbytes
<span class="token number">48</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.3 新版功能.</p>
<p>在 3.5 版更改: 当转换为字节视图时，源格式将不再受限。</p>
</li>
</ul>
<p>还存在一些可用的只读属性：</p>
<ul>
<li><p><code>obj</code></p>
<p>内存视图的下层对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b  <span class="token operator">=</span> bytearray<span class="token punctuation">(</span>b<span class="token string">'xyz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>obj <span class="token keyword">is</span> b
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.3 新版功能.</p>
</li>
<li><p><code>nbytes</code></p>
<p><code>nbytes == product(shape) * itemsize == len(m.tobytes())</code>。 这是数组在连续表示时将会占用的空间总字节数。 它不一定等于 <code>len(m)</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> array
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>m<span class="token punctuation">)</span>
<span class="token number">5</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>nbytes
<span class="token number">20</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> m<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
<span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>nbytes
<span class="token number">12</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>y<span class="token punctuation">.</span>tobytes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>多维数组:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> struct
<span class="token operator">>></span><span class="token operator">></span> buf <span class="token operator">=</span> struct<span class="token punctuation">.</span>pack<span class="token punctuation">(</span><span class="token string">"d"</span><span class="token operator">*</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">[</span><span class="token number">1.5</span><span class="token operator">*</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> x <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>buf<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y <span class="token operator">=</span> x<span class="token punctuation">.</span>cast<span class="token punctuation">(</span><span class="token string">'d'</span><span class="token punctuation">,</span> shape<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">6.0</span><span class="token punctuation">,</span> <span class="token number">7.5</span><span class="token punctuation">,</span> <span class="token number">9.0</span><span class="token punctuation">,</span> <span class="token number">10.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">12.0</span><span class="token punctuation">,</span> <span class="token number">13.5</span><span class="token punctuation">,</span> <span class="token number">15.0</span><span class="token punctuation">,</span> <span class="token number">16.5</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>y<span class="token punctuation">)</span>
<span class="token number">3</span>
<span class="token operator">>></span><span class="token operator">></span> y<span class="token punctuation">.</span>nbytes
<span class="token number">96</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.3 新版功能.</p>
</li>
<li><p><code>readonly</code></p>
<p>一个表明内存是否只读的布尔值。</p>
</li>
<li><p><code>format</code></p>
<p>一个字符串，包含视图中每个元素的格式（表示为 <code>struct</code> 模块样式）。 内存视图可以从具有任意格式字符串的导出器创建，但某些方法 (例如 <code>tolist()</code>) 仅限于原生的单元素格式。</p>
<p>在 3.3 版更改: 格式 <code>'B'</code> 现在会按照 struct 模块语法来处理。 这意味着 <code>memoryview(b'abc')[0] == b'abc'[0] == 97</code>。</p>
</li>
<li><p><code>itemsize</code></p>
<p>memoryview 中每个元素以字节表示的大小:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> array<span class="token punctuation">,</span> struct
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> memoryview<span class="token punctuation">(</span>array<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token string">'H'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">32000</span><span class="token punctuation">,</span> <span class="token number">32001</span><span class="token punctuation">,</span> <span class="token number">32002</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>itemsize
<span class="token number">2</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token number">32000</span>
<span class="token operator">>></span><span class="token operator">></span> struct<span class="token punctuation">.</span>calcsize<span class="token punctuation">(</span><span class="token string">'H'</span><span class="token punctuation">)</span> <span class="token operator">==</span> m<span class="token punctuation">.</span>itemsize
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>ndim</code></p>
<p>一个整数，表示内存所代表的多维数组具有多少个维度。</p>
</li>
<li><p><code>shape</code></p>
<p>一个整数元组，通过 <code>ndim</code> 的长度值给出内存所代表的 N 维数组的形状。</p>
<p>在 3.3 版更改: 当 ndim = 0 时值为空元组而不再为 <code>None</code>。</p>
</li>
<li><p><code>strides</code></p>
<p>一个整数元组，通过 <code>ndim</code> 的长度给出以字节表示的大小，以便访问数组中每个维度上的每个元素。</p>
<p>在 3.3 版更改: 当 ndim = 0 时值为空元组而不再为 <code>None</code>。</p>
</li>
<li><p><code>suboffsets</code></p>
<p>供 PIL 风格的数组内部使用。 该值仅作为参考信息。</p>
</li>
<li><p><code>c_contiguous</code></p>
<p>一个表明内存是否为 C-contiguous 的布尔值。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>f_contiguous</code></p>
<p>一个表明内存是否为 Fortran contiguous 的布尔值。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>contiguous</code></p>
<p>一个表明内存是否为 contiguous 的布尔值。</p>
<p>3.3 新版功能.</p>
</li>
</ul>
<h2 id="集合类型-—-set-frozenset"><a href="#集合类型-—-set-frozenset" class="headerlink" title="集合类型 —- set, frozenset"></a>集合类型 —- <code>set</code>, <code>frozenset</code></h2><p><em>set</em> 对象是由具有唯一性的 hashable 对象所组成的无序多项集。 常见的用途包括成员检测、从序列中去除重复项以及数学中的集合类计算，例如交集、并集、差集与对称差集等等。 </p>
<p>与其他多项集一样，集合也支持 <code>x in set</code>, <code>len(set)</code> 和 <code>for x in set</code>。 作为一种无序的多项集，集合并不记录元素位置或插入顺序。 相应地，集合不支持索引、切片或其他序列类的操作。</p>
<p>目前有两种内置集合类型，<code>set</code> 和 <code>frozenset</code>。 <code>set</code> 类型是可变的 —- 其内容可以使用 <code>add()</code> 和 <code>remove()</code> 这样的方法来改变。 由于是可变类型，它没有哈希值，且不能被用作字典的键或其他集合的元素。 <code>frozenset</code> 类型是不可变并且为 hashable —- 其内容在被创建后不能再改变；因此它可以被用作字典的键或其他集合的元素。</p>
<p>除了可以使用 <code>set</code> 构造器，非空的 set (不是 frozenset) 还可以通过将以逗号分隔的元素列表包含于花括号之内来创建，例如: <code>{'jack', 'sjoerd'}</code>。</p>
<p>两个类的构造器具有相同的作用方式：</p>
<p><em>class</em> <code>set</code>([<em>iterable</em>])</p>
<p><em>class</em> <code>frozenset</code>([<em>iterable</em>])</p>
<p>返回一个新的 set 或 frozenset 对象，其元素来自于 <em>iterable</em>。 集合的元素必须为 hashable。 要表示由集合对象构成的集合，所有的内层集合必须为 <code>frozenset</code> 对象。 如果未指定 <em>iterable</em>，则将返回一个新的空集合。</p>
<p>集合可用多种方式来创建:</p>
<ul>
<li>使用花括号内以逗号分隔元素的方式: <code>{'jack', 'sjoerd'}</code></li>
<li>使用集合推导式: <code>{c for c in 'abracadabra' if c not in 'abc'}</code></li>
<li>使用类型构造器: <code>set()</code>, <code>set('foobar')</code>, <code>set(['a', 'b', 'foo'])</code></li>
</ul>
<p><code>set</code> 和 <code>frozenset</code> 的实例提供以下操作：</p>
<ul>
<li><p><code>len(s)</code></p>
<p>返回集合 <em>s</em> 中的元素数量（即 <em>s</em> 的基数）。</p>
</li>
<li><p><code>x in s</code></p>
<p>检测 <em>x</em> 是否为 <em>s</em> 中的成员。</p>
</li>
<li><p><code>x not in s</code></p>
<p>检测 <em>x</em> 是否非 <em>s</em> 中的成员。</p>
</li>
<li><p><code>isdisjoint</code>(<em>other</em>)</p>
<p>如果集合中没有与 <em>other</em> 共有的元素则返回 <code>True</code>。 当且仅当两个集合的交集为空集合时，两者为不相交集合。</p>
</li>
<li><p><code>issubset</code>(<em>other</em>)</p>
<p><code>set &lt;= other</code></p>
<p>检测是否集合中的每个元素都在 <em>other</em> 之中。</p>
</li>
<li><p><code>set &lt; other</code></p>
<p>检测集合是否为 <em>other</em> 的真子集，即 <code>set &lt;= other and set != other</code>。</p>
</li>
<li><p><code>issuperset</code>(<em>other</em>)</p>
<p><code>set &gt;= other</code></p>
<p>检测是否 <em>other</em> 中的每个元素都在集合之中。</p>
</li>
<li><p><code>set &gt; other</code></p>
<p>检测集合是否为 <em>other</em> 的真超集，即 <code>set &gt;= other and set != other</code>。</p>
</li>
<li><p><code>union</code>(<em>\</em>others*)</p>
<p><code>set | other | ...</code></p>
<p>返回一个新集合，其中包含来自原集合以及 others 指定的所有集合中的元素。</p>
</li>
<li><p><code>intersection</code>(<em>\</em>others*)</p>
<p><code>set &amp; other &amp; ...</code></p>
<p>返回一个新集合，其中包含原集合以及 others 指定的所有集合中共有的元素。</p>
</li>
<li><p><code>difference</code>(<em>\</em>others*)</p>
<p><code>set - other - ...</code></p>
<p>返回一个新集合，其中包含原集合中在 others 指定的其他集合中不存在的元素。</p>
</li>
<li><p><code>symmetric_difference</code>(<em>other</em>)</p>
<p><code>set ^ other</code></p>
<p>返回一个新集合，其中的元素或属于原集合或属于 <em>other</em> 指定的其他集合，但不能同时属于两者。</p>
</li>
<li><p><code>copy</code>()</p>
<p>返回原集合的浅拷贝。</p>
</li>
</ul>
<p>Note, the non-operator versions of <code>union()</code>, <code>intersection()</code>, <code>difference()</code>, <code>symmetric_difference()</code>, <code>issubset()</code>, and <code>issuperset()</code> methods will accept any iterable as an argument. In contrast, their operator based counterparts require their arguments to be sets. This precludes error-prone constructions like <code>set('abc') &amp; 'cbs'</code> in favor of the more readable <code>set('abc').intersection('cbs')</code>.</p>
<p><code>set</code> 和 <code>frozenset</code> 均支持集合与集合的比较。 两个集合当且仅当每个集合中的每个元素均包含于另一个集合之内（即各为对方的子集）时则相等。 一个集合当且仅当其为另一个集合的真子集（即为后者的子集但两者不相等）时则小于另一个集合。 一个集合当且仅当其为另一个集合的真超集（即为后者的超集但两者不相等）时则大于另一个集合。</p>
<p><code>set</code> 的实例与 <code>frozenset</code> 的实例之间基于它们的成员进行比较。 例如 <code>set('abc') == frozenset('abc')</code> 返回 <code>True</code>，<code>set('abc') in set([frozenset('abc')])</code> 也一样。</p>
<p>子集与相等比较并不能推广为完全排序函数。 例如，任意两个非空且不相交的集合不相等且互不为对方的子集，因此以下 <em>所有</em> 比较均返回 <code>False</code>: <code>a&lt;b</code>, <code>a==b</code>, or <code>a&gt;b</code>。</p>
<p>由于集合仅定义了部分排序（子集关系），因此由集合构成的列表 <code>list.sort()</code> 方法的输出并无定义。</p>
<p>集合的元素，与字典的键类似，必须为 hashable。</p>
<p>混合了 <code>set</code> 实例与 <code>frozenset</code> 的二进制位运算将返回与第一个操作数相同的类型。例如: <code>frozenset('ab') | set('bc')</code> 将返回 <code>frozenset</code> 的实例。</p>
<p>下表列出了可用于 <code>set</code> 而不能用于不可变的 <code>frozenset</code> 实例的操作：</p>
<ul>
<li><p><code>update</code>(<em>\</em>others*)</p>
<p><code>set |= other | ...</code></p>
<p>更新集合，添加来自 others 中的所有元素。</p>
</li>
<li><p><code>intersection_update</code>(<em>\</em>others*)</p>
<p><code>set &amp;= other &amp; ...</code></p>
<p>更新集合，只保留其中在所有 others 中也存在的元素。</p>
</li>
<li><p><code>difference_update</code>(<em>\</em>others*)</p>
<p><code>set -= other | ...</code></p>
<p>更新集合，移除其中也存在于 others 中的元素。</p>
</li>
<li><p><code>symmetric_difference_update</code>(<em>other</em>)</p>
<p><code>set ^= other</code></p>
<p>更新集合，只保留存在于集合的一方而非共同存在的元素。</p>
</li>
<li><p><code>add</code>(<em>elem</em>)</p>
<p>将元素 <em>elem</em> 添加到集合中。</p>
</li>
<li><p><code>remove</code>(<em>elem</em>)</p>
<p>从集合中移除元素 <em>elem*。 如果 *elem</em> 不存在于集合中则会引发 <code>KeyError</code>。</p>
</li>
<li><p><code>discard</code>(<em>elem</em>)</p>
<p>如果元素 <em>elem</em> 存在于集合中则将其移除。</p>
</li>
<li><p><code>pop</code>()</p>
<p>从集合中移除并返回任意一个元素。 如果集合为空则会引发 <code>KeyError</code>。</p>
</li>
<li><p><code>clear</code>()</p>
<p>从集合中移除所有元素。</p>
</li>
</ul>
<p>请注意，非运算符版本的 <code>update()</code>, <code>intersection_update()</code>, <code>difference_update()</code> 和 <code>symmetric_difference_update()</code> 方法将接受任意可迭代对象作为参数。</p>
<p>请注意，<code>__contains__()</code>, <code>remove()</code> 和 <code>discard()</code> 方法的 <em>elem</em> 参数可能是一个 set。 为支持对一个等价的 frozenset 进行搜索，会根据 <em>elem</em> 临时创建一个该类型对象。</p>
<h2 id="映射类型-—-dict"><a href="#映射类型-—-dict" class="headerlink" title="映射类型 —- dict"></a>映射类型 —- <code>dict</code></h2><p>mapping 对象会将 hashable 值映射到任意对象。 映射属于可变对象。 目前仅有一种标准映射类型 <em>字典</em>。 </p>
<p>字典的键 <em>几乎</em> 可以是任何值。 非 hashable 的值，即包含列表、字典或其他可变类型的值（此类对象基于值而非对象标识进行比较）不可用作键。 数字类型用作键时遵循数字比较的一般规则：如果两个数值相等 (例如 <code>1</code> 和 <code>1.0</code>) 则两者可以被用来索引同一字典条目。 （但是请注意，由于计算机对于浮点数存储的只是近似值，因此将其用作字典键是不明智的。）</p>
<p>字典可以通过将以逗号分隔的 <code>键: 值</code> 对列表包含于花括号之内来创建，例如: <code>{'jack': 4098, 'sjoerd': 4127}</code> 或 <code>{4098: 'jack', 4127: 'sjoerd'}</code>，也可以通过 <code>dict</code> 构造器来创建。</p>
<p><em>class</em> <code>dict</code>(<em>**kwarg</em>)</p>
<p><em>class</em> <code>dict</code>(<em>mapping</em>, <em>**kwarg</em>)</p>
<p><em>class</em> <code>dict</code>(<em>iterable</em>, <em>**kwarg</em>)</p>
<p>返回一个新的字典，基于可选的位置参数和可能为空的关键字参数集来初始化。</p>
<p>字典可用多种方式来创建:</p>
<ul>
<li>使用花括号内以逗号分隔 <code>键: 值</code> 对的方式: <code>{'jack': 4098, 'sjoerd': 4127}</code> or <code>{4098: 'jack', 4127: 'sjoerd'}</code></li>
<li>使用字典推导式: <code>{}</code>, <code>{x: x ** 2 for x in range(10)}</code></li>
<li>使用类型构造器: <code>dict()</code>, <code>dict([('foo', 100), ('bar', 200)])</code>, <code>dict(foo=100, bar=200)</code></li>
</ul>
<p>如果没有给出位置参数，将创建一个空字典。 如果给出一个位置参数并且其属于映射对象，将创建一个具有与映射对象相同键值对的字典。 否则的话，位置参数必须为一个 iterable 对象。 该可迭代对象中的每一项本身必须为一个刚好包含两个元素的可迭代对象。 每一项中的第一个对象将成为新字典的一个键，第二个对象将成为其对应的值。 如果一个键出现一次以上，该键的最后一个值将成为其在新字典中对应的值。</p>
<p>如果给出了关键字参数，则关键字参数及其值会被加入到基于位置参数创建的字典。 如果要加入的键已存在，来自关键字参数的值将替代来自位置参数的值。</p>
<p>作为演示，以下示例返回的字典均等于 <code>{"one": 1, "two": 2, "three": 3}</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> dict<span class="token punctuation">(</span>one<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> two<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> three<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> dict<span class="token punctuation">(</span>zip<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'three'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> e <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> dict<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span> two<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">==</span> b <span class="token operator">==</span> c <span class="token operator">==</span> d <span class="token operator">==</span> e <span class="token operator">==</span> f
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像第一个例子那样提供关键字参数的方式只能使用有效的 Python 标识符作为键。 其他方式则可使用任何有效的键。</p>
<p>这些是字典所支持的操作（因而自定义的映射类型也应当支持）：</p>
<ul>
<li><p><code>list(d)</code></p>
<p>返回字典 <em>d</em> 中使用的所有键的列表。</p>
</li>
<li><p><code>len(d)</code></p>
<p>返回字典 <em>d</em> 中的项数。</p>
</li>
<li><p><code>d[key]</code></p>
<p>返回 <em>d</em> 中以 <em>key</em> 为键的项。 如果映射中不存在 <em>key</em> 则会引发 <code>KeyError</code>。</p>
<p>如果字典的子类定义了方法 <code>__missing__()</code> 并且 <em>key</em> 不存在，则 <code>d[key]</code> 操作将调用该方法并附带键 <em>key</em> 作为参数。 <code>d[key]</code> 随后将返回或引发 <code>__missing__(key)</code> 调用所返回或引发的任何对象或异常。 没有其他操作或方法会发起调用 <code>__missing__()</code>。 如果未定义 <code>__missing__()</code>，则会引发 <code>KeyError</code>。 <code>__missing__()</code> 必须是一个方法；它不能是一个实例变量:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Counter</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__missing__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token number">0</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">]</span>
<span class="token number">0</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">]</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的例子显示了 <code>collections.Counter</code> 实现的部分代码。 还有另一个不同的 <code>__missing__</code> 方法是由 <code>collections.defaultdict</code> 所使用的。</p>
</li>
<li><p><code>d[key] = value</code></p>
<p>将 <code>d[key]</code> 设为 <em>value</em>。</p>
</li>
<li><p><code>del d[key]</code></p>
<p>将 <code>d[key]</code> 从 <em>d</em> 中移除。 如果映射中不存在 <em>key</em> 则会引发 <code>KeyError</code>。</p>
</li>
<li><p><code>key in d</code></p>
<p>如果 <em>d</em> 中存在键 <em>key</em> 则返回 <code>True</code>，否则返回 <code>False</code>。</p>
</li>
<li><p><code>key not in d</code></p>
<p>等价于 <code>not key in d</code>。</p>
</li>
<li><p><code>iter(d)</code></p>
<p>返回以字典的键为元素的迭代器。 这是 <code>iter(d.keys())</code> 的快捷方式。</p>
</li>
<li><p><code>clear</code>()</p>
<p>移除字典中的所有元素。</p>
</li>
<li><p><code>copy</code>()</p>
<p>返回原字典的浅拷贝。</p>
</li>
<li><p><em>classmethod</em> <code>fromkeys</code>(<em>iterable</em>[, <em>value</em>])</p>
<p>使用来自 <em>iterable</em> 的键创建一个新字典，并将键值设为 <em>value</em>。</p>
<p><code>fromkeys()</code> 是一个返回新字典的类方法。 <em>value</em> 默认为 <code>None</code>。 所有值都只引用一个单独的实例，因此让 <em>value</em> 成为一个可变对象例如空列表通常是没有意义的。 要获取不同的值，请改用 字典推导式。</p>
</li>
<li><p><code>get</code>(<em>key</em>[, <em>default</em>])</p>
<p>如果 <em>key</em> 存在于字典中则返回 <em>key</em> 的值，否则返回 <em>default*。 如果 *default</em> 未给出则默认为 <code>None</code>，因而此方法绝不会引发 <code>KeyError</code>。</p>
</li>
<li><p><code>items</code>()</p>
<p>返回由字典项 (<code>(键, 值)</code> 对) 组成的一个新视图。 </p>
</li>
<li><p><code>keys</code>()</p>
<p>返回由字典键组成的一个新视图。 </p>
</li>
<li><p><code>pop</code>(<em>key</em>[, <em>default</em>])</p>
<p>如果 <em>key</em> 存在于字典中则将其移除并返回其值，否则返回 <em>default*。 如果 *default</em> 未给出且 <em>key</em> 不存在于字典中，则会引发 <code>KeyError</code>。</p>
</li>
<li><p><code>popitem</code>()</p>
<p>从字典中移除并返回一个 <code>(键, 值)</code> 对。 键值对会按 LIFO 的顺序被返回。</p>
<p><code>popitem()</code> 适用于对字典进行消耗性的迭代，这在集合算法中经常被使用。 如果字典为空，调用 <code>popitem()</code> 将引发 <code>KeyError</code>。</p>
<p>在 3.7 版更改: 现在会确保采用 LIFO 顺序。 在之前的版本中，<code>popitem()</code> 会返回一个任意的键/值对。</p>
</li>
<li><p><code>reversed(d)</code></p>
<p>返回一个逆序获取字典键的迭代器。 这是 <code>reversed(d.keys())</code> 的快捷方式。</p>
<p>3.8 新版功能.</p>
</li>
<li><p><code>setdefault</code>(<em>key</em>[, <em>default</em>])</p>
<p>如果字典存在键 <em>key</em> ，返回它的值。如果不存在，插入值为 <em>default</em> 的键 <em>key</em> ，并返回 <em>default</em> 。 <em>default</em> 默认为 <code>None</code>。</p>
</li>
<li><p><code>update</code>([<em>other</em>])</p>
<p>使用来自 <em>other</em> 的键/值对更新字典，覆盖原有的键。 返回 <code>None</code>。</p>
<p><code>update()</code> 接受另一个字典对象，或者一个包含键/值对（以长度为二的元组或其他可迭代对象表示）的可迭代对象。 如果给出了关键字参数，则会以其所指定的键/值对更新字典: <code>d.update(red=1, blue=2)</code>。</p>
</li>
<li><p><code>values</code>()</p>
<p>返回由字典值组成的一个新视图。 </p>
<p>两个 <code>dict.values()</code> 视图之间的相等性比较将总是返回 <code>False</code>。 这在 <code>dict.values()</code> 与其自身比较时也同样适用:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> d<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>d | other</code></p>
<p>合并 <em>d</em> 和 <em>other</em> 中的键和值来创建一个新的字典，两者必须都是字典。当 <em>d</em> 和 <em>other</em> 有相同键时， <em>other</em> 的值优先。</p>
<p>3.9 新版功能.</p>
</li>
<li><p><code>d |= other</code></p>
<p>用 <em>other</em> 的键和值更新字典 <em>d</em> ，<em>other</em> 可以是 mapping 或 iterable 的键值对。当 <em>d</em> 和 <em>other</em> 有相同键时， <em>other</em> 的值优先。</p>
<p>3.9 新版功能.</p>
</li>
</ul>
<p>两个字典的比较当且仅当它们具有相同的 <code>(键, 值)</code> 对时才会相等（不考虑顺序）。 排序比较 (‘&lt;’, ‘&lt;=’, ‘&gt;=’, ‘&gt;’) 会引发 <code>TypeError</code>。</p>
<p>字典会保留插入时的顺序。 请注意对键的更新不会影响顺序。 删除并再次添加的键将被插入到末尾。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"one"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> d
<span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>d<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>d<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">"one"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span>
<span class="token operator">>></span><span class="token operator">></span> d
<span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> d<span class="token punctuation">[</span><span class="token string">"two"</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> d<span class="token punctuation">[</span><span class="token string">"two"</span><span class="token punctuation">]</span> <span class="token operator">=</span> None
<span class="token operator">>></span><span class="token operator">></span> d
<span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> None<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.7 版更改: 字典顺序会确保为插入顺序。 此行为是自 3.6 版开始的 CPython 实现细节。</p>
<p>字典和字典视图都是可逆的。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"one"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> d
<span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>reversed<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'four'</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token string">'one'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>reversed<span class="token punctuation">(</span>d<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>reversed<span class="token punctuation">(</span>d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'four'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'three'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.8 版更改: 字典现在是可逆的。</p>
<h3 id="字典视图对象"><a href="#字典视图对象" class="headerlink" title="字典视图对象"></a>字典视图对象</h3><p>由 <code>dict.keys()</code>, <code>dict.values()</code> 和 <code>dict.items()</code> 所返回的对象是 <em>视图对象</em>。 该对象提供字典条目的一个动态视图，这意味着当字典改变时，视图也会相应改变。</p>
<p>字典视图可以被迭代以产生与其对应的数据，并支持成员检测：</p>
<pre><code>len(dictview)</code></pre><p>返回字典中的条目数。</p>
<pre><code>iter(dictview)</code></pre><p>返回字典中的键、值或项（以 <code>(键, 值)</code> 为元素的元组表示）的迭代器。</p>
<p>键和值是按插入时的顺序进行迭代的。 这样就允许使用 <code>zip()</code> 来创建 <code>(值, 键)</code> 对: <code>pairs = zip(d.values(), d.keys())</code>。 另一个创建相同列表的方式是 <code>pairs = [(v, k) for (k, v) in d.items()]</code>.</p>
<p>在添加或删除字典中的条目期间对视图进行迭代可能引发 <code>RuntimeError</code> 或者无法完全迭代所有条目。</p>
<p>在 3.7 版更改: 字典顺序会确保为插入顺序。</p>
<pre><code>x in dictview</code></pre><p>如果 <em>x</em> 是对应字典中存在的键、值或项（在最后一种情况下 <em>x</em> 应为一个 <code>(键, 值)</code> 元组） 则返回 <code>True</code>。</p>
<pre><code>reversed(dictview)</code></pre><p>返回一个逆序获取字典键、值或项的迭代器。 视图将按与插入时相反的顺序进行迭代。</p>
<p>在 3.8 版更改: 字典视图现在是可逆的。</p>
<pre><code>dictview.mapping</code></pre><p>Return a <code>types.MappingProxyType</code> that wraps the original dictionary to which the view refers.</p>
<p>3.10 新版功能.</p>
<p>键视图类似于集合，因为其条目不重复且可哈希。 如果所有值都是可哈希的，即 <code>(键, 值)</code> 对也是不重复且可哈希的，那么条目视图也会类似于集合。 （值视图则不被视为类似于集合，因其条目通常都是有重复的。） 对于类似于集合的视图，为抽象基类 <code>collections.abc.Set</code> 所定义的全部操作都是有效的 (例如 <code>==</code>, <code>&lt;</code> 或 <code>^</code>)。</p>
<p>一个使用字典视图的示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> dishes <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'eggs'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'sausage'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'bacon'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">:</span> <span class="token number">500</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> keys <span class="token operator">=</span> dishes<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> values <span class="token operator">=</span> dishes<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># iteration</span>
<span class="token operator">>></span><span class="token operator">></span> n <span class="token operator">=</span> <span class="token number">0</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> val <span class="token keyword">in</span> values<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     n <span class="token operator">+=</span> val
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
<span class="token number">504</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># keys and values are iterated over in the same order (insertion order)</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>keys<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'eggs'</span><span class="token punctuation">,</span> <span class="token string">'sausage'</span><span class="token punctuation">,</span> <span class="token string">'bacon'</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>values<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># view objects are dynamic and reflect dict changes</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> dishes<span class="token punctuation">[</span><span class="token string">'eggs'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> dishes<span class="token punctuation">[</span><span class="token string">'sausage'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>keys<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'bacon'</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># set operations</span>
<span class="token operator">>></span><span class="token operator">></span> keys <span class="token operator">&amp;</span> <span class="token punctuation">{</span><span class="token string">'eggs'</span><span class="token punctuation">,</span> <span class="token string">'bacon'</span><span class="token punctuation">,</span> <span class="token string">'salad'</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span><span class="token string">'bacon'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> keys <span class="token operator">^</span> <span class="token punctuation">{</span><span class="token string">'sausage'</span><span class="token punctuation">,</span> <span class="token string">'juice'</span><span class="token punctuation">}</span>
<span class="token punctuation">{</span><span class="token string">'juice'</span><span class="token punctuation">,</span> <span class="token string">'sausage'</span><span class="token punctuation">,</span> <span class="token string">'bacon'</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># get back a read-only proxy for the original dictionary</span>
<span class="token operator">>></span><span class="token operator">></span> values<span class="token punctuation">.</span>mapping
mappingproxy<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'eggs'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'sausage'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'bacon'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">:</span> <span class="token number">500</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> values<span class="token punctuation">.</span>mapping<span class="token punctuation">[</span><span class="token string">'spam'</span><span class="token punctuation">]</span>
<span class="token number">500</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="上下文管理器类型"><a href="#上下文管理器类型" class="headerlink" title="上下文管理器类型"></a>上下文管理器类型</h2><p>Python 的 <code>with</code> 语句支持通过上下文管理器所定义的运行时上下文这一概念。 此对象的实现使用了一对专门方法，允许用户自定义类来定义运行时上下文，在语句体被执行前进入该上下文，并在语句执行完毕时退出该上下文：</p>
<p><code>contextmanager.__enter__</code>()</p>
<p>进入运行时上下文并返回此对象或关联到该运行时上下文的其他对象。 此方法的返回值会绑定到使用此上下文管理器的 <code>with</code> 语句的 <code>as</code> 子句中的标识符。</p>
<p>一个返回其自身的上下文管理器的例子是 file object。 文件对象会从 <strong>enter</strong>() 返回其自身，以允许 <code>open()</code> 被用作 <code>with</code> 语句中的上下文表达式。</p>
<p>一个返回关联对象的上下文管理器的例子是 <code>decimal.localcontext()</code> 所返回的对象。 此种管理器会将活动的 decimal 上下文设为原始 decimal 上下文的一个副本并返回该副本。 这允许对 <code>with</code> 语句的语句体中的当前 decimal 上下文进行更改，而不会影响 <code>with</code> 语句以外的代码。</p>
<p><code>contextmanager.__exit__</code>(<em>exc_type</em>, <em>exc_val</em>, <em>exc_tb</em>)</p>
<p>退出运行时上下文并返回一个布尔值旗标来表明所发生的任何异常是否应当被屏蔽。 如果在执行 <code>with</code> 语句的语句体期间发生了异常，则参数会包含异常的类型、值以及回溯信息。 在其他情况下三个参数均为 <code>None</code>。</p>
<p>自此方法返回一个真值将导致 <code>with</code> 语句屏蔽异常并继续执行紧随在 <code>with</code> 语句之后的语句。 否则异常将在此方法结束执行后继续传播。 在此方法执行期间发生的异常将会取代 <code>with</code> 语句的语句体中发生的任何异常。</p>
<p>传入的异常绝对不应当被显式地重新引发 —— 相反地，此方法应当返回一个假值以表明方法已成功完成并且不希望屏蔽被引发的异常。 这允许上下文管理代码方便地检测 <code>__exit__()</code> 方法是否确实已失败。</p>
<p>Python 定义了一些上下文管理器来支持简易的线程同步、文件或其他对象的快速关闭，以及更方便地操作活动的十进制算术上下文。 除了实现上下文管理协议以外，不同类型不会被特殊处理。 </p>
<p>Python 的 generator 和 <code>contextlib.contextmanager</code> 装饰器提供了实现这些协议的便捷方式。 如果使用 <code>contextlib.contextmanager</code> 装饰器来装饰一个生成器函数，它将返回一个实现了必要的 <code>__enter__()</code> and <code>__exit__()</code> 方法的上下文管理器，而不再是由未经装饰的生成器函数所产生的迭代器。</p>
<p>请注意，Python/C API 中 Python 对象的类型结构中并没有针对这些方法的专门槽位。 想要定义这些方法的扩展类型必须将它们作为普通的 Python 可访问方法来提供。 与设置运行时上下文的开销相比，单个类字典查找的开销可以忽略不计。</p>
<h2 id="Type-Annotation-Types-—-Generic-Alias-Union"><a href="#Type-Annotation-Types-—-Generic-Alias-Union" class="headerlink" title="Type Annotation Types —- Generic Alias, Union"></a>Type Annotation Types —- Generic Alias, Union</h2><p>The core built-in types for type annotations are Generic Alias and Union.</p>
<h3 id="Generic-Alias-Type"><a href="#Generic-Alias-Type" class="headerlink" title="Generic Alias Type"></a>Generic Alias Type</h3><p><code>GenericAlias</code> objects are created by subscripting a class (usually a container), such as <code>list[int]</code>. They are intended primarily for type annotations.</p>
<p>Usually, the subscription of container objects calls the method <code>__getitem__()</code> of the object. However, the subscription of some containers’ classes may call the classmethod <code>__class_getitem__()</code> of the class instead. The classmethod <code>__class_getitem__()</code> should return a <code>GenericAlias</code> object.</p>
<p>注解</p>
<p>If the <code>__getitem__()</code> of the class’ metaclass is present, it will take precedence over the <code>__class_getitem__()</code> defined in the class (see <a href="https://www.python.org/dev/peps/pep-0560" target="_blank" rel="noopener"><strong>PEP 560</strong></a> for more details).</p>
<p>The <code>GenericAlias</code> object acts as a proxy for generic types, implementing <em>parameterized generics</em> - a specific instance of a generic which provides the types for container elements.</p>
<p>The user-exposed type for the <code>GenericAlias</code> object can be accessed from <code>types.GenericAlias</code> and used for <code>isinstance()</code> checks. It can also be used to create <code>GenericAlias</code> objects directly.</p>
<pre><code>T[X, Y, ...]</code></pre><p>Creates a <code>GenericAlias</code> representing a type <code>T</code> containing elements of types <em>X</em>, <em>Y</em>, and more depending on the <code>T</code> used. For example, a function expecting a <code>list</code> containing <code>float</code> elements:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">average</span><span class="token punctuation">(</span>values<span class="token punctuation">:</span> list<span class="token punctuation">[</span>float<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> float<span class="token punctuation">:</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">(</span>values<span class="token punctuation">)</span> <span class="token operator">/</span> len<span class="token punctuation">(</span>values<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Another example for mapping objects, using a <code>dict</code>, which is a generic type expecting two type parameters representing the key type and the value type. In this example, the function expects a <code>dict</code> with keys of type <code>str</code> and values of type <code>int</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">send_post_request</span><span class="token punctuation">(</span>url<span class="token punctuation">:</span> str<span class="token punctuation">,</span> body<span class="token punctuation">:</span> dict<span class="token punctuation">[</span>str<span class="token punctuation">,</span> int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>The builtin functions <code>isinstance()</code> and <code>issubclass()</code> do not accept <code>GenericAlias</code> types for their second argument:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> isinstance<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> isinstance<span class="token punctuation">(</span><span class="token punctuation">)</span> argument <span class="token number">2</span> cannot be a parameterized generic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>The Python runtime does not enforce type annotations. This extends to generic types and their type parameters. When creating an object from a <code>GenericAlias</code>, container elements are not checked against their type. For example, the following code is discouraged, but will run without errors:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> list<span class="token punctuation">[</span>str<span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> t<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>Furthermore, parameterized generics erase type parameters during object creation:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> t <span class="token operator">=</span> list<span class="token punctuation">[</span>str<span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>t<span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'types.GenericAlias'</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> l <span class="token operator">=</span> t<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>l<span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'list'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Calling <code>repr()</code> or <code>str()</code> on a generic shows the parameterized type:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> repr<span class="token punctuation">(</span>list<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">'list[int]'</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>list<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">'list[int]'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>The <code>__getitem__()</code> method of generics will raise an exception to disallow mistakes like <code>dict[str][str]</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> dict<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">[</span>str<span class="token punctuation">]</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> There are no type variables left <span class="token keyword">in</span> dict<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>However, such expressions are valid when type variables are used. The index must have as many elements as there are type variable items in the <code>GenericAlias</code> object’s <code>__args__</code>.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> typing <span class="token keyword">import</span> TypeVar
<span class="token operator">>></span><span class="token operator">></span> Y <span class="token operator">=</span> TypeVar<span class="token punctuation">(</span><span class="token string">'Y'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> dict<span class="token punctuation">[</span>str<span class="token punctuation">,</span> Y<span class="token punctuation">]</span><span class="token punctuation">[</span>int<span class="token punctuation">]</span>
dict<span class="token punctuation">[</span>str<span class="token punctuation">,</span> int<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Standard-Generic-Collections"><a href="#Standard-Generic-Collections" class="headerlink" title="Standard Generic Collections"></a>Standard Generic Collections</h4><p>These standard library collections support parameterized generics.</p>
<ul>
<li><code>tuple</code></li>
<li><code>list</code></li>
<li><code>dict</code></li>
<li><code>set</code></li>
<li><code>frozenset</code></li>
<li><code>type</code></li>
<li><code>collections.deque</code></li>
<li><code>collections.defaultdict</code></li>
<li><code>collections.OrderedDict</code></li>
<li><code>collections.Counter</code></li>
<li><code>collections.ChainMap</code></li>
<li><code>collections.abc.Awaitable</code></li>
<li><code>collections.abc.Coroutine</code></li>
<li><code>collections.abc.AsyncIterable</code></li>
<li><code>collections.abc.AsyncIterator</code></li>
<li><code>collections.abc.AsyncGenerator</code></li>
<li><code>collections.abc.Iterable</code></li>
<li><code>collections.abc.Iterator</code></li>
<li><code>collections.abc.Generator</code></li>
<li><code>collections.abc.Reversible</code></li>
<li><code>collections.abc.Container</code></li>
<li><code>collections.abc.Collection</code></li>
<li><code>collections.abc.Callable</code></li>
<li><code>collections.abc.Set</code></li>
<li><code>collections.abc.MutableSet</code></li>
<li><code>collections.abc.Mapping</code></li>
<li><code>collections.abc.MutableMapping</code></li>
<li><code>collections.abc.Sequence</code></li>
<li><code>collections.abc.MutableSequence</code></li>
<li><code>collections.abc.ByteString</code></li>
<li><code>collections.abc.MappingView</code></li>
<li><code>collections.abc.KeysView</code></li>
<li><code>collections.abc.ItemsView</code></li>
<li><code>collections.abc.ValuesView</code></li>
<li><code>contextlib.AbstractContextManager</code></li>
<li><code>contextlib.AbstractAsyncContextManager</code></li>
<li>re.Pattern</li>
<li>re.Match</li>
</ul>
<h4 id="Special-Attributes-of-Generic-Alias"><a href="#Special-Attributes-of-Generic-Alias" class="headerlink" title="Special Attributes of Generic Alias"></a>Special Attributes of Generic Alias</h4><p>All parameterized generics implement special read-only attributes.</p>
<pre class="line-numbers language-python"><code class="language-python">genericalias<span class="token punctuation">.</span>__origin__<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>This attribute points at the non-parameterized generic class:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">.</span>__origin__
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'list'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>genericalias.__args__</code></p>
<p>This attribute is a <code>tuple</code> (possibly of length 1) of generic types passed to the original <code>__class_getitem__()</code> of the generic container:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> dict<span class="token punctuation">[</span>str<span class="token punctuation">,</span> list<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span>__args__
<span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span><span class="token punctuation">,</span> list<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>genericalias.__parameters__</code></p>
<p>This attribute is a lazily computed tuple (possibly empty) of unique type variables found in <code>__args__</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> typing <span class="token keyword">import</span> TypeVar
<span class="token operator">>></span><span class="token operator">></span> T <span class="token operator">=</span> TypeVar<span class="token punctuation">(</span><span class="token string">'T'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">.</span>__parameters__
<span class="token punctuation">(</span><span class="token operator">~</span>T<span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>A <code>GenericAlias</code> object with <code>typing.ParamSpec</code> parameters may not have correct <code>__parameters__</code> after substitution because <code>typing.ParamSpec</code> is intended primarily for static type checking.</p>
<p>参见</p>
<ul>
<li><a href="https://www.python.org/dev/peps/pep-0585" target="_blank" rel="noopener"><strong>PEP 585</strong></a> — “Type Hinting Generics In Standard Collections”</li>
<li><code>__class_getitem__()</code> — Used to implement parameterized generics.</li>
<li>泛型（Generic） — Generics in the <code>typing</code> module.</li>
</ul>
<p>3.9 新版功能.</p>
<h3 id="Union-Type"><a href="#Union-Type" class="headerlink" title="Union Type"></a>Union Type</h3><p>A union object holds the value of the <code>|</code> (bitwise or) operation on multiple type objects. These types are intended primarily for type annotations. The union type expression enables cleaner type hinting syntax compared to <code>typing.Union</code>.</p>
<pre><code>X | Y | ...</code></pre><p>Defines a union object which holds types <em>X</em>, <em>Y</em>, and so forth. <code>X | Y</code> means either X or Y. It is equivalent to <code>typing.Union[X, Y]</code>. For example, the following function expects an argument of type <code>int</code> or <code>float</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">square</span><span class="token punctuation">(</span>number<span class="token punctuation">:</span> int <span class="token operator">|</span> float<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int <span class="token operator">|</span> float<span class="token punctuation">:</span>
    <span class="token keyword">return</span> number <span class="token operator">**</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>union_object == other</code></p>
<p>Union objects can be tested for equality with other union objects. Details:</p>
<ul>
<li><p>Unions of unions are flattened:</p>
<pre><code>(int | str) | float == int | str | float</code></pre></li>
<li><p>Redundant types are removed:</p>
<pre><code>int | str | int == int | str</code></pre></li>
<li><p>When comparing unions, the order is ignored:</p>
<pre><code>int | str == str | int</code></pre></li>
<li><p>It is compatible with <code>typing.Union</code>:</p>
<pre><code>int | str == typing.Union[int, str]</code></pre></li>
<li><p>Optional types can be spelled as a union with <code>None</code>:</p>
<pre><code>str | None == typing.Optional[str]</code></pre></li>
</ul>
<pre><code>isinstance(obj, union_object)
issubclass(obj, union_object)</code></pre><p>Calls to <code>isinstance()</code> and <code>issubclass()</code> are also supported with a union object:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> isinstance<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> int <span class="token operator">|</span> str<span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>However, union objects containing parameterized generics cannot be used:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> isinstance<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> int <span class="token operator">|</span> list<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> isinstance<span class="token punctuation">(</span><span class="token punctuation">)</span> argument <span class="token number">2</span> cannot contain a parameterized generic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>The user-exposed type for the union object can be accessed from <code>types.UnionType</code> and used for <code>isinstance()</code> checks. An object cannot be instantiated from the type:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> types
<span class="token operator">>></span><span class="token operator">></span> isinstance<span class="token punctuation">(</span>int <span class="token operator">|</span> str<span class="token punctuation">,</span> types<span class="token punctuation">.</span>UnionType<span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> types<span class="token punctuation">.</span>UnionType<span class="token punctuation">(</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> cannot create <span class="token string">'types.UnionType'</span> instances<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>The <code>__or__()</code> method for type objects was added to support the syntax <code>X | Y</code>. If a metaclass implements <code>__or__()</code>, the Union may override it:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">M</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__or__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token string">"Hello"</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>metaclass<span class="token operator">=</span>M<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">pass</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> C <span class="token operator">|</span> int
<span class="token string">'Hello'</span>
<span class="token operator">>></span><span class="token operator">></span> int <span class="token operator">|</span> C
int <span class="token operator">|</span> __main__<span class="token punctuation">.</span>C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0604" target="_blank" rel="noopener"><strong>PEP 604</strong></a> — PEP proposing the <code>X | Y</code> syntax and the Union type.</p>
<p>3.10 新版功能.</p>
<h2 id="其他内置类型"><a href="#其他内置类型" class="headerlink" title="其他内置类型"></a>其他内置类型</h2><p>解释器支持一些其他种类的对象。 这些对象大都仅支持一两种操作。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块唯一的特殊操作是属性访问: <code>m.name</code>，这里 <em>m</em> 为一个模块而 <em>name</em> 访问定义在 <em>m</em> 的符号表中的一个名称。 模块属性可以被赋值。 （请注意 <code>import</code> 语句严格来说也是对模块对象的一种操作；<code>import foo</code> 不要求存在一个名为 <em>foo</em> 的模块对象，而是要求存在一个对于名为 <em>foo</em> 的模块的 (永久性) <em>定义</em>。）</p>
<p>每个模块都有一个特殊属性 <code>__dict__</code>。 这是包含模块的符号表的字典。 修改此字典将实际改变模块的符号表，但是无法直接对 <code>__dict__</code> 赋值 (你可以写 <code>m.__dict__['a'] = 1</code>，这会将 <code>m.a</code> 定义为 <code>1</code>，但是你不能写 <code>m.__dict__ = {}</code>)。 不建议直接修改 <code>__dict__</code>。</p>
<p>内置于解释器中的模块会写成这样: <code>&lt;module 'sys' (built-in)&gt;</code>。 如果是从一个文件加载，则会写成 <code>&lt;module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'&gt;</code>。</p>
<h3 id="类与类实例"><a href="#类与类实例" class="headerlink" title="类与类实例"></a>类与类实例</h3><p>关于这些类型请参阅 对象、值与类型 和 类定义。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数对象是通过函数定义创建的。 对函数对象的唯一操作是调用它: <code>func(argument-list)</code>。</p>
<p>实际上存在两种不同的函数对象：内置函数和用户自定义函数。 两者支持同样的操作（调用函数），但实现方式不同，因此对象类型也不同。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法是使用属性表示法来调用的函数。 存在两种形式：内置方法（例如列表的 <code>append()</code> 方法）和类实例方法。 内置方法由支持它们的类型来描述。</p>
<p>如果你通过一个实例来访问方法（即定义在类命名空间内的函数），你会得到一个特殊对象: <em>绑定方法</em> (或称 <em>实例方法</em>) 对象。 当被调用时，它会将 <code>self</code> 参数添加到参数列表。 绑定方法具有两个特殊的只读属性: <code>m.__self__</code> 操作该方法的对象，而 <code>m.__func__</code> 是实现该方法的函数。 调用 <code>m(arg-1, arg-2, ..., arg-n)</code> 完全等价于调用 <code>m.__func__(m.__self__, arg-1, arg-2, ..., arg-n)</code>。</p>
<p>与函数对象类似，绑定方法对象也支持获取任意属性。 但是，由于方法属性实际上保存于下层的函数对象中 (<code>meth.__func__</code>)，因此不允许设置绑定方法的方法属性。 尝试设置方法的属性将会导致引发 <code>AttributeError</code>。 想要设置方法属性，你必须在下层的函数对象中显式地对其进行设置:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">pass</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>method<span class="token punctuation">.</span>whoami <span class="token operator">=</span> <span class="token string">'my name is method'</span>  <span class="token comment" spellcheck="true"># can't set on the method</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
AttributeError<span class="token punctuation">:</span> <span class="token string">'method'</span> object has no attribute <span class="token string">'whoami'</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>method<span class="token punctuation">.</span>__func__<span class="token punctuation">.</span>whoami <span class="token operator">=</span> <span class="token string">'my name is method'</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>method<span class="token punctuation">.</span>whoami
<span class="token string">'my name is method'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="代码对象"><a href="#代码对象" class="headerlink" title="代码对象"></a>代码对象</h3><p>代码对象被具体实现用来表示“伪编译”的可执行 Python 代码，例如一个函数体。 它们不同于函数对象，因为它们不包含对其全局执行环境的引用。 代码对象由内置的 <code>compile()</code> 函数返回，并可通过从函数对象的 <code>__code__</code> 属性从中提取。 </p>
<p>Accessing <code>__code__</code> raises an auditing event <code>object.__getattr__</code> with arguments <code>obj</code> and <code>"__code__"</code>.</p>
<p>可以通过将代码对象（而非源码字符串）传给 <code>exec()</code> 或 <code>eval()</code> 内置函数来执行或求值。</p>
<h3 id="类型对象"><a href="#类型对象" class="headerlink" title="类型对象"></a>类型对象</h3><p>类型对象表示各种对象类型。 对象的类型可通过内置函数 <code>type()</code> 来获取。 类型没有特殊的操作。 标准库模块 <code>types</code> 定义了所有标准内置类型的名称。</p>
<p>类型以这样的写法来表示: <code>&lt;class 'int'&gt;</code>。</p>
<h3 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h3><p>此对象会由不显式地返回值的函数所返回。 它不支持任何特殊的操作。 空对象只有一种值 <code>None</code> (这是个内置名称)。 <code>type(None)()</code> 会生成同一个单例。</p>
<p>该对象的写法为 <code>None</code>。</p>
<h3 id="省略符对象"><a href="#省略符对象" class="headerlink" title="省略符对象"></a>省略符对象</h3><p>此对象常被用于切片。 它不支持任何特殊的操作。 省略符对象只有一种值 <code>Ellipsis</code> (这是个内置名称)。 <code>type(Ellipsis)()</code> 会生成 <code>Ellipsis</code> 单例。</p>
<p>该对象的写法为 <code>Ellipsis</code> 或 <code>...</code>。</p>
<h3 id="未实现对象"><a href="#未实现对象" class="headerlink" title="未实现对象"></a>未实现对象</h3><p>此对象会被作为比较和二元运算被应用于它们所不支持的类型时的返回值。未实现对象只有一种值 <code>NotImplemented</code>。 <code>type(NotImplemented)()</code> 会生成这个单例。</p>
<p>该对象的写法为 <code>NotImplemented</code>。</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔值是两个常量对象 <code>False</code> 和 <code>True</code>。 它们被用来表示逻辑上的真假（不过其他值也可被当作真值或假值）。 在数字类的上下文中（例如被用作算术运算符的参数时），它们的行为分别类似于整数 0 和 1。 内置函数 <code>bool()</code> 可被用来将任意值转换为布尔值，只要该值可被解析为一个逻辑值。</p>
<p>该对象的写法分别为 <code>False</code> 和 <code>True</code>。</p>
<h3 id="内部对象"><a href="#内部对象" class="headerlink" title="内部对象"></a>内部对象</h3><p>有关此对象的信息请参阅 标准类型层级结构。 其中描述了栈帧对象、回溯对象以及切片对象等等。</p>
<h2 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h2><p>语言实现为部分对象类型添加了一些特殊的只读属性，它们具有各自的作用。 其中一些并不会被 <code>dir()</code> 内置函数所列出。</p>
<pre><code>object.__dict__</code></pre><p>一个字典或其他类型的映射对象，用于存储对象的（可写）属性。</p>
<pre><code>instance.__class__</code></pre><p>类实例所属的类。</p>
<pre><code>class.__bases__</code></pre><p>由类对象的基类所组成的元组。</p>
<pre><code>definition.__name__</code></pre><p>类、函数、方法、描述器或生成器实例的名称。</p>
<pre><code>definition.__qualname__</code></pre><p>类、函数、方法、描述器或生成器实例的 qualified name。</p>
<p>3.3 新版功能.</p>
<pre><code>class.__mro__</code></pre><p>此属性是由类组成的元组，在方法解析期间会基于它来查找基类。</p>
<p><code>class.mro</code>()</p>
<p>此方法可被一个元类来重载，以为其实例定制方法解析顺序。 它会在类实例化时被调用，其结果存储于 <code>__mro__</code> 之中。</p>
<p><code>class.__subclasses__</code>()</p>
<p>Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order. Example:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">.</span>__subclasses__<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'bool'</span><span class="token operator">></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h1 id="内置异常"><a href="#内置异常" class="headerlink" title="内置异常"></a>内置异常</h1><p>在 Python 中，所有异常必须为一个派生自 <code>BaseException</code> 的类的实例。 在带有提及一个特定类的 <code>except</code> 子句的 <code>try</code> 语句中，该子句也会处理任何派生自该类的异常类（但不处理 <em>它</em> 所派生出的异常类）。 通过子类化创建的两个不相关异常类永远是不等效的，既使它们具有相同的名称。</p>
<p>下面列出的内置异常可通过解释器或内置函数来生成。除非另有说明，它们都会具有一个提示导致错误详细原因的“关联值”。 这可以是一个字符串或由多个信息项（例如一个错误码和一个解释错误的字符串）组成的元组。 关联值通常会作为参数被传递给异常类的构造器。</p>
<p>用户代码可以引发内置异常。 这可被用于测试异常处理程序或报告错误条件，“就像” 在解释器引发了相同异常的情况时一样；但是请注意，没有任何机制能防止用户代码引发不适当的错误。</p>
<p>内置异常类可以被子类化以定义新的异常；鼓励程序员从 <code>Exception</code> 类或它的某个子类而不是从 <code>BaseException</code> 来派生新的异常。 </p>
<p>当在 <code>except</code> 或 <code>finally</code> 子句中引发（或重新引发）异常时，<code>__context__</code> 会被自动设为所捕获的最后一个异常；如果新的异常未被处理，则最终显示的回溯信息将包括原始的异常和最后的异常。</p>
<p>当引发一个新的异常（而不是简单地使用 <code>raise</code> 来重新引发 当前在处理的异常）时，隐式的异常上下文可以通过使用带有 <code>raise</code> 的 <code>from</code> 子句来补充一个显式的原因:</p>
<pre><code>raise new_exc from original_exc</code></pre><p>跟在 <code>from</code> 之后一表达式必须为一个异常或 <code>None</code>。 它将在所引发的异常上被设置为 <code>__cause__</code>。 设置 <code>__cause__</code> 还会隐式地将 <code>__suppress_context__</code> 属性设为 <code>True</code>，这样使用 <code>raise new_exc from None</code> 可以有效地将旧异常替换为新异常来显示其目的 (例如将 <code>KeyError</code> 转换为 <code>AttributeError</code>)，同时让旧异常在 <code>__context__</code> 中保持可用状态以便在调试时进行内省。</p>
<p>除了异常本身的回溯以外，默认的回溯还会显示这些串连的异常。 <code>__cause__</code> 中的显式串连异常如果存在将总是显示。 <code>__context__</code> 中的隐式串连异常仅在 <code>__cause__</code> 为 <code>None</code> 并且 <code>__suppress_context__</code> 为假值时显示。</p>
<p>不论在哪种情况下，异常本身总会在任何串连异常之后显示，以便回溯的最后一行总是显示所引发的最后一个异常。</p>
<h2 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h2><p>下列异常主要被用作其他异常的基类。</p>
<ul>
<li><em>exception</em> <code>BaseException</code></li>
</ul>
<p>所有内置异常的基类。 它不应该被用户自定义类直接继承 (这种情况请使用 <code>Exception</code>)。 如果在此类的实例上调用 <code>str()</code>，则会返回实例的参数表示，或者当没有参数时返回空字符串。</p>
<p>​    <code>args</code></p>
<p>传给异常构造器的参数元组。 某些内置异常 (例如 <code>OSError</code>) 接受特定数量的参数并赋予此元组中的元素特殊的含义，而其他异常通常只接受一个给出错误信息的单独字符串。</p>
<p>​    <code>with_traceback</code>(<em>tb</em>)</p>
<p>此方法会将 <em>tb</em> 设为新的异常回溯信息并返回异常对象。 它在 <a href="https://www.python.org/dev/peps/pep-3134" target="_blank" rel="noopener"><strong>PEP 3134</strong></a> 的异常链特性可用之前更为常用。 下面的例子演示了我们如何将一个 <code>SomeException</code> 实例转换为 <code>OtherException</code> 实例而保留回溯信息。 异常一旦被引发，当前帧会被推至 <code>OtherException</code> 的回溯栈顶端，就像当我们允许原始 <code>SomeException</code> 被传播给调用方时它的回溯栈将会发生的情形一样。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">except</span> SomeException<span class="token punctuation">:</span>
    tb <span class="token operator">=</span> sys<span class="token punctuation">.</span>exc_info<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
    <span class="token keyword">raise</span> OtherException<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">.</span>with_traceback<span class="token punctuation">(</span>tb<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><em>exception</em> <code>Exception</code></li>
</ul>
<p>所有内置的非系统退出类异常都派生自此类。 所有用户自定义异常也应当派生自此类。</p>
<ul>
<li><em>exception</em> <code>ArithmeticError</code></li>
</ul>
<p>此基类用于派生针对各种算术类错误而引发的内置异常: <code>OverflowError</code>, <code>ZeroDivisionError</code>, <code>FloatingPointError</code>。</p>
<ul>
<li><em>exception</em> <code>BufferError</code></li>
</ul>
<p>当与 缓冲区 相关的操作无法执行时将被引发。</p>
<ul>
<li><em>exception</em> <code>LookupError</code></li>
</ul>
<p>此基类用于派生当映射或序列所使用的键或索引无效时引发的异常: <code>IndexError</code>, <code>KeyError</code>。 这可以通过 <code>codecs.lookup()</code> 来直接引发。</p>
<h2 id="具体异常"><a href="#具体异常" class="headerlink" title="具体异常"></a>具体异常</h2><p>以下异常属于经常被引发的异常。</p>
<ul>
<li><em>exception</em> <code>AssertionError</code></li>
</ul>
<p>当 <code>assert</code> 语句失败时将被引发。</p>
<ul>
<li><em>exception</em> <code>AttributeError</code></li>
</ul>
<p>当属性引用 或赋值失败时将被引发。 （当一个对象根本不支持属性引用或属性赋值时则将引发 <code>TypeError</code>。）</p>
<p><code>name</code> 和 <code>obj</code> 属性可以使用构造器的仅限关键字参数来设置。 它们如果被设置则分别代表要尝试访问的属性名称以及所访问的该属性的对象。</p>
<p>在 3.10 版更改: 增加了 <code>name</code> 和 <code>obj</code> 属性。</p>
<ul>
<li><em>exception</em> <code>EOFError</code></li>
</ul>
<p>当 <code>input()</code> 函数未读取任何数据即达到文件结束条件 (EOF) 时将被引发。 （另外，<code>io.IOBase.read()</code> 和 <code>io.IOBase.readline()</code> 方法在遇到 EOF 则将返回一个空字符串。）</p>
<ul>
<li><em>exception</em> <code>FloatingPointError</code></li>
</ul>
<p>目前未被使用。</p>
<ul>
<li><em>exception</em> <code>GeneratorExit</code></li>
</ul>
<p>当一个 generator 或 coroutine 被关闭时将被引发；见 <code>generator.close()</code> 和 <code>coroutine.close()</code>。 它直接继承自 <code>BaseException</code> 而不是 <code>Exception</code>，因为从技术上来说它并不是一个错误。</p>
<ul>
<li><em>exception</em> <code>ImportError</code></li>
</ul>
<p>当 <code>import</code> 语句尝试加载模块遇到麻烦时将被引发。 并且当 <code>from ... import</code> 中的 “from list” 存在无法找到的名称时也会被引发。</p>
<p><code>name</code> 与 <code>path</code> 属性可通过对构造器使用仅关键字参数来设定。 设定后它们将分别表示被尝试导入的模块名称与触发异常的任意文件所在路径。</p>
<p>在 3.3 版更改: 添加了 <code>name</code> 与 <code>path</code> 属性。</p>
<ul>
<li><em>exception</em> <code>ModuleNotFoundError</code></li>
</ul>
<p><code>ImportError</code> 的子类，当一个模块无法被定位时将由 <code>import</code> 引发。 当在 <code>sys.modules</code> 中找到 <code>None</code> 时也会被引发。</p>
<p>3.6 新版功能.</p>
<ul>
<li><em>exception</em> <code>IndexError</code></li>
</ul>
<p>当序列抽取超出范围时将被引发。 （切片索引会被静默截短到允许的范围；如果指定索引不是整数则 <code>TypeError</code> 会被引发。）</p>
<ul>
<li><em>exception</em> <code>KeyError</code></li>
</ul>
<p>当在现有键集合中找不到指定的映射（字典）键时将被引发。</p>
<ul>
<li><em>exception</em> <code>KeyboardInterrupt</code></li>
</ul>
<p>当用户按下中断键 (通常为 Control-C 或 Delete) 时将被引发。 在执行期间，会定期检测中断信号。 该异常继承自 <code>BaseException</code> 以确保不会被处理 <code>Exception</code> 的代码意外捕获，这样可以避免退出解释器。</p>
<ul>
<li><em>exception</em> <code>MemoryError</code></li>
</ul>
<p>当一个操作耗尽内存但情况仍可（通过删除一些对象）进行挽救时将被引发。 关联的值是一个字符串，指明是哪种（内部）操作耗尽了内存。 请注意由于底层的内存管理架构（C 的 <code>malloc()</code> 函数），解释器也许并不总是能够从这种情况下完全恢复；但它毕竟可以引发一个异常，这样就能打印出栈回溯信息，以便找出导致问题的失控程序。</p>
<ul>
<li><em>exception</em> <code>NameError</code></li>
</ul>
<p>当某个局部或全局名称未找到时将被引发。 此异常仅用于非限定名称。 关联的值是一条错误信息，其中包含未找到的名称。</p>
<p><code>name</code> 属性可以使用构造器的仅限关键字参数来设置。 它如果被设置则代表要尝试访问的变量名称。</p>
<p>在 3.10 版更改: 增加了 <code>name</code> 属性。</p>
<ul>
<li><em>exception</em> <code>NotImplementedError</code></li>
</ul>
<p>此异常派生自 <code>RuntimeError</code>。 在用户自定义的基类中，抽象方法应当在其要求所派生类重载该方法，或是在其要求所开发的类提示具体实现尚待添加时引发此异常。</p>
<p>注解</p>
<p>它不应当用来表示一个运算符或方法根本不能被支持 — 在此情况下应当让特定运算符 / 方法保持未定义，或者在子类中将其设为 <code>None</code>。</p>
<p>注解</p>
<p><code>NotImplementedError</code> 和 <code>NotImplemented</code> 不可互换，即使它们有相似的名称和用途。 </p>
<ul>
<li><p><em>exception</em> <code>OSError</code>([<em>arg</em>])</p>
</li>
<li><p><em>exception</em> <code>OSError</code>(<em>errno</em>, <em>strerror</em>[, <em>filename</em>[, <em>winerror</em>[, <em>filename2</em>]]])</p>
<p>此异常在一个系统函数返回系统相关的错误时将被引发，此类错误包括 I/O 操作失败例如 “文件未找到” 或 “磁盘已满” 等（不包括非法参数类型或其他偶然性错误）。</p>
<p>构造器的第二种形式可设置如下所述的相应属性。 如果未指定这些属性则默认为 <code>None</code>。 为了能向下兼容，如果传入了三个参数，则 <code>args</code> 属性将仅包含由前两个构造器参数组成的 2 元组。</p>
<p>构造器实际返回的往往是 <code>OSError</code> 的某个子类，如下文 OS exceptions 中所描述的。 具体的子类取决于最终的 <code>errno</code> 值。 此行为仅在直接或通过别名来构造 <code>OSError</code> 时发生，并且在子类化时不会被继承。</p>
<ul>
<li><p><code>errno</code></p>
<p>来自于 C 变量 <code>errno</code> 的数字错误码。</p>
</li>
<li><p><code>winerror</code></p>
<p>在 Windows 下，此参数将给出原生的 Windows 错误码。 而 <code>errno</code> 属性将是该原生错误码在 POSIX 平台下的近似转换形式。</p>
<p>在 Windows 下，如果 <em>winerror</em> 构造器参数是一个整数，则 <code>errno</code> 属性会根据 Windows 错误码来确定，而 <em>errno</em> 参数会被忽略。 在其他平台上，<em>winerror</em> 参数会被忽略，并且 <code>winerror</code> 属性将不存在。</p>
</li>
<li><p><code>strerror</code></p>
<p>操作系统所提供的相应错误信息。 它在 POSIX 平台中由 C 函数 <code>perror()</code> 来格式化，在 Windows 中则是由 <code>FormatMessage()</code>。</p>
</li>
<li><p><code>filename</code></p>
<p><code>filename2</code></p>
<p>对于与文件系统路径有关 (例如 <code>open()</code> 或 <code>os.unlink()</code>) 的异常，<code>filename</code> 是传给函数的文件名。 对于涉及两个文件系统路径的函数 (例如 <code>os.rename()</code>)，<code>filename2</code> 将是传给函数的第二个文件名。</p>
</li>
</ul>
</li>
</ul>
<p>在 3.3 版更改: <code>EnvironmentError</code>, <code>IOError</code>, <code>WindowsError</code>, <code>socket.error</code>, <code>select.error</code> 与 <code>mmap.error</code> 已被合并到 <code>OSError</code>，构造器可能返回其中一个子类。</p>
<p>在 3.4 版更改: <code>filename</code> 属性现在是传给函数的原始文件名，而不是基于 filesystem encoding and error handler 进行编码或解码之后的名称。 此外，还添加了 <em>filename2</em> 构造器参数和属性。</p>
<ul>
<li><em>exception</em> <code>OverflowError</code></li>
</ul>
<p>当算术运算的结果大到无法表示时将被引发。 这对整数来说不可能发生（宁可引发 <code>MemoryError</code> 也不会放弃尝试）。 但是出于历史原因，有时也会在整数超出要求范围的情况下引发 OverflowError。 因为在 C 中缺少对浮点异常处理的标准化，大多数浮点运算都不会做检查。</p>
<ul>
<li><em>exception</em> <code>RecursionError</code></li>
</ul>
<p>此异常派生自 <code>RuntimeError</code>。 它会在解释器检测发现超过最大递归深度 时被引发。</p>
<p>3.5 新版功能: 在此之前将只引发 <code>RuntimeError</code>。</p>
<ul>
<li><em>exception</em> <code>ReferenceError</code></li>
</ul>
<p>此异常将在使用 <code>weakref.proxy()</code> 函数所创建的弱引用来访问该引用的某个已被作为垃圾回收的属性时被引发。 </p>
<ul>
<li><em>exception</em> <code>RuntimeError</code></li>
</ul>
<p>当检测到一个不归属于任何其他类别的错误时将被引发。 关联的值是一个指明究竟发生了什么问题的字符串。</p>
<ul>
<li><em>exception</em> <code>StopIteration</code></li>
</ul>
<p>由内置函数 <code>next()</code> 和 iterator 的 <code>__next__()</code> 方法所引发，用来表示该迭代器不能产生下一项。</p>
<p>该异常对象只有一个属性 <code>value</code>，它在构造该异常时作为参数给出，默认值为 <code>None</code>。</p>
<p>当一个 generator 或 coroutine 函数返回时，将引发一个新的 <code>StopIteration</code> 实例，函数返回的值将被用作异常构造器的 <code>value</code> 形参。</p>
<p>如果某个生成器代码直接或间接地引发了 <code>StopIteration</code>，它会被转换为 <code>RuntimeError</code> (并将 <code>StopIteration</code> 保留为导致新异常的原因)。</p>
<p>在 3.3 版更改: 添加了 <code>value</code> 属性及其被生成器函数用作返回值的功能。</p>
<p>在 3.5 版更改: 引入了通过 <code>from __future__ import generator_stop</code> 来实现 RuntimeError 转换，参见 <a href="https://www.python.org/dev/peps/pep-0479" target="_blank" rel="noopener"><strong>PEP 479</strong></a>。</p>
<p>在 3.7 版更改: 默认对所有代码启用 <a href="https://www.python.org/dev/peps/pep-0479" target="_blank" rel="noopener"><strong>PEP 479</strong></a>: 在生成器中引发的 <code>StopIteration</code> 错误将被转换为 <code>RuntimeError</code>。</p>
<ul>
<li><em>exception</em> <code>StopAsyncIteration</code></li>
</ul>
<p>必须由一个 asynchronous iterator 对象的 <code>__anext__()</code> 方法来引发以停止迭代操作。</p>
<p>3.5 新版功能.</p>
<ul>
<li><p><em>exception</em> <code>SyntaxError</code>(<em>message</em>, <em>details</em>)</p>
<p>当解析器遇到语法错误时引发。 这可以发生在 <code>import</code> 语句，对内置函数 <code>compile()</code>, <code>exec()</code> 或 <code>eval()</code> 的调用，或是读取原始脚本或标准输入（也包括交互模式）的时候。</p>
<p>异常实例的 <code>str()</code> 只返回错误消息。 错误详情为一个元组，其成员也可在单独的属性中分别获取。</p>
<ul>
<li><p><code>filename</code></p>
<p>发生语法错误所在文件的名称。</p>
</li>
<li><p><code>lineno</code></p>
<p>发生错误所在文件中的行号。 行号索引从 1 开始：文件中首行的 <code>lineno</code> 为 1。</p>
</li>
<li><p><code>offset</code></p>
<p>发生错误所在文件中的列号。 列号索引从 1 开始：行中首个字符的 <code>offset</code> 为 1。</p>
</li>
<li><p><code>text</code></p>
<p>错误所涉及的源代码文本。</p>
</li>
<li><p><code>end_lineno</code></p>
<p>发生的错误在文件中的末尾行号。 这个索引是从 1 开始的：文件中首行的 <code>lineno</code> 为 1。</p>
</li>
<li><p><code>end_offset</code></p>
<p>发生的错误在文件中的末尾列号。 这个索引是从 1 开始：行中首个字符的 <code>offset</code> 为 1。</p>
</li>
</ul>
</li>
</ul>
<p>对于 f-字符串字段中的错误，消息会带有 “f-string: “ 前缀并且其位置是基于替换表达式构建的文本中的位置。 例如，编译 f’Bad {a b} field’ 将产生这样的 args 属性: (‘f-string: …’, (‘’, 1, 2, ‘(a b)n’, 1, 5))。</p>
<p>在 3.10 版更改: 增加了 <code>end_lineno</code> 和 <code>end_offset</code> 属性。</p>
<ul>
<li><em>exception</em> <code>IndentationError</code></li>
</ul>
<p>与不正确的缩进相关的语法错误的基类。 这是 <code>SyntaxError</code> 的一个子类。</p>
<ul>
<li><em>exception</em> <code>TabError</code></li>
</ul>
<p>当缩进包含对制表符和空格符不一致的使用时将被引发。 这是 <code>IndentationError</code> 的一个子类。</p>
<ul>
<li><em>exception</em> <code>SystemError</code></li>
</ul>
<p>当解释器发现内部错误，但情况看起来尚未严重到要放弃所有希望时将被引发。 关联的值是一个指明发生了什么问题的字符串（表示为低层级的符号）。</p>
<p>你应当将此问题报告给你所用 Python 解释器的作者或维护人员。 请确认报告 Python 解释器的版本号 (<code>sys.version</code>; 它也会在交互式 Python 会话开始时被打印出来)，具体的错误消息（异常所关联的值）以及可能触发该错误的程序源码。</p>
<ul>
<li><em>exception</em> <code>SystemExit</code></li>
</ul>
<p>此异常由 <code>sys.exit()</code> 函数引发。 它继承自 <code>BaseException</code> 而不是 <code>Exception</code> 以确保不会被处理 <code>Exception</code> 的代码意外捕获。 这允许此异常正确地向上传播并导致解释器退出。 如果它未被处理，则 Python 解释器就将退出；不会打印任何栈回溯信息。 构造器接受的可选参数与传递给 <code>sys.exit()</code> 的相同。 如果该值为一个整数，则它指明系统退出状态码（会传递给 C 的 <code>exit()</code> 函数）；如果该值为 <code>None</code>，则退出状态码为零；如果该值为其他类型（例如字符串），则会打印对象的值并将退出状态码设为一。</p>
<p>对 <code>sys.exit()</code> 的调用会被转换为一个异常以便能执行清理处理程序 (<code>try</code> 语句的 <code>finally</code> 子句)，并且使得调试器可以执行一段脚本而不必冒失去控制的风险。 如果绝对确实地需要立即退出（例如在调用 <code>os.fork()</code> 之后的子进程中）则可使用 <code>os._exit()</code>.</p>
<p>​    <code>code</code></p>
<p>​    传给构造器的退出状态码或错误信息（默认为 <code>None</code>。）</p>
<ul>
<li><em>exception</em> <code>TypeError</code></li>
</ul>
<p>当一个操作或函数被应用于类型不适当的对象时将被引发。 关联的值是一个字符串，给出有关类型不匹配的详情。</p>
<p>此异常可以由用户代码引发，以表明尝试对某个对象进行的操作不受支持也不应当受支持。 如果某个对象应当支持给定的操作但尚未提供相应的实现，所要引发的适当异常应为 <code>NotImplementedError</code>。</p>
<p>传入参数的类型错误 (例如在要求 <code>int</code> 时却传入了 <code>list</code>) 应当导致 <code>TypeError</code>，但传入参数的值错误 (例如传入要求范围之外的数值) 则应当导致 <code>ValueError</code>。</p>
<ul>
<li><em>exception</em> <code>UnboundLocalError</code></li>
</ul>
<p>当在函数或方法中对某个局部变量进行引用，但该变量并未绑定任何值时将被引发。 此异常是 <code>NameError</code> 的一个子类。</p>
<ul>
<li><p><em>exception</em> <code>UnicodeError</code></p>
<p>当发生与 Unicode 相关的编码或解码错误时将被引发。 此异常是 <code>ValueError</code> 的一个子类。</p>
<p><code>UnicodeError</code> 具有一些描述编码或解码错误的属性。 例如 <code>err.object[err.start:err.end]</code> 会给出导致编解码器失败的特定无效输入。</p>
<ul>
<li><p><code>encoding</code></p>
<p>引发错误的编码名称。</p>
</li>
<li><p><code>reason</code></p>
<p>描述特定编解码器错误的字符串。</p>
</li>
<li><p><code>object</code></p>
<p>编解码器试图要编码或解码的对象。</p>
</li>
<li><p><code>start</code></p>
<p><code>object</code> 中无效数据的开始位置索引。</p>
</li>
<li><p><code>end</code></p>
<p><code>object</code> 中无效数据的末尾位置索引（不含）。</p>
</li>
</ul>
</li>
<li><p><em>exception</em> <code>UnicodeEncodeError</code></p>
</li>
</ul>
<p>当在编码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <code>UnicodeError</code> 的一个子类。</p>
<ul>
<li><em>exception</em> <code>UnicodeDecodeError</code></li>
</ul>
<p>当在解码过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <code>UnicodeError</code> 的一个子类。</p>
<ul>
<li><em>exception</em> <code>UnicodeTranslateError</code></li>
</ul>
<p>在转写过程中发生与 Unicode 相关的错误时将被引发。 此异常是 <code>UnicodeError</code> 的一个子类。</p>
<ul>
<li><em>exception</em> <code>ValueError</code></li>
</ul>
<p>当操作或函数接收到具有正确类型但值不适合的参数，并且情况不能用更精确的异常例如 <code>IndexError</code> 来描述时将被引发。</p>
<ul>
<li><em>exception</em> <code>ZeroDivisionError</code></li>
</ul>
<p>当除法或取余运算的第二个参数为零时将被引发。 关联的值是一个字符串，指明操作数和运算的类型。</p>
<p>下列异常被保留以与之前的版本相兼容；从 Python 3.3 开始，它们都是 <code>OSError</code> 的别名。</p>
<ul>
<li><p><em>exception</em> <code>EnvironmentError</code></p>
</li>
<li><p><em>exception</em> <code>IOError</code></p>
</li>
<li><p><em>exception</em> <code>WindowsError</code></p>
</li>
</ul>
<p>限在 Windows 中可用。</p>
<h3 id="OS-异常"><a href="#OS-异常" class="headerlink" title="OS 异常"></a>OS 异常</h3><p>下列异常均为 <code>OSError</code> 的子类，它们将根据系统错误代码被引发。</p>
<ul>
<li><em>exception</em> <code>BlockingIOError</code></li>
</ul>
<p>当一个操作会被某个设置为非阻塞操作的对象（例如套接字）所阻塞时将被引发。 对应于 <code>errno</code> <code>EAGAIN</code>, <code>EALREADY</code>, <code>EWOULDBLOCK</code> 和 <code>EINPROGRESS</code>。</p>
<p>除了 <code>OSError</code> 已有的属性，<code>BlockingIOError</code> 还有一个额外属性：</p>
<ul>
<li><p><code>characters_written</code></p>
<p>一个整数，表示在被阻塞前已写入到流的字符数。 当使用来自 <code>io</code> 模块的带缓冲 I/O 类时此属性可用。</p>
</li>
<li><p><em>exception</em> <code>ChildProcessError</code></p>
</li>
</ul>
<p>当一个子进程上的操作失败时将被引发。 对应于 <code>errno</code> <code>ECHILD</code>。</p>
<ul>
<li><em>exception</em> <code>ConnectionError</code></li>
</ul>
<p>与连接相关问题的基类。</p>
<p>其子类有 <code>BrokenPipeError</code>, <code>ConnectionAbortedError</code>, <code>ConnectionRefusedError</code> 和 <code>ConnectionResetError</code>。</p>
<ul>
<li><em>exception</em> <code>BrokenPipeError</code></li>
</ul>
<p><code>ConnectionError</code> 的子类，当试图写入另一端已被关闭的管道，或是试图写入已关闭写入的套接字时将被引发。 对应于 <code>errno</code> <code>EPIPE</code> 和 <code>ESHUTDOWN</code>。</p>
<ul>
<li><em>exception</em> <code>ConnectionAbortedError</code></li>
</ul>
<p><code>ConnectionError</code> 的子类，当连接尝试被对端中止时将被引发。 对应于 <code>errno</code> <code>ECONNABORTED</code>。</p>
<ul>
<li><em>exception</em> <code>ConnectionRefusedError</code></li>
</ul>
<p><code>ConnectionError</code> 的子类，当连接尝试被对端拒绝时将被引发。 对应于 <code>errno</code> <code>ECONNREFUSED</code>。</p>
<ul>
<li><em>exception</em> <code>ConnectionResetError</code></li>
</ul>
<p><code>ConnectionError</code> 的子类，当连接被对端重置时将被引发。 对应于 <code>errno</code> <code>ECONNRESET</code>。</p>
<ul>
<li><em>exception</em> <code>FileExistsError</code></li>
</ul>
<p>当试图创建一个已存在的文件或目录时将被引发。 对应于 <code>errno</code> <code>EEXIST</code>。</p>
<ul>
<li><em>exception</em> <code>FileNotFoundError</code></li>
</ul>
<p>当所请求的文件或目录不存在时将被引发。 对应于 <code>errno</code> <code>ENOENT</code>。</p>
<ul>
<li><em>exception</em> <code>InterruptedError</code></li>
</ul>
<p>当系统调用被输入信号中断时将被引发。 对应于 <code>errno</code> <code>EINTR</code>。</p>
<p>在 3.5 版更改: 当系统调用被某个信号中断时，Python 现在会重试系统调用，除非该信号的处理程序引发了其它异常 (原理参见 <a href="https://www.python.org/dev/peps/pep-0475" target="_blank" rel="noopener"><strong>PEP 475</strong></a>) 而不是引发 <code>InterruptedError</code>。</p>
<ul>
<li><em>exception</em> <code>IsADirectoryError</code></li>
</ul>
<p>当请求对一个目录执行文件操作 (例如 <code>os.remove()</code>) 将被引发。 对应于 <code>errno</code> <code>EISDIR</code>。</p>
<ul>
<li><em>exception</em> <code>NotADirectoryError</code></li>
</ul>
<p>当在非目录上请求目录操作 (例如 <code>os.listdir()</code>) 时被引发。 在大多数 POSIX 平台上，它还可能在某个操作尝试以目录方式打开或遍历非目录时被引发。 对应于 <code>errno</code> <code>ENOTDIR</code>。</p>
<ul>
<li><em>exception</em> <code>PermissionError</code></li>
</ul>
<p>当在没有足够操作权限的情况下试图执行某个操作时将被引发 —— 例如缺少文件系统权限。 对应于 <code>errno</code> <code>EACCES</code> 和 <code>EPERM</code>。</p>
<ul>
<li><em>exception</em> <code>ProcessLookupError</code></li>
</ul>
<p>当给定的进程不存在时将被引发。 对应于 <code>errno</code> <code>ESRCH</code>。</p>
<ul>
<li><em>exception</em> <code>TimeoutError</code></li>
</ul>
<p>当一个系统函数发生系统级超时的情况下将被引发。 对应于 <code>errno</code> <code>ETIMEDOUT</code>。</p>
<p>3.3 新版功能: 添加了以上所有 <code>OSError</code> 的子类。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-3151" target="_blank" rel="noopener"><strong>PEP 3151</strong></a> - 重写 OS 和 IO 异常的层次结构</p>
<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>下列异常被用作警告类别</p>
<ul>
<li><em>exception</em> <code>Warning</code></li>
</ul>
<p>警告类别的基类。</p>
<ul>
<li><em>exception</em> <code>UserWarning</code></li>
</ul>
<p>用户代码所产生警告的基类。</p>
<ul>
<li><em>exception</em> <code>DeprecationWarning</code></li>
</ul>
<p>如果所发出的警告是针对其他 Python 开发者的，则以此作为与已弃用特性相关警告的基类。</p>
<p>会被默认警告过滤器忽略，在 <code>__main__</code> 模块中的情况除外 (<a href="https://www.python.org/dev/peps/pep-0565" target="_blank" rel="noopener"><strong>PEP 565</strong></a>)。 启用 Python 开发模式 时会显示此警告。</p>
<p>The deprecation policy is described in <a href="https://www.python.org/dev/peps/pep-0387" target="_blank" rel="noopener"><strong>PEP 387</strong></a>.</p>
<ul>
<li><em>exception</em> <code>PendingDeprecationWarning</code></li>
</ul>
<p>对于已过时并预计在未来弃用，但目前尚未弃用的特性相关警告的基类。</p>
<p>这个类很少被使用，因为针对未来可能的弃用发出警告的做法并不常见，而针对当前已有的弃用则推荐使用 <code>DeprecationWarning</code>。</p>
<p>会被默认警告过滤器忽略。 启用 Python 开发模式 时会显示此警告。</p>
<p>The deprecation policy is described in <a href="https://www.python.org/dev/peps/pep-0387" target="_blank" rel="noopener"><strong>PEP 387</strong></a>.</p>
<ul>
<li><em>exception</em> <code>SyntaxWarning</code></li>
</ul>
<p>与模糊的语法相关的警告的基类。</p>
<ul>
<li><em>exception</em> <code>RuntimeWarning</code></li>
</ul>
<p>与模糊的运行时行为相关的警告的基类。</p>
<ul>
<li><em>exception</em> <code>FutureWarning</code></li>
</ul>
<p>如果所发出的警告是针对以 Python 所编写应用的最终用户的，则以此作为与已弃用特性相关警告的基类。</p>
<ul>
<li><em>exception</em> <code>ImportWarning</code></li>
</ul>
<p>与在模块导入中可能的错误相关的警告的基类。</p>
<p>会被默认警告过滤器忽略。 启用 Python 开发模式 时会显示此警告。</p>
<ul>
<li><em>exception</em> <code>UnicodeWarning</code></li>
</ul>
<p>与 Unicode 相关的警告的基类。</p>
<ul>
<li><em>exception</em> <code>EncodingWarning</code></li>
</ul>
<p>与编码格式相关的警告的基类。</p>
<p>3.10 新版功能.</p>
<ul>
<li><em>exception</em> <code>BytesWarning</code></li>
</ul>
<p>与 <code>bytes</code> 和 <code>bytearray</code> 相关的警告的基类。</p>
<ul>
<li><em>exception</em> <code>ResourceWarning</code></li>
</ul>
<p>资源使用相关警告的基类。</p>
<p>会被默认警告过滤器忽略。 启用 Python 开发模式 时会显示此警告。</p>
<p>3.2 新版功能.</p>
<h2 id="异常层次结构"><a href="#异常层次结构" class="headerlink" title="异常层次结构"></a>异常层次结构</h2><p>内置异常的类层级结构如下：</p>
<pre><code>BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
      |    +-- ModuleNotFoundError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      |    +-- RecursionError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- EncodingWarning
           +-- ResourceWarning</code></pre><h1 id="文本处理服务"><a href="#文本处理服务" class="headerlink" title="文本处理服务"></a>文本处理服务</h1><p>在 二进制数据服务 之下描述的 <code>codecs</code> 模块也与文本处理高度相关。</p>
<ul>
<li><code>string</code> —- 常见的字符串操作<ul>
<li>字符串常量</li>
<li>自定义字符串格式化</li>
<li>格式字符串语法<ul>
<li>格式规格迷你语言</li>
<li>格式示例</li>
</ul>
</li>
<li>模板字符串</li>
<li>辅助函数</li>
</ul>
</li>
<li><code>re</code> —- 正则表达式操作<ul>
<li>正则表达式语法</li>
<li>模块内容</li>
<li>正则表达式对象 （正则对象）</li>
<li>匹配对象</li>
<li>正则表达式例子<ul>
<li>检查对子</li>
<li>模拟 scanf()</li>
<li>search() vs. match()</li>
<li>制作一个电话本</li>
<li>文字整理</li>
<li>查找所有副词</li>
<li>查找所有的副词及其位置</li>
<li>原始字符串标记</li>
<li>写一个词法分析器</li>
</ul>
</li>
</ul>
</li>
<li><code>difflib</code> —- 计算差异的辅助工具<ul>
<li>SequenceMatcher 对象</li>
<li>SequenceMatcher 的示例</li>
<li>Differ 对象</li>
<li>Differ 示例</li>
<li>difflib 的命令行接口</li>
</ul>
</li>
<li><code>textwrap</code> —- 文本自动换行与填充</li>
<li><code>unicodedata</code> —- Unicode 数据库</li>
<li><code>stringprep</code> —- 因特网字符串预备</li>
<li><code>readline</code> —- GNU readline 接口<ul>
<li>初始化文件</li>
<li>行缓冲区</li>
<li>历史文件</li>
<li>历史列表</li>
<li>启动钩子</li>
<li>Completion</li>
<li>示例</li>
</ul>
</li>
<li><code>rlcompleter</code> —- GNU readline 的补全函数<ul>
<li>Completer 对象</li>
</ul>
</li>
</ul>
<h2 id="string-—-常见的字符串操作"><a href="#string-—-常见的字符串操作" class="headerlink" title="string —- 常见的字符串操作"></a><code>string</code> —- 常见的字符串操作</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/string.py" target="_blank" rel="noopener">Lib/string.py</a></p>
<h3 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h3><p>此模块中定义的常量为：</p>
<pre><code>string.ascii_letters</code></pre><p>下文所述 <code>ascii_lowercase</code> 和 <code>ascii_uppercase</code> 常量的拼连。 该值不依赖于语言区域。</p>
<pre><code>string.ascii_lowercase</code></pre><p>小写字母 <code>'abcdefghijklmnopqrstuvwxyz'</code>。 该值不依赖于语言区域，不会发生改变。</p>
<pre><code>string.ascii_uppercase</code></pre><p>大写字母 <code>'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</code>。 该值不依赖于语言区域，不会发生改变。</p>
<pre><code>string.digits</code></pre><p>字符串 <code>'0123456789'</code>。</p>
<pre><code>string.hexdigits</code></pre><p>字符串 <code>'0123456789abcdefABCDEF'</code>。</p>
<pre><code>string.octdigits</code></pre><p>字符串 <code>'01234567'</code>。</p>
<pre><code>string.punctuation</code></pre><p>由在 <code>C</code> 区域设置中被视为标点符号的 ASCII 字符所组成的字符串: <code>!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_</code>{|}~`.</p>
<pre><code>string.printable</code></pre><p>由被视为可打印符号的 ASCII 字符组成的字符串。 这是 <code>digits</code>, <code>ascii_letters</code>, <code>punctuation</code> 和 <code>whitespace</code> 的总和。</p>
<pre><code>string.whitespace</code></pre><p>由被视为空白符号的 ASCII 字符组成的字符串。 其中包括空格、制表、换行、回车、进纸和纵向制表符。</p>
<h3 id="自定义字符串格式化"><a href="#自定义字符串格式化" class="headerlink" title="自定义字符串格式化"></a>自定义字符串格式化</h3><p>内置的字符串类提供了通过使用 <a href="https://www.python.org/dev/peps/pep-3101" target="_blank" rel="noopener"><strong>PEP 3101</strong></a> 所描述的 <code>format()</code> 方法进行复杂变量替换和值格式化的能力。 <code>string</code> 模块中的 <code>Formatter</code> 类允许你使用与内置 <code>format()</code> 方法相同的实现来创建并定制你自己的字符串格式化行为。</p>
<p><em>class</em> <code>string.Formatter</code></p>
<p><code>Formatter</code> 类包含下列公有方法：</p>
<ul>
<li><p><code>format</code>(<em>format_string</em>, <em>/</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>首要的 API 方法。 它接受一个格式字符串和任意一组位置和关键字参数。 它只是一个调用 <code>vformat()</code> 的包装器。</p>
<p>在 3.7 版更改: 格式字符串参数现在是 仅限位置参数。</p>
</li>
<li><p><code>vformat</code>(<em>format_string</em>, <em>args</em>, <em>kwargs</em>)</p>
<p>此函数执行实际的格式化操作。 它被公开为一个单独的函数，用于需要传入一个预定义字母作为参数，而不是使用 <code>*args</code> 和 <code>**kwargs</code> 语法将字典解包为多个单独参数并重打包的情况。 <code>vformat()</code> 完成将格式字符串分解为字符数据和替换字段的工作。 它会调用下文所述的几种不同方法。</p>
</li>
</ul>
<p>此外，<code>Formatter</code> 还定义了一些旨在被子类替换的方法：</p>
<ul>
<li><p><code>parse</code>(<em>format_string</em>)</p>
<p>循环遍历 format_string 并返回一个由可迭代对象组成的元组 (<em>literal_text</em>, <em>field_name</em>, <em>format_spec</em>, <em>conversion</em>)。 它会被 <code>vformat()</code> 用来将字符串分解为文本字面值或替换字段。</p>
<p>元组中的值在概念上表示一段字面文本加上一个替换字段。 如果没有字面文本（如果连续出现两个替换字段就会发生这种情况），则 <em>literal_text</em> 将是一个长度为零的字符串。 如果没有替换字段，则 <em>field_name</em>, <em>format_spec</em> 和 <em>conversion</em> 的值将为 <code>None</code>。</p>
</li>
<li><p><code>get_field</code>(<em>field_name</em>, <em>args</em>, <em>kwargs</em>)</p>
<p>给定 <em>field_name</em> 作为 <code>parse()</code> (见上文) 的返回值，将其转换为要格式化的对象。 返回一个元组 (obj, used_key)。 默认版本接受在 <a href="https://www.python.org/dev/peps/pep-3101" target="_blank" rel="noopener"><strong>PEP 3101</strong></a> 所定义形式的字符串，例如 “0[name]“ 或 “label.title”。 <em>args</em> 和 <em>kwargs</em> 与传给 <code>vformat()</code> 的一样。 返回值 <em>used_key</em> 与 <code>get_value()</code> 的 <em>key</em> 形参具有相同的含义。</p>
</li>
<li><p><code>get_value</code>(<em>key</em>, <em>args</em>, <em>kwargs</em>)</p>
<p>提取给定的字段值。 <em>key</em> 参数将为整数或字符串。 如果是整数，它表示 <em>args</em> 中位置参数的索引；如果是字符串，它表示 <em>kwargs</em> 中的关键字参数名。</p>
<p><em>args</em> 形参会被设为 <code>vformat()</code> 的位置参数列表，而 <em>kwargs</em> 形参会被设为由关键字参数组成的字典。</p>
<p>对于复合字段名称，仅会为字段名称的第一个组件调用这些函数；后续组件会通过普通属性和索引操作来进行处理。</p>
<p>因此举例来说，字段表达式 ‘0.name’ 将导致调用 <code>get_value()</code> 时附带 <em>key</em> 参数值 0。 在 <code>get_value()</code> 通过调用内置的 <code>getattr()</code> 函数返回后将会查找 <code>name</code> 属性。</p>
<p>如果索引或关键字引用了一个不存在的项，则将引发 <code>IndexError</code> 或 <code>KeyError</code>。</p>
</li>
<li><p><code>check_unused_args</code>(<em>used_args</em>, <em>args</em>, <em>kwargs</em>)</p>
<p>在必要时实现对未使用参数进行检测。 此函数的参数是是格式字符串中实际引用的所有参数键的集合（整数表示位置参数，字符串表示名称参数），以及被传给 vformat 的 <em>args</em> 和 <em>kwargs</em> 的引用。 未使用参数的集合可以根据这些形参计算出来。 如果检测失败则 <code>check_unused_args()</code> 应会引发一个异常。</p>
</li>
<li><p><code>format_field</code>(<em>value</em>, <em>format_spec</em>)</p>
<p><code>format_field()</code> 会简单地调用内置全局函数 <code>format()</code>。 提供该方法是为了让子类能够重载它。</p>
</li>
<li><p><code>convert_field</code>(<em>value</em>, <em>conversion</em>)</p>
<p>使用给定的转换类型（来自 <code>parse()</code> 方法所返回的元组）来转换（由 <code>get_field()</code> 所返回的）值。 默认版本支持 ‘s’ (str), ‘r’ (repr) 和 ‘a’ (ascii) 等转换类型。</p>
</li>
</ul>
<h3 id="格式字符串语法"><a href="#格式字符串语法" class="headerlink" title="格式字符串语法"></a>格式字符串语法</h3><p><code>str.format()</code> 方法和 <code>Formatter</code> 类共享相同的格式字符串语法（虽然对于 <code>Formatter</code> 来说，其子类可以定义它们自己的格式字符串语法）。 具体语法与 格式化字符串字面值 相似，但较为简单一些，并且关键的一点是不支持任意表达式。</p>
<p>格式字符串包含有以花括号 <code>{}</code> 括起来的“替换字段”。 不在花括号之内的内容被视为字面文本，会不加修改地复制到输出中。 如果你需要在字面文本中包含花括号字符，可以通过重复来转义: <code>{{` and `}}</code>。</p>
<p>替换字段的语法如下：</p>
<blockquote>
<pre><code>replacement_field ::=  "{" [field_name] ["!" conversion] [":" format_spec] "}"
field_name        ::=  arg_name ("." attribute_name | "[" element_index "]")*
arg_name          ::=  [identifier | digit+]
attribute_name    ::=  identifier
element_index     ::=  digit+ | index_string
index_string      ::=  &lt;any source character except "]"&gt; +
conversion        ::=  "r" | "s" | "a"
format_spec       ::=  &lt;described in the next section&gt;</code></pre></blockquote>
<p>用不太正式的术语来描述，替换字段开头可以用一个 <em>field_name</em> 指定要对值进行格式化并取代替换字符被插入到输出结果的对象。 <em>field_name</em> 之后有可选的 <em>conversion</em> 字段，它是一个感叹号 <code>'!'</code> 加一个 <em>format_spec</em>，并以一个冒号 <code>':'</code> 打头。 这些指明了替换值的非默认格式。</p>
<p><em>field_name</em> 本身以一个数字或关键字 <em>arg_name</em> 打头。 如果为数字，则它指向一个位置参数，而如果为关键字，则它指向一个命名关键字参数。 如果格式字符串中的数字 arg_names 为 0, 1, 2, … 的序列，它们可以全部省略（而非部分省略），数字 0, 1, 2, … 将会按顺序自动插入。 由于 <em>arg_name</em> 不使用引号分隔，因此无法在格式字符串中指定任意的字典键 (例如字符串 <code>'10'</code> 或 <code>':-]'</code>)。 <em>arg_name</em> 之后可以带上任意数量的索引或属性表达式。 <code>'.name'</code> 形式的表达式会使用 <code>getattr()</code> 选择命名属性，而 <code>'[index]'</code> 形式的表达式会使用 <code>__getitem__()</code> 执行索引查找。</p>
<p>在 3.1 版更改: 位置参数说明符对于 <code>str.format()</code> 可以省略，因此 <code>'{} {}'.format(a, b)</code> 等价于 <code>'{0} {1}'.format(a, b)</code>。</p>
<p>在 3.4 版更改: 位置参数说明符对于 <code>Formatter</code> 可以省略。</p>
<p>一些简单的格式字符串示例</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token string">"First, thou shalt count to {0}"</span>  <span class="token comment" spellcheck="true"># References first positional argument</span>
<span class="token string">"Bring me a {}"</span>                   <span class="token comment" spellcheck="true"># Implicitly references the first positional argument</span>
<span class="token string">"From {} to {}"</span>                   <span class="token comment" spellcheck="true"># Same as "From {0} to {1}"</span>
<span class="token string">"My quest is {name}"</span>              <span class="token comment" spellcheck="true"># References keyword argument 'name'</span>
<span class="token string">"Weight in tons {0.weight}"</span>       <span class="token comment" spellcheck="true"># 'weight' attribute of first positional arg</span>
<span class="token string">"Units destroyed: {players[0]}"</span>   <span class="token comment" spellcheck="true"># First element of keyword argument 'players'.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <em>conversion</em> 字段在格式化之前进行类型强制转换。 通常，格式化值的工作由值本身的 <code>__format__()</code> 方法来完成。 但是，在某些情况下最好强制将类型格式化为一个字符串，覆盖其本身的格式化定义。 通过在调用 <code>__format__()</code> 之前将值转换为字符串，可以绕过正常的格式化逻辑。</p>
<p>目前支持的转换旗标有三种: <code>'!s'</code> 会对值调用 <code>str()</code>，<code>'!r'</code> 调用 <code>repr()</code> 而 <code>'!a'</code> 则调用 <code>ascii()</code>。</p>
<p>示例如下：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token string">"Harold's a clever {0!s}"</span>        <span class="token comment" spellcheck="true"># Calls str() on the argument first</span>
<span class="token string">"Bring out the holy {name!r}"</span>    <span class="token comment" spellcheck="true"># Calls repr() on the argument first</span>
<span class="token string">"More {!a}"</span>                      <span class="token comment" spellcheck="true"># Calls ascii() on the argument first</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><em>format_spec</em> 字段包含值应如何呈现的规格描述，例如字段宽度、对齐、填充、小数精度等细节信息。 每种值类型可以定义自己的“格式化迷你语言”或对 <em>format_spec</em> 的解读方式。</p>
<p>大多数内置类型都支持同样的格式化迷你语言，具体描述见下一节。</p>
<p><em>format_spec</em> 字段还可以在其内部包含嵌套的替换字段。 这些嵌套的替换字段可能包括字段名称、转换旗标和格式规格描述，但是不再允许更深层的嵌套。 format_spec 内部的替换字段会在解读 <em>format_spec</em> 字符串之前先被解读。 这将允许动态地指定特定值的格式。</p>
<h4 id="格式规格迷你语言"><a href="#格式规格迷你语言" class="headerlink" title="格式规格迷你语言"></a>格式规格迷你语言</h4><p>“格式规格”在格式字符串所包含的替换字段内部使用，用于定义单个值应如何呈现 。 它们也可以被直接传给内置的 <code>format()</code> 函数。 每种可格式化的类型都可以自行定义如何对格式规格进行解读。</p>
<p>大多数内置类型都为格式规格实现了下列选项，不过某些格式化选项只被数值类型所支持。</p>
<p>一般约定空的格式描述将产生与在值上调用 <code>str()</code> 相同的结果。 非空格式描述通常会修改此结果。</p>
<p><em>标准格式说明符</em> 的一般形式如下：</p>
<pre><code>format_spec     ::=  [[fill]align][sign][#][0][width][grouping_option][.precision][type]
fill            ::=  &lt;any character&gt;
align           ::=  "&lt;" | "&gt;" | "=" | "^"
sign            ::=  "+" | "-" | " "
width           ::=  digit+
grouping_option ::=  "_" | ","
precision       ::=  digit+
type            ::=  "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%"</code></pre><p>如果指定了一个有效的 <em>align</em> 值，则可以在该值前面加一个 <em>fill</em> 字符，它可以为任意字符，如果省略则默认为空格符。 在 格式化字符串字面值 或在使用 <code>str.format()</code> 方法时是无法使用花括号字面值 (“<code>{</code>“ or “<code>}</code>“) 作为 <em>fill</em> 字符的。 但是，通过嵌套替换字段插入花括号则是可以的。 这个限制不会影响 <code>format()</code> 函数。</p>
<p>各种对齐选项的含义如下：</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘&lt;’</code></td>
<td align="left">强制字段在可用空间内左对齐（这是大多数对象的默认值）。</td>
</tr>
<tr>
<td align="left"><code>‘&gt;’</code></td>
<td align="left">强制字段在可用空间内右对齐（这是数字的默认值）。</td>
</tr>
<tr>
<td align="left"><code>‘=’</code></td>
<td align="left">强制在符号（如果有）之后数码之前放置填充。 这被用于以 ‘+000000120’ 形式打印字段。 这个对齐选项仅对数字类型有效。 这是当 ‘0’ 紧接在字段宽度之前时的默认选项。</td>
</tr>
<tr>
<td align="left"><code>‘^’</code></td>
<td align="left">强制字段在可用空间内居中。</td>
</tr>
</tbody></table>
</blockquote>
<p>请注意，除非定义了最小字段宽度，否则字段宽度将始终与填充它的数据大小相同，因此在这种情况下，对齐选项没有意义。</p>
<p><em>sign</em> 选项仅对数字类型有效，可以是以下之一：</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘+’</code></td>
<td align="left">表示标志应该用于正数和负数。</td>
</tr>
<tr>
<td align="left"><code>‘-‘</code></td>
<td align="left">表示标志应仅用于负数（这是默认行为）。</td>
</tr>
<tr>
<td align="left">space</td>
<td align="left">表示应在正数上使用前导空格，在负数上使用减号。</td>
</tr>
</tbody></table>
</blockquote>
<p><code>'#'</code> 选项可让“替代形式”被用于执行转换。 替代形式会针对不同的类型分别定义。 此选项仅适用于整数、浮点数和复数类型。 对于整数类型，当使用二进制、八进制或十六进制输出时，此选项会为输出值分别添加相应的 <code>'0b'</code>, <code>'0o'</code>, <code>'0x'</code> 或 <code>'0X'</code> 前缀。 对于浮点数和复数类型，替代形式会使得转换结果总是包含小数点符号，即使其不带小数部分。 通常只有在带有小数部分的情况下，此类转换的结果中才会出现小数点符号。 此外，对于 <code>'g'</code> 和 <code>'G'</code> 转换，末尾的零不会从结果中被移除。</p>
<p><code>','</code> 选项表示使用逗号作为千位分隔符。 对于感应区域设置的分隔符，请改用 <code>'n'</code> 整数表示类型。</p>
<p>在 3.1 版更改: 添加了 <code>','</code> 选项 (另请参阅 <a href="https://www.python.org/dev/peps/pep-0378" target="_blank" rel="noopener"><strong>PEP 378</strong></a>)。</p>
<p><code>'_'</code> 选项表示对浮点表示类型和整数表示类型 <code>'d'</code> 使用下划线作为千位分隔符。 对于整数表示类型 <code>'b'</code>, <code>'o'</code>, <code>'x'</code> 和 <code>'X'</code>，将为每 4 个数位插入一个下划线。 对于其他表示类型指定此选项则将导致错误。</p>
<p>在 3.6 版更改: 添加了 <code>'_'</code> 选项 (另请参阅 <a href="https://www.python.org/dev/peps/pep-0515" target="_blank" rel="noopener"><strong>PEP 515</strong></a>)。</p>
<p><em>width</em> 是一个定义最小总字段宽度的十进制整数，包括任何前缀、分隔符和其他格式化字符。 如果未指定，则字段宽度将由内容确定。</p>
<p>当未显式给出对齐方式时，在 <em>width</em> 字段前加一个零 (<code>'0'</code>) 字段将为数字类型启用感知正负号的零填充。 这相当于设置 <em>fill</em> 字符为 <code>'0'</code> 且 <em>alignment</em> 类型为 <code>'='</code>。</p>
<p>在 3.10 版更改: 在 <em>width</em> 字段之前添加 <code>'0'</code> 不会再影响字符串的默认对齐。</p>
<p><em>precision</em> 是一个十进制数字，表示对于以 <code>'f'</code> and <code>'F'</code> 格式化的浮点数值要在小数点后显示多少个数位，或者对于以 <code>'g'</code> 或 <code>'G'</code> 格式化的浮点数值要在小数点前后共显示多少个数位。 对于非数字类型，该字段表示最大字段大小 —— 换句话说就是要使用多少个来自字段内容的字符。 对于整数值则不允许使用 <em>precision</em>。</p>
<p>最后，<em>type</em> 确定了数据应如何呈现。</p>
<p>可用的字符串表示类型是：</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘s’</code></td>
<td align="left">字符串格式。这是字符串的默认类型，可以省略。</td>
</tr>
<tr>
<td align="left">None</td>
<td align="left">和 <code>‘s’</code> 一样。</td>
</tr>
</tbody></table>
</blockquote>
<p>可用的整数表示类型是：</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘b’</code></td>
<td align="left">二进制格式。 输出以 2 为基数的数字。</td>
</tr>
<tr>
<td align="left"><code>‘c’</code></td>
<td align="left">字符。在打印之前将整数转换为相应的unicode字符。</td>
</tr>
<tr>
<td align="left"><code>‘d’</code></td>
<td align="left">十进制整数。 输出以 10 为基数的数字。</td>
</tr>
<tr>
<td align="left"><code>‘o’</code></td>
<td align="left">八进制格式。 输出以 8 为基数的数字。</td>
</tr>
<tr>
<td align="left"><code>‘x’</code></td>
<td align="left">十六进制格式。 输出以 16 为基数的数字，使用小写字母表示 9 以上的数码。</td>
</tr>
<tr>
<td align="left"><code>‘X’</code></td>
<td align="left">十六进制格式。 输出以 16 为基数的数字，使用大写字母表示 9 以上的数码。 在指定 <code>‘#’</code> 的情况下，前缀 <code>‘0x’</code> 也将被转为大写形式 <code>‘0X’</code>。</td>
</tr>
<tr>
<td align="left"><code>‘n’</code></td>
<td align="left">数字。 这与 <code>‘d’</code> 相似，不同之处在于它会使用当前区域设置来插入适当的数字分隔字符。</td>
</tr>
<tr>
<td align="left">None</td>
<td align="left">和 <code>‘d’</code> 相同。</td>
</tr>
</tbody></table>
</blockquote>
<p>在上述的表示类型之外，整数还可以通过下列的浮点表示类型来格式化 (除了 <code>'n'</code> 和 <code>None</code>)。 当这样做时，会在格式化之前使用 <code>float()</code> 将整数转换为浮点数。</p>
<p><code>float</code> 和 <code>Decimal</code> 值的可用表示类型有:</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘e’</code></td>
<td align="left">科学计数法。 对于一个给定的精度 <code>p</code>，将数字格式化为以字母 ‘e’ 分隔系数和指数的科学计数法形式。 系数在小数点之前有一位，之后有 <code>p</code> 位，总计 <code>p + 1</code> 个有效数位。 如未指定精度，则会对 <code>float</code> 采用小数点之后 <code>6</code> 位精度，而对 <code>Decimal</code> 则显示所有系数位。 如果小数点之后没有数位，则小数点也会被略去，除非使用了 <code>#</code> 选项。</td>
</tr>
<tr>
<td align="left"><code>‘E’</code></td>
<td align="left">科学计数法。 与 <code>‘e’</code> 相似，不同之处在于它使用大写字母 ‘E’ 作为分隔字符。</td>
</tr>
<tr>
<td align="left"><code>‘f’</code></td>
<td align="left">定点表示法。 对于一个给定的精度 <code>p</code>，将数字格式化为在小数点之后恰好有 <code>p</code> 位的小数形式。 如未指定精度，则会对 <code>float</code> 采用小数点之后 <code>6</code> 位精度，而对 <code>Decimal</code> 则使用大到足够显示所有系数位的精度。 如果小数点之后没有数位，则小数点也会被略去，除非使用了 <code>#</code> 选项。</td>
</tr>
<tr>
<td align="left"><code>‘F’</code></td>
<td align="left">定点表示。 与 <code>‘f’</code> 相似，但会将 <code>nan</code> 转为 <code>NAN</code> 并将 <code>inf</code> 转为 <code>INF</code>。</td>
</tr>
<tr>
<td align="left"><code>‘g’</code></td>
<td align="left">常规格式。 对于给定精度 <code>p &gt;= 1</code>，这会将数值舍入到 <code>p</code> 个有效数位，再将结果以定点表示法或科学计数法进行格式化，具体取决于其值的大小。 精度 <code>0</code> 会被视为等价于精度 <code>1</code>。准确的规则如下：假设使用表示类型 <code>‘e’</code> 和精度 <code>p-1</code> 进行格式化的结果具有指数值 <code>exp</code>。 那么如果 <code>m &lt;= exp &lt; p</code>，其中 <code>m</code> 以 -4 表示浮点值而以 -6 表示 <code>Decimal</code> 值，该数字将使用类型 <code>‘f’</code> 和精度 <code>p-1-exp</code> 进行格式化。 否则的话，该数字将使用表示类型 <code>‘e’</code> 和精度 <code>p-1</code> 进行格式化。 在两种情况下，都会从有效数字中移除无意义的末尾零，如果小数点之后没有余下数字则小数点也会被移除，除非使用了 <code>‘#’</code> 选项。如未指定精度，会对 <code>float</code> 采用 <code>6</code> 个有效数位的精度。 对于 <code>Decimal</code>，结果的系数会沿用原值的系数数位；对于绝对值小于 <code>1e-6</code> 的值以及最小有效数位的位值大于 1 的数值将会使用科学计数法，在其他情况下则会使用定点表示法。正负无穷，正负零和 nan 会分别被格式化为 <code>inf</code>, <code>-inf</code>, <code>0</code>, <code>-0</code> 和 <code>nan</code>，无论精度如何设定。</td>
</tr>
<tr>
<td align="left"><code>‘G’</code></td>
<td align="left">常规格式。 类似于 <code>‘g’</code>，不同之处在于当数值非常大时会切换为 <code>‘E’</code>。 无穷与 NaN 也会表示为大写形式。</td>
</tr>
<tr>
<td align="left"><code>‘n’</code></td>
<td align="left">数字。 这与 <code>‘g’</code> 相似，不同之处在于它会使用当前区域设置来插入适当的数字分隔字符。</td>
</tr>
<tr>
<td align="left"><code>‘%’</code></td>
<td align="left">百分比。 将数字乘以 100 并显示为定点 (<code>‘f’</code>) 格式，后面带一个百分号。</td>
</tr>
<tr>
<td align="left">None</td>
<td align="left">对于 <code>float</code> 来说这类似于 <code>‘g’</code>，不同之处在于当使用定点表示法时，小数点之后将至少显示一位。 所用的精度会大到足以精确表示给定的值。对于 <code>Decimal</code> 来说这相当于 <code>‘g’</code> 或 <code>‘G’</code>，具体取决于当前 decimal 上下文的 <code>context.capitals</code> 值。总体效果是将 <code>str()</code> 的输出匹配为其他格式化因子所调整出的样子。</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="格式示例"><a href="#格式示例" class="headerlink" title="格式示例"></a>格式示例</h4><p>本节包含 <code>str.format()</code> 语法的示例以及与旧式 <code>%</code> 格式化的比较。</p>
<p>该语法在大多数情况下与旧式的 <code>%</code> 格式化类似，只是增加了 <code>{}</code> 和 <code>:</code> 来取代 <code>%</code>。 例如，，<code>'%03.2f'</code> 可以被改写为 <code>'{:03.2f}'</code>。</p>
<p>新的格式语法还支持新增的不同选项，将在以下示例中说明。</p>
<p>按位置访问参数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{0}, {1}, {2}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span>
<span class="token string">'a, b, c'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{}, {}, {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 3.1+ only</span>
<span class="token string">'a, b, c'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{2}, {1}, {0}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span>
<span class="token string">'c, b, a'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{2}, {1}, {0}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token operator">*</span><span class="token string">'abc'</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># unpacking argument sequence</span>
<span class="token string">'c, b, a'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{0}{1}{0}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'abra'</span><span class="token punctuation">,</span> <span class="token string">'cad'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># arguments' indices can be repeated</span>
<span class="token string">'abracadabra'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>按名称访问参数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Coordinates: {latitude}, {longitude}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>latitude<span class="token operator">=</span><span class="token string">'37.24N'</span><span class="token punctuation">,</span> longitude<span class="token operator">=</span><span class="token string">'-115.81W'</span><span class="token punctuation">)</span>
<span class="token string">'Coordinates: 37.24N, -115.81W'</span>
<span class="token operator">>></span><span class="token operator">></span> coord <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'latitude'</span><span class="token punctuation">:</span> <span class="token string">'37.24N'</span><span class="token punctuation">,</span> <span class="token string">'longitude'</span><span class="token punctuation">:</span> <span class="token string">'-115.81W'</span><span class="token punctuation">}</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Coordinates: {latitude}, {longitude}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token operator">**</span>coord<span class="token punctuation">)</span>
<span class="token string">'Coordinates: 37.24N, -115.81W'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>访问参数的属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token operator">-</span><span class="token number">5j</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token string">'The complex number {0} is formed from the real part {0.real} '</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token string">'and the imaginary part {0.imag}.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>c<span class="token punctuation">)</span>
<span class="token string">'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y <span class="token operator">=</span> x<span class="token punctuation">,</span> y
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> <span class="token string">'Point({self.x}, {self.y})'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>self<span class="token operator">=</span>self<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>Point<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">'Point(4, 2)'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>访问参数的项:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> coord <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'X: {0[0]};  Y: {0[1]}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>coord<span class="token punctuation">)</span>
<span class="token string">'X: 3;  Y: 5'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>替代 <code>%s</code> 和 <code>%r</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">"repr() shows quotes: {!r}; str() doesn't: {!s}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'test1'</span><span class="token punctuation">,</span> <span class="token string">'test2'</span><span class="token punctuation">)</span>
<span class="token string">"repr() shows quotes: 'test1'; str() doesn't: test2"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>对齐文本以及指定宽度:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:&lt;30}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'left aligned'</span><span class="token punctuation">)</span>
<span class="token string">'left aligned                  '</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:>30}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'right aligned'</span><span class="token punctuation">)</span>
<span class="token string">'                 right aligned'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:^30}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'centered'</span><span class="token punctuation">)</span>
<span class="token string">'           centered           '</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:*^30}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token string">'centered'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># use '*' as a fill char</span>
<span class="token string">'***********centered***********'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>替代 <code>%+f</code>, <code>%-f</code> 和 <code>% f</code> 以及指定正负号:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:+f}; {:+f}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.14</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># show it always</span>
<span class="token string">'+3.140000; -3.140000'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{: f}; {: f}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.14</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># show a space for positive numbers</span>
<span class="token string">' 3.140000; -3.140000'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:-f}; {:-f}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.14</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># show only the minus -- same as '{:f}; {:f}'</span>
<span class="token string">'3.140000; -3.140000'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>替代 <code>%x</code> 和 <code>%o</code> 以及转换基于不同进位制的值:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># format also supports binary numbers</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">"int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token string">'int: 42;  hex: 2a;  oct: 52;  bin: 101010'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># with 0x, 0o, or 0b as prefix:</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">"int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token string">'int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用逗号作为千位分隔符:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:,}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token number">1234567890</span><span class="token punctuation">)</span>
<span class="token string">'1,234,567,890'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>表示为百分数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> points <span class="token operator">=</span> <span class="token number">19</span>
<span class="token operator">>></span><span class="token operator">></span> total <span class="token operator">=</span> <span class="token number">22</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'Correct answers: {:.2%}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>points<span class="token operator">/</span>total<span class="token punctuation">)</span>
<span class="token string">'Correct answers: 86.36%'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用特定类型的专属格式化:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> datetime
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">(</span><span class="token number">2010</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">58</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:%Y-%m-%d %H:%M:%S}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>d<span class="token punctuation">)</span>
<span class="token string">'2010-07-04 12:15:58'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>嵌套参数以及更复杂的示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> align<span class="token punctuation">,</span> text <span class="token keyword">in</span> zip<span class="token punctuation">(</span><span class="token string">'&lt;^>'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'left'</span><span class="token punctuation">,</span> <span class="token string">'center'</span><span class="token punctuation">,</span> <span class="token string">'right'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token string">'{0:{fill}{align}16}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>text<span class="token punctuation">,</span> fill<span class="token operator">=</span>align<span class="token punctuation">,</span> align<span class="token operator">=</span>align<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token string">'left&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;'</span>
<span class="token string">'^^^^^center^^^^^'</span>
<span class="token string">'>>>>>>>>>>>right'</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> octets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">192</span><span class="token punctuation">,</span> <span class="token number">168</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'{:02X}{:02X}{:02X}{:02X}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span><span class="token operator">*</span>octets<span class="token punctuation">)</span>
<span class="token string">'C0A80001'</span>
<span class="token operator">>></span><span class="token operator">></span> int<span class="token punctuation">(</span>_<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span>
<span class="token number">3232235521</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> width <span class="token operator">=</span> <span class="token number">5</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> num <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">:</span> 
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> base <span class="token keyword">in</span> <span class="token string">'dXob'</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'{0:{width}{base}}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>num<span class="token punctuation">,</span> base<span class="token operator">=</span>base<span class="token punctuation">,</span> width<span class="token operator">=</span>width<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token number">5</span>     <span class="token number">5</span>     <span class="token number">5</span>   <span class="token number">101</span>
    <span class="token number">6</span>     <span class="token number">6</span>     <span class="token number">6</span>   <span class="token number">110</span>
    <span class="token number">7</span>     <span class="token number">7</span>     <span class="token number">7</span>   <span class="token number">111</span>
    <span class="token number">8</span>     <span class="token number">8</span>    <span class="token number">10</span>  <span class="token number">1000</span>
    <span class="token number">9</span>     <span class="token number">9</span>    <span class="token number">11</span>  <span class="token number">1001</span>
   <span class="token number">10</span>     A    <span class="token number">12</span>  <span class="token number">1010</span>
   <span class="token number">11</span>     B    <span class="token number">13</span>  <span class="token number">1011</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串提供了由 <a href="https://www.python.org/dev/peps/pep-0292" target="_blank" rel="noopener"><strong>PEP 292</strong></a> 所描述的更简便的字符串替换方式。 模板字符串的一个主要用例是文本国际化 (i18n)，因为在此场景下，更简单的语法和功能使得文本翻译过程比使用 Python 的其他内置字符串格式化工具更为方便。 作为基于模板字符串构建以实现 i18n 的库的一个示例，请参看 <a href="http://flufli18n.readthedocs.io/en/latest/" target="_blank" rel="noopener">flufl.i18n</a> 包。</p>
<p>模板字符串支持基于 <code>$</code> 的替换，使用以下规则：</p>
<ul>
<li><code>$$</code> 为转义符号；它会被替换为单个的 <code>$</code>。</li>
<li><code>$identifier</code> 为替换占位符，它会匹配一个名为 <code>"identifier"</code> 的映射键。 在默认情况下，<code>"identifier"</code> 限制为任意 ASCII 字母数字（包括下划线）组成的字符串，不区分大小写，以下划线或 ASCII 字母开头。 在 <code>$</code> 字符之后的第一个非标识符字符将表明占位符的终结。</li>
<li><code>${identifier}</code> 等价于 <code>$identifier</code>。 当占位符之后紧跟着有效的但又不是占位符一部分的标识符字符时需要使用，例如 <code>"${noun}ification"</code>。</li>
</ul>
<p>在字符串的其他位置出现 <code>$</code> 将导致引发 <code>ValueError</code>。</p>
<p><code>string</code> 模块提供了实现这些规则的 <code>Template</code> 类。 <code>Template</code> 有下列方法：</p>
<p><em>class</em> <code>string.Template</code>(<em>template</em>)</p>
<p>该构造器接受一个参数作为模板字符串。</p>
<ul>
<li><p><code>substitute</code>(<em>mapping={}</em>, <em>/</em>, <em>**kwds</em>)</p>
<p>执行模板替换，返回一个新字符串。 <em>mapping</em> 为任意字典类对象，其中的键将匹配模板中的占位符。 或者你也可以提供一组关键字参数，其中的关键字即对应占位符。 当同时给出 <em>mapping</em> 和 <em>kwds</em> 并且存在重复时，则以 <em>kwds</em> 中的占位符为优先。</p>
</li>
<li><p><code>safe_substitute</code>(<em>mapping={}</em>, <em>/</em>, <em>**kwds</em>)</p>
<p>类似于 <code>substitute()</code>，不同之处是如果有占位符未在 <em>mapping</em> 和 <em>kwds</em> 中找到，不是引发 <code>KeyError</code> 异常，而是将原始占位符不加修改地显示在结果字符串中。 另一个与 <code>substitute()</code> 的差异是任何在其他情况下出现的 <code>$</code> 将简单地返回 <code>$</code> 而不是引发 <code>ValueError</code>。</p>
<p>此方法被认为“安全”，因为虽然仍有可能发生其他异常，但它总是尝试返回可用的字符串而不是引发一个异常。 从另一方面来说，<code>safe_substitute()</code> 也可能根本算不上安全，因为它将静默地忽略错误格式的模板，例如包含多余的分隔符、不成对的花括号或不是合法 Python 标识符的占位符等等。</p>
</li>
</ul>
<p><code>Template</code> 的实例还提供一个公有数据属性：</p>
<ul>
<li><p><code>template</code></p>
<p>这是作为构造器的 <em>template</em> 参数被传入的对象。 一般来说，你不应该修改它，但并不强制要求只读访问。</p>
</li>
</ul>
<p>以下是一个如何使用模版的示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> string <span class="token keyword">import</span> Template
<span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> Template<span class="token punctuation">(</span><span class="token string">'$who likes $what'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>substitute<span class="token punctuation">(</span>who<span class="token operator">=</span><span class="token string">'tim'</span><span class="token punctuation">,</span> what<span class="token operator">=</span><span class="token string">'kung pao'</span><span class="token punctuation">)</span>
<span class="token string">'tim likes kung pao'</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> dict<span class="token punctuation">(</span>who<span class="token operator">=</span><span class="token string">'tim'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Template<span class="token punctuation">(</span><span class="token string">'Give $who $100'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>substitute<span class="token punctuation">(</span>d<span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
ValueError<span class="token punctuation">:</span> Invalid placeholder <span class="token keyword">in</span> string<span class="token punctuation">:</span> line <span class="token number">1</span><span class="token punctuation">,</span> col <span class="token number">11</span>
<span class="token operator">>></span><span class="token operator">></span> Template<span class="token punctuation">(</span><span class="token string">'$who likes $what'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>substitute<span class="token punctuation">(</span>d<span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
KeyError<span class="token punctuation">:</span> <span class="token string">'what'</span>
<span class="token operator">>></span><span class="token operator">></span> Template<span class="token punctuation">(</span><span class="token string">'$who likes $what'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>safe_substitute<span class="token punctuation">(</span>d<span class="token punctuation">)</span>
<span class="token string">'tim likes $what'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>进阶用法：你可以派生 <code>Template</code> 的子类来自定义占位符语法、分隔符，或用于解析模板字符串的整个正则表达式。 为此目的，你可以重载这些类属性：</p>
<ul>
<li><p><em>delimiter</em> — 这是用来表示占位符的起始的分隔符的字符串字面值。 默认值为 <code>$</code>。 请注意此参数 <em>不能</em> 为正则表达式，因为其实现将在必要时对此字符串调用 <code>re.escape()</code>。 还要注意你不能在创建类之后改变此分隔符（例如在子类的类命名空间中必须设置不同的分隔符）。</p>
</li>
<li><p><em>idpattern</em> — 这是用来描述不带花括号的占位符的模式的正则表达式。 默认值为正则表达式 <code>(?a:[_a-z][_a-z0-9]*)</code>。 如果给出了此属性并且 <em>braceidpattern</em> 为 <code>None</code> 则此模式也将作用于带花括号的占位符。</p>
<p>注解</p>
<p>由于默认的 <em>flags</em> 为 <code>re.IGNORECASE</code>，模式 <code>[a-z]</code> 可以匹配某些非 ASCII 字符。 因此我们在这里使用了局部旗标 <code>a</code>。</p>
<p>在 3.7 版更改: <em>braceidpattern</em> 可被用来定义对花括号内部和外部进行区分的模式。</p>
</li>
<li><p><em>braceidpattern</em> — 此属性类似于 <em>idpattern</em> 但是用来描述带花括号的占位符的模式。 默认值 <code>None</code> 意味着回退到 <em>idpattern</em> (即在花括号内部和外部使用相同的模式)。 如果给出此属性，这将允许你为带花括号和不带花括号的占位符定义不同的模式。</p>
<p>3.7 新版功能.</p>
</li>
<li><p><em>flags</em> — 将在编译用于识别替换内容的正则表达式被应用的正则表达式旗标。 默认值为 <code>re.IGNORECASE</code>。 请注意 <code>re.VERBOSE</code> 总是会被加为旗标，因此自定义的 <em>idpattern</em> 必须遵循详细正则表达式的约定。</p>
<p>3.2 新版功能.</p>
</li>
</ul>
<p>作为另一种选项，你可以通过重载类属性 <em>pattern</em> 来提供整个正则表达式模式。 如果你这样做，该值必须为一个具有四个命名捕获组的正则表达式对象。 这些捕获组对应于上面已经给出的规则，以及无效占位符的规则：</p>
<ul>
<li><em>escaped</em> — 这个组匹配转义序列，在默认模式中即 <code>$$</code>。</li>
<li><em>named</em> — 这个组匹配不带花括号的占位符名称；它不应当包含捕获组中的分隔符。</li>
<li><em>braced</em> — 这个组匹配带有花括号的占位符名称；它不应当包含捕获组中的分隔符或者花括号。</li>
<li><em>invalid</em> — 这个组匹配任何其他分隔符模式（通常为单个分隔符），并且它应当出现在正则表达式的末尾。</li>
</ul>
<h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p><code>string.capwords</code>(<em>s</em>, <em>sep=None</em>)</p>
<p>使用 <code>str.split()</code> 将参数拆分为单词，使用 <code>str.capitalize()</code> 将单词转为大写形式，使用 <code>str.join()</code> 将大写的单词进行拼接。 如果可选的第二个参数 <em>sep</em> 被省略或为 <code>None</code>，则连续的空白字符会被替换为单个空格符并且开头和末尾的空白字符会被移除，否则 <em>sep</em> 会被用来拆分和拼接单词。</p>
<h2 id="re-—-正则表达式操作"><a href="#re-—-正则表达式操作" class="headerlink" title="re —- 正则表达式操作"></a><code>re</code> —- 正则表达式操作</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/re.py" target="_blank" rel="noopener">Lib/re.py</a></p>
<hr>
<p>本模块提供了与 Perl 语言类似的正则表达式匹配操作。</p>
<p>模式和被搜索的字符串既可以是 Unicode 字符串 (<code>str</code>) ，也可以是8位字节串 (<code>bytes</code>)。 但是，Unicode 字符串与 8 位字节串不能混用：也就是说，不能用字节串模式匹配 Unicode 字符串，反之亦然；同理，替换操作时，替换字符串的类型也必须与所用的模式和搜索字符串的类型一致。</p>
<p>正则表达式用反斜杠字符 (<code>'\'</code>) 表示特殊形式，或是允许在使用特殊字符时，不引发它们的特殊含义。 这与 Python 的字符串字面值中对相同字符出于相同目的的用法产生冲突；例如，要匹配一个反斜杠字面值，用户可能必须写成 <code>'\\\\'</code> 来作为模式字符串，因为正则表达式必须为 <code>\\</code>，而每个反斜杠在普通 Python 字符串字面值中又必须表示为 <code>\\</code>。 而且还要注意，在 Python 的字符串字面值中使用的反斜杠如果有任何无效的转义序列，现在会触发 <code>DeprecationWarning</code>，但以后会改为 <code>SyntaxError</code>。 此行为即使对于正则表达式来说有效的转义字符同样会发生。</p>
<p>解决办法是对于正则表达式样式使用 Python 的原始字符串表示法；在带有 <code>'r'</code> 前缀的字符串字面值中，反斜杠不必做任何特殊处理。 因此 <code>r"\n"</code> 表示包含 <code>'\'</code> 和 <code>'n'</code> 两个字符的字符串，而 <code>"\n"</code> 则表示只包含一个换行符的字符串。 样式在 Python 代码中通常都使用原始字符串表示法。</p>
<p>绝大多数正则表达式操作都提供为模块函数和方法，在 编译正则表达式. 这些函数是一个捷径，不需要先编译正则对象，但是损失了一些优化参数。</p>
<p>参见</p>
<p>第三方模块 regex , 提供了与标准库 <code>re</code> 模块兼容的 API 接口，同时，还提供了更多功能和更全面的 Unicode 支持。</p>
<h3 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h3><p>正则表达式（或 RE）指定了一组与之匹配的字符串；模块内的函数可以检查某个字符串是否与给定的正则表达式匹配（或者正则表达式是否匹配到字符串，这两种说法含义相同）。</p>
<p>正则表达式可以拼接；如果 <em>A</em> 和 <em>B</em> 都是正则表达式，则 <em>AB</em> 也是正则表达式。通常，如果字符串 <em>p</em> 匹配 <em>A</em>，并且另一个字符串 <em>q</em> 匹配 <em>B</em>，那么 <em>pq</em> 可以匹配 AB。除非 <em>A</em> 或者 <em>B</em> 包含低优先级操作，<em>A</em> 和 <em>B</em> 存在边界条件；或者命名组引用。所以，复杂表达式可以很容易的从这里描述的简单源语表达式构建。</p>
<p>正则表达式可以包含普通或者特殊字符。绝大部分普通字符，比如 <code>'A'</code>, <code>'a'</code>, 或者 <code>'0'</code>，都是最简单的正则表达式。它们就匹配自身。你可以拼接普通字符，所以 <code>last</code> 匹配字符串 <code>'last'</code>. （在这一节的其他部分，我们将用 <code>this special style</code> 这种方式表示正则表达式，通常不带引号，要匹配的字符串用 <code>'in single quotes'</code> ，单引号形式。）</p>
<p>有些字符，比如 <code>'|'</code> 或者 <code>'('</code>，属于特殊字符。 特殊字符既可以表示它的普通含义， 也可以影响它旁边的正则表达式的解释。</p>
<p>重复修饰符 (<code>*</code>, <code>+</code>, <code>?</code>, <code>{m,n}</code>, 等) 不能直接嵌套。这样避免了非贪婪后缀 <code>?</code> 修饰符，和其他实现中的修饰符产生的多义性。要应用一个内层重复嵌套，可以使用括号。 比如，表达式 <code>(?:a{6})*</code> 匹配6个 <code>'a'</code> 字符重复任意次数。</p>
<p>特殊字符有：</p>
<pre><code>.</code></pre><p>(点) 在默认模式，匹配除了换行的任意字符。如果指定了标签 <code>DOTALL</code> ，它将匹配包括换行符的任意字符。</p>
<pre><code>^</code></pre><p>(插入符号) 匹配字符串的开头， 并且在 <code>MULTILINE</code> 模式也匹配换行后的首个符号。</p>
<pre><code>$</code></pre><p>匹配字符串尾或者在字符串尾的换行符的前一个字符，在 <code>MULTILINE</code> 模式下也会匹配换行符之前的文本。 <code>foo</code> 匹配 ‘foo’ 和 ‘foobar’，但正则表达式 <code>foo$</code> 只匹配 ‘foo’。 更有趣的是，在 <code>'foo1\nfoo2\n'</code> 中搜索 <code>foo.$</code>，通常匹配 ‘foo2’，但在 <code>MULTILINE</code> 模式下可以匹配到 ‘foo1’；在 <code>'foo\n'</code> 中搜索 <code>$</code> 会找到两个（空的）匹配：一个在换行符之前，一个在字符串的末尾。</p>
<pre><code>*</code></pre><p>对它前面的正则式匹配0到任意次重复， 尽量多的匹配字符串。 <code>ab*</code> 会匹配 <code>'a'</code>，<code>'ab'</code>，或者 <code>'a'</code> 后面跟随任意个 <code>'b'</code>。</p>
<pre><code>+</code></pre><p>对它前面的正则式匹配1到任意次重复。 <code>ab+</code> 会匹配 <code>'a'</code> 后面跟随1个以上到任意个 <code>'b'</code>，它不会匹配 <code>'a'</code>。</p>
<pre><code>?</code></pre><p>对它前面的正则式匹配0到1次重复。 <code>ab?</code> 会匹配 <code>'a'</code> 或者 <code>'ab'</code>。</p>
<pre><code>*?, +?, ??</code></pre><p><code>'*'</code>, <code>'+'</code>，和 <code>'?'</code> 修饰符都是 <em>贪婪的*；它们在字符串进行尽可能多的匹配。有时候并不需要这种行为。如果正则式 `&lt;.</em>&gt;<code>希望找到</code>‘<a> b <c>‘<code>，它将会匹配整个字符串，而不仅是</code>‘</c></a><a>‘<code>。在修饰符之后添加</code>?<code>将使样式以 *非贪婪</code>方式或者 :dfn:<code>最小* 方式进行匹配； 尽量 *少* 的字符将会被匹配。 使用正则式</code>&lt;.*?&gt;<code>将会仅仅匹配</code>‘</a><a>‘`。</a></p><a>
<pre><code>{m}</code></pre><p>对其之前的正则式指定匹配 <em>m</em> 个重复；少于 <em>m</em> 的话就会导致匹配失败。比如， <code>a{6}</code> 将匹配6个 <code>'a'</code> , 但是不能是5个。</p>
<pre><code>{m,n}</code></pre><p>对正则式进行 <em>m</em> 到 <em>n</em> 次匹配，在 <em>m</em> 和 <em>n</em> 之间取尽量多。 比如，<code>a{3,5}</code> 将匹配 3 到 5个 <code>'a'</code>。忽略 <em>m</em> 意为指定下界为0，忽略 <em>n</em> 指定上界为无限次。 比如 <code>a{4,}b</code> 将匹配 <code>'aaaab'</code> 或者1000个 <code>'a'</code> 尾随一个 <code>'b'</code>，但不能匹配 <code>'aaab'</code>。逗号不能省略，否则无法辨别修饰符应该忽略哪个边界。</p>
<pre><code>{m,n}?</code></pre><p>前一个修饰符的非贪婪模式，只匹配尽量少的字符次数。比如，对于 <code>'aaaaaa'</code>， <code>a{3,5}</code> 匹配 5个 <code>'a'</code> ，而 <code>a{3,5}?</code> 只匹配3个 <code>'a'</code>。</p>
<pre><code>\</code></pre><p>转义特殊字符（允许你匹配 <code>'*'</code>, <code>'?'</code>, 或者此类其他），或者表示一个特殊序列；特殊序列之后进行讨论。</p>
<p>如果你没有使用原始字符串（ <code>r'raw'</code> ）来表达样式，要牢记Python也使用反斜杠作为转义序列；如果转义序列不被Python的分析器识别，反斜杠和字符才能出现在字符串中。如果Python可以识别这个序列，那么反斜杠就应该重复两次。这将导致理解障碍，所以高度推荐，就算是最简单的表达式，也要使用原始字符串。</p>
<pre><code>[]</code></pre><p>用于表示一个字符集合。在一个集合中：</p>
</a><ul><a>
<li>字符可以单独列出，比如 <code>[amk]</code> 匹配 <code>'a'</code>， <code>'m'</code>， 或者 <code>'k'</code>。</li>
<li>可以表示字符范围，通过用 <code>'-'</code> 将两个字符连起来。比如 <code>[a-z]</code> 将匹配任何小写ASCII字符， <code>[0-5][0-9]</code> 将匹配从 <code>00</code> 到 <code>59</code> 的两位数字， <code>[0-9A-Fa-f]</code> 将匹配任何十六进制数位。 如果 <code>-</code> 进行了转义 （比如 <code>[a\-z]</code>）或者它的位置在首位或者末尾（如 <code>[-a]</code> 或 <code>[a-]</code>），它就只表示普通字符 <code>'-'</code>。</li>
<li>特殊字符在集合中，失去它的特殊含义。比如 <code>[(+*)]</code> 只会匹配这几个文法字符 <code>'('</code>, <code>'+'</code>, <code>'*'</code>, or <code>')'</code>。</li>
<li>字符类如 <code>\w</code> 或者 <code>\S</code> (如下定义) 在集合内可以接受，它们可以匹配的字符由 <code>ASCII</code> 或者 <code>LOCALE</code> 模式决定。</li>
<li>不在集合范围内的字符可以通过 <em>取反</em> 来进行匹配。如果集合首字符是 <code>'^'</code> ，所有 <em>不</em> 在集合内的字符将会被匹配，比如 <code>[^5]</code> 将匹配所有字符，除了 <code>'5'</code>， <code>[^^]</code> 将匹配所有字符，除了 <code>'^'</code>. <code>^</code> 如果不在集合首位，就没有特殊含义。</li>
<li>在集合内要匹配一个字符 <code>']'</code>，有两种方法，要么就在它之前加上反斜杠，要么就把它放到集合首位。比如， <code>[()[\]{}]</code> 和 <code>[]()[{}]</code> 都可以匹配括号。</li>
</a><li><a></a><a href="https://unicode.org/reports/tr18/" target="_blank" rel="noopener">Unicode Technical Standard #18</a> 里的嵌套集合和集合操作支持可能在未来添加。这将会改变语法，所以为了帮助这个改变，一个 <code>FutureWarning</code> 将会在有多义的情况里被 <code>raise</code>，包含以下几种情况，集合由 <code>'['</code> 开始，或者包含下列字符序列 <code>'--'</code>, <code>'&amp;&amp;'</code>, <code>'~~'</code>, 和 <code>'||'</code>。为了避免警告，需要将它们用反斜杠转义。</li>
</ul>
<p>在 3.7 版更改: 如果一个字符串构建的语义在未来会改变的话，一个 <code>FutureWarning</code> 会 <code>raise</code> 。</p>
<pre><code>|</code></pre><p><code>A|B</code>， <em>A</em> 和 <em>B</em> 可以是任意正则表达式，创建一个正则表达式，匹配 <em>A</em> 或者 <em>B</em>. 任意个正则表达式可以用 <code>'|'</code> 连接。它也可以在组合（见下列）内使用。扫描目标字符串时， <code>'|'</code> 分隔开的正则样式从左到右进行匹配。当一个样式完全匹配时，这个分支就被接受。意思就是，一旦 <em>A</em> 匹配成功， <em>B</em> 就不再进行匹配，即便它能产生一个更好的匹配。或者说，<code>'|'</code> 操作符绝不贪婪。 如果要匹配 <code>'|'</code> 字符，使用 <code>\|</code>， 或者把它包含在字符集里，比如 <code>[|]</code>.</p>
<pre><code>(...)</code></pre><p>（组合），匹配括号内的任意正则表达式，并标识出组合的开始和结尾。匹配完成后，组合的内容可以被获取，并可以在之后用 <code>\number</code> 转义序列进行再次匹配，之后进行详细说明。要匹配字符 <code>'('</code> 或者 <code>')'</code>, 用 <code>\(</code> 或 <code>\)</code>, 或者把它们包含在字符集合里: <code>[(]</code>, <code>[)]</code>.</p>
<pre><code>(?…)</code></pre><p>这是个扩展标记法 （一个 <code>'?'</code> 跟随 <code>'('</code> 并无含义）。 <code>'?'</code> 后面的第一个字符决定了这个构建采用什么样的语法。这种扩展通常并不创建新的组合； <code>(?P&lt;name&gt;...)</code> 是唯一的例外。 以下是目前支持的扩展。</p>
<pre><code>(?aiLmsux)</code></pre><p>( <code>'a'</code>, <code>'i'</code>, <code>'L'</code>, <code>'m'</code>, <code>'s'</code>, <code>'u'</code>, <code>'x'</code> 中的一个或多个) 这个组合匹配一个空字符串；这些字符对正则表达式设置以下标记 <code>re.A</code> (只匹配ASCII字符), <code>re.I</code> (忽略大小写), <code>re.L</code> (语言依赖), <code>re.M</code> (多行模式), <code>re.S</code> (点dot匹配全部字符), <code>re.U</code> (Unicode匹配), and <code>re.X</code> (冗长模式)。 如果你想将这些标记包含在正则表达式中，这个方法就很有用，免去了在 <code>re.compile()</code> 中传递 <em>flag</em> 参数。标记应该在表达式字符串首位表示。</p>
<pre><code>(?:…)</code></pre><p>正则括号的非捕获版本。 匹配在括号内的任何正则表达式，但该分组所匹配的子字符串 <em>不能</em> 在执行匹配后被获取或是之后在模式中被引用。</p>
<pre><code>(?aiLmsux-imsx:…)</code></pre><p>(<code>'a'</code>, <code>'i'</code>, <code>'L'</code>, <code>'m'</code>, <code>'s'</code>, <code>'u'</code>, <code>'x'</code> 中的0或者多个， 之后可选跟随 <code>'-'</code> 在后面跟随 <code>'i'</code> , <code>'m'</code> , <code>'s'</code> , <code>'x'</code> 中的一到多个 .) 这些字符为表达式的其中一部分 <em>设置</em> 或者 <em>去除</em> 相应标记 <code>re.A</code> (只匹配ASCII), <code>re.I</code> (忽略大小写), <code>re.L</code> (语言依赖), <code>re.M</code> (多行), <code>re.S</code> (点匹配所有字符), <code>re.U</code> (Unicode匹配), and <code>re.X</code> (冗长模式)。</p>
<p><code>'a'</code>, <code>'L'</code> and <code>'u'</code> 作为内联标记是相互排斥的， 所以它们不能结合在一起，或者跟随 <code>'-'</code> 。 当他们中的某个出现在内联组中，它就覆盖了括号组内的匹配模式。在Unicode样式中， <code>(?a:...)</code> 切换为 只匹配ASCII， <code>(?u:...)</code> 切换为Unicode匹配 (默认). 在byte样式中 <code>(?L:...)</code> 切换为语言依赖模式， <code>(?a:...)</code> 切换为 只匹配ASCII (默认)。这种方式只覆盖组合内匹配，括号外的匹配模式不受影响。</p>
<p>3.6 新版功能.</p>
<p>在 3.7 版更改: 符号 <code>'a'</code>, <code>'L'</code> 和 <code>'u'</code> 同样可以用在一个组合内。</p>
<pre><code>(?P&lt;name&gt;…)</code></pre><p>（命名组合）类似正则组合，但是匹配到的子串组在外部是通过定义的 <em>name</em> 来获取的。组合名必须是有效的Python标识符，并且每个组合名只能用一个正则表达式定义，只能定义一次。一个符号组合同样是一个数字组合，就像这个组合没有被命名一样。</p>
<p>命名组合可以在三种上下文中引用。如果样式是 <code>(?P&lt;quote&gt;['"]).*?(?P=quote)</code> （也就是说，匹配单引号或者双引号括起来的字符串)：</p>
<table>
<thead>
<tr>
<th align="left">引用组合 “quote” 的上下文</th>
<th align="left">引用方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">在正则式自身内</td>
<td align="left"><code>(?P=quote)</code> (如示) <code>\1</code></td>
</tr>
<tr>
<td align="left">处理匹配对象 <em>m</em></td>
<td align="left"><code>m.group(‘quote’)</code> <code>m.end(‘quote’)</code> (等)</td>
</tr>
<tr>
<td align="left">传递到 <code>re.sub()</code> 里的 <em>repl</em> 参数中</td>
<td align="left"><code>\g&lt;quote&gt;</code> <code>\g&lt;1&gt;</code> <code>\1</code></td>
</tr>
</tbody></table>
<pre><code>(?P=name)</code></pre><p>反向引用一个命名组合；它匹配前面那个叫 <em>name</em> 的命名组中匹配到的串同样的字串。</p>
<pre><code>(?#…)</code></pre><p>注释；里面的内容会被忽略。</p>
<pre><code>(?=…)</code></pre><p>匹配 <code>…</code> 的内容，但是并不消费样式的内容。这个叫做 <em>lookahead assertion</em>。比如， <code>Isaac (?=Asimov)</code> 匹配 <code>'Isaac '</code> 只有在后面是 <code>'Asimov'</code> 的时候。</p>
<pre><code>(?!…)</code></pre><p>匹配 <code>…</code> 不符合的情况。这个叫 <em>negative lookahead assertion</em> （前视取反）。比如说， <code>Isaac (?!Asimov)</code> 只有后面 <em>不</em> 是 <code>'Asimov'</code> 的时候才匹配 <code>'Isaac '</code> 。</p>
<pre><code>(?&lt;=…)</code></pre><p>匹配字符串的当前位置，它的前面匹配 <code>...</code> 的内容到当前位置。这叫 <em>positive lookbehind assertion</em> （正向后视断定）。 <code>(?&lt;=abc)def</code> 会在 <code>'abcdef'</code> 中找到一个匹配，因为后视会往后看3个字符并检查是否包含匹配的样式。包含的匹配样式必须是定长的，意思就是 <code>abc</code> 或 <code>a|b</code> 是允许的，但是 <code>a*</code> 和 <code>a{3,4}</code> 不可以。注意以 positive lookbehind assertions 开始的样式，如 <code>(?&lt;=abc)def</code> ，并不是从 a 开始搜索，而是从 d 往回看的。你可能更加愿意使用 <code>search()</code> 函数，而不是 <code>match()</code> 函数：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> re
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'(?&lt;=abc)def'</span><span class="token punctuation">,</span> <span class="token string">'abcdef'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token string">'def'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个例子搜索一个跟随在连字符后的单词：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>r<span class="token string">'(?&lt;=-)\w+'</span><span class="token punctuation">,</span> <span class="token string">'spam-egg'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token string">'egg'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 3.5 版更改: 添加定长组合引用的支持。</p>
<pre><code>(?&lt;!…)</code></pre><p>匹配当前位置之前不是 <code>...</code> 的样式。这个叫 <em>negative lookbehind assertion</em> （后视断定取非）。类似正向后视断定，包含的样式匹配必须是定长的。由 negative lookbehind assertion 开始的样式可以从字符串搜索开始的位置进行匹配。</p>
<pre><code>(?(id/name)yes-pattern|no-pattern)</code></pre><p>如果给定的 <em>id</em> 或 <em>name</em> 存在，将会尝试匹配 <code>yes-pattern</code> ，否则就尝试匹配 <code>no-pattern</code>，<code>no-pattern</code> 可选，也可以被忽略。比如， <code>(&lt;)?(\w+@\w+(?:\.\w+)+)(?(1)&gt;|$)</code> 是一个email样式匹配，将匹配 <code>'&lt;user@host.com&gt;'</code> 或 <code>'user@host.com'</code> ，但不会匹配 <code>'&lt;user@host.com'</code> ，也不会匹配 <code>'user@host.com&gt;'</code>。</p>
<p>由 <code>'\'</code> 和一个字符组成的特殊序列在以下列出。 如果普通字符不是ASCII数位或者ASCII字母，那么正则样式将匹配第二个字符。比如，<code>\$</code> 匹配字符 <code>'$'</code>.</p>
<pre><code>\number</code></pre><p>匹配数字代表的组合。每个括号是一个组合，组合从1开始编号。比如 <code>(.+) \1</code> 匹配 <code>'the the'</code> 或者 <code>'55 55'</code>, 但不会匹配 <code>'thethe'</code> (注意组合后面的空格)。这个特殊序列只能用于匹配前面99个组合。如果 <em>number</em> 的第一个数位是0， 或者 <em>number</em> 是三个八进制数，它将不会被看作是一个组合，而是八进制的数字值。在 <code>'['</code> 和 <code>']'</code> 字符集合内，任何数字转义都被看作是字符。</p>
<pre><code>\A</code></pre><p>只匹配字符串开始。</p>
<pre><code>\b</code></pre><p>匹配空字符串，但只在单词开始或结尾的位置。一个单词被定义为一个单词字符的序列。注意，通常 <code>\b</code> 定义为 <code>\w</code> 和 <code>\W</code> 字符之间，或者 <code>\w</code> 和字符串开始/结尾的边界， 意思就是 <code>r'\bfoo\b'</code> 匹配 <code>'foo'</code>, <code>'foo.'</code>, <code>'(foo)'</code>, <code>'bar foo baz'</code> 但不匹配 <code>'foobar'</code> 或者 <code>'foo3'</code>。</p>
<p>默认情况下，Unicode字母和数字是在Unicode样式中使用的，但是可以用 <code>ASCII</code> 标记来更改。如果 <code>LOCALE</code> 标记被设置的话，词的边界是由当前语言区域设置决定的，<code>\b</code> 表示退格字符，以便与Python字符串文本兼容。</p>
<pre><code>\B</code></pre><p>匹配空字符串，但 <em>不</em> 能在词的开头或者结尾。意思就是 <code>r'py\B'</code> 匹配 <code>'python'</code>, <code>'py3'</code>, <code>'py2'</code>, 但不匹配 <code>'py'</code>, <code>'py.'</code>, 或者 <code>'py!'</code>. <code>\B</code> 是 <code>\b</code> 的取非，所以Unicode样式的词语是由Unicode字母，数字或下划线构成的，虽然可以用 <code>ASCII</code> 标志来改变。如果使用了 <code>LOCALE</code> 标志，则词的边界由当前语言区域设置。</p>
<pre><code>\d</code></pre><ul>
<li><p>对于 Unicode (str) 样式：</p>
<p>匹配任何Unicode十进制数（就是在Unicode字符目录[Nd]里的字符）。这包括了 <code>[0-9]</code> ，和很多其他的数字字符。如果设置了 <code>ASCII</code> 标志，就只匹配 <code>[0-9]</code> 。</p>
<p>对于8位(bytes)样式：</p>
<p>匹配任何十进制数，就是 <code>[0-9]</code>。</p>
</li>
</ul>
<pre><code>\D</code></pre><p>匹配任何非十进制数字的字符。就是 <code>\d</code> 取非。 如果设置了 <code>ASCII</code> 标志，就相当于 <code>[^0-9]</code> 。</p>
<pre><code>\s</code></pre><ul>
<li><p>对于 Unicode (str) 样式：</p>
<p>匹配任何Unicode空白字符（包括 <code>[ \t\n\r\f\v]</code> ，还有很多其他字符，比如不同语言排版规则约定的不换行空格）。如果 <code>ASCII</code> 被设置，就只匹配 <code>[ \t\n\r\f\v]</code> 。</p>
<p>对于8位(bytes)样式：</p>
<p>匹配ASCII中的空白字符，就是 <code>[ \t\n\r\f\v]</code> 。</p>
</li>
</ul>
<pre><code>\S</code></pre><p>匹配任何非空白字符。就是 <code>\s</code> 取非。如果设置了 <code>ASCII</code> 标志，就相当于 <code>[^ \t\n\r\f\v]</code> 。</p>
<pre><code>\w</code></pre><ul>
<li><p>对于 Unicode (str) 样式：</p>
<p>匹配Unicode词语的字符，包含了可以构成词语的绝大部分字符，也包括数字和下划线。如果设置了 <code>ASCII</code> 标志，就只匹配 <code>[a-zA-Z0-9_]</code> 。</p>
<p>对于8位(bytes)样式：</p>
<p>匹配ASCII字符中的数字和字母和下划线，就是 <code>[a-zA-Z0-9_]</code> 。如果设置了 <code>LOCALE</code> 标记，就匹配当前语言区域的数字和字母和下划线。</p>
</li>
</ul>
<pre><code>\W</code></pre><p>匹配非单词字符的字符。这与 <code>\w</code> 正相反。如果使用了 <code>ASCII</code> 旗标，这就等价于 <code>[^a-zA-Z0-9_]</code>。如果使用了 <code>LOCALE</code> 旗标，则会匹配当前区域中既非字母数字也非下划线的字符。</p>
<pre><code>\Z</code></pre><p>只匹配字符串尾。</p>
<p>绝大部分Python的标准转义字符也被正则表达式分析器支持。:</p>
<pre><code>\a      \b      \f      \n\N      \r      \t      \u\U      \v      \x      \\</code></pre><p>（注意 <code>\b</code> 被用于表示词语的边界，它只在字符集合内表示退格，比如 <code>[\b]</code> 。）</p>
<p><code>'\u'</code>, <code>'\U'</code> 和 <code>'\N'</code> 转义序列只在 Unicode 模式中可被识别。 在 bytes 模式中它们会导致错误。 未知的 ASCII 字母转义序列保留在未来使用，会被当作错误来处理。</p>
<p>八进制转义包含为一个有限形式。如果首位数字是 0， 或者有三个八进制数位，那么就认为它是八进制转义。其他的情况，就看作是组引用。对于字符串文本，八进制转义最多有三个数位长。</p>
<p>在 3.3 版更改: 增加了 <code>'\u'</code> 和 <code>'\U'</code> 转义序列。</p>
<p>在 3.6 版更改: 由 <code>'\'</code> 和一个ASCII字符组成的未知转义会被看成错误。</p>
<p>在 3.8 版更改: 添加了 <code>'\N{name}'</code> 转义序列。 与在字符串字面值中一样，它扩展了命名 Unicode 字符 (例如 <code>'\N{EM DASH}'</code>)。</p>
<h3 id="模块内容"><a href="#模块内容" class="headerlink" title="模块内容"></a>模块内容</h3><p>模块定义了几个函数、常量，和一个异常。有些函数是编译后的正则表达式方法的简化版本（少了一些特性）。重要的应用程序大多会在使用前先编译正则表达式。</p>
<p>在 3.6 版更改: 标志常量现在是 <code>RegexFlag</code> 类的实例，这个类是 <code>enum.IntFlag</code> 的子类。</p>
<p><code>re.compile</code>(<em>pattern</em>, <em>flags=0</em>)</p>
<p>将正则表达式的样式编译为一个 正则表达式对象 （正则对象），可以用于匹配，通过这个对象的方法 <code>match()</code>, <code>search()</code> 以及其他如下描述。</p>
<p>这个表达式的行为可以通过指定 <em>标记</em> 的值来改变。值可以是以下任意变量，可以通过位的OR操作来结合（ <code>|</code> 操作符）。</p>
<p>序列</p>
<pre class="line-numbers language-python"><code class="language-python">prog <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>
result <span class="token operator">=</span> prog<span class="token punctuation">.</span>match<span class="token punctuation">(</span>string<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>等价于</p>
<pre class="line-numbers language-python"><code class="language-python">result <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果需要多次使用这个正则表达式的话，使用 <code>re.compile()</code> 和保存这个正则对象以便复用，可以让程序更加高效。</p>
<p>注解</p>
<p>通过 <code>re.compile()</code> 编译后的样式，和模块级的函数会被缓存， 所以少数的正则表达式使用无需考虑编译的问题。</p>
<pre><code>re.A
re.ASCII</code></pre><p>让 <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code>, <code>\d</code>, <code>\D</code>, <code>\s</code> 和 <code>\S</code> 只匹配ASCII，而不是Unicode。这只对Unicode样式有效，会被byte样式忽略。相当于前面语法中的内联标志 <code>(?a)</code> 。</p>
<p>注意，为了保持向后兼容， <code>re.U</code> 标记依然存在（还有他的同义 <code>re.UNICODE</code> 和嵌入形式 <code>(?u)</code> ) ， 但是这些在 Python 3 是冗余的，因为默认字符串已经是Unicode了（并且Unicode匹配不允许byte出现)。</p>
<pre><code>re.DEBUG</code></pre><p>显示编译时的debug信息，没有内联标记。</p>
<pre><code>re.I
re.IGNORECASE</code></pre><p>进行忽略大小写匹配；表达式如 <code>[A-Z]</code> 也会匹配小写字符。Unicode匹配（比如 <code>Ü</code> 匹配 <code>ü</code>）同样有用，除非设置了 <code>re.ASCII</code> 标记来禁用非ASCII匹配。当前语言区域不会改变这个标记，除非设置了 <code>re.LOCALE</code> 标记。这个相当于内联标记 <code>(?i)</code> 。</p>
<p>注意，当设置了 <code>IGNORECASE</code> 标记，搜索Unicode样式 <code>[a-z]</code> 或 <code>[A-Z]</code> 的结合时，它将会匹配52个ASCII字符和4个额外的非ASCII字符： ‘İ’ (U+0130, 拉丁大写的 I 带个点在上面), ‘ı’ (U+0131, 拉丁小写没有点的 I ), ‘ſ’ (U+017F, 拉丁小写长 s) and ‘K’ (U+212A, 开尔文符号).如果使用 <code>ASCII</code> 标记，就只匹配 ‘a’ 到 ‘z’ 和 ‘A’ 到 ‘Z’ 。</p>
<pre><code>re.L
re.LOCALE</code></pre><p>由当前语言区域决定 <code>\w</code>, <code>\W</code>, <code>\b</code>, <code>\B</code> 和大小写敏感匹配。这个标记只能对byte样式有效。这个标记不推荐使用，因为语言区域机制很不可靠，它一次只能处理一个 “习惯”，而且只对8位字节有效。Unicode匹配在Python 3 里默认启用，并可以处理不同语言。 这个对应内联标记 <code>(?L)</code> 。</p>
<p>在 3.6 版更改: <code>re.LOCALE</code> 只能用于byte样式，而且不能和 <code>re.ASCII</code> 一起用。</p>
<p>在 3.7 版更改: 设置了 <code>re.LOCALE</code> 标记的编译正则对象不再在编译时依赖语言区域设置。语言区域设置只在匹配的时候影响其结果。</p>
<pre><code>re.M
re.MULTILINE</code></pre><p>设置以后，样式字符 <code>'^'</code> 匹配字符串的开始，和每一行的开始（换行符后面紧跟的符号）；样式字符 <code>'$'</code> 匹配字符串尾，和每一行的结尾（换行符前面那个符号）。默认情况下，<code>’^’</code> 匹配字符串头，<code>'$'</code> 匹配字符串尾。对应内联标记 <code>(?m)</code> 。</p>
<pre><code>re.S
re.DOTALL</code></pre><p>让 <code>'.'</code> 特殊字符匹配任何字符，包括换行符；如果没有这个标记，<code>'.'</code> 就匹配 <em>除了</em> 换行符的其他任意字符。对应内联标记 <code>(?s)</code> 。</p>
<pre><code>re.X
re.VERBOSE</code></pre><p>这个标记允许你编写更具可读性更友好的正则表达式。通过分段和添加注释。空白符号会被忽略，除非在一个字符集合当中或者由反斜杠转义，或者在 <code>*?</code>, <code>(?:</code> or <code>(?P&lt;…&gt;</code> 分组之内。当一个行内有 <code>#</code> 不在字符集和转义序列，那么它之后的所有字符都是注释。</p>
<p>意思就是下面两个正则表达式等价地匹配一个十进制数字：</p>
<pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token triple-quoted-string string">"""\d +  # the integral part
                   \.    # the decimal point
                   \d *  # some fractional digits"""</span><span class="token punctuation">,</span> re<span class="token punctuation">.</span>X<span class="token punctuation">)</span>
b <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">"\d+\.\d*"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应内联标记 <code>(?x)</code> 。</p>
<p><code>re.search</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p>
<p>扫描整个 <em>字符串</em> 找到匹配样式的第一个位置，并返回一个相应的 匹配对象。如果没有匹配，就返回一个 <code>None</code> ； 注意这和找到一个零长度匹配是不同的。</p>
<p><code>re.match</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p>
<p>如果 <em>string</em> 开始的0或者多个字符匹配到了正则表达式样式，就返回一个相应的 匹配对象 。 如果没有匹配，就返回 <code>None</code> ；注意它跟零长度匹配是不同的。</p>
<p>注意即便是 <code>MULTILINE</code> 多行模式， <code>re.match()</code> 也只匹配字符串的开始位置，而不匹配每行开始。</p>
<p>如果你想定位 <em>string</em> 的任何位置，使用 <code>search()</code> 来替代</p>
<p><code>re.fullmatch</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p>
<p>如果整个 <em>string</em> 匹配到正则表达式样式，就返回一个相应的 匹配对象 。 否则就返回一个 <code>None</code> ；注意这跟零长度匹配是不同的。</p>
<p>3.4 新版功能.</p>
<p><code>re.split</code>(<em>pattern</em>, <em>string</em>, <em>maxsplit=0</em>, <em>flags=0</em>)</p>
<p>用 <em>pattern</em> 分开 <em>string</em> 。 如果在 <em>pattern</em> 中捕获到括号，那么所有的组里的文字也会包含在列表里。如果 <em>maxsplit</em> 非零， 最多进行 <em>maxsplit</em> 次分隔， 剩下的字符全部返回到列表的最后一个元素。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">'\W+'</span><span class="token punctuation">,</span> <span class="token string">'Words, words, words.'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'Words'</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">'(\W+)'</span><span class="token punctuation">,</span> <span class="token string">'Words, words, words.'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'Words'</span><span class="token punctuation">,</span> <span class="token string">', '</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">', '</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">'\W+'</span><span class="token punctuation">,</span> <span class="token string">'Words, words, words.'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'Words'</span><span class="token punctuation">,</span> <span class="token string">'words, words.'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'[a-f]+'</span><span class="token punctuation">,</span> <span class="token string">'0a3B9'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果分隔符里有捕获组合，并且匹配到字符串的开始，那么结果将会以一个空字符串开始。对于结尾也是一样</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">'(\W+)'</span><span class="token punctuation">,</span> <span class="token string">'...words, words...'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'...'</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">', '</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">'...'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这样的话，分隔组将会出现在结果列表中同样的位置。</p>
<p>样式的空匹配仅在与前一个空匹配不相邻时才会拆分字符串。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">'\b'</span><span class="token punctuation">,</span> <span class="token string">'Words, words, words.'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'Words'</span><span class="token punctuation">,</span> <span class="token string">', '</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">', '</span><span class="token punctuation">,</span> <span class="token string">'words'</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">'\W*'</span><span class="token punctuation">,</span> <span class="token string">'...words...'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span>r<span class="token string">'(\W*)'</span><span class="token punctuation">,</span> <span class="token string">'...words...'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'...'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'...'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.1 版更改: 增加了可选标记参数。</p>
<p>在 3.7 版更改: 增加了空字符串的样式分隔。</p>
<p><code>re.findall</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p>
<p>Return all non-overlapping matches of <em>pattern</em> in <em>string</em>, as a list of strings or tuples. The <em>string</em> is scanned left-to-right, and matches are returned in the order found. Empty matches are included in the result.</p>
<p>The result depends on the number of capturing groups in the pattern. If there are no groups, return a list of strings matching the whole pattern. If there is exactly one group, return a list of strings matching that group. If multiple groups are present, return a list of tuples of strings matching the groups. Non-capturing groups do not affect the form of the result.</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">'\bf[a-z]*'</span><span class="token punctuation">,</span> <span class="token string">'which foot or hand fell fastest'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'foot'</span><span class="token punctuation">,</span> <span class="token string">'fell'</span><span class="token punctuation">,</span> <span class="token string">'fastest'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">'(\w+)=(\d+)'</span><span class="token punctuation">,</span> <span class="token string">'set width=20 and height=10'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'width'</span><span class="token punctuation">,</span> <span class="token string">'20'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'height'</span><span class="token punctuation">,</span> <span class="token string">'10'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.7 版更改: 非空匹配现在可以在前一个空匹配之后出现了。</p>
<p><code>re.finditer</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>)</p>
<p><em>pattern</em> 在 <em>string</em> 里所有的非重复匹配，返回为一个迭代器 iterator 保存了 匹配对象 。 <em>string</em> 从左到右扫描，匹配按顺序排列。空匹配也包含在结果里。</p>
<p>在 3.7 版更改: 非空匹配现在可以在前一个空匹配之后出现了。</p>
<p><code>re.sub</code>(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count=0</em>, <em>flags=0</em>)</p>
<p>返回通过使用 <em>repl</em> 替换在 <em>string</em> 最左边非重叠出现的 <em>pattern</em> 而获得的字符串。 如果样式没有找到，则不加改变地返回 <em>string*。 *repl</em> 可以是字符串或函数；如为字符串，则其中任何反斜杠转义序列都会被处理。 也就是说，<code>\n</code> 会被转换为一个换行符，<code>\r</code> 会被转换为一个回车符，依此类推。 未知的 ASCII 字符转义序列保留在未来使用，会被当作错误来处理。 其他未知转义序列例如 <code>\&amp;</code> 会保持原样。 向后引用像是 <code>\6</code> 会用样式中第 6 组所匹配到的子字符串来替换。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        r<span class="token string">'static PyObject*\npy_\1(void)\n{'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token string">'def myfunc():'</span><span class="token punctuation">)</span>
<span class="token string">'static PyObject*\npy_myfunc(void)\n{'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>repl</em> 是一个函数，那它会对每个非重复的 <em>pattern</em> 的情况调用。这个函数只能有一个 匹配对象 参数，并返回一个替换后的字符串。比如</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">dashrepl</span><span class="token punctuation">(</span>matchobj<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> matchobj<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token string">' '</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token string">'-'</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">'-{1,2}'</span><span class="token punctuation">,</span> dashrepl<span class="token punctuation">,</span> <span class="token string">'pro----gram-files'</span><span class="token punctuation">)</span>
<span class="token string">'pro--gram files'</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">'\sAND\s'</span><span class="token punctuation">,</span> <span class="token string">' &amp; '</span><span class="token punctuation">,</span> <span class="token string">'Baked Beans And Spam'</span><span class="token punctuation">,</span> flags<span class="token operator">=</span>re<span class="token punctuation">.</span>IGNORECASE<span class="token punctuation">)</span>
<span class="token string">'Baked Beans &amp; Spam'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>样式可以是一个字符串或者一个 样式对象 。</p>
<p>可选参数 <em>count</em> 是要替换的最大次数；<em>count</em> 必须是非负整数。如果省略这个参数或设为 0，所有的匹配都会被替换。 样式的空匹配仅在与前一个空匹配不相邻时才会被替换，所以 <code>sub('x*', '-', 'abxd')</code> 返回 <code>'-a-b--d-'</code> 。</p>
<p>在字符串类型的 <em>repl</em> 参数里，如上所述的转义和向后引用中，<code>\g&lt;name&gt;</code> 会使用命名组合 <code>name</code>，（在 <code>(?P&lt;name&gt;…)</code> 语法中定义） <code>\g&lt;number&gt;</code> 会使用数字组；<code>\g&lt;2&gt;</code> 就是 <code>\2</code>，但它避免了二义性，如 <code>\g&lt;2&gt;0</code>。 <code>\20</code> 就会被解释为组20，而不是组2后面跟随一个字符 <code>'0'</code>。向后引用 <code>\g&lt;0&gt;</code> 把 <em>pattern</em> 作为一整个组进行引用。</p>
<p>在 3.1 版更改: 增加了可选标记参数。</p>
<p>在 3.5 版更改: 不匹配的组合替换为空字符串。</p>
<p>在 3.6 版更改: <em>pattern</em> 中的未知转义（由 <code>'\'</code> 和一个 ASCII 字符组成）被视为错误。</p>
<p>在 3.7 版更改: <em>repl</em> 中的未知转义（由 <code>'\'</code> 和一个 ASCII 字符组成）被视为错误。</p>
<p>在 3.7 版更改: 样式中的空匹配相邻接时会被替换。</p>
<p><code>re.subn</code>(<em>pattern</em>, <em>repl</em>, <em>string</em>, <em>count=0</em>, <em>flags=0</em>)</p>
<p>行为与 <code>sub()</code> 相同，但是返回一个元组 <code>(字符串, 替换次数)</code>.</p>
<p>在 3.1 版更改: 增加了可选标记参数。</p>
<p>在 3.5 版更改: 不匹配的组合替换为空字符串。</p>
<p><code>re.escape</code>(<em>pattern</em>)</p>
<p>转义 <em>pattern</em> 中的特殊字符。如果你想对任意可能包含正则表达式元字符的文本字符串进行匹配，它就是有用的。比如</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>escape<span class="token punctuation">(</span><span class="token string">'https://www.python.org'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
https<span class="token punctuation">:</span><span class="token operator">//</span>www\<span class="token punctuation">.</span>python\<span class="token punctuation">.</span>org
<span class="token operator">>></span><span class="token operator">></span> legal_chars <span class="token operator">=</span> string<span class="token punctuation">.</span>ascii_lowercase <span class="token operator">+</span> string<span class="token punctuation">.</span>digits <span class="token operator">+</span> <span class="token string">"!#$%&amp;'*+-.^_`|~:"</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[%s]+'</span> <span class="token operator">%</span> re<span class="token punctuation">.</span>escape<span class="token punctuation">(</span>legal_chars<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>abcdefghijklmnopqrstuvwxyz0123456789!\#\$<span class="token operator">%</span>\<span class="token operator">&amp;</span>'\<span class="token operator">*</span>\<span class="token operator">+</span>\<span class="token operator">-</span>\<span class="token punctuation">.</span>\<span class="token operator">^</span>_`\<span class="token operator">|</span>\<span class="token operator">~</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">+</span>
<span class="token operator">>></span><span class="token operator">></span> operators <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">,</span> <span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'**'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'|'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>map<span class="token punctuation">(</span>re<span class="token punctuation">.</span>escape<span class="token punctuation">,</span> sorted<span class="token punctuation">(</span>operators<span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">/</span><span class="token operator">|</span>\<span class="token operator">-</span><span class="token operator">|</span>\<span class="token operator">+</span><span class="token operator">|</span>\<span class="token operator">*</span>\<span class="token operator">*</span><span class="token operator">|</span>\<span class="token operator">*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数不能被用于 <code>sub()</code> 和 <code>subn()</code> 的替换字符串，只有反斜杠应该被转义。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> digits_re <span class="token operator">=</span> r<span class="token string">'\d+'</span>
<span class="token operator">>></span><span class="token operator">></span> sample <span class="token operator">=</span> <span class="token string">'/usr/sbin/sendmail - 0 errors, 12 warnings'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>digits_re<span class="token punctuation">,</span> digits_re<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'\\'</span><span class="token punctuation">,</span> r<span class="token string">'\\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> sample<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">/</span>usr<span class="token operator">/</span>sbin<span class="token operator">/</span>sendmail <span class="token operator">-</span> \d<span class="token operator">+</span> errors<span class="token punctuation">,</span> \d<span class="token operator">+</span> warnings<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.3 版更改: <code>'_'</code> 不再被转义。</p>
<p>在 3.7 版更改: 只有在正则表达式中具有特殊含义的字符才会被转义。 因此， <code>'!'</code>, <code>'"'</code>, <code>'%'</code>, <code>"'"</code>, <code>','</code>, <code>'/'</code>, <code>':'</code>, <code>';'</code>, <code>'&lt;'</code>, <code>'='</code>, <code>'&gt;'</code>, <code>'@'</code> 和 <code>"</code>“` 将不再会被转义。</p>
<p><code>re.purge</code>()</p>
<p>清除正则表达式的缓存。</p>
<p><em>exception</em> <code>re.error</code>(<em>msg</em>, <em>pattern=None</em>, <em>pos=None</em>)</p>
<p>当传递给函数的正则表达式不合法（比如括号不匹配），或者在编译或匹配过程中出现其他错误时，会引发异常。所给字符串不匹配所给模式不会引发异常。异常实例有以下附加属性：</p>
<ul>
<li><p><code>msg</code></p>
<p>未格式化的错误消息。</p>
</li>
<li><p><code>pattern</code></p>
<p>正则表达式的模式串。</p>
</li>
<li><p><code>pos</code></p>
<p>编译失败的 <em>pattern</em> 的位置索引（可以是 <code>None</code> ）。</p>
</li>
<li><p><code>lineno</code></p>
<p>对应 <em>pos</em> (可以是 <code>None</code>) 的行号。</p>
</li>
<li><p><code>colno</code></p>
<p>对应 <em>pos</em> (可以是 <code>None</code>) 的列号。</p>
</li>
</ul>
<p>在 3.5 版更改: 增加了额外的属性。</p>
<h3 id="正则表达式对象-（正则对象）"><a href="#正则表达式对象-（正则对象）" class="headerlink" title="正则表达式对象 （正则对象）"></a>正则表达式对象 （正则对象）</h3><p>编译后的正则表达式对象支持以下方法和属性：</p>
<p><code>Pattern.search</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p>
<p>扫描整个 <em>string</em> 寻找第一个匹配的位置， 并返回一个相应的 匹配对象。如果没有匹配，就返回 <code>None</code> ；注意它和零长度匹配是不同的。</p>
<p>可选的第二个参数 <em>pos</em> 给出了字符串中开始搜索的位置索引；默认为 <code>0</code>，它不完全等价于字符串切片； <code>'^'</code> 样式字符匹配字符串真正的开头，和换行符后面的第一个字符，但不会匹配索引规定开始的位置。</p>
<p>可选参数 <em>endpos</em> 限定了字符串搜索的结束；它假定字符串长度到 <em>endpos</em> ， 所以只有从 <code>pos</code> 到 <code>endpos - 1</code> 的字符会被匹配。如果 <em>endpos</em> 小于 <em>pos*，就不会有匹配产生；另外，如果 *rx</em> 是一个编译后的正则对象， <code>rx.search(string, 0, 50)</code> 等价于 <code>rx.search(string[:50], 0)</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pattern <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pattern<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Match at index 0</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'d'</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> pattern<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># No match; search doesn't include the "d"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Pattern.match</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p>
<p>如果 <em>string</em> 的 <em>开始位置</em> 能够找到这个正则样式的任意个匹配，就返回一个相应的 匹配对象。如果不匹配，就返回 <code>None</code> ；注意它与零长度匹配是不同的。</p>
<p>可选参数 <em>pos</em> 和 <em>endpos</em> 与 <code>search()</code> 含义相同。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pattern <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span><span class="token string">"o"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pattern<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># No match as "o" is not at the start of "dog".</span>
<span class="token operator">>></span><span class="token operator">></span> pattern<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Match as "o" is the 2nd character of "dog".</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'o'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果你想定位匹配在 <em>string</em> 中的位置，使用 <code>search()</code> 来替代。</p>
<p><code>Pattern.fullmatch</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p>
<p>如果整个 <em>string</em> 匹配这个正则表达式，就返回一个相应的 匹配对象 。 否则就返回 <code>None</code> ； 注意跟零长度匹配是不同的。</p>
<p>可选参数 <em>pos</em> 和 <em>endpos</em> 与 <code>search()</code> 含义相同。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pattern <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span><span class="token string">"o[gh]"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pattern<span class="token punctuation">.</span>fullmatch<span class="token punctuation">(</span><span class="token string">"dog"</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># No match as "o" is not at the start of "dog".</span>
<span class="token operator">>></span><span class="token operator">></span> pattern<span class="token punctuation">.</span>fullmatch<span class="token punctuation">(</span><span class="token string">"ogre"</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># No match as not the full string matches.</span>
<span class="token operator">>></span><span class="token operator">></span> pattern<span class="token punctuation">.</span>fullmatch<span class="token punctuation">(</span><span class="token string">"doggie"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Matches within given limits.</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'og'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.4 新版功能.</p>
<p><code>Pattern.split</code>(<em>string</em>, <em>maxsplit=0</em>)</p>
<p>等价于 <code>split()</code> 函数，使用了编译后的样式。</p>
<p><code>Pattern.findall</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p>
<p>类似函数 <code>findall()</code> ， 使用了编译后样式，但也可以接收可选参数 <em>pos</em> 和 <em>endpos</em> ，限制搜索范围，就像 <code>search()</code>。</p>
<p><code>Pattern.finditer</code>(<em>string</em>[, <em>pos</em>[, <em>endpos</em>]])</p>
<p>类似函数 <code>finditer()</code> ， 使用了编译后样式，但也可以接收可选参数 <em>pos</em> 和 <em>endpos</em> ，限制搜索范围，就像 <code>search()</code>。</p>
<p><code>Pattern.sub</code>(<em>repl</em>, <em>string</em>, <em>count=0</em>)</p>
<p>等价于 <code>sub()</code> 函数，使用了编译后的样式。</p>
<p><code>Pattern.subn</code>(<em>repl</em>, <em>string</em>, <em>count=0</em>)</p>
<p>等价于 <code>subn()</code> 函数，使用了编译后的样式。</p>
<pre><code>Pattern.flags</code></pre><p>正则匹配标记。这是可以传递给 <code>compile()</code> 的参数，任何 <code>(?…)</code> 内联标记，隐性标记比如 <code>UNICODE</code> 的结合。</p>
<pre><code>Pattern.groups</code></pre><p>捕获到的模式串中组的数量。</p>
<pre><code>Pattern.groupindex</code></pre><p>映射由 <code>(?P&lt;id&gt;)</code> 定义的命名符号组合和数字组合的字典。如果没有符号组，那字典就是空的。</p>
<pre><code>Pattern.pattern</code></pre><p>编译对象的原始样式字符串。</p>
<p>在 3.7 版更改: 添加 <code>copy.copy()</code> 和 <code>copy.deepcopy()</code> 函数的支持。编译后的正则表达式对象被认为是原子性的。</p>
<h3 id="匹配对象"><a href="#匹配对象" class="headerlink" title="匹配对象"></a>匹配对象</h3><p>匹配对象总是有一个布尔值 <code>True</code>。如果没有匹配的话 <code>match()</code> 和 <code>search()</code> 返回 <code>None</code> 所以你可以简单的用 <code>if</code> 语句来判断是否匹配</p>
<pre class="line-numbers language-python"><code class="language-python">match <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> string<span class="token punctuation">)</span>
<span class="token keyword">if</span> match<span class="token punctuation">:</span>
    process<span class="token punctuation">(</span>match<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>匹配对象支持以下方法和属性：</p>
<p><code>Match.expand</code>(<em>template</em>)</p>
<p>对 <em>template</em> 进行反斜杠转义替换并且返回，就像 <code>sub()</code> 方法中一样。转义如同 <code>\n</code> 被转换成合适的字符，数字引用(<code>\1</code>, <code>\2</code>)和命名组合(<code>\g&lt;1&gt;</code>, <code>\g&lt;name&gt;</code>) 替换为相应组合的内容。</p>
<p>在 3.5 版更改: 不匹配的组合替换为空字符串。</p>
<p><code>Match.group</code>([<em>group1</em>, <em>…</em>])</p>
<p>返回一个或者多个匹配的子组。如果只有一个参数，结果就是一个字符串，如果有多个参数，结果就是一个元组（每个参数对应一个项），如果没有参数，组1默认到0（整个匹配都被返回）。 如果一个组N 参数值为 0，相应的返回值就是整个匹配字符串；如果它是一个范围 [1..99]，结果就是相应的括号组字符串。如果一个组号是负数，或者大于样式中定义的组数，就引发一个 <code>IndexError</code> 异常。如果一个组包含在样式的一部分，并被匹配多次，就返回最后一个匹配。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"(\w+) (\w+)"</span><span class="token punctuation">,</span> <span class="token string">"Isaac Newton, physicist"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># The entire match</span>
<span class="token string">'Isaac Newton'</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># The first parenthesized subgroup.</span>
<span class="token string">'Isaac'</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># The second parenthesized subgroup.</span>
<span class="token string">'Newton'</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Multiple arguments give us a tuple.</span>
<span class="token punctuation">(</span><span class="token string">'Isaac'</span><span class="token punctuation">,</span> <span class="token string">'Newton'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果正则表达式使用了 <code>(?P&lt;name&gt;...)</code> 语法， <em>groupN</em> 参数就也可能是命名组合的名字。如果一个字符串参数在样式中未定义为组合名，就引发一个 <code>IndexError</code> 异常。</p>
<p>一个相对复杂的例子</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"(?P&lt;first_name>\w+) (?P&lt;last_name>\w+)"</span><span class="token punctuation">,</span> <span class="token string">"Malcolm Reynolds"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">'first_name'</span><span class="token punctuation">)</span>
<span class="token string">'Malcolm'</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token string">'last_name'</span><span class="token punctuation">)</span>
<span class="token string">'Reynolds'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>命名组合同样可以通过索引值引用</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token string">'Malcolm'</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token string">'Reynolds'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果一个组匹配成功多次，就只返回最后一个匹配</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"(..)+"</span><span class="token punctuation">,</span> <span class="token string">"a1b2c3"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Matches 3 times.</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                        <span class="token comment" spellcheck="true"># Returns only the last match.</span>
<span class="token string">'c3'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>Match.__getitem__</code>(<em>g</em>)</p>
<p>这个等价于 <code>m.group(g)</code>。这允许更方便的引用一个匹配</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"(\w+) (\w+)"</span><span class="token punctuation">,</span> <span class="token string">"Isaac Newton, physicist"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true"># The entire match</span>
<span class="token string">'Isaac Newton'</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true"># The first parenthesized subgroup.</span>
<span class="token string">'Isaac'</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>       <span class="token comment" spellcheck="true"># The second parenthesized subgroup.</span>
<span class="token string">'Newton'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.6 新版功能.</p>
<p><code>Match.groups</code>(<em>default=None</em>)</p>
<p>返回一个元组，包含所有匹配的子组，在样式中出现的从1到任意多的组合。 <em>default</em> 参数用于不参与匹配的情况，默认为 <code>None</code>。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"(\d+)\.(\d+)"</span><span class="token punctuation">,</span> <span class="token string">"24.1632"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'24'</span><span class="token punctuation">,</span> <span class="token string">'1632'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果我们使小数点可选，那么不是所有的组都会参与到匹配当中。这些组合默认会返回一个 <code>None</code> ，除非指定了 <em>default</em> 参数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"(\d+)\.?(\d+)?"</span><span class="token punctuation">,</span> <span class="token string">"24"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># Second group defaults to None.</span>
<span class="token punctuation">(</span><span class="token string">'24'</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Now, the second group defaults to '0'.</span>
<span class="token punctuation">(</span><span class="token string">'24'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Match.groupdict</code>(<em>default=None</em>)</p>
<p>返回一个字典，包含了所有的 <em>命名</em> 子组。key就是组名。 <em>default</em> 参数用于不参与匹配的组合；默认为 <code>None</code>。 例如</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"(?P&lt;first_name>\w+) (?P&lt;last_name>\w+)"</span><span class="token punctuation">,</span> <span class="token string">"Malcolm Reynolds"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> m<span class="token punctuation">.</span>groupdict<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token string">'first_name'</span><span class="token punctuation">:</span> <span class="token string">'Malcolm'</span><span class="token punctuation">,</span> <span class="token string">'last_name'</span><span class="token punctuation">:</span> <span class="token string">'Reynolds'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>Match.start</code>([<em>group</em>])</p>
<p><code>Match.end</code>([<em>group</em>])</p>
<p>返回 <em>group</em> 匹配到的字串的开始和结束标号。<em>group</em> 默认为0（意思是整个匹配的子串）。如果 <em>group</em> 存在，但未产生匹配，就返回 <code>-1</code> 。对于一个匹配对象 <em>m</em>， 和一个未参与匹配的组 <em>g</em> ，组 <em>g</em> (等价于 <code>m.group(g)</code>)产生的匹配是</p>
<pre><code>m.string[m.start(g):m.end(g)]</code></pre><p>注意 <code>m.start(group)</code> 将会等于 <code>m.end(group)</code> ，如果 <em>group</em> 匹配一个空字符串的话。比如，在 <code>m = re.search('b(c?)', 'cba')</code> 之后，<code>m.start(0)</code> 为 1, <code>m.end(0)</code> 为 2, <code>m.start(1)</code> 和 <code>m.end(1)</code> 都是 2, <code>m.start(2)</code> 引发一个 <code>IndexError</code> 异常。</p>
<p>这个例子会从email地址中移除掉 <em>remove_this</em></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> email <span class="token operator">=</span> <span class="token string">"tony@tiremove_thisger.net"</span>
<span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"remove_this"</span><span class="token punctuation">,</span> email<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> email<span class="token punctuation">[</span><span class="token punctuation">:</span>m<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> email<span class="token punctuation">[</span>m<span class="token punctuation">.</span>end<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token string">'tony@tiger.net'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Match.span</code>([<em>group</em>])</p>
<p>对于一个匹配 <em>m</em> ， 返回一个二元组 <code>(m.start(group), m.end(group))</code> 。 注意如果 <em>group</em> 没有在这个匹配中，就返回 <code>(-1, -1)</code> 。<em>group</em> 默认为0，就是整个匹配。</p>
<pre><code>Match.pos</code></pre><p><em>pos</em> 的值，会传递给 <code>search()</code> 或 <code>match()</code> 的方法 a 正则对象 。这个是正则引擎开始在字符串搜索一个匹配的索引位置。</p>
<pre><code>Match.endpos</code></pre><p><em>endpos</em> 的值，会传递给 <code>search()</code> 或 <code>match()</code> 的方法 a 正则对象 。这个是正则引擎停止在字符串搜索一个匹配的索引位置。</p>
<pre><code>Match.lastindex</code></pre><p>捕获组的最后一个匹配的整数索引值，或者 <code>None</code> 如果没有匹配产生的话。比如，对于字符串 <code>'ab'</code>，表达式 <code>(a)b</code>, <code>((a)(b))</code>, 和 <code>((ab))</code> 将得到 <code>lastindex == 1</code> ， 而 <code>(a)(b)</code> 会得到 <code>lastindex == 2</code> 。</p>
<pre><code>Match.lastgroup</code></pre><p>最后一个匹配的命名组名字，或者 <code>None</code> 如果没有产生匹配的话。</p>
<pre><code>Match.re</code></pre><p>返回产生这个实例的 正则对象 ， 这个实例是由 正则对象的 <code>match()</code> 或 <code>search()</code> 方法产生的。</p>
<pre><code>Match.string</code></pre><p>传递到 <code>match()</code> 或 <code>search()</code> 的字符串。</p>
<p>在 3.7 版更改: 添加了对 <code>copy.copy()</code> 和 <code>copy.deepcopy()</code> 的支持。匹配对象被看作是原子性的。</p>
<h3 id="正则表达式例子"><a href="#正则表达式例子" class="headerlink" title="正则表达式例子"></a>正则表达式例子</h3><h4 id="检查对子"><a href="#检查对子" class="headerlink" title="检查对子"></a>检查对子</h4><p>在这个例子里，我们使用以下辅助函数来更好地显示匹配对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">displaymatch</span><span class="token punctuation">(</span>match<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> match <span class="token keyword">is</span> None<span class="token punctuation">:</span>
        <span class="token keyword">return</span> None
    <span class="token keyword">return</span> <span class="token string">'&lt;Match: %r, groups=%r>'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>match<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token punctuation">.</span>groups<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>假设你在写一个扑克程序，一个玩家的一手牌为五个字符的串，每个字符表示一张牌，”a” 就是 A, “k” K， “q” Q, “j” J, “t” 为 10, “2” 到 “9” 表示2 到 9。</p>
<p>要看给定的字符串是否有效，我们可以按照以下步骤</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> valid <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">"^[a2-9tjqk]{5}$"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> displaymatch<span class="token punctuation">(</span>valid<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"akt5q"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Valid.</span>
<span class="token string">"&lt;Match: 'akt5q', groups=()>"</span>
<span class="token operator">>></span><span class="token operator">></span> displaymatch<span class="token punctuation">(</span>valid<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"akt5e"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Invalid.</span>
<span class="token operator">>></span><span class="token operator">></span> displaymatch<span class="token punctuation">(</span>valid<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"akt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># Invalid.</span>
<span class="token operator">>></span><span class="token operator">></span> displaymatch<span class="token punctuation">(</span>valid<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"727ak"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Valid.</span>
<span class="token string">"&lt;Match: '727ak', groups=()>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后一手牌，<code>"727ak"</code> ，包含了一个对子，或者两张同样数值的牌。要用正则表达式匹配它，应该使用向后引用如下</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pair <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">".*(.).*\1"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> displaymatch<span class="token punctuation">(</span>pair<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"717ak"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Pair of 7s.</span>
<span class="token string">"&lt;Match: '717', groups=('7',)>"</span>
<span class="token operator">>></span><span class="token operator">></span> displaymatch<span class="token punctuation">(</span>pair<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"718ak"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># No pairs.</span>
<span class="token operator">>></span><span class="token operator">></span> displaymatch<span class="token punctuation">(</span>pair<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"354aa"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># Pair of aces.</span>
<span class="token string">"&lt;Match: '354aa', groups=('a',)>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要找出对子由什么牌组成，开发者可以按照下面的方式来使用匹配对象的 <code>group()</code> 方法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pair <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>r<span class="token string">".*(.).*\1"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> pair<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"717ak"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token string">'7'</span>
<span class="token comment" spellcheck="true"># Error because re.match() returns None, which doesn't have a group() method:</span>
<span class="token operator">>></span><span class="token operator">></span> pair<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"718ak"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;pyshell#23>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
    re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">".*(.).*\1"</span><span class="token punctuation">,</span> <span class="token string">"718ak"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
AttributeError<span class="token punctuation">:</span> <span class="token string">'NoneType'</span> object has no attribute <span class="token string">'group'</span>
<span class="token operator">>></span><span class="token operator">></span> pair<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"354aa"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token string">'a'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="模拟-scanf"><a href="#模拟-scanf" class="headerlink" title="模拟 scanf()"></a>模拟 scanf()</h4><p>Python 目前没有一个类似c函数 <code>scanf()</code> 的替代品。正则表达式通常比 <code>scanf()</code> 格式字符串要更强大一些，但也带来更多复杂性。下面的表格提供了 <code>scanf()</code> 格式符和正则表达式大致相同的映射。</p>
<table>
<thead>
<tr>
<th align="left"><code>scanf()</code> 格式符</th>
<th align="left">正则表达式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>%c</code></td>
<td align="left"><code>.</code></td>
</tr>
<tr>
<td align="left"><code>%5c</code></td>
<td align="left"><code>.{5}</code></td>
</tr>
<tr>
<td align="left"><code>%d</code></td>
<td align="left"><code>[-+]?\d+</code></td>
</tr>
<tr>
<td align="left"><code>%e</code>, <code>%E</code>, <code>%f</code>, <code>%g</code></td>
<td align="left">`[-+]?(\d+(.\d*)?</td>
</tr>
<tr>
<td align="left"><code>%i</code></td>
<td align="left">`[-+]?(0[xX][\dA-Fa-f]+</td>
</tr>
<tr>
<td align="left"><code>%o</code></td>
<td align="left"><code>[-+]?[0-7]+</code></td>
</tr>
<tr>
<td align="left"><code>%s</code></td>
<td align="left"><code>\S+</code></td>
</tr>
<tr>
<td align="left"><code>%u</code></td>
<td align="left"><code>\d+</code></td>
</tr>
<tr>
<td align="left"><code>%x</code>, <code>%X</code></td>
<td align="left"><code>[-+]?(0[xX])?[\dA-Fa-f]+</code></td>
</tr>
</tbody></table>
<p>从文件名和数字提取字符串</p>
<pre><code>/usr/sbin/sendmail - 0 errors, 4 warnings</code></pre><p>你可以使用 <code>scanf()</code> 格式化</p>
<pre><code>%s - %d errors, %d warnings</code></pre><p>等价的正则表达式是：</p>
<pre><code>(\S+) - (\d+) errors, (\d+) warnings</code></pre><h4 id="search-vs-match"><a href="#search-vs-match" class="headerlink" title="search() vs. match()"></a>search() vs. match()</h4><p>Python 提供了两种不同的操作：基于 <code>re.match()</code> 检查字符串开头，或者 <code>re.search()</code> 检查字符串的任意位置（默认Perl中的行为）。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"abcdef"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># No match</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"abcdef"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># Match</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'c'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 <code>search()</code> 中，可以用 <code>'^'</code> 作为开始来限制匹配到字符串的首位</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"abcdef"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># No match</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"^c"</span><span class="token punctuation">,</span> <span class="token string">"abcdef"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># No match</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">"^a"</span><span class="token punctuation">,</span> <span class="token string">"abcdef"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Match</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'a'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意 <code>MULTILINE</code> 多行模式中函数 <code>match()</code> 只匹配字符串的开始，但使用 <code>search()</code> 和以 <code>'^'</code> 开始的正则表达式会匹配每行的开始</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'X'</span><span class="token punctuation">,</span> <span class="token string">'A\nB\nX'</span><span class="token punctuation">,</span> re<span class="token punctuation">.</span>MULTILINE<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># No match</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>search<span class="token punctuation">(</span><span class="token string">'^X'</span><span class="token punctuation">,</span> <span class="token string">'A\nB\nX'</span><span class="token punctuation">,</span> re<span class="token punctuation">.</span>MULTILINE<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Match</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'X'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="制作一个电话本"><a href="#制作一个电话本" class="headerlink" title="制作一个电话本"></a>制作一个电话本</h4><p><code>split()</code> 将字符串用参数传递的样式分隔开。这个方法对于转换文本数据到易读而且容易修改的数据结构，是很有用的，如下面的例子证明。</p>
<p>首先，这里是输入。 它通常来自一个文件，这里我们使用三重引号字符串语法</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> text <span class="token operator">=</span> <span class="token triple-quoted-string string">"""Ross McFluff: 834.345.1254 155 Elm Street
...
... Ronald Heathmore: 892.345.3428 436 Finley Avenue
... Frank Burger: 925.541.7625 662 South Dogwood Way
...
...
... Heather Albrecht: 548.326.4584 919 Park Place"""</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>条目用一个或者多个换行符分开。现在我们将字符串转换为一个列表，每个非空行都有一个条目:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> entries <span class="token operator">=</span> re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"\n+"</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> entries
<span class="token punctuation">[</span><span class="token string">'Ross McFluff: 834.345.1254 155 Elm Street'</span><span class="token punctuation">,</span>
<span class="token string">'Ronald Heathmore: 892.345.3428 436 Finley Avenue'</span><span class="token punctuation">,</span>
<span class="token string">'Frank Burger: 925.541.7625 662 South Dogwood Way'</span><span class="token punctuation">,</span>
<span class="token string">'Heather Albrecht: 548.326.4584 919 Park Place'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终，将每个条目分割为一个由名字、姓氏、电话号码和地址组成的列表。我们为 <code>split()</code> 使用了 <code>maxsplit</code> 形参，因为地址中包含有被我们作为分割模式的空格符:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">":? "</span><span class="token punctuation">,</span> entry<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">for</span> entry <span class="token keyword">in</span> entries<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'Ross'</span><span class="token punctuation">,</span> <span class="token string">'McFluff'</span><span class="token punctuation">,</span> <span class="token string">'834.345.1254'</span><span class="token punctuation">,</span> <span class="token string">'155 Elm Street'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token string">'Ronald'</span><span class="token punctuation">,</span> <span class="token string">'Heathmore'</span><span class="token punctuation">,</span> <span class="token string">'892.345.3428'</span><span class="token punctuation">,</span> <span class="token string">'436 Finley Avenue'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token string">'Frank'</span><span class="token punctuation">,</span> <span class="token string">'Burger'</span><span class="token punctuation">,</span> <span class="token string">'925.541.7625'</span><span class="token punctuation">,</span> <span class="token string">'662 South Dogwood Way'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token string">'Heather'</span><span class="token punctuation">,</span> <span class="token string">'Albrecht'</span><span class="token punctuation">,</span> <span class="token string">'548.326.4584'</span><span class="token punctuation">,</span> <span class="token string">'919 Park Place'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>:?</code> 样式匹配姓后面的冒号，因此它不出现在结果列表中。如果 <code>maxsplit</code> 设置为 <code>4</code> ，我们还可以从地址中获取到房间号:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>re<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">":? "</span><span class="token punctuation">,</span> entry<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">for</span> entry <span class="token keyword">in</span> entries<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">'Ross'</span><span class="token punctuation">,</span> <span class="token string">'McFluff'</span><span class="token punctuation">,</span> <span class="token string">'834.345.1254'</span><span class="token punctuation">,</span> <span class="token string">'155'</span><span class="token punctuation">,</span> <span class="token string">'Elm Street'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token string">'Ronald'</span><span class="token punctuation">,</span> <span class="token string">'Heathmore'</span><span class="token punctuation">,</span> <span class="token string">'892.345.3428'</span><span class="token punctuation">,</span> <span class="token string">'436'</span><span class="token punctuation">,</span> <span class="token string">'Finley Avenue'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token string">'Frank'</span><span class="token punctuation">,</span> <span class="token string">'Burger'</span><span class="token punctuation">,</span> <span class="token string">'925.541.7625'</span><span class="token punctuation">,</span> <span class="token string">'662'</span><span class="token punctuation">,</span> <span class="token string">'South Dogwood Way'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">[</span><span class="token string">'Heather'</span><span class="token punctuation">,</span> <span class="token string">'Albrecht'</span><span class="token punctuation">,</span> <span class="token string">'548.326.4584'</span><span class="token punctuation">,</span> <span class="token string">'919'</span><span class="token punctuation">,</span> <span class="token string">'Park Place'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="文字整理"><a href="#文字整理" class="headerlink" title="文字整理"></a>文字整理</h4><p><code>sub()</code> 替换字符串中出现的样式的每一个实例。这个例子证明了使用 <code>sub()</code> 来整理文字，或者随机化每个字符的位置，除了首位和末尾字符</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">repl</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     inner_word <span class="token operator">=</span> list<span class="token punctuation">(</span>m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>inner_word<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>inner_word<span class="token punctuation">)</span> <span class="token operator">+</span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> text <span class="token operator">=</span> <span class="token string">"Professor Abdolmalek, please report your absences promptly."</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">"(\w)(\w+)(\w)"</span><span class="token punctuation">,</span> repl<span class="token punctuation">,</span> text<span class="token punctuation">)</span>
<span class="token string">'Poefsrosr Aealmlobdk, pslaee reorpt your abnseces plmrptoy.'</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>r<span class="token string">"(\w)(\w+)(\w)"</span><span class="token punctuation">,</span> repl<span class="token punctuation">,</span> text<span class="token punctuation">)</span>
<span class="token string">'Pofsroser Aodlambelk, plasee reoprt yuor asnebces potlmrpy.'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="查找所有副词"><a href="#查找所有副词" class="headerlink" title="查找所有副词"></a>查找所有副词</h4><p><code>findall()</code> 匹配样式 <em>所有</em> 的出现，不仅是像 <code>search()</code> 中的第一个匹配。比如，如果一个作者希望找到文字中的所有副词，他可能会按照以下方法用 <code>findall()</code></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> text <span class="token operator">=</span> <span class="token string">"He was carefully disguised but captured quickly by police."</span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">"\w+ly"</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'carefully'</span><span class="token punctuation">,</span> <span class="token string">'quickly'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="查找所有的副词及其位置"><a href="#查找所有的副词及其位置" class="headerlink" title="查找所有的副词及其位置"></a>查找所有的副词及其位置</h4><p>如果需要匹配样式的更多信息， <code>finditer()</code> 可以起到作用，它提供了 匹配对象 作为返回值，而不是字符串。继续上面的例子，如果一个作者希望找到所有副词和它的位置，可以按照下面方法使用 <code>finditer()</code></p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> text <span class="token operator">=</span> <span class="token string">"He was carefully disguised but captured quickly by police."</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> m <span class="token keyword">in</span> re<span class="token punctuation">.</span>finditer<span class="token punctuation">(</span>r<span class="token string">"\w+ly"</span><span class="token punctuation">,</span> text<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'%02d-%02d: %s'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span>end<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">07</span><span class="token operator">-</span><span class="token number">16</span><span class="token punctuation">:</span> carefully
<span class="token number">40</span><span class="token operator">-</span><span class="token number">47</span><span class="token punctuation">:</span> quickly<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="原始字符串标记"><a href="#原始字符串标记" class="headerlink" title="原始字符串标记"></a>原始字符串标记</h4><p>原始字符串记法 (<code>r"text"</code>) 保持正则表达式正常。否则，每个正则式里的反斜杠(<code>'\'</code>) 都必须前缀一个反斜杠来转义。比如，下面两行代码功能就是完全一致的</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"\W(.)\1\W"</span><span class="token punctuation">,</span> <span class="token string">" ff "</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">' ff '</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"\\W(.)\\1\\W"</span><span class="token punctuation">,</span> <span class="token string">" ff "</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">' ff '</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当需要匹配一个字符反斜杠，它必须在正则表达式中转义。在原始字符串记法，就是 <code>r"\\"</code>。否则就必须用 <code>"\\\\"</code>，来表示同样的意思</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span>r<span class="token string">"\\"</span><span class="token punctuation">,</span> r<span class="token string">"\\"</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'\\'</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">"\\\\"</span><span class="token punctuation">,</span> r<span class="token string">"\\"</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'\\'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="写一个词法分析器"><a href="#写一个词法分析器" class="headerlink" title="写一个词法分析器"></a>写一个词法分析器</h4><p>一个 词法器或词法分析器 分析字符串，并分类成目录组。 这是写一个编译器或解释器的第一步。</p>
<p>文字目录是由正则表达式指定的。这个技术是通过将这些样式合并为一个主正则式，并且循环匹配来实现的</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> typing <span class="token keyword">import</span> NamedTuple
<span class="token keyword">import</span> re
<span class="token keyword">class</span> <span class="token class-name">Token</span><span class="token punctuation">(</span>NamedTuple<span class="token punctuation">)</span><span class="token punctuation">:</span>
    type<span class="token punctuation">:</span> str
    value<span class="token punctuation">:</span> str
    line<span class="token punctuation">:</span> int
    column<span class="token punctuation">:</span> int
<span class="token keyword">def</span> <span class="token function">tokenize</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">:</span>
    keywords <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'IF'</span><span class="token punctuation">,</span> <span class="token string">'THEN'</span><span class="token punctuation">,</span> <span class="token string">'ENDIF'</span><span class="token punctuation">,</span> <span class="token string">'FOR'</span><span class="token punctuation">,</span> <span class="token string">'NEXT'</span><span class="token punctuation">,</span> <span class="token string">'GOSUB'</span><span class="token punctuation">,</span> <span class="token string">'RETURN'</span><span class="token punctuation">}</span>
    token_specification <span class="token operator">=</span> <span class="token punctuation">[</span>
        <span class="token punctuation">(</span><span class="token string">'NUMBER'</span><span class="token punctuation">,</span>   r<span class="token string">'\d+(\.\d*)?'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true"># Integer or decimal number</span>
        <span class="token punctuation">(</span><span class="token string">'ASSIGN'</span><span class="token punctuation">,</span>   r<span class="token string">':='</span><span class="token punctuation">)</span><span class="token punctuation">,</span>           <span class="token comment" spellcheck="true"># Assignment operator</span>
        <span class="token punctuation">(</span><span class="token string">'END'</span><span class="token punctuation">,</span>      r<span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true"># Statement terminator</span>
        <span class="token punctuation">(</span><span class="token string">'ID'</span><span class="token punctuation">,</span>       r<span class="token string">'[A-Za-z]+'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true"># Identifiers</span>
        <span class="token punctuation">(</span><span class="token string">'OP'</span><span class="token punctuation">,</span>       r<span class="token string">'[+\-*/]'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true"># Arithmetic operators</span>
        <span class="token punctuation">(</span><span class="token string">'NEWLINE'</span><span class="token punctuation">,</span>  r<span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>           <span class="token comment" spellcheck="true"># Line endings</span>
        <span class="token punctuation">(</span><span class="token string">'SKIP'</span><span class="token punctuation">,</span>     r<span class="token string">'[ \t]+'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>       <span class="token comment" spellcheck="true"># Skip over spaces and tabs</span>
        <span class="token punctuation">(</span><span class="token string">'MISMATCH'</span><span class="token punctuation">,</span> r<span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true"># Any other character</span>
    <span class="token punctuation">]</span>
    tok_regex <span class="token operator">=</span> <span class="token string">'|'</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'(?P&lt;%s>%s)'</span> <span class="token operator">%</span> pair <span class="token keyword">for</span> pair <span class="token keyword">in</span> token_specification<span class="token punctuation">)</span>
    line_num <span class="token operator">=</span> <span class="token number">1</span>
    line_start <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> mo <span class="token keyword">in</span> re<span class="token punctuation">.</span>finditer<span class="token punctuation">(</span>tok_regex<span class="token punctuation">,</span> code<span class="token punctuation">)</span><span class="token punctuation">:</span>
        kind <span class="token operator">=</span> mo<span class="token punctuation">.</span>lastgroup
        value <span class="token operator">=</span> mo<span class="token punctuation">.</span>group<span class="token punctuation">(</span><span class="token punctuation">)</span>
        column <span class="token operator">=</span> mo<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> line_start
        <span class="token keyword">if</span> kind <span class="token operator">==</span> <span class="token string">'NUMBER'</span><span class="token punctuation">:</span>
            value <span class="token operator">=</span> float<span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token string">'.'</span> <span class="token keyword">in</span> value <span class="token keyword">else</span> int<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> kind <span class="token operator">==</span> <span class="token string">'ID'</span> <span class="token operator">and</span> value <span class="token keyword">in</span> keywords<span class="token punctuation">:</span>
            kind <span class="token operator">=</span> value
        <span class="token keyword">elif</span> kind <span class="token operator">==</span> <span class="token string">'NEWLINE'</span><span class="token punctuation">:</span>
            line_start <span class="token operator">=</span> mo<span class="token punctuation">.</span>end<span class="token punctuation">(</span><span class="token punctuation">)</span>
            line_num <span class="token operator">+=</span> <span class="token number">1</span>
            <span class="token keyword">continue</span>
        <span class="token keyword">elif</span> kind <span class="token operator">==</span> <span class="token string">'SKIP'</span><span class="token punctuation">:</span>
            <span class="token keyword">continue</span>
        <span class="token keyword">elif</span> kind <span class="token operator">==</span> <span class="token string">'MISMATCH'</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> RuntimeError<span class="token punctuation">(</span>f<span class="token string">'{value!r} unexpected on line {line_num}'</span><span class="token punctuation">)</span>
        <span class="token keyword">yield</span> Token<span class="token punctuation">(</span>kind<span class="token punctuation">,</span> value<span class="token punctuation">,</span> line_num<span class="token punctuation">,</span> column<span class="token punctuation">)</span>
statements <span class="token operator">=</span> <span class="token triple-quoted-string string">'''
    IF quantity THEN
        total := total + price * quantity;
        tax := price * 0.05;
    ENDIF;
'''</span>
<span class="token keyword">for</span> token <span class="token keyword">in</span> tokenize<span class="token punctuation">(</span>statements<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该词法器产生以下的输出</p>
<pre class="line-numbers language-python"><code class="language-python">Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'IF'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'IF'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ID'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'quantity'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'THEN'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'THEN'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ID'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'total'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ASSIGN'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">':='</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">14</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ID'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'total'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">17</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'OP'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'+'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">23</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ID'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'price'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'OP'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'*'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">31</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ID'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'quantity'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">33</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'END'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">';'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">41</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ID'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'tax'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ASSIGN'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">':='</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ID'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'price'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">15</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'OP'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'*'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">21</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'NUMBER'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token number">0.05</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">23</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'END'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">';'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">27</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'ENDIF'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">'ENDIF'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span>
Token<span class="token punctuation">(</span>type<span class="token operator">=</span><span class="token string">'END'</span><span class="token punctuation">,</span> value<span class="token operator">=</span><span class="token string">';'</span><span class="token punctuation">,</span> line<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> column<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Frie09</p>
<p>Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O’Reilly Media, 2009. 该书的第三版不再包含 Python，但第一版极详细地覆盖了正则表达式模式串的编写。</p>
<h2 id="difflib-—-计算差异的辅助工具"><a href="#difflib-—-计算差异的辅助工具" class="headerlink" title="difflib —- 计算差异的辅助工具"></a><code>difflib</code> —- 计算差异的辅助工具</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/difflib.py" target="_blank" rel="noopener">Lib/difflib.py</a></p>
<p>此模块提供用于比较序列的类和函数。 例如，它可被用于比较文件，并可产生多种格式的不同文件差异信息，包括 HTML 和上下文以及统一的 diff 数据。 </p>
<p><em>class</em> <code>difflib.SequenceMatcher</code></p>
<p>这是一个灵活的类，可用于比较任何类型的序列对，只要序列元素为 hashable 对象。 其基本算法要早于由 Ratcliff 和 Obershelp 于 1980 年代末期发表并以“格式塔模式匹配”的夸张名称命名的算法，并且更加有趣一些。 其思路是找到不包含“垃圾”元素的最长连续匹配子序列；所谓“垃圾”元素是指其在某种意义上没有价值，例如空白行或空白符。 （处理垃圾元素是对 Ratcliff 和 Obershelp 算法的一个扩展。） 然后同样的思路将递归地应用于匹配序列的左右序列片段。 这并不能产生最小编辑序列，但确实能产生在人们看来“正确”的匹配。</p>
<p><strong>耗时:</strong> 基本 Ratcliff-Obershelp 算法在最坏情况下为立方时间而在一般情况下为平方时间。 <code>SequenceMatcher</code> 在最坏情况下为平方时间而在一般情况下的行为受到序列中有多少相同元素这一因素的微妙影响；在最佳情况下则为线性时间。</p>
<p><strong>自动垃圾启发式计算:</strong> <code>SequenceMatcher</code> 支持使用启发式计算来自动将特定序列项视为垃圾。 这种启发式计算会统计每个单独项在序列中出现的次数。 如果某一项（在第一项之后）的重复次数超过序列长度的 1% 并且序列长度至少有 200 项，该项会被标记为“热门”并被视为序列匹配中的垃圾。 这种启发式计算可以通过在创建 <code>SequenceMatcher</code> 时将 <code>autojunk</code> 参数设为 <code>False</code> 来关闭。</p>
<p>3.2 新版功能: <em>autojunk</em> 形参。</p>
<p><em>class</em> <code>difflib.Differ</code></p>
<p>这个类的作用是比较由文本行组成的序列，并产生可供人阅读的差异或增量信息。 Differ 统一使用 <code>SequenceMatcher</code> 来完成行序列的比较以及相似（接近匹配）行内部字符序列的比较。</p>
<p><code>Differ</code> 增量的每一行均以双字母代码打头：</p>
<table>
<thead>
<tr>
<th align="left">双字母代码</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘- ‘</code></td>
<td align="left">行为序列 1 所独有</td>
</tr>
<tr>
<td align="left"><code>‘+ ‘</code></td>
<td align="left">行为序列 2 所独有</td>
</tr>
<tr>
<td align="left"><code>‘ ‘</code></td>
<td align="left">行在两序列中相同</td>
</tr>
<tr>
<td align="left"><code>‘? ‘</code></td>
<td align="left">行不存在于任一输入序列</td>
</tr>
</tbody></table>
<p>以 ‘<code>?</code>‘ 打头的行尝试将视线引至行以外而不存在于任一输入序列的差异。 如果序列包含制表符则这些行可能会令人感到迷惑。</p>
<p><em>class</em> <code>difflib.HtmlDiff</code></p>
<p>这个类可用于创建 HTML 表格（或包含表格的完整 HTML 文件）以并排地逐行显示文本比较，行间与行外的更改将突出显示。 此表格可以基于完全或上下文差异模式来生成。</p>
<p>这个类的构造函数：</p>
<ul>
<li><p><code>__init__</code>(<em>tabsize=8</em>, <em>wrapcolumn=None</em>, <em>linejunk=None</em>, <em>charjunk=IS_CHARACTER_JUNK</em>)</p>
<p>初始化 <code>HtmlDiff</code> 的实例。</p>
<p><em>tabsize</em> 是一个可选关键字参数，指定制表位的间隔，默认值为 <code>8</code>。</p>
<p><em>wrapcolumn</em> 是一个可选关键字参数，指定行文本自动打断并换行的列位置，默认值为 <code>None</code> 表示不自动换行。</p>
<p><em>linejunk</em> 和 <em>charjunk</em> 均是可选关键字参数，会传入 <code>ndiff()</code> (被 <code>HtmlDiff</code> 用来生成并排显示的 HTML 差异)。 </p>
</li>
</ul>
<p>下列是公开的方法</p>
<ul>
<li><p><code>make_file</code>(<em>fromlines</em>, <em>tolines</em>, <em>fromdesc=’’</em>, <em>todesc=’’</em>, <em>context=False</em>, <em>numlines=5</em>, <em>**,</em> charset=’utf-8’*)</p>
<p>比较 <em>fromlines</em> 和 <em>tolines</em> (字符串列表) 并返回一个字符串，表示一个完整 HTML 文件，其中包含各行差异的表格，行间与行外的更改将突出显示。</p>
<p><em>fromdesc</em> 和 <em>todesc</em> 均是可选关键字参数，指定来源/目标文件的列标题字符串（默认均为空白字符串）。</p>
<p><em>context</em> 和 <em>numlines</em> 均是可选关键字参数。 当只要显示上下文差异时就将 <em>context</em> 设为 <code>True</code>，否则默认值 <code>False</code> 为显示完整文件。 <em>numlines</em> 默认为 <code>5</code>。 当 <em>context</em> 为 <code>True</code> 时 <em>numlines</em> 将控制围绕突出显示差异部分的上下文行数。 当 <em>context</em> 为 <code>False</code> 时 <em>numlines</em> 将控制在使用 “next” 超链接时突出显示差异部分之前所显示的行数（设为零则会导致 “next” 超链接将下一个突出显示差异部分放在浏览器顶端，不添加任何前导上下文）。</p>
<p>注解</p>
<p><em>fromdesc</em> 和 <em>todesc</em> 会被当作未转义的 HTML 来解读，当接收不可信来源的输入时应该适当地进行转义。</p>
<p>在 3.5 版更改: 增加了 <em>charset</em> 关键字参数。 HTML 文档的默认字符集从 <code>'ISO-8859-1'</code> 更改为 <code>'utf-8'</code>。</p>
</li>
<li><p><code>make_table</code>(<em>fromlines</em>, <em>tolines</em>, <em>fromdesc=’’</em>, <em>todesc=’’</em>, <em>context=False</em>, <em>numlines=5</em>)</p>
<p>比较 <em>fromlines</em> 和 <em>tolines</em> (字符串列表) 并返回一个字符串，表示一个包含各行差异的完整 HTML 表格，行间与行外的更改将突出显示。</p>
</li>
</ul>
<p><code>Tools/scripts/diff.py</code> 是这个类的命令行前端，其中包含一个很好的使用示例。</p>
<p><code>difflib.context_diff</code>(<em>a</em>, <em>b</em>, <em>fromfile=’’</em>, <em>tofile=’’</em>, <em>fromfiledate=’’</em>, <em>tofiledate=’’</em>, <em>n=3</em>, <em>lineterm=’\n’</em>)</p>
<p>比较 <em>a</em> 和 <em>b</em> (字符串列表)；返回上下文差异格式的增量信息 (一个产生增量行的 generator)。</p>
<p>所谓上下文差异是一种只显示有更改的行再加几个上下文行的紧凑形式。 更改被显示为之前/之后的样式。 上下文行数由 <em>n</em> 设定，默认为三行。</p>
<p>默认情况下，差异控制行（以 <code>***</code> or <code>---</code> 表示）是通过末尾换行符来创建的。 这样做的好处是从 <code>io.IOBase.readlines()</code> 创建的输入将得到适用于 <code>io.IOBase.writelines()</code> 的差异信息，因为输入和输出都带有末尾换行符。</p>
<p>对于没有末尾换行符的输入，应将 <em>lineterm</em> 参数设为 <code>""</code>，这样输出内容将统一不带换行符。</p>
<p>上下文差异格式通常带有一个记录文件名和修改时间的标头。 这些信息的部分或全部可以使用字符串 <em>fromfile</em>, <em>tofile</em>, <em>fromfiledate</em> 和 <em>tofiledate</em> 来指定。 修改时间通常以 ISO 8601 格式表示。 如果未指定，这些字符串默认为空。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'bacon\n'</span><span class="token punctuation">,</span> <span class="token string">'eggs\n'</span><span class="token punctuation">,</span> <span class="token string">'ham\n'</span><span class="token punctuation">,</span> <span class="token string">'guido\n'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> s2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'python\n'</span><span class="token punctuation">,</span> <span class="token string">'eggy\n'</span><span class="token punctuation">,</span> <span class="token string">'hamster\n'</span><span class="token punctuation">,</span> <span class="token string">'guido\n'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>context_diff<span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> fromfile<span class="token operator">=</span><span class="token string">'before.py'</span><span class="token punctuation">,</span> tofile<span class="token operator">=</span><span class="token string">'after.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">**</span><span class="token operator">*</span> before<span class="token punctuation">.</span>py
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> after<span class="token punctuation">.</span>py
<span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">**</span><span class="token operator">*</span>
<span class="token operator">**</span><span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token operator">**</span><span class="token operator">**</span>
! bacon
! eggs
! ham
  guido
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>
! python
! eggy
! hamster
  guido<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>difflib.get_close_matches</code>(<em>word</em>, <em>possibilities</em>, <em>n=3</em>, <em>cutoff=0.6</em>)</p>
<p>返回由最佳“近似”匹配构成的列表。 <em>word</em> 为一个指定目标近似匹配的序列（通常为字符串），<em>possibilities</em> 为一个由用于匹配 <em>word</em> 的序列构成的列表（通常为字符串列表）。</p>
<p>可选参数 <em>n</em> (默认为 <code>3</code>) 指定最多返回多少个近似匹配； <em>n</em> 必须大于 <code>0</code>.</p>
<p>可选参数 <em>cutoff</em> (默认为 <code>0.6</code>) 是一个 [0, 1] 范围内的浮点数。 与 <em>word</em> 相似度得分未达到该值的候选匹配将被忽略。</p>
<p>候选匹配中（不超过 <em>n</em> 个）的最佳匹配将以列表形式返回，按相似度得分排序，最相似的排在最前面。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> get_close_matches<span class="token punctuation">(</span><span class="token string">'appel'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'ape'</span><span class="token punctuation">,</span> <span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'peach'</span><span class="token punctuation">,</span> <span class="token string">'puppy'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token string">'ape'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> keyword
<span class="token operator">>></span><span class="token operator">></span> get_close_matches<span class="token punctuation">(</span><span class="token string">'wheel'</span><span class="token punctuation">,</span> keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'while'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> get_close_matches<span class="token punctuation">(</span><span class="token string">'pineapple'</span><span class="token punctuation">,</span> keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> get_close_matches<span class="token punctuation">(</span><span class="token string">'accept'</span><span class="token punctuation">,</span> keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'except'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>difflib.ndiff</code>(<em>a</em>, <em>b</em>, <em>linejunk=None</em>, <em>charjunk=IS_CHARACTER_JUNK</em>)</p>
<p>比较 <em>a</em> 和 <em>b</em> (字符串列表)；返回 <code>Differ</code> 形式的增量信息 (一个产生增量行的 generator)。</p>
<p>可选关键字形参 <em>linejunk</em> 和 <em>charjunk</em> 均为过滤函数 (或为 <code>None</code>)：</p>
<p><em>linejunk</em>: 此函数接受单个字符串参数，如果其为垃圾字符串则返回真值，否则返回假值。 默认为 <code>None</code>。 此外还有一个模块层级的函数 <code>IS_LINE_JUNK()</code>，它会过滤掉没有可见字符的行，除非该行添加了至多一个井号符 (<code>'#'</code>) — 但是下层的 <code>SequenceMatcher</code> 类会动态分析哪些行的重复频繁到足以形成噪音，这通常会比使用此函数的效果更好。</p>
<p><em>charjunk</em>: 此函数接受一个字符（长度为 1 的字符串)，如果其为垃圾字符则返回真值，否则返回假值。 默认为模块层级的函数 <code>IS_CHARACTER_JUNK()</code>，它会过滤掉空白字符（空格符或制表符；但包含换行符可不是个好主意！）。</p>
<p><code>Tools/scripts/ndiff.py</code> 是这个函数的命令行前端。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> diff <span class="token operator">=</span> ndiff<span class="token punctuation">(</span><span class="token string">'one\ntwo\nthree\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>              <span class="token string">'ore\ntree\nemu\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>diff<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>
<span class="token operator">-</span> one
?  <span class="token operator">^</span>
<span class="token operator">+</span> ore
?  <span class="token operator">^</span>
<span class="token operator">-</span> two
<span class="token operator">-</span> three
?  <span class="token operator">-</span>
<span class="token operator">+</span> tree
<span class="token operator">+</span> emu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>difflib.restore</code>(<em>sequence</em>, <em>which</em>)</p>
<p>返回两个序列中产生增量的那一个。</p>
<p>给出一个由 <code>Differ.compare()</code> 或 <code>ndiff()</code> 产生的 <em>序列<em>，提取出来自文件 1 或 2 (</em>which</em> 形参) 的行，去除行前缀。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> diff <span class="token operator">=</span> ndiff<span class="token punctuation">(</span><span class="token string">'one\ntwo\nthree\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>              <span class="token string">'ore\ntree\nemu\n'</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> diff <span class="token operator">=</span> list<span class="token punctuation">(</span>diff<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># materialize the generated delta into a list</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>restore<span class="token punctuation">(</span>diff<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>
one
two
three
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>restore<span class="token punctuation">(</span>diff<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>
ore
tree
emu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>difflib.unified_diff</code>(<em>a</em>, <em>b</em>, <em>fromfile=’’</em>, <em>tofile=’’</em>, <em>fromfiledate=’’</em>, <em>tofiledate=’’</em>, <em>n=3</em>, <em>lineterm=’\n’</em>)</p>
<p>比较 <em>a</em> 和 <em>b</em> (字符串列表)；返回统一差异格式的增量信息 (一个产生增量行的 generator)。</p>
<p>所以统一差异是一种只显示有更改的行再加几个上下文行的紧凑形式。 更改被显示为内联的样式（而不是分开的之前/之后文本块）。 上下文行数由 <em>n</em> 设定，默认为三行。</p>
<p>默认情况下，差异控制行 (以 <code>---</code>, <code>+++</code> 或 <code>@@</code> 表示) 是通过末尾换行符来创建的。 这样做的好处是从 <code>io.IOBase.readlines()</code> 创建的输入将得到适用于 <code>io.IOBase.writelines()</code> 的差异信息，因为输入和输出都带有末尾换行符。</p>
<p>对于没有末尾换行符的输入，应将 <em>lineterm</em> 参数设为 <code>""</code>，这样输出内容将统一不带换行符。</p>
<p>上下文差异格式通常带有一个记录文件名和修改时间的标头。 这些信息的部分或全部可以使用字符串 <em>fromfile</em>, <em>tofile</em>, <em>fromfiledate</em> 和 <em>tofiledate</em> 来指定。 修改时间通常以 ISO 8601 格式表示。 如果未指定，这些字符串默认为空。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'bacon\n'</span><span class="token punctuation">,</span> <span class="token string">'eggs\n'</span><span class="token punctuation">,</span> <span class="token string">'ham\n'</span><span class="token punctuation">,</span> <span class="token string">'guido\n'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> s2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'python\n'</span><span class="token punctuation">,</span> <span class="token string">'eggy\n'</span><span class="token punctuation">,</span> <span class="token string">'hamster\n'</span><span class="token punctuation">,</span> <span class="token string">'guido\n'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>unified_diff<span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">,</span> fromfile<span class="token operator">=</span><span class="token string">'before.py'</span><span class="token punctuation">,</span> tofile<span class="token operator">=</span><span class="token string">'after.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> before<span class="token punctuation">.</span>py
<span class="token operator">+</span><span class="token operator">+</span><span class="token operator">+</span> after<span class="token punctuation">.</span>py
@@ <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span> @@
<span class="token operator">-</span>bacon
<span class="token operator">-</span>eggs
<span class="token operator">-</span>ham
<span class="token operator">+</span>python
<span class="token operator">+</span>eggy
<span class="token operator">+</span>hamster
 guido<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>difflib.diff_bytes</code>(<em>dfunc</em>, <em>a</em>, <em>b</em>, <em>fromfile=b’’</em>, <em>tofile=b’’</em>, <em>fromfiledate=b’’</em>, <em>tofiledate=b’’</em>, <em>n=3</em>, <em>lineterm=b’\n’</em>)</p>
<p>使用 <em>dfunc</em> 比较 <em>a</em> 和 <em>b</em> (字节串对象列表)；产生以 <em>dfunc</em> 所返回格式表示的差异行列表（也是字节串）。 <em>dfunc</em> 必须是可调用对象，通常为 <code>unified_diff()</code> 或 <code>context_diff()</code>。</p>
<p>允许你比较编码未知或不一致的数据。 除 <em>n</em> 之外的所有输入都必须为字节串对象而非字符串。 作用方式为无损地将所有输入 (除 <em>n</em> 之外) 转换为字符串，并调用 <code>dfunc(a, b, fromfile, tofile, fromfiledate, tofiledate, n, lineterm)</code>。 <em>dfunc</em> 的输出会被随即转换回字节串，这样你所得到的增量行将具有与 <em>a</em> 和 <em>b</em> 相同的未知/不一致编码。</p>
<p>3.5 新版功能.</p>
<p><code>difflib.IS_LINE_JUNK</code>(<em>line</em>)</p>
<p>对于可忽略的行返回 <code>True</code>。 如果 <em>line</em> 为空行或只包含单个 <code>'#'</code> 则 <em>line</em> 行就是可忽略的，否则就是不可忽略的。 此函数被用作较旧版本 <code>ndiff()</code> 中 <em>linejunk</em> 形参的默认值。</p>
<p><code>difflib.IS_CHARACTER_JUNK</code>(<em>ch</em>)</p>
<p>对于可忽略的字符返回 <code>True</code>。 字符 <em>ch</em> 如果为空格符或制表符则 <em>ch</em> 就是可忽略的，否则就是不可忽略的。 此函数被用作 <code>ndiff()</code> 中 <em>charjunk</em> 形参的默认值。</p>
<h3 id="SequenceMatcher-对象"><a href="#SequenceMatcher-对象" class="headerlink" title="SequenceMatcher 对象"></a>SequenceMatcher 对象</h3><p><code>SequenceMatcher</code> 类具有这样的构造器：</p>
<p><em>class</em> <code>difflib.SequenceMatcher</code>(<em>isjunk=None</em>, <em>a=’’</em>, <em>b=’’</em>, <em>autojunk=True</em>)</p>
<p>可选参数 <em>isjunk</em> 必须为 <code>None</code> (默认值) 或为接受一个序列元素并当且仅当其为应忽略的“垃圾”元素时返回真值的单参数函数。 传入 <code>None</code> 作为 <em>isjunk</em> 的值就相当于传入 <code>lambda x: False</code>；也就是说不忽略任何值。 例如，传入:</p>
<pre><code>lambda x: x in " \t"</code></pre><p>如果你以字符序列的形式对行进行比较，并且不希望区分空格符或硬制表符。</p>
<p>可选参数 <em>a</em> 和 <em>b</em> 为要比较的序列；两者默认为空字符串。 两个序列的元素都必须为 hashable。</p>
<p>可选参数 <em>autojunk</em> 可用于启用自动垃圾启发式计算。</p>
<p>3.2 新版功能: <em>autojunk</em> 形参。</p>
<p>SequenceMatcher 对象接受三个数据属性: <em>bjunk</em> 是 <em>b</em> 当中 <em>isjunk</em> 为 <code>True</code> 的元素集合；<em>bpopular</em> 是被启发式计算（如果其未被禁用）视为热门候选的非垃圾元素集合；<em>b2j</em> 是将 <em>b</em> 当中剩余元素映射到一个它们出现位置列表的字典。 所有三个数据属性将在 <em>b</em> 通过 <code>set_seqs()</code> 或 <code>set_seq2()</code> 重置时被重置。</p>
<p>3.2 新版功能: <em>bjunk</em> 和 <em>bpopular</em> 属性。</p>
<p><code>SequenceMatcher</code> 对象具有以下方法：</p>
<ul>
<li><p><code>set_seqs</code>(<em>a</em>, <em>b</em>)</p>
<p>设置要比较的两个序列。</p>
</li>
</ul>
<p><code>SequenceMatcher</code> 计算并缓存有关第二个序列的详细信息，这样如果你想要将一个序列与多个序列进行比较，可使用 <code>set_seq2()</code> 一次性地设置该常用序列并重复地对每个其他序列各调用一次 <code>set_seq1()</code>。</p>
<ul>
<li><p><code>set_seq1</code>(<em>a</em>)</p>
<p>设置要比较的第一个序列。 要比较的第二个序列不会改变。</p>
</li>
<li><p><code>set_seq2</code>(<em>b</em>)</p>
<p>设置要比较的第二个序列。 要比较的第一个序列不会改变。</p>
</li>
<li><p><code>find_longest_match</code>(<em>alo=0</em>, <em>ahi=None</em>, <em>blo=0</em>, <em>bhi=None</em>)</p>
<p>找出 <code>a[alo:ahi]</code> 和 <code>b[blo:bhi]</code> 中的最长匹配块。</p>
<p>如果 <em>isjunk</em> 被省略或为 <code>None</code>，<code>find_longest_match()</code> 将返回 <code>(i, j, k)</code> 使得 <code>a[i:i+k]</code> 等于 <code>b[j:j+k]</code>，其中 <code>alo &lt;= i &lt;= i+k &lt;= ahi</code> 并且 <code>blo &lt;= j &lt;= j+k &lt;= bhi</code>。 对于所有满足这些条件的 <code>(i', j', k')</code>，如果 <code>i == i'</code>, <code>j &lt;= j'</code> 也被满足，则附加条件 <code>k &gt;= k'</code>, <code>i &lt;= i'</code>。 换句话说，对于所有最长匹配块，返回在 <em>a</em> 当中最先出现的一个，而对于在 <em>a</em> 当中最先出现的所有最长匹配块，则返回在 <em>b</em> 当中最先出现的一个。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> SequenceMatcher<span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token string">" abcd"</span><span class="token punctuation">,</span> <span class="token string">"abcd abcd"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>find_longest_match<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>
Match<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果提供了 <em>isjunk</em>，将按上述规则确定第一个最长匹配块，但额外附加不允许块内出现垃圾元素的限制。 然后将通过（仅）匹配两边的垃圾元素来尽可能地扩展该块。 这样结果块绝对不会匹配垃圾元素，除非同样的垃圾元素正好与有意义的匹配相邻。</p>
<p>这是与之前相同的例子，但是将空格符视为垃圾。 这将防止 <code>' abcd'</code> 直接与第二个序列末尾的 <code>' abcd'</code> 相匹配。 而只可以匹配 <code>'abcd'</code>，并且是匹配第二个序列最左边的 <code>'abcd'</code>：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> SequenceMatcher<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token operator">==</span><span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">" abcd"</span><span class="token punctuation">,</span> <span class="token string">"abcd abcd"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>find_longest_match<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>
Match<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果未找到匹配块，此方法将返回 <code>(alo, blo, 0)</code>。</p>
<p>此方法将返回一个 named tuple <code>Match(a, b, size)</code>。</p>
<p>在 3.9 版更改: 加入默认参数。</p>
</li>
<li><p><code>get_matching_blocks</code>()</p>
<p>返回描述非重叠匹配子序列的三元组列表。 每个三元组的形式为 <code>(i, j, n)</code>，其含义为 <code>a[i:i+n] == b[j:j+n]</code>。 这些三元组按 <em>i</em> 和 <em>j</em> 单调递增排列。</p>
<p>最后一个三元组用于占位，其值为 <code>(len(a), len(b), 0)</code>。 它是唯一 <code>n == 0</code> 的三元组。 如果 <code>(i, j, n)</code> 和 <code>(i', j', n')</code> 是在列表中相邻的三元组，且后者不是列表中的最后一个三元组，则 <code>i+n &lt; i'</code> 或 <code>j+n &lt; j'</code>；换句话说，相邻的三元组总是描述非相邻的相等块。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> SequenceMatcher<span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token string">"abxcd"</span><span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>get_matching_blocks<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>Match<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Match<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Match<span class="token punctuation">(</span>a<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>get_opcodes</code>()</p>
<p>返回描述如何将 <em>a</em> 变为 <em>b</em> 的 5 元组列表，每个元组的形式为 <code>(tag, i1, i2, j1, j2)</code>。 在第一个元组中 <code>i1 == j1 == 0</code>，而在其余的元组中 <em>i1</em> 等于前一个元组的 <em>i2*，并且 *j1</em> 也等于前一个元组的 <em>j2</em>。</p>
<p><em>tag</em> 值为字符串，其含义如下：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘replace’</code></td>
<td align="left"><code>a[i1:i2]</code> 应由 <code>b[j1:j2]</code> 替换。</td>
</tr>
<tr>
<td align="left"><code>‘delete’</code></td>
<td align="left"><code>a[i1:i2]</code> 应被删除。 请注意在此情况下 <code>j1 == j2</code>。</td>
</tr>
<tr>
<td align="left"><code>‘insert’</code></td>
<td align="left"><code>b[j1:j2]</code> 应插入到 <code>a[i1:i1]</code>。 请注意在此情况下 <code>i1 == i2</code>。</td>
</tr>
<tr>
<td align="left"><code>‘equal’</code></td>
<td align="left"><code>a[i1:i2] == b[j1:j2]</code> (两个子序列相同)。</td>
</tr>
</tbody></table>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token string">"qabxcd"</span>
<span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> <span class="token string">"abycdf"</span>
<span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> SequenceMatcher<span class="token punctuation">(</span>None<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> tag<span class="token punctuation">,</span> i1<span class="token punctuation">,</span> i2<span class="token punctuation">,</span> j1<span class="token punctuation">,</span> j2 <span class="token keyword">in</span> s<span class="token punctuation">.</span>get_opcodes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'{:7}   a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         tag<span class="token punctuation">,</span> i1<span class="token punctuation">,</span> i2<span class="token punctuation">,</span> j1<span class="token punctuation">,</span> j2<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i1<span class="token punctuation">:</span>i2<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>j1<span class="token punctuation">:</span>j2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
delete    a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>      <span class="token string">'q'</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token string">''</span>
equal     a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span>     <span class="token string">'ab'</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token string">'ab'</span>
replace   a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>      <span class="token string">'x'</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token string">'y'</span>
equal     a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span>     <span class="token string">'cd'</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token string">'cd'</span>
insert    a<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> b<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">]</span>       <span class="token string">''</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token string">'f'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>get_grouped_opcodes</code>(<em>n=3</em>)</p>
<p>返回一个带有最多 <em>n</em> 行上下文的分组的 generator。</p>
<p>从 <code>get_opcodes()</code> 所返回的组开始，此方法会拆分出较小的更改簇并消除没有更改的间隔区域。</p>
<p>这些分组以与 <code>get_opcodes()</code> 相同的格式返回。</p>
</li>
<li><p><code>ratio</code>()</p>
<p>返回一个取值范围 [0, 1] 的浮点数作为序列相似性度量。</p>
<p>其中 T 是两个序列中元素的总数量，M 是匹配的数量，即 2.0*M / T。 请注意如果两个序列完全相同则该值为 <code>1.0</code>，如果两者完全不同则为 <code>0.0</code>。</p>
<p>如果 <code>get_matching_blocks()</code> 或 <code>get_opcodes()</code> 尚未被调用则此方法运算消耗较大，在此情况下你可能需要先调用 <code>quick_ratio()</code> 或 <code>real_quick_ratio()</code> 来获取一个上界。</p>
<p>注解</p>
<p>注意: <code>ratio()</code> 调用的结果可能会取决于参数的顺序。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> SequenceMatcher<span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token string">'tide'</span><span class="token punctuation">,</span> <span class="token string">'diet'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ratio<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">0.25</span>
<span class="token operator">>></span><span class="token operator">></span> SequenceMatcher<span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token string">'diet'</span><span class="token punctuation">,</span> <span class="token string">'tide'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ratio<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">0.5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>quick_ratio</code>()</p>
<p>相对快速地返回一个 <code>ratio()</code> 的上界。</p>
</li>
<li><p><code>real_quick_ratio</code>()</p>
<p>非常快速地返回一个 <code>ratio()</code> 的上界。</p>
</li>
</ul>
<p>这三个返回匹配部分占字符总数的比率的方法可能由于不同的近似级别而给出不一样的结果，但是 <code>quick_ratio()</code> 和 <code>real_quick_ratio()</code> 总是会至少与 <code>ratio()</code> 一样大：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> SequenceMatcher<span class="token punctuation">(</span>None<span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">,</span> <span class="token string">"bcde"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>ratio<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">0.75</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>quick_ratio<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">0.75</span>
<span class="token operator">>></span><span class="token operator">></span> s<span class="token punctuation">.</span>real_quick_ratio<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">1.0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="SequenceMatcher-的示例"><a href="#SequenceMatcher-的示例" class="headerlink" title="SequenceMatcher 的示例"></a>SequenceMatcher 的示例</h3><p>以下示例比较两个字符串，并将空格视为“垃圾”：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> SequenceMatcher<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x <span class="token operator">==</span> <span class="token string">" "</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token string">"private Thread currentThread;"</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                     <span class="token string">"private volatile Thread currentThread;"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><code>ratio()</code> 返回一个 [0, 1] 范围内的整数作为两个序列相似性的度量。 根据经验，<code>ratio()</code> 值超过 0.6 就意味着两个序列是近似匹配的：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>round<span class="token punctuation">(</span>s<span class="token punctuation">.</span>ratio<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">0.866</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果你只对两个序列相匹配的位置感兴趣，则 <code>get_matching_blocks()</code> 就很方便：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> block <span class="token keyword">in</span> s<span class="token punctuation">.</span>get_matching_blocks<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a[%d] and b[%d] match for %d elements"</span> <span class="token operator">%</span> block<span class="token punctuation">)</span>
a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">and</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> match <span class="token keyword">for</span> <span class="token number">8</span> elements
a<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">and</span> b<span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">]</span> match <span class="token keyword">for</span> <span class="token number">21</span> elements
a<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">and</span> b<span class="token punctuation">[</span><span class="token number">38</span><span class="token punctuation">]</span> match <span class="token keyword">for</span> <span class="token number">0</span> elements<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请注意 <code>get_matching_blocks()</code> 返回的最后一个元组总是只用于占位的 <code>(len(a), len(b), 0)</code>，这也是元组末尾元素（匹配的元素数量）为 <code>0</code> 的唯一情况。</p>
<p>如果你想要知道如何将第一个序列转成第二个序列，可以使用 <code>get_opcodes()</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> opcode <span class="token keyword">in</span> s<span class="token punctuation">.</span>get_opcodes<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%6s a[%d:%d] b[%d:%d]"</span> <span class="token operator">%</span> opcode<span class="token punctuation">)</span>
 equal a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span> b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span>
insert a<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">]</span> b<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">17</span><span class="token punctuation">]</span>
 equal a<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">:</span><span class="token number">29</span><span class="token punctuation">]</span> b<span class="token punctuation">[</span><span class="token number">17</span><span class="token punctuation">:</span><span class="token number">38</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参见</p>
<ul>
<li>此模块中的 <code>get_close_matches()</code> 函数显示了如何基于 <code>SequenceMatcher</code> 构建简单的代码来执行有用的功能。</li>
<li>使用 <code>SequenceMatcher</code> 构建小型应用的 简易版本控制方案。</li>
</ul>
<h3 id="Differ-对象"><a href="#Differ-对象" class="headerlink" title="Differ 对象"></a>Differ 对象</h3><p>请注意 <code>Differ</code> 所生成的增量并不保证是 <strong>最小</strong> 差异。 相反，最小差异往往是违反直觉的，因为它们会同步任何可能的地方，有时甚至意外产生相距 100 页的匹配。 将同步点限制为连续匹配保留了一些局部性概念，这偶尔会带来产生更长差异的代价。</p>
<p><code>Differ</code> 类具有这样的构造器：</p>
<p><em>class</em> <code>difflib.Differ</code>(<em>linejunk=None</em>, <em>charjunk=None</em>)</p>
<p>可选关键字形参 <em>linejunk</em> 和 <em>charjunk</em> 均为过滤函数 (或为 <code>None</code>)：</p>
<p><em>linejunk</em>: 接受单个字符串作为参数的函数，如果其为垃圾字符串则返回真值。 默认值为 <code>None</code>，意味着没有任何行会被视为垃圾行。</p>
<p><em>charjunk</em>: 接受单个字符（长度为 1 的字符串）作为参数的函数，如果其为垃圾字符则返回真值。 默认值为 <code>None</code>，意味着没有任何字符会被视为垃圾字符。</p>
<p>这些垃圾过滤函数可加快查找差异的匹配速度，并且不会导致任何差异行或字符被忽略。 </p>
<p><code>Differ</code> 对象是通过一个单独方法来使用（生成增量）的：</p>
<ul>
<li><p><code>compare</code>(<em>a</em>, <em>b</em>)</p>
<p>比较两个由行组成的序列，并生成增量（一个由行组成的序列）。</p>
<p>每个序列必须包含一个以换行符结尾的单行字符串。 这样的序列可以通过文件类对象的 <code>readlines()</code> 方法来获取。 所生成的增量同样由以换行符结尾的字符串构成，可以通过文件类对象的 <code>writelines()</code> 方法原样打印出来。</p>
</li>
</ul>
<h3 id="Differ-示例"><a href="#Differ-示例" class="headerlink" title="Differ 示例"></a>Differ 示例</h3><p>此示例比较两段文本。 首先我们设置文本为以换行符结尾的单行字符串构成的序列（这样的序列也可以通过文件类对象的 <code>readlines()</code> 方法来获取）：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> text1 <span class="token operator">=</span> <span class="token triple-quoted-string string">'''  1. Beautiful is better than ugly.
...   2. Explicit is better than implicit.
...   3. Simple is better than complex.
...   4. Complex is better than complicated.
... '''</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>text1<span class="token punctuation">)</span>
<span class="token number">4</span>
<span class="token operator">>></span><span class="token operator">></span> text1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token string">'\n'</span>
<span class="token operator">>></span><span class="token operator">></span> text2 <span class="token operator">=</span> <span class="token triple-quoted-string string">'''  1. Beautiful is better than ugly.
...   3.   Simple is better than complex.
...   4. Complicated is better than complex.
...   5. Flat is better than nested.
... '''</span><span class="token punctuation">.</span>splitlines<span class="token punctuation">(</span>keepends<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来我们实例化一个 Differ 对象：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> Differ<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>请注意在实例化 <code>Differ</code> 对象时我们可以传入函数来过滤掉“垃圾”行和字符。 </p>
<p>最后，我们比较两个序列：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> result <span class="token operator">=</span> list<span class="token punctuation">(</span>d<span class="token punctuation">.</span>compare<span class="token punctuation">(</span>text1<span class="token punctuation">,</span> text2<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>result</code> 是一个字符串列表，让我们将其美化打印出来：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> pprint <span class="token keyword">import</span> pprint
<span class="token operator">>></span><span class="token operator">></span> pprint<span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'    1. Beautiful is better than ugly.\n'</span><span class="token punctuation">,</span>
 <span class="token string">'-   2. Explicit is better than implicit.\n'</span><span class="token punctuation">,</span>
 <span class="token string">'-   3. Simple is better than complex.\n'</span><span class="token punctuation">,</span>
 <span class="token string">'+   3.   Simple is better than complex.\n'</span><span class="token punctuation">,</span>
 <span class="token string">'?     ++\n'</span><span class="token punctuation">,</span>
 <span class="token string">'-   4. Complex is better than complicated.\n'</span><span class="token punctuation">,</span>
 <span class="token string">'?            ^                     ---- ^\n'</span><span class="token punctuation">,</span>
 <span class="token string">'+   4. Complicated is better than complex.\n'</span><span class="token punctuation">,</span>
 <span class="token string">'?           ++++ ^                      ^\n'</span><span class="token punctuation">,</span>
 <span class="token string">'+   5. Flat is better than nested.\n'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>作为单独的多行字符串显示出来则是这样：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> sys
<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>result<span class="token punctuation">)</span>
    <span class="token number">1</span><span class="token punctuation">.</span> Beautiful <span class="token keyword">is</span> better than ugly<span class="token punctuation">.</span>
<span class="token operator">-</span>   <span class="token number">2</span><span class="token punctuation">.</span> Explicit <span class="token keyword">is</span> better than implicit<span class="token punctuation">.</span>
<span class="token operator">-</span>   <span class="token number">3</span><span class="token punctuation">.</span> Simple <span class="token keyword">is</span> better than complex<span class="token punctuation">.</span>
<span class="token operator">+</span>   <span class="token number">3</span><span class="token punctuation">.</span>   Simple <span class="token keyword">is</span> better than complex<span class="token punctuation">.</span>
?     <span class="token operator">+</span><span class="token operator">+</span>
<span class="token operator">-</span>   <span class="token number">4</span><span class="token punctuation">.</span> Complex <span class="token keyword">is</span> better than complicated<span class="token punctuation">.</span>
?            <span class="token operator">^</span>                     <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span> <span class="token operator">^</span>
<span class="token operator">+</span>   <span class="token number">4</span><span class="token punctuation">.</span> Complicated <span class="token keyword">is</span> better than complex<span class="token punctuation">.</span>
?           <span class="token operator">+</span><span class="token operator">+</span><span class="token operator">+</span><span class="token operator">+</span> <span class="token operator">^</span>                      <span class="token operator">^</span>
<span class="token operator">+</span>   <span class="token number">5</span><span class="token punctuation">.</span> Flat <span class="token keyword">is</span> better than nested<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="difflib-的命令行接口"><a href="#difflib-的命令行接口" class="headerlink" title="difflib 的命令行接口"></a>difflib 的命令行接口</h3><p>这个实例演示了如何使用 difflib 来创建一个类似于 <code>diff</code> 的工具。 它同样包含在 Python 源码发布包中，文件名为 <code>Tools/scripts/diff.py</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python3</span>
<span class="token triple-quoted-string string">""" Command line interface to difflib.py providing diffs in four formats:
* ndiff:    lists every line and highlights interline changes.
* context:  highlights clusters of changes in a before/after format.
* unified:  highlights clusters of changes in an inline format.
* html:     generates side by side comparison with change highlights.
"""</span>
<span class="token keyword">import</span> sys<span class="token punctuation">,</span> os<span class="token punctuation">,</span> difflib<span class="token punctuation">,</span> argparse
<span class="token keyword">from</span> datetime <span class="token keyword">import</span> datetime<span class="token punctuation">,</span> timezone
<span class="token keyword">def</span> <span class="token function">file_mtime</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">:</span>
    t <span class="token operator">=</span> datetime<span class="token punctuation">.</span>fromtimestamp<span class="token punctuation">(</span>os<span class="token punctuation">.</span>stat<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">.</span>st_mtime<span class="token punctuation">,</span>
                               timezone<span class="token punctuation">.</span>utc<span class="token punctuation">)</span>
    <span class="token keyword">return</span> t<span class="token punctuation">.</span>astimezone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>isoformat<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    parser <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-c'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
                        help<span class="token operator">=</span><span class="token string">'Produce a context format diff (default)'</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-u'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
                        help<span class="token operator">=</span><span class="token string">'Produce a unified format diff'</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-m'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
                        help<span class="token operator">=</span><span class="token string">'Produce HTML side by side diff '</span>
                             <span class="token string">'(can use -c and -l in conjunction)'</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-n'</span><span class="token punctuation">,</span> action<span class="token operator">=</span><span class="token string">'store_true'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>
                        help<span class="token operator">=</span><span class="token string">'Produce a ndiff format diff'</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-l'</span><span class="token punctuation">,</span> <span class="token string">'--lines'</span><span class="token punctuation">,</span> type<span class="token operator">=</span>int<span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span>
                        help<span class="token operator">=</span><span class="token string">'Set number of context lines (default 3)'</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'fromfile'</span><span class="token punctuation">)</span>
    parser<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'tofile'</span><span class="token punctuation">)</span>
    options <span class="token operator">=</span> parser<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span>
    n <span class="token operator">=</span> options<span class="token punctuation">.</span>lines
    fromfile <span class="token operator">=</span> options<span class="token punctuation">.</span>fromfile
    tofile <span class="token operator">=</span> options<span class="token punctuation">.</span>tofile
    fromdate <span class="token operator">=</span> file_mtime<span class="token punctuation">(</span>fromfile<span class="token punctuation">)</span>
    todate <span class="token operator">=</span> file_mtime<span class="token punctuation">(</span>tofile<span class="token punctuation">)</span>
    <span class="token keyword">with</span> open<span class="token punctuation">(</span>fromfile<span class="token punctuation">)</span> <span class="token keyword">as</span> ff<span class="token punctuation">:</span>
        fromlines <span class="token operator">=</span> ff<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">with</span> open<span class="token punctuation">(</span>tofile<span class="token punctuation">)</span> <span class="token keyword">as</span> tf<span class="token punctuation">:</span>
        tolines <span class="token operator">=</span> tf<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> options<span class="token punctuation">.</span>u<span class="token punctuation">:</span>
        diff <span class="token operator">=</span> difflib<span class="token punctuation">.</span>unified_diff<span class="token punctuation">(</span>fromlines<span class="token punctuation">,</span> tolines<span class="token punctuation">,</span> fromfile<span class="token punctuation">,</span> tofile<span class="token punctuation">,</span> fromdate<span class="token punctuation">,</span> todate<span class="token punctuation">,</span> n<span class="token operator">=</span>n<span class="token punctuation">)</span>
    <span class="token keyword">elif</span> options<span class="token punctuation">.</span>n<span class="token punctuation">:</span>
        diff <span class="token operator">=</span> difflib<span class="token punctuation">.</span>ndiff<span class="token punctuation">(</span>fromlines<span class="token punctuation">,</span> tolines<span class="token punctuation">)</span>
    <span class="token keyword">elif</span> options<span class="token punctuation">.</span>m<span class="token punctuation">:</span>
        diff <span class="token operator">=</span> difflib<span class="token punctuation">.</span>HtmlDiff<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>make_file<span class="token punctuation">(</span>fromlines<span class="token punctuation">,</span>tolines<span class="token punctuation">,</span>fromfile<span class="token punctuation">,</span>tofile<span class="token punctuation">,</span>context<span class="token operator">=</span>options<span class="token punctuation">.</span>c<span class="token punctuation">,</span>numlines<span class="token operator">=</span>n<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        diff <span class="token operator">=</span> difflib<span class="token punctuation">.</span>context_diff<span class="token punctuation">(</span>fromlines<span class="token punctuation">,</span> tolines<span class="token punctuation">,</span> fromfile<span class="token punctuation">,</span> tofile<span class="token punctuation">,</span> fromdate<span class="token punctuation">,</span> todate<span class="token punctuation">,</span> n<span class="token operator">=</span>n<span class="token punctuation">)</span>
    sys<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>diff<span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="textwrap-—-文本自动换行与填充"><a href="#textwrap-—-文本自动换行与填充" class="headerlink" title="textwrap —- 文本自动换行与填充"></a><code>textwrap</code> —- 文本自动换行与填充</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/textwrap.py" target="_blank" rel="noopener">Lib/textwrap.py</a></p>
<hr>
<p><code>textwrap</code> 模块提供了一些快捷函数，以及可以完成所有工作的类 <code>TextWrapper</code>。 如果你只是要对一两个文本字符串进行自动换行或填充，快捷函数应该就够用了；否则的话，你应该使用 <code>TextWrapper</code> 的实例来提高效率。</p>
<p><code>textwrap.wrap</code>(<em>text</em>, <em>width=70</em>, <em>**,</em> initial_indent=’’<em>,</em> subsequent_indent=’’<em>,</em> expand_tabs=True<em>,</em> replace_whitespace=True<em>,</em> fix_sentence_endings=False<em>,</em> break_long_words=True<em>,</em> drop_whitespace=True<em>,</em> break_on_hyphens=True<em>,</em> tabsize=8<em>,</em> max_lines=None*)</p>
<p>对 <em>text</em> (字符串) 中的单独段落自动换行以使每行长度最多为 <em>width</em> 个字符。 返回由输出行组成的列表，行尾不带换行符。</p>
<p>与 <code>TextWrapper</code> 的实例属性对应的可选的关键字参数，具体文档见下。</p>
<p><code>textwrap.fill</code>(<em>text</em>, <em>width=70</em>, <em>**,</em> initial_indent=’’<em>,</em> subsequent_indent=’’<em>,</em> expand_tabs=True<em>,</em> replace_whitespace=True<em>,</em> fix_sentence_endings=False<em>,</em> break_long_words=True<em>,</em> drop_whitespace=True<em>,</em> break_on_hyphens=True<em>,</em> tabsize=8<em>,</em> max_lines=None*)</p>
<p>对 <em>text</em> 中的单独段落自动换行，并返回一个包含被自动换行段落的单独字符串。 <code>fill()</code> 是以下语句的快捷方式</p>
<pre><code>"\n".join(wrap(text, ...))</code></pre><p>特别要说明的是，<code>fill()</code> 接受与 <code>wrap()</code> 完全相同的关键字参数。</p>
<p><code>textwrap.shorten</code>(<em>text</em>, <em>width</em>, <em>**,</em> fix_sentence_endings=False<em>,</em> break_long_words=True<em>,</em> break_on_hyphens=True<em>,</em> placeholder=’ […]‘*)</p>
<p>折叠并截短给定的 <em>text</em> 以符合给定的 <em>width</em>。</p>
<p>首先，将折叠 <em>text</em> 中的空格（所有连续空格替换为单个空格）。 如果结果能适合 <em>width</em> 则将其返回。 否则将丢弃足够数量的末尾单词以使得剩余单词加 <code>placeholder</code> 能适合 <code>width</code>：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> textwrap<span class="token punctuation">.</span>shorten<span class="token punctuation">(</span><span class="token string">"Hello  world!"</span><span class="token punctuation">,</span> width<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">)</span>
<span class="token string">'Hello world!'</span>
<span class="token operator">>></span><span class="token operator">></span> textwrap<span class="token punctuation">.</span>shorten<span class="token punctuation">(</span><span class="token string">"Hello  world!"</span><span class="token punctuation">,</span> width<span class="token operator">=</span><span class="token number">11</span><span class="token punctuation">)</span>
<span class="token string">'Hello [...]'</span>
<span class="token operator">>></span><span class="token operator">></span> textwrap<span class="token punctuation">.</span>shorten<span class="token punctuation">(</span><span class="token string">"Hello world"</span><span class="token punctuation">,</span> width<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> placeholder<span class="token operator">=</span><span class="token string">"..."</span><span class="token punctuation">)</span>
<span class="token string">'Hello...'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可选的关键字参数对应于 <code>TextWrapper</code> 的实际属性，具体见下文。 请注意文本在被传入 <code>TextWrapper</code> 的 <code>fill()</code> 函数之前会被折叠，因此改变 <code>tabsize</code>, <code>expand_tabs</code>, <code>drop_whitespace</code> 和 <code>replace_whitespace</code> 的值将没有任何效果。</p>
<p>3.4 新版功能.</p>
<p><code>textwrap.dedent</code>(<em>text</em>)</p>
<p>移除 <em>text</em> 中每一行的任何相同前缀空白符。</p>
<p>这可以用来清除三重引号字符串行左侧空格，而仍然在源码中显示为缩进格式。</p>
<p>请注意制表符和空格符都被视为是空白符，但它们并不相等：以下两行 <code>" hello"</code> 和 <code>"\thello"</code> 不会被视为具有相同的前缀空白符。</p>
<p>只包含空白符的行会在输入时被忽略并在输出时被标准化为单个换行符。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># end first line with \ to avoid the empty line!</span>
    s <span class="token operator">=</span> <span class="token triple-quoted-string string">'''\
    hello
      world
    '''</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># prints '    hello\n      world\n    '</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>dedent<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># prints 'hello\n  world\n'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>textwrap.indent</code>(<em>text</em>, <em>prefix</em>, <em>predicate=None</em>)</p>
<p>将 <em>prefix</em> 添加到 <em>text</em> 中选定行的开头。</p>
<p>通过调用 <code>text.splitlines(True)</code> 来对行进行拆分。</p>
<p>默认情况下，<em>prefix</em> 会被添加到所有不是只由空白符（包括任何行结束符）组成的行。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">'hello\n\n \nworld'</span>
<span class="token operator">>></span><span class="token operator">></span> indent<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">'  '</span><span class="token punctuation">)</span>
<span class="token string">'  hello\n\n \n  world'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可选的 <em>predicate</em> 参数可用来控制哪些行要缩进。 例如，可以很容易地为空行或只有空白符的行添加 <em>prefix</em>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>indent<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">'+ '</span><span class="token punctuation">,</span> <span class="token keyword">lambda</span> line<span class="token punctuation">:</span> <span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">+</span> hello
<span class="token operator">+</span>
<span class="token operator">+</span>
<span class="token operator">+</span> world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.3 新版功能.</p>
<p><code>wrap()</code>, <code>fill()</code> 和 <code>shorten()</code> 的作用方式为创建一个 <code>TextWrapper</code> 实例并在其上调用单个方法。 该实例不会被重用，因此对于要使用 <code>wrap()</code> 和/或 <code>fill()</code> 来处理许多文本字符串的应用来说，创建你自己的 <code>TextWrapper</code> 对象可能会更有效率。</p>
<p>文本最好在空白符位置自动换行，包括带连字符单词的连字符之后；长单词仅在必要时会被拆分，除非 <code>TextWrapper.break_long_words</code> 被设为假值。</p>
<p><em>class</em> <code>textwrap.TextWrapper</code>(<em>**kwargs</em>)</p>
<p><code>TextWrapper</code> 构造器接受多个可选的关键字参数。 每个关键字参数对应一个实例属性，比如说</p>
<pre class="line-numbers language-python"><code class="language-python">wrapper <span class="token operator">=</span> TextWrapper<span class="token punctuation">(</span>initial_indent<span class="token operator">=</span><span class="token string">"* "</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>相当于：</p>
<pre class="line-numbers language-python"><code class="language-python">wrapper <span class="token operator">=</span> TextWrapper<span class="token punctuation">(</span><span class="token punctuation">)</span>
wrapper<span class="token punctuation">.</span>initial_indent <span class="token operator">=</span> <span class="token string">"* "</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>你可以多次重用相同的 <code>TextWrapper</code> 对象，并且你也可以在使用期间通过直接向实例属性赋值来修改它的任何选项。</p>
<p><code>TextWrapper</code> 的实例属性（以及构造器的关键字参数）如下所示：</p>
<ul>
<li><p><code>width</code></p>
<p>(默认: <code>70</code>) 自动换行的最大行长度。 只要输入文本中没有长于 <code>width</code> 的单个单词，<code>TextWrapper</code> 就能保证没有长于 <code>width</code> 个字符的输出行。</p>
</li>
<li><p><code>expand_tabs</code></p>
<p>(默认: <code>True</code>) 如果为真值，则 <em>text</em> 中所有的制表符将使用 <em>text</em> 的 <code>expandtabs()</code> 方法扩展为空格符。</p>
</li>
<li><p><code>tabsize</code></p>
<p>(默认: <code>8</code>) 如果 <code>expand_tabs</code> 为真值，则 <em>text</em> 中所有的制表符将扩展为零个或多个空格，具体取决于当前列位置和给定的制表宽度。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>replace_whitespace</code></p>
<p>(default: <code>True</code>) 如果为真值，在制表符扩展之后、自动换行之前，<code>wrap()</code> 方法将把每个空白字符都替换为单个空格。 会被替换的空白字符如下：制表，换行，垂直制表，进纸和回车 (<code>'\t\n\v\f\r'</code>)。</p>
<p>注解</p>
<p>如果 <code>expand_tabs</code> 为假值且 <code>replace_whitespace</code> 为真值，每个制表符将被替换为单个空格，这与制表符扩展是 <em>不</em> 一样的。</p>
<p>注解</p>
<p>如果 <code>replace_whitespace</code> 为假值，在一行的中间有可能出现换行符并导致怪异的输出。 因此，文本应当（使用 <code>str.splitlines()</code> 或类似方法）拆分为段落并分别进行自动换行。</p>
</li>
<li><p><code>drop_whitespace</code></p>
<p>(默认: <code>True</code>) 如果为真值，每一行开头和末尾的空白字符（在包装之后、缩进之前）会被丢弃。 但是段落开头的空白字符如果后面不带任何非空白字符则不会被丢弃。 如果被丢弃的空白字符占据了一个整行，则该整行将被丢弃。</p>
</li>
<li><p><code>initial_indent</code></p>
<p>(默认: <code>''</code>) 将被添加到被自动换行输出内容的第一行的字符串。 其长度会被计入第一行的长度。 空字符串不会被缩进。</p>
</li>
<li><p><code>subsequent_indent</code></p>
<p>(default: <code>''</code>) 将被添加到被自动换行输出内容除第一行外的所有行的字符串。 其长度会被计入除行一行外的所有行的长度。</p>
</li>
<li><p><code>fix_sentence_endings</code></p>
<p>(默认: <code>False</code>) 如果为真值，<code>TextWrapper</code> 将尝试检测句子结尾并确保句子间总是以恰好两个空格符分隔。 对于使用等宽字体的文本来说通常都需要这样。 但是，句子检测算法并不完美：它假定句子结尾是一个小写字母加字符 <code>'.'</code>, <code>'!'</code> 或 <code>'?'</code> 中的一个，并可能带有字符 <code>'"'</code> 或 <code>"'"</code>，最后以一个空格结束。 此算法的问题之一是它无法区分以下文本中的 “Dr.”</p>
<pre><code>[...] Dr. Frankenstein's monster [...]</code></pre><p>和以下文本中的 “Spot.”</p>
<pre><code>[...] See Spot. See Spot run [...]</code></pre><p><code>fix_sentence_endings</code> 默认为假值。</p>
<p>由于句子检测算法依赖于 <code>string.lowercase</code> 来确定“小写字母”，以及约定在句点后使用两个空格来分隔处于同一行的句子，因此只适用于英语文本。</p>
</li>
<li><p><code>break_long_words</code></p>
<p>(默认: <code>True</code>) 如果为真值，则长度超过 <code>width</code> 的单词将被分开以保证行的长度不会超过 <code>width</code>。 如果为假值，超长单词不会被分开，因而某些行的长度可能会超过 <code>width</code>。 （超长单词将被单独作为一行，以尽量减少超出 <code>width</code> 的情况。）</p>
</li>
<li><p><code>break_on_hyphens</code></p>
<p>(默认: <code>True</code>) 如果为真值，将根据英语的惯例首选在空白符和复合词的连字符之后自动换行。 如果为假值，则只有空白符会被视为合适的潜在断行位置，但如果你确实不希望出现分开的单词则你必须将 <code>break_long_words</code> 设为假值。 之前版本的默认行为总是允许分开带有连字符的单词。</p>
</li>
<li><p><code>max_lines</code></p>
<p>(默认: <code>None</code>) 如果不为 <code>None</code>，则输出内容将最多包含 <em>max_lines</em> 行，并使 <em>placeholder</em> 出现在输出内容的末尾。</p>
<p>3.4 新版功能.</p>
</li>
<li><p><code>placeholder</code></p>
<p>(默认: <code>' [...]'</code>) 该文本将在输出文本被截短时出现在文本末尾。</p>
<p>3.4 新版功能.</p>
</li>
</ul>
<p><code>TextWrapper</code> 还提供了一些公有方法，类似于模块层级的便捷函数：</p>
<ul>
<li><p><code>wrap</code>(<em>text</em>)</p>
<p>对 <em>text</em> (字符串) 中的单独段落自动换行以使每行长度最多为 <code>width</code> 个字符。 所有自动换行选项均获取自 <code>TextWrapper</code> 实例的实例属性。 返回由输出行组成的列表，行尾不带换行符。 如果自动换行输出结果没有任何内容，则返回空列表。</p>
</li>
<li><p><code>fill</code>(<em>text</em>)</p>
<p>对 <em>text</em> 中的单独段落自动换行并返回包含被自动换行段落的单独字符串。</p>
</li>
</ul>
<h2 id="unicodedata-—-Unicode-数据库"><a href="#unicodedata-—-Unicode-数据库" class="headerlink" title="unicodedata —- Unicode 数据库"></a><code>unicodedata</code> —- Unicode 数据库</h2><p>此模块提供了对 Unicode Character Database (UCD) 的访问，其中定义了所有 Unicode 字符的字符属性。 此数据库中包含的数据编译自 <a href="https://www.unicode.org/Public/13.0.0/ucd" target="_blank" rel="noopener">UCD 版本 13.0.0</a>。</p>
<p>该模块使用与 Unicode 标准附件 #44 <a href="https://www.unicode.org/reports/tr44/" target="_blank" rel="noopener">“Unicode 字符数据库”</a> 中所定义的相同名称和符号。 它定义了以下函数：</p>
<p><code>unicodedata.lookup</code>(<em>name</em>)</p>
<p>按名称查找字符。如果找到具有给定名称的字符，则返回相应的字符。 如果没有找到，则 <code>KeyError</code> 被引发。</p>
<p>在 3.3 版更改: 已添加对名称<a href="https://www.unicode.org/Public/13.0.0/ucd/NameAliases.txt" target="_blank" rel="noopener">别名</a> 和<a href="https://www.unicode.org/Public/13.0.0/ucd/NamedSequences.txt" target="_blank" rel="noopener">命名序列</a> 的支持。</p>
<p><code>unicodedata.name</code>(<em>chr</em>[, <em>default</em>])</p>
<p>返回分配给字符 <em>chr</em> 的名称作为字符串。如果没有定义名称，则返回 <em>default</em> ，如果没有给出，则 <code>ValueError</code> 被引发。</p>
<p><code>unicodedata.decimal</code>(<em>chr</em>[, <em>default</em>])</p>
<p>返回分配给字符 <em>chr</em> 的十进制值作为整数。 如果没有定义这样的值，则返回 <em>default</em> ，如果没有给出，则 <code>ValueError</code> 被引发。</p>
<p><code>unicodedata.digit</code>(<em>chr</em>[, <em>default</em>])</p>
<p>返回分配给字符 <em>chr</em> 的数字值作为整数。 如果没有定义这样的值，则返回 <em>default</em> ，如果没有给出，则 <code>ValueError</code> 被引发。</p>
<p><code>unicodedata.numeric</code>(<em>chr</em>[, <em>default</em>])</p>
<p>返回分配给字符 <em>chr</em> 的数值作为浮点数。 如果没有定义这样的值，则返回 <em>default</em> ，如果没有给出，则 <code>ValueError</code> 被引发。</p>
<p><code>unicodedata.category</code>(<em>chr</em>)</p>
<p>返回分配给字符 <em>chr</em> 的常规类别为字符串。</p>
<p><code>unicodedata.bidirectional</code>(<em>chr</em>)</p>
<p>返回分配给字符 <em>chr</em> 的双向类作为字符串。如果未定义此类值，则返回空字符串。</p>
<p><code>unicodedata.combining</code>(<em>chr</em>)</p>
<p>返回分配给字符 <em>chr</em> 的规范组合类作为整数。如果没有定义组合类，则返回 <code>0</code> 。</p>
<p><code>unicodedata.east_asian_width</code>(<em>chr</em>)</p>
<p>返回分配给字符 <em>chr</em> 的东亚宽度作为字符串。</p>
<p><code>unicodedata.mirrored</code>(<em>chr</em>)</p>
<p>返回分配给字符 <em>chr</em> 的镜像属性为整数。如果字符在双向文本中被识别为“镜像”字符，则返回 <code>1</code> ，否则返回 <code>0</code> 。</p>
<p><code>unicodedata.decomposition</code>(<em>chr</em>)</p>
<p>返回分配给字符 <em>chr</em> 的字符分解映射作为字符串。如果未定义此类映射，则返回空字符串。</p>
<p><code>unicodedata.normalize</code>(<em>form</em>, <em>unistr</em>)</p>
<p>返回 Unicode 字符串 <em>unistr</em> 的正常形式 <em>form</em> 。 <em>form</em> 的有效值为 ‘NFC’ 、 ‘NFKC’ 、 ‘NFD’ 和 ‘NFKD’ 。</p>
<p>Unicode 标准基于规范等价和兼容性等效的定义定义了 Unicode 字符串的各种规范化形式。在 Unicode 中，可以以各种方式表示多个字符。 例如，字符 U+00C7 （带有 CEDILLA 的 LATIN CAPITAL LETTER C ）也可以表示为序列 U+0043（ LATIN CAPITAL LETTER C ）U+0327（ COMBINING CEDILLA ）。</p>
<p>对于每个字符，有两种正规形式：正规形式 C 和正规形式 D 。正规形式D（NFD）也称为规范分解，并将每个字符转换为其分解形式。 正规形式C（NFC）首先应用规范分解，然后再次组合预组合字符。</p>
<p>除了这两种形式之外，还有两种基于兼容性等效的其他常规形式。 在 Unicode 中，支持某些字符，这些字符通常与其他字符统一。 例如， U+2160（ROMAN NUMERAL ONE）与 U+0049（LATIN CAPITAL LETTER I）完全相同。 但是， Unicode 支持它与现有字符集（例如 gb2312 ）的兼容性。</p>
<p>正规形式KD（NFKD）将应用兼容性分解，即用其等价项替换所有兼容性字符。 正规形式KC（NFKC）首先应用兼容性分解，然后是规范组合。</p>
<p>即使两个 unicode 字符串被规范化并且人类读者看起来相同，如果一个具有组合字符而另一个没有，则它们可能无法相等。</p>
<p><code>unicodedata.is_normalized</code>(<em>form</em>, <em>unistr</em>)</p>
<p>判断 Unicode 字符串 <em>unistr</em> 是否为正规形式 <em>form*。 *form</em> 的有效值为 ‘NFC’, ‘NFKC’, ‘NFD’ 和 ‘NFKD’。</p>
<p>3.8 新版功能.</p>
<p>此外，该模块暴露了以下常量：</p>
<pre><code>unicodedata.unidata_version</code></pre><p>此模块中使用的 Unicode 数据库的版本。</p>
<pre><code>unicodedata.ucd_3_2_0</code></pre><p>这是一个与整个模块具有相同方法的对象，但对于需要此特定版本的 Unicode 数据库（如 IDNA ）的应用程序，则使用 Unicode 数据库版本 3.2 。</p>
<p>示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> unicodedata
<span class="token operator">>></span><span class="token operator">></span> unicodedata<span class="token punctuation">.</span>lookup<span class="token punctuation">(</span><span class="token string">'LEFT CURLY BRACKET'</span><span class="token punctuation">)</span>
<span class="token string">'{'</span>
<span class="token operator">>></span><span class="token operator">></span> unicodedata<span class="token punctuation">.</span>name<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token string">'SOLIDUS'</span>
<span class="token operator">>></span><span class="token operator">></span> unicodedata<span class="token punctuation">.</span>decimal<span class="token punctuation">(</span><span class="token string">'9'</span><span class="token punctuation">)</span>
<span class="token number">9</span>
<span class="token operator">>></span><span class="token operator">></span> unicodedata<span class="token punctuation">.</span>decimal<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
ValueError<span class="token punctuation">:</span> <span class="token operator">not</span> a decimal
<span class="token operator">>></span><span class="token operator">></span> unicodedata<span class="token punctuation">.</span>category<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 'L'etter, 'u'ppercase</span>
<span class="token string">'Lu'</span>
<span class="token operator">>></span><span class="token operator">></span> unicodedata<span class="token punctuation">.</span>bidirectional<span class="token punctuation">(</span><span class="token string">'\u0660'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 'A'rabic, 'N'umber</span>
<span class="token string">'AN'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="stringprep-—-因特网字符串预备"><a href="#stringprep-—-因特网字符串预备" class="headerlink" title="stringprep —- 因特网字符串预备"></a><code>stringprep</code> —- 因特网字符串预备</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/stringprep.py" target="_blank" rel="noopener">Lib/stringprep.py</a></p>
<hr>
<p>在标识因特网上的事物（例如主机名），经常需要比较这些标识是否（相等）。 这种比较的具体执行可能会取决于应用域的不同，例如是否要区分大小写等等。 有时也可能需要限制允许的标识为仅由“可打印”字符组成。</p>
<p><a href="https://tools.ietf.org/html/rfc3454.html" target="_blank" rel="noopener"><strong>RFC 3454</strong></a> 定义了在因特网协议中 Unicode 字符串的“预备”过程。 在将字符串连线传输之前，它们会先使用预备过程进行处理，之后它们将具有特定的标准形式。 该 RFC 定义了一系列表格，它们可以被组合为选项配置。 每个配置必须定义所使用的表格，<code>stringprep</code> 过程的其他可选项也是配置的组成部分。 <code>stringprep</code> 配置的一个例子是 <code>nameprep</code>，它被用于国际化域名。</p>
<p>模块 <code>stringprep</code> 仅公开了来自 <a href="https://tools.ietf.org/html/rfc3454.html" target="_blank" rel="noopener"><strong>RFC 3454</strong></a> 的表格。 由于这些如果表格如果表示为字典或列表将会非常庞大，该模块在内部使用 Unicode 字符数据库。 该模块本身的源代码是使用 <code>mkstringprep.py</code> 工具生成的。</p>
<p>因此，这些表格以函数而非数据结构的形式公开。 在 RFC 中有两种表格：集合与映射。 对于集合，<code>stringprep</code> 提供了“特征函数”，即如果形参是集合的一部分则返回值为 <code>True</code> 的函数。 对于映射，它提供了映射函数：它会根据给定的键返回所关联的值。 以下是模块中所有可用函数的列表。</p>
<p><code>stringprep.in_table_a1</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableA.1 (Unicode 3.2 中的未分配码位)。</p>
<p><code>stringprep.in_table_b1</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableB.1 (通常映射为空值)。</p>
<p><code>stringprep.map_table_b2</code>(<em>code</em>)</p>
<p>返回 <em>code</em> 依据 tableB.2 (配合 NFKC 使用的大小写转换映射) 所映射的值。</p>
<p><code>stringprep.map_table_b3</code>(<em>code</em>)</p>
<p>返回 <em>code</em> 依据 tableB.3 (不附带正规化的大小写折叠映射) 所映射的值。</p>
<p><code>stringprep.in_table_c11</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.1.1 (ASCII 空白字符)。</p>
<p><code>stringprep.in_table_c12</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.1.2 (非 ASCII 空白字符)。</p>
<p><code>stringprep.in_table_c11_c12</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.1 (空白字符，C.1.1 和 C.1.2 的并集)。</p>
<p><code>stringprep.in_table_c21</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.2.1 (ASCII 控制字符)。</p>
<p><code>stringprep.in_table_c22</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.2.2 (非 ASCII 控制字符)。</p>
<p><code>stringprep.in_table_c21_c22</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.2 (控制字符，C.2.1 和 C.2.2 的并集)。</p>
<p><code>stringprep.in_table_c3</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.3 (私有使用)。</p>
<p><code>stringprep.in_table_c4</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.4 (非字符码位)。</p>
<p><code>stringprep.in_table_c5</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.5 (替代码)。</p>
<p><code>stringprep.in_table_c6</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.6 (不适用于纯文本)。</p>
<p><code>stringprep.in_table_c7</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.7 (不适用于规范表示)。</p>
<p><code>stringprep.in_table_c8</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.8 (改变显示属性或已弃用)。</p>
<p><code>stringprep.in_table_c9</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableC.9 (标记字符)。</p>
<p><code>stringprep.in_table_d1</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableD.1 (带有双向属性 “R” 或 “AL” 的字符)。</p>
<p><code>stringprep.in_table_d2</code>(<em>code</em>)</p>
<p>确定 <em>code</em> 是否属于 tableD.2 (带有双向属性 “L” 的字符)。</p>
<h2 id="readline-—-GNU-readline-接口"><a href="#readline-—-GNU-readline-接口" class="headerlink" title="readline —- GNU readline 接口"></a><code>readline</code> —- GNU readline 接口</h2><hr>
<p><code>readline</code> 模块定义了许多方便从 Python 解释器完成和读取/写入历史文件的函数。 此模块可以直接使用，或通过支持在交互提示符下完成 Python 标识符的 <code>rlcompleter</code> 模块使用。 使用此模块进行的设置会同时影响解释器的交互提示符以及内置 <code>input()</code> 函数提供的提示符。</p>
<p>Readline keybindings may be configured via an initialization file, typically <code>.inputrc</code> in your home directory. See Readline Init File in the GNU Readline manual for information about the format and allowable constructs of that file, and the capabilities of the Readline library in general.</p>
<p>注解</p>
<p>底层的 Readline 库 API 可能使用 <code>libedit</code> 库来实现而不是 GNU readline。 在 macOS 上 <code>readline</code> 模块会在运行时检测所使用的是哪个库。</p>
<p><code>libedit</code> 所用的配置文件与 GNU readline 的不同。 如果你要在程序中载入配置字符串你可以在 <code>readline.__doc__</code> 中检测文本 “libedit” 来区分 GNU readline 和 libedit。</p>
<p>如果你是在 macOS 上使用 <em>editline</em>/<code>libedit</code> readline 模拟，则位于你的主目录中的初始化文件名称为 <code>.editrc</code>。 例如，<code>~/.editrc</code> 中的以下内容将开启 <em>vi</em> 按键绑定以及 TAB 补全:</p>
<pre><code>python:bind -vpython:bind ^I rl_complete</code></pre><h3 id="初始化文件"><a href="#初始化文件" class="headerlink" title="初始化文件"></a>初始化文件</h3><p>下列函数与初始化文件和用户配置有关：</p>
<p><code>readline.parse_and_bind</code>(<em>string</em>)</p>
<p>执行在 <em>string</em> 参数中提供的初始化行。 此函数会调用底层库中的 <code>rl_parse_and_bind()</code>。</p>
<p><code>readline.read_init_file</code>([<em>filename</em>])</p>
<p>执行一个 readline 初始化文件。 默认文件名为最近所使用的文件名。 此函数会调用底层库中的 <code>rl_read_init_file()</code>。</p>
<h3 id="行缓冲区"><a href="#行缓冲区" class="headerlink" title="行缓冲区"></a>行缓冲区</h3><p>下列函数会在行缓冲区上操作。</p>
<p><code>readline.get_line_buffer</code>()</p>
<p>返回行缓冲区的当前内容 (底层库中的 <code>rl_line_buffer</code>)。</p>
<p><code>readline.insert_text</code>(<em>string</em>)</p>
<p>将文本插入行缓冲区的当前游标位置。 该函数会调用底层库中的 <code>rl_insert_text()</code>，但会忽略其返回值。</p>
<p><code>readline.redisplay</code>()</p>
<p>改变屏幕的显示以反映行缓冲区的当前内容。 该函数会调用底层库中的 <code>rl_redisplay()</code>。</p>
<h3 id="历史文件"><a href="#历史文件" class="headerlink" title="历史文件"></a>历史文件</h3><p>下列函数会在历史文件上操作：</p>
<p><code>readline.read_history_file</code>([<em>filename</em>])</p>
<p>载入一个 readline 历史文件，并将其添加到历史列表。 默认文件名为 <code>~/.history</code>。 此函数会调用底层库中的 <code>read_history()</code>。</p>
<p><code>readline.write_history_file</code>([<em>filename</em>])</p>
<p>将历史列表保存为 readline 历史文件，覆盖任何现有文件。 默认文件名为 <code>~/.history</code>。 此函数会调用底层库中的 <code>write_history()</code>。</p>
<p><code>readline.append_history_file</code>(<em>nelements</em>[, <em>filename</em>])</p>
<p>将历史列表的最后 <em>nelements</em> 项添加到历史文件。 默认文件名为 <code>~/.history</code>。 文件必须已存在。 此函数会调用底层库中的 <code>append_history()</code>。 此函数仅当 Python 编译包带有支持此功能的库版本时才会存在。</p>
<p>3.5 新版功能.</p>
<p><code>readline.get_history_length</code>()</p>
<p><code>readline.set_history_length</code>(<em>length</em>)</p>
<p>设置或返回需要保存到历史文件的行数。 <code>write_history_file()</code> 函数会通过调用底层库中的 <code>history_truncate_file()</code> 以使用该值来截取历史文件。 负值意味着不限制历史文件的大小。</p>
<h3 id="历史列表"><a href="#历史列表" class="headerlink" title="历史列表"></a>历史列表</h3><p>以下函数会在全局历史列表上操作：</p>
<p><code>readline.clear_history</code>()</p>
<p>清除当前历史。 此函数会调用底层库的 <code>clear_history()</code>。 此 Python 函数仅当 Python 编译包带有支持此功能的库版本时才会存在。</p>
<p><code>readline.get_current_history_length</code>()</p>
<p>返回历史列表的当前项数。 （此函数不同于 <code>get_history_length()</code>，后者是返回将被写入历史文件的最大行数。）</p>
<p><code>readline.get_history_item</code>(<em>index</em>)</p>
<p>返回序号为 <em>index</em> 的历史条目的当前内容。 条目序号从一开始。 此函数会调用底层库中的 <code>history_get()</code>。</p>
<p><code>readline.remove_history_item</code>(<em>pos</em>)</p>
<p>从历史列表中移除指定位置上的历史条目。 条目位置从零开始。 此函数会调用底层库中的 <code>remove_history()</code>。</p>
<p><code>readline.replace_history_item</code>(<em>pos</em>, <em>line</em>)</p>
<p>将指定位置上的历史条目替换为 <em>line</em>。 条目位置从零开始。 此函数会调用底层库中的 <code>replace_history_entry()</code>。</p>
<p><code>readline.add_history</code>(<em>line</em>)</p>
<p>将 <em>line</em> 添加到历史缓冲区，相当于是最近输入的一行。 此函数会调用底层库中的 <code>add_history()</code>。</p>
<p><code>readline.set_auto_history</code>(<em>enabled</em>)</p>
<p>启用或禁用当通过 readline 读取输入时自动调用 <code>add_history()</code>。 <em>enabled</em> 参数应为一个布尔值，当其为真值时启用自动历史，当其为假值时禁用自动历史。</p>
<p>3.6 新版功能.</p>
<p><strong>CPython implementation detail:</strong> Auto history is enabled by default, and changes to this do not persist across multiple sessions.</p>
<h3 id="启动钩子"><a href="#启动钩子" class="headerlink" title="启动钩子"></a>启动钩子</h3><p><code>readline.set_startup_hook</code>([<em>function</em>])</p>
<p>设置或移除底层库的 <code>rl_startup_hook</code> 回调所发起调用的函数。 如果指定了 <em>function</em>，它将被用作新的钩子函数；如果省略或为 <code>None</code>，任何已安装的函数将被移除。 钩子函数将在 readline 打印第一个提示信息之前不带参数地被调用。</p>
<p><code>readline.set_pre_input_hook</code>([<em>function</em>])</p>
<p>设置或移除底层库的 <code>rl_pre_input_hook</code> 回调所发起调用的函数。 如果指定了 <em>function</em>，它将被用作新的钩子函数；如果省略或为 <code>None</code>，任何已安装的函数将被移除。 钩子函数将在打印第一个提示信息之后、readline 开始读取输入字符之前不带参数地被调用。 此函数仅当 Python 编译包带有支持此功能的库版本时才会存在。</p>
<h3 id="Completion"><a href="#Completion" class="headerlink" title="Completion"></a>Completion</h3><p>以下函数与自定义单词补全函数的实现有关。 这通常使用 Tab 键进行操作，能够提示并自动补全正在输入的单词。 默认情况下，Readline 设置为由 <code>rlcompleter</code> 来补全交互模式解释器的 Python 标识符。 如果 <code>readline</code> 模块要配合自定义的补全函数来使用，则需要设置不同的单词分隔符。</p>
<p><code>readline.set_completer</code>([<em>function</em>])</p>
<p>设置或移除补全函数。 如果指定了 <em>function*，它将被用作新的补全函数；如果省略或为 <code>None</code>，任何已安装的补全函数将被移除。 补全函数的调用形式为 <code>function(text, state)</code>，其中 *state</em> 为 <code>0</code>, <code>1</code>, <code>2</code>, …, 直至其返回一个非字符串值。 它应当返回下一个以 <em>text</em> 开头的候选补全内容。</p>
<p>已安装的补全函数将由传递给底层库中 <code>rl_completion_matches()</code> 的 <em>entry_func</em> 回调函数来发起调用。 <em>text</em> 字符串来自于底层库中 <code>rl_attempted_completion_function</code> 回调函数的第一个形参。</p>
<p><code>readline.get_completer</code>()</p>
<p>获取补全函数，如果没有设置补全函数则返回 <code>None</code>。</p>
<p><code>readline.get_completion_type</code>()</p>
<p>获取正在尝试的补全类型。 此函数会将底层库中的 <code>rl_completion_type</code> 变量作为一个整数返回。</p>
<p><code>readline.get_begidx</code>()</p>
<p><code>readline.get_endidx</code>()</p>
<p>获取完全范围的开始和结束索引号。 这些索引号就是传递给下层库的 <code>rl_attempted_completion_function</code> 回调的 <em>start</em> 和 <em>end</em> 参数。 具体值在同一个输入编辑场景中可能不同，具体取决于下层的 C readline 实现。 例如：已知 libedit 的行为就不同于 libreadline。</p>
<p><code>readline.set_completer_delims</code>(<em>string</em>)</p>
<p><code>readline.get_completer_delims</code>()</p>
<p>设置或获取补全的单词分隔符。 此分隔符确定了要考虑补全的单词的开始和结束位置（补全域）。 这些函数会访问底层库的 <code>rl_completer_word_break_characters</code> 变量。</p>
<p><code>readline.set_completion_display_matches_hook</code>([<em>function</em>])</p>
<p>设置或移除补全显示函数。 如果指定了 <em>function</em>，它将被用作新的补全显示函数；如果省略或为 <code>None</code>，任何已安装的补全显示函数将被移除。 此函数会设置或清除底层库的 <code>rl_completion_display_matches_hook</code> 回调函数。 补全显示函数会在每次需要显示匹配项时以 <code>function(substitution, [matches], longest_match_length)</code> 的形式被调用。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下示例演示了如何使用 <code>readline</code> 模块的历史读取或写入函数来自动加载和保存用户主目录下名为 <code>.python_history</code> 的历史文件。 以下代码通常应当在交互会话期间从用户的 <code>PYTHONSTARTUP</code> 文件自动执行。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> atexit
<span class="token keyword">import</span> os
<span class="token keyword">import</span> readline
histfile <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span><span class="token string">"~"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">".python_history"</span><span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    readline<span class="token punctuation">.</span>read_history_file<span class="token punctuation">(</span>histfile<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># default history len is -1 (infinite), which may grow unruly</span>
    readline<span class="token punctuation">.</span>set_history_length<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> FileNotFoundError<span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
atexit<span class="token punctuation">.</span>register<span class="token punctuation">(</span>readline<span class="token punctuation">.</span>write_history_file<span class="token punctuation">,</span> histfile<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此代码实际上会在 Python 运行于 交互模式 时自动运行。</p>
<p>以下示例实现了同样的目标，但是通过只添加新历史的方式来支持并发的交互会话。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> atexit
<span class="token keyword">import</span> os
<span class="token keyword">import</span> readline
histfile <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span><span class="token string">"~"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">".python_history"</span><span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    readline<span class="token punctuation">.</span>read_history_file<span class="token punctuation">(</span>histfile<span class="token punctuation">)</span>
    h_len <span class="token operator">=</span> readline<span class="token punctuation">.</span>get_current_history_length<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> FileNotFoundError<span class="token punctuation">:</span>
    open<span class="token punctuation">(</span>histfile<span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
    h_len <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">def</span> <span class="token function">save</span><span class="token punctuation">(</span>prev_h_len<span class="token punctuation">,</span> histfile<span class="token punctuation">)</span><span class="token punctuation">:</span>
    new_h_len <span class="token operator">=</span> readline<span class="token punctuation">.</span>get_current_history_length<span class="token punctuation">(</span><span class="token punctuation">)</span>
    readline<span class="token punctuation">.</span>set_history_length<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
    readline<span class="token punctuation">.</span>append_history_file<span class="token punctuation">(</span>new_h_len <span class="token operator">-</span> prev_h_len<span class="token punctuation">,</span> histfile<span class="token punctuation">)</span>
atexit<span class="token punctuation">.</span>register<span class="token punctuation">(</span>save<span class="token punctuation">,</span> h_len<span class="token punctuation">,</span> histfile<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以下示例扩展了 <code>code.InteractiveConsole</code> 类以支持历史保存/恢复。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> atexit
<span class="token keyword">import</span> code
<span class="token keyword">import</span> os
<span class="token keyword">import</span> readline
<span class="token keyword">class</span> <span class="token class-name">HistoryConsole</span><span class="token punctuation">(</span>code<span class="token punctuation">.</span>InteractiveConsole<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> locals<span class="token operator">=</span>None<span class="token punctuation">,</span> filename<span class="token operator">=</span><span class="token string">"&lt;console>"</span><span class="token punctuation">,</span>
                 histfile<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span><span class="token string">"~/.console-history"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        code<span class="token punctuation">.</span>InteractiveConsole<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">,</span> locals<span class="token punctuation">,</span> filename<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>init_history<span class="token punctuation">(</span>histfile<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">init_history</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> histfile<span class="token punctuation">)</span><span class="token punctuation">:</span>
        readline<span class="token punctuation">.</span>parse_and_bind<span class="token punctuation">(</span><span class="token string">"tab: complete"</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> hasattr<span class="token punctuation">(</span>readline<span class="token punctuation">,</span> <span class="token string">"read_history_file"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">try</span><span class="token punctuation">:</span>
                readline<span class="token punctuation">.</span>read_history_file<span class="token punctuation">(</span>histfile<span class="token punctuation">)</span>
            <span class="token keyword">except</span> FileNotFoundError<span class="token punctuation">:</span>
                <span class="token keyword">pass</span>
            atexit<span class="token punctuation">.</span>register<span class="token punctuation">(</span>self<span class="token punctuation">.</span>save_history<span class="token punctuation">,</span> histfile<span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">save_history</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> histfile<span class="token punctuation">)</span><span class="token punctuation">:</span>
        readline<span class="token punctuation">.</span>set_history_length<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span>
        readline<span class="token punctuation">.</span>write_history_file<span class="token punctuation">(</span>histfile<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="rlcompleter-—-GNU-readline-的补全函数"><a href="#rlcompleter-—-GNU-readline-的补全函数" class="headerlink" title="rlcompleter —- GNU readline 的补全函数"></a><code>rlcompleter</code> —- GNU readline 的补全函数</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/rlcompleter.py" target="_blank" rel="noopener">Lib/rlcompleter.py</a></p>
<hr>
<p><code>rlcompeleter</code> 通过补全有效的 Python 标识符和关键字定义了一个适用于 <code>readline</code> 模块的补全函数。</p>
<p>当此模块在具有可用的 <code>readline</code> 模块的 Unix 平台被导入, 一个 <code>Completer</code> 实例将被自动创建并且它的 <code>complete()</code> 方法将设置为 <code>readline</code> 的补全器.</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> rlcompleter
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> readline
<span class="token operator">>></span><span class="token operator">></span> readline<span class="token punctuation">.</span>parse_and_bind<span class="token punctuation">(</span><span class="token string">"tab: complete"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> readline<span class="token punctuation">.</span> <span class="token operator">&lt;</span>TAB PRESSED<span class="token operator">></span>
readline<span class="token punctuation">.</span>__doc__          readline<span class="token punctuation">.</span>get_line_buffer<span class="token punctuation">(</span>  readline<span class="token punctuation">.</span>read_init_file<span class="token punctuation">(</span>
readline<span class="token punctuation">.</span>__file__         readline<span class="token punctuation">.</span>insert_text<span class="token punctuation">(</span>      readline<span class="token punctuation">.</span>set_completer<span class="token punctuation">(</span>
readline<span class="token punctuation">.</span>__name__         readline<span class="token punctuation">.</span>parse_and_bind<span class="token punctuation">(</span>
<span class="token operator">>></span><span class="token operator">></span> readline<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>rlcompleter</code> 模块是为了使用 Python 的 交互模式 而设计的。 除非 Python 是通过 <code>-S</code> 选项运行, 这个模块总是自动地被导入且配置 。</p>
<p>在没有 <code>readline</code> 的平台, 此模块定义的 <code>Completer</code> 类仍然可以用于自定义行为.</p>
<h3 id="Completer-对象"><a href="#Completer-对象" class="headerlink" title="Completer 对象"></a>Completer 对象</h3><p>Completer 对象具有以下方法：</p>
<p><code>Completer.complete</code>(<em>text</em>, <em>state</em>)</p>
<p>为 <em>text</em> 返回第 <em>state</em> 项补全。</p>
<p>如果指定的 <em>text</em> 不包含句点字符 (<code>'.'</code>)，它将根据当前 <code>__main__</code>, <code>builtins</code> 和保留关键字（定义于 <code>keyword</code> 模块）所定义的名称进行补全。</p>
<p>如果为带有句点的名称执行调用，它将尝试尽量求值直到最后一部分为止而不产生附带影响（函数不会被求值，但它可以生成对 <code>__getattr__()</code> 的调用），并通过 <code>dir()</code> 函数来匹配剩余部分。 在对表达式求值期间引发的任何异常都会被捕获、静默处理并返回 <code>None</code>。</p>
<h1 id="二进制数据服务"><a href="#二进制数据服务" class="headerlink" title="二进制数据服务"></a>二进制数据服务</h1><p>下面描述的一些库 文本处理服务 也可以使用 ASCII 兼容的二进制格式（例如 <code>re</code> ）或所有二进制数据（例如 <code>difflib</code> ）。</p>
<ul>
<li><code>struct</code> —- 将字节串解读为打包的二进制数据<ul>
<li>函数和异常</li>
<li>格式字符串<ul>
<li>字节顺序，大小和对齐方式</li>
<li>格式字符</li>
<li>例子</li>
</ul>
</li>
<li>类</li>
</ul>
</li>
<li><code>codecs</code> —- 编解码器注册和相关基类<ul>
<li>编解码器基类<ul>
<li>错误处理方案</li>
<li>无状态的编码和解码</li>
<li>增量式的编码和解码<ul>
<li>IncrementalEncoder 对象</li>
<li>IncrementalDecoder 对象</li>
</ul>
</li>
<li>流式的编码和解码<ul>
<li>StreamWriter 对象</li>
<li>StreamReader 对象</li>
<li>StreamReaderWriter 对象</li>
<li>StreamRecoder 对象</li>
</ul>
</li>
</ul>
</li>
<li>编码格式与 Unicode</li>
<li>标准编码</li>
<li>Python 专属的编码格式<ul>
<li>文字编码</li>
<li>二进制转换</li>
<li>文字转换</li>
</ul>
</li>
<li><code>encodings.idna</code> —- 应用程序中的国际化域名</li>
<li><code>encodings.mbcs</code> —- Windows ANSI代码页</li>
<li><code>encodings.utf_8_sig</code> —- 带BOM签名的UTF-8编解码器</li>
</ul>
</li>
</ul>
<h2 id="struct-—-将字节串解读为打包的二进制数据"><a href="#struct-—-将字节串解读为打包的二进制数据" class="headerlink" title="struct —- 将字节串解读为打包的二进制数据"></a><code>struct</code> —- 将字节串解读为打包的二进制数据</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/struct.py" target="_blank" rel="noopener">Lib/struct.py</a></p>
<hr>
<p>此模块可以执行 Python 值和以 Python <code>bytes</code> 对象表示的 C 结构之间的转换。 这可以被用来处理存储在文件中或是从网络连接等其他来源获取的二进制数据。 它使用 格式字符串 作为 C 结构布局的精简描述以及与 Python 值的双向转换。</p>
<p>注解</p>
<p>默认情况下，打包给定 C 结构的结果会包含填充字节以使得所涉及的 C 类型保持正确的对齐；类似地，对齐在解包时也会被纳入考虑。 选择此种行为的目的是使得被打包结构的字节能与相应 C 结构在内存中的布局完全一致。 要处理平台独立的数据格式或省略隐式的填充字节，请使用 <code>standard</code> 大小和对齐而不是 <code>native</code> 大小和对齐。</p>
<p>某些 <code>struct</code> 的函数（以及 <code>Struct</code> 的方法）接受一个 <em>buffer</em> 参数。 这将指向实现了 缓冲协议 并提供只读或是可读写缓冲的对象。 用于此目的的最常见类型为 <code>bytes</code> 和 <code>bytearray</code>，但许多其他可被视为字节数组的类型也实现了缓冲协议，因此它们无需额外从 <code>bytes</code> 对象复制即可被读取或填充。</p>
<h3 id="函数和异常"><a href="#函数和异常" class="headerlink" title="函数和异常"></a>函数和异常</h3><p>此模块定义了下列异常和函数：</p>
<p><em>exception</em> <code>struct.error</code></p>
<p>会在多种场合下被引发的异常；其参数为一个描述错误信息的字符串。</p>
<p><code>struct.pack</code>(<em>format</em>, <em>v1</em>, <em>v2</em>, <em>…</em>)</p>
<p>返回一个 bytes 对象，其中包含根据格式字符串 <em>format</em> 打包的值 <em>v1</em>, <em>v2</em>, … 参数个数必须与格式字符串所要求的值完全匹配。</p>
<p><code>struct.pack_into</code>(<em>format</em>, <em>buffer</em>, <em>offset</em>, <em>v1</em>, <em>v2</em>, <em>…</em>)</p>
<p>根据格式字符串 <em>format</em> 打包 <em>v1</em>, <em>v2</em>, … 等值并将打包的字节串写入可写缓冲区 <em>buffer</em> 从 <em>offset</em> 开始的位置。 请注意 <em>offset</em> 是必需的参数。</p>
<p><code>struct.unpack</code>(<em>format</em>, <em>buffer</em>)</p>
<p>根据格式字符串 <em>format</em> 从缓冲区 <em>buffer</em> 解包（假定是由 <code>pack(format, ...)</code> 打包）。 结果为一个元组，即使其只包含一个条目。 缓冲区的字节大小必须匹配格式所要求的大小，如 <code>calcsize()</code> 所示。</p>
<p><code>struct.unpack_from</code>(<em>format</em>, <em>/</em>, <em>buffer</em>, <em>offset=0</em>)</p>
<p>对 <em>buffer</em> 从位置 <em>offset</em> 开始根据格式字符串 <em>format</em> 进行解包。 结果为一个元组，即使其中只包含一个条目。 缓冲区的字节大小从位置 <em>offset</em> 开始必须至少为 <code>calcsize()</code> 显示的格式所要求的大小。</p>
<p><code>struct.iter_unpack</code>(<em>format</em>, <em>buffer</em>)</p>
<p>根据格式字符串 <em>format</em> 以迭代方式从缓冲区 <em>buffer</em> 解包。 此函数返回一个迭代器，它将从缓冲区读取相同大小的块直至其内容全部耗尽。 缓冲区的字节大小必须整数倍于格式所要求的大小，如 <code>calcsize()</code> 所示。</p>
<p>每次迭代将产生一个如格式字符串所指定的元组。</p>
<p>3.4 新版功能.</p>
<p><code>struct.calcsize</code>(<em>format</em>)</p>
<p>返回与格式字符串 <em>format</em> 相对应的结构的大小（亦即 <code>pack(format, ...)</code> 所产生的字节串对象的大小）。</p>
<h3 id="格式字符串"><a href="#格式字符串" class="headerlink" title="格式字符串"></a>格式字符串</h3><p>格式字符串是用来在打包和解包数据时指定预期布局的机制。 它们使用指定被打包/解包数据类型的 格式字符 进行构建。 此外，还有一些特殊字符用来控制 字节顺序，大小和对齐方式。</p>
<h4 id="字节顺序，大小和对齐方式"><a href="#字节顺序，大小和对齐方式" class="headerlink" title="字节顺序，大小和对齐方式"></a>字节顺序，大小和对齐方式</h4><p>默认情况下，C类型以机器的本机格式和字节顺序表示，并在必要时通过跳过填充字节进行正确对齐（根据C编译器使用的规则）。</p>
<p>或者，根据下表，格式字符串的第一个字符可用于指示打包数据的字节顺序，大小和对齐方式：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">字节顺序</th>
<th align="left">大小</th>
<th align="left">对齐方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>@</code></td>
<td align="left">按原字节</td>
<td align="left">按原字节</td>
<td align="left">按原字节</td>
</tr>
<tr>
<td align="left"><code>=</code></td>
<td align="left">按原字节</td>
<td align="left">标准</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>&lt;</code></td>
<td align="left">小端</td>
<td align="left">标准</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>&gt;</code></td>
<td align="left">大端</td>
<td align="left">标准</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><code>!</code></td>
<td align="left">网络（=大端）</td>
<td align="left">标准</td>
<td align="left">无</td>
</tr>
</tbody></table>
<p>如果第一个字符不是其中之一，则假定为 <code>'@'</code> 。</p>
<p>本机字节顺序可能为大端或是小端，取决于主机系统的不同。 例如， Intel x86 和 AMD64 (x86-64) 是小端的；Motorola 68000 和 PowerPC G5 是大端的；ARM 和 Intel Itanium 具有可切换的字节顺序（双端）。 请使用 <code>sys.byteorder</code> 来检查你的系统字节顺序。</p>
<p>本机大小和对齐方式是使用 C 编译器的 <code>sizeof</code> 表达式来确定的。 这总是会与本机字节顺序相绑定。</p>
<p>标准大小仅取决于格式字符。</p>
<p>请注意 <code>'@'</code> 和 <code>'='</code> 之间的区别：两个都使用本机字节顺序，但后者的大小和对齐方式是标准化的。</p>
<p>形式 <code>'!'</code> 代表网络字节顺序总是使用在 <a href="https://tools.ietf.org/html/rfc1700" target="_blank" rel="noopener">IETF RFC 1700</a> 中所定义的大端序。</p>
<p>没有什么方式能指定非本机字节顺序（强制字节对调）；请正确选择使用 <code>'&lt;'</code> 或 <code>'&gt;'</code>。</p>
<p>注释：</p>
<ol>
<li>填充只会在连续结构成员之间自动添加。 填充不会添加到已编码结构的开头和末尾。</li>
<li>当使用非本机大小和对齐方式即 ‘&lt;’, ‘&gt;’, ‘=’, and ‘!’ 时不会添加任何填充。</li>
<li>要将结构的末尾对齐到符合特定类型的对齐要求，请以该类型代码加重复计数的零作为格式结束。 </li>
</ol>
<h4 id="格式字符"><a href="#格式字符" class="headerlink" title="格式字符"></a>格式字符</h4><p>格式字符具有以下含义；C 和 Python 值之间的按其指定类型的转换应当是相当明显的。 ‘标准大小’列是指当使用标准大小时以字节表示的已打包值大小；也就是当格式字符串以 <code>'&lt;'</code>, <code>'&gt;'</code>, <code>'!'</code> 或 <code>'='</code> 之一开头的情况。 当使用本机大小时，已打包值的大小取决于具体的平台。</p>
<table>
<thead>
<tr>
<th align="left">格式</th>
<th align="left">C 类型</th>
<th align="left">Python 类型</th>
<th align="left">标准大小</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>x</code></td>
<td align="left">填充字节</td>
<td align="left">无</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>c</code></td>
<td align="left">char</td>
<td align="left">长度为 1 的字节串</td>
<td align="left">1</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>b</code></td>
<td align="left">signed char</td>
<td align="left">整数</td>
<td align="left">1</td>
<td align="left">(1), (2)</td>
</tr>
<tr>
<td align="left"><code>B</code></td>
<td align="left">unsigned char</td>
<td align="left">整数</td>
<td align="left">1</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>?</code></td>
<td align="left">_Bool</td>
<td align="left">bool</td>
<td align="left">1</td>
<td align="left">(1)</td>
</tr>
<tr>
<td align="left"><code>h</code></td>
<td align="left">short</td>
<td align="left">整数</td>
<td align="left">2</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>H</code></td>
<td align="left">unsigned short</td>
<td align="left">整数</td>
<td align="left">2</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>i</code></td>
<td align="left">int</td>
<td align="left">整数</td>
<td align="left">4</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>I</code></td>
<td align="left">unsigned int</td>
<td align="left">整数</td>
<td align="left">4</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>l</code></td>
<td align="left">long</td>
<td align="left">整数</td>
<td align="left">4</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>L</code></td>
<td align="left">unsigned long</td>
<td align="left">整数</td>
<td align="left">4</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>q</code></td>
<td align="left">long long</td>
<td align="left">整数</td>
<td align="left">8</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>Q</code></td>
<td align="left">unsigned long long</td>
<td align="left">整数</td>
<td align="left">8</td>
<td align="left">(2)</td>
</tr>
<tr>
<td align="left"><code>n</code></td>
<td align="left"><code>ssize_t</code></td>
<td align="left">整数</td>
<td align="left"></td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>N</code></td>
<td align="left"><code>size_t</code></td>
<td align="left">整数</td>
<td align="left"></td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>e</code></td>
<td align="left">(6)</td>
<td align="left">float</td>
<td align="left">2</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>f</code></td>
<td align="left">float</td>
<td align="left">float</td>
<td align="left">4</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>d</code></td>
<td align="left">double</td>
<td align="left">float</td>
<td align="left">8</td>
<td align="left">(4)</td>
</tr>
<tr>
<td align="left"><code>s</code></td>
<td align="left">char[]</td>
<td align="left">字节串</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>p</code></td>
<td align="left">char[]</td>
<td align="left">字节串</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>P</code></td>
<td align="left">void*</td>
<td align="left">整数</td>
<td align="left"></td>
<td align="left">(5)</td>
</tr>
</tbody></table>
<p>在 3.3 版更改: 增加了对 <code>'n'</code> 和 <code>'N'</code> 格式的支持</p>
<p>在 3.6 版更改: 添加了对 <code>'e'</code> 格式的支持。</p>
<p>注释：</p>
<ol>
<li><p><code>'?'</code> 转换码对应于 C99 定义的 _Bool 类型。 如果此类型不可用，则使用 char 来模拟。 在标准模式下，它总是以一个字节表示。</p>
</li>
<li><p>当尝试使用任何整数转换码打包一个非整数时，如果该非整数具有 <code>__index__()</code> 方法，则会在打包之前调用该方法将参数转换为一个整数。</p>
<p>在 3.2 版更改: 增加了针对非整数使用 <code>__index__()</code> 方法的特性。</p>
</li>
<li><p><code>'n'</code> 和 <code>'N'</code> 转换码仅对本机大小可用（选择为默认或使用 <code>'@'</code> 字节顺序字符）。 对于标准大小，你可以使用适合你的应用的任何其他整数格式。</p>
</li>
<li><p>对于 <code>'f'</code>, <code>'d'</code> 和 <code>'e'</code> 转换码，打包表示形式将使用 IEEE 754 binary32, binary64 或 binary16 格式 (分别对应于 <code>'f'</code>, <code>'d'</code> 或 <code>'e'</code>)，无论平台使用何种浮点格式。</p>
</li>
<li><p><code>'P'</code> 格式字符仅对本机字节顺序可用（选择为默认或使用 <code>'@'</code> 字节顺序字符）。 字节顺序字符 <code>'='</code> 选择使用基于主机系统的小端或大端排序。 struct 模块不会将其解读为本机排序，因此 <code>'P'</code> 格式将不可用。</p>
</li>
<li><p>IEEE 754 binary16 “半精度” 类型是在 <a href="https://en.wikipedia.org/wiki/IEEE_floating_point#IEEE_754-2008" target="_blank" rel="noopener">IEEE 754 标准</a> 的 2008 修订版中引入的。 它包含一个符号位，5 个指数位和 11 个精度位（明确存储 10 位），可以完全精确地表示大致范围在 <code>6.1e-05</code> 和 <code>6.5e+04</code> 之间的数字。 此类型并不被 C 编译器广泛支持：在一台典型的机器上，可以使用 unsigned short 进行存储，但不会被用于数学运算。 请参阅维基百科页面 <a href="https://en.wikipedia.org/wiki/Half-precision_floating-point_format" target="_blank" rel="noopener">half-precision floating-point format</a> 了解详情。</p>
</li>
</ol>
<p>格式字符之前可以带有整数重复计数。 例如，格式字符串 <code>'4h'</code> 的含义与 <code>'hhhh'</code> 完全相同。</p>
<p>格式之间的空白字符会被忽略；但是计数及其格式字符中不可有空白字符。</p>
<p>对于 <code>'s'</code> 格式字符，计数会被解析为字节的长度，而不是像其他格式字符那样的重复计数；例如，<code>'10s'</code> 表示一个 10 字节的字节串，而 <code>'10c'</code> 表示 10 个字符。 如果未给出计数，则默认值为 1。 对于打包操作，字节串会被适当地截断或填充空字节以符合要求。 对于解包操作，结果字节对象总是恰好具有指定数量的字节。 作为特殊情况，<code>'0s'</code> 表示一个空字符串（而 <code>'0c'</code> 表示 0 个字符）。</p>
<p>当使用某一种整数格式 (<code>'b'</code>, <code>'B'</code>, <code>'h'</code>, <code>'H'</code>, <code>'i'</code>, <code>'I'</code>, <code>'l'</code>, <code>'L'</code>, <code>'q'</code>, <code>'Q'</code>) 打包值 <code>x</code> 时，如果 <code>x</code> 在该格式的有效范围之外则将引发 <code>struct.error</code>。</p>
<p>在 3.1 版更改: 在之前版本中，某些整数格式包装了超范围的值并会引发 <code>DeprecationWarning</code> 而不是 <code>struct.error</code>。</p>
<p><code>'p'</code> 格式字符用于编码“Pascal 字符串”，即存储在由计数指定的 <em>固定长度字节</em> 中的可变长度短字符串。 所存储的第一个字节为字符串长度或 255 中的较小值。 之后是字符串对应的字节。 如果传入 <code>pack()</code> 的字符串过长（超过计数值减 1），则只有字符串前 <code>count-1</code> 个字节会被存储。 如果字符串短于 <code>count-1</code>，则会填充空字节以使得恰好使用了 count 个字节。 请注意对于 <code>unpack()</code>，<code>'p'</code> 格式字符会消耗 <code>count</code> 个字节，但返回的字符串永远不会包含超过 255 个字节。</p>
<p>对于 <code>'?'</code> 格式字符，返回值为 <code>True</code> 或 <code>False</code>。 在打包时将会使用参数对象的逻辑值。 以本机或标准 bool 类型表示的 0 或 1 将被打包，任何非零值在解包时将为 <code>True</code>。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>注解</p>
<p>所有示例都假定使用一台大端机器的本机字节顺序、大小和对齐方式。</p>
<p>打包/解包三个整数的基础示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> struct <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token operator">>></span><span class="token operator">></span> pack<span class="token punctuation">(</span><span class="token string">'hhl'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
b<span class="token string">'\x00\x01\x00\x02\x00\x00\x00\x03'</span>
<span class="token operator">>></span><span class="token operator">></span> unpack<span class="token punctuation">(</span><span class="token string">'hhl'</span><span class="token punctuation">,</span> b<span class="token string">'\x00\x01\x00\x02\x00\x00\x00\x03'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> calcsize<span class="token punctuation">(</span><span class="token string">'hhl'</span><span class="token punctuation">)</span>
<span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解包的字段可通过将它们赋值给变量或将结果包装为一个具名元组来命名:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> record <span class="token operator">=</span> b<span class="token string">'raymond   \x32\x12\x08\x01\x08'</span>
<span class="token operator">>></span><span class="token operator">></span> name<span class="token punctuation">,</span> serialnum<span class="token punctuation">,</span> school<span class="token punctuation">,</span> gradelevel <span class="token operator">=</span> unpack<span class="token punctuation">(</span><span class="token string">'&lt;10sHHb'</span><span class="token punctuation">,</span> record<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections <span class="token keyword">import</span> namedtuple
<span class="token operator">>></span><span class="token operator">></span> Student <span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">'Student'</span><span class="token punctuation">,</span> <span class="token string">'name serialnum school gradelevel'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Student<span class="token punctuation">.</span>_make<span class="token punctuation">(</span>unpack<span class="token punctuation">(</span><span class="token string">'&lt;10sHHb'</span><span class="token punctuation">,</span> record<span class="token punctuation">)</span><span class="token punctuation">)</span>
Student<span class="token punctuation">(</span>name<span class="token operator">=</span>b<span class="token string">'raymond   '</span><span class="token punctuation">,</span> serialnum<span class="token operator">=</span><span class="token number">4658</span><span class="token punctuation">,</span> school<span class="token operator">=</span><span class="token number">264</span><span class="token punctuation">,</span> gradelevel<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>格式字符的顺序可能对大小产生影响，因为满足对齐要求所需的填充是不同的:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pack<span class="token punctuation">(</span><span class="token string">'ci'</span><span class="token punctuation">,</span> b<span class="token string">'*'</span><span class="token punctuation">,</span> <span class="token number">0x12131415</span><span class="token punctuation">)</span>
b<span class="token string">'*\x00\x00\x00\x12\x13\x14\x15'</span>
<span class="token operator">>></span><span class="token operator">></span> pack<span class="token punctuation">(</span><span class="token string">'ic'</span><span class="token punctuation">,</span> <span class="token number">0x12131415</span><span class="token punctuation">,</span> b<span class="token string">'*'</span><span class="token punctuation">)</span>
b<span class="token string">'\x12\x13\x14\x15*'</span>
<span class="token operator">>></span><span class="token operator">></span> calcsize<span class="token punctuation">(</span><span class="token string">'ci'</span><span class="token punctuation">)</span>
<span class="token number">8</span>
<span class="token operator">>></span><span class="token operator">></span> calcsize<span class="token punctuation">(</span><span class="token string">'ic'</span><span class="token punctuation">)</span>
<span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以下格式 <code>'llh0l'</code> 指定在末尾有两个填充字节，假定 long 类型按 4 个字节的边界对齐:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> pack<span class="token punctuation">(</span><span class="token string">'llh0l'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
b<span class="token string">'\x00\x00\x00\x01\x00\x00\x00\x02\x00\x03\x00\x00'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这仅当本机大小和对齐方式生效时才会起作用；标准大小和对齐方式并不会强制进行任何对齐。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p><code>struct</code> 模块还定义了以下类型：</p>
<p><em>class</em> <code>struct.Struct</code>(<em>format</em>)</p>
<p>返回一个新的 Struct 对象，它会根据格式字符串 <em>format</em> 来写入和读取二进制数据。 一次性地创建 Struct 对象并调用其方法相比使用同样的格式调用 <code>struct</code> 函数更为高效，因为这样格式字符串只需被编译一次。</p>
<p>注解</p>
<p>传递给 <code>Struct</code> 和模块层级函数的已编译版最新格式字符串会被缓存，因此只使用少量格式字符串的程序无需担心重用单独的 <code>Struct</code> 实例。</p>
<p>已编译的 Struct 对象支持以下方法和属性：</p>
<ul>
<li><p><code>pack</code>(<em>v1</em>, <em>v2</em>, <em>…</em>)</p>
<p>等价于 <code>pack()</code> 函数，使用了已编译的格式。 (<code>len(result)</code> 将等于 <code>size</code>。)</p>
</li>
<li><p><code>pack_into</code>(<em>buffer</em>, <em>offset</em>, <em>v1</em>, <em>v2</em>, <em>…</em>)</p>
<p>等价于 <code>pack_into()</code> 函数，使用了已编译的格式。</p>
</li>
<li><p><code>unpack</code>(<em>buffer</em>)</p>
<p>等价于 <code>unpack()</code> 函数，使用了已编译的格式。 缓冲区的字节大小必须等于 <code>size</code>。</p>
</li>
<li><p><code>unpack_from</code>(<em>buffer</em>, <em>offset=0</em>)</p>
<p>等价于 <code>unpack_from()</code> 函数，使用了已编译的格式。 缓冲区的字节大小从位置 <em>offset</em> 开始必须至少为 <code>size</code>。</p>
</li>
<li><p><code>iter_unpack</code>(<em>buffer</em>)</p>
<p>等价于 <code>iter_unpack()</code> 函数，使用了已编译的格式。 缓冲区的大小必须为 <code>size</code> 的整数倍。</p>
<p>3.4 新版功能.</p>
</li>
<li><p><code>format</code></p>
<p>用于构造此 Struct 对象的格式字符串。</p>
<p>在 3.7 版更改: 格式字符串类型现在是 <code>str</code> 而不再是 <code>bytes</code>。</p>
</li>
<li><p><code>size</code></p>
<p>计算出对应于 <code>format</code> 的结构大小（亦即 <code>pack()</code> 方法所产生的字节串对象的大小）。</p>
</li>
</ul>
<h2 id="codecs-—-编解码器注册和相关基类"><a href="#codecs-—-编解码器注册和相关基类" class="headerlink" title="codecs —- 编解码器注册和相关基类"></a><code>codecs</code> —- 编解码器注册和相关基类</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/codecs.py" target="_blank" rel="noopener">Lib/codecs.py</a></p>
<hr>
<p>这个模块定义了标准 Python 编解码器（编码器和解码器）的基类，并提供接口用来访问内部的 Python 编解码器注册表，该注册表负责管理编解码器和错误处理的查找过程。 大多数标准编解码器都属于 文本编码，它们可将文本编码为字节串，但也提供了一些编解码器可将文本编码为文本，以及字节串编码为字节串。 自定义编解码器可以在任意类型间进行编码和解码，但某些模块特性仅适用于 文本编码 或将数据编码为 <code>字节串</code> 的编解码器。</p>
<p>该模块定义了以下用于使用任何编解码器进行编码和解码的函数:</p>
<p><code>codecs.encode</code>(<em>obj</em>, <em>encoding=’utf-8’</em>, <em>errors=’strict’</em>)</p>
<p>使用为 <em>encoding</em> 注册的编解码器对 <em>obj</em> 进行编码。</p>
<p>可以给定 <em>Errors</em> 以设置所需要的错误处理方案。 默认的错误处理方案 <code>'strict'</code> 表示编码错误将引发 <code>ValueError</code> (或更特定编解码器相关的子类，例如 <code>UnicodeEncodeError</code>)。 </p>
<p><code>codecs.decode</code>(<em>obj</em>, <em>encoding=’utf-8’</em>, <em>errors=’strict’</em>)</p>
<p>使用为 <em>encoding</em> 注册的编解码器对 <em>obj</em> 进行解码。</p>
<p>可以给定 <em>Errors</em> 以设置所需要的错误处理方案。 默认的错误处理方案 <code>'strict'</code> 表示编码错误将引发 <code>ValueError</code> (或更特定编解码器相关的子类，例如 <code>UnicodeDecodeError</code>)。 </p>
<p>每种编解码器的完整细节也可以直接查找获取：</p>
<p><code>codecs.lookup</code>(<em>encoding</em>)</p>
<p>在 Python 编解码器注册表中查找编解码器信息，并返回一个 <code>CodecInfo</code> 对象，其定义见下文。</p>
<p>首先将会在注册表缓存中查找编码，如果未找到，则会扫描注册的搜索函数列表。 如果没有找到 <code>CodecInfo</code> 对象，则将引发 <code>LookupError</code>。 否则，<code>CodecInfo</code> 对象将被存入缓存并返回给调用者。</p>
<p><em>class</em> <code>codecs.CodecInfo</code>(<em>encode</em>, <em>decode</em>, <em>streamreader=None</em>, <em>streamwriter=None</em>, <em>incrementalencoder=None</em>, <em>incrementaldecoder=None</em>, <em>name=None</em>)</p>
<p>查找编解码器注册表所得到的编解码器细节信息。 构造器参数将保存为同名的属性：</p>
<ul>
<li><p><code>name</code></p>
<p>编码名称</p>
</li>
<li><p><code>encode</code></p>
<p><code>decode</code></p>
<p>无状态的编码和解码函数。 它们必须是具有与 Codec 的 <code>encode()</code> 和 <code>decode()</code> 方法相同接口的函数或方法。 这些函数或方法应当工作于无状态的模式。</p>
</li>
<li><p><code>incrementalencoder</code></p>
<p><code>incrementaldecoder</code></p>
<p>增量式的编码器和解码器类或工厂函数。 这些函数必须分别提供由基类 <code>IncrementalEncoder</code> 和 <code>IncrementalDecoder</code> 所定义的接口。 增量式编解码器可以保持状态。</p>
</li>
<li><p><code>streamwriter</code></p>
<p><code>streamreader</code></p>
<p>流式写入器和读取器类或工厂函数。 这些函数必须分别提供由基类 <code>StreamWriter</code> 和 <code>StreamReader</code> 所定义的接口。 流式编解码器可以保持状态。</p>
</li>
</ul>
<p>为了简化对各种编解码器组件的访问，本模块提供了以下附加函数，它们使用 <code>lookup()</code> 来执行编解码器查找：</p>
<p><code>codecs.getencoder</code>(<em>encoding</em>)</p>
<p>查找给定编码的编解码器并返回其编码器函数。</p>
<p>在编码无法找到时将引发 <code>LookupError</code>。</p>
<p><code>codecs.getdecoder</code>(<em>encoding</em>)</p>
<p>查找给定编码的编解码器并返回其解码器函数。</p>
<p>在编码无法找到时将引发 <code>LookupError</code>。</p>
<p><code>codecs.getincrementalencoder</code>(<em>encoding</em>)</p>
<p>查找给定编码的编解码器并返回其增量式编码器类或工厂函数。</p>
<p>在编码无法找到或编解码器不支持增量式编码器时将引发 <code>LookupError</code>。</p>
<p><code>codecs.getincrementaldecoder</code>(<em>encoding</em>)</p>
<p>查找给定编码的编解码器并返回其增量式解码器类或工厂函数。</p>
<p>在编码无法找到或编解码器不支持增量式解码器时将引发 <code>LookupError</code>。</p>
<p><code>codecs.getreader</code>(<em>encoding</em>)</p>
<p>查找给定编码的编解码器并返回其 <code>StreamReader</code> 类或工厂函数。</p>
<p>在编码无法找到时将引发 <code>LookupError</code>。</p>
<p><code>codecs.getwriter</code>(<em>encoding</em>)</p>
<p>查找给定编码的编解码器并返回其 <code>StreamWriter</code> 类或工厂函数。</p>
<p>在编码无法找到时将引发 <code>LookupError</code>。</p>
<p>自定义编解码器的启用是通过注册适当的编解码器搜索函数：</p>
<p><code>codecs.register</code>(<em>search_function</em>)</p>
<p>注册一个编解码器搜索函数。 搜索函数预期接收一个参数，即全部以小写字母表示的编码格式名称，其中中连字符和空格会被转换为下划线，并返回一个 <code>CodecInfo</code> 对象。 在搜索函数无法找到给定编码格式的情况下，它应当返回 <code>None</code>。</p>
<p>在 3.9 版更改: 连字符和空格会被转换为下划线。</p>
<p><code>codecs.unregister</code>(<em>search_function</em>)</p>
<p>注销一个编解码器搜索函数并清空注册表缓存。 如果指定搜索函数未被注册，则不做任何操作。</p>
<p>3.10 新版功能.</p>
<p>虽然内置的 <code>open()</code> 和相关联的 <code>io</code> 模块是操作已编码文本文件的推荐方式，但本模块也提供了额外的工具函数和类，允许在操作二进制文件时使用更多各类的编解码器：</p>
<p><code>codecs.open</code>(<em>filename</em>, <em>mode=’r’</em>, <em>encoding=None</em>, <em>errors=’strict’</em>, <em>buffering=- 1</em>)</p>
<p>使用给定的 <em>mode</em> 打开已编码的文件并返回一个 <code>StreamReaderWriter</code> 的实例，提供透明的编码/解码。 默认的文件模式为 <code>'r'</code>，表示以读取模式打开文件。</p>
<p>注解</p>
<p>下层的已编码文件总是以二进制模式打开。 在读取和写入时不会自动执行 <code>'\n'</code> 的转换。 <em>mode</em> 参数可以是内置 <code>open()</code> 函数所接受的任意二进制模式；<code>'b'</code> 会被自动添加。</p>
<p><em>encoding</em> 指定文件所要使用的编码格式。 允许任何编码为字节串或从字节串解码的编码格式，而文件方法所支持的数据类型则取决于所使用的编解码器。</p>
<p>可以指定 <em>errors</em> 来定义错误处理方案。 默认值 <code>'strict'</code> 表示在出现编码错误时引发 <code>ValueError</code>。</p>
<p><em>buffering</em> 的含义与内置 <code>open()</code> 函数中的相同。 默认值 -1 表示将使用默认的缓冲区大小。</p>
<p><code>codecs.EncodedFile</code>(<em>file</em>, <em>data_encoding</em>, <em>file_encoding=None</em>, <em>errors=’strict’</em>)</p>
<p>返回一个 <code>StreamRecoder</code> 实例，它提供了 <em>file</em> 的透明转码包装版本。 当包装版本被关闭时原始文件也会被关闭。</p>
<p>写入已包装文件的数据会根据给定的 <em>data_encoding</em> 解码，然后以使用 <em>file_encoding</em> 的字节形式写入原始文件。 从原始文件读取的字节串将根据 <em>file_encoding</em> 解码，其结果将使用 <em>data_encoding</em> 进行编码。</p>
<p>如果 <em>file_encoding</em> 未给定，则默认为 <em>data_encoding</em>。</p>
<p>可以指定 <em>errors</em> 来定义错误处理方案。 默认值 <code>'strict'</code> 表示在出现编码错误时引发 <code>ValueError</code>。</p>
<p><code>codecs.iterencode</code>(<em>iterator</em>, <em>encoding</em>, <em>errors=’strict’</em>, <em>**kwargs</em>)</p>
<p>使用增量式编码器通过迭代来编码由 <em>iterator</em> 所提供的输入。 此函数属于 generator。 <em>errors</em> 参数（以及任何其他关键字参数）会被传递给增量式编码器。</p>
<p>此函数要求编解码器接受 <code>str</code> 对象形式的文本进行编码。 因此它不支持字节到字节的编码器，例如 <code>base64_codec</code>。</p>
<p><code>codecs.iterdecode</code>(<em>iterator</em>, <em>encoding</em>, <em>errors=’strict’</em>, <em>**kwargs</em>)</p>
<p>使用增量式解码器通过迭代来解码由 <em>iterator</em> 所提供的输入。 此函数属于 generator。 <em>errors</em> 参数（以及任何其他关键字参数）会被传递给增量式解码器。</p>
<p>此函数要求编解码器接受 <code>bytes</code> 对象进行解码。 因此它不支持文本到文本的编码器，例如 <code>rot_13</code>，但是 <code>rot_13</code> 可以通过同样效果的 <code>iterencode()</code> 来使用。</p>
<p>本模块还提供了以下常量，适用于读取和写入依赖于平台的文件：</p>
<pre><code>codecs.BOM
codecs.BOM_BE
codecs.BOM_LE
codecs.BOM_UTF8
codecs.BOM_UTF16
codecs.BOM_UTF16_BE
codecs.BOM_UTF16_LE
codecs.BOM_UTF32
codecs.BOM_UTF32_BE
codecs.BOM_UTF32_LE</code></pre><p>这些常量定义了多种字节序列，即一些编码格式的 Unicode 字节顺序标记（BOM）。 它们在 UTF-16 和 UTF-32 数据流中被用以指明所使用的字节顺序，并在 UTF-8 中被用作 Unicode 签名。 <code>BOM_UTF16</code> 是 <code>BOM_UTF16_BE</code> 或 <code>BOM_UTF16_LE</code>，具体取决于平台的本机字节顺序，<code>BOM</code> 是 <code>BOM_UTF16</code> 的别名, <code>BOM_LE</code> 是 <code>BOM_UTF16_LE</code> 的别名，<code>BOM_BE</code> 是 <code>BOM_UTF16_BE</code> 的别名。 其他序列则表示 UTF-8 和 UTF-32 编码格式中的 BOM。</p>
<h3 id="编解码器基类"><a href="#编解码器基类" class="headerlink" title="编解码器基类"></a>编解码器基类</h3><p><code>codecs</code> 模块定义了一系列基类用来定义配合编解码器对象进行工作的接口，并且也可用作定制编解码器实现的基础。</p>
<p>每种编解码器必须定义四个接口以便用作 Python 中的编解码器：无状态编码器、无状态解码器、流读取器和流写入器。 流读取器和写入器通常会重用无状态编码器/解码器来实现文件协议。 编解码器作者还需要定义编解码器将如何处理编码和解码错误。</p>
<h4 id="错误处理方案"><a href="#错误处理方案" class="headerlink" title="错误处理方案"></a>错误处理方案</h4><p>为了简化和标准化错误处理，编解码器可以通过接受 <em>errors</em> 字符串参数来实现不同的错误处理方案。 所有标准的 Python 编解码器都定义并实现了以下字符串值：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘strict’</code></td>
<td align="left">引发 <code>UnicodeError</code> (或其子类)；这是默认的方案。 在 <code>strict_errors()</code> 中实现。</td>
</tr>
<tr>
<td align="left"><code>‘ignore’</code></td>
<td align="left">忽略错误格式的数据并且不加进一步通知就继续执行。 在 <code>ignore_errors()</code> 中实现。</td>
</tr>
</tbody></table>
<p>以下错误处理方案仅适用于 文本编码:</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘replace’</code></td>
<td align="left">使用适当的替换标记进行替换；Python 内置编解码器将在解码时使用官方 <code>U+FFFD</code> 替换字符，而在编码时使用 ‘?’ 。 在 <code>replace_errors()</code> 中实现。</td>
</tr>
<tr>
<td align="left"><code>‘xmlcharrefreplace’</code></td>
<td align="left">使用适当的 XML 字符引用进行替换（仅在编码时）。 在 <code>xmlcharrefreplace_errors()</code> 中实现。</td>
</tr>
<tr>
<td align="left"><code>‘backslashreplace’</code></td>
<td align="left">使用带反斜杠的转义序列进行替换。 在 <code>backslashreplace_errors()</code> 中实现。</td>
</tr>
<tr>
<td align="left"><code>‘namereplace’</code></td>
<td align="left">使用 <code>\N{…}</code> 转义序列进行替换（仅在编码时）。 在 <code>namereplace_errors()</code> 中实现。</td>
</tr>
<tr>
<td align="left"><code>‘surrogateescape’</code></td>
<td align="left">在解码时，将字节替换为 <code>U+DC80</code> 至 <code>U+DCFF</code> 范围内的单个代理代码。 当在编码数据时使用 <code>‘surrogateescape’</code> 错误处理方案时，此代理将被转换回相同的字节。 （请参阅 <a href="https://www.python.org/dev/peps/pep-0383" target="_blank" rel="noopener"><strong>PEP 383</strong></a> 了解详情。）</td>
</tr>
</tbody></table>
<p>此外，以下错误处理方案被专门用于指定的编解码器：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">编解码器</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘surrogatepass’</code></td>
<td align="left">utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le</td>
<td align="left">允许编码和解码代理代码。 这些编解码器通常会将出现的代理代码视为错误。</td>
</tr>
</tbody></table>
<p>3.1 新版功能: <code>'surrogateescape'</code> 和 <code>'surrogatepass'</code> 错误处理方案。</p>
<p>在 3.4 版更改: <code>'surrogatepass'</code> 错误处理方案现在适用于 utf-16* 和 utf-32* 编解码器。</p>
<p>3.5 新版功能: <code>'namereplace'</code> 错误处理方案。</p>
<p>在 3.5 版更改: <code>'backslashreplace'</code> 错误处理方案现在适用于解码和转换。</p>
<p>允许的值集合可以通过注册新命名的错误处理方案来扩展：</p>
<p><code>codecs.register_error</code>(<em>name</em>, <em>error_handler</em>)</p>
<p>在名称 <em>name</em> 之下注册错误处理函数 <em>error_handler*。 当 *name</em> 被指定为错误形参时，<em>error_handler</em> 参数所指定的对象将在编码和解码期间发生错误的情况下被调用，</p>
<p>对于编码操作，将会调用 <em>error_handler</em> 并传入一个 <code>UnicodeEncodeError</code> 实例，其中包含有关错误位置的信息。 错误处理程序必须引发此异常或别的异常，或者也可以返回一个元组，其中包含输入的不可编码部分的替换对象，以及应当继续进行编码的位置。 替换对象可以为 <code>str</code> 或 <code>bytes</code> 类型。 如果替换对象为字节串，编码器将简单地将其复制到输出缓冲区。 如果替换对象为字符串，编码器将对替换对象进行编码。 对原始输入的编码操作会在指定位置继续进行。 负的位置值将被视为相对于输入字符串的末尾。 如果结果位置超出范围则将引发 <code>IndexError</code>。</p>
<p>解码和转换的做法很相似，不同之处在于将把 <code>UnicodeDecodeError</code> 或 <code>UnicodeTranslateError</code> 传给处理程序，并且来自错误处理程序的替换对象将被直接放入输出。</p>
<p>之前注册的错误处理方案（包括标准错误处理方案）可通过名称进行查找：</p>
<p><code>codecs.lookup_error</code>(<em>name</em>)</p>
<p>返回之前在名称 <em>name</em> 之下注册的错误处理方案。</p>
<p>在处理方案无法找到时将引发 <code>LookupError</code>。</p>
<p>以下标准错误处理方案也可通过模块层级函数的方式来使用：</p>
<p><code>codecs.strict_errors</code>(<em>exception</em>)</p>
<p>实现 <code>'strict'</code> 错误处理方案：每个编码或解码错误都会引发 <code>UnicodeError</code>。</p>
<p><code>codecs.replace_errors</code>(<em>exception</em>)</p>
<p>实现 <code>'replace'</code> 错误处理方案 (仅用于 文本编码)：编码错误替换为 <code>'?'</code> (并由编解码器编码)，解码错误替换为 <code>'\ufffd'</code> (Unicode 替换字符)。</p>
<p><code>codecs.ignore_errors</code>(<em>exception</em>)</p>
<p>实现 <code>'ignore'</code> 错误处理方案：忽略错误格式的数据并且不加进一步通知就继续执行。</p>
<p><code>codecs.xmlcharrefreplace_errors</code>(<em>exception</em>)</p>
<p>实现 <code>'xmlcharrefreplace'</code> 错误处理方案 (仅用于 文本编码 的编码过程)：不可编码的字符将以适当的 XML 字符引用进行替换。</p>
<p><code>codecs.backslashreplace_errors</code>(<em>exception</em>)</p>
<p>实现 <code>'backslashreplace'</code> 错误处理方案 (仅用于 文本编码)：错误格式的数据将以带反斜杠的转义序列进行替换。</p>
<p><code>codecs.namereplace_errors</code>(<em>exception</em>)</p>
<p>实现 <code>'namereplace'</code> 错误处理方案 (仅用于 文本编码 的编码过程)：不可编码的字符将以 <code>\N{...}</code> 转义序列进行替换。</p>
<p>3.5 新版功能.</p>
<h4 id="无状态的编码和解码"><a href="#无状态的编码和解码" class="headerlink" title="无状态的编码和解码"></a>无状态的编码和解码</h4><p>基本 <code>Codec</code> 类定义了这些方法，同时还定义了无状态编码器和解码器的函数接口：</p>
<p><code>Codec.encode</code>(<em>input</em>[, <em>errors</em>])</p>
<p>编码 <em>input</em> 对象并返回一个元组 (输出对象, 消耗长度)。 例如，text encoding 会使用特定的字符集编码格式 (例如 <code>cp1252</code> 或 <code>iso-8859-1</code>) 将字符串转换为字节串对象。</p>
<p><em>errors</em> 参数定义了要应用的错误处理方案。 默认为 <code>'strict'</code> 处理方案。</p>
<p>此方法不一定会在 <code>Codec</code> 实例中保存状态。 可使用必须保存状态的 <code>StreamWriter</code> 作为编解码器以便高效地进行编码。</p>
<p>编码器必须能够处理零长度的输入并在此情况下返回输出对象类型的空对象。</p>
<p><code>Codec.decode</code>(<em>input</em>[, <em>errors</em>])</p>
<p>解码 <em>input</em> 对象并返回一个元组 (输出对象, 消耗长度)。 例如，text encoding 的解码操作会使用特定的字符集编码格式将字节串对象转换为字符串对象。</p>
<p>对于文本编码格式和字节到字节编解码器，<em>input</em> 必须为一个字节串对象或提供了只读缓冲区接口的对象 — 例如，缓冲区对象和映射到内存的文件。</p>
<p><em>errors</em> 参数定义了要应用的错误处理方案。 默认为 <code>'strict'</code> 处理方案。</p>
<p>此方法不一定会在 <code>Codec</code> 实例中保存状态。 可使用必须保存状态的 <code>StreamReader</code> 作为编解码器以便高效地进行解码。</p>
<p>解码器必须能够处理零长度的输入并在此情况下返回输出对象类型的空对象。</p>
<h4 id="增量式的编码和解码"><a href="#增量式的编码和解码" class="headerlink" title="增量式的编码和解码"></a>增量式的编码和解码</h4><p><code>IncrementalEncoder</code> 和 <code>IncrementalDecoder</code> 类提供了增量式编码和解码的基本接口。 对输入的编码/解码不是通过对无状态编码器/解码器的一次调用，而是通过对增量式编码器/解码器的 <code>encode()</code>/<code>decode()</code> 方法的多次调用。 增量式编码器/解码器会在方法调用期间跟踪编码/解码过程。</p>
<p>调用 <code>encode()</code>/<code>decode()</code> 方法后的全部输出相当于将所有通过无状态编码器/解码器进行编码/解码的单个输入连接在一起所得到的输出。</p>
<h5 id="IncrementalEncoder-对象"><a href="#IncrementalEncoder-对象" class="headerlink" title="IncrementalEncoder 对象"></a>IncrementalEncoder 对象</h5><p><code>IncrementalEncoder</code> 类用来对一个输入进行分步编码。 它定义了以下方法，每个增量式编码器都必须定义这些方法以便与 Python 编解码器注册表相兼容。</p>
<p><em>class</em> <code>codecs.IncrementalEncoder</code>(<em>errors=’strict’</em>)</p>
<p><code>IncrementalEncoder</code> 实例的构造器。</p>
<p>所有增量式编码器必须提供此构造器接口。 它们可以自由地添加额外的关键字参数，但只有在这里定义的参数才会被 Python 编解码器注册表所使用。</p>
<p><code>IncrementalEncoder</code> 可以通过提供 <em>errors</em> 关键字参数来实现不同的错误处理方案。 </p>
<p><em>errors</em> 参数将被赋值给一个同名的属性。 通过对此属性赋值就可以在 <code>IncrementalEncoder</code> 对象的生命期内在不同的错误处理策略之间进行切换。</p>
<ul>
<li><p><code>encode</code>(<em>object</em>[, <em>final</em>])</p>
<p>编码 <em>object</em> (会将编码器的当前状态纳入考虑) 并返回已编码的结果对象。 如果这是对 <code>encode()</code> 的最终调用则 <em>final</em> 必须为真值（默认为假值）。</p>
</li>
<li><p><code>reset</code>()</p>
<p>将编码器重置为初始状态。 输出将被丢弃：调用 <code>.encode(object, final=True)</code>，在必要时传入一个空字节串或字符串，重置编码器并得到输出。</p>
</li>
<li><p><code>getstate</code>()</p>
<p>返回编码器的当前状态，该值必须为一个整数。 实现应当确保 <code>0</code> 是最常见的状态。 （比整数更复杂的状态表示可以通过编组/选择状态并将结果字符串的字节数据编码为整数来转换为一个整数值）。</p>
</li>
<li><p><code>setstate</code>(<em>state</em>)</p>
<p>将编码器的状态设为 <em>state*。 *state</em> 必须为 <code>getstate()</code> 所返回的一个编码器状态。</p>
</li>
</ul>
<h5 id="IncrementalDecoder-对象"><a href="#IncrementalDecoder-对象" class="headerlink" title="IncrementalDecoder 对象"></a>IncrementalDecoder 对象</h5><p><code>IncrementalDecoder</code> 类用来对一个输入进行分步解码。 它定义了以下方法，每个增量式解码器都必须定义这些方法以便与 Python 编解码器注册表相兼容。</p>
<p><em>class</em> <code>codecs.IncrementalDecoder</code>(<em>errors=’strict’</em>)</p>
<p><code>IncrementalDecoder</code> 实例的构造器。</p>
<p>所有增量式解码器必须提供此构造器接口。 它们可以自由地添加额外的关键字参数，但只有在这里定义的参数才会被 Python 编解码器注册表所使用。</p>
<p><code>IncrementalDecoder</code> 可以通过提供 <em>errors</em> 关键字参数来实现不同的错误处理方案。 </p>
<p><em>errors</em> 参数将被赋值给一个同名的属性。 通过对此属性赋值就可以在 <code>IncrementalDecoder</code> 对象的生命期内在不同的错误处理策略之间进行切换。</p>
<ul>
<li><p><code>decode</code>(<em>object</em>[, <em>final</em>])</p>
<p>解码 <em>object</em> (会将解码器的当前状态纳入考虑) 并返回已解码的结果对象。 如果这是对 <code>decode()</code> 的最终调用则 <em>final</em> 必须为真值（默认为假值）。 如果 <em>final</em> 为真值则解码器必须对输入进行完全解码并且必须 刷新所有缓冲区。 如果这无法做到（例如由于在输入结束时字节串序列不完整）则它必须像在无状态的情况下那样初始化错误处理（这可能引发一个异常）。</p>
</li>
<li><p><code>reset</code>()</p>
<p>将解码器重置为初始状态。</p>
</li>
<li><p><code>getstate</code>()</p>
<p>返回解码器的当前状态。 这必须为一个二元组，第一项必须是包含尚未解码的输入的缓冲区。 第二项必须为一个整数，可以表示附加状态信息。 （实现应当确保 <code>0</code> 是最常见的附加状态信息。） 如果此附加状态信息为 <code>0</code> 则必须可以将解码器设为没有已缓冲输入并且以 <code>0</code> 作为附加状态信息，以便将先前已缓冲的输入馈送到解码器使其返回到先前的状态而不产生任何输出。 （比整数更复杂的附加状态信息可以通过编组/选择状态信息并将结果字符串的字节数据编码为整数来转换为一个整数值。）</p>
</li>
<li><p><code>setstate</code>(<em>state</em>)</p>
<p>将解码器的状态设为 <em>state*。 *state</em> 必须为 <code>getstate()</code> 所返回的一个解码器状态。</p>
</li>
</ul>
<h4 id="流式的编码和解码"><a href="#流式的编码和解码" class="headerlink" title="流式的编码和解码"></a>流式的编码和解码</h4><p><code>StreamWriter</code> 和 <code>StreamReader</code> 类提供了一些泛用工作接口，可被用来非常方便地实现新的编码格式子模块。 </p>
<h5 id="StreamWriter-对象"><a href="#StreamWriter-对象" class="headerlink" title="StreamWriter 对象"></a>StreamWriter 对象</h5><p><code>StreamWriter</code> 类是 <code>Codec</code> 的子类，它定义了以下方法，每个流式写入器都必须定义这些方法以便与 Python 编解码器注册表相兼容。</p>
<p><em>class</em> <code>codecs.StreamWriter</code>(<em>stream</em>, <em>errors=’strict’</em>)</p>
<p><code>StreamWriter</code> 实例的构造器。</p>
<p>所有流式写入器必须提供此构造器接口。 它们可以自由地添加额外的关键字参数，但只有在这里定义的参数才会被 Python 编解码器注册表所使用。</p>
<p><em>stream</em> 参数必须为一个基于特定编解码器打开用于写入文本或二进制数据的文件类对象。</p>
<p><code>StreamWriter</code> 可以通过提供 <em>errors</em> 关键字参数来实现不同的错误处理方案。 </p>
<p><em>errors</em> 参数将被赋值给一个同名的属性。 通过对此属性赋值就可以在 <code>StreamWriter</code> 对象的生命期内在不同的错误处理策略之间进行切换。</p>
<ul>
<li><p><code>write</code>(<em>object</em>)</p>
<p>将编码后的对象内容写入到流。</p>
</li>
<li><p><code>writelines</code>(<em>list</em>)</p>
<p>将拼接后的字符串列表写入到流（可能通过重用 <code>write()</code> 方法）。 标准的字节到字节编解码器不支持此方法。</p>
</li>
<li><p><code>reset</code>()</p>
<p>重置用于保持内部状态的编解码器缓冲区。</p>
<p>调用此方法应当确保在干净的状态下放入输出数据，以允许直接添加新的干净数据而无须重新扫描整个流来恢复状态。</p>
</li>
</ul>
<p>除了上述的方法，<code>StreamWriter</code> 还必须继承来自下层流的所有其他方法和属性。</p>
<h5 id="StreamReader-对象"><a href="#StreamReader-对象" class="headerlink" title="StreamReader 对象"></a>StreamReader 对象</h5><p><code>StreamReader</code> 类是 <code>Codec</code> 的子类，它定义了以下方法，每个流式读取器都必须定义这些方法以便与 Python 编解码器注册表相兼容。</p>
<p><em>class</em> <code>codecs.StreamReader</code>(<em>stream</em>, <em>errors=’strict’</em>)</p>
<p><code>StreamReader</code> 实例的构造器。</p>
<p>所有流式读取器必须提供此构造器接口。 它们可以自由地添加额外的关键字参数，但只有在这里定义的参数才会被 Python 编解码器注册表所使用。</p>
<p><em>stream</em> 参数必须为一个基于特定编解码器打开用于读取文本或二进制数据的文件类对象。</p>
<p><code>StreamReader</code> 可以通过提供 <em>errors</em> 关键字参数来实现不同的错误处理方案。</p>
<p><em>errors</em> 参数将被赋值给一个同名的属性。 通过对此属性赋值就可以在 <code>StreamReader</code> 对象的生命期内在不同的错误处理策略之间进行切换。</p>
<p><em>errors</em> 参数所允许的值集合可以使用 <code>register_error()</code> 来扩展。</p>
<ul>
<li><p><code>read</code>([<em>size</em>[, <em>chars</em>[, <em>firstline</em>]]])</p>
<p>解码来自流的数据并返回结果对象。</p>
<p><em>chars</em> 参数指明要返回的解码后码位或字节数量。 <code>read()</code> 方法绝不会返回超出请求数量的数据，但如果可用数量不足，它可能返回少于请求数量的数据。</p>
<p><em>size</em> 参数指明要读取并解码的已编码字节或码位的最大数量近似值。 解码器可以适当地修改此设置。 默认值 -1 表示尽可能多地读取并解码。 此形参的目的是防止一次性解码过于巨大的文件。</p>
<p><em>firstline</em> 旗标指明如果在后续行发生解码错误，则仅返回第一行就足够了。</p>
<p>此方法应当使用“贪婪”读取策略，这意味着它应当在编码格式定义和给定大小所允许的情况下尽可能多地读取数据，例如，如果在流上存在可选的编码结束或状态标记，这些内容也应当被读取。</p>
</li>
<li><p><code>readline</code>([<em>size</em>[, <em>keepends</em>]])</p>
<p>从输入流读取一行并返回解码后的数据。</p>
<p>如果给定了 <em>size</em>，则将其作为 size 参数传递给流的 <code>read()</code> 方法。</p>
<p>如果 <em>keepends</em> 为假值，则行结束符将从返回的行中去除。</p>
</li>
<li><p><code>readlines</code>([<em>sizehint</em>[, <em>keepends</em>]])</p>
<p>从输入流读取所有行并将其作为一个行列表返回。</p>
<p>行结束符会使用编解码器的 <code>decode()</code> 方法来实现，并且如果 <em>keepends</em> 为真值则会将其包含在列表条目中。</p>
<p>如果给定了 <em>sizehint*，则将其作为 *size</em> 参数传递给流的 <code>read()</code> 方法。</p>
</li>
<li><p><code>reset</code>()</p>
<p>重置用于保持内部状态的编解码器缓冲区。</p>
<p>请注意不应当对流进行重定位。 使用此方法的主要目的是为了能够从解码错误中恢复。</p>
</li>
</ul>
<p>除了上述的方法，<code>StreamReader</code> 还必须继承来自下层流的所有其他方法和属性。</p>
<h5 id="StreamReaderWriter-对象"><a href="#StreamReaderWriter-对象" class="headerlink" title="StreamReaderWriter 对象"></a>StreamReaderWriter 对象</h5><p><code>StreamReaderWriter</code> 是一个方便的类，允许对同时工作于读取和写入模式的流进行包装。</p>
<p>其设计使得开发者可以使用 <code>lookup()</code> 函数所返回的工厂函数来构造实例。</p>
<p><em>class</em> <code>codecs.StreamReaderWriter</code>(<em>stream</em>, <em>Reader</em>, <em>Writer</em>, <em>errors=’strict’</em>)</p>
<p>创建一个 <code>StreamReaderWriter</code> 实例。 <em>stream</em> 必须为一个文件类对象。 <em>Reader</em> 和 <em>Writer</em> 必须为分别提供了 <code>StreamReader</code> 和 <code>StreamWriter</code> 接口的工厂函数或类。 错误处理通过与流式读取器和写入器所定义的相同方式来完成。</p>
<p><code>StreamReaderWriter</code> 实例定义了 <code>StreamReader</code> 和 <code>StreamWriter</code> 类的组合接口。 它们还继承了来自下层流的所有其他方法和属性。</p>
<h5 id="StreamRecoder-对象"><a href="#StreamRecoder-对象" class="headerlink" title="StreamRecoder 对象"></a>StreamRecoder 对象</h5><p><code>StreamRecoder</code> 将数据从一种编码格式转换为另一种，这对于处理不同编码环境的情况有时会很有用。</p>
<p>其设计使得开发者可以使用 <code>lookup()</code> 函数所返回的工厂函数来构造实例。</p>
<p><em>class</em> <code>codecs.StreamRecoder</code>(<em>stream</em>, <em>encode</em>, <em>decode</em>, <em>Reader</em>, <em>Writer</em>, <em>errors=’strict’</em>)</p>
<p>创建一个实现了双向转换的 <code>StreamRecoder</code> 实例: <em>encode</em> 和 <em>decode</em> 工作于前端 — 对代码可见的数据调用 <code>read()</code> 和 <code>write()</code>，而 <em>Reader</em> 和 <em>Writer</em> 工作于后端 — <em>stream</em> 中的数据。</p>
<p>你可以使用这些对象来进行透明转码，例如从 Latin-1 转为 UTF-8 以及反向转换。</p>
<p><em>stream</em> 参数必须为一个文件类对象。</p>
<p><em>encode</em> 和 <em>decode</em> 参数必须遵循 <code>Codec</code> 接口。 <em>Reader</em> 和 <em>Writer</em> 必须为分别提供了 <code>StreamReader</code> 和 <code>StreamWriter</code> 接口对象的工厂函数或类。</p>
<p>错误处理通过与流式读取器和写入器所定义的相同方式来完成。</p>
<p><code>StreamRecoder</code> 实例定义了 <code>StreamReader</code> 和 <code>StreamWriter</code> 类的组合接口。 它们还继承了来自下层流的所有其他方法和属性。</p>
<h3 id="编码格式与-Unicode"><a href="#编码格式与-Unicode" class="headerlink" title="编码格式与 Unicode"></a>编码格式与 Unicode</h3><p>字符串在系统内部存储为 <code>0x0</code>–<code>0x10FFFF</code> 范围内的码位序列。 （请参阅 <a href="https://www.python.org/dev/peps/pep-0393" target="_blank" rel="noopener"><strong>PEP 393</strong></a> 了解有关实现的详情。） 一旦字符串对象要在 CPU 和内存以外使用，字节的大小端顺序和字节数组的存储方式就成为一个关键问题。 如同使用其他编解码器一样，将字符串序列化为字节序列被称为 <em>编码</em>，而从字节序列重建字符串被称为 <em>解码</em>。 存在许多不同的文本序列化编解码器，它们被统称为 文本编码。</p>
<p>最简单的文本编码格式 (称为 <code>'latin-1'</code> 或 <code>'iso-8859-1'</code>) 将码位 0—255 映射为字节值 <code>0x0</code>–<code>0xff</code>，这意味着包含 <code>U+00FF</code> 以上码位的字符串对象无法使用此编解码器进行编码。 这样做将引发 <code>UnicodeEncodeError</code>，其形式类似下面这样（不过详细的错误信息可能会有所不同）: <code>UnicodeEncodeError: 'latin-1' codec can't encode character '\u1234' in position 3: ordinal not in range(256)</code>。</p>
<p>还有另外一组编码格式（所谓的字符映射编码）会选择全部 Unicode 码位的不同子集并设定如何将这些码位映射为字节值 <code>0x0</code>–<code>0xff</code>。 要查看这是如何实现的，只需简单地打开相应源码例如 <code>encodings/cp1252.py</code> (这是一个主要在 Windows 上使用的编码格式)。 其中会有一个包含 256 个字符的字符串常量，指明每个字符所映射的字节值。</p>
<p>所有这些编码格式只能对 Unicode 所定义的 1114112 个码位中的 256 个进行编码。 一种能够存储每个 Unicode 码位的简单而直接的办法就是将每个码位存储为四个连续的字节。 存在两种不同的可能性：以大端序存储或以小端序存储。 这两种编码格式分别被称为 <code>UTF-32-BE</code> 和 <code>UTF-32-LE</code>。 它们的缺点可以举例说明：如果你在一台小端序的机器上使用 <code>UTF-32-BE</code> 则你将必须在编码和解码时翻转字节。 <code>UTF-32</code> 避免了这个问题：字节的排列将总是使用自然顺序。 当这些字节被具有不同字节顺序的 CPU 读取时，则必须进行字节翻转。 为了能够检测 <code>UTF-16</code> 或 <code>UTF-32</code> 字节序列的大小端序，可以使用所谓的 BOM (“字节顺序标记”)。 这对应于 Unicode 字符 <code>U+FEFF</code>。 此字符可添加到每个 <code>UTF-16</code> 或 <code>UTF-32</code> 字节序列的开头。 此字符的字节翻转版本 (<code>0xFFFE</code>) 是一个不可出现于 Unicode 文本中的非法字符。 因此当发现一个 <code>UTF-16</code> 或 <code>UTF-32</code> 字节序列的首个字符是 <code>U+FFFE</code> 时，就必须在解码时进行字节翻转。 不幸的是字符 <code>U+FEFF</code> 还有第二个含义 <code>ZERO WIDTH NO-BREAK SPACE</code>: 即宽度为零并且不允许用来拆分单词的字符。 它可以被用来为语言分析算法提供提示。 在 Unicode 4.0 中用 <code>U+FEFF</code> 表示 <code>ZERO WIDTH NO-BREAK SPACE</code> 已被弃用（改用 <code>U+2060</code> (<code>WORD JOINER</code>) 负责此任务）。 然而 Unicode 软件仍然必须能够处理 <code>U+FEFF</code> 的两个含义：作为 BOM 它被用来确定已编码字节的存储布局，并在字节序列被解码为字符串后将其去除；作为 <code>ZERO WIDTH NO-BREAK SPACE</code> 它是一个普通字符，将像其他字符一样被解码。</p>
<p>There’s another encoding that is able to encode the full range of Unicode characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no issues with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists of two parts: marker bits (the most significant bits) and payload bits. The marker bits are a sequence of zero to four <code>1</code> bits followed by a <code>0</code> bit. Unicode characters are encoded like this (with x being payload bits, which when concatenated give the Unicode character):</p>
<table>
<thead>
<tr>
<th align="left">范围</th>
<th align="left">编码</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>U-00000000</code> … <code>U-0000007F</code></td>
<td align="left">0xxxxxxx</td>
</tr>
<tr>
<td align="left"><code>U-00000080</code> … <code>U-000007FF</code></td>
<td align="left">110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td align="left"><code>U-00000800</code> … <code>U-0000FFFF</code></td>
<td align="left">1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td align="left"><code>U-00010000</code> … <code>U-0010FFFF</code></td>
<td align="left">11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p>Unicode 字符最不重要的一个位就是最右侧的二进制位 x。</p>
<p>由于 UTF-8 是一种 8 位编码格式，因此 BOM 是不必要的，并且已编码字符串中的任何 <code>U+FEFF</code> 字符（即使是作为第一个字符）都会被视为是 <code>ZERO WIDTH NO-BREAK SPACE</code>。</p>
<p>在没有外部信息的情况下，就不可能毫无疑义地确定一个字符串使用了何种编码格式。 每种字符映射编码格式都可以解码任意的随机字节序列。 然而对 UTF-8 来说这却是不可能的，因为 UTF-8 字节序列具有不允许任意字节序列的特别结构。 为了提升 UTF-8 编码检测的可靠性，Microsoft 发明了一种 UTF-8 变体形式 (Python 2.5 称之为 <code>"utf-8-sig"</code>) 专门用于其 Notepad 程序：在任何 Unicode 字符在被写入文件之前，会先写入一个 UTF-8 编码的 BOM (它看起来是这样一个字节序列: <code>0xef</code>, <code>0xbb</code>, <code>0xbf</code>)。 由于任何字符映射编码后的文件都不大可能以这些字节值开头（例如它们会映射为</p>
<blockquote>
<p>LATIN SMALL LETTER I WITH DIAERESIS</p>
<p>RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK</p>
<p>INVERTED QUESTION MARK</p>
</blockquote>
<p>对于 iso-8859-1 编码格式来说），这提升了根据字节序列来正确猜测 <code>utf-8-sig</code> 编码格式的成功率。 所以在这里 BOM 的作用并不是帮助确定生成字节序列所使用的字节顺序，而是作为帮助猜测编码格式的记号。 在进行编码时 utf-8-sig 编解码器将把 <code>0xef</code>, <code>0xbb</code>, <code>0xbf</code> 作为头三个字节写入文件。 在进行解码时 <code>utf-8-sig</code> 将跳过这三个字节，如果它们作为文件的头三个字节出现的话。 在 UTF-8 中并不推荐使用 BOM，通常应当避免它们的出现。</p>
<h3 id="标准编码"><a href="#标准编码" class="headerlink" title="标准编码"></a>标准编码</h3><p>Python 自带了许多内置的编解码器，它们的实现或者是通过 C 函数，或者是通过映射表。 以下表格是按名称排序的编解码器列表，并提供了一些常见别名以及编码格式通常针对的语言。 别名和语言列表都不是详尽无遗的。 请注意仅有大小写区别或使用连字符替代下划线的拼写形式也都是有效的别名；因此，<code>'utf-8'</code> 是 <code>'utf_8'</code> 编解码器的有效别名。</p>
<p><strong>CPython implementation detail:</strong> 有些常见编码格式可以绕过编解码器查找机制来提升性能。 这些优化机会对于 CPython 来说仅能通过一组有限的别名（大小写不敏感）来识别：utf-8, utf8, latin-1, latin1, iso-8859-1, iso8859-1, mbcs (Windows 专属), ascii, us-ascii, utf-16, utf16, utf-32, utf32, 也包括使用下划线替代连字符的的形式。 使用这些编码格式的其他别名可能会导致更慢的执行速度。</p>
<p>在 3.6 版更改: 可识别针对 us-ascii 的优化机会。</p>
<p>许多字符集都支持相同的语言。 它们在个别字符（例如是否支持 EURO SIGN 等）以及给字符所分配的码位方面存在差异。 特别是对于欧洲语言来说，通常存在以下几种变体：</p>
<ul>
<li>某个 ISO 8859 编码集</li>
<li>某个 Microsoft Windows 编码页，通常是派生自某个 8859 编码集，但会用附加的图形字符来替换控制字符。</li>
<li>某个 IBM EBCDIC 编码页</li>
<li>某个 IBM PC 编码页，通常会兼容 ASCII</li>
</ul>
<table>
<thead>
<tr>
<th align="left">编码</th>
<th align="left">别名</th>
<th align="left">语言</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ascii</td>
<td align="left">646, us-ascii</td>
<td align="left">英语</td>
</tr>
<tr>
<td align="left">big5</td>
<td align="left">big5-tw, csbig5</td>
<td align="left">繁体中文</td>
</tr>
<tr>
<td align="left">big5hkscs</td>
<td align="left">big5-hkscs, hkscs</td>
<td align="left">繁体中文</td>
</tr>
<tr>
<td align="left">cp037</td>
<td align="left">IBM037, IBM039</td>
<td align="left">英语</td>
</tr>
<tr>
<td align="left">cp273</td>
<td align="left">273, IBM273, csIBM273</td>
<td align="left">德语3.4 新版功能.</td>
</tr>
<tr>
<td align="left">cp424</td>
<td align="left">EBCDIC-CP-HE, IBM424</td>
<td align="left">希伯来语</td>
</tr>
<tr>
<td align="left">cp437</td>
<td align="left">437, IBM437</td>
<td align="left">英语</td>
</tr>
<tr>
<td align="left">cp500</td>
<td align="left">EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">cp720</td>
<td align="left"></td>
<td align="left">阿拉伯语</td>
</tr>
<tr>
<td align="left">cp737</td>
<td align="left"></td>
<td align="left">希腊语</td>
</tr>
<tr>
<td align="left">cp775</td>
<td align="left">IBM775</td>
<td align="left">波罗的海语言</td>
</tr>
<tr>
<td align="left">cp850</td>
<td align="left">850, IBM850</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">cp852</td>
<td align="left">852, IBM852</td>
<td align="left">中欧和东欧</td>
</tr>
<tr>
<td align="left">cp855</td>
<td align="left">855, IBM855</td>
<td align="left">保加利亚语，白俄罗斯语，马其顿语，俄语，塞尔维亚语</td>
</tr>
<tr>
<td align="left">cp856</td>
<td align="left"></td>
<td align="left">希伯来语</td>
</tr>
<tr>
<td align="left">cp857</td>
<td align="left">857, IBM857</td>
<td align="left">土耳其语</td>
</tr>
<tr>
<td align="left">cp858</td>
<td align="left">858, IBM858</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">cp860</td>
<td align="left">860, IBM860</td>
<td align="left">葡萄牙语</td>
</tr>
<tr>
<td align="left">cp861</td>
<td align="left">861, CP-IS, IBM861</td>
<td align="left">冰岛语</td>
</tr>
<tr>
<td align="left">cp862</td>
<td align="left">862, IBM862</td>
<td align="left">希伯来语</td>
</tr>
<tr>
<td align="left">cp863</td>
<td align="left">863, IBM863</td>
<td align="left">加拿大语</td>
</tr>
<tr>
<td align="left">cp864</td>
<td align="left">IBM864</td>
<td align="left">阿拉伯语</td>
</tr>
<tr>
<td align="left">cp865</td>
<td align="left">865, IBM865</td>
<td align="left">丹麦语/挪威语</td>
</tr>
<tr>
<td align="left">cp866</td>
<td align="left">866, IBM866</td>
<td align="left">俄语</td>
</tr>
<tr>
<td align="left">cp869</td>
<td align="left">869, CP-GR, IBM869</td>
<td align="left">希腊语</td>
</tr>
<tr>
<td align="left">cp874</td>
<td align="left"></td>
<td align="left">泰语</td>
</tr>
<tr>
<td align="left">cp875</td>
<td align="left"></td>
<td align="left">希腊语</td>
</tr>
<tr>
<td align="left">cp932</td>
<td align="left">932, ms932, mskanji, ms-kanji</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">cp949</td>
<td align="left">949, ms949, uhc</td>
<td align="left">韩语</td>
</tr>
<tr>
<td align="left">cp950</td>
<td align="left">950, ms950</td>
<td align="left">繁体中文</td>
</tr>
<tr>
<td align="left">cp1006</td>
<td align="left"></td>
<td align="left">乌尔都语</td>
</tr>
<tr>
<td align="left">cp1026</td>
<td align="left">ibm1026</td>
<td align="left">土耳其语</td>
</tr>
<tr>
<td align="left">cp1125</td>
<td align="left">1125, ibm1125, cp866u, ruscii</td>
<td align="left">乌克兰语3.4 新版功能.</td>
</tr>
<tr>
<td align="left">cp1140</td>
<td align="left">ibm1140</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">cp1250</td>
<td align="left">windows-1250</td>
<td align="left">中欧和东欧</td>
</tr>
<tr>
<td align="left">cp1251</td>
<td align="left">windows-1251</td>
<td align="left">保加利亚语，白俄罗斯语，马其顿语，俄语，塞尔维亚语</td>
</tr>
<tr>
<td align="left">cp1252</td>
<td align="left">windows-1252</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">cp1253</td>
<td align="left">windows-1253</td>
<td align="left">希腊语</td>
</tr>
<tr>
<td align="left">cp1254</td>
<td align="left">windows-1254</td>
<td align="left">土耳其语</td>
</tr>
<tr>
<td align="left">cp1255</td>
<td align="left">windows-1255</td>
<td align="left">希伯来语</td>
</tr>
<tr>
<td align="left">cp1256</td>
<td align="left">windows-1256</td>
<td align="left">阿拉伯语</td>
</tr>
<tr>
<td align="left">cp1257</td>
<td align="left">windows-1257</td>
<td align="left">波罗的海语言</td>
</tr>
<tr>
<td align="left">cp1258</td>
<td align="left">windows-1258</td>
<td align="left">越南语</td>
</tr>
<tr>
<td align="left">euc_jp</td>
<td align="left">eucjp, ujis, u-jis</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">euc_jis_2004</td>
<td align="left">jisx0213, eucjis2004</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">euc_jisx0213</td>
<td align="left">eucjisx0213</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">euc_kr</td>
<td align="left">euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001</td>
<td align="left">韩语</td>
</tr>
<tr>
<td align="left">gb2312</td>
<td align="left">chinese, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, gb2312-80, iso-ir-58</td>
<td align="left">简体中文</td>
</tr>
<tr>
<td align="left">gbk</td>
<td align="left">936, cp936, ms936</td>
<td align="left">统一汉语</td>
</tr>
<tr>
<td align="left">gb18030</td>
<td align="left">gb18030-2000</td>
<td align="left">统一汉语</td>
</tr>
<tr>
<td align="left">hz</td>
<td align="left">hzgb, hz-gb, hz-gb-2312</td>
<td align="left">简体中文</td>
</tr>
<tr>
<td align="left">iso2022_jp</td>
<td align="left">csiso2022jp, iso2022jp, iso-2022-jp</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">iso2022_jp_1</td>
<td align="left">iso2022jp-1, iso-2022-jp-1</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">iso2022_jp_2</td>
<td align="left">iso2022jp-2, iso-2022-jp-2</td>
<td align="left">日语，韩语，简体中文，西欧，希腊语</td>
</tr>
<tr>
<td align="left">iso2022_jp_2004</td>
<td align="left">iso2022jp-2004, iso-2022-jp-2004</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">iso2022_jp_3</td>
<td align="left">iso2022jp-3, iso-2022-jp-3</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">iso2022_jp_ext</td>
<td align="left">iso2022jp-ext, iso-2022-jp-ext</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">iso2022_kr</td>
<td align="left">csiso2022kr, iso2022kr, iso-2022-kr</td>
<td align="left">韩语</td>
</tr>
<tr>
<td align="left">latin_1</td>
<td align="left">iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">iso8859_2</td>
<td align="left">iso-8859-2, latin2, L2</td>
<td align="left">中欧和东欧</td>
</tr>
<tr>
<td align="left">iso8859_3</td>
<td align="left">iso-8859-3, latin3, L3</td>
<td align="left">世界语，马耳他语</td>
</tr>
<tr>
<td align="left">iso8859_4</td>
<td align="left">iso-8859-4, latin4, L4</td>
<td align="left">波罗的海语言</td>
</tr>
<tr>
<td align="left">iso8859_5</td>
<td align="left">iso-8859-5, cyrillic</td>
<td align="left">保加利亚语，白俄罗斯语，马其顿语，俄语，塞尔维亚语</td>
</tr>
<tr>
<td align="left">iso8859_6</td>
<td align="left">iso-8859-6, arabic</td>
<td align="left">阿拉伯语</td>
</tr>
<tr>
<td align="left">iso8859_7</td>
<td align="left">iso-8859-7, greek, greek8</td>
<td align="left">希腊语</td>
</tr>
<tr>
<td align="left">iso8859_8</td>
<td align="left">iso-8859-8, hebrew</td>
<td align="left">希伯来语</td>
</tr>
<tr>
<td align="left">iso8859_9</td>
<td align="left">iso-8859-9, latin5, L5</td>
<td align="left">土耳其语</td>
</tr>
<tr>
<td align="left">iso8859_10</td>
<td align="left">iso-8859-10, latin6, L6</td>
<td align="left">北欧语言</td>
</tr>
<tr>
<td align="left">iso8859_11</td>
<td align="left">iso-8859-11, thai</td>
<td align="left">泰语</td>
</tr>
<tr>
<td align="left">iso8859_13</td>
<td align="left">iso-8859-13, latin7, L7</td>
<td align="left">波罗的海语言</td>
</tr>
<tr>
<td align="left">iso8859_14</td>
<td align="left">iso-8859-14, latin8, L8</td>
<td align="left">凯尔特语</td>
</tr>
<tr>
<td align="left">iso8859_15</td>
<td align="left">iso-8859-15, latin9, L9</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">iso8859_16</td>
<td align="left">iso-8859-16, latin10, L10</td>
<td align="left">东南欧</td>
</tr>
<tr>
<td align="left">johab</td>
<td align="left">cp1361, ms1361</td>
<td align="left">韩语</td>
</tr>
<tr>
<td align="left">koi8_r</td>
<td align="left"></td>
<td align="left">俄语</td>
</tr>
<tr>
<td align="left">koi8_t</td>
<td align="left"></td>
<td align="left">塔吉克3.5 新版功能.</td>
</tr>
<tr>
<td align="left">koi8_u</td>
<td align="left"></td>
<td align="left">乌克兰语</td>
</tr>
<tr>
<td align="left">kz1048</td>
<td align="left">kz_1048, strk1048_2002, rk1048</td>
<td align="left">哈萨克语3.5 新版功能.</td>
</tr>
<tr>
<td align="left">mac_cyrillic</td>
<td align="left">maccyrillic</td>
<td align="left">保加利亚语，白俄罗斯语，马其顿语，俄语，塞尔维亚语</td>
</tr>
<tr>
<td align="left">mac_greek</td>
<td align="left">macgreek</td>
<td align="left">希腊语</td>
</tr>
<tr>
<td align="left">mac_iceland</td>
<td align="left">maciceland</td>
<td align="left">冰岛语</td>
</tr>
<tr>
<td align="left">mac_latin2</td>
<td align="left">maclatin2, maccentraleurope, mac_centeuro</td>
<td align="left">中欧和东欧</td>
</tr>
<tr>
<td align="left">mac_roman</td>
<td align="left">macroman, macintosh</td>
<td align="left">西欧</td>
</tr>
<tr>
<td align="left">mac_turkish</td>
<td align="left">macturkish</td>
<td align="left">土耳其语</td>
</tr>
<tr>
<td align="left">ptcp154</td>
<td align="left">csptcp154, pt154, cp154, cyrillic-asian</td>
<td align="left">哈萨克语</td>
</tr>
<tr>
<td align="left">shift_jis</td>
<td align="left">csshiftjis, shiftjis, sjis, s_jis</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">shift_jis_2004</td>
<td align="left">shiftjis2004, sjis_2004, sjis2004</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">shift_jisx0213</td>
<td align="left">shiftjisx0213, sjisx0213, s_jisx0213</td>
<td align="left">日语</td>
</tr>
<tr>
<td align="left">utf_32</td>
<td align="left">U32, utf32</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_32_be</td>
<td align="left">UTF-32BE</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_32_le</td>
<td align="left">UTF-32LE</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_16</td>
<td align="left">U16, utf16</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_16_be</td>
<td align="left">UTF-16BE</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_16_le</td>
<td align="left">UTF-16LE</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_7</td>
<td align="left">U7, unicode-1-1-utf-7</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_8</td>
<td align="left">U8, UTF, utf8, cp65001</td>
<td align="left">所有语言</td>
</tr>
<tr>
<td align="left">utf_8_sig</td>
<td align="left"></td>
<td align="left">所有语言</td>
</tr>
</tbody></table>
<p>在 3.4 版更改: utf-16* 和 utf-32* 编码器将不再允许编码代理码位 (<code>U+D800</code>–<code>U+DFFF</code>)。 utf-32* 解码器将不再解码与代理码位相对应的字节序列。</p>
<p>在 3.8 版更改: <code>cp65001</code> 现在是 <code>utf_8</code> 的一个别名。</p>
<h3 id="Python-专属的编码格式"><a href="#Python-专属的编码格式" class="headerlink" title="Python 专属的编码格式"></a>Python 专属的编码格式</h3><p>有一些预定义编解码器是 Python 专属的，因此它们在 Python 之外没有意义。 这些编解码器按其所预期的输入和输出类型在下表中列出（请注意虽然文本编码是编解码器最常见的使用场景，但下层的编解码器架构支持任意数据转换而不仅是文本编码）。 对于非对称编解码器，该列描述的含义是编码方向。</p>
<h4 id="文字编码"><a href="#文字编码" class="headerlink" title="文字编码"></a>文字编码</h4><p>以下编解码器提供了 <code>str</code> 到 <code>bytes</code> 的编码和 bytes-like object 到 <code>str</code> 的解码，类似于 Unicode 文本编码。</p>
<table>
<thead>
<tr>
<th align="left">编码</th>
<th align="left">别名</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left">idna</td>
<td align="left"></td>
<td align="left">实现 <a href="https://tools.ietf.org/html/rfc3490.html" target="_blank" rel="noopener"><strong>RFC 3490</strong></a>。仅支持 <code>errors=’strict’</code> 。</td>
</tr>
<tr>
<td align="left">mbcs</td>
<td align="left">ansi, dbcs</td>
<td align="left">Windows 专属：根据 ANSI 代码页（CP_ACP）对操作数进行编码。</td>
</tr>
<tr>
<td align="left">oem</td>
<td align="left"></td>
<td align="left">Windows 专属：根据 OEM 代码页（CP_OEMCP）对操作数进行编码。3.6 新版功能.</td>
</tr>
<tr>
<td align="left">palmos</td>
<td align="left"></td>
<td align="left">PalmOS 3.5 的编码格式</td>
</tr>
<tr>
<td align="left">punycode</td>
<td align="left"></td>
<td align="left">实现 <a href="https://tools.ietf.org/html/rfc3492.html" target="_blank" rel="noopener"><strong>RFC 3492</strong></a>。 不支持有状态编解码器。</td>
</tr>
<tr>
<td align="left">raw_unicode_escape</td>
<td align="left"></td>
<td align="left">Latin-1 编码格式附带对其他码位以 <code>\uXXXX</code> 和 <code>\UXXXXXXXX</code> 进行编码。 现有反斜杠不会以任何方式转义。 它被用于 Python 的 pickle 协议。</td>
</tr>
<tr>
<td align="left">undefined</td>
<td align="left"></td>
<td align="left">所有转换都将引发异常，甚至对空字符串也不例外。 错误处理方案会被忽略。</td>
</tr>
<tr>
<td align="left">unicode_escape</td>
<td align="left"></td>
<td align="left">适合用于以 ASCII 编码的 Python 源代码中的 Unicode 字面值内容的编码格式，但引号不会被转义。 对 Latin-1 源代码进行解码。 请注意 Python 源代码实际上默认使用 UTF-8。</td>
</tr>
</tbody></table>
<p>在 3.8 版更改: “unicode_internal” 编解码器已被移除。</p>
<h4 id="二进制转换"><a href="#二进制转换" class="headerlink" title="二进制转换"></a>二进制转换</h4><p>以下编解码器提供了二进制转换: bytes-like object 到 <code>bytes</code> 的映射。 它们不被 <code>bytes.decode()</code> 所支持（该方法只生成 <code>str</code> 类型的输出）。</p>
<table>
<thead>
<tr>
<th align="left">编码</th>
<th align="left">别名</th>
<th align="left">含意</th>
<th align="left">编码器/解码器</th>
</tr>
</thead>
<tbody><tr>
<td align="left">base64_codec</td>
<td align="left">base64, base_64</td>
<td align="left">将操作数转换为多行 MIME base64 (结果总是包含一个末尾的 <code>‘\n’</code>)在 3.4 版更改: 接受任意 bytes-like object 作为输入用于编码和解码</td>
<td align="left"><code>base64.encodebytes()</code> / <code>base64.decodebytes()</code></td>
</tr>
<tr>
<td align="left">bz2_codec</td>
<td align="left">bz2</td>
<td align="left">使用bz2压缩操作数</td>
<td align="left"><code>bz2.compress()</code> / <code>bz2.decompress()</code></td>
</tr>
<tr>
<td align="left">hex_codec</td>
<td align="left">hex</td>
<td align="left">将操作数转换为十六进制表示，每个字节有两位数</td>
<td align="left"><code>binascii.b2a_hex()</code> / <code>binascii.a2b_hex()</code></td>
</tr>
<tr>
<td align="left">quopri_codec</td>
<td align="left">quopri, quotedprintable, quoted_printable</td>
<td align="left">将操作数转换为 MIME 带引号的可打印数据</td>
<td align="left"><code>quopri.encode()</code> 且 <code>quotetabs=True</code> / <code>quopri.decode()</code></td>
</tr>
<tr>
<td align="left">uu_codec</td>
<td align="left">uu</td>
<td align="left">使用uuencode转换操作数</td>
<td align="left"><code>uu.encode()</code> / <code>uu.decode()</code></td>
</tr>
<tr>
<td align="left">zlib_codec</td>
<td align="left">zip, zlib</td>
<td align="left">使用gzip压缩操作数</td>
<td align="left"><code>zlib.compress()</code> / <code>zlib.decompress()</code></td>
</tr>
</tbody></table>
<p>除了 字节类对象，<code>'base64_codec'</code> 也接受仅包含 ASCII 的 <code>str</code> 实例用于解码</p>
<p>3.2 新版功能: 恢复二进制转换。</p>
<p>在 3.4 版更改: 恢复二进制转换的别名。</p>
<h4 id="文字转换"><a href="#文字转换" class="headerlink" title="文字转换"></a>文字转换</h4><p>以下编解码器提供了文本转换: <code>str</code> 到 <code>str</code> 的映射。 它不被 <code>str.encode()</code> 所支持（该方法只生成 <code>bytes</code> 类型的输出）。</p>
<table>
<thead>
<tr>
<th align="left">编码</th>
<th align="left">别名</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left">rot_13</td>
<td align="left">rot13</td>
<td align="left">返回操作数的凯撒密码加密结果</td>
</tr>
</tbody></table>
<p>3.2 新版功能: 恢复 <code>rot_13</code> 文本转换。</p>
<p>在 3.4 版更改: 恢复 <code>rot13</code> 别名。</p>
<h3 id="encodings-idna-—-应用程序中的国际化域名"><a href="#encodings-idna-—-应用程序中的国际化域名" class="headerlink" title="encodings.idna —- 应用程序中的国际化域名"></a><code>encodings.idna</code> —- 应用程序中的国际化域名</h3><p>此模块实现了 <a href="https://tools.ietf.org/html/rfc3490.html" target="_blank" rel="noopener"><strong>RFC 3490</strong></a> (应用程序中的国际化域名) 和 <a href="https://tools.ietf.org/html/rfc3492.html" target="_blank" rel="noopener"><strong>RFC 3492</strong></a> (Nameprep: 用于国际化域名 (IDN) 的 Stringprep 配置文件)。 它是在 <code>punycode</code> 编码格式和 <code>stringprep</code> 的基础上构建的。</p>
<p>如果你需要来自 <a href="https://tools.ietf.org/html/rfc5891.html" target="_blank" rel="noopener"><strong>RFC 5891</strong></a> 和 <a href="https://tools.ietf.org/html/rfc5895.html" target="_blank" rel="noopener"><strong>RFC 5895</strong></a> 的 IDNA 2008 标准，请使用第三方 idna 模块 <a href="https://pypi.org/project/idna/" target="_blank" rel="noopener">https://pypi.org/project/idna/</a></p>
<p>这些 RFC 共同定义了一个在域名中支持非 ASCII 字符的协议。 一个包含非 ASCII 字符的域名 (例如 <code>www.Alliancefrançaise.nu</code>) 会被转换为兼容 ASCII 的编码格式 (简称 ACE，例如 <code>www.xn--alliancefranaise-npb.nu</code>)。 随后此域名的 ACE 形式可以用于所有由于特定协议而不允许使用任意字符的场合，例如 DNS 查询，HTTP <em>Host</em> 字段等等。 此转换是在应用中进行的；如有可能将对用户可见：应用应当透明地将 Unicode 域名标签转换为线上的 IDNA，并在 ACE 标签被呈现给用户之前将其转换回 Unicode。</p>
<p>Python 以多种方式支持这种转换: <code>idna</code> 编解码器执行 Unicode 和 ACE 之间的转换，基于在 <a href="https://tools.ietf.org/html/rfc3490.html#section-3.1" target="_blank" rel="noopener"><strong>section 3.1 of RFC 3490</strong></a> 中定义的分隔字符将输入字符串拆分为标签，再根据需要将每个标签转换为 ACE，相反地又会基于 <code>.</code> 分隔符将输入字节串拆分为标签，再将找到的任何 ACE 标签转换为 Unicode。 此外，<code>socket</code> 模块可透明地将 Unicode 主机名转换为 ACE，以便应用在将它们传给 socket 模块时无须自行转换主机名。 除此之外，许多包含以主机名作为函数参数的模块例如 <code>http.client</code> 和 <code>ftplib</code> 都接受 Unicode 主机名（并且 <code>http.client</code> 也会在 <em>Host</em> 字段中透明地发送 IDNA 主机名，如果它需要发送该字段的话）。</p>
<p>当从线路接收主机名时（例如反向名称查找），到 Unicode 的转换不会自动被执行：希望向用户提供此种主机名的应用应当将它们解码为 Unicode。</p>
<p><code>encodings.idna</code> 模块还实现了 nameprep 过程，该过程会对主机名执行特定的规范化操作，以实现国际域名的大小写不敏感特性与合并相似的字符。 如果有需要可以直接使用 nameprep 函数。</p>
<p><code>encodings.idna.nameprep</code>(<em>label</em>)</p>
<p>返回 <em>label</em> 经过名称处理操作的版本。 该实现目前基于查询字符串，因此 <code>AllowUnassigned</code> 为真值。</p>
<p><code>encodings.idna.ToASCII</code>(<em>label</em>)</p>
<p>将标签转换为 ASCII，规则定义见 <a href="https://tools.ietf.org/html/rfc3490.html" target="_blank" rel="noopener"><strong>RFC 3490</strong></a>。 <code>UseSTD3ASCIIRules</code> 预设为假值。</p>
<p><code>encodings.idna.ToUnicode</code>(<em>label</em>)</p>
<p>将标签转换为 Unicode，规则定义见 <a href="https://tools.ietf.org/html/rfc3490.html" target="_blank" rel="noopener"><strong>RFC 3490</strong></a>。</p>
<h3 id="encodings-mbcs-—-Windows-ANSI代码页"><a href="#encodings-mbcs-—-Windows-ANSI代码页" class="headerlink" title="encodings.mbcs —- Windows ANSI代码页"></a><code>encodings.mbcs</code> —- Windows ANSI代码页</h3><p>此模块实现ANSI代码页（CP_ACP）。</p>
<p>Availability: 仅Windows可用</p>
<p>在 3.3 版更改: 支持任何错误处理</p>
<p>在 3.2 版更改: 在 3.2 版之前， <em>errors</em> 参数会被忽略；总是会使用 <code>'replace'</code> 进行编码，并使用 <code>'ignore'</code> 进行解码。</p>
<h3 id="encodings-utf-8-sig-—-带BOM签名的UTF-8编解码器"><a href="#encodings-utf-8-sig-—-带BOM签名的UTF-8编解码器" class="headerlink" title="encodings.utf_8_sig —- 带BOM签名的UTF-8编解码器"></a><code>encodings.utf_8_sig</code> —- 带BOM签名的UTF-8编解码器</h3><p>此模块实现了 UTF-8 编解码器的一个变种：在编码时将把 UTF-8 已编码 BOM 添加到 UTF-8 编码字节数据的开头。 对于有状态编码器此操作只执行一次（当首次写入字节流时）。 在解码时将跳过数据开头作为可选项的 UTF-8 已编码 BOM。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Python也提供一些内置数据类型，特别是，<code>dict</code>、 <code>list</code>、<code>set</code>、<code>frozenset</code>、以及 <code>tuple</code>。<code>str</code> 这个类是用来存储Unicode字符串的，而 <code>bytes</code> 和 <code>bytearray</code> 这两个类是用来存储二进制数据的。</p>
<p>本章包含以下模块的文档：</p>
<ul>
<li><code>datetime</code> —- 基本日期和时间类型<ul>
<li>感知型对象和简单型对象</li>
<li>常量</li>
<li>有效的类型<ul>
<li>通用的特征属性</li>
<li>确定一个对象是感知型还是简单型</li>
</ul>
</li>
<li><code>timedelta</code> 类对象<ul>
<li>class:timedelta 用法示例</li>
</ul>
</li>
<li><code>date</code> 对象<ul>
<li>class:date 用法示例</li>
</ul>
</li>
<li><code>datetime</code> 对象<ul>
<li>用法示例: <code>datetime</code></li>
</ul>
</li>
<li><code>time</code> 对象<ul>
<li>用法示例: <code>time</code></li>
</ul>
</li>
<li><code>tzinfo</code> 对象</li>
<li><code>timezone</code> 对象</li>
<li><code>strftime()</code> 和 <code>strptime()</code> 的行为<ul>
<li><code>strftime()</code> 和 <code>strptime()</code> Format Codes</li>
<li>技术细节</li>
</ul>
</li>
</ul>
</li>
<li><code>zoneinfo</code> —- IANA 时区支持<ul>
<li>使用 <code>ZoneInfo</code></li>
<li>数据源<ul>
<li>配置数据源<ul>
<li>编译时配置</li>
<li>环境配置</li>
<li>运行时配置</li>
</ul>
</li>
</ul>
</li>
<li><code>ZoneInfo</code> 类<ul>
<li>字符串表示</li>
<li>封存序列化</li>
</ul>
</li>
<li>函数</li>
<li>全局变量</li>
<li>异常与警告</li>
</ul>
</li>
<li><code>calendar</code> —- 日历相关函数</li>
<li><code>collections</code> —- 容器数据类型<ul>
<li><code>ChainMap</code> 对象<ul>
<li><code>ChainMap</code> 例子和方法</li>
</ul>
</li>
<li><code>Counter</code> 对象</li>
<li><code>deque</code> 对象<ul>
<li><code>deque</code> 用法</li>
</ul>
</li>
<li><code>defaultdict</code> 对象<ul>
<li><code>defaultdict</code> 例子</li>
</ul>
</li>
<li><code>namedtuple()</code> 命名元组的工厂函数</li>
<li><code>OrderedDict</code> 对象<ul>
<li><code>OrderedDict</code> 例子和用法</li>
</ul>
</li>
<li><code>UserDict</code> 对象</li>
<li><code>UserList</code> 对象</li>
<li><code>UserString</code> 对象</li>
</ul>
</li>
<li><code>collections.abc</code> —- 容器的抽象基类<ul>
<li>容器抽象基类</li>
<li>Collections Abstract Base Classes — Detailed Descriptions</li>
<li>Examples and Recipes</li>
</ul>
</li>
<li><code>heapq</code> —- 堆队列算法<ul>
<li>基本示例</li>
<li>优先队列实现说明</li>
<li>理论</li>
</ul>
</li>
<li><code>bisect</code> —- 数组二分查找算法<ul>
<li>性能说明</li>
<li>搜索有序列表</li>
<li>例子</li>
</ul>
</li>
<li><code>array</code> —- 高效的数值数组</li>
<li><code>weakref</code> —- 弱引用<ul>
<li>弱引用对象</li>
<li>示例</li>
<li>终结器对象</li>
<li>比较终结器与 <code>__del__()</code> 方法</li>
</ul>
</li>
<li><code>types</code> —- 动态类型创建和内置类型名称<ul>
<li>动态类型创建</li>
<li>标准解释器类型</li>
<li>附加工具类和函数</li>
<li>协程工具函数</li>
</ul>
</li>
<li><code>copy</code> —- 浅层 (shallow) 和深层 (deep) 复制操作</li>
<li><code>pprint</code> —- 数据美化输出<ul>
<li>PrettyPrinter 对象</li>
<li>示例</li>
</ul>
</li>
<li><code>reprlib</code> —- 另一种 <code>repr()</code> 实现<ul>
<li>Repr 对象</li>
<li>子类化 Repr 对象</li>
</ul>
</li>
<li><code>enum</code> —- 对枚举的支持<ul>
<li>模块内容</li>
<li>创建 Enum</li>
<li>枚举成员及其属性的编程访问</li>
<li>重复的枚举成员和值</li>
<li>确保唯一枚举值</li>
<li>使用自动设定的值</li>
<li>迭代</li>
<li>比较运算</li>
<li>允许的枚举成员和属性</li>
<li>受限的 Enum 子类化</li>
<li>封存</li>
<li>功能性 API</li>
<li>派生的枚举<ul>
<li>IntEnum</li>
<li>IntFlag</li>
<li>旗标</li>
<li>其他事项</li>
</ul>
</li>
<li>何时使用 <code>__new__()</code> 与 <code>__init__()</code></li>
<li>有趣的示例<ul>
<li>省略值<ul>
<li>使用 <code>auto</code></li>
<li>使用 <code>object</code></li>
<li>使用描述性字符串</li>
<li>使用自定义的 <code>__new__()</code></li>
</ul>
</li>
<li>OrderedEnum</li>
<li>DuplicateFreeEnum</li>
<li>Planet</li>
<li>TimePeriod</li>
</ul>
</li>
<li>各种枚举有何区别？<ul>
<li>枚举类</li>
<li>枚举成员（即实例）</li>
<li>细节要点<ul>
<li>支持的 <code>__dunder__</code> 名称</li>
<li>支持的 <code>_sunder_</code> 名称</li>
<li>_Private__names</li>
<li><code>Enum</code> 成员类型</li>
<li><code>Enum</code> 类和成员的布尔值</li>
<li>带有方法的 <code>Enum</code> 类</li>
<li>组合 <code>Flag</code> 的成员</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>graphlib</code> —- 操作类似图的结构的功能<ul>
<li>异常</li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io" rel="external nofollow noreferrer">杰克成</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io/posts/blog-python28.html">https://jackhcc.github.io/posts/blog-python28.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Python/">
                                    <span class="chip bg-color">Python</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/aliqr.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/wxqr.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '3821a0bbb773038a51fc',
        clientSecret: '4b30b507d67ec5497ec0e77f43f80cb3e0d7dd3a',
        repo: 'JackHCC.github.io',
        owner: 'JackHCC',
        admin: "JackHCC",
        id: '2021-11-03T19-18-39',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/dl-series17.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/8.jpg" class="responsive-img" alt="DL专栏17>网络可视化">
                        
                        <span class="card-title">DL专栏17>网络可视化</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            深度学习模型网络可视化概述
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-11-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Deep-Learning/" class="post-category">
                                    Deep Learning
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Deep-Learning/">
                        <span class="chip bg-color">Deep Learning</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/basic-know-006.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/7.jpg" class="responsive-img" alt="反爬虫详解">
                        
                        <span class="card-title">反爬虫详解</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            反爬虫机制与方法详解
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Basic/" class="post-category">
                                    Basic
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Crawler/">
                        <span class="chip bg-color">Crawler</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('4'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">2414.3k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "2";
                    var startDate = "27";
                    var startHour = "6";
                    var startMinute = "30";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/JackHCC" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:jackcc0701@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://www.facebook.com/profile.php?id=100046343443643" class="tooltipped" target="_blank" data-tooltip="关注我的Facebook: https://www.facebook.com/profile.php?id=100046343443643" data-position="top" data-delay="50">
        <i class="fab fa-facebook-f"></i>
    </a>



    <a href="https://twitter.com/JackChe66021834" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/JackChe66021834" data-position="top" data-delay="50">
        <i class="fab fa-twitter"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2508074836" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2508074836" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/6885584679" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/6885584679" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/matery.js"></script>

    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script type="text/javascript" src="/js/fireworks.js"></script>

    <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>'); }
    </script>

    <!-- weather -->
	<script type="text/javascript">
	WIDGET = {FID: 'TToslpmkVO'}
	</script>
	<script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>


    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

    
    
    <script async src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    
        <script src="//code.tidio.co/kqhlkxviiccyoa0czpfpu4ijuey9hfre.js"></script>
        <script> 
            $(document).ready(function () {
                setInterval(change_Tidio, 50);  
                function change_Tidio() { 
                    var tidio=$("#tidio-chat iframe");
                    if(tidio.css("display")=="block"&& $(window).width()>977 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" &&$(window).width()>977)>0? "-40px" : ($("div.toc-title").length&&$(window).width()>977)>0?"85px":"20px";   
                        document.getElementById("tidio-chat-iframe").style.right="-15px";   
                        document.getElementById("tidio-chat-iframe").style.height=parseInt(tidio.css("height"))>=520?"520px":tidio.css("height");
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    } 
                    else if(tidio.css("display")=="block"&&$(window).width()>601 &&$(window).width()<992 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && 601< $(window).width()<992)>0? "-40px":"20px" ;   
                        document.getElementById("tidio-chat-iframe").style.right="-15px"; 
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    else if(tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))<230){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && $(window).width()<601)>0? "-10px":"45px" ;   
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    if( tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))>=230){
                        document.getElementById("tidio-chat-iframe").style.zIndex="998";
                    }
                } 
            }); 
        </script>
    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/instantpage/instantpage.js" type="module"></script>
    
<script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script>
        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        $('a').each(function() {
          const $this = $(this);
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'your_domain' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script></body>

</html>

