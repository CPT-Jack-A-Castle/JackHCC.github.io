<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Python-Standard Library, JackHCC">
    <meta name="description" content="Python标准库详解【2】">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Python-Standard Library | JackHCC</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my.css">
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="JackHCC" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-hopscotch.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JackHCC</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">JackHCC</div>
        <div class="logo-desc">
            
            Make the world betterrrr!!!
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JackHCC/JackHCC.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JackHCC/JackHCC.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/7.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Python-Standard Library</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 30px;
        bottom: 146px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Python/">
                                <span class="chip bg-color">Python</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Python/" class="post-category">
                                Python
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-11-04
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-11-14
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    87.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    353 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Python-标准库"><a href="#Python-标准库" class="headerlink" title="Python 标准库"></a>Python 标准库</h1><ul>
<li>函数式编程模块<ul>
<li><code>itertools</code> —- 为高效循环而创建迭代器的函数</li>
<li><code>functools</code> —- 高阶函数和可调用对象上的操作</li>
<li><code>operator</code> —- 标准运算符替代函数</li>
</ul>
</li>
<li>文件和目录访问<ul>
<li><code>pathlib</code> —- 面向对象的文件系统路径</li>
<li><code>os.path</code> —- 常用路径操作</li>
<li><code>fileinput</code> —- 迭代来自多个输入流的行</li>
<li><code>stat</code> —- 解析 <code>stat()</code> 结果</li>
<li><code>filecmp</code> —- 文件及目录的比较</li>
<li><code>tempfile</code> —- 生成临时文件和目录</li>
<li><code>glob</code> —- Unix 风格路径名模式扩展</li>
<li><code>fnmatch</code> —- Unix 文件名模式匹配</li>
<li><code>linecache</code> —- 随机读写文本行</li>
<li><code>shutil</code> —- 高阶文件操作</li>
</ul>
</li>
<li>数据持久化<ul>
<li><code>pickle</code> —- Python 对象序列化</li>
<li><code>copyreg</code> —- 注册配合 <code>pickle</code> 模块使用的函数</li>
<li><code>shelve</code> —- Python 对象持久化</li>
<li><code>marshal</code> —- 内部 Python 对象序列化</li>
<li><code>dbm</code> —- Unix “数据库” 接口</li>
<li><code>sqlite3</code> —- SQLite 数据库 DB-API 2.0 接口模块</li>
</ul>
</li>
<li>数据压缩和存档<ul>
<li><code>zlib</code> —- 与 <strong>gzip</strong> 兼容的压缩</li>
<li><code>gzip</code> —- 对 <strong>gzip</strong> 格式的支持</li>
<li><code>bz2</code> —- 对 <strong>bzip2</strong> 压缩算法的支持</li>
<li><code>lzma</code> —- 用 LZMA 算法压缩</li>
<li><code>zipfile</code> —- 使用ZIP存档</li>
<li><code>tarfile</code> —- 读写tar归档文件</li>
</ul>
</li>
<li>文件格式<ul>
<li><code>csv</code> —- CSV 文件读写</li>
<li><code>configparser</code> —- 配置文件解析器</li>
<li><code>netrc</code> —- netrc 文件处理</li>
<li><code>xdrlib</code> —- 编码与解码 XDR 数据</li>
<li><code>plistlib</code> —- 生成与解析 Apple <code>.plist</code> 文件</li>
</ul>
</li>
<li>加密服务<ul>
<li><code>hashlib</code> —- 安全哈希与消息摘要</li>
<li><code>hmac</code> —- 基于密钥的消息验证</li>
<li><code>secrets</code> —- 生成管理密码的安全随机数</li>
</ul>
</li>
<li>通用操作系统服务<ul>
<li><code>os</code> —- 多种操作系统接口</li>
<li><code>io</code> —- 处理流的核心工具</li>
<li><code>time</code> —- 时间的访问和转换</li>
<li><code>argparse</code> —- 命令行选项、参数和子命令解析器</li>
<li><code>getopt</code> —- C 风格的命令行选项解析器</li>
<li><code>logging</code> —- Python 的日志记录工具</li>
<li><code>logging.config</code> —- 日志记录配置</li>
<li><code>logging.handlers</code> —- 日志处理程序</li>
<li><code>getpass</code> —- 便携式密码输入工具</li>
<li><code>curses</code> —- 终端字符单元显示的处理</li>
<li><code>curses.textpad</code> —- 用于 curses 程序的文本输入控件</li>
<li><code>curses.ascii</code> —- 用于 ASCII 字符的工具</li>
<li><code>curses.panel</code> —- curses 的面板栈扩展</li>
<li><code>platform</code> —- 获取底层平台的标识数据</li>
<li><code>errno</code> —- 标准 errno 系统符号</li>
<li><code>ctypes</code> —- Python 的外部函数库</li>
</ul>
</li>
<li>并发执行<ul>
<li><code>threading</code> —- 基于线程的并行</li>
<li><code>multiprocessing</code> —- 基于进程的并行</li>
<li><code>multiprocessing.shared_memory</code> —- 可从进程直接访问的共享内存</li>
<li><code>concurrent</code> 包</li>
<li><code>concurrent.futures</code> —- 启动并行任务</li>
<li><code>subprocess</code> —- 子进程管理</li>
<li><code>sched</code> —- 事件调度器</li>
<li><code>queue</code> —- 一个同步的队列类</li>
<li><code>contextvars</code> —- 上下文变量</li>
<li><code>_thread</code> —- 底层多线程 API</li>
</ul>
</li>
<li>网络和进程间通信<ul>
<li><code>asyncio</code> —- 异步 I/O</li>
<li><code>socket</code> —- 底层网络接口</li>
<li><code>ssl</code> —- 套接字对象的 TLS/SSL 包装器</li>
<li><code>select</code> —- 等待 I/O 完成</li>
<li><code>selectors</code> —- 高级 I/O 复用库</li>
<li><code>asyncore</code> —- 异步套接字处理器</li>
<li><code>asynchat</code> —- 异步套接字指令/响应处理程序</li>
<li><code>signal</code> —- 设置异步事件处理程序</li>
<li><code>mmap</code> —- 内存映射文件支持</li>
</ul>
</li>
<li>互联网数据处理<ul>
<li><code>email</code> —- 电子邮件与 MIME 处理包</li>
<li><code>json</code> —- JSON 编码和解码器</li>
<li><code>mailcap</code> —- Mailcap 文件处理</li>
<li><code>mailbox</code> —- 操作多种格式的邮箱</li>
<li><code>mimetypes</code> —- 映射文件名到 MIME 类型</li>
<li><code>base64</code> —- Base16, Base32, Base64, Base85 数据编码</li>
<li><code>binhex</code> —- 对binhex4文件进行编码和解码</li>
<li><code>binascii</code> —- 二进制和 ASCII 码互转</li>
<li><code>quopri</code> —- 编码与解码经过 MIME 转码的可打印数据</li>
<li><code>uu</code> —- 对 uuencode 文件进行编码与解码</li>
</ul>
</li>
<li>结构化标记处理工具<ul>
<li><code>html</code> —- 超文本标记语言支持</li>
<li><code>html.parser</code> —- 简单的 HTML 和 XHTML 解析器</li>
<li><code>html.entities</code> —- HTML 一般实体的定义</li>
<li>XML处理模块</li>
<li><code>xml.etree.ElementTree</code> —- ElementTree XML API</li>
<li><code>xml.dom</code> —- 文档对象模型 API</li>
<li><code>xml.dom.minidom</code> —- 最小化的 DOM 实现</li>
<li><code>xml.dom.pulldom</code> —- 支持构建部分 DOM 树</li>
<li><code>xml.sax</code> —- 支持 SAX2 解析器</li>
<li><code>xml.sax.handler</code> —- SAX 处理句柄的基类</li>
<li><code>xml.sax.saxutils</code> —- SAX 工具集</li>
<li><code>xml.sax.xmlreader</code> —- 用于 XML 解析器的接口</li>
<li><code>xml.parsers.expat</code> —- 使用 Expat 的快速 XML 解析</li>
</ul>
</li>
<li>互联网协议和支持<ul>
<li><code>webbrowser</code> —- 方便的 Web 浏览器控制工具</li>
<li><code>cgi</code> —- 通用网关接口支持</li>
<li><code>cgitb</code> —- 用于 CGI 脚本的回溯管理器</li>
<li><code>wsgiref</code> —- WSGI 工具和参考实现</li>
<li><code>urllib</code> —- URL 处理模块</li>
<li><code>urllib.request</code> —- 用于打开 URL 的可扩展库</li>
<li><code>urllib.response</code> —- urllib 使用的 Response 类</li>
<li><code>urllib.parse</code> 用于解析 URL</li>
<li><code>urllib.error</code> —- urllib.request 引发的异常类</li>
<li><code>urllib.robotparser</code> —- robots.txt 语法分析程序</li>
<li><code>http</code> —- HTTP 模块</li>
<li><code>http.client</code> —- HTTP 协议客户端</li>
<li><code>ftplib</code> —- FTP 协议客户端</li>
<li><code>poplib</code> —- POP3 协议客户端</li>
<li><code>imaplib</code> —- IMAP4 协议客户端</li>
<li><code>nntplib</code> —- NNTP protocol client</li>
<li><code>smtplib</code> —-SMTP协议客户端</li>
<li><code>smtpd</code> —- SMTP 服务器</li>
<li><code>telnetlib</code> — Telnet 客户端</li>
<li><code>uuid</code> —- UUID objects according to <strong>RFC 4122</strong></li>
<li><code>socketserver</code> —- A framework for network servers</li>
<li><code>http.server</code> —- HTTP 服务器</li>
<li><code>http.cookies</code> —- HTTP状态管理</li>
<li><code>http.cookiejar</code> —— HTTP 客户端的 Cookie 处理</li>
<li><code>xmlrpc</code> —- XMLRPC 服务端与客户端模块</li>
<li><code>xmlrpc.client</code> —- XML-RPC 客户端访问</li>
<li><code>xmlrpc.server</code> —- 基本 XML-RPC 服务器</li>
<li><code>ipaddress</code> —- IPv4/IPv6 操作库</li>
</ul>
</li>
<li>多媒体服务<ul>
<li><code>audioop</code> —- 处理原始音频数据</li>
<li><code>aifc</code> —- 读写 AIFF 和 AIFC 文件</li>
<li><code>sunau</code> —- 读写 Sun AU 文件</li>
<li><code>wave</code> —- 读写WAV格式文件</li>
<li><code>chunk</code> —- 读取 IFF 分块数据</li>
<li><code>colorsys</code> —- 颜色系统间的转换</li>
<li><code>imghdr</code> —- 推测图像类型</li>
<li><code>sndhdr</code> —- 推测声音文件的类型</li>
<li><code>ossaudiodev</code> —- 访问兼容OSS的音频设备</li>
</ul>
</li>
<li>国际化<ul>
<li><code>gettext</code> —- 多语种国际化服务</li>
<li><code>locale</code> —- 国际化服务</li>
</ul>
</li>
<li>程序框架<ul>
<li><code>turtle</code> —- 海龟绘图</li>
<li><code>cmd</code> —- 支持面向行的命令解释器</li>
<li><code>shlex</code> —— 简单的词法分析</li>
</ul>
</li>
<li>Tk图形用户界面(GUI)<ul>
<li><code>tkinter</code> —- Tcl/Tk的Python接口</li>
<li><code>tkinter.colorchooser</code> —- 颜色选择对话框</li>
<li><code>tkinter.font</code> —- Tkinter 字体封装</li>
<li>Tkinter 对话框</li>
<li><code>tkinter.messagebox</code> —- Tkinter 消息提示</li>
<li><code>tkinter.scrolledtext</code> —- 滚动文字控件</li>
<li><code>tkinter.dnd</code> —- 拖放操作支持</li>
<li><code>tkinter.ttk</code> —- Tk主题部件</li>
<li><code>tkinter.tix</code> —- TK扩展包</li>
<li>IDLE</li>
</ul>
</li>
<li>开发工具<ul>
<li><code>typing</code> —- 类型提示支持</li>
<li><code>pydoc</code> —- 文档生成器和在线帮助系统</li>
<li>Python Development Mode</li>
<li>Effects of the Python Development Mode</li>
<li>ResourceWarning Example</li>
<li>Bad file descriptor error example</li>
<li><code>doctest</code> —- 测试交互性的Python示例</li>
<li><code>unittest</code> —- 单元测试框架</li>
<li><code>unittest.mock</code> —- 模拟对象库</li>
<li><code>unittest.mock</code> 上手指南</li>
<li>2to3 - 自动将 Python 2 代码转为 Python 3 代码</li>
<li><code>test</code> —- Python回归测试包</li>
<li><code>test.support</code> —- Utilities for the Python test suite</li>
<li><code>test.support.socket_helper</code> —- Utilities for socket tests</li>
<li><code>test.support.script_helper</code> —- Utilities for the Python execution tests</li>
<li><code>test.support.bytecode_helper</code> —- Support tools for testing correct bytecode generation</li>
<li><code>test.support.threading_helper</code> —- Utilities for threading tests</li>
<li><code>test.support.os_helper</code> —- Utilities for os tests</li>
<li><code>test.support.import_helper</code> —- Utilities for import tests</li>
<li><code>test.support.warnings_helper</code> —- Utilities for warnings tests</li>
</ul>
</li>
<li>调试和分析<ul>
<li>审计事件表</li>
<li><code>bdb</code> —- Debugger framework</li>
<li><code>faulthandler</code> —- Dump the Python traceback</li>
<li><code>pdb</code> —- Python 的调试器</li>
<li>Python Profilers 分析器</li>
<li><code>timeit</code> —- 测量小代码片段的执行时间</li>
<li><code>trace</code> —- 跟踪Python语句的执行</li>
<li><code>tracemalloc</code> —- 跟踪内存分配</li>
</ul>
</li>
<li>软件打包和分发<ul>
<li><code>distutils</code> —- 构建和安装 Python 模块</li>
<li><code>ensurepip</code> —- Bootstrapping the <code>pip</code> installer</li>
<li><code>venv</code> —- 创建虚拟环境</li>
<li><code>zipapp</code> —- Manage executable Python zip archives</li>
</ul>
</li>
<li>Python运行时服务<ul>
<li><code>sys</code> —- 系统相关的参数和函数</li>
<li><code>sysconfig</code> —- Provide access to Python’s configuration information</li>
<li><code>builtins</code> —- 内建对象</li>
<li><code>__main__</code> —- Top-level code environment</li>
<li><code>warnings</code> —— 警告信息的控制</li>
<li><code>dataclasses</code> —- 数据类</li>
<li><code>contextlib</code> —- 为 <code>with</code>语句上下文提供的工具</li>
<li><code>abc</code> —- 抽象基类</li>
<li><code>atexit</code> —- 退出处理器</li>
<li><code>traceback</code> —- 打印或检索堆栈回溯</li>
<li><code>__future__</code> —- Future 语句定义</li>
<li><code>gc</code> —- 垃圾回收器接口</li>
<li><code>inspect</code> —- 检查对象</li>
<li><code>site</code> —— 指定域的配置钩子</li>
</ul>
</li>
<li>自定义 Python 解释器<ul>
<li><code>code</code> —- 解释器基类</li>
<li><code>codeop</code> —- 编译Python代码</li>
</ul>
</li>
<li>导入模块<ul>
<li><code>zipimport</code> —- 从 Zip 存档中导入模块</li>
<li><code>pkgutil</code> —- 包扩展工具</li>
<li><code>modulefinder</code> —- 查找脚本使用的模块</li>
<li><code>runpy</code> ——查找并执行 Python 模块</li>
<li><code>importlib</code> —- <code>import</code> 的实现</li>
<li>Using <code>importlib.metadata</code></li>
</ul>
</li>
<li>Python 语言服务<ul>
<li><code>ast</code> —- 抽象语法树</li>
<li><code>symtable</code> —- Access to the compiler’s symbol tables</li>
<li><code>token</code> —- 与Python解析树一起使用的常量</li>
<li><code>keyword</code> —- 检验Python关键字</li>
<li><code>tokenize</code> —- 对 Python 代码使用的标记解析器</li>
<li><code>tabnanny</code> —- 模糊缩进检测</li>
<li><code>pyclbr</code> —- Python 模块浏览器支持</li>
<li><code>py_compile</code> —- 编译 Python 源文件</li>
<li><code>compileall</code> —- Byte-compile Python libraries</li>
<li><code>dis</code> —- Python 字节码反汇编器</li>
<li><code>pickletools</code> —- pickle 开发者工具集</li>
</ul>
</li>
<li>Windows系统相关模块<ul>
<li><code>msilib</code> —- Read and write Microsoft Installer files</li>
<li><code>msvcrt</code> —- 来自 MS VC++ 运行时的有用例程</li>
<li><code>winreg</code> —- 访问 Windows 注册表</li>
<li><code>winsound</code> —— Windows 系统的音频播放接口</li>
</ul>
</li>
<li>Unix 专有服务<ul>
<li><code>posix</code> —- 最常见的 POSIX 系统调用</li>
<li><code>pwd</code> —- 用户密码数据库</li>
<li><code>spwd</code> —- The shadow password database</li>
<li><code>grp</code> —- 组数据库</li>
<li><code>crypt</code> —— 验证 Unix 口令的函数</li>
<li><code>termios</code> —- POSIX 风格的 tty 控制</li>
<li><code>tty</code> —- 终端控制功能</li>
<li><code>pty</code> —- 伪终端工具</li>
<li><code>fcntl</code> —— 系统调用 <code>fcntl</code> 和 <code>ioctl</code></li>
<li><code>pipes</code> —- 终端管道接口</li>
<li><code>resource</code> —- Resource usage information</li>
<li><code>nis</code> —- Sun 的 NIS (黄页) 接口</li>
<li>Unix syslog 库例程</li>
</ul>
</li>
<li>被取代的模块<ul>
<li><code>optparse</code> —- 解析器的命令行选项</li>
<li><code>imp</code> —- Access the import internals</li>
</ul>
</li>
<li>未创建文档的模块<ul>
<li>平台特定模块</li>
</ul>
</li>
<li>Security Considerations</li>
</ul>
<h1 id="函数式编程模块"><a href="#函数式编程模块" class="headerlink" title="函数式编程模块"></a>函数式编程模块</h1><ul>
<li><code>itertools</code> —- 为高效循环而创建迭代器的函数<ul>
<li>Itertool函数</li>
<li>itertools 配方</li>
</ul>
</li>
<li><code>functools</code> —- 高阶函数和可调用对象上的操作<ul>
<li><code>partial</code> 对象</li>
</ul>
</li>
<li><code>operator</code> —- 标准运算符替代函数<ul>
<li>将运算符映射到函数</li>
<li>原地运算符</li>
</ul>
</li>
</ul>
<h2 id="itertools-—-为高效循环而创建迭代器的函数"><a href="#itertools-—-为高效循环而创建迭代器的函数" class="headerlink" title="itertools —- 为高效循环而创建迭代器的函数"></a><code>itertools</code> —- 为高效循环而创建迭代器的函数</h2><p>本模块实现一系列 iterator ，这些迭代器受到APL，Haskell和SML的启发。为了适用于Python，它们都被重新写过。</p>
<p>本模块标准化了一个快速、高效利用内存的核心工具集，这些工具本身或组合都很有用。它们一起形成了“迭代器代数”，这使得在纯Python中有可能创建简洁又高效的专用工具。</p>
<p>例如，SML有一个制表工具： <code>tabulate(f)</code>，它可产生一个序列 <code>f(0), f(1), ...</code>。在Python中可以组合 <code>map()</code> 和 <code>count()</code> 实现： <code>map(f, count())</code>。</p>
<p>这些内置工具同时也能很好地与 <code>operator</code> 模块中的高效函数配合使用。例如，我们可以将两个向量的点积映射到乘法运算符： <code>sum(map(operator.mul, vector1, vector2))</code> 。</p>
<p><strong>无穷迭代器：</strong></p>
<table>
<thead>
<tr>
<th align="left">迭代器</th>
<th align="left">实参</th>
<th align="left">结果</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>count()</code></td>
<td align="left">start, [step]</td>
<td align="left">start, start+step, start+2*step, …</td>
<td align="left"><code>count(10) —&gt; 10 11 12 13 14 …</code></td>
</tr>
<tr>
<td align="left"><code>cycle()</code></td>
<td align="left">p</td>
<td align="left">p0, p1, … plast, p0, p1, …</td>
<td align="left"><code>cycle(‘ABCD’) —&gt; A B C D A B C D …</code></td>
</tr>
<tr>
<td align="left"><code>repeat()</code></td>
<td align="left">elem [,n]</td>
<td align="left">elem, elem, elem, … 重复无限次或n次</td>
<td align="left"><code>repeat(10, 3) —&gt; 10 10 10</code></td>
</tr>
</tbody></table>
<p><strong>根据最短输入序列长度停止的迭代器：</strong></p>
<table>
<thead>
<tr>
<th align="left">迭代器</th>
<th align="left">实参</th>
<th align="left">结果</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>accumulate()</code></td>
<td align="left">p [,func]</td>
<td align="left">p0, p0+p1, p0+p1+p2, …</td>
<td align="left"><code>accumulate([1,2,3,4,5]) —&gt; 1 3 6 10 15</code></td>
</tr>
<tr>
<td align="left"><code>chain()</code></td>
<td align="left">p, q, …</td>
<td align="left">p0, p1, … plast, q0, q1, …</td>
<td align="left"><code>chain(‘ABC’, ‘DEF’) —&gt; A B C D E F</code></td>
</tr>
<tr>
<td align="left"><code>chain.from_iterable()</code></td>
<td align="left">iterable — 可迭代对象</td>
<td align="left">p0, p1, … plast, q0, q1, …</td>
<td align="left"><code>chain.from_iterable([‘ABC’, ‘DEF’]) —&gt; A B C D E F</code></td>
</tr>
<tr>
<td align="left"><code>compress()</code></td>
<td align="left">data, selectors</td>
<td align="left">(d[0] if s[0]), (d[1] if s[1]), …</td>
<td align="left"><code>compress(‘ABCDEF’, [1,0,1,0,1,1]) —&gt; A C E F</code></td>
</tr>
<tr>
<td align="left"><code>dropwhile()</code></td>
<td align="left">pred, seq</td>
<td align="left">seq[n], seq[n+1], … 从pred首次真值测试失败开始</td>
<td align="left"><code>dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) —&gt; 6 4 1</code></td>
</tr>
<tr>
<td align="left"><code>filterfalse()</code></td>
<td align="left">pred, seq</td>
<td align="left">seq中pred(x)为假值的元素，x是seq中的元素。</td>
<td align="left"><code>filterfalse(lambda x: x%2, range(10)) —&gt; 0 2 4 6 8</code></td>
</tr>
<tr>
<td align="left"><code>groupby()</code></td>
<td align="left">iterable[, key]</td>
<td align="left">根据key(v)值分组的迭代器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>islice()</code></td>
<td align="left">seq, [start,] stop [, step]</td>
<td align="left">seq[start:stop:step]中的元素</td>
<td align="left"><code>islice(‘ABCDEFG’, 2, None) —&gt; C D E F G</code></td>
</tr>
<tr>
<td align="left"><code>pairwise()</code></td>
<td align="left">iterable — 可迭代对象</td>
<td align="left">(p[0], p[1]), (p[1], p[2])</td>
<td align="left"><code>pairwise(‘ABCDEFG’) —&gt; AB BC CD DE EF FG</code></td>
</tr>
<tr>
<td align="left"><code>starmap()</code></td>
<td align="left">func, seq</td>
<td align="left">func(<em>seq[0]), func(</em>seq[1]), …</td>
<td align="left"><code>starmap(pow, [(2,5), (3,2), (10,3)]) —&gt; 32 9 1000</code></td>
</tr>
<tr>
<td align="left"><code>takewhile()</code></td>
<td align="left">pred, seq</td>
<td align="left">seq[0], seq[1], …, 直到pred真值测试失败</td>
<td align="left"><code>takewhile(lambda x: x&lt;5, [1,4,6,4,1]) —&gt; 1 4</code></td>
</tr>
<tr>
<td align="left"><code>tee()</code></td>
<td align="left">it, n</td>
<td align="left">it1, it2, … itn 将一个迭代器拆分为n个迭代器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>zip_longest()</code></td>
<td align="left">p, q, …</td>
<td align="left">(p[0], q[0]), (p[1], q[1]), …</td>
<td align="left"><code>zip_longest(‘ABCD’, ‘xy’, fillvalue=’-‘) —&gt; Ax By C- D-</code></td>
</tr>
</tbody></table>
<p><strong>排列组合迭代器：</strong></p>
<table>
<thead>
<tr>
<th align="left">迭代器</th>
<th align="left">实参</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>product()</code></td>
<td align="left">p, q, … [repeat=1]</td>
<td align="left">笛卡尔积，相当于嵌套的for循环</td>
</tr>
<tr>
<td align="left"><code>permutations()</code></td>
<td align="left">p[, r]</td>
<td align="left">长度r元组，所有可能的排列，无重复元素</td>
</tr>
<tr>
<td align="left"><code>combinations()</code></td>
<td align="left">p, r</td>
<td align="left">长度r元组，有序，无重复元素</td>
</tr>
<tr>
<td align="left"><code>combinations_with_replacement()</code></td>
<td align="left">p, r</td>
<td align="left">长度r元组，有序，元素可重复</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">例子</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>product(‘ABCD’, repeat=2)</code></td>
<td align="left"><code>AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD</code></td>
</tr>
<tr>
<td align="left"><code>permutations(‘ABCD’, 2)</code></td>
<td align="left"><code>AB AC AD BA BC BD CA CB CD DA DB DC</code></td>
</tr>
<tr>
<td align="left"><code>combinations(‘ABCD’, 2)</code></td>
<td align="left"><code>AB AC AD BC BD CD</code></td>
</tr>
<tr>
<td align="left"><code>combinations_with_replacement(‘ABCD’, 2)</code></td>
<td align="left"><code>AA AB AC AD BB BC BD CC CD DD</code></td>
</tr>
</tbody></table>
<h3 id="Itertool函数"><a href="#Itertool函数" class="headerlink" title="Itertool函数"></a>Itertool函数</h3><p>下列模块函数均创建并返回迭代器。有些迭代器不限制输出流长度，所以它们只应在能截断输出流的函数或循环中使用。</p>
<p><code>itertools.accumulate</code>(<em>iterable</em>[, <em>func</em>, <em>**,</em> initial=None*])</p>
<p>创建一个迭代器，返回累积汇总值或其他双目运算函数的累积结果值（通过可选的 <em>func</em> 参数指定）。</p>
<p>如果提供了 <em>func*，它应当为带有两个参数的函数。 输入 *iterable</em> 的元素可以是能被 <em>func</em> 接受为参数的任意类型。 （例如，对于默认的加法运算，元素可以是任何可相加的类型包括 <code>Decimal</code> 或 <code>Fraction</code>。）</p>
<p>通常，输出的元素数量与输入的可迭代对象是一致的。 但是，如果提供了关键字参数 <em>initial*，则累加会以 *initial</em> 值开始，这样输出就比输入的可迭代对象多一个元素。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> func<span class="token operator">=</span>operator<span class="token punctuation">.</span>add<span class="token punctuation">,</span><span class="token operator">*</span><span class="token punctuation">,</span> initial<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">'Return running totals'</span>
<span class="token comment" spellcheck="true"># accumulate([1,2,3,4,5]) --> 1 3 6 10 15</span>
<span class="token comment" spellcheck="true"># accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115</span>
<span class="token comment" spellcheck="true"># accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    total <span class="token operator">=</span> initial
<span class="token keyword">if</span> initial isNone<span class="token punctuation">:</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
            total <span class="token operator">=</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token keyword">return</span>
<span class="token keyword">yield</span> total
<span class="token keyword">for</span> element <span class="token keyword">in</span> it<span class="token punctuation">:</span>
        total <span class="token operator">=</span> func<span class="token punctuation">(</span>total<span class="token punctuation">,</span> element<span class="token punctuation">)</span>
<span class="token keyword">yield</span> total<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>func</em> 参数有几种用法。它可以被设为 <code>min()</code> 最终得到一个最小值，或者设为 <code>max()</code> 最终得到一个最大值，或设为 <code>operator.mul()</code> 最终得到一个乘积。摊销表可通过累加利息和支付款项得到。给iterable设置初始值并只将参数 <em>func</em> 设为累加总数可以对一阶 递归关系 建模。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>accumulate<span class="token punctuation">(</span>data<span class="token punctuation">,</span>operator<span class="token punctuation">.</span>mul<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># running product</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">72</span><span class="token punctuation">,</span><span class="token number">144</span><span class="token punctuation">,</span><span class="token number">144</span><span class="token punctuation">,</span><span class="token number">1296</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>accumulate<span class="token punctuation">(</span>data<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># running maximum</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># Amortize a 5% loan of 1000 with 4 annual payments of 90</span>
<span class="token operator">>></span><span class="token operator">></span> cashflows <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">90</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>accumulate<span class="token punctuation">(</span>cashflows<span class="token punctuation">,</span><span class="token keyword">lambda</span> bal<span class="token punctuation">,</span> pmt<span class="token punctuation">:</span> bal<span class="token operator">*</span><span class="token number">1.05</span><span class="token operator">+</span> pmt<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">960.0</span><span class="token punctuation">,</span><span class="token number">918.0</span><span class="token punctuation">,</span><span class="token number">873.9000000000001</span><span class="token punctuation">,</span><span class="token number">827.5950000000001</span><span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map</span>
<span class="token operator">>></span><span class="token operator">></span> logistic_map <span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> _<span class="token punctuation">:</span>  r <span class="token operator">*</span> x <span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span> x<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> r <span class="token operator">=</span><span class="token number">3.8</span>
<span class="token operator">>></span><span class="token operator">></span> x0 <span class="token operator">=</span><span class="token number">0.4</span>
<span class="token operator">>></span><span class="token operator">></span> inputs <span class="token operator">=</span> repeat<span class="token punctuation">(</span>x0<span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># only the initial value is used</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">[</span>format<span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token string">'.2f'</span><span class="token punctuation">)</span><span class="token keyword">for</span> x <span class="token keyword">in</span> accumulate<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> logistic_map<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">'0.40'</span><span class="token punctuation">,</span><span class="token string">'0.91'</span><span class="token punctuation">,</span><span class="token string">'0.30'</span><span class="token punctuation">,</span><span class="token string">'0.81'</span><span class="token punctuation">,</span><span class="token string">'0.60'</span><span class="token punctuation">,</span><span class="token string">'0.92'</span><span class="token punctuation">,</span><span class="token string">'0.29'</span><span class="token punctuation">,</span><span class="token string">'0.79'</span><span class="token punctuation">,</span><span class="token string">'0.63'</span><span class="token punctuation">,</span>
<span class="token string">'0.88'</span><span class="token punctuation">,</span><span class="token string">'0.39'</span><span class="token punctuation">,</span><span class="token string">'0.90'</span><span class="token punctuation">,</span><span class="token string">'0.33'</span><span class="token punctuation">,</span><span class="token string">'0.84'</span><span class="token punctuation">,</span><span class="token string">'0.52'</span><span class="token punctuation">,</span><span class="token string">'0.95'</span><span class="token punctuation">,</span><span class="token string">'0.18'</span><span class="token punctuation">,</span><span class="token string">'0.57'</span><span class="token punctuation">,</span>
<span class="token string">'0.93'</span><span class="token punctuation">,</span><span class="token string">'0.25'</span><span class="token punctuation">,</span><span class="token string">'0.71'</span><span class="token punctuation">,</span><span class="token string">'0.79'</span><span class="token punctuation">,</span><span class="token string">'0.63'</span><span class="token punctuation">,</span><span class="token string">'0.88'</span><span class="token punctuation">,</span><span class="token string">'0.39'</span><span class="token punctuation">,</span><span class="token string">'0.91'</span><span class="token punctuation">,</span><span class="token string">'0.32'</span><span class="token punctuation">,</span>
<span class="token string">'0.83'</span><span class="token punctuation">,</span><span class="token string">'0.54'</span><span class="token punctuation">,</span><span class="token string">'0.95'</span><span class="token punctuation">,</span><span class="token string">'0.20'</span><span class="token punctuation">,</span><span class="token string">'0.60'</span><span class="token punctuation">,</span><span class="token string">'0.91'</span><span class="token punctuation">,</span><span class="token string">'0.30'</span><span class="token punctuation">,</span><span class="token string">'0.80'</span><span class="token punctuation">,</span><span class="token string">'0.60'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参考一个类似函数 <code>functools.reduce()</code> ，它只返回一个最终累积值。</p>
<p>3.2 新版功能.</p>
<p>在 3.3 版更改: 增加可选参数 <em>func</em> 。</p>
<p>在 3.8 版更改: 添加了可选的 <em>initial</em> 形参。</p>
<p><code>itertools.chain</code>(<em>\</em>iterables*)</p>
<p>创建一个迭代器，它首先返回第一个可迭代对象中所有元素，接着返回下一个可迭代对象中所有元素，直到耗尽所有可迭代对象中的元素。可将多个序列处理为单个序列。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">chain</span><span class="token punctuation">(</span><span class="token operator">*</span>iterables<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># chain('ABC', 'DEF') --> A B C D E F</span>
<span class="token keyword">for</span> it <span class="token keyword">in</span> iterables<span class="token punctuation">:</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> it<span class="token punctuation">:</span>
<span class="token keyword">yield</span> element<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>classmethod<em><code>chain.from_iterable</code>(</em>iterable</em>)</p>
<p>构建类似 <code>chain()</code> 迭代器的另一个选择。从一个单独的可迭代参数中得到链式输入，该参数是延迟计算的。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">from_iterable</span><span class="token punctuation">(</span>iterables<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># chain.from_iterable(['ABC', 'DEF']) --> A B C D E F</span>
<span class="token keyword">for</span> it <span class="token keyword">in</span> iterables<span class="token punctuation">:</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> it<span class="token punctuation">:</span>
<span class="token keyword">yield</span> element<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.combinations</code>(<em>iterable</em>, <em>r</em>)</p>
<p>返回由输入 <em>iterable</em> 中元素组成长度为 <em>r</em> 的子序列。</p>
<p>组合元组会以字典顺序根据所输入 <em>iterable</em> 的顺序发出。 因此，如果所输入 <em>iterable</em> 是已排序的，组合元组也将按已排序的顺序生成。</p>
<p>即使元素的值相同，不同位置的元素也被认为是不同的。如果元素各自不同，那么每个组合中没有重复元素。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">combinations</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># combinations('ABCD', 2) --> AB AC AD BC BD CD</span>
<span class="token comment" spellcheck="true"># combinations(range(4), 3) --> 012 013 023 123</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
<span class="token keyword">if</span> r <span class="token operator">></span> n<span class="token punctuation">:</span>
<span class="token keyword">return</span>
    indices <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span>
whileTrue<span class="token punctuation">:</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> reversed<span class="token punctuation">(</span>range<span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span> i <span class="token operator">+</span> n <span class="token operator">-</span> r<span class="token punctuation">:</span>
<span class="token keyword">break</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span>
        indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
<span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
            indices<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span> indices<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>combinations()</code> 的代码可被改写为 <code>permutations()</code> 过滤后的子序列，（相对于元素在输入中的位置）元素不是有序的。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">combinations</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
<span class="token keyword">for</span> indices <span class="token keyword">in</span> permutations<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> sorted<span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token operator">==</span> list<span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 <code>0 &lt;= r &lt;= n</code> 时，返回项的个数是 <code>n! / r! / (n-r)!</code>；当 <code>r &gt; n</code> 时，返回项个数为0。</p>
<p><code>itertools.combinations_with_replacement</code>(<em>iterable</em>, <em>r</em>)</p>
<p>返回由输入 <em>iterable</em> 中元素组成的长度为 <em>r</em> 的子序列，允许每个元素可重复出现。</p>
<p>组合元组会以字典顺序根据所输入 <em>iterable</em> 的顺序发出。 因此，如果所输入 <em>iterable</em> 是已排序的，组合元组也将按已排序的顺序生成。</p>
<p>不同位置的元素是不同的，即使它们的值相同。因此如果输入中的元素都是不同的话，返回的组合中元素也都会不同。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">combinations_with_replacement</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
ifnot n <span class="token operator">and</span> r<span class="token punctuation">:</span>
<span class="token keyword">return</span>
    indices <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span> r
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span>
whileTrue<span class="token punctuation">:</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> reversed<span class="token punctuation">(</span>range<span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span> n <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
<span class="token keyword">break</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span>
        indices<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span>indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>r <span class="token operator">-</span> i<span class="token punctuation">)</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>combinations_with_replacement()</code> 的代码可被改写为 <code>production()</code> 过滤后的子序列，（相对于元素在输入中的位置）元素不是有序的。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">combinations_with_replacement</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
<span class="token keyword">for</span> indices <span class="token keyword">in</span> product<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> repeat<span class="token operator">=</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> sorted<span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token operator">==</span> list<span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 <code>n &gt; 0</code> 时，返回项个数为 <code>(n+r-1)! / r! / (n-1)!</code>.</p>
<p>3.1 新版功能.</p>
<p><code>itertools.compress</code>(<em>data</em>, <em>selectors</em>)</p>
<p>创建一个迭代器，它返回 <em>data</em> 中经 <em>selectors</em> 真值测试为 <code>True</code> 的元素。迭代器在两者较短的长度处停止。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">compress</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> selectors<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F</span>
<span class="token keyword">return</span><span class="token punctuation">(</span>d <span class="token keyword">for</span> d<span class="token punctuation">,</span> s <span class="token keyword">in</span> zip<span class="token punctuation">(</span>data<span class="token punctuation">,</span> selectors<span class="token punctuation">)</span><span class="token keyword">if</span> s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3.1 新版功能.</p>
<p><code>itertools.count</code>(<em>start=0</em>, <em>step=1</em>)</p>
<p>创建一个迭代器，它从 <em>start</em> 值开始，返回均匀间隔的值。常用于 <code>map()</code> 中的实参来生成连续的数据点。此外，还用于 <code>zip()</code> 来添加序列号。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> step<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># count(10) --> 10 11 12 13 14 ...</span>
<span class="token comment" spellcheck="true"># count(2.5, 0.5) -> 2.5 3.0 3.5 ...</span>
    n <span class="token operator">=</span> start
whileTrue<span class="token punctuation">:</span>
<span class="token keyword">yield</span> n
        n <span class="token operator">+=</span> step<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当对浮点数计数时，替换为乘法代码有时精度会更好，例如： <code>(start + step * i for i in count())</code> 。</p>
<p>在 3.1 版更改: 增加参数 <em>step</em> ，允许非整型。</p>
<p><code>itertools.cycle</code>(<em>iterable</em>)</p>
<p>创建一个迭代器，返回 <em>iterable</em> 中所有元素并保存一个副本。当取完 <em>iterable</em> 中所有元素，返回副本中的所有元素。无限重复。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cycle</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># cycle('ABCD') --> A B C D A B C D A B C D ...</span>
    saved <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
<span class="token keyword">yield</span> element
        saved<span class="token punctuation">.</span>append<span class="token punctuation">(</span>element<span class="token punctuation">)</span>
<span class="token keyword">while</span> saved<span class="token punctuation">:</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> saved<span class="token punctuation">:</span>
<span class="token keyword">yield</span> element<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，该函数可能需要相当大的辅助空间（取决于 <em>iterable</em> 的长度）。</p>
<p><code>itertools.dropwhile</code>(<em>predicate</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，如果 <em>predicate</em> 为true，迭代器丢弃这些元素，然后返回其他元素。注意，迭代器在 <em>predicate</em> 首次为false之前不会产生任何输出，所以可能需要一定长度的启动时间。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dropwhile</span><span class="token punctuation">(</span>predicate<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --> 6 4 1</span>
    iterable <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
ifnot predicate<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> x
<span class="token keyword">break</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
<span class="token keyword">yield</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.filterfalse</code>(<em>predicate</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，只返回 <em>iterable</em> 中 <em>predicate</em> 为 <code>False</code> 的元素。如果 <em>predicate</em> 是 <code>None</code>，返回真值测试为false的元素。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">filterfalse</span><span class="token punctuation">(</span>predicate<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8</span>
<span class="token keyword">if</span> predicate isNone<span class="token punctuation">:</span>
        predicate <span class="token operator">=</span>bool
<span class="token keyword">for</span> x <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
ifnot predicate<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.groupby</code>(<em>iterable</em>, <em>key=None</em>)</p>
<p>创建一个迭代器，返回 <em>iterable</em> 中连续的键和组。<em>key</em> 是一个计算元素键值函数。如果未指定或为 <code>None</code>，<em>key</em> 缺省为恒等函数（identity function），返回元素不变。一般来说，<em>iterable</em> 需用同一个键值函数预先排序。</p>
<p><code>groupby()</code> 操作类似于Unix中的 <code>uniq</code>。当每次 <em>key</em> 函数产生的键值改变时，迭代器会分组或生成一个新组（这就是为什么通常需要使用同一个键值函数先对数据进行排序）。这种行为与SQL的GROUP BY操作不同，SQL的操作会忽略输入的顺序将相同键值的元素分在同组中。</p>
<p>返回的组本身也是一个迭代器，它与 <code>groupby()</code> 共享底层的可迭代对象。因为源是共享的，当 <code>groupby()</code> 对象向后迭代时，前一个组将消失。因此如果稍后还需要返回结果，可保存为列表：</p>
<pre class="line-numbers language-python"><code class="language-python">groups <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
uniquekeys <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
data <span class="token operator">=</span> sorted<span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token operator">=</span>keyfunc<span class="token punctuation">)</span>
<span class="token keyword">for</span> k<span class="token punctuation">,</span> g <span class="token keyword">in</span> groupby<span class="token punctuation">(</span>data<span class="token punctuation">,</span> keyfunc<span class="token punctuation">)</span><span class="token punctuation">:</span>
    groups<span class="token punctuation">.</span>append<span class="token punctuation">(</span>list<span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Store group iterator as a list</span>
    uniquekeys<span class="token punctuation">.</span>append<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>groupby()</code> 大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">groupby</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B</span>
<span class="token comment" spellcheck="true"># [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D</span>
<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> iterable<span class="token punctuation">,</span> key<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> key isNone<span class="token punctuation">:</span>
            key <span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x
self<span class="token punctuation">.</span>keyfunc <span class="token operator">=</span> key
self<span class="token punctuation">.</span>it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
self<span class="token punctuation">.</span>tgtkey <span class="token operator">=</span>self<span class="token punctuation">.</span>currkey <span class="token operator">=</span>self<span class="token punctuation">.</span>currvalue <span class="token operator">=</span>object<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
returnself
<span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
self<span class="token punctuation">.</span>id <span class="token operator">=</span>object<span class="token punctuation">(</span><span class="token punctuation">)</span>
whileself<span class="token punctuation">.</span>currkey <span class="token operator">==</span>self<span class="token punctuation">.</span>tgtkey<span class="token punctuation">:</span>
self<span class="token punctuation">.</span>currvalue <span class="token operator">=</span>next<span class="token punctuation">(</span>self<span class="token punctuation">.</span>it<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Exit on StopIteration</span>
self<span class="token punctuation">.</span>currkey <span class="token operator">=</span>self<span class="token punctuation">.</span>keyfunc<span class="token punctuation">(</span>self<span class="token punctuation">.</span>currvalue<span class="token punctuation">)</span>
self<span class="token punctuation">.</span>tgtkey <span class="token operator">=</span>self<span class="token punctuation">.</span>currkey
<span class="token keyword">return</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>currkey<span class="token punctuation">,</span>self<span class="token punctuation">.</span>_grouper<span class="token punctuation">(</span>self<span class="token punctuation">.</span>tgtkey<span class="token punctuation">,</span>self<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">_grouper</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tgtkey<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">:</span>
whileself<span class="token punctuation">.</span>id <span class="token keyword">is</span> id andself<span class="token punctuation">.</span>currkey <span class="token operator">==</span> tgtkey<span class="token punctuation">:</span>
yieldself<span class="token punctuation">.</span>currvalue
<span class="token keyword">try</span><span class="token punctuation">:</span>
self<span class="token punctuation">.</span>currvalue <span class="token operator">=</span>next<span class="token punctuation">(</span>self<span class="token punctuation">.</span>it<span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token keyword">return</span>
self<span class="token punctuation">.</span>currkey <span class="token operator">=</span>self<span class="token punctuation">.</span>keyfunc<span class="token punctuation">(</span>self<span class="token punctuation">.</span>currvalue<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.islice</code>(<em>iterable</em>, <em>stop</em>)</p>
<p><code>itertools.islice</code>(<em>iterable</em>, <em>start</em>, <em>stop</em>[, <em>step</em>])</p>
<p>创建一个迭代器，返回从 <em>iterable</em> 里选中的元素。如果 <em>start</em> 不是0，跳过 <em>iterable</em> 中的元素，直到到达 <em>start</em> 这个位置。之后迭代器连续返回元素，除非 <em>step</em> 设置的值很高导致被跳过。如果 <em>stop</em> 为 <code>None</code>，迭代器耗光为止；否则，在指定的位置停止。与普通的切片不同，<code>islice()</code> 不支持将 <em>start</em> ， <em>stop</em> ，或 <em>step</em> 设为负值。可用来从内部数据结构被压平的数据中提取相关字段（例如一个多行报告，它的名称字段出现在每三行上）。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">islice</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># islice('ABCDEFG', 2) --> A B</span>
<span class="token comment" spellcheck="true"># islice('ABCDEFG', 2, 4) --> C D</span>
<span class="token comment" spellcheck="true"># islice('ABCDEFG', 2, None) --> C D E F G</span>
<span class="token comment" spellcheck="true"># islice('ABCDEFG', 0, None, 2) --> A C E G</span>
    s <span class="token operator">=</span> slice<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
    start<span class="token punctuation">,</span> stop<span class="token punctuation">,</span> step <span class="token operator">=</span> s<span class="token punctuation">.</span>start or0<span class="token punctuation">,</span> s<span class="token punctuation">.</span>stop <span class="token operator">or</span> sys<span class="token punctuation">.</span>maxsize<span class="token punctuation">,</span> s<span class="token punctuation">.</span>step or1
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>range<span class="token punctuation">(</span>start<span class="token punctuation">,</span> stop<span class="token punctuation">,</span> step<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
        nexti <span class="token operator">=</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Consume *iterable* up to the *start* position.</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> element <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">pass</span>
<span class="token keyword">return</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> element <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> i <span class="token operator">==</span> nexti<span class="token punctuation">:</span>
<span class="token keyword">yield</span> element
                nexti <span class="token operator">=</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Consume to *stop*.</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> element <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span>i <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> stop<span class="token punctuation">)</span><span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>start</em> 为 <code>None</code>，迭代从0开始。如果 <em>step</em> 为 <code>None</code> ，步长缺省为1。</p>
<p><code>itertools.pairwise</code>(<em>iterable</em>)</p>
<p>返回从输入 <em>iterable</em> 中获取的连续重叠对。</p>
<p>输出迭代器中 2 元组的数量将比输入的数量少一个。 如果输入可迭代对象中少于两个值则它将为空。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">pairwise</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># pairwise('ABCDEFG') --> AB BC CD DE EF FG</span>
    a<span class="token punctuation">,</span> b <span class="token operator">=</span> tee<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
next<span class="token punctuation">(</span>b<span class="token punctuation">,</span>None<span class="token punctuation">)</span>
<span class="token keyword">return</span> zip<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.10 新版功能.</p>
<p><code>itertools.permutations</code>(<em>iterable</em>, <em>r=None</em>)</p>
<p>连续返回由 <em>iterable</em> 元素生成长度为 <em>r</em> 的排列。</p>
<p>如果 <em>r</em> 未指定或为 <code>None</code> ，<em>r</em> 默认设置为 <em>iterable</em> 的长度，这种情况下，生成所有全长排列。</p>
<p>排列元组会以字典顺序根据所输入 <em>iterable</em> 的顺序发出。 因此，如果所输入 <em>iterable</em> 是已排序的，组合元组也将按已排序的顺序生成。</p>
<p>即使元素的值相同，不同位置的元素也被认为是不同的。如果元素值都不同，每个排列中的元素值不会重复。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">permutations</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC</span>
<span class="token comment" spellcheck="true"># permutations(range(3)) --> 012 021 102 120 201 210</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
    r <span class="token operator">=</span> n <span class="token keyword">if</span> r isNoneelse r
<span class="token keyword">if</span> r <span class="token operator">></span> n<span class="token punctuation">:</span>
<span class="token keyword">return</span>
    indices <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
    cycles <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">,</span> n<span class="token operator">-</span>r<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">[</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> n<span class="token punctuation">:</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> reversed<span class="token punctuation">(</span>range<span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            cycles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>
<span class="token keyword">if</span> cycles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                indices<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">=</span> indices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">+</span> indices<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
                cycles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span> n <span class="token operator">-</span> i
<span class="token keyword">else</span><span class="token punctuation">:</span>
                j <span class="token operator">=</span> cycles<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> indices<span class="token punctuation">[</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token operator">=</span> indices<span class="token punctuation">[</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">[</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">break</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>permutations()</code> 的代码也可被改写为 <code>product()</code> 的子序列，只要将含有重复元素（来自输入中同一位置的）的项排除。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">permutations</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
    r <span class="token operator">=</span> n <span class="token keyword">if</span> r isNoneelse r
<span class="token keyword">for</span> indices <span class="token keyword">in</span> product<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> repeat<span class="token operator">=</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> len<span class="token punctuation">(</span>set<span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span> r<span class="token punctuation">:</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 <code>0 &lt;= r &lt;= n</code> ，返回项个数为 <code>n! / (n-r)!</code> ；当 <code>r &gt; n</code> ，返回项个数为0。</p>
<p><code>itertools.product</code>(<em>\</em>iterables<em>,</em> repeat=1*)</p>
<p>可迭代对象输入的笛卡儿积。</p>
<p>大致相当于生成器表达式中的嵌套循环。例如， <code>product(A, B)</code> 和 <code>((x,y) for x in A for y in B)</code> 返回结果一样。</p>
<p>嵌套循环像里程表那样循环变动，每次迭代时将最右侧的元素向后迭代。这种模式形成了一种字典序，因此如果输入的可迭代对象是已排序的，笛卡尔积元组依次序发出。</p>
<p>要计算可迭代对象自身的笛卡尔积，将可选参数 <em>repeat</em> 设定为要重复的次数。例如，<code>product(A, repeat=4)</code> 和 <code>product(A, A, A, A)</code> 是一样的。</p>
<p>该函数大致相当于下面的代码，只不过实际实现方案不会在内存中创建中间结果。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">product</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> repeat<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy</span>
<span class="token comment" spellcheck="true"># product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111</span>
    pools <span class="token operator">=</span><span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token keyword">for</span> pool <span class="token keyword">in</span> args<span class="token punctuation">]</span><span class="token operator">*</span> repeat
    result <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> pool <span class="token keyword">in</span> pools<span class="token punctuation">:</span>
        result <span class="token operator">=</span><span class="token punctuation">[</span>x<span class="token operator">+</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token keyword">for</span> x <span class="token keyword">in</span> result <span class="token keyword">for</span> y <span class="token keyword">in</span> pool<span class="token punctuation">]</span>
<span class="token keyword">for</span> prod <span class="token keyword">in</span> result<span class="token punctuation">:</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>prod<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>product()</code> 运行之前，它会完全耗尽输入的可迭代对象，在内存中保留值的临时池以生成结果积。 相应地，它只适用于有限的输入。</p>
<p><code>itertools.repeat</code>(<em>object</em>[, <em>times</em>])</p>
<p>创建一个迭代器，不断重复 <em>object</em> 。除非设定参数 <em>times</em> ，否则将无限重复。可用于 <code>map()</code> 函数中的参数，被调用函数可得到一个不变参数。也可用于 <code>zip()</code> 的参数以在元组记录中创建一个不变的部分。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">repeat</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> times<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># repeat(10, 3) --> 10 10 10</span>
<span class="token keyword">if</span> times isNone<span class="token punctuation">:</span>
whileTrue<span class="token punctuation">:</span>
yieldobject
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>times<span class="token punctuation">)</span><span class="token punctuation">:</span>
yieldobject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>repeat</em> 最常见的用途就是在 <em>map</em> 或 <em>zip</em> 提供一个常量流：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>pow<span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> repeat<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">49</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">,</span><span class="token number">81</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>itertools.starmap</code>(<em>function</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，使用从可迭代对象中获取的参数来计算该函数。当参数对应的形参已从一个单独可迭代对象组合为元组时（数据已被“预组对”）可用此函数代替 <code>map()</code>。<code>map()</code> 与 <code>starmap()</code> 之间的区别可以类比 <code>function(a,b)</code> 与 <code>function(*c)</code> 的区别。大致相当于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">starmap</span><span class="token punctuation">(</span>function<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000</span>
<span class="token keyword">for</span> args <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
yieldfunction<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.takewhile</code>(<em>predicate</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，只要 predicate 为真就从可迭代对象中返回元素。大致相当于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">takewhile</span><span class="token punctuation">(</span>predicate<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --> 1 4</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
<span class="token keyword">if</span> predicate<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> x
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.tee</code>(<em>iterable</em>, <em>n=2</em>)</p>
<p>从一个可迭代对象中返回 <em>n</em> 个独立的迭代器。</p>
<p>下面的Python代码能帮助解释 <em>tee</em> 做了什么（尽管实际的实现更复杂，而且仅使用了一个底层的 FIFO 队列）。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">tee</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    deques <span class="token operator">=</span><span class="token punctuation">[</span>collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">gen</span><span class="token punctuation">(</span>mydeque<span class="token punctuation">)</span><span class="token punctuation">:</span>
whileTrue<span class="token punctuation">:</span>
ifnot mydeque<span class="token punctuation">:</span><span class="token comment" spellcheck="true"># when the local deque is empty</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
                    newval <span class="token operator">=</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># fetch a new value and</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token keyword">return</span>
<span class="token keyword">for</span> d <span class="token keyword">in</span> deques<span class="token punctuation">:</span><span class="token comment" spellcheck="true"># load it to all the deques</span>
                    d<span class="token punctuation">.</span>append<span class="token punctuation">(</span>newval<span class="token punctuation">)</span>
<span class="token keyword">yield</span> mydeque<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>gen<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token keyword">for</span> d <span class="token keyword">in</span> deques<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一旦 <code>tee()</code> 实施了一次分裂，原有的 <em>iterable</em> 不应再被使用；否则tee对象无法得知 <em>iterable</em> 可能已向后迭代。</p>
<p><code>tee</code> 迭代器不是线程安全的。当同时使用由同一个 <code>tee()</code> 调用所返回的迭代器时可能引发 <code>RuntimeError</code>，即使原本的 <em>iterable</em> 是线程安全的。</p>
<p>该迭代工具可能需要相当大的辅助存储空间（这取决于要保存多少临时数据）。通常，如果一个迭代器在另一个迭代器开始之前就要使用大部份或全部数据，使用 <code>list()</code> 会比 <code>tee()</code> 更快。</p>
<p><code>itertools.zip_longest</code>(<em>\</em>iterables<em>,</em> fillvalue=None*)</p>
<p>创建一个迭代器，从每个可迭代对象中收集元素。如果可迭代对象的长度未对齐，将根据 <em>fillvalue</em> 填充缺失值。迭代持续到耗光最长的可迭代对象。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">zip_longest</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> fillvalue<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-</span>
    iterators <span class="token operator">=</span><span class="token punctuation">[</span>iter<span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token keyword">for</span> it <span class="token keyword">in</span> args<span class="token punctuation">]</span>
    num_active <span class="token operator">=</span> len<span class="token punctuation">(</span>iterators<span class="token punctuation">)</span>
ifnot num_active<span class="token punctuation">:</span>
<span class="token keyword">return</span>
whileTrue<span class="token punctuation">:</span>
        values <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> it <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>iterators<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
                value <span class="token operator">=</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
                num_active <span class="token operator">-=</span><span class="token number">1</span>
ifnot num_active<span class="token punctuation">:</span>
<span class="token keyword">return</span>
                iterators<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span> repeat<span class="token punctuation">(</span>fillvalue<span class="token punctuation">)</span>
                value <span class="token operator">=</span> fillvalue
            values<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>values<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果其中一个可迭代对象有无限长度，<code>zip_longest()</code> 函数应封装在限制调用次数的场景中（例如 <code>islice()</code> 或 <code>takewhile()</code>）。除非指定， <em>fillvalue</em> 默认为 <code>None</code> 。</p>
<h3 id="itertools-配方"><a href="#itertools-配方" class="headerlink" title="itertools 配方"></a>itertools 配方</h3><p>本节将展示如何使用现有的 itertools 作为基础构件来创建扩展的工具集。</p>
<p>基本上所有这些西方和许许多多其他的配方都可以通过 Python Package Index 上的 more-itertools 项目 来安装:</p>
<pre><code>pip install more-itertools</code></pre><p>扩展的工具提供了与底层工具集相同的高性能。保持了超棒的内存利用率，因为一次只处理一个元素，而不是将整个可迭代对象加载到内存。代码量保持得很小，以函数式风格将这些工具连接在一起，有助于消除临时变量。速度依然很快，因为倾向于使用“矢量化”构件来取代解释器开销大的 for 循环和 generator 。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">take</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Return first n items of the iterable as a list"</span>
<span class="token keyword">return</span> list<span class="token punctuation">(</span>islice<span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">prepend</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> iterator<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Prepend a single value in front of an iterator"</span>
<span class="token comment" spellcheck="true"># prepend(1, [2, 3, 4]) -> 1 2 3 4</span>
<span class="token keyword">return</span> chain<span class="token punctuation">(</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">,</span> iterator<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">tabulate</span><span class="token punctuation">(</span>function<span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Return function(0), function(1), ..."</span>
<span class="token keyword">return</span> map<span class="token punctuation">(</span>function<span class="token punctuation">,</span> count<span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">tail</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Return an iterator over the last n items"</span>
<span class="token comment" spellcheck="true"># tail(3, 'ABCDEFG') --> E F G</span>
<span class="token keyword">return</span> iter<span class="token punctuation">(</span>collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> maxlen<span class="token operator">=</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">consume</span><span class="token punctuation">(</span>iterator<span class="token punctuation">,</span> n<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Advance the iterator n-steps ahead. If n is None, consume entirely."</span>
<span class="token comment" spellcheck="true"># Use functions that consume iterators at C speed.</span>
<span class="token keyword">if</span> n isNone<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># feed the entire iterator into a zero-length deque</span>
        collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span>iterator<span class="token punctuation">,</span> maxlen<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># advance to the empty slice starting at position n</span>
next<span class="token punctuation">(</span>islice<span class="token punctuation">(</span>iterator<span class="token punctuation">,</span> n<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span>None<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">nth</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">,</span>default<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Returns the nth item or a default value"</span>
returnnext<span class="token punctuation">(</span>islice<span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">,</span>None<span class="token punctuation">)</span><span class="token punctuation">,</span>default<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">all_equal</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Returns True if all the elements are equal to each other"</span>
    g <span class="token operator">=</span> groupby<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
returnnext<span class="token punctuation">(</span>g<span class="token punctuation">,</span><span class="token boolean">True</span><span class="token punctuation">)</span>andnotnext<span class="token punctuation">(</span>g<span class="token punctuation">,</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">quantify</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> pred<span class="token operator">=</span>bool<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Count how many times the predicate is true"</span>
<span class="token keyword">return</span> sum<span class="token punctuation">(</span>map<span class="token punctuation">(</span>pred<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">pad_none</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""Returns the sequence elements and then returns None indefinitely.
    Useful for emulating the behavior of the built-in map() function.
    """</span>
<span class="token keyword">return</span> chain<span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> repeat<span class="token punctuation">(</span>None<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">ncycles</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Returns the sequence elements n times"</span>
<span class="token keyword">return</span> chain<span class="token punctuation">.</span>from_iterable<span class="token punctuation">(</span>repeat<span class="token punctuation">(</span>tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">dotproduct</span><span class="token punctuation">(</span>vec1<span class="token punctuation">,</span> vec2<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> sum<span class="token punctuation">(</span>map<span class="token punctuation">(</span>operator<span class="token punctuation">.</span>mul<span class="token punctuation">,</span> vec1<span class="token punctuation">,</span> vec2<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">convolve</span><span class="token punctuation">(</span>signal<span class="token punctuation">,</span> kernel<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># See:  https://betterexplained.com/articles/intuitive-convolution/</span>
<span class="token comment" spellcheck="true"># convolve(data, [0.25, 0.25, 0.25, 0.25]) --> Moving average (blur)</span>
<span class="token comment" spellcheck="true"># convolve(data, [1, -1]) --> 1st finite difference (1st derivative)</span>
<span class="token comment" spellcheck="true"># convolve(data, [1, -2, 1]) --> 2nd finite difference (2nd derivative)</span>
    kernel <span class="token operator">=</span> tuple<span class="token punctuation">(</span>kernel<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>kernel<span class="token punctuation">)</span>
    window <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> maxlen<span class="token operator">=</span>n<span class="token punctuation">)</span><span class="token operator">*</span> n
<span class="token keyword">for</span> x <span class="token keyword">in</span> chain<span class="token punctuation">(</span>signal<span class="token punctuation">,</span> repeat<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        window<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token keyword">yield</span> sum<span class="token punctuation">(</span>map<span class="token punctuation">(</span>operator<span class="token punctuation">.</span>mul<span class="token punctuation">,</span> kernel<span class="token punctuation">,</span> window<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">flatten</span><span class="token punctuation">(</span>list_of_lists<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Flatten one level of nesting"</span>
<span class="token keyword">return</span> chain<span class="token punctuation">.</span>from_iterable<span class="token punctuation">(</span>list_of_lists<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">repeatfunc</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> times<span class="token operator">=</span>None<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""Repeat calls to func with specified arguments.
    Example:  repeatfunc(random.random)
    """</span>
<span class="token keyword">if</span> times isNone<span class="token punctuation">:</span>
<span class="token keyword">return</span> starmap<span class="token punctuation">(</span>func<span class="token punctuation">,</span> repeat<span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> starmap<span class="token punctuation">(</span>func<span class="token punctuation">,</span> repeat<span class="token punctuation">(</span>args<span class="token punctuation">,</span> times<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">grouper</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">,</span> fillvalue<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Collect data into non-overlapping fixed-length chunks or blocks"</span>
<span class="token comment" spellcheck="true"># grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx</span>
    args <span class="token operator">=</span><span class="token punctuation">[</span>iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">*</span> n
<span class="token keyword">return</span> zip_longest<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> fillvalue<span class="token operator">=</span>fillvalue<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">triplewise</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Return overlapping triplets from an iterable"</span>
<span class="token comment" spellcheck="true"># triplewise('ABCDEFG') -> ABC BCD CDE DEF EFG</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token keyword">in</span> pairwise<span class="token punctuation">(</span>pairwise<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c
<span class="token keyword">def</span> <span class="token function">sliding_window</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># sliding_window('ABCDEFG', 4) -> ABCD BCDE CDEF DEFG</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    window <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span>islice<span class="token punctuation">(</span>it<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span> maxlen<span class="token operator">=</span>n<span class="token punctuation">)</span>
<span class="token keyword">if</span> len<span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token operator">==</span> n<span class="token punctuation">:</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>window<span class="token punctuation">)</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> it<span class="token punctuation">:</span>
        window<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>window<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">roundrobin</span><span class="token punctuation">(</span><span class="token operator">*</span>iterables<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"roundrobin('ABC', 'D', 'EF') --> A D E B F C"</span>
<span class="token comment" spellcheck="true"># Recipe credited to George Sakkis</span>
    num_active <span class="token operator">=</span> len<span class="token punctuation">(</span>iterables<span class="token punctuation">)</span>
    nexts <span class="token operator">=</span> cycle<span class="token punctuation">(</span>iter<span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>__next__ <span class="token keyword">for</span> it <span class="token keyword">in</span> iterables<span class="token punctuation">)</span>
<span class="token keyword">while</span> num_active<span class="token punctuation">:</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
fornextin nexts<span class="token punctuation">:</span>
yieldnext<span class="token punctuation">(</span><span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Remove the iterator we just exhausted from the cycle.</span>
            num_active <span class="token operator">-=</span><span class="token number">1</span>
            nexts <span class="token operator">=</span> cycle<span class="token punctuation">(</span>islice<span class="token punctuation">(</span>nexts<span class="token punctuation">,</span> num_active<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Use a predicate to partition entries into false entries and true entries"</span>
<span class="token comment" spellcheck="true"># partition(is_odd, range(10)) --> 0 2 4 6 8   and  1 3 5 7 9</span>
    t1<span class="token punctuation">,</span> t2 <span class="token operator">=</span> tee<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
<span class="token keyword">return</span> filterfalse<span class="token punctuation">(</span>pred<span class="token punctuation">,</span> t1<span class="token punctuation">)</span><span class="token punctuation">,</span> filter<span class="token punctuation">(</span>pred<span class="token punctuation">,</span> t2<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">before_and_after</span><span class="token punctuation">(</span>predicate<span class="token punctuation">,</span> it<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">""" Variant of takewhile() that allows complete
        access to the remainder of the iterator.
        >>> it = iter('ABCdEfGhI')
        >>> all_upper, remainder = before_and_after(str.isupper, it)
        >>> ''.join(all_upper)
        'ABC'
        >>> ''.join(remainder)     # takewhile() would lose the 'd'
        'dEfGhI'
        Note that the first iterator must be fully
        consumed before the second iterator can
        generate valid results.
    """</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    transition <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">true_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">for</span> elem <span class="token keyword">in</span> it<span class="token punctuation">:</span>
<span class="token keyword">if</span> predicate<span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> elem
<span class="token keyword">else</span><span class="token punctuation">:</span>
                transition<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>
<span class="token keyword">return</span>
<span class="token keyword">def</span> <span class="token function">remainder_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
yieldfrom transition
yieldfrom it
<span class="token keyword">return</span> true_iterator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> remainder_iterator<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">powerset</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"</span>
    s <span class="token operator">=</span> list<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
<span class="token keyword">return</span> chain<span class="token punctuation">.</span>from_iterable<span class="token punctuation">(</span>combinations<span class="token punctuation">(</span>s<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token keyword">for</span> r <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">unique_everseen</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> key<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"List unique elements, preserving order. Remember all elements ever seen."</span>
<span class="token comment" spellcheck="true"># unique_everseen('AAAABBBCCDAABBB') --> A B C D</span>
<span class="token comment" spellcheck="true"># unique_everseen('ABBCcAD', str.lower) --> A B C D</span>
    seen <span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>
    seen_add <span class="token operator">=</span> seen<span class="token punctuation">.</span>add
<span class="token keyword">if</span> key isNone<span class="token punctuation">:</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> filterfalse<span class="token punctuation">(</span>seen<span class="token punctuation">.</span>__contains__<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
            seen_add<span class="token punctuation">(</span>element<span class="token punctuation">)</span>
<span class="token keyword">yield</span> element
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
            k <span class="token operator">=</span> key<span class="token punctuation">(</span>element<span class="token punctuation">)</span>
<span class="token keyword">if</span> k notin seen<span class="token punctuation">:</span>
                seen_add<span class="token punctuation">(</span>k<span class="token punctuation">)</span>
<span class="token keyword">yield</span> element
<span class="token keyword">def</span> <span class="token function">unique_justseen</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> key<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"List unique elements, preserving order. Remember only the element just seen."</span>
<span class="token comment" spellcheck="true"># unique_justseen('AAAABBBCCDAABBB') --> A B C D A B</span>
<span class="token comment" spellcheck="true"># unique_justseen('ABBCcAD', str.lower) --> A B C A D</span>
<span class="token keyword">return</span> map<span class="token punctuation">(</span>next<span class="token punctuation">,</span> map<span class="token punctuation">(</span>operator<span class="token punctuation">.</span>itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> groupby<span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">iter_except</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> exception<span class="token punctuation">,</span> first<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">""" Call a function repeatedly until an exception is raised.
    Converts a call-until-exception interface to an iterator interface.
    Like builtins.iter(func, sentinel) but uses an exception instead
    of a sentinel to end the loop.
    Examples:
        iter_except(functools.partial(heappop, h), IndexError)   # priority queue iterator
        iter_except(d.popitem, KeyError)                         # non-blocking dict iterator
        iter_except(d.popleft, IndexError)                       # non-blocking deque iterator
        iter_except(q.get_nowait, Queue.Empty)                   # loop over a producer Queue
        iter_except(s.pop, KeyError)                             # non-blocking set iterator
    """</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> first isnotNone<span class="token punctuation">:</span>
<span class="token keyword">yield</span> first<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># For database APIs needing an initial cast to db.first()</span>
whileTrue<span class="token punctuation">:</span>
<span class="token keyword">yield</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> exception<span class="token punctuation">:</span>
<span class="token keyword">pass</span>
<span class="token keyword">def</span> <span class="token function">first_true</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span>default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> pred<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""Returns the first true value in the iterable.
    If no true value is found, returns *default*
    If *pred* is not None, returns the first item
    for which pred(item) is true.
    """</span>
<span class="token comment" spellcheck="true"># first_true([a,b,c], x) --> a or b or c or x</span>
<span class="token comment" spellcheck="true"># first_true([a,b], x, f) --> a if f(a) else b if f(b) else x</span>
returnnext<span class="token punctuation">(</span>filter<span class="token punctuation">(</span>pred<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">,</span>default<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">random_product</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> repeat<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Random selection from itertools.product(*args, **kwds)"</span>
    pools <span class="token operator">=</span><span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token keyword">for</span> pool <span class="token keyword">in</span> args<span class="token punctuation">]</span><span class="token operator">*</span> repeat
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>map<span class="token punctuation">(</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">,</span> pools<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">random_permutation</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Random selection from itertools.permutations(iterable, r)"</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    r <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token keyword">if</span> r isNoneelse r
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>pool<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">random_combination</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Random selection from itertools.combinations(iterable, r)"</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
    indices <span class="token operator">=</span> sorted<span class="token punctuation">(</span>random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">random_combination_with_replacement</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Random selection from itertools.combinations_with_replacement(iterable, r)"</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
    indices <span class="token operator">=</span> sorted<span class="token punctuation">(</span>random<span class="token punctuation">.</span>choices<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> k<span class="token operator">=</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">nth_combination</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Equivalent to list(combinations(iterable, r))[index]"</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
<span class="token keyword">if</span> r <span class="token operator">&lt;</span>0or r <span class="token operator">></span> n<span class="token punctuation">:</span>
raiseValueError
    c <span class="token operator">=</span><span class="token number">1</span>
    k <span class="token operator">=</span> min<span class="token punctuation">(</span>r<span class="token punctuation">,</span> n<span class="token operator">-</span>r<span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        c <span class="token operator">=</span> c <span class="token operator">*</span><span class="token punctuation">(</span>n <span class="token operator">-</span> k <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">//</span> i
<span class="token keyword">if</span> index <span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>
        index <span class="token operator">+=</span> c
<span class="token keyword">if</span> index <span class="token operator">&lt;</span>0or index <span class="token operator">>=</span> c<span class="token punctuation">:</span>
raiseIndexError
    result <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">while</span> r<span class="token punctuation">:</span>
        c<span class="token punctuation">,</span> n<span class="token punctuation">,</span> r <span class="token operator">=</span> c<span class="token operator">*</span>r<span class="token operator">//</span>n<span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">,</span> r<span class="token number">-1</span>
<span class="token keyword">while</span> index <span class="token operator">>=</span> c<span class="token punctuation">:</span>
            index <span class="token operator">-=</span> c
            c<span class="token punctuation">,</span> n <span class="token operator">=</span> c<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">-</span>r<span class="token punctuation">)</span><span class="token operator">//</span>n<span class="token punctuation">,</span> n<span class="token number">-1</span>
        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>pool<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="functools-—-高阶函数和可调用对象上的操作"><a href="#functools-—-高阶函数和可调用对象上的操作" class="headerlink" title="functools —- 高阶函数和可调用对象上的操作"></a><code>functools</code> —- 高阶函数和可调用对象上的操作</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/functools.py" target="_blank" rel="noopener">Lib/functools.py</a></p>
<hr>
<p><code>functools</code> 模块应用于高阶函数，即参数或（和）返回值为其他函数的函数。 通常来说，此模块的功能适用于所有可调用对象。</p>
<p><code>functools</code> 模块定义了以下函数:</p>
<p><code>@functools.cache</code>(<em>user_function</em>)</p>
<p>简单轻量级未绑定函数缓存。 有时称为 “memoize”。</p>
<p>返回值与 <code>lru_cache(maxsize=None)</code> 相同，创建一个查找函数参数的字典的简单包装器。 因为它不需要移出旧值，所以比带有大小限制的 <code>lru_cache()</code> 更小更快。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python">@cache
<span class="token keyword">def</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> factorial<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token keyword">if</span> n <span class="token keyword">else</span> <span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> factorial<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># no previously cached result, makes 11 recursive calls</span>
<span class="token number">3628800</span>
<span class="token operator">>></span><span class="token operator">></span> factorial<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># just looks up cached value result</span>
<span class="token number">120</span>
<span class="token operator">>></span><span class="token operator">></span> factorial<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># makes two new recursive calls, the other 10 are cached</span>
<span class="token number">479001600</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>@functools.cached_property</code>(<em>func</em>)</p>
<p>将一个类方法转换为特征属性，一次性计算该特征属性的值，然后将其缓存为实例生命周期内的普通属性。 类似于 <code>property()</code> 但增加了缓存功能。 对于在其他情况下实际不可变的高计算资源消耗的实例特征属性来说该函数非常有用。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">DataSet</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sequence_of_numbers<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_data <span class="token operator">=</span> tuple<span class="token punctuation">(</span>sequence_of_numbers<span class="token punctuation">)</span>
    @cached_property
    <span class="token keyword">def</span> <span class="token function">stdev</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> statistics<span class="token punctuation">.</span>stdev<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>cached_property()</code> 的设定与 <code>property()</code> 有所不同。 常规的 property 会阻止属性写入，除非定义了 setter。 与之相反，<em>cached_property</em> 则允许写入。</p>
<p><em>cached_property</em> 装饰器仅在执行查找且不存在同名属性时才会运行。 当运行时，<em>cached_property</em> 会写入同名的属性。 后续的属性读取和写入操作会优先于 <em>cached_property</em> 方法，其行为就像普通的属性一样。</p>
<p>缓存的值可通过删除该属性来清空。 这允许 <em>cached_property</em> 方法再次运行。</p>
<p>注意，这个装饰器会影响 <a href="https://www.python.org/dev/peps/pep-0412" target="_blank" rel="noopener"><strong>PEP 412</strong></a> 键共享字典的操作。 这意味着相应的字典实例可能占用比通常时更多的空间。</p>
<p>而且，这个装饰器要求每个实例上的 <code>__dict__</code> 是可变的映射。 这意味着它将不适用于某些类型，例如元类（因为类型实例上的 <code>__dict__</code> 属性是类命名空间的只读代理），以及那些指定了 <code>__slots__</code> 但未包括 <code>__dict__</code> 作为所定义的空位之一的类（因为这样的类根本没有提供 <code>__dict__</code> 属性）。</p>
<p>如果可变的映射不可用或者如果想要节省空间的键共享，可以通过在 <code>cache()</code> 之上堆叠一个 <code>property()</code> 来实现类似 <code>cached_property()</code> 的效果:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">DataSet</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sequence_of_numbers<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_data <span class="token operator">=</span> sequence_of_numbers
    @property
    @cache
    <span class="token keyword">def</span> <span class="token function">stdev</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> statistics<span class="token punctuation">.</span>stdev<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.8 新版功能.</p>
<p><code>functools.cmp_to_key</code>(<em>func</em>)</p>
<p>将(旧式的)比较函数转换为新式的 key function . 在类似于 <code>sorted()</code> ， <code>min()</code> ， <code>max()</code> ， <code>heapq.nlargest()</code> ， <code>heapq.nsmallest()</code> ， <code>itertools.groupby()</code> 等函数的 key 参数中使用。此函数主要用作将 Python 2 程序转换至新版的转换工具，以保持对比较函数的兼容。</p>
<p>比较函数意为一个可调用对象，该对象接受两个参数并比较它们，结果为小于则返回一个负数，相等则返回零，大于则返回一个正数。key function则是一个接受一个参数，并返回另一个用以排序的值的可调用对象。</p>
<p>示例:</p>
<pre><code>sorted(iterable, key=cmp_to_key(locale.strcoll))  # locale-aware sort order</code></pre><p>3.2 新版功能.</p>
<p><code>@``functools.lru_cache</code>(<em>user_function</em>)</p>
<p><code>@``functools.lru_cache</code>(<em>maxsize=128</em>, <em>typed=False</em>)</p>
<p>一个为函数提供缓存功能的装饰器，缓存 <em>maxsize</em> 组传入参数，在下次以相同参数调用时直接返回上一次的结果。用以节约高开销或I/O函数的调用时间。</p>
<p>由于使用了字典存储缓存，所以该函数的固定参数和关键字参数必须是可哈希的。</p>
<p>不同模式的参数可能被视为不同从而产生多个缓存项，例如, f(a=1, b=2) 和 f(b=2, a=1) 因其参数顺序不同，可能会被缓存两次。</p>
<p>如果指定了 <em>user_function*，它必须是一个可调用对象。 这允许 *lru_cache</em> 装饰器被直接应用于一个用户自定义函数，让 <em>maxsize</em> 保持其默认值 128:</p>
<pre class="line-numbers language-python"><code class="language-python">@lru_cache
<span class="token keyword">def</span> <span class="token function">count_vowels</span><span class="token punctuation">(</span>sentence<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">(</span>sentence<span class="token punctuation">.</span>count<span class="token punctuation">(</span>vowel<span class="token punctuation">)</span> <span class="token keyword">for</span> vowel <span class="token keyword">in</span> <span class="token string">'AEIOUaeiou'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>maxsize</em> 设为 <code>None</code>，LRU 特性将被禁用且缓存可无限增长。</p>
<p>如果 <em>typed</em> 被设为真值，则不同类型的函数参数将被分别缓存。 例如，<code>f(3)</code> 和 <code>f(3.0)</code> 将总是会被当作具有不同结果的不同调用。 如果 <em>typed</em> 为假值，则具体实现通常会把它们当作相同调用并且只缓存一个结果，虽然并不一定总是会这样做。</p>
<p>被包装的函数配有一个 <code>cache_parameters()</code> 函数，该函数返回一个新的 <code>dict</code> 用来显示 <em>maxsize</em> 和 <em>typed</em> 的值。 这只是出于显示信息的目的。 改变值没有任何效果。</p>
<p>为了帮助衡量缓存的有效性以及调整 <em>maxsize</em> 形参，被包装的函数会带有一个 <code>cache_info()</code> 函数，它返回一个 named tuple 以显示 <em>hits</em>, <em>misses</em>, <em>maxsize</em> 和 <em>currsize</em>。</p>
<p>该装饰器也提供了一个用于清理/使缓存失效的函数 <code>cache_clear()</code> 。</p>
<p>原始的未经装饰的函数可以通过 <code>__wrapped__</code> 属性访问。它可以用于检查、绕过缓存，或使用不同的缓存再次装饰原始函数。</p>
<p>缓存会保持对参数的引用并返回值，直到它们结束生命期退出缓存或者直到缓存被清空。</p>
<p><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)" target="_blank" rel="noopener">LRU（最久未使用算法）缓存</a> 在最近的调用是即将到来的调用的最佳预测值时性能最好（例如，新闻服务器上最热门文章倾向于每天更改）。 缓存的大小限制可确保缓存不会在长期运行进程如网站服务器上无限制地增长。</p>
<p>一般来说，LRU缓存只在当你想要重用之前计算的结果时使用。因此，用它缓存具有副作用的函数、需要在每次调用时创建不同、易变的对象的函数或者诸如time（）或random（）之类的不纯函数是没有意义的。</p>
<p>静态 Web 内容的 LRU 缓存示例:</p>
<pre class="line-numbers language-python"><code class="language-python">@lru_cache<span class="token punctuation">(</span>maxsize<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">get_pep</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">'Retrieve text of a Python Enhancement Proposal'</span>
    resource <span class="token operator">=</span> <span class="token string">'https://www.python.org/dev/peps/pep-%04d/'</span> <span class="token operator">%</span> num
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token keyword">with</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>resource<span class="token punctuation">)</span> <span class="token keyword">as</span> s<span class="token punctuation">:</span>
            <span class="token keyword">return</span> s<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> urllib<span class="token punctuation">.</span>error<span class="token punctuation">.</span>HTTPError<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'Not Found'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">290</span><span class="token punctuation">,</span> <span class="token number">308</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">218</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">279</span><span class="token punctuation">,</span> <span class="token number">289</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">9991</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     pep <span class="token operator">=</span> get_pep<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> len<span class="token punctuation">(</span>pep<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> get_pep<span class="token punctuation">.</span>cache_info<span class="token punctuation">(</span><span class="token punctuation">)</span>
CacheInfo<span class="token punctuation">(</span>hits<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> misses<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> maxsize<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span> currsize<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以下是使用缓存通过 <a href="https://zh.wikipedia.org/wiki/动态规划" target="_blank" rel="noopener">动态规划</a> 计算 <a href="https://zh.wikipedia.org/wiki/斐波那契数列" target="_blank" rel="noopener">斐波那契数列</a> 的例子。</p>
<pre class="line-numbers language-python"><code class="language-python">@lru_cache<span class="token punctuation">(</span>maxsize<span class="token operator">=</span>None<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> n
    <span class="token keyword">return</span> fib<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>fib<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token keyword">for</span> n <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">144</span><span class="token punctuation">,</span> <span class="token number">233</span><span class="token punctuation">,</span> <span class="token number">377</span><span class="token punctuation">,</span> <span class="token number">610</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> fib<span class="token punctuation">.</span>cache_info<span class="token punctuation">(</span><span class="token punctuation">)</span>
CacheInfo<span class="token punctuation">(</span>hits<span class="token operator">=</span><span class="token number">28</span><span class="token punctuation">,</span> misses<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">,</span> maxsize<span class="token operator">=</span>None<span class="token punctuation">,</span> currsize<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
<p>在 3.3 版更改: 添加 <em>typed</em> 选项。</p>
<p>在 3.8 版更改: 添加了 <em>user_function</em> 选项。</p>
<p>3.9 新版功能: 新增函数 <code>cache_parameters()</code></p>
<pre><code>@``functools.total_ordering</code></pre><p>给定一个声明一个或多个全比较排序方法的类，这个类装饰器实现剩余的方法。这减轻了指定所有可能的全比较操作的工作。</p>
<p>此类必须包含以下方法之一：<code>__lt__()</code> 、<code>__le__()</code>、<code>__gt__()</code> 或 <code>__ge__()</code>。另外，此类必须支持 <code>__eq__()</code> 方法。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python">@total_ordering
<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">_is_valid_operand</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>hasattr<span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token string">"lastname"</span><span class="token punctuation">)</span> <span class="token operator">and</span>
                hasattr<span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token string">"firstname"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__eq__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>_is_valid_operand<span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> NotImplemented
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>lastname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>firstname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span>
                <span class="token punctuation">(</span>other<span class="token punctuation">.</span>lastname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> other<span class="token punctuation">.</span>firstname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__lt__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>_is_valid_operand<span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> NotImplemented
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>lastname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>firstname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>
                <span class="token punctuation">(</span>other<span class="token punctuation">.</span>lastname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> other<span class="token punctuation">.</span>firstname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>虽然此装饰器使得创建具有良好行为的完全有序类型变得非常容易，但它 <em>确实</em> 是以执行速度更缓慢和派生比较方法的堆栈回溯更复杂为代价的。 如果性能基准测试表明这是特定应用的瓶颈所在，则改为实现全部六个富比较方法应该会轻松提升速度。</p>
<p>注解</p>
<p>这个装饰器不会尝试重载类 <em>或其上级类</em> 中已经被声明的方法。 这意味着如果某个上级类定义了比较运算符，则 <em>total_ordering</em> 将不会再次实现它，即使原方法是抽象方法。</p>
<p>3.2 新版功能.</p>
<p>在 3.4 版更改: 现在已支持从未识别类型的下层比较函数返回 NotImplemented 异常。</p>
<p><code>functools.partial</code>(<em>func</em>, <em>/</em>, <em>\</em>args<em>,</em> <em>*keywords</em>)</p>
<p>返回一个新的 部分对象，当被调用时其行为类似于 <em>func</em> 附带位置参数 <em>args</em> 和关键字参数 <em>keywords</em> 被调用。 如果为调用提供了更多的参数，它们会被附加到 <em>args</em>。 如果提供了额外的关键字参数，它们会扩展并重载 <em>keywords</em>。 大致等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">partial</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>keywords<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">newfunc</span><span class="token punctuation">(</span><span class="token operator">*</span>fargs<span class="token punctuation">,</span> <span class="token operator">**</span>fkeywords<span class="token punctuation">)</span><span class="token punctuation">:</span>
        newkeywords <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">**</span>keywords<span class="token punctuation">,</span> <span class="token operator">**</span>fkeywords<span class="token punctuation">}</span>
        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">*</span>fargs<span class="token punctuation">,</span> <span class="token operator">**</span>newkeywords<span class="token punctuation">)</span>
    newfunc<span class="token punctuation">.</span>func <span class="token operator">=</span> func
    newfunc<span class="token punctuation">.</span>args <span class="token operator">=</span> args
    newfunc<span class="token punctuation">.</span>keywords <span class="token operator">=</span> keywords
    <span class="token keyword">return</span> newfunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>partial()</code> 会被“冻结了”一部分函数参数和/或关键字的部分函数应用所使用，从而得到一个具有简化签名的新对象。 例如，<code>partial()</code> 可用来创建一个行为类似于 <code>int()</code> 函数的可调用对象，其中 <em>base</em> 参数默认为二：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> functools <span class="token keyword">import</span> partial
<span class="token operator">>></span><span class="token operator">></span> basetwo <span class="token operator">=</span> partial<span class="token punctuation">(</span>int<span class="token punctuation">,</span> base<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> basetwo<span class="token punctuation">.</span>__doc__ <span class="token operator">=</span> <span class="token string">'Convert base 2 string to an int.'</span>
<span class="token operator">>></span><span class="token operator">></span> basetwo<span class="token punctuation">(</span><span class="token string">'10010'</span><span class="token punctuation">)</span>
<span class="token number">18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>class</em> <code>functools.partialmethod</code>(<em>func</em>, <em>/</em>, <em>\</em>args<em>,</em> <em>*keywords</em>)</p>
<p>返回一个新的 <code>partialmethod</code> 描述器，其行为类似 <code>partial</code> 但它被设计用作方法定义而非直接用作可调用对象。</p>
<p><em>func</em> 必须是一个 descriptor 或可调用对象（同属两者的对象例如普通函数会被当作描述器来处理）。</p>
<p>当 <em>func</em> 是一个描述器（例如普通 Python 函数, <code>classmethod()</code>, <code>staticmethod()</code>, <code>abstractmethod()</code> 或其他 <code>partialmethod</code> 的实例）时, 对 <code>__get__</code> 的调用会被委托给底层的描述器，并会返回一个适当的 部分对象 作为结果。</p>
<p>当 <em>func</em> 是一个非描述器类可调用对象时，则会动态创建一个适当的绑定方法。 当用作方法时其行为类似普通 Python 函数：将会插入 <em>self</em> 参数作为第一个位置参数，其位置甚至会处于提供给 <code>partialmethod</code> 构造器的 <em>args</em> 和 <em>keywords</em> 之前。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Cell</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>_alive <span class="token operator">=</span> <span class="token boolean">False</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     @property
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">alive</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> self<span class="token punctuation">.</span>_alive
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">set_state</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>_alive <span class="token operator">=</span> bool<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     set_alive <span class="token operator">=</span> partialmethod<span class="token punctuation">(</span>set_state<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     set_dead <span class="token operator">=</span> partialmethod<span class="token punctuation">(</span>set_state<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Cell<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>alive
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>set_alive<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>alive
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.4 新版功能.</p>
<p><code>functools.reduce</code>(<em>function</em>, <em>iterable</em>[, <em>initializer</em>])</p>
<p>将两个参数的 <em>function</em> 从左至右积累地应用到 <em>iterable</em> 的条目，以便将该可迭代对象缩减为单一的值。 例如，<code>reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])</code> 是计算 <code>((((1+2)+3)+4)+5)</code> 的值。 左边的参数 <em>x</em> 是积累值而右边的参数 <em>y</em> 则是来自 <em>iterable</em> 的更新值。 如果存在可选项 <em>initializer*，它会被放在参与计算的可迭代对象的条目之前，并在可迭代对象为空时作为默认值。 如果没有给出 *initializer</em> 并且 <em>iterable</em> 仅包含一个条目，则将返回第一项。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">reduce</span><span class="token punctuation">(</span>function<span class="token punctuation">,</span> iterable<span class="token punctuation">,</span> initializer<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    <span class="token keyword">if</span> initializer <span class="token keyword">is</span> None<span class="token punctuation">:</span>
        value <span class="token operator">=</span> next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        value <span class="token operator">=</span> initializer
    <span class="token keyword">for</span> element <span class="token keyword">in</span> it<span class="token punctuation">:</span>
        value <span class="token operator">=</span> function<span class="token punctuation">(</span>value<span class="token punctuation">,</span> element<span class="token punctuation">)</span>
    <span class="token keyword">return</span> value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请参阅 <code>itertools.accumulate()</code> 了解有关可产生所有中间值的迭代器。</p>
<pre><code>@``functools.singledispatch</code></pre><p>将一个函数转换为 单分派 generic function。</p>
<p>要定义一个泛型函数，应使用 <code>@singledispatch</code> 装饰器进行装饰。 请注意分派是作用于第一个参数的类型，要相应地创建你的函数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> functools <span class="token keyword">import</span> singledispatch
<span class="token operator">>></span><span class="token operator">></span> @singledispatch
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Let me just say,"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要将重载的实现添加到函数中，请使用泛型函数的 <code>register()</code> 属性。 它是一个装饰器。 对于带有类型标注的函数，该装饰器将自动推断第一个参数的类型:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> @fun<span class="token punctuation">.</span>register
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> int<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Strength in numbers, eh?"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> @fun<span class="token punctuation">.</span>register
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> list<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Enumerate this:"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> i<span class="token punctuation">,</span> elem <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于不使用类型标注的代码，可以将适当的类型参数显式地传给装饰器本身:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> @fun<span class="token punctuation">.</span>register<span class="token punctuation">(</span>complex<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Better than complicated."</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>real<span class="token punctuation">,</span> arg<span class="token punctuation">.</span>imag<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要启用注册 lambda 和现有函数，可以使用函数形式的 <code>register()</code> 属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">nothing</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Nothing."</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>register<span class="token punctuation">(</span>type<span class="token punctuation">(</span>None<span class="token punctuation">)</span><span class="token punctuation">,</span> nothing<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>register()</code> 属性将返回启用了装饰器堆栈、封存的未装饰函数，并会为每个变量单独创建单元测试:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> @fun<span class="token punctuation">.</span>register<span class="token punctuation">(</span>float<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> @fun<span class="token punctuation">.</span>register<span class="token punctuation">(</span>Decimal<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">fun_num</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Half of your number:"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>arg <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun_num <span class="token keyword">is</span> fun
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在调用时，泛型函数会根据第一个参数的类型进行分派:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token string">"Hello, world."</span><span class="token punctuation">)</span>
Hello<span class="token punctuation">,</span> world<span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token string">"test."</span><span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
Let me just say<span class="token punctuation">,</span> test<span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
Strength <span class="token keyword">in</span> numbers<span class="token punctuation">,</span> eh? <span class="token number">42</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'eggs'</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
Enumerate this<span class="token punctuation">:</span>
<span class="token number">0</span> spam
<span class="token number">1</span> spam
<span class="token number">2</span> eggs
<span class="token number">3</span> spam
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span>None<span class="token punctuation">)</span>
Nothing<span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token number">1.23</span><span class="token punctuation">)</span>
<span class="token number">0.615</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在没有用于特定类型的已注册实现的情况下，则会使用其方法解析顺序来查找更通用的实现。 以 <code>@singledispatch</code> 装饰的原始函数将为最基本的 <code>object</code> 类型进行注册，这意味着它将在找不到更好的实现时被使用。</p>
<p>如果一个实现注册到了 abstract base class，虚拟子类将会被发送到该实现:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections<span class="token punctuation">.</span>abc <span class="token keyword">import</span> Mapping
<span class="token operator">>></span><span class="token operator">></span> @fun<span class="token punctuation">.</span>register
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> Mapping<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Keys &amp; Values"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> arg<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"=>"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token string">"b"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
a <span class="token operator">=</span><span class="token operator">></span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要检查泛型函数将为给定类型选择哪个实现，请使用 <code>dispatch()</code> 属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>dispatch<span class="token punctuation">(</span>float<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>function fun_num at <span class="token number">0x1035a2840</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>dispatch<span class="token punctuation">(</span>dict<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># note: default implementation</span>
<span class="token operator">&lt;</span>function fun at <span class="token number">0x103fe0000</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要访问所有忆注册实现，请使用只读的 <code>registry</code> 属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>
dict_keys<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'NoneType'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'int'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'object'</span><span class="token operator">></span><span class="token punctuation">,</span>
          <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'decimal.Decimal'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'list'</span><span class="token operator">></span><span class="token punctuation">,</span>
          <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'float'</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>registry<span class="token punctuation">[</span>float<span class="token punctuation">]</span>
<span class="token operator">&lt;</span>function fun_num at <span class="token number">0x1035a2840</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>registry<span class="token punctuation">[</span>object<span class="token punctuation">]</span>
<span class="token operator">&lt;</span>function fun at <span class="token number">0x103fe0000</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.4 新版功能.</p>
<p>在 3.7 版更改: <code>register()</code> 属性支持使用类型标注。</p>
<p><em>class</em> <code>functools.singledispatchmethod</code>(<em>func</em>)</p>
<p>将一个方法转换为 单分派 generic function。</p>
<p>要定义一个泛型方法，应使用 <code>@singledispatchmethod</code> 装饰器进行装饰。 请注意分派是作用于第一个非 self 或非 cls 参数的类型，要相应地创建你的函数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Negator</span><span class="token punctuation">:</span>
    @singledispatchmethod
    <span class="token keyword">def</span> <span class="token function">neg</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> NotImplementedError<span class="token punctuation">(</span><span class="token string">"Cannot negate a"</span><span class="token punctuation">)</span>
    @neg<span class="token punctuation">.</span>register
    <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arg<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>arg
    @neg<span class="token punctuation">.</span>register
    <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arg<span class="token punctuation">:</span> bool<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">not</span> arg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>@singledispatchmethod</code> 支持与其他装饰器如 <code>@classmethod</code> 相嵌套。 请注意如果要允许 <code>dispatcher.register</code>，则 <code>singledispatchmethod</code> 必须是 <em>最外层</em> 的装饰器。 下面的示例定义了 <code>Negator</code> 类，其中包含绑定到类的 <code>neg</code> 方法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Negator</span><span class="token punctuation">:</span>
    @singledispatchmethod
    @classmethod
    <span class="token keyword">def</span> <span class="token function">neg</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> NotImplementedError<span class="token punctuation">(</span><span class="token string">"Cannot negate a"</span><span class="token punctuation">)</span>
    @neg<span class="token punctuation">.</span>register
    @classmethod
    <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> arg<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>arg
    @neg<span class="token punctuation">.</span>register
    @classmethod
    <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> arg<span class="token punctuation">:</span> bool<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">not</span> arg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同样的模式也被用于其他类似的装饰器: <code>staticmethod</code>, <code>abstractmethod</code> 等等。</p>
<p>3.8 新版功能.</p>
<p><code>functools.update_wrapper</code>(<em>wrapper</em>, <em>wrapped</em>, <em>assigned=WRAPPER_ASSIGNMENTS</em>, <em>updated=WRAPPER_UPDATES</em>)</p>
<p>更新一个 <em>wrapper</em> 函数以使其类似于 <em>wrapped</em> 函数。 可选参数为指明原函数的哪些属性要直接被赋值给 wrapper 函数的匹配属性的元组，并且这些 wrapper 函数的属性将使用原函数的对应属性来更新。 这些参数的默认值是模块级常量 <code>WRAPPER_ASSIGNMENTS</code> (它将被赋值给 wrapper 函数的 <code>__module__</code>, <code>__name__</code>, <code>__qualname__</code>, <code>__annotations__</code> 和 <code>__doc__</code> 即文档字符串) 以及 <code>WRAPPER_UPDATES</code> (它将更新 wrapper 函数的 <code>__dict__</code> 即实例字典)。</p>
<p>为了允许出于内省和其他目的访问原始函数（例如绕过 <code>lru_cache()</code> 之类的缓存装饰器），此函数会自动为 wrapper 添加一个指向被包装函数的 <code>__wrapped__</code> 属性。</p>
<p>此函数的主要目的是在 decorator 函数中用来包装被装饰的函数并返回包装器。 如果包装器函数未被更新，则被返回函数的元数据将反映包装器定义而不是原始函数定义，这通常没有什么用处。</p>
<p><code>update_wrapper()</code> 可以与函数之外的可调用对象一同使用。 在 <em>assigned</em> 或 <em>updated</em> 中命名的任何属性如果不存在于被包装对象则会被忽略（即该函数将不会尝试在包装器函数上设置它们）。 如果包装器函数自身缺少在 <em>updated</em> 中命名的任何属性则仍将引发 <code>AttributeError</code>。</p>
<p>3.2 新版功能: 自动添加 <code>__wrapped__</code> 属性。</p>
<p>3.2 新版功能: 默认拷贝 <code>__annotations__</code> 属性。</p>
<p>在 3.2 版更改: 不存在的属性将不再触发 <code>AttributeError</code>。</p>
<p>在 3.4 版更改: <code>__wrapped__</code> 属性现在总是指向被包装的函数，即使该函数定义了 <code>__wrapped__</code> 属性。 (参见 <a href="https://bugs.python.org/issue17482" target="_blank" rel="noopener">bpo-17482</a>)</p>
<p><code>@``functools.wraps</code>(<em>wrapped</em>, <em>assigned=WRAPPER_ASSIGNMENTS</em>, <em>updated=WRAPPER_UPDATES</em>)</p>
<p>这是一个便捷函数，用于在定义包装器函数时发起调用 <code>update_wrapper()</code> 作为函数装饰器。 它等价于 <code>partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated)</code>。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> functools <span class="token keyword">import</span> wraps
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">my_decorator</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     @wraps<span class="token punctuation">(</span>f<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwds<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Calling decorated function'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> f<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwds<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> wrapper
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> @my_decorator
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token triple-quoted-string string">"""Docstring"""</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Called example function'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> example<span class="token punctuation">(</span><span class="token punctuation">)</span>
Calling decorated function
Called example function
<span class="token operator">>></span><span class="token operator">></span> example<span class="token punctuation">.</span>__name__
<span class="token string">'example'</span>
<span class="token operator">>></span><span class="token operator">></span> example<span class="token punctuation">.</span>__doc__
<span class="token string">'Docstring'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果不使用这个装饰器工厂函数，则 example 函数的名称将变为 <code>'wrapper'</code>，并且 <code>example()</code> 原本的文档字符串将会丢失。</p>
<h3 id="partial-对象"><a href="#partial-对象" class="headerlink" title="partial 对象"></a><code>partial</code> 对象</h3><p><code>partial</code> 对象是由 <code>partial()</code> 创建的可调用对象。 它们具有三个只读属性：</p>
<pre><code>partial.func</code></pre><p>一个可调用对象或函数。 对 <code>partial</code> 对象的调用将被转发给 <code>func</code> 并附带新的参数和关键字。</p>
<pre><code>partial.args</code></pre><p>最左边的位置参数将放置在提供给 <code>partial</code> 对象调用的位置参数之前。</p>
<pre><code>partial.keywords</code></pre><p>当调用 <code>partial</code> 对象时将要提供的关键字参数。</p>
<p><code>partial</code> 对象与 <code>function</code> 对象的类似之处在于它们都是可调用、可弱引用的对象并可拥有属性。 但两者也存在一些重要的区别。 例如前者不会自动创建 <code>__name__</code> 和 <code>__doc__</code> 属性。 而且，在类中定义的 <code>partial</code> 对象的行为类似于静态方法，并且不会在实例属性查找期间转换为绑定方法。</p>
<h2 id="operator-—-标准运算符替代函数"><a href="#operator-—-标准运算符替代函数" class="headerlink" title="operator —- 标准运算符替代函数"></a><code>operator</code> —- 标准运算符替代函数</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/operator.py" target="_blank" rel="noopener">Lib/operator.py</a></p>
<hr>
<p><code>operator</code> 模块提供了一套与Python的内置运算符对应的高效率函数。例如，<code>operator.add(x, y)</code> 与表达式 <code>x+y</code> 相同。 许多函数名与特殊方法名相同，只是没有双下划线。为了向后兼容性，也保留了许多包含双下划线的函数。为了表述清楚，建议使用没有双下划线的函数。</p>
<p>函数包含的种类有：对象的比较运算、逻辑运算、数学运算以及序列运算。</p>
<p>对象比较函数适用于所有的对象，函数名根据它们对应的比较运算符命名。</p>
<p><code>operator.lt</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.le</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.eq</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.ne</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.ge</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.gt</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__lt__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__le__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__eq__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ne__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ge__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__gt__</code>(<em>a</em>, <em>b</em>)</p>
<p>在 <em>a</em> 和 <em>b</em> 之间进行全比较。具体的，<code>lt(a, b)</code> 与 <code>a &lt; b</code> 相同， <code>le(a, b)</code> 与 <code>a &lt;= b</code> 相同，<code>eq(a, b)</code> 与 <code>a == b</code> 相同，<code>ne(a, b)</code> 与 <code>a != b</code> 相同，<code>gt(a, b)</code> 与 <code>a &gt; b</code> 相同，<code>ge(a, b)</code>与 <code>a &gt;= b</code> 相同。注意这些函数可以返回任何值，无论它是否可当作布尔值。</p>
<p>逻辑运算通常也适用于所有对象，并且支持真值检测、标识检测和布尔运算：</p>
<p><code>operator.not_</code>(<em>obj</em>)</p>
<p><code>operator.__not__</code>(<em>obj</em>)</p>
<p>返回 <code>not</code> <em>obj</em> 的结果。 （请注意对象实例并没有 <code>__not__()</code> 方法；只有解释器核心可定义此操作。 结果会受 <code>__bool__()</code> 和 <code>__len__()</code> 方法影响。）</p>
<p><code>operator.truth</code>(<em>obj</em>)</p>
<p>如果 <em>obj</em> 为真值则返回 <code>True</code>，否则返回 <code>False</code>。 这等价于使用 <code>bool</code> 构造器。</p>
<p><code>operator.is_</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a is b</code>。 检测对象标识。</p>
<p><code>operator.is_not</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a is not b</code>。 检测对象标识。</p>
<p>数学和按位运算的种类是最多的：</p>
<p><code>operator.abs</code>(<em>obj</em>)</p>
<p><code>operator.__abs__</code>(<em>obj</em>)</p>
<p>返回 <em>obj</em> 的绝对值。</p>
<p><code>operator.add</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__add__</code>(<em>a</em>, <em>b</em>)</p>
<p>对于数字 <em>a</em> 和 <em>b</em>，返回 <code>a + b</code>。</p>
<p><code>operator.and_</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__and__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>x</em> 和 <em>y</em> 按位与的结果。</p>
<p><code>operator.floordiv</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__floordiv__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a // b</code>。</p>
<p><code>operator.index</code>(<em>a</em>)</p>
<p><code>operator.__index__</code>(<em>a</em>)</p>
<p>返回 <em>a</em> 转换为整数的结果。 等价于 <code>a.__index__()</code>。</p>
<p>在 3.10 版更改: 结果总是为 <code>int</code> 类型。 在之前版本中，结果可能为 <code>int</code> 的子类的实例。</p>
<p><code>operator.inv</code>(<em>obj</em>)</p>
<p><code>operator.invert</code>(<em>obj</em>)</p>
<p><code>operator.__inv__</code>(<em>obj</em>)</p>
<p><code>operator.__invert__</code>(<em>obj</em>)</p>
<p>返回数字 <em>obj</em> 按位取反的结果。 这等价于 <code>~obj</code>。</p>
<p><code>operator.lshift</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__lshift__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>a</em> 左移 <em>b</em> 位的结果。</p>
<p><code>operator.mod</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__mod__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a % b</code>。</p>
<p><code>operator.mul</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__mul__</code>(<em>a</em>, <em>b</em>)</p>
<p>对于数字 <em>a</em> 和 <em>b</em>，返回 <code>a * b</code>。</p>
<p><code>operator.matmul</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__matmul__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a @ b</code>。</p>
<p>3.5 新版功能.</p>
<p><code>operator.neg</code>(<em>obj</em>)</p>
<p><code>operator.__neg__</code>(<em>obj</em>)</p>
<p>返回 <em>obj</em> 取负的结果 (<code>-obj</code>)。</p>
<p><code>operator.or_</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__or__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>a</em> 和 <em>b</em> 按位或的结果。</p>
<p><code>operator.pos</code>(<em>obj</em>)</p>
<p><code>operator.__pos__</code>(<em>obj</em>)</p>
<p>返回 <em>obj</em> 取正的结果 (<code>+obj</code>)。</p>
<p><code>operator.pow</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__pow__</code>(<em>a</em>, <em>b</em>)</p>
<p>对于数字 <em>a</em> 和 <em>b</em>，返回 <code>a ** b</code>。</p>
<p><code>operator.rshift</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__rshift__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>a</em> 右移 <em>b</em> 位的结果。</p>
<p><code>operator.sub</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__sub__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a - b</code>。</p>
<p><code>operator.truediv</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__truediv__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a / b</code> 例如 2/3 将等于 .66 而不是 0。 这也被称为“真”除法。</p>
<p><code>operator.xor</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__xor__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>a</em> 和 <em>b</em> 按位异或的结果。</p>
<p>适用于序列的操作（其中一些也适用于映射）包括：</p>
<p><code>operator.concat</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__concat__</code>(<em>a</em>, <em>b</em>)</p>
<p>对于序列 <em>a</em> 和 <em>b</em>，返回 <code>a + b</code>。</p>
<p><code>operator.contains</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__contains__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>b in a</code> 检测的结果。 请注意操作数是反序的。</p>
<p><code>operator.countOf</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>b</em> 在 <em>a</em> 中的出现次数。</p>
<p><code>operator.delitem</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__delitem__</code>(<em>a</em>, <em>b</em>)</p>
<p>移除 <em>a</em> 中索引号为 <em>b</em> 的值。</p>
<p><code>operator.getitem</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__getitem__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>a</em> 中索引为 <em>b</em> 的值。</p>
<p><code>operator.indexOf</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>b</em> 在 <em>a</em> 中首次出现所在的索引号。</p>
<p><code>operator.setitem</code>(<em>a</em>, <em>b</em>, <em>c</em>)</p>
<p><code>operator.__setitem__</code>(<em>a</em>, <em>b</em>, <em>c</em>)</p>
<p>将 <em>a</em> 中索引号为 <em>b</em> 的值设为 <em>c</em>。</p>
<p><code>operator.length_hint</code>(<em>obj</em>, <em>default=0</em>)</p>
<p>返回对象 <em>o</em> 的估计长度。 首先尝试返回其实际长度，再使用 <code>object.__length_hint__()</code> 得出估计值，最后返回默认值。</p>
<p>3.4 新版功能.</p>
<p><code>operator</code> 模块还定义了一些用于常规属性和条目查找的工具。 这些工具适合用来编写快速字段提取器作为 <code>map()</code>, <code>sorted()</code>, <code>itertools.groupby()</code> 或其他需要相应函数参数的函数的参数。</p>
<p><code>operator.attrgetter</code>(<em>attr</em>)</p>
<p><code>operator.attrgetter</code>(<em>\</em>attrs*)</p>
<p>返回一个可从操作数中获取 <em>attr</em> 的可调用对象。 如果请求了一个以上的属性，则返回一个属性元组。 属性名称还可包含点号。 例如：</p>
<ul>
<li>在 <code>f = attrgetter('name')</code> 之后，调用 <code>f(b)</code> 将返回 <code>b.name</code>。</li>
<li>在 <code>f = attrgetter('name', 'date')</code> 之后，调用 <code>f(b)</code> 将返回 <code>(b.name, b.date)</code>。</li>
<li>在 <code>f = attrgetter('name.first', 'name.last')</code> 之后，调用 <code>f(b)</code> 将返回 <code>(b.name.first, b.name.last)</code>。</li>
</ul>
<p>等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">attrgetter</span><span class="token punctuation">(</span><span class="token operator">*</span>items<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> any<span class="token punctuation">(</span><span class="token operator">not</span> isinstance<span class="token punctuation">(</span>item<span class="token punctuation">,</span> str<span class="token punctuation">)</span> <span class="token keyword">for</span> item <span class="token keyword">in</span> items<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span><span class="token string">'attribute name must be a string'</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> len<span class="token punctuation">(</span>items<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        attr <span class="token operator">=</span> items<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">g</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> resolve_attr<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> attr<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">g</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> tuple<span class="token punctuation">(</span>resolve_attr<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> attr<span class="token punctuation">)</span> <span class="token keyword">for</span> attr <span class="token keyword">in</span> items<span class="token punctuation">)</span>
    <span class="token keyword">return</span> g
<span class="token keyword">def</span> <span class="token function">resolve_attr</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> attr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> name <span class="token keyword">in</span> attr<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        obj <span class="token operator">=</span> getattr<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
    <span class="token keyword">return</span> obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>operator.itemgetter</code>(<em>item</em>)</p>
<p><code>operator.itemgetter</code>(<em>\</em>items*)</p>
<p>返回一个使用操作数的 <code>__getitem__()</code> 方法从操作数中获取 <em>item</em> 的可调用对象。 如果指定了多个条目，则返回一个查找值的元组。 例如：</p>
<ul>
<li>在 <code>f = itemgetter(2)</code> 之后，调用 <code>f(r)</code> 将返回 <code>r[2]</code>。</li>
<li>在 <code>g = itemgetter(2, 5, 3)</code> 之后，调用 <code>g(r)</code> 将返回 <code>(r[2], r[5], r[3])</code>。</li>
</ul>
<p>等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">itemgetter</span><span class="token punctuation">(</span><span class="token operator">*</span>items<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> len<span class="token punctuation">(</span>items<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        item <span class="token operator">=</span> items<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">g</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">g</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> tuple<span class="token punctuation">(</span>obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token keyword">for</span> item <span class="token keyword">in</span> items<span class="token punctuation">)</span>
    <span class="token keyword">return</span> g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>传入的条目可以为操作数的 <code>__getitem__()</code> 所接受的任何类型。 字典接受任意可哈希的值。 列表、元组和字符串接受 index 或 slice 对象：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'ABCDEFG'</span><span class="token punctuation">)</span>
<span class="token string">'B'</span>
<span class="token operator">>></span><span class="token operator">></span> itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'ABCDEFG'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'F'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> itemgetter<span class="token punctuation">(</span>slice<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'ABCDEFG'</span><span class="token punctuation">)</span>
<span class="token string">'CDEFG'</span>
<span class="token operator">>></span><span class="token operator">></span> soldier <span class="token operator">=</span> dict<span class="token punctuation">(</span>rank<span class="token operator">=</span><span class="token string">'captain'</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'dotterbart'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> itemgetter<span class="token punctuation">(</span><span class="token string">'rank'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>soldier<span class="token punctuation">)</span>
<span class="token string">'captain'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>itemgetter()</code> 从元组的记录中提取特定字段的例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> inventory <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> getcount <span class="token operator">=</span> itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>getcount<span class="token punctuation">,</span> inventory<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>inventory<span class="token punctuation">,</span> key<span class="token operator">=</span>getcount<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>operator.methodcaller</code>(<em>name</em>, <em>/</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>返回一个在操作数上调用 <em>name</em> 方法的可调用对象。 如果给出额外的参数和/或关键字参数，它们也将被传给该方法。 例如：</p>
<ul>
<li>在 <code>f = methodcaller('name')</code> 之后，调用 <code>f(b)</code> 将返回 <code>b.name()</code>。</li>
<li>在 <code>f = methodcaller('name', 'foo', bar=1)</code> 之后，调用 <code>f(b)</code> 将返回 <code>b.name('foo', bar=1)</code>。</li>
</ul>
<p>等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">methodcaller</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">caller</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> getattr<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
    <span class="token keyword">return</span> caller<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="将运算符映射到函数"><a href="#将运算符映射到函数" class="headerlink" title="将运算符映射到函数"></a>将运算符映射到函数</h3><p>以下表格显示了抽象运算是如何对应于 Python 语法中的运算符和 <code>operator</code> 模块中的函数的。</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">语法</th>
<th align="left">函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">加法</td>
<td align="left"><code>a + b</code></td>
<td align="left"><code>add(a, b)</code></td>
</tr>
<tr>
<td align="left">字符串拼接</td>
<td align="left"><code>seq1 + seq2</code></td>
<td align="left"><code>concat(seq1, seq2)</code></td>
</tr>
<tr>
<td align="left">包含测试</td>
<td align="left"><code>obj in seq</code></td>
<td align="left"><code>contains(seq, obj)</code></td>
</tr>
<tr>
<td align="left">除法</td>
<td align="left"><code>a / b</code></td>
<td align="left"><code>truediv(a, b)</code></td>
</tr>
<tr>
<td align="left">除法</td>
<td align="left"><code>a // b</code></td>
<td align="left"><code>floordiv(a, b)</code></td>
</tr>
<tr>
<td align="left">按位与</td>
<td align="left"><code>a &amp; b</code></td>
<td align="left"><code>and*(a, b)*</code></td>
</tr>
<tr>
<td align="left">按位异或</td>
<td align="left"><code>a ^ b</code></td>
<td align="left"><code>xor(a, b)</code></td>
</tr>
<tr>
<td align="left">按位取反</td>
<td align="left"><code>~ a</code></td>
<td align="left"><code>invert(a)</code></td>
</tr>
<tr>
<td align="left">按位或</td>
<td align="left">`a</td>
<td align="left">b`</td>
</tr>
<tr>
<td align="left">取幂</td>
<td align="left"><code>a ** b*</code></td>
<td align="left"><code>pow(a, b)</code></td>
</tr>
<tr>
<td align="left">标识</td>
<td align="left"><code>a is b</code></td>
<td align="left"><code>is_(a, b)</code></td>
</tr>
<tr>
<td align="left">标识</td>
<td align="left"><code>a is not b</code></td>
<td align="left"><code>is_not(a, b)</code></td>
</tr>
<tr>
<td align="left">索引赋值</td>
<td align="left"><code>obj[k] = v</code></td>
<td align="left"><code>setitem(obj, k, v)</code></td>
</tr>
<tr>
<td align="left">索引删除</td>
<td align="left"><code>del obj[k]</code></td>
<td align="left"><code>delitem(obj, k)</code></td>
</tr>
<tr>
<td align="left">索引取值</td>
<td align="left"><code>obj[k]</code></td>
<td align="left"><code>getitem(obj, k)</code></td>
</tr>
<tr>
<td align="left">左移</td>
<td align="left"><code>a &lt;&lt; b</code></td>
<td align="left"><code>lshift(a, b)</code></td>
</tr>
<tr>
<td align="left">取模</td>
<td align="left"><code>a % b</code></td>
<td align="left"><code>mod(a, b)</code></td>
</tr>
<tr>
<td align="left">乘法</td>
<td align="left"><code>a b</code></td>
<td align="left"><code>mul(a, b)</code></td>
</tr>
<tr>
<td align="left">矩阵乘法</td>
<td align="left"><code>a @ b</code></td>
<td align="left"><code>matmul(a, b)</code></td>
</tr>
<tr>
<td align="left">取反（算术）</td>
<td align="left"><code>- a</code></td>
<td align="left"><code>neg(a)</code></td>
</tr>
<tr>
<td align="left">取反（逻辑）</td>
<td align="left"><code>not a</code></td>
<td align="left"><code>not_(a)</code></td>
</tr>
<tr>
<td align="left">正数</td>
<td align="left"><code>+ a</code></td>
<td align="left"><code>pos(a)</code></td>
</tr>
<tr>
<td align="left">右移</td>
<td align="left"><code>a &gt;&gt; b</code></td>
<td align="left"><code>rshift(a, b)</code></td>
</tr>
<tr>
<td align="left">切片赋值</td>
<td align="left"><code>seq[i:j] = values</code></td>
<td align="left"><code>setitem(seq, slice(i, j), values)</code></td>
</tr>
<tr>
<td align="left">切片删除</td>
<td align="left"><code>del seq[i:j]</code></td>
<td align="left"><code>delitem(seq, slice(i, j))</code></td>
</tr>
<tr>
<td align="left">切片取值</td>
<td align="left"><code>seq[i:j]</code></td>
<td align="left"><code>getitem(seq, slice(i, j))</code></td>
</tr>
<tr>
<td align="left">字符串格式化</td>
<td align="left"><code>s % obj</code></td>
<td align="left"><code>mod(s, obj)</code></td>
</tr>
<tr>
<td align="left">减法</td>
<td align="left"><code>a - b</code></td>
<td align="left"><code>sub(a, b)</code></td>
</tr>
<tr>
<td align="left">真值测试</td>
<td align="left"><code>obj</code></td>
<td align="left"><code>truth(obj)</code></td>
</tr>
<tr>
<td align="left">比较</td>
<td align="left"><code>a &lt; b</code></td>
<td align="left"><code>lt(a, b)</code></td>
</tr>
<tr>
<td align="left">比较</td>
<td align="left"><code>a &lt;= b</code></td>
<td align="left"><code>le(a, b)</code></td>
</tr>
<tr>
<td align="left">相等</td>
<td align="left"><code>a == b</code></td>
<td align="left"><code>eq(a, b)</code></td>
</tr>
<tr>
<td align="left">不等</td>
<td align="left"><code>a != b</code></td>
<td align="left"><code>ne(a, b)</code></td>
</tr>
<tr>
<td align="left">比较</td>
<td align="left"><code>a &gt;= b</code></td>
<td align="left"><code>ge(a, b)</code></td>
</tr>
<tr>
<td align="left">比较</td>
<td align="left"><code>a &gt; b</code></td>
<td align="left"><code>gt(a, b)</code></td>
</tr>
</tbody></table>
<h3 id="原地运算符"><a href="#原地运算符" class="headerlink" title="原地运算符"></a>原地运算符</h3><p>许多运算都有“原地”版本。 以下列出的是提供对原地运算符相比通常语法更底层访问的函数，例如 statement <code>x += y</code> 相当于 <code>x = operator.iadd(x, y)</code>。 换一种方式来讲就是 <code>z = operator.iadd(x, y)</code> 等价于语句块 <code>z = x; z += y</code>。</p>
<p>在这些例子中，请注意当调用一个原地方法时，运算和赋值是分成两个步骤来执行的。 下面列出的原地函数只执行第一步即调用原地方法。 第二步赋值则不加处理。</p>
<p>对于不可变的目标例如字符串、数字和元组，更新的值会被计算，但不会被再被赋值给输入变量：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token string">'hello'</span>
<span class="token operator">>></span><span class="token operator">></span> iadd<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">' world'</span><span class="token punctuation">)</span>
<span class="token string">'hello world'</span>
<span class="token operator">>></span><span class="token operator">></span> a
<span class="token string">'hello'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于可变的目标例如列表和字典，原地方法将执行更新，因此不需要后续赋值操作：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> iadd<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> s
<span class="token punctuation">[</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>operator.iadd</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__iadd__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = iadd(a, b)</code> 等价于 <code>a += b</code>。</p>
<p><code>operator.iand</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__iand__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = iand(a, b)</code> 等价于 <code>a &amp;= b</code>。</p>
<p><code>operator.iconcat</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__iconcat__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = iconcat(a, b)</code> 等价于 <code>a += b</code> 其中 <em>a</em> 和 <em>b</em> 为序列。</p>
<p><code>operator.ifloordiv</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ifloordiv__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = ifloordiv(a, b)</code> 等价于 <code>a //= b</code>。</p>
<p><code>operator.ilshift</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ilshift__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = ilshift(a, b)</code> 等价于 <code>a &lt;&lt;= b</code>。</p>
<p><code>operator.imod</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__imod__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = imod(a, b)</code> 等价于 <code>a %= b</code>。</p>
<p><code>operator.imul</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__imul__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = imul(a, b)</code> 等价于 <code>a *= b</code>。</p>
<p><code>operator.imatmul</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__imatmul__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = imatmul(a, b)</code> 等价于 <code>a @= b</code>。</p>
<p>3.5 新版功能.</p>
<p><code>operator.ior</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ior__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = ior(a, b)</code> 等价于 <code>a |= b</code>。</p>
<p><code>operator.ipow</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ipow__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = ipow(a, b)</code> 等价于 <code>a **= b</code>。</p>
<p><code>operator.irshift</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__irshift__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = irshift(a, b)</code> 等价于 <code>a &gt;&gt;= b</code>。</p>
<p><code>operator.isub</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__isub__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = isub(a, b)</code> 等价于 <code>a -= b</code>。</p>
<p><code>operator.itruediv</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__itruediv__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = itruediv(a, b)</code> 等价于 <code>a /= b</code>。</p>
<p><code>operator.ixor</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ixor__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = ixor(a, b)</code> 等价于 <code>a ^= b</code>。</p>
<h1 id="文件和目录访问"><a href="#文件和目录访问" class="headerlink" title="文件和目录访问"></a>文件和目录访问</h1><ul>
<li><code>pathlib</code> —- 面向对象的文件系统路径<ul>
<li>基础使用</li>
<li>纯路径<ul>
<li>通用性质</li>
<li>运算符</li>
<li>访问个别部分</li>
<li>方法和特征属性</li>
</ul>
</li>
<li>具体路径<ul>
<li>方法</li>
</ul>
</li>
<li>对应的 <code>os</code> 模块的工具</li>
</ul>
</li>
<li><code>os.path</code> —- 常用路径操作</li>
<li><code>fileinput</code> —- 迭代来自多个输入流的行</li>
<li><code>stat</code> —- 解析 <code>stat()</code> 结果</li>
<li><code>filecmp</code> —- 文件及目录的比较<ul>
<li><code>dircmp</code> 类</li>
</ul>
</li>
<li><code>tempfile</code> —- 生成临时文件和目录<ul>
<li>例子</li>
<li>已弃用的函数和变量</li>
</ul>
</li>
<li><code>glob</code> —- Unix 风格路径名模式扩展</li>
<li><code>fnmatch</code> —- Unix 文件名模式匹配</li>
<li><code>linecache</code> —- 随机读写文本行</li>
<li><code>shutil</code> —- 高阶文件操作<ul>
<li>目录和文件操作<ul>
<li>依赖于具体平台的高效拷贝操作</li>
<li>copytree 示例</li>
<li>rmtree 示例</li>
</ul>
</li>
<li>归档操作<ul>
<li>归档程序示例</li>
<li>使用 <em>base_dir</em> 的归档程序示例</li>
</ul>
</li>
<li>查询输出终端的尺寸</li>
</ul>
</li>
</ul>
<h2 id="pathlib-—-面向对象的文件系统路径"><a href="#pathlib-—-面向对象的文件系统路径" class="headerlink" title="pathlib —- 面向对象的文件系统路径"></a><code>pathlib</code> —- 面向对象的文件系统路径</h2><p>3.4 新版功能.</p>
<p><strong>源代码</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/pathlib.py" target="_blank" rel="noopener">Lib/pathlib.py</a></p>
<hr>
<p>该模块提供表示文件系统路径的类，其语义适用于不同的操作系统。路径类被分为提供纯计算操作而没有 I/O 的 纯路径，以及从纯路径继承而来但提供 I/O 操作的 具体路径。</p>
<p><img src="/images/loading.gif" data-original="../images/basic/7630eaca04bc0113c9884a446d903e20.png" alt=""></p>
<p>如果以前从未用过此模块，或不确定哪个类适合完成任务，那要用的可能就是 <code>Path</code>。它在运行代码的平台上实例化为 具体路径。</p>
<p>在一些用例中纯路径很有用，例如：</p>
<ol>
<li>如果你想要在 Unix 设备上操作 Windows 路径（或者相反）。你不应在 Unix 上实例化一个 <code>WindowsPath</code>，但是你可以实例化 <code>PureWindowsPath</code>。</li>
<li>你只想操作路径但不想实际访问操作系统。在这种情况下，实例化一个纯路径是有用的，因为它们没有任何访问操作系统的操作。</li>
</ol>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0428" target="_blank" rel="noopener"><strong>PEP 428</strong></a>：pathlib 模块 — 面向对象的的文件系统路径。</p>
<p>参见</p>
<p>对于底层的路径字符串操作，你也可以使用 <code>os.path</code> 模块。</p>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>导入主类:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> pathlib <span class="token keyword">import</span> Path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>列出子目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> p<span class="token punctuation">.</span>iterdir<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> x<span class="token punctuation">.</span>is_dir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'.hg'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'docs'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'__pycache__'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'build'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>列出当前目录树下的所有 Python 源代码文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>p<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'**/*.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'test_pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'docs/conf.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'build/lib/pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在目录树中移动:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> q <span class="token operator">=</span> p <span class="token operator">/</span> <span class="token string">'init.d'</span> <span class="token operator">/</span> <span class="token string">'reboot'</span>
<span class="token operator">>></span><span class="token operator">></span> q
PosixPath<span class="token punctuation">(</span><span class="token string">'/etc/init.d/reboot'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">.</span>resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/etc/rc.d/init.d/halt'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查询路径的属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">.</span>is_dir<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>打开一个文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> q<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span> f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token string">'#!/bin/bash\n'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="纯路径"><a href="#纯路径" class="headerlink" title="纯路径"></a>纯路径</h3><p>纯路径对象提供了不实际访问文件系统的路径处理操作。有三种方式来访问这些类，也是不同的风格：</p>
<p><em>class</em> <code>pathlib.PurePath</code>(<em>\</em>pathsegments*)</p>
<p>一个通用的类，代表当前系统的路径风格（实例化为 <code>PurePosixPath</code> 或者 <code>PureWindowsPath</code>）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># Running on a Unix machine</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>每一个 <em>pathsegments</em> 的元素可能是一个代表路径片段的字符串，一个返回字符串的实现了 <code>os.PathLike</code> 接口的对象，或者另一个路径对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token string">'some/path'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/some/path/bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Path<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/bar'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 <em>pathsegments</em> 为空的时候，假定为当前目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>当给出一些绝对路径，最后一位将被当作锚（模仿 <code>os.path.join()</code> 的行为）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">,</span> <span class="token string">'/usr'</span><span class="token punctuation">,</span> <span class="token string">'lib64'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/usr/lib64'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Windows'</span><span class="token punctuation">,</span> <span class="token string">'d:bar'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'d:bar'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是，在 Windows 路径中，改变本地根目录并不会丢弃之前盘符的设置:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Windows'</span><span class="token punctuation">,</span> <span class="token string">'/Program Files'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>假斜线和单独的点都会被消除，但是双点 （<code>‘..’</code>） 不会，以防改变符号链接的含义。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'foo//bar'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'foo/./bar'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'foo/../bar'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/../bar'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（一个很 naïve 的做法是让 <code>PurePosixPath('foo/../bar')</code> 等同于 <code>PurePosixPath('bar')</code>，如果 <code>foo</code> 是一个指向其他目录的符号链接那么这个做法就将出错）</p>
<p>纯路径对象实现了 <code>os.PathLike</code> 接口，允许它们在任何接受此接口的地方使用。</p>
<p>在 3.6 版更改: 添加了 <code>os.PathLike</code> 接口支持。</p>
<p><em>class</em> <code>pathlib.PurePosixPath</code>(<em>\</em>pathsegments*)</p>
<p>一个 <code>PurePath</code> 的子类，路径风格不同于 Windows 文件系统:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>pathsegments</em> 参数的指定和 <code>PurePath</code> 相同。</p>
<p><em>class</em> <code>pathlib.PureWindowsPath</code>(<em>\</em>pathsegments*)</p>
<p><code>PurePath</code> 的一个子类，路径风格为 Windows 文件系统路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>pathsegments</em> 参数的指定和 <code>PurePath</code> 相同。</p>
<p>无论你正运行什么系统，你都可以实例化这些类，因为它们提供的操作不做任何系统调用。</p>
<h4 id="通用性质"><a href="#通用性质" class="headerlink" title="通用性质"></a>通用性质</h4><p>路径是不可变并可哈希的。相同风格的路径可以排序与比较。这些性质尊重对应风格的大小写转换语义:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token operator">==</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'FOO'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token operator">==</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'FOO'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'FOO'</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token punctuation">{</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'C:'</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'d:'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不同风格的路径比较得到不等的结果并且无法被排序:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token operator">==</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> <span class="token string">'&lt;'</span> <span class="token operator">not</span> supported between instances of <span class="token string">'PureWindowsPath'</span> <span class="token operator">and</span> <span class="token string">'PurePosixPath'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>斜杠 <code>/</code> 操作符有助于创建子路径，就像 <code>os.path.join()</code> 一样:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">/</span> <span class="token string">'init.d'</span> <span class="token operator">/</span> <span class="token string">'apache2'</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/init.d/apache2'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> q <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'bin'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'/usr'</span> <span class="token operator">/</span> q
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/usr/bin'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>文件对象可用于任何接受 <code>os.PathLike</code> 接口实现的地方。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>fspath<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token string">'/etc'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>路径的字符串表示法为它自己原始的文件系统路径（以原生形式，例如在 Windows 下使用反斜杠）。你可以传递给任何需要字符串形式路径的函数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token string">'/etc'</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token string">'c:\\Program Files'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>类似地，在路径上调用 <code>bytes</code> 将原始文件系统路径作为字节对象给出，就像被 <code>os.fsencode()</code> 编码一样:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> bytes<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
b<span class="token string">'/etc'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注解</p>
<p>只推荐在 Unix 下调用 <code>bytes</code>。在 Windows， unicode 形式是文件系统路径的规范表示法。</p>
<h4 id="访问个别部分"><a href="#访问个别部分" class="headerlink" title="访问个别部分"></a>访问个别部分</h4><p>为了访问路径独立的部分 （组件），使用以下特征属性：</p>
<pre><code>PurePath.parts</code></pre><p>一个元组，可以访问路径的多个组件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'/usr/bin/python3'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parts
<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'usr'</span><span class="token punctuation">,</span> <span class="token string">'bin'</span><span class="token punctuation">,</span> <span class="token string">'python3'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/PSF'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parts
<span class="token punctuation">(</span><span class="token string">'c:\\'</span><span class="token punctuation">,</span> <span class="token string">'Program Files'</span><span class="token punctuation">,</span> <span class="token string">'PSF'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（注意盘符和本地根目录是如何重组的）</p>
<h4 id="方法和特征属性"><a href="#方法和特征属性" class="headerlink" title="方法和特征属性"></a>方法和特征属性</h4><p>纯路径提供以下方法和特征属性：</p>
<pre><code>PurePath.drive</code></pre><p>一个表示驱动器盘符或命名的字符串，如果存在:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>drive
<span class="token string">'c:'</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'/Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>drive
<span class="token string">''</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>drive
<span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>UNC 分享也被认作驱动器:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//host/share/foo.txt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>drive
<span class="token string">'\\\\host\\share'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>PurePath.root</code></p>
<p>一个表示（本地或全局）根的字符串，如果存在:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>root
<span class="token string">'\\'</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>root
<span class="token string">''</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>root
<span class="token string">'/'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>UNC 分享一样拥有根:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//host/share'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>root
<span class="token string">'\\'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>PurePath.anchor</code></p>
<p>驱动器和根的联合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>anchor
<span class="token string">'c:\\'</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>anchor
<span class="token string">'c:'</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>anchor
<span class="token string">'/'</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//host/share'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>anchor
<span class="token string">'\\\\host\\share\\'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>An immutable sequence providing access to the logical ancestors of the path:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/foo/bar/setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/foo/bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/foo'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.10 版更改: parents 序列现在支持 切片 负的索引值。</p>
<pre><code>PurePath.parent</code></pre><p>此路径的逻辑父路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/a/b/c/d'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parent
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/a/b/c'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>你不能超过一个 anchor 或空路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parent
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parent
PurePosixPath<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>这是一个单纯的词法操作，因此有以下行为:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/..'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parent
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果你想要向上移动任意文件系统路径，推荐先使用 <code>Path.resolve()</code> 来解析符号链接以及消除 <code>".."</code> 组件。</p>
<pre><code>PurePath.name</code></pre><p>一个表示最后路径组件的字符串，排除了驱动器与根目录，如果存在的话:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library/setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name
<span class="token string">'setup.py'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>UNC 驱动器名不被考虑:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//some/share/setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name
<span class="token string">'setup.py'</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//some/share'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name
<span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.suffix</code></p>
<p>最后一个组件的文件扩展名，如果存在:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library/setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffix
<span class="token string">'.py'</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library.tar.gz'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffix
<span class="token string">'.gz'</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffix
<span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.suffixes</code></p>
<p>路径的文件扩展名列表:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library.tar.gar'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffixes
<span class="token punctuation">[</span><span class="token string">'.tar'</span><span class="token punctuation">,</span> <span class="token string">'.gar'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library.tar.gz'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffixes
<span class="token punctuation">[</span><span class="token string">'.tar'</span><span class="token punctuation">,</span> <span class="token string">'.gz'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffixes
<span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.stem</code></p>
<p>最后一个路径组件，除去后缀:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library.tar.gz'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>stem
<span class="token string">'library.tar'</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library.tar'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>stem
<span class="token string">'library'</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>stem
<span class="token string">'library'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.as_posix</code>()</p>
<p>返回使用正斜杠（<code>/</code>）的路径字符串:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:\\windows'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token string">'c:\\windows'</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>as_posix<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'c:/windows'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.as_uri</code>()</p>
<p>将路径表示为 <code>file</code> URL。如果并非绝对路径，抛出 <code>ValueError</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>as_uri<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'file:///etc/passwd'</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Windows'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>as_uri<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'file:///c:/Windows'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.is_absolute</code>()</p>
<p>返回此路径是否为绝对路径。如果路径同时拥有驱动器符与根路径（如果风格允许）则将被认作绝对路径。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/a/b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'a/b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/a/b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'/a/b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//some/share'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.is_relative_to</code>(<em>\</em>other*)</p>
<p>返回此路径是否相对于 <em>other</em> 的路径。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>is_relative_to<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>is_relative_to<span class="token punctuation">(</span><span class="token string">'/usr'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>PurePath.is_reserved</code>()</p>
<p>在 <code>PureWindowsPath</code>，如果路径是被 Windows 保留的则返回 <code>True</code>，否则 <code>False</code>。在 <code>PurePosixPath</code>，总是返回 <code>False</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'nul'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_reserved<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'nul'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_reserved<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当保留路径上的文件系统被调用，则可能出现玄学失败或者意料之外的效应。</p>
<p><code>PurePath.joinpath</code>(<em>\</em>other*)</p>
<p>调用此方法等同于将每个 <em>other</em> 参数中的项目连接在一起:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">'passwd'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span>PurePosixPath<span class="token punctuation">(</span><span class="token string">'passwd'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">'init.d'</span><span class="token punctuation">,</span> <span class="token string">'apache2'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/init.d/apache2'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">'/Program Files'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.match</code>(<em>pattern</em>)</p>
<p>将此路径与提供的通配符风格的模式匹配。如果匹配成功则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>如果 <em>pattern</em> 是相对的，则路径可以是相对路径或绝对路径，并且匹配是从右侧完成的：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'a/b.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'*.py'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'/a/b/c.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'b/*.py'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'/a/b/c.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'a/*.py'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>pattern</em> 是绝对的，则路径必须是绝对的，并且路径必须完全匹配:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'/a.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'/*.py'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'a/b.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'/*.py'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>与其他方法一样，是否大小写敏感遵循平台的默认规则:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'b.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'*.PY'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'b.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'*.PY'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.relative_to</code>(<em>\</em>other*)</p>
<p>计算此路径相对 <em>other</em> 表示路径的版本。如果不可计算，则抛出 ValueError:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>relative_to<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>relative_to<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>relative_to<span class="token punctuation">(</span><span class="token string">'/usr'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"pathlib.py"</span><span class="token punctuation">,</span> line <span class="token number">694</span><span class="token punctuation">,</span> <span class="token keyword">in</span> relative_to
    <span class="token punctuation">.</span>format<span class="token punctuation">(</span>str<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> str<span class="token punctuation">(</span>formatted<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ValueError<span class="token punctuation">:</span> <span class="token string">'/etc/passwd'</span> <span class="token keyword">is</span> <span class="token operator">not</span> <span class="token keyword">in</span> the subpath of <span class="token string">'/usr'</span> OR one path <span class="token keyword">is</span> relative <span class="token operator">and</span> the other absolute<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：此函数是 <code>PurePath</code> 的一部分并且适用于字符串。 它不会检查或访问下层的文件结构。</p>
<p><code>PurePath.with_name</code>(<em>name</em>)</p>
<p>返回一个新的路径并修改 <code>name</code>。如果原本路径没有 name，ValueError 被抛出:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/pathlib.tar.gz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_name<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_name<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"/home/antoine/cpython/default/Lib/pathlib.py"</span><span class="token punctuation">,</span> line <span class="token number">751</span><span class="token punctuation">,</span> <span class="token keyword">in</span> with_name
    <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">"%r has an empty name"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ValueError<span class="token punctuation">:</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/'</span><span class="token punctuation">)</span> has an empty name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.with_stem</code>(<em>stem</em>)</p>
<p>返回一个带有修改后 <code>stem</code> 的新路径。 如果原路径没有名称，则会引发 ValueError:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/draft.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_stem<span class="token punctuation">(</span><span class="token string">'final'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/final.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/pathlib.tar.gz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_stem<span class="token punctuation">(</span><span class="token string">'lib'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/lib.gz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_stem<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"/home/antoine/cpython/default/Lib/pathlib.py"</span><span class="token punctuation">,</span> line <span class="token number">861</span><span class="token punctuation">,</span> <span class="token keyword">in</span> with_stem
    <span class="token keyword">return</span> self<span class="token punctuation">.</span>with_name<span class="token punctuation">(</span>stem <span class="token operator">+</span> self<span class="token punctuation">.</span>suffix<span class="token punctuation">)</span>
  File <span class="token string">"/home/antoine/cpython/default/Lib/pathlib.py"</span><span class="token punctuation">,</span> line <span class="token number">851</span><span class="token punctuation">,</span> <span class="token keyword">in</span> with_name
    <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">"%r has an empty name"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ValueError<span class="token punctuation">:</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/'</span><span class="token punctuation">)</span> has an empty name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>PurePath.with_suffix</code>(<em>suffix</em>)</p>
<p>返回一个新的路径并修改 <code>suffix</code>。如果原本的路径没有后缀，新的 <em>suffix</em> 则被追加以代替。如果 <em>suffix</em> 是空字符串，则原本的后缀被移除:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/pathlib.tar.gz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_suffix<span class="token punctuation">(</span><span class="token string">'.bz2'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/pathlib.tar.bz2'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'README'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_suffix<span class="token punctuation">(</span><span class="token string">'.txt'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'README.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'README.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_suffix<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'README'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="具体路径"><a href="#具体路径" class="headerlink" title="具体路径"></a>具体路径</h3><p>具体路径是纯路径的子类。除了后者提供的操作之外，它们还提供了对路径对象进行系统调用的方法。有三种方法可以实例化具体路径:</p>
<p><em>class</em> <code>pathlib.Path</code>(<em>\</em>pathsegments*)</p>
<p>一个 <code>PurePath</code> 的子类，此类以当前系统的路径风格表示路径（实例化为 <code>PosixPath</code> 或 <code>WindowsPath</code>）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>pathsegments</em> 参数的指定和 <code>PurePath</code> 相同。</p>
<p><em>class</em> <code>pathlib.PosixPath</code>(<em>\</em>pathsegments*)</p>
<p>一个 <code>Path</code> 和 <code>PurePosixPath</code> 的子类，此类表示一个非 Windows 文件系统的具体路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>pathsegments</em> 参数的指定和 <code>PurePath</code> 相同。</p>
<p><em>class</em> <code>pathlib.WindowsPath</code>(<em>\</em>pathsegments*)</p>
<p><code>Path</code> 和 <code>PureWindowsPath</code> 的子类，从类表示一个 Windows 文件系统的具体路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> WindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/'</span><span class="token punctuation">)</span>
WindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>pathsegments</em> 参数的指定和 <code>PurePath</code> 相同。</p>
<p>你只能实例化与当前系统风格相同的类（允许系统调用作用于不兼容的路径风格可能在应用程序中导致缺陷或失败）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>name
<span class="token string">'posix'</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> WindowsPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"pathlib.py"</span><span class="token punctuation">,</span> line <span class="token number">798</span><span class="token punctuation">,</span> <span class="token keyword">in</span> __new__
    <span class="token operator">%</span> <span class="token punctuation">(</span>cls<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
NotImplementedError<span class="token punctuation">:</span> cannot instantiate <span class="token string">'WindowsPath'</span> on your system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>除纯路径方法外，实体路径还提供以下方法。 如果系统调用失败（例如因为路径不存在）这些方法中许多都会引发 <code>OSError</code>。</p>
<p>在 3.8 版更改: 对于包含 OS 层级无法表示字符的路径，<code>exists()</code>, <code>is_dir()</code>, <code>is_file()</code>, <code>is_mount()</code>, <code>is_symlink()</code>, <code>is_block_device()</code>, <code>is_char_device()</code>, <code>is_fifo()</code>, <code>is_socket()</code> 现在将返回 <code>False</code> 而不是引发异常。</p>
<p><em>classmethod</em> <code>Path.cwd</code>()</p>
<p>返回一个新的表示当前目录的路径对象（和 <code>os.getcwd()</code> 返回的相同）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">.</span>cwd<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/antoine/pathlib'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>classmethod</em> <code>Path.home</code>()</p>
<p>返回一个表示用户家目录的新路径对象（与带 <code>~</code> 构造的 <code>os.path.expanduser()</code> 所返回的相同）。 如果无法解析家目录，则会引发 <code>RuntimeError</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">.</span>home<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/antoine'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p><code>Path.stat</code>(<em>**,</em> follow_symlinks=True*)</p>
<p>返回一个 <code>os.stat_result</code> 对象，其中包含有关此路径的信息，例如 <code>os.stat()</code>。 结果会在每次调用此方法时重新搜索。</p>
<p>此方法通常会跟随符号链接；要对 symlink 使用 stat 请添加参数 <code>follow_symlinks=False</code>，或者使用 <code>lstat()</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_size
<span class="token number">956</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_mtime
<span class="token number">1327883547.852554</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.10 版更改: 增加了 <em>follow_symlinks</em> 形参。</p>
<p><code>Path.chmod</code>(<em>mode</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>改变文件模式和权限，和 <code>os.chmod()</code> 一样。</p>
<p>此方法通常会跟随符号链接。 某些 Unix 变种支持改变 symlink 本身的权限；在这些平台上你可以添加参数 <code>follow_symlinks=False</code>，或者使用 <code>lchmod()</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_mode
<span class="token number">33277</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>chmod<span class="token punctuation">(</span><span class="token number">0o444</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_mode
<span class="token number">33060</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.10 版更改: 增加了 <em>follow_symlinks</em> 形参。</p>
<p><code>Path.exists</code>()</p>
<p>此路径是否指向一个已存在的文件或目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'nonexistentfile'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>如果路径指向一个符号链接， <code>exists()</code> 返回此符号链接是否指向存在的文件或目录。</p>
<p><code>Path.expanduser</code>()</p>
<p>返回带有扩展 <code>~</code> 和 <code>~user</code> 构造的新路径，与 <code>os.path.expanduser()</code> 所返回的相同。 如果无法解析家目录，则会引发 <code>RuntimeError</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PosixPath<span class="token punctuation">(</span><span class="token string">'~/films/Monty Python'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/eric/films/Monty Python'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p><code>Path.glob</code>(<em>pattern</em>)</p>
<p>解析相对于此路径的通配符 <em>pattern</em>，产生所有匹配的文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'*.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'test_pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'*/*.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'docs/conf.py'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>pattern 的形式与 <code>fnmatch</code> 的相同，还增加了 “<code>**</code>“ 表示 “此目录以及所有子目录，递归”。 换句话说，它启用递归通配:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'**/*.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'build/lib/pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'docs/conf.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'test_pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>在一个较大的目录树中使用 “<code>**</code>“ 模式可能会消耗非常多的时间。</p>
<p>引发一个 审计事件 <code>pathlib.Path.glob</code> 附带参数 <code>self</code>, <code>pattern</code>。</p>
<p><code>Path.group</code>()</p>
<p>返回拥有此文件的用户组。如果文件的 GID 无法在系统数据库中找到，将抛出 <code>KeyError</code> 。</p>
<p><code>Path.is_dir</code>()</p>
<p>如果路径指向一个目录（或者一个指向目录的符号链接）则返回 <code>True</code>，如果指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_file</code>()</p>
<p>如果路径指向一个正常的文件（或者一个指向正常文件的符号链接）则返回 <code>True</code>，如果指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_mount</code>()</p>
<p>如果路径是一个 <em>挂载点 &lt;mount point&gt;*：在文件系统中被其他不同的文件系统挂载的地点。在 POSIX 系统，此函数检查 *path</em> 的父级 —— <code>path/..</code> 是否处于一个和 <em>path</em> 不同的设备中，或者 file:path/.. 和 <em>path</em> 是否指向相同设备的相同 i-node —— 这能检测所有 Unix 以及 POSIX 变种上的挂载点。 Windows 上未实现。</p>
<p>3.7 新版功能.</p>
<p><code>Path.is_symlink</code>()</p>
<p>如果路径指向符号链接则返回 <code>True</code>， 否则 <code>False</code>。</p>
<p>如果路径不存在也返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_socket</code>()</p>
<p>如果路径指向一个 Unix socket 文件（或者指向 Unix socket 文件的符号链接）则返回 <code>True</code>，如果指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_fifo</code>()</p>
<p>如果路径指向一个先进先出存储（或者指向先进先出存储的符号链接）则返回 <code>True</code> ，指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_block_device</code>()</p>
<p>如果文件指向一个块设备（或者指向块设备的符号链接）则返回 <code>True</code>，指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_char_device</code>()</p>
<p>如果路径指向一个字符设备（或指向字符设备的符号链接）则返回 <code>True</code>，指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.iterdir</code>()</p>
<p>当路径指向一个目录时，产生该路径下的对象的路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'docs'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> child <span class="token keyword">in</span> p<span class="token punctuation">.</span>iterdir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> child
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/conf.py'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/_templates'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/make.bat'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/index.rst'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/_build'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/_static'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/Makefile'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>子条目会以任意顺序生成，并且不包括特殊条目 <code>'.'</code> 和 <code>'..'</code>。 如果有文件在迭代器创建之后在目录中被移除或添加，是否要包括该文件对应的路径对象并没有规定。</p>
<p><code>Path.lchmod</code>(<em>mode</em>)</p>
<p>就像 <code>Path.chmod()</code> 但是如果路径指向符号链接则是修改符号链接的模式，而不是修改符号链接的目标。</p>
<p><code>Path.lstat</code>()</p>
<p>就和 <code>Path.stat()</code> 一样，但是如果路径指向符号链接，则是返回符号链接而不是目标的信息。</p>
<p><code>Path.mkdir</code>(<em>mode=511</em>, <em>parents=False</em>, <em>exist_ok=False</em>)</p>
<p>新建给定路径的目录。如果给出了 <em>mode</em> ，它将与当前进程的 <code>umask</code> 值合并来决定文件模式和访问标志。如果路径已经存在，则抛出 <code>FileExistsError</code>。</p>
<p>如果 <em>parents</em> 为 true，任何找不到的父目录都会伴随着此路径被创建；它们会以默认权限被创建，而不考虑 <em>mode</em> 设置（模仿 POSIX 的 <code>mkdir -p</code> 命令）。</p>
<p>如果 <em>parents</em> 为 false（默认），则找不到的父级目录会导致 <code>FileNotFoundError</code> 被抛出。</p>
<p>如果 <em>exist_ok</em> 为 false（默认），则在目标已存在的情况下抛出 <code>FileExistsError</code>。</p>
<p>如果 <em>exist_ok</em> 为 true， 则 <code>FileExistsError</code> 异常将被忽略（和 POSIX <code>mkdir -p</code> 命令行为相同），但是只有在最后一个路径组件不是现存的非目录文件时才生效。</p>
<p>在 3.5 版更改: <em>exist_ok</em> 形参被加入。</p>
<p><code>Path.open</code>(<em>mode=’r’</em>, <em>buffering=- 1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>)</p>
<p>打开路径指向的文件，就像内置的 <code>open()</code> 函数所做的一样:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> p<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token string">'#!/usr/bin/env python3\n'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Path.owner</code>()</p>
<p>返回拥有此文件的用户名。如果文件的 UID 无法在系统数据库中找到，则抛出 <code>KeyError</code>。</p>
<p><code>Path.read_bytes</code>()</p>
<p>以字节对象的形式返回路径指向的文件的二进制内容:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'my_binary_file'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>write_bytes<span class="token punctuation">(</span>b<span class="token string">'Binary file contents'</span><span class="token punctuation">)</span>
<span class="token number">20</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>read_bytes<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'Binary file contents'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p><code>Path.read_text</code>(<em>encoding=None</em>, <em>errors=None</em>)</p>
<p>以字符串形式返回路径指向的文件的解码后文本内容。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'my_text_file'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>write_text<span class="token punctuation">(</span><span class="token string">'Text file contents'</span><span class="token punctuation">)</span>
<span class="token number">18</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>read_text<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'Text file contents'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>文件先被打开然后关闭。有和 <code>open()</code> 一样的可选形参。</p>
<p>3.5 新版功能.</p>
<p><code>Path.readlink</code>()</p>
<p>返回符号链接所指向的路径（即 <code>os.readlink()</code> 的返回值）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'mylink'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>symlink_to<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>readlink<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>Path.rename</code>(<em>target</em>)</p>
<p>将文件或目录重命名为给定的 <em>target*，并返回一个新的指向 *target</em> 的 Path 实例。 在 Unix 上，如果 <em>target</em> 存在且为一个文件，如果用户有足够权限，则它将被静默地替换。 <em>target</em> 可以是一个字符串或者另一个路径对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'w'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'some text'</span><span class="token punctuation">)</span>
<span class="token number">9</span>
<span class="token operator">>></span><span class="token operator">></span> target <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>rename<span class="token punctuation">(</span>target<span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> target<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'some text'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>目标路径可能为绝对或相对路径。 相对路径将被解释为相对于当前工作目录，而 <em>不是</em> 相对于 Path 对象的目录。</p>
<p>在 3.8 版更改: 添加了返回值，返回新的 Path 实例。</p>
<p><code>Path.replace</code>(<em>target</em>)</p>
<p>将文件名目录重命名为给定的 <em>target*，并返回一个新的指向 *target</em> 的 Path 实例。 如果 <em>target</em> 指向一个现有文件或目录，则它将被无条件地替换。</p>
<p>目标路径可能为绝对或相对路径。 相对路径将被解释为相对于当前工作目录，而 <em>不是</em> 相对于 Path 对象的目录。</p>
<p>在 3.8 版更改: 添加了返回值，返回新的 Path 实例。</p>
<p><code>Path.resolve</code>(<em>strict=False</em>)</p>
<p>将路径绝对化，解析任何符号链接。返回新的路径对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p
PosixPath<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/antoine/pathlib'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>“<code>..</code>“ 组件也将被消除（只有这一种方法这么做）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'docs/../setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/antoine/pathlib/setup.py'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果路径不存在并且 <em>strict</em> 设为 <code>True</code>，则抛出 <code>FileNotFoundError</code>。如果 <em>strict</em> 为 <code>False</code>，则路径将被尽可能地解析并且任何剩余部分都会被不检查是否存在地追加。如果在解析路径上发生无限循环，则抛出 <code>RuntimeError</code>。</p>
<p>3.6 新版功能: 加入<em>strict</em> 参数（3.6之前的版本相当于strict值为True）</p>
<p><code>Path.rglob</code>(<em>pattern</em>)</p>
<p>这就像调用 <code>Path.glob</code>时在给定的相对 <em>pattern</em> 前面添加了”``**/<code>()</code>“</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rglob<span class="token punctuation">(</span><span class="token string">"*.py"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'build/lib/pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'docs/conf.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'test_pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>引发一个 审计事件 <code>pathlib.Path.rglob</code> 附带参数 <code>self</code>, <code>pattern</code>。</p>
<p><code>Path.rmdir</code>()</p>
<p>移除此目录。此目录必须为空的。</p>
<p><code>Path.samefile</code>(<em>other_path</em>)</p>
<p>返回此目录是否指向与可能是字符串或者另一个路径对象的 <em>other_path</em> 相同的文件。语义类似于 <code>os.path.samefile()</code> 与 <code>os.path.samestat()</code>。</p>
<p>如果两者都以同一原因无法访问，则抛出 <code>OSError</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> q <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'eggs'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>samefile<span class="token punctuation">(</span>q<span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>samefile<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p><code>Path.symlink_to</code>(<em>target</em>, <em>target_is_directory=False</em>)</p>
<p>将此路径创建为指向 <em>target</em> 的符号链接。在 Windows 下，如果链接的目标是一个目录则 <em>target_is_directory</em> 必须为 true （默认为 <code>False</code>）。在 POSIX 下， <em>target_is_directory</em> 的值将被忽略。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'mylink'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>symlink_to<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/antoine/pathlib/setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_size
<span class="token number">956</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>lstat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_size
<span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>参数的顺序（link, target) 和 <code>os.symlink()</code> 是相反的。</p>
<p><code>Path.hardlink_to</code>(<em>target</em>)</p>
<p>将此路径设为一个指向与 <em>target</em> 相同文件的硬链接。</p>
<p>注解</p>
<p>参数顺序 (link, target) 和 <code>os.link()</code> 是相反的。</p>
<p>3.10 新版功能.</p>
<p><code>Path.link_to</code>(<em>target</em>)</p>
<p>创建硬链接 <em>target</em> 指向此路径。</p>
<p>警告</p>
<p>此函数不会将此路径设为指向 <em>target</em> 的硬链接，尽管此函数名和参数名有此含义。 参数顺序 (target, link) 与 <code>Path.symlink_to()</code> 和 <code>Path.hardlink_to()</code> 相反，而与 <code>os.link()</code> 的一致。</p>
<p>3.8 新版功能.</p>
<p>3.10 版后已移除: 此方法已被弃用而建议改用 <code>Path.hardlink_to()</code>，因为 <code>Path.link_to()</code> 的参数顺序与 <code>Path.symlink_to()</code> 的不相匹配。</p>
<p><code>Path.touch</code>(<em>mode=438</em>, <em>exist_ok=True</em>)</p>
<p>将给定的路径创建为文件。如果给出了 <em>mode</em> 它将与当前进程的 <code>umask</code> 值合并以确定文件的模式和访问标志。如果文件已经存在，则当 <em>exist_ok</em> 为 true 则函数仍会成功（并且将它的修改事件更新为当前事件），否则抛出 <code>FileExistsError</code>。</p>
<p><code>Path.unlink</code>(<em>missing_ok=False</em>)</p>
<p>移除此文件或符号链接。如果路径指向目录，则用 <code>Path.rmdir()</code> 代替。</p>
<p>如果 <em>missing_ok</em> 为假值（默认），则如果路径不存在将会引发 <code>FileNotFoundError</code>。</p>
<p>如果 <em>missing_ok</em> 为真值，则 <code>FileNotFoundError</code> 异常将被忽略（和 POSIX <code>rm -f</code> 命令的行为相同）。</p>
<p>在 3.8 版更改: 增加了 <em>missing_ok</em> 形参。</p>
<p><code>Path.write_bytes</code>(<em>data</em>)</p>
<p>将文件以二进制模式打开，写入 <em>data</em> 并关闭:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'my_binary_file'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>write_bytes<span class="token punctuation">(</span>b<span class="token string">'Binary file contents'</span><span class="token punctuation">)</span>
<span class="token number">20</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>read_bytes<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'Binary file contents'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个同名的现存文件将被覆盖。</p>
<p>3.5 新版功能.</p>
<p><code>Path.write_text</code>(<em>data</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>)</p>
<p>将文件以文本模式打开，写入 <em>data</em> 并关闭:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'my_text_file'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>write_text<span class="token punctuation">(</span><span class="token string">'Text file contents'</span><span class="token punctuation">)</span>
<span class="token number">18</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>read_text<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'Text file contents'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同名的现有文件会被覆盖。 可选形参的含义与 <code>open()</code> 的相同。</p>
<p>3.5 新版功能.</p>
<p>在 3.10 版更改: 增加了 <em>newline</em> 形参。</p>
<h3 id="对应的-os-模块的工具"><a href="#对应的-os-模块的工具" class="headerlink" title="对应的 os 模块的工具"></a>对应的 <code>os</code> 模块的工具</h3><p>以下是一个映射了 <code>os</code> 与 <code>PurePath</code>/<code>Path</code> 对应相同的函数的表。</p>
<p>注解</p>
<p>以下函数/方法对并不完全等价。 它们有些虽然具有相互重叠的使用场景，但语义并不相同。 这包括了 <code>os.path.abspath()</code> 和 <code>Path.resolve()</code>，以及 <code>os.path.relpath()</code> 和 <code>PurePath.relative_to()</code>。</p>
<table>
<thead>
<tr>
<th align="left"><code>os</code> 和 <code>os.path</code></th>
<th align="left"><code>pathlib</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>os.path.abspath()</code></td>
<td align="left"><code>Path.resolve()</code></td>
</tr>
<tr>
<td align="left"><code>os.chmod()</code></td>
<td align="left"><code>Path.chmod()</code></td>
</tr>
<tr>
<td align="left"><code>os.mkdir()</code></td>
<td align="left"><code>Path.mkdir()</code></td>
</tr>
<tr>
<td align="left"><code>os.makedirs()</code></td>
<td align="left"><code>Path.mkdir()</code></td>
</tr>
<tr>
<td align="left"><code>os.rename()</code></td>
<td align="left"><code>Path.rename()</code></td>
</tr>
<tr>
<td align="left"><code>os.replace()</code></td>
<td align="left"><code>Path.replace()</code></td>
</tr>
<tr>
<td align="left"><code>os.rmdir()</code></td>
<td align="left"><code>Path.rmdir()</code></td>
</tr>
<tr>
<td align="left"><code>os.remove()</code>, <code>os.unlink()</code></td>
<td align="left"><code>Path.unlink()</code></td>
</tr>
<tr>
<td align="left"><code>os.getcwd()</code></td>
<td align="left"><code>Path.cwd()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.exists()</code></td>
<td align="left"><code>Path.exists()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.expanduser()</code></td>
<td align="left"><code>Path.expanduser()</code> 和 <code>Path.home()</code></td>
</tr>
<tr>
<td align="left"><code>os.listdir()</code></td>
<td align="left"><code>Path.iterdir()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.isdir()</code></td>
<td align="left"><code>Path.is_dir()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.isfile()</code></td>
<td align="left"><code>Path.is_file()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.islink()</code></td>
<td align="left"><code>Path.is_symlink()</code></td>
</tr>
<tr>
<td align="left"><code>os.link()</code></td>
<td align="left"><code>Path.hardlink_to()</code></td>
</tr>
<tr>
<td align="left"><code>os.symlink()</code></td>
<td align="left"><code>Path.symlink_to()</code></td>
</tr>
<tr>
<td align="left"><code>os.readlink()</code></td>
<td align="left"><code>Path.readlink()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.relpath()</code></td>
<td align="left"><code>Path.relative_to()</code></td>
</tr>
<tr>
<td align="left"><code>os.stat()</code></td>
<td align="left"><code>Path.stat()</code>, <code>Path.owner()</code>, <code>Path.group()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.isabs()</code></td>
<td align="left"><code>PurePath.is_absolute()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.join()</code></td>
<td align="left"><code>PurePath.joinpath()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.basename()</code></td>
<td align="left"><code>PurePath.name</code></td>
</tr>
<tr>
<td align="left"><code>os.path.dirname()</code></td>
<td align="left"><code>PurePath.parent</code></td>
</tr>
<tr>
<td align="left"><code>os.path.samefile()</code></td>
<td align="left"><code>Path.samefile()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.splitext()</code></td>
<td align="left"><code>PurePath.suffix</code></td>
</tr>
</tbody></table>
<h2 id="os-path-—-常用路径操作"><a href="#os-path-—-常用路径操作" class="headerlink" title="os.path —- 常用路径操作"></a><code>os.path</code> —- 常用路径操作</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/posixpath.py" target="_blank" rel="noopener">Lib/posixpath.py</a> （用于 POSIX）和 <a href="https://github.com/python/cpython/tree/3.10/Lib/ntpath.py" target="_blank" rel="noopener">Lib/ntpath.py</a> （用于 Windows NT）</p>
<hr>
<p>该模块在路径名上实现了一些有用的功能。路径参数可以字符串或字节形式传递。我们鼓励应用程序将文件名表示为（Unicode）字符串。不幸的是，某些文件名在Unix上可能无法用字符串表示，因此在Unix上平台上需要支持任意文件名的应用程序，应使用字节对象来表示路径名。反之亦然，在Windows平台上仅使用字节对象，不能表示的所有文件名（以标准 <code>mbcs</code> 编码），因此Windows应用程序应使用字符串对象来访问所有文件。</p>
<p>与unix shell不同，Python不执行任何 <em>自动</em> 路径扩展。当应用程序需要类似shell的路径扩展时，可以显式调用诸如 <code>expanduser()</code> 和 <code>expandvars()</code> 之类的函数。 </p>
<p>参见</p>
<p><code>pathlib</code> 模块提供高级路径对象。</p>
<p>注解</p>
<p>所有这些函数都仅接受字节或字符串对象作为其参数。如果返回路径或文件名，则结果是相同类型的对象。</p>
<p>注解</p>
<p>由于不同的操作系统具有不同的路径名称约定，因此标准库中有此模块的几个版本。<code>os.path</code> 模块始终是适合 Python 运行的操作系统的路径模块，因此可用于本地路径。但是，如果操作的路径 <em>总是</em> 以一种不同的格式显示，那么也可以分别导入和使用各个模块。它们都具有相同的接口：</p>
<ul>
<li><code>posixpath</code> 用于Unix 样式的路径</li>
<li><code>ntpath</code> 用于 Windows 路径</li>
</ul>
<p>在 3.8 版更改: <code>exists()</code>、<code>lexists()</code>、<code>isdir()</code>、<code>isfile()</code>、<code>islink()</code> 和 <code>ismount()</code> 现在遇到系统层面上不可表示的字符或字节的路径时，会返回 <code>False</code>，而不是抛出异常。</p>
<p><code>os.path.abspath</code>(<em>path</em>)</p>
<p>返回路径 <em>path</em> 的绝对路径（标准化的）。在大多数平台上，这等同于用 <code>normpath(join(os.getcwd(), path))</code> 的方式调用 <code>normpath()</code> 函数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.basename</code>(<em>path</em>)</p>
<p>返回路径 <em>path</em> 的基本名称。这是将 <em>path</em> 传入函数 <code>split()</code> 之后，返回的一对值中的第二个元素。请注意，此函数的结果与Unix <strong>basename</strong> 程序不同。<strong>basename</strong> 在 <code>'/foo/bar/'</code> 上返回 <code>'bar'</code>，而 <code>basename()</code> 函数返回一个空字符串 (<code>''</code>)。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.commonpath</code>(<em>paths</em>)</p>
<p>接受包含多个路径的序列 <em>paths*，返回 *paths</em> 的最长公共子路径。如果 <em>paths</em> 同时包含绝对路径和相对路径，或 <em>paths</em> 在不同的驱动器上，或 <em>paths</em> 为空，则抛出 <code>ValueError</code> 异常。与 <code>commonprefix()</code> 不同，本方法返回有效路径。</p>
<p>可用性: Unix, Windows。</p>
<p>3.5 新版功能.</p>
<p>在 3.6 版更改: 接受一个 类路径对象 序列。</p>
<p><code>os.path.commonprefix</code>(<em>list</em>)</p>
<p>接受包含多个路径的 <em>列表*，返回所有路径的最长公共前缀（逐字符比较）。如果 *列表</em> 为空，则返回空字符串 (<code>''</code>)。</p>
<p>注解</p>
<p>此函数是逐字符比较，因此可能返回无效路径。要获取有效路径，参见 <code>commonpath()</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>commonprefix<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'/usr/lib'</span><span class="token punctuation">,</span> <span class="token string">'/usr/local/lib'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">'/usr/l'</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>commonpath<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'/usr/lib'</span><span class="token punctuation">,</span> <span class="token string">'/usr/local/lib'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">'/usr'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.dirname</code>(<em>path</em>)</p>
<p>返回路径 <em>path</em> 的目录名称。这是将 <em>path</em> 传入函数 <code>split()</code> 之后，返回的一对值中的第一个元素。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.exists</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 指向一个已存在的路径或已打开的文件描述符，返回 <code>True</code>。对于失效的符号链接，返回 <code>False</code>。在某些平台上，如果使用 <code>os.stat()</code> 查询到目标文件没有执行权限，即使 <em>path</em> 确实存在，本函数也可能返回 <code>False</code>。</p>
<p>在 3.3 版更改: <em>path</em> 现在可以是一个整数：如果该整数是一个已打开的文件描述符，返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.lexists</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 指向一个已存在的路径，返回 <code>True</code>。对于失效的符号链接，也返回 <code>True</code>。在缺失 <code>os.lstat()</code> 的平台上等同于 <code>exists()</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.expanduser</code>(<em>path</em>)</p>
<p>在 Unix 和 Windows 上，将参数中开头部分的 <code>~</code> 或 <code>~user</code> 替换为当前 <em>用户</em> 的家目录并返回。</p>
<p>在 Unix 上，开头的 <code>~</code> 会被环境变量 <code>HOME</code> 代替，如果变量未设置，则通过内置模块 <code>pwd</code> 在 password 目录中查找当前用户的主目录。以 <code>~user</code> 开头则直接在 password 目录中查找。</p>
<p>在 Windows 上，如果 <code>USERPROFILE</code> 已设置将会被使用，否则 <code>HOMEPATH</code> 和 <code>HOMEDRIVE</code> 将被组合起来使用。 初始的 <code>~user</code> 会通过检查当前用户的家目录中匹配 <code>USERNAME</code> 的最后一部分目录名并执行替换来处理。</p>
<p>如果展开路径失败，或者路径不是以波浪号开头，则路径将保持不变。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>在 3.8 版更改: Windows 不再使用 <code>HOME</code>。</p>
<p><code>os.path.expandvars</code>(<em>path</em>)</p>
<p>输入带有环境变量的路径作为参数，返回展开变量以后的路径。<code>$name</code> 或 <code>${name}</code> 形式的子字符串被环境变量 <em>name</em> 的值替换。格式错误的变量名称和对不存在变量的引用保持不变。</p>
<p>在 Windows 上，除了 <code>$name</code> 和 <code>${name}</code> 外，还可以展开 <code>%name%</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.getatime</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 的最后访问时间。返回值是一个浮点数，为纪元秒数。如果该文件不存在或不可访问，则抛出 <code>OSError</code> 异常。</p>
<p><code>os.path.getmtime</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 的最后修改时间。返回值是一个浮点数，为纪元秒数。如果该文件不存在或不可访问，则抛出 <code>OSError</code> 异常。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.getctime</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 在系统中的 ctime，在有些系统（比如 Unix）上，它是元数据的最后修改时间，其他系统（比如 Windows）上，它是 <em>path</em> 的创建时间。返回值是一个数，为纪元秒数。如果该文件不存在或不可访问，则抛出 <code>OSError</code> 异常。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.getsize</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 的大小，以字节为单位。如果该文件不存在或不可访问，则抛出 <code>OSError</code> 异常。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.isabs</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 是一个绝对路径，则返回 <code>True</code>。在 Unix 上，它就是以斜杠开头，而在 Windows 上，它可以是去掉驱动器号后以斜杠（或反斜杠）开头。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.isfile</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 是 <code>现有的</code> 常规文件，则返回 <code>True</code>。本方法会跟踪符号链接，因此，对于同一路径，<code>islink()</code> 和 <code>isfile()</code> 都可能为 <code>True</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.isdir</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 是 <code>现有的</code> 目录，则返回 <code>True</code>。本方法会跟踪符号链接，因此，对于同一路径，<code>islink()</code> 和 <code>isdir()</code> 都可能为 <code>True</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.islink</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 指向的 <code>现有</code> 目录条目是一个符号链接，则返回 <code>True</code>。如果 Python 运行时不支持符号链接，则总是返回 <code>False</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.ismount</code>(<em>path</em>)</p>
<p>如果路径 <em>path</em> 是 <em>挂载点</em> （文件系统中挂载其他文件系统的点），则返回 <code>True</code>。在 POSIX 上，该函数检查 <em>path</em> 的父目录 <code>*path*/..</code> 是否在与 <em>path</em> 不同的设备上，或者 <code>*path*/..</code> 和 <em>path</em> 是否指向同一设备上的同一 inode（这一检测挂载点的方法适用于所有 Unix 和 POSIX 变体）。本方法不能可靠地检测同一文件系统上的绑定挂载 (bind mount)。在 Windows 上，盘符和共享 UNC 始终是挂载点，对于任何其他路径，将调用 <code>GetVolumePathName</code> 来查看它是否与输入的路径不同。</p>
<p>3.4 新版功能: 支持在 Windows 上检测非根挂载点。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.join</code>(<em>path</em>, <em>\</em>paths*)</p>
<p>智能地拼接一个或多个路径部分。 返回值是 <em>path</em> 和 <em>\</em>paths* 的所有成员的拼接，其中每个非空部分后面都紧跟一个目录分隔符，最后一个部分除外，这意味着如果最后一个部分为空，则结果将以分隔符结尾。 如果某个部分为绝对路径，则之前的所有部分会被丢弃并从绝对路径部分开始继续拼接。</p>
<p>在 Windows 上，遇到绝对路径部分（例如 <code>r'\foo'</code>）时，不会重置盘符。如果某部分路径包含盘符，则会丢弃所有先前的部分，并重置盘符。请注意，由于每个驱动器都有一个“当前目录”，所以 <code>os.path.join("c:", "foo")</code> 表示驱动器 <code>C:</code> 上当前目录的相对路径 (<code>c:foo</code>)，而不是 <code>c:\foo</code>。</p>
<p>在 3.6 版更改: 接受一个 类路径对象 用于 <em>path</em> 和 <em>paths</em> 。</p>
<p><code>os.path.normcase</code>(<em>path</em>)</p>
<p>规范路径的大小写。在 Windows 上，将路径中的所有字符都转换为小写，并将正斜杠转换为反斜杠。在其他操作系统上返回原路径。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.normpath</code>(<em>path</em>)</p>
<blockquote>
<p>通过折叠多余的分隔符和对上级目录的引用来标准化路径名，所以 <code>A//B</code>、<code>A/B/</code>、<code>A/./B</code> 和 <code>A/foo/../B</code> 都会转换成 <code>A/B</code>。这个字符串操作可能会改变带有符号链接的路径的含义。在 Windows 上，本方法将正斜杠转换为反斜杠。要规范大小写，请使用 <code>normcase()</code>。</p>
</blockquote>
<p>注解</p>
<blockquote>
<p>在 POSIX 系统上，根据 <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13" target="_blank" rel="noopener">IEEE Std 1003.1 2013 Edition; 4.13 Pathname Resolution</a>，如果一个路径名称以两个斜杠开始，则开始字符之后的第一个部分将以具体实现所定义的方式来解读，但是超过两个开始字符则将被视为单个字符。</p>
</blockquote>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.realpath</code>(<em>path</em>, <em>**,</em> strict=False*)</p>
<p>返回指定文件的规范路径，消除路径中存在的任何符号链接（如果操作系统支持）。</p>
<p>如果一个路径不存在或是遇到了符号链接循环，并且 <em>strict</em> 为 <code>True</code>，则会引发 <code>OSError</code>。 如果 <em>strict</em> 为 <code>False</code>，则会尽可能地解析路径并添加结果而不检查路径是否存在。</p>
<p>注解</p>
<p>这个函数会模拟操作系统生成规范路径的过程，Windows 与 UNIX 的这个过程在处理链接和后续路径组成部分的交互方式上有所差异。</p>
<p>操作系统 API 会根据需要来规范化路径，因此通常不需要调用此函数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>在 3.8 版更改: 在 Windows 上现在可以正确解析符号链接和交接点 (junction point)。</p>
<p>在 3.10 版更改: 增加了 <em>strict</em> 形参。</p>
<p><code>os.path.relpath</code>(<em>path</em>, <em>start=os.curdir</em>)</p>
<p>返回从当前目录或可选的 <em>start</em> 目录至 <em>path</em> 的相对文件路径。 这只是一个路径计算：不会访问文件系统来确认 <em>path</em> 或 <em>start</em> 是否存在或其性质。 在 Windows 上，当 <em>path</em> 和 <em>start</em> 位于不同驱动器时将引发 <code>ValueError</code>。</p>
<p><em>start</em> 默认为 <code>os.curdir</code>。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.samefile</code>(<em>path1</em>, <em>path2</em>)</p>
<p>如果两个路径都指向相同的文件或目录，则返回 <code>True</code>。这由设备号和 inode 号确定，在任一路径上调用 <code>os.stat()</code> 失败则抛出异常。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.2 版更改: 添加了对 Windows 的支持。</p>
<p>在 3.4 版更改: Windows现在使用与其他所有平台相同的实现。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.sameopenfile</code>(<em>fp1</em>, <em>fp2</em>)</p>
<p>如果文件描述符 <em>fp1</em> 和 <em>fp2</em> 指向相同文件，则返回 <code>True</code>。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.2 版更改: 添加了对 Windows 的支持。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.samestat</code>(<em>stat1</em>, <em>stat2</em>)</p>
<p>如果 stat 元组 <em>stat1</em> 和 <em>stat2</em> 指向相同文件，则返回 <code>True</code>。这些 stat 元组可能是由 <code>os.fstat()</code>、<code>os.lstat()</code> 或 <code>os.stat()</code> 返回的。本函数实现了 <code>samefile()</code> 和 <code>sameopenfile()</code> 底层所使用的比较过程。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.4 版更改: 添加了对 Windows 的支持。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.split</code>(<em>path</em>)</p>
<p>将路径 <em>path</em> 拆分为一对，即 <code>(head, tail)</code>，其中，<em>tail</em> 是路径的最后一部分，而 <em>head</em> 里是除最后部分外的所有内容。<em>tail</em> 部分不会包含斜杠，如果 <em>path</em> 以斜杠结尾，则 <em>tail</em> 将为空。如果 <em>path</em> 中没有斜杠，<em>head</em> 将为空。如果 <em>path</em> 为空，则 <em>head</em> 和 <em>tail</em> 均为空。<em>head</em> 末尾的斜杠会被去掉，除非它是根目录（即它仅包含一个或多个斜杠）。在所有情况下，<code>join(head, tail)</code> 指向的位置都与 <em>path</em> 相同（但字符串可能不同）。另请参见函数 <code>dirname()</code> 和 <code>basename()</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.splitdrive</code>(<em>path</em>)</p>
<p>将路径 <em>path</em> 拆分为一对，即 <code>(drive, tail)</code>，其中 <em>drive</em> 是挂载点或空字符串。在没有驱动器概念的系统上，<em>drive</em> 将始终为空字符串。在所有情况下，<code>drive + tail</code> 都与 <em>path</em> 相同。</p>
<p>在 Windows 上，本方法将路径拆分为驱动器/UNC 根节点和相对路径。</p>
<p>如果路径 path 包含盘符，则 drive 将包含冒号之前的所有内容包括冒号本身:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> splitdrive<span class="token punctuation">(</span><span class="token string">"c:/dir"</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">"c:"</span><span class="token punctuation">,</span> <span class="token string">"/dir"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果路径 path 包含 UNC 路径，则 drive 将包含主机名和 share，直至第四个分隔符但不包括该分隔符:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> splitdrive<span class="token punctuation">(</span><span class="token string">"//host/computer/dir"</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">"//host/computer"</span><span class="token punctuation">,</span> <span class="token string">"/dir"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.splitext</code>(<em>path</em>)</p>
<p>将路径名称 <em>path</em> 拆分为 <code>(root, ext)</code> 对使得 <code>root + ext == path</code>，并且扩展名 <em>ext</em> 为空或以句点打头并最多只包含一个句点。</p>
<p>如果路径 path 不包含扩展名，则 <em>ext</em> 将为 <code>''</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> splitext<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果路径 path 包含扩展名，则 <em>ext</em> 将被设为该扩展名，包括打头的句点。 请注意在其之前的句点将被忽略:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> splitext<span class="token punctuation">(</span><span class="token string">'foo.bar.exe'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'foo.bar'</span><span class="token punctuation">,</span> <span class="token string">'.exe'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>基本名中打头的句点会被忽略:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> splitext<span class="token punctuation">(</span><span class="token string">'.cshrc'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'.cshrc'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<pre><code>os.path.supports_unicode_filenames</code></pre><h2 id="fileinput-—-迭代来自多个输入流的行"><a href="#fileinput-—-迭代来自多个输入流的行" class="headerlink" title="fileinput —- 迭代来自多个输入流的行"></a><code>fileinput</code> —- 迭代来自多个输入流的行</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/fileinput.py" target="_blank" rel="noopener">Lib/fileinput.py</a></p>
<hr>
<p>此模块实现了一个辅助类和一些函数用来快速编写访问标准输入或文件列表的循环。 </p>
<p>典型用法为:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> fileinput
<span class="token keyword">for</span> line <span class="token keyword">in</span> fileinput<span class="token punctuation">.</span>input<span class="token punctuation">(</span>encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    process<span class="token punctuation">(</span>line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>此程序会迭代 <code>sys.argv[1:]</code> 中列出的所有文件内的行，如果列表为空则会使用 <code>sys.stdin</code>。 如果有一个文件名为 <code>'-'</code>，它也会被替换为 <code>sys.stdin</code> 并且可选参数 <em>mode</em> 和 <em>openhook</em> 会被忽略。 要指定替代文件列表，请将其作为第一个参数传给 <code>input()</code>。 也允许使用单个文件。</p>
<p>所有文件都默认以文本模式打开，但你可以通过在调用 <code>input()</code> 或 <code>FileInput</code> 时指定 <em>mode</em> 形参来重载此行为。 如果在打开或读取文件时发生了 I/O 错误，将会引发 <code>OSError</code>。</p>
<p>在 3.3 版更改: 原来会引发 <code>IOError</code>；现在它是 <code>OSError</code> 的别名。</p>
<p>如果 <code>sys.stdin</code> 被使用超过一次，则第二次之后的使用将不返回任何行，除非是被交互式的使用，或都是被显式地重置 (例如使用 <code>sys.stdin.seek(0)</code>)。</p>
<p>空文件打开后将立即被关闭；它们在文件列表中会被注意到的唯一情况只有当最后打开的文件为空的时候。</p>
<p>反回的行不会对换行符做任何处理，这意味着文件中的最后一行可能不带换行符。</p>
<p>You can control how files are opened by providing an opening hook via the <em>openhook</em> parameter to <code>fileinput.input()</code> or <code>FileInput()</code>. The hook must be a function that takes two arguments, <em>filename</em> and <em>mode</em>, and returns an accordingly opened file-like object. If <em>encoding</em> and/or <em>errors</em> are specified, they will be passed to the hook as aditional keyword arguments. This module provides a <code>hook_compressed()</code> to support compressed files.</p>
<p>以下函数是此模块的初始接口：</p>
<p><code>fileinput.input</code>(<em>files=None</em>, <em>inplace=False</em>, <em>backup=’’</em>, <em>**,</em> mode=’r’<em>,</em> openhook=None<em>,</em> encoding=None<em>,</em> errors=None*)</p>
<p>创建一个 <code>FileInput</code> 类的实例。 该实例将被用作此模块中函数的全局状态，并且还将在迭代期间被返回使用。 此函数的形参将被继续传递给 <code>FileInput</code> 类的构造器。</p>
<p><code>FileInput</code> 实例可以在 <code>with</code> 语句中被用作上下文管理器。 在这个例子中，<em>input</em> 在 <code>with</code> 语句结束后将会被关闭，即使发生了异常也是如此:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> fileinput<span class="token punctuation">.</span>input<span class="token punctuation">(</span>files<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'spam.txt'</span><span class="token punctuation">,</span> <span class="token string">'eggs.txt'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>
        process<span class="token punctuation">(</span>line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 3.2 版更改: 可以被用作上下文管理器。</p>
<p>在 3.8 版更改: 关键字形参 <em>mode</em> 和 <em>openhook</em> 现在是仅限关键字形参。</p>
<p>在 3.10 版更改: 增加了仅限关键字形参 <em>encoding</em> 和 <em>errors</em>。</p>
<p>下列函数会使用 <code>fileinput.input()</code> 所创建的全局状态；如果没有活动的状态，则会引发 <code>RuntimeError</code>。</p>
<p><code>fileinput.filename</code>()</p>
<p>返回当前被读取的文件名。 在第一行被读取之前，返回 <code>None</code>。</p>
<p><code>fileinput.fileno</code>()</p>
<p>返回以整数表示的当前文件“文件描述符”。 当未打开文件时（处在第一行和文件之间），返回 <code>-1</code>。</p>
<p><code>fileinput.lineno</code>()</p>
<p>返回已被读取的累计行号。 在第一行被读取之前，返回 <code>0</code>。 在最后一个文件的最后一行被读取之后，返回该行的行号。</p>
<p><code>fileinput.filelineno</code>()</p>
<p>返回当前文件中的行号。 在第一行被读取之前，返回 <code>0</code>。 在最后一个文件的最后一行被读取之后，返回此文件中该行的行号。</p>
<p><code>fileinput.isfirstline</code>()</p>
<p>如果刚读取的行是其所在文件的第一行则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p><code>fileinput.isstdin</code>()</p>
<p>如果最后读取的行来自 <code>sys.stdin</code> 则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p><code>fileinput.nextfile</code>()</p>
<p>关闭当前文件以使下次迭代将从下一个文件（如果存在）读取第一行；不是从该文件读取的行将不会被计入累计行数。 直到下一个文件的第一行被读取之后文件名才会改变。 在第一行被读取之前，此函数将不会生效；它不能被用来跳过第一个文件。 在最后一个文件的最后一行被读取之后，此函数将不再生效。</p>
<p><code>fileinput.close</code>()</p>
<p>关闭序列。</p>
<p>此模块所提供的实现了序列行为的类同样也可用于子类化：</p>
<p><em>class</em> <code>fileinput.FileInput</code>(<em>files=None</em>, <em>inplace=False</em>, <em>backup=’’</em>, <em>**,</em> mode=’r’<em>,</em> openhook=None<em>,</em> encoding=None<em>,</em> errors=None*)</p>
<p>类 <code>FileInput</code> 是一个实现；它的方法 <code>filename()</code>, <code>fileno()</code>, <code>lineno()</code>, <code>filelineno()</code>, <code>isfirstline()</code>, <code>isstdin()</code>, <code>nextfile()</code> 和 <code>close()</code> 对应于此模块中具有相同名称的函数。 此外它还有一个 <code>readline()</code> 方法可返回下一个输入行，以及一个 <code>__getitem__()</code> 方法，该方法实现了序列行为。 这种序列必须以严格的序列顺序来读写；随机读写和 <code>readline()</code> 不可以被混用。</p>
<p>通过 <em>mode</em> 你可以指定要传给 <code>open()</code> 的文件模式。 它必须为 <code>'r'</code>, <code>'rU'</code>, <code>'U'</code> 和 <code>'rb'</code> 中的一个。</p>
<p><em>openhook</em> 如果给出则必须为一个函数，它接受两个参数 <em>filename</em> 和 <em>mode*，并相应地返回一个打开的文件类对象。 你不能同时使用 *inplace</em> 和 <em>openhook</em>。</p>
<p>你可以指定 <em>encoding</em> 和 <em>errors</em> 来将其传给 <code>open()</code> 或 <em>openhook</em>。</p>
<p><code>FileInput</code> 实例可以在 <code>with</code> 语句中被用作上下文管理器。 在这个例子中，<em>input</em> 在 <code>with</code> 语句结束后将会被关闭，即使发生了异常也是如此:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> FileInput<span class="token punctuation">(</span>files<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'spam.txt'</span><span class="token punctuation">,</span> <span class="token string">'eggs.txt'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">as</span> input<span class="token punctuation">:</span>
    process<span class="token punctuation">(</span>input<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.2 版更改: 可以被用作上下文管理器。</p>
<p>3.4 版后已移除: <code>'rU'</code> 和 <code>'U'</code> 模式。</p>
<p>3.8 版后已移除: 对 <code>__getitem__()</code> 方法的支持已弃用。</p>
<p>在 3.8 版更改: 关键字形参 <em>mode</em> 和 <em>openhook</em> 现在是仅限关键字形参。</p>
<p>在 3.10 版更改: 增加了仅限关键字形参 <em>encoding</em> 和 <em>errors</em>。</p>
<p><strong>可选的原地过滤:</strong> 如果传递了关键字参数 <code>inplace=True</code> 给 <code>fileinput.input()</code> 或 <code>FileInput</code> 构造器，则文件会被移至备份文件并将标准输出定向到输入文件（如果已存在与备份文件同名的文件，它将被静默地替换）。 这使得编写一个能够原地重写其输入文件的过滤器成为可能。 如果给出了 <em>backup</em> 形参 (通常形式为 <code>backup='.&lt;some extension&gt;'</code>)，它将指定备份文件的扩展名，并且备份文件会被保留；默认情况下扩展名为 <code>'.bak'</code> 并且它会在输出文件关闭时被删除。 在读取标准输入时原地过滤会被禁用。</p>
<p>此模块提供了以下两种打开文件钩子：</p>
<p><code>fileinput.hook_compressed</code>(<em>filename</em>, <em>mode</em>, <em>**,</em> encoding=None<em>,</em> errors=None*)</p>
<p>使用 <code>gzip</code> 和 <code>bz2</code> 模块透明地打开 gzip 和 bzip2 压缩的文件（通过扩展名 <code>'.gz'</code> 和 <code>'.bz2'</code> 来识别）。 如果文件扩展名不是 <code>'.gz'</code> 或 <code>'.bz2'</code>，文件会以正常方式打开（即使用 <code>open()</code> 并且不带任何解压操作）。</p>
<p><em>encoding</em> 和 <em>errors</em> 值会被传给 <code>io.TextIOWrapper</code> 用于压缩文件以及打开普通文件。</p>
<p>用法示例: <code>fi = fileinput.FileInput(openhook=fileinput.hook_compressed, encoding="utf-8")</code></p>
<p>在 3.10 版更改: 增加了仅限关键字形参 <em>encoding</em> 和 <em>errors</em>。</p>
<p><code>fileinput.hook_encoded</code>(<em>encoding</em>, <em>errors=None</em>)</p>
<p>返回一个通过 <code>open()</code> 打开每个文件的钩子，使用给定的 <em>encoding</em> 和 <em>errors</em> 来读取文件。</p>
<p>使用示例: <code>fi = fileinput.FileInput(openhook=fileinput.hook_encoded("utf-8", "surrogateescape"))</code></p>
<p>在 3.6 版更改: 添加了可选的 <em>errors</em> 形参。</p>
<p>3.10 版后已移除: 此函数已被弃用，因为 <code>input()</code> 和 <code>FileInput</code> 现在有了 <em>encoding</em> 和 <em>errors</em> 形参。</p>
<h2 id="stat-—-解析-stat-结果"><a href="#stat-—-解析-stat-结果" class="headerlink" title="stat —- 解析 stat() 结果"></a><code>stat</code> —- 解析 <code>stat()</code> 结果</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/stat.py" target="_blank" rel="noopener">Lib/stat.py</a></p>
<hr>
<p><code>stat</code> 模块定义了一些用于解析 <code>os.stat()</code>, <code>os.fstat()</code> 和 <code>os.lstat()</code> (如果它们存在) 输出结果的常量和函数。 有关 <code>stat()</code>, <code>fstat()</code> 和 <code>lstat()</code> 调用的完整细节，请参阅你的系统文档。</p>
<p>在 3.4 版更改: stat 模块是通过 C 实现来支持的。</p>
<p><code>stat</code> 模块定义了以下函数来检测特定文件类型：</p>
<p><code>stat.S_ISDIR</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个目录则返回非零值。</p>
<p><code>stat.S_ISCHR</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个字符特殊设备文件则返回非零值。</p>
<p><code>stat.S_ISBLK</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个块特殊设备文件则返回非零值。</p>
<p><code>stat.S_ISREG</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个常规文件则返回非零值。</p>
<p><code>stat.S_ISFIFO</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个 FIFO (命名管道) 则返回非零值。</p>
<p><code>stat.S_ISLNK</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个符号链接则返回非零值。</p>
<p><code>stat.S_ISSOCK</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个套接字则返回非零值。</p>
<p><code>stat.S_ISDOOR</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个门则返回非零值。</p>
<p>3.4 新版功能.</p>
<p><code>stat.S_ISPORT</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个事件端口则返回非零值。</p>
<p>3.4 新版功能.</p>
<p><code>stat.S_ISWHT</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个白输出则返回非零值。</p>
<p>3.4 新版功能.</p>
<p>定义了两个附加函数用于对文件模式进行更一般化的操作：</p>
<p><code>stat.S_IMODE</code>(<em>mode</em>)</p>
<p>返回文件模式中可由 <code>os.chmod()</code> 进行设置的部分 —- 即文件的 permission 位，加上 sticky 位、set-group-id 以及 set-user-id 位（在支持这些部分的系统上）。</p>
<p><code>stat.S_IFMT</code>(<em>mode</em>)</p>
<p>返回文件模式中描述文件类型的部分（供上面的 <code>S_IS*()</code> 函数使用）。</p>
<p>通常，你应当使用 <code>os.path.is*()</code> 函数来检测文件的类型；这里提供的函数则适用于当你要对同一文件执行多项检测并且希望避免每项检测的 <code>stat()</code> 系统调用开销的情况。 这些函数也适用于检测有关未被 <code>os.path</code> 处理的信息，例如检测块和字符设备等。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token punctuation">,</span> sys
<span class="token keyword">from</span> stat <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token keyword">def</span> <span class="token function">walktree</span><span class="token punctuation">(</span>top<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''recursively descend the directory tree rooted at top,
       calling the callback function for each regular file'''</span>
    <span class="token keyword">for</span> f <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>top<span class="token punctuation">)</span><span class="token punctuation">:</span>
        pathname <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>top<span class="token punctuation">,</span> f<span class="token punctuation">)</span>
        mode <span class="token operator">=</span> os<span class="token punctuation">.</span>stat<span class="token punctuation">(</span>pathname<span class="token punctuation">)</span><span class="token punctuation">.</span>st_mode
        <span class="token keyword">if</span> S_ISDIR<span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># It's a directory, recurse into it</span>
            walktree<span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> S_ISREG<span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># It's a file, call the callback function</span>
            callback<span class="token punctuation">(</span>pathname<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># Unknown file type, print a message</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Skipping %s'</span> <span class="token operator">%</span> pathname<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">visitfile</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'visiting'</span><span class="token punctuation">,</span> file<span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    walktree<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> visitfile<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外还提供了一个附加的辅助函数用来将文件模式转换为人类易读的字符串：</p>
<p><code>stat.filemode</code>(<em>mode</em>)</p>
<p>将文件模式转换为 ‘-rwxrwxrwx’ 形式的字符串。</p>
<p>3.3 新版功能.</p>
<p>在 3.4 版更改: 此函数支持 <code>S_IFDOOR</code>, <code>S_IFPORT</code> and <code>S_IFWHT</code>。</p>
<p>以下所有变量是一些简单的符号索引，用于访问 <code>os.stat()</code>, <code>os.fstat()</code> 或 <code>os.lstat()</code> 所返回的 10 条目元组。</p>
<pre><code>stat.ST_MODE</code></pre><p>inode 保护模式。</p>
<pre><code>stat.ST_INO</code></pre><p>Inode 号</p>
<pre><code>stat.ST_DEV</code></pre><p>Inode 所在的设备。</p>
<pre><code>stat.ST_NLINK</code></pre><p>Inode 拥有的链接数量。</p>
<pre><code>stat.ST_UID</code></pre><p>所有者的用户 ID。</p>
<pre><code>stat.ST_GID</code></pre><p>所有者的用户组ID。</p>
<pre><code>stat.ST_SIZE</code></pre><p>以字节为单位的普通文件大小；对于某些特殊文件则是所等待的数据量。</p>
<pre><code>stat.ST_ATIME</code></pre><p>上次访问的时间。</p>
<pre><code>stat.ST_MTIME</code></pre><p>上次修改的时间。</p>
<pre><code>stat.ST_CTIME</code></pre><p>操作系统所报告的 “ctime”。 在某些系统上（例如 Unix）是元数据的最后修改时间，而在其他系统上（例如 Windows）则是创建时间（请参阅系统平台的文档了解相关细节）。</p>
<p>对于“文件大小”的解析可因文件类型的不同而变化。 对于普通文件就是文件的字节数。 对于大部分种类的 Unix（特别包括 Linux）的 FIFO 和套接字来说，“大小”则是指在调用 <code>os.stat()</code>, <code>os.fstat()</code> 或 <code>os.lstat()</code> 时等待读取的字节数；这在某些时候很有用处，特别是在一个非阻塞的打开后轮询这些特殊文件中的一个时。 其他字符和块设备的文件大小字段的含义还会有更多变化，具体取决于底层系统调用的实现方式。</p>
<p>以下变量定义了在 <code>ST_MODE</code> 字段中使用的旗标。</p>
<p>使用上面的函数会比使用第一组旗标更容易移植：</p>
<pre><code>stat.S_IFSOCK</code></pre><p>套接字。</p>
<pre><code>stat.S_IFLNK</code></pre><p>符号链接。</p>
<pre><code>stat.S_IFREG</code></pre><p>普通文件。</p>
<pre><code>stat.S_IFBLK</code></pre><p>块设备。</p>
<pre><code>stat.S_IFDIR</code></pre><p>目录。</p>
<pre><code>stat.S_IFCHR</code></pre><p>字符设备。</p>
<pre><code>stat.S_IFIFO</code></pre><p>先进先出。</p>
<pre><code>stat.S_IFDOOR</code></pre><p>门。</p>
<p>3.4 新版功能.</p>
<pre><code>stat.S_IFPORT</code></pre><p>事件端口。</p>
<p>3.4 新版功能.</p>
<pre><code>stat.S_IFWHT</code></pre><p>白输出。</p>
<p>3.4 新版功能.</p>
<p>注解</p>
<p><code>S_IFDOOR</code>, <code>S_IFPORT</code> or <code>S_IFWHT</code> 等文件类型在不受系统平台支持时会被定义为 0。</p>
<p>以下旗标还可以 <code>os.chmod()</code> 的在 <em>mode</em> 参数中使用：</p>
<pre><code>stat.S_ISUID</code></pre><p>设置 UID 位。</p>
<pre><code>stat.S_ISGID</code></pre><p>设置分组 ID 位。 这个位有几种特殊用途。 对于目录它表示该目录将使用 BSD 语义：在其中创建的文件将从目录继承其分组 ID，而不是从创建进程的有效分组 ID 继承，并且在其中创建的目录也将设置 <code>S_ISGID</code> 位。 对于没有设置分组执行位 (<code>S_IXGRP</code>) 的文件，设置分组 ID 位表示强制性文件/记录锁定。</p>
<pre><code>stat.S_ISVTX</code></pre><p>固定位。 当对目录设置该位时则意味着此目录中的文件只能由文件所有者、目录所有者或特权进程来重命名或删除。</p>
<pre><code>stat.S_IRWXU</code></pre><p>文件所有者权限的掩码。</p>
<pre><code>stat.S_IRUSR</code></pre><p>所有者具有读取权限。</p>
<pre><code>stat.S_IWUSR</code></pre><p>所有者具有写入权限。</p>
<pre><code>stat.S_IXUSR</code></pre><p>所有者具有执行权限。</p>
<pre><code>stat.S_IRWXG</code></pre><p>组权限的掩码。</p>
<pre><code>stat.S_IRGRP</code></pre><p>组具有读取权限。</p>
<pre><code>stat.S_IWGRP</code></pre><p>组具有写入权限。</p>
<pre><code>stat.S_IXGRP</code></pre><p>组具有执行权限。</p>
<pre><code>stat.S_IRWXO</code></pre><p>其他人（不在组中）的权限掩码。</p>
<pre><code>stat.S_IROTH</code></pre><p>其他人具有读取权限。</p>
<pre><code>stat.S_IWOTH</code></pre><p>其他人具有写入权限。</p>
<pre><code>stat.S_IXOTH</code></pre><p>其他人具有执行权限。</p>
<pre><code>stat.S_ENFMT</code></pre><p>System V 执行文件锁定。 此旗标是与 <code>S_ISGID</code> 共享的：文件/记录锁定会针对未设置分组执行位 (<code>S_IXGRP</code>) 的文件强制执行。</p>
<pre><code>stat.S_IREAD</code></pre><p>Unix V7 中 <code>S_IRUSR</code> 的同义词。</p>
<pre><code>stat.S_IWRITE</code></pre><p>Unix V7 中 <code>S_IWUSR</code> 的同义词。</p>
<pre><code>stat.S_IEXEC</code></pre><p>Unix V7 中 <code>S_IXUSR</code> 的同义词。</p>
<p>以下旗标可以在 <code>os.chflags()</code> 的 <em>flags</em> 参数中使用：</p>
<pre><code>stat.UF_NODUMP</code></pre><p>不要转储文件。</p>
<pre><code>stat.UF_IMMUTABLE</code></pre><p>文件不能被更改。</p>
<pre><code>stat.UF_APPEND</code></pre><p>文件只能被附加。</p>
<pre><code>stat.UF_OPAQUE</code></pre><p>当通过联合堆栈查看时，目录是不透明的。</p>
<pre><code>stat.UF_NOUNLINK</code></pre><p>文件不能重命名或删除。</p>
<pre><code>stat.UF_COMPRESSED</code></pre><p>The file is stored compressed (macOS 10.6+).</p>
<pre><code>stat.UF_HIDDEN</code></pre><p>The file should not be displayed in a GUI (macOS 10.5+).</p>
<pre><code>stat.SF_ARCHIVED</code></pre><p>文件可能已存档。</p>
<pre><code>stat.SF_IMMUTABLE</code></pre><p>文件不能被更改。</p>
<pre><code>stat.SF_APPEND</code></pre><p>文件只能被附加。</p>
<pre><code>stat.SF_NOUNLINK</code></pre><p>文件不能重命名或删除。</p>
<pre><code>stat.SF_SNAPSHOT</code></pre><p>文件有一个快照文件</p>
<p>See the <em>BSD or macOS systems man page *<a href="https://manpages.debian.org/chflags(2)" target="_blank" rel="noopener">chflags(2)</a></em> for more information.</p>
<p>在 Windows 上，以下文件属性常量可被用来检测 <code>os.stat()</code> 所返回的 <code>st_file_attributes</code> 成员中的位。 请参阅 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/gg258117.aspx" target="_blank" rel="noopener">Windows API 文档</a> 了解有关这些常量含义的详情。</p>
<pre class="line-numbers language-python"><code class="language-python">stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_ARCHIVE
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_COMPRESSED
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_DEVICE
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_DIRECTORY
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_ENCRYPTED
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_HIDDEN
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_INTEGRITY_STREAM
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_NORMAL
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_NO_SCRUB_DATA
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_OFFLINE
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_READONLY
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_REPARSE_POINT
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_SPARSE_FILE
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_SYSTEM
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_TEMPORARY
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_VIRTUAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p>在 Windows 上，以下常量可被用来与 <code>os.lstat()</code> 所返回的 <code>st_reparse_tag</code> 成员进行比较。 这些是最主要的常量，而不是详尽的清单。</p>
<pre class="line-numbers language-python"><code class="language-python">stat<span class="token punctuation">.</span>IO_REPARSE_TAG_SYMLINK
stat<span class="token punctuation">.</span>IO_REPARSE_TAG_MOUNT_POINT
stat<span class="token punctuation">.</span>IO_REPARSE_TAG_APPEXECLINK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3.8 新版功能.</p>
<h2 id="filecmp-—-文件及目录的比较"><a href="#filecmp-—-文件及目录的比较" class="headerlink" title="filecmp —- 文件及目录的比较"></a><code>filecmp</code> —- 文件及目录的比较</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/filecmp.py" target="_blank" rel="noopener">Lib/filecmp.py</a></p>
<hr>
<p><code>filecmp</code> 模块定义了用于比较文件及目录的函数，并且可以选取多种关于时间和准确性的折衷方案。</p>
<p><code>filecmp</code> 模块定义了如下函数：</p>
<p><code>filecmp.cmp</code>(<em>f1</em>, <em>f2</em>, <em>shallow=True</em>)</p>
<p>比较名为 <em>f1</em> 和 <em>f2</em> 的文件，如果它们似乎相等则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p>如果 <em>shallow</em> 为真值且两个文件的 <code>os.stat()</code> 签名信息（文件类型、大小和修改时间）一致，则文件会被视为相同。</p>
<p>在其他情况下，如果文件大小或内容不同则它们会被视为不同。</p>
<p>需要注意，没有外部程序被该函数调用，这赋予了该函数可移植性与效率。</p>
<p>该函数会缓存过去的比较及其结果，且在文件的 <code>os.stat()</code> 信息变化后缓存条目失效。所有的缓存可以通过使用 <code>clear_cache()</code> 来清除。</p>
<p><code>filecmp.cmpfiles</code>(<em>dir1</em>, <em>dir2</em>, <em>common</em>, <em>shallow=True</em>)</p>
<p>比较在两个目录 <em>dir1</em> 和 <em>dir2</em> 中，由 <em>common</em> 所确定名称的文件。</p>
<p>返回三组文件名列表： <em>match</em>, <em>mismatch</em>, <em>errors</em> 。 <em>match</em> 含有相匹配的文件， <em>mismatch</em> 含有那些不匹配的，然后 <em>errors</em> 列出那些未被比较文件的名称。如果文件不存在于两目录中的任一个，或者用户缺少读取它们的权限，又或者因为其他的一些原因而无法比较，那么这些文件将会被列在 <em>errors</em> 中。</p>
<p>参数 <em>shallow</em> 具有同 <code>filecmp.cmp()</code> 一致的含义与默认值。</p>
<p>例如， <code>cmpfiles('a', 'b', ['c', 'd/e'])</code> 将会比较 <code>a/c</code> 与 <code>b/c</code> 以及 <code>a/d/e</code> 与 <code>b/d/e</code> 。 <code>'c'</code> 和 <code>'d/e'</code> 将会各自出现在返回的三个列表里的某一个列表中。</p>
<p><code>filecmp.clear_cache</code>()</p>
<p>清除 filecmp 缓存。如果一个文件过快地修改，以至于超过底层文件系统记录修改时间的精度，那么该函数可能有助于比较该类文件。</p>
<p>3.4 新版功能.</p>
<h2 id="dircmp-类"><a href="#dircmp-类" class="headerlink" title="dircmp 类"></a><code>dircmp</code> 类</h2><p><em>class</em> <code>filecmp.dircmp</code>(<em>a</em>, <em>b</em>, <em>ignore=None</em>, <em>hide=None</em>)</p>
<p>创建一个用于比较目录 <em>a</em> 和 <em>b</em> 的新的目录比较对象。 <em>ignore</em> 是需要忽略的文件名列表，且默认为 <code>filecmp.DEFAULT_IGNORES</code> 。 <em>hide</em> 是需要隐藏的文件名列表，且默认为 <code>[os.curdir, os.pardir]</code> 。</p>
<p><code>dircmp</code> 类如 <code>filecmp.cmp()</code> 中所描述的那样对文件进行 <em>shallow</em> 比较。</p>
<p><code>dircmp</code> 类提供以下方法：</p>
<ul>
<li><p><code>report</code>()</p>
<p>将 <em>a</em> 与 <em>b</em> 之间的比较结果打印（到 <code>sys.stdout</code> ）。</p>
</li>
<li><p><code>report_partial_closure</code>()</p>
<p>打印 <em>a</em> 与 <em>b</em> 及共同直接子目录的比较结果。</p>
</li>
<li><p><code>report_full_closure</code>()</p>
<p>打印 <em>a</em> 与 <em>b</em> 及共同子目录比较结果（递归地）。</p>
</li>
</ul>
<p><code>dircmp</code> 类提供了一些有趣的属性，用以得到关于参与比较的目录树的各种信息。</p>
<p>需要注意，通过 <code>__getattr__()</code> 钩子，所有的属性将会惰性求值，因此如果只使用那些计算简便的属性，将不会有速度损失。</p>
<ul>
<li><p><code>left</code></p>
<p>目录 <em>a</em> 。</p>
</li>
<li><p><code>right</code></p>
<p>目录 <em>b</em> 。</p>
</li>
<li><p><code>left_list</code></p>
<p>经 <em>hide</em> 和 <em>ignore</em> 过滤，目录 <em>a</em> 中的文件与子目录。</p>
</li>
<li><p><code>right_list</code></p>
<p>经 <em>hide</em> 和 <em>ignore</em> 过滤，目录 <em>b</em> 中的文件与子目录。</p>
</li>
<li><p><code>common</code></p>
<p>同时存在于目录 <em>a</em> 和 <em>b</em> 中的文件和子目录。</p>
</li>
<li><p><code>left_only</code></p>
<p>仅在目录 <em>a</em> 中的文件和子目录。</p>
</li>
<li><p><code>right_only</code></p>
<p>仅在目录 <em>b</em> 中的文件和子目录。</p>
</li>
<li><p><code>common_dirs</code></p>
<p>同时存在于目录 <em>a</em> 和 <em>b</em> 中的子目录。</p>
</li>
<li><p><code>common_files</code></p>
<p>同时存在于目录 <em>a</em> 和 <em>b</em> 中的文件。</p>
</li>
<li><p><code>common_funny</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中类型不同的名字，或者那些 <code>os.stat()</code> 报告错误的名字。</p>
</li>
<li><p><code>same_files</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中，使用类的文件比较操作符判定相等的文件。</p>
</li>
<li><p><code>diff_files</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中，根据类的文件比较操作符判定内容不等的文件。</p>
</li>
<li><p><code>funny_files</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中无法比较的文件。</p>
</li>
<li><p><code>subdirs</code></p>
<p>一个将 <code>common_dirs</code> 中的名称映射到 <code>dircmp</code> 实例（或者 MyDirCmp 实例，如果该实例类型为 <code>dircmp</code> 的子类 MyDirCmp 的话）的字典。</p>
<p>在 3.10 版更改: 在之前版本中字典条目总是为 <code>dircmp</code> 实例。 现在条目将与 <em>self</em> 的类型相同，如果 <em>self</em> 为 <code>dircmp</code> 的子类的话。</p>
</li>
</ul>
<pre><code>filecmp.DEFAULT_IGNORES</code></pre><p>3.4 新版功能.</p>
<p>默认被 <code>dircmp</code> 忽略的目录列表。</p>
<p>下面是一个简单的例子，使用 <code>subdirs</code> 属性递归搜索两个目录以显示公共差异文件：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> filecmp <span class="token keyword">import</span> dircmp
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">print_diff_files</span><span class="token punctuation">(</span>dcmp<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> name <span class="token keyword">in</span> dcmp<span class="token punctuation">.</span>diff_files<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"diff_file %s found in %s and %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> dcmp<span class="token punctuation">.</span>left<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>               dcmp<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> sub_dcmp <span class="token keyword">in</span> dcmp<span class="token punctuation">.</span>subdirs<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         print_diff_files<span class="token punctuation">(</span>sub_dcmp<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> dcmp <span class="token operator">=</span> dircmp<span class="token punctuation">(</span><span class="token string">'dir1'</span><span class="token punctuation">,</span> <span class="token string">'dir2'</span><span class="token punctuation">)</span> 
<span class="token operator">>></span><span class="token operator">></span> print_diff_files<span class="token punctuation">(</span>dcmp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="tempfile-—-生成临时文件和目录"><a href="#tempfile-—-生成临时文件和目录" class="headerlink" title="tempfile —- 生成临时文件和目录"></a><code>tempfile</code> —- 生成临时文件和目录</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/tempfile.py" target="_blank" rel="noopener">Lib/tempfile.py</a></p>
<hr>
<p>该模块用于创建临时文件和目录，它可以跨平台使用。<code>TemporaryFile</code>、<code>NamedTemporaryFile</code>、<code>TemporaryDirectory</code> 和 <code>SpooledTemporaryFile</code> 是带有自动清理功能的高级接口，可用作上下文管理器。<code>mkstemp()</code> 和 <code>mkdtemp()</code> 是低级函数，使用完毕需手动清理。</p>
<p>所有由用户调用的函数和构造函数都带有参数，这些参数可以设置临时文件和临时目录的路径和名称。该模块生成的文件名包括一串随机字符，在公共的临时目录中，这些字符可以让创建文件更加安全。为了保持向后兼容性，参数的顺序有些奇怪。所以为了代码清晰，建议使用关键字参数。</p>
<p>这个模块定义了以下内容供用户调用：</p>
<p><code>tempfile.TemporaryFile</code>(<em>mode=’w+b’</em>, <em>buffering=- 1</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>**,</em> errors=None*)</p>
<p>返回一个 file-like object （文件类对象）作为临时存储区域。创建该文件使用了与 <code>mkstemp()</code> 相同的安全规则。它将在关闭后立即销毁（包括垃圾回收机制关闭该对象时）。在 Unix 下，该文件在目录中的条目根本不创建，或者创建文件后立即就被删除了，其他平台不支持此功能。您的代码不应依赖使用此功能创建的临时文件名称，因为它在文件系统中的名称可能是可见的，也可能是不可见的。</p>
<p>生成的对象可以用作上下文管理器。完成上下文或销毁临时文件对象后，临时文件将从文件系统中删除。</p>
<p><em>mode</em> 参数默认值为 <code>'w+b'</code>，所以创建的文件不用关闭，就可以读取或写入。因为用的是二进制模式，所以无论存的是什么数据，它在所有平台上都表现一致。<em>buffering<em>、</em>encoding<em>、</em>errors</em> 和 <em>newline</em> 的含义与 <code>open()</code> 中的相同。</p>
<p>参数 <em>dir<em>、</em>prefix</em> 和 <em>suffix</em> 的含义和默认值都与它们在 <code>mkstemp()</code> 中的相同。</p>
<p>在 POSIX 平台上，它返回的对象是真实的文件对象。在其他平台上，它是一个文件类对象 (file-like object)，它的 <code>file</code> 属性是底层的真实文件对象。</p>
<p>如果可用，则使用 <code>os.O_TMPFILE</code> 标志（仅限于 Linux，需要 3.11 及更高版本的内核）。</p>
<p>引发一个 <code>tempfile.mkstemp</code> 审计事件，附带参数 <code>fullpath</code>。</p>
<p>在 3.5 版更改: 如果可用，现在用的是 <code>os.O_TMPFILE</code> 标志。</p>
<p>在 3.8 版更改: 添加了 <em>errors</em> 参数。</p>
<p><code>tempfile.NamedTemporaryFile</code>(<em>mode=’w+b’</em>, <em>buffering=- 1</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>delete=True</em>, <em>**,</em> errors=None*)</p>
<p>此函数执行的操作与 <code>TemporaryFile()</code> 完全相同，但确保了该临时文件在文件系统中具有可见的名称（在 Unix 上表现为目录条目不取消链接）。从返回的文件类对象的 <code>name</code> 属性中可以检索到文件名。在临时文件仍打开时，是否允许用文件名第二次打开文件，在各个平台上是不同的（在 Unix 上可以，但在 Windows NT 或更高版本上不行）。如果 <em>delete</em> 为 true（默认值），则文件会在关闭后立即被删除。该函数返回的对象始终是文件类对象 (file-like object)，它的 <code>file</code> 属性是底层的真实文件对象。文件类对象可以像普通文件一样在 <code>with</code> 语句中使用。</p>
<p>引发一个 <code>tempfile.mkstemp</code> 审计事件，附带参数 <code>fullpath</code>。</p>
<p>在 3.8 版更改: 添加了 <em>errors</em> 参数。</p>
<p><code>tempfile.SpooledTemporaryFile</code>(<em>max_size=0</em>, <em>mode=’w+b’</em>, <em>buffering=- 1</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>**,</em> errors=None*)</p>
<p>此函数执行的操作与 <code>TemporaryFile()</code> 完全相同，但会将数据缓存在内存中，直到文件大小超过 <em>max_size</em>，或调用文件的 <code>fileno()</code> 方法为止，此时数据会被写入磁盘，并且写入操作与 <code>TemporaryFile()</code> 相同。</p>
<p>此函数生成的文件对象有一个额外的方法——<code>rollover()</code>，可以忽略文件大小，让文件立即写入磁盘。</p>
<p>返回的对象是文件类对象 (file-like object)，它的 <code>_file</code> 属性是 <code>io.BytesIO</code> 或 <code>io.TextIOWrapper</code> 对象（取决于指定的是二进制模式还是文本模式）或真实的文件对象（取决于是否已调用 <code>rollover()</code>）。文件类对象可以像普通文件一样在 <code>with</code> 语句中使用。</p>
<p>在 3.3 版更改: 现在，文件的 truncate 方法可接受一个 <code>size</code> 参数。</p>
<p>在 3.8 版更改: 添加了 <em>errors</em> 参数。</p>
<p><code>tempfile.TemporaryDirectory</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>ignore_cleanup_errors=False</em>)</p>
<p>此函数会使用与 <code>mkdtemp()</code> 相同的规则安全地创建一个临时目录。 结果对象可被用作上下文管理器。 在完成上下文或销毁临时目录对象时，新创建的临时目录及其所有内容会从文件系统中被移除。</p>
<p>可以从返回对象的 <code>name</code> 属性中找到临时目录的名称。当返回的对象用作上下文管理器时，这个 <code>name</code> 会作为 <code>with</code> 语句中 <code>as</code> 子句的目标（如果有 as 的话）。</p>
<p>此目录可通过调用 <code>cleanup()</code> 方法来显式地清理。 如果 <em>ignore_cleanup_errors</em> 为真值，则在显式或隐式清理（例如在 Windows 上 <code>PermissionError</code> 移除打开的文件）期间出现的未处理异常将被忽略，并且剩余的可移除条目会被“尽可能”地删除。 在其他情况下，错误将在任何上下文清理发生时被引发 (<code>cleanup()</code> 调用、退出上下文管理器、对象被作为垃圾回收或解释器关闭等)。</p>
<p>引发一个 <code>tempfile.mkdtemp</code> 审计事件，附带参数 <code>fullpath</code>。</p>
<p>3.2 新版功能.</p>
<p>在 3.10 版更改: 添加了 <em>ignore_cleanup_errors</em> 形参。</p>
<p><code>tempfile.mkstemp</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>text=False</em>)</p>
<p>以最安全的方式创建一个临时文件。假设所在平台正确实现了 <code>os.open()</code> 的 <code>os.O_EXCL</code> 标志，则创建文件时不会有竞争的情况。该文件只能由创建者读写，如果所在平台用权限位来标记文件是否可执行，那么没有人有执行权。文件描述符不会过继给子进程。</p>
<p>与 <code>TemporaryFile()</code> 不同，<code>mkstemp()</code> 用户用完临时文件后需要自行将其删除。</p>
<p>如果 <em>suffix</em> 不是 <code>None</code> 则文件名将以该后缀结尾，是 <code>None</code> 则没有后缀。<code>mkstemp()</code> 不会在文件名和后缀之间加点，如果需要加一个点号，请将其放在 <em>suffix</em> 的开头。</p>
<p>如果 <em>prefix</em> 不是 <code>None</code>，则文件名将以该前缀开头，是 <code>None</code> 则使用默认前缀。默认前缀是 <code>gettempprefix()</code> 或 <code>gettempprefixb()</code> 函数的返回值（自动调用合适的函数）。</p>
<p>如果 <em>dir</em> 不为 <code>None</code>，则在指定的目录创建文件，是 <code>None</code> 则使用默认目录。默认目录是从一个列表中选择出来的，这个列表不同平台不一样，但是用户可以设置 <em>TMPDIR<em>、</em>TEMP</em> 或 <em>TMP</em> 环境变量来设置目录的位置。因此，不能保证生成的临时文件路径很规范，比如，通过 <code>os.popen()</code> 将路径传递给外部命令时仍需要加引号。</p>
<p>如果 <em>suffix<em>、</em>prefix</em> 和 <em>dir</em> 中的任何一个不是 <code>None</code>，就要保证它们是同一数据类型。如果它们是 bytes，则返回的名称的类型就是 bytes 而不是 str。如果确实要用默认参数，但又想要返回值是 bytes 类型，请传入 <code>suffix=b''</code>。</p>
<p>如果指定了 <em>text</em> 且为真值，文件会以文本模式打开。 否则，文件（默认）会以二进制模式打开。</p>
<p><code>mkstemp()</code> 返回一个元组，元组中第一个元素是句柄，它是一个系统级句柄，指向一个打开的文件（等同于 <code>os.open()</code> 的返回值），第二元素是该文件的绝对路径。</p>
<p>引发一个 <code>tempfile.mkstemp</code> 审计事件，附带参数 <code>fullpath</code>。</p>
<p>在 3.5 版更改: 现在，<em>suffix<em>、</em>prefix</em> 和 <em>dir</em> 可以以 bytes 类型按顺序提供，以获得 bytes 类型的返回值。之前只允许使用 str。<em>suffix</em> 和 <em>prefix</em> 现在可以接受 <code>None</code>，并且默认为 <code>None</code> 以使用合适的默认值。</p>
<p>在 3.6 版更改: <em>dir</em> 参数现在可接受一个路径类对象 (path-like object)。</p>
<p><code>tempfile.mkdtemp</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>)</p>
<p>以最安全的方式创建一个临时目录，创建该目录时不会有竞争的情况。该目录只能由创建者读取、写入和搜索。</p>
<p><code>mkdtemp()</code> 用户用完临时目录后需要自行将其删除。</p>
<p><em>prefix<em>、</em>suffix</em> 和 <em>dir</em> 的含义与它们在 <code>mkstemp()</code> 中的相同。</p>
<p><code>mkdtemp()</code> 返回新目录的绝对路径。</p>
<p>引发一个 <code>tempfile.mkdtemp</code> 审计事件，附带参数 <code>fullpath</code>。</p>
<p>在 3.5 版更改: 现在，<em>suffix<em>、</em>prefix</em> 和 <em>dir</em> 可以以 bytes 类型按顺序提供，以获得 bytes 类型的返回值。之前只允许使用 str。<em>suffix</em> 和 <em>prefix</em> 现在可以接受 <code>None</code>，并且默认为 <code>None</code> 以使用合适的默认值。</p>
<p>在 3.6 版更改: <em>dir</em> 参数现在可接受一个路径类对象 (path-like object)。</p>
<p><code>tempfile.gettempdir</code>()</p>
<p>返回放置临时文件的目录的名称。这个方法的返回值就是本模块所有函数的 <em>dir</em> 参数的默认值。</p>
<p>Python 搜索标准目录列表，以找到调用者可以在其中创建文件的目录。这个列表是：</p>
<ol>
<li><code>TMPDIR</code> 环境变量指向的目录。</li>
<li><code>TEMP</code> 环境变量指向的目录。</li>
<li><code>TMP</code> 环境变量指向的目录。</li>
<li>与平台相关的位置：<ul>
<li>在 Windows 上，依次为 <code>C:\TEMP</code>、<code>C:\TMP</code>、<code>\TEMP</code> 和 <code>\TMP</code>。</li>
<li>在所有其他平台上，依次为 <code>/tmp</code>、<code>/var/tmp</code> 和 <code>/usr/tmp</code>。</li>
</ul>
</li>
<li>不得已时，使用当前工作目录。</li>
</ol>
<p>在 3.10 版更改: 总是返回一个字符串。 在之前的版本中它会返回任意 <code>tempdir</code> 值而不考虑它的类型，只要它不为 <code>None</code>。</p>
<p><code>tempfile.gettempdirb</code>()</p>
<p>与 <code>gettempdir()</code> 相同，但返回值为字节类型。</p>
<p>3.5 新版功能.</p>
<p><code>tempfile.gettempprefix</code>()</p>
<p>返回用于创建临时文件的文件名前缀，它不包含目录部分。</p>
<p><code>tempfile.gettempprefixb</code>()</p>
<p>与 <code>gettempprefix()</code> 相同，但返回值为字节类型。</p>
<p>3.5 新版功能.</p>
<p>本模块使用一个全局变量来存储由 <code>gettempdir()</code> 返回的临时文件使用的目录路径。 它可被直接设置以覆盖选择过程，但不建议这样做。 本模块中的所有函数都接受一个 <em>dir</em> 参数，它可被用于指定目录。 这是不会通过改变全局 API 行为对其他无准备代码造成影响的推荐做法。</p>
<pre><code>tempfile.tempdir</code></pre><p>当设为 <code>None</code> 以外的值时，此变量会为本模块中定义的函数的 <em>dir</em> 参数定义默认值，包括确定其类型为字节串还是字符串。 它不可以为 path-like object。</p>
<p>如果在调用除 <code>gettempprefix()</code> 外的上述任何函数时 <code>tempdir</code> 为 <code>None</code> (默认值) 则它会按照 <code>gettempdir()</code> 中所描述的算法来初始化。</p>
<p>注解</p>
<p>请注意如果你将 <code>tempdir</code> 设为字节串值，会有一个麻烦的副作用: <code>mkstemp()</code> 和 <code>mkdtemp()</code> 的全局默认返回类型会在没有显式提供字符串类型的when no explicit <code>prefix</code>, <code>suffix</code> 或 <code>dir</code> 的时候被改为字节串。 请不要编写预期或依赖于此入围的代码。 这个笨拙行为是为了保持与历史实现的兼容性。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下是 <code>tempfile</code> 模块典型用法的一些示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> tempfile
<span class="token comment" spellcheck="true"># create a temporary file and write some data to it</span>
<span class="token operator">>></span><span class="token operator">></span> fp <span class="token operator">=</span> tempfile<span class="token punctuation">.</span>TemporaryFile<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> fp<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">'Hello world!'</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># read data from file</span>
<span class="token operator">>></span><span class="token operator">></span> fp<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> fp<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'Hello world!'</span>
<span class="token comment" spellcheck="true"># close the file, it will be removed</span>
<span class="token operator">>></span><span class="token operator">></span> fp<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># create a temporary file using a context manager</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> tempfile<span class="token punctuation">.</span>TemporaryFile<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     fp<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">'Hello world!'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     fp<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     fp<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'Hello world!'</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token comment" spellcheck="true"># file is now closed and removed</span>
<span class="token comment" spellcheck="true"># create a temporary directory using the context manager</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> tempfile<span class="token punctuation">.</span>TemporaryDirectory<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tmpdirname<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'created temporary directory'</span><span class="token punctuation">,</span> tmpdirname<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token comment" spellcheck="true"># directory and contents have been removed</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="已弃用的函数和变量"><a href="#已弃用的函数和变量" class="headerlink" title="已弃用的函数和变量"></a>已弃用的函数和变量</h3><p>创建临时文件有一种历史方法，首先使用 <code>mktemp()</code> 函数生成一个文件名，然后使用该文件名创建文件。不幸的是，这是不安全的，因为在调用 <code>mktemp()</code> 与随后尝试创建文件的进程之间的时间里，其他进程可能会使用该名称创建文件。解决方案是将两个步骤结合起来，立即创建文件。这个方案目前被 <code>mkstemp()</code> 和上述其他函数所采用。</p>
<p><code>tempfile.mktemp</code>(<em>suffix=’’</em>, <em>prefix=’tmp’</em>, <em>dir=None</em>)</p>
<p>2.3 版后已移除: 使用 <code>mkstemp()</code> 来代替。</p>
<p>返回一个绝对路径，这个路径指向的文件在调用本方法时不存在。<em>prefix<em>、</em>suffix</em> 和 <em>dir</em> 参数与 <code>mkstemp()</code> 中的同名参数类似，不同之处在于不支持字节类型的文件名，不支持 <code>suffix=None</code> 和 <code>prefix=None</code>。</p>
<p>警告</p>
<p>使用此功能可能会在程序中引入安全漏洞。当你开始使用本方法返回的文件执行任何操作时，可能有人已经捷足先登了。<code>mktemp()</code> 的功能可以很轻松地用 <code>NamedTemporaryFile()</code> 代替，当然需要传递 <code>delete=False</code> 参数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> NamedTemporaryFile<span class="token punctuation">(</span>delete<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>name
<span class="token string">'/tmp/tmptjujjt'</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span>
<span class="token number">13</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>unlink<span class="token punctuation">(</span>f<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>f<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="glob-—-Unix-风格路径名模式扩展"><a href="#glob-—-Unix-风格路径名模式扩展" class="headerlink" title="glob —- Unix 风格路径名模式扩展"></a><code>glob</code> —- Unix 风格路径名模式扩展</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/glob.py" target="_blank" rel="noopener">Lib/glob.py</a></p>
<hr>
<p><code>glob</code> 模块可根据 Unix 终端所用规则找出所有匹配特定模式的路径名，但会按不确定的顺序返回结果。 波浪号扩展不会生效，但 <code>*</code>, <code>?</code> 以及表示为 <code>[]</code> 的字符范围将被正确地匹配。 这是通过配合使用 <code>os.scandir()</code> 和 <code>fnmatch.fnmatch()</code> 函数来实现的，而不是通过实际发起调用子终端。 请注意不同于 <code>fnmatch.fnmatch()</code>，<code>glob</code> 会将以点号 (<code>.</code>) 开头的文件名作为特殊情况来处理。 （对于波浪号和终端变量扩展，请使用 <code>os.path.expanduser()</code> 和 <code>os.path.expandvars()</code>。）</p>
<p>对于字面值匹配，请将原字符用方括号括起来。 例如，<code>'[?]'</code> 将匹配字符 <code>'?'</code>。</p>
<p>参见</p>
<p><code>pathlib</code> 模块提供高级路径对象。</p>
<p><code>glob.glob</code>(<em>pathname</em>, <em>**,</em> root_dir=None<em>,</em> dir_fd=None<em>,</em> recursive=False*)</p>
<p>返回匹配 <em>pathname</em> 的可能为空的路径名列表，其中的元素必须为包含路径信息的字符串。 <em>pathname</em> 可以是绝对路径 (如 <code>/usr/src/Python-1.5/Makefile</code>) 或相对路径 (如 <code>../../Tools/*/*.gif</code>)，并且可包含 shell 风格的通配符。 结果也将包含无效的符号链接（与在 shell 中一样）。 结果是否排序取决于具体文件系统。 如果某个符合条件的文件在调用此函数期间被移除或添加，是否包括该文件的路径是没有规定的。</p>
<p>如果 <em>root_dir</em> 不为 <code>None</code>，则它应当是指明要搜索的根目录的 path-like object。 它用在 <code>glob()</code> 上与在调用它之前改变当前目录有相同的效果。 如果 <em>pathname</em> 为相对路径，结果将包含相对于 <em>root_dir</em> 的路径。</p>
<p>本函数带有 <em>dir_fd</em> 参数，支持 基于目录描述符的相对路径。</p>
<p>如果 <em>recursive</em> 为真值，则模式 “<code>**</code>“ 将匹配目录中的任何文件以及零个或多个目录、子目录和符号链接。 如果模式加了一个 <code>os.sep</code> 或 <code>os.altsep</code> 则将不匹配文件。</p>
<p>引发一个 审计事件 <code>glob.glob</code> 附带参数 <code>pathname</code>, <code>recursive</code>。</p>
<p>引发一个 审计事件 <code>glob.glob/2</code>，附带参数 <code>pathname</code>, <code>recursive</code>, <code>root_dir</code>, <code>dir_fd</code>。</p>
<p>注解</p>
<p>在一个较大的目录树中使用 “<code>**</code>“ 模式可能会消耗非常多的时间。</p>
<p>在 3.5 版更改: 支持使用 “<code>**</code>“ 的递归 glob。</p>
<p>在 3.10 版更改: 添加了 <em>root_dir</em> 和 <em>dir_fd</em> 形参。</p>
<p><code>glob.iglob</code>(<em>pathname</em>, <em>**,</em> root_dir=None<em>,</em> dir_fd=None<em>,</em> recursive=False*)</p>
<p>返回一个 iterator，它会产生与 <code>glob()</code> 相同的结果，但不会实际地同时保存它们。</p>
<p>引发一个 审计事件 <code>glob.glob</code> 附带参数 <code>pathname</code>, <code>recursive</code>。</p>
<p>引发一个 审计事件 <code>glob.glob/2</code>，附带参数 <code>pathname</code>, <code>recursive</code>, <code>root_dir</code>, <code>dir_fd</code>。</p>
<p>在 3.5 版更改: 支持使用 “<code>**</code>“ 的递归 glob。</p>
<p>在 3.10 版更改: 添加了 <em>root_dir</em> 和 <em>dir_fd</em> 形参。</p>
<p><code>glob.escape</code>(<em>pathname</em>)</p>
<p>转义所有特殊字符 (<code>'?'</code>, <code>'*'</code> 和 <code>'['</code>)。 这适用于当你想要匹配可能带有特殊字符的任意字符串字面值的情况。 在 drive/UNC 共享点中的特殊字符不会被转义，例如在 Windows 上 <code>escape('//?/c:/Quo vadis?.txt')</code> 将返回 <code>'//?/c:/Quo vadis[?].txt'</code>。</p>
<p>3.4 新版功能.</p>
<p>例如，考虑一个包含以下内容的目录：文件 <code>1.gif</code>, <code>2.txt</code>, <code>card.gif</code> 以及一个子目录 <code>sub</code> 其中只包含一个文件 <code>3.txt</code>. <code>glob()</code> 将产生如下结果。 请注意路径的任何开头部分都将被保留。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> glob
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'./[0-9].*'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'./1.gif'</span><span class="token punctuation">,</span> <span class="token string">'./2.txt'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'*.gif'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1.gif'</span><span class="token punctuation">,</span> <span class="token string">'card.gif'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'?.gif'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1.gif'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'**/*.txt'</span><span class="token punctuation">,</span> recursive<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'2.txt'</span><span class="token punctuation">,</span> <span class="token string">'sub/3.txt'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'./**/'</span><span class="token punctuation">,</span> recursive<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'./'</span><span class="token punctuation">,</span> <span class="token string">'./sub/'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果目录包含以 <code>.</code> 打头的文件，它们默认将不会被匹配。 例如，考虑一个包含 <code>card.gif</code> 和 <code>.card.gif</code> 的目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> glob
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'*.gif'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'card.gif'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'.c*'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'.card.gif'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="fnmatch-—-Unix-文件名模式匹配"><a href="#fnmatch-—-Unix-文件名模式匹配" class="headerlink" title="fnmatch —- Unix 文件名模式匹配"></a><code>fnmatch</code> —- Unix 文件名模式匹配</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/fnmatch.py" target="_blank" rel="noopener">Lib/fnmatch.py</a></p>
<hr>
<p>此模块提供了 Unix shell 风格的通配符，它们 <em>并不</em> 等同于正则表达式。 shell 风格通配符所使用的特殊字符如下：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>*</code></td>
<td align="left">匹配所有</td>
</tr>
<tr>
<td align="left"><code>?</code></td>
<td align="left">匹配任何单个字符</td>
</tr>
<tr>
<td align="left"><code>[seq]</code></td>
<td align="left">匹配 <em>seq</em> 中的任何字符</td>
</tr>
<tr>
<td align="left"><code>[!seq]</code></td>
<td align="left">匹配任何不在 <em>seq</em> 中的字符</td>
</tr>
</tbody></table>
<p>对于字面值匹配，请将原字符用方括号括起来。 例如，<code>'[?]'</code> 将匹配字符 <code>'?'</code>。</p>
<p>注意文件名分隔符 (Unix 上为 <code>'/'</code>) <em>不是</em> 此模块所特有的。 请参见 <code>glob</code> 模块了解文件名扩展 (<code>glob</code> 使用 <code>filter()</code> 来匹配文件名的各个部分)。 类似地，以一个句点打头的文件名也不是此模块所特有的，可以通过 <code>*</code> 和 <code>?</code> 模式来匹配。</p>
<p><code>fnmatch.fnmatch</code>(<em>filename</em>, <em>pattern</em>)</p>
<p>检测 <em>filename</em> 字符串是否匹配 <em>pattern</em> 字符串，返回 <code>True</code> 或 <code>False</code>。 两个形参都会使用 <code>os.path.normcase()</code> 进行大小写正规化。 <code>fnmatchcase()</code> 可被用于执行大小写敏感的比较，无论这是否为所在操作系统的标准。</p>
<p>这个例子将打印当前目录下带有扩展名 <code>.txt</code> 的所有文件名:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> fnmatch
<span class="token keyword">import</span> os
<span class="token keyword">for</span> file <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> fnmatch<span class="token punctuation">.</span>fnmatch<span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">'*.txt'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>fnmatch.fnmatchcase</code>(<em>filename</em>, <em>pattern</em>)</p>
<p>检测 <em>filename</em> 是否匹配 <em>pattern</em>，返回 <code>True</code> 或 <code>False</code>；此比较是大小写敏感的，并且不会应用 <code>os.path.normcase()</code>。</p>
<p><code>fnmatch.filter</code>(<em>names</em>, <em>pattern</em>)</p>
<p>基于可迭代对象 <em>names</em> 中匹配 <em>pattern</em> 的元素构造一个列表。 它等价于 <code>[n for n in names if fnmatch(n, pattern)]</code>，但实现得更有效率。</p>
<p><code>fnmatch.translate</code>(<em>pattern</em>)</p>
<p>返回 shell 风格 <em>pattern</em> 转换成的正则表达式以便用于 <code>re.match()</code>。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> fnmatch<span class="token punctuation">,</span> re
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> regex <span class="token operator">=</span> fnmatch<span class="token punctuation">.</span>translate<span class="token punctuation">(</span><span class="token string">'*.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> regex
<span class="token string">'(?s:.*\\.txt)\\Z'</span>
<span class="token operator">>></span><span class="token operator">></span> reobj <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>regex<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> reobj<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'foobar.txt'</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'foobar.txt'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="linecache-—-随机读写文本行"><a href="#linecache-—-随机读写文本行" class="headerlink" title="linecache —- 随机读写文本行"></a><code>linecache</code> —- 随机读写文本行</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/linecache.py" target="_blank" rel="noopener">Lib/linecache.py</a></p>
<hr>
<p><code>linecache</code> 模块允许从一个 Python 源文件中获取任意的行，并会尝试使用缓存进行内部优化，常应用于从单个文件读取多行的场合。 此模块被 <code>traceback</code> 模块用来提取源码行以便包含在格式化的回溯中。</p>
<p><code>tokenize.open()</code> 函数被用于打开文件。 此函数使用 <code>tokenize.detect_encoding()</code> 来获取文件的编码格式；如果未指明编码格式，则默认编码为 UTF-8。</p>
<p><code>linecache</code> 模块定义了下列函数：</p>
<p><code>linecache.getline</code>(<em>filename</em>, <em>lineno</em>, <em>module_globals=None</em>)</p>
<p>从名为 <em>filename</em> 的文件中获取 <em>lineno</em> 行，此函数绝不会引发异常 —- 出现错误时它将返回 <code>''</code> (所有找到的行都将包含换行符作为结束)。</p>
<p>如果找不到名为 <em>filename</em> 的文件，此函数会先在 <em>module_globals</em> 中检查 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a> <code>__loader__</code>。 如果存在这样的加载器并且它定义了 <code>get_source</code> 方法，则由该方法来确定源行 (如果 <code>get_source()</code> 返回 <code>None</code>，则该函数返回 <code>''</code>)。 最后，如果 <em>filename</em> 是一个相对路径文件名，则它会在模块搜索路径 <code>sys.path</code> 中按条目的相对位置进行查找。</p>
<p><code>linecache.clearcache</code>()</p>
<p>清空缓存。 如果你不再需要之前使用 <code>getline()</code> 从文件读取的行即可使用此函数。</p>
<p><code>linecache.checkcache</code>(<em>filename=None</em>)</p>
<p>检查缓存有效性。 如果缓存中的文件在磁盘上发生了改变，而你需要更新后的版本即可使用此函数。 如果省略了 <em>filename</em>，它会检查缓存中的所有条目。</p>
<p><code>linecache.lazycache</code>(<em>filename</em>, <em>module_globals</em>)</p>
<p>捕获有关某个非基于文件的模块的足够细节信息，以允许稍后再通过 <code>getline()</code> 来获取其中的行，即使当稍后调用时 <em>module_globals</em> 为 <code>None</code>。 这可以避免在实际需要读取行之前执行 I/O，也不必始终保持模块全局变量。</p>
<p>3.5 新版功能.</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> linecache
<span class="token operator">>></span><span class="token operator">></span> linecache<span class="token punctuation">.</span>getline<span class="token punctuation">(</span>linecache<span class="token punctuation">.</span>__file__<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>
<span class="token string">'import sys\n'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="shutil-—-高阶文件操作"><a href="#shutil-—-高阶文件操作" class="headerlink" title="shutil —- 高阶文件操作"></a><code>shutil</code> —- 高阶文件操作</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/shutil.py" target="_blank" rel="noopener">Lib/shutil.py</a></p>
<hr>
<p><code>shutil</code> 模块提供了一系列对文件和文件集合的高阶操作。 特别是提供了一些支持文件拷贝和删除的函数。 </p>
<p>警告</p>
<p>即便是高阶文件拷贝函数 (<code>shutil.copy()</code>, <code>shutil.copy2()</code>) 也无法拷贝所有的文件元数据。</p>
<p>在 POSIX 平台上，这意味着将丢失文件所有者和组以及 ACL 数据。 在 Mac OS 上，资源钩子和其他元数据不被使用。 这意味着将丢失这些资源并且文件类型和创建者代码将不正确。 在 Windows 上，将不会拷贝文件所有者、ACL 和替代数据流。</p>
<h3 id="目录和文件操作"><a href="#目录和文件操作" class="headerlink" title="目录和文件操作"></a>目录和文件操作</h3><p><code>shutil.copyfileobj</code>(<em>fsrc</em>, <em>fdst</em>[, <em>length</em>])</p>
<p>将文件类对象 <em>fsrc</em> 的内容拷贝到文件类对象 <em>fdst*。 整数值 *length</em> 如果给出则为缓冲区大小。 特别地， <em>length</em> 为负值表示拷贝数据时不对源数据进行分块循环处理；默认情况下会分块读取数据以避免不受控制的内存消耗。 请注意如果 <em>fsrc</em> 对象的当前文件位置不为 0，则只有从当前文件位置到文件末尾的内容会被拷贝。</p>
<p><code>shutil.copyfile</code>(<em>src</em>, <em>dst</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>将名为 <em>src</em> 的文件的内容（不包括元数据）拷贝到名为 <em>dst</em> 的文件并以尽可能高效的方式返回 <em>dst*。 *src</em> 和 <em>dst</em> 均为路径类对象或以字符串形式给出的路径名。</p>
<p><em>dst</em> 必须是完整的目标文件名。 如果 <em>src</em> 和 <em>dst</em> 指定了同一个文件，则将引发 <code>SameFileError</code>。</p>
<p>目标位置必须是可写的；否则将引发 <code>OSError</code> 异常。 如果 <em>dst</em> 已经存在，它将被替换。 特殊文件如字符或块设备以及管道无法用此函数来拷贝。</p>
<p>如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则将创建一个新的符号链接而不是拷贝 <em>src</em> 所指向的文件。</p>
<p>引发一个 审计事件 <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 曾经是引发 <code>IOError</code> 而不是 <code>OSError</code>。 增加了 <em>follow_symlinks</em> 参数。 现在是返回 <em>dst</em>。</p>
<p>在 3.4 版更改: 引发 <code>SameFileError</code> 而不是 <code>Error</code>。 由于前者是后者的子类，此改变是向后兼容的。</p>
<p>在 3.8 版更改: 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 </p>
<p><em>exception</em> <code>shutil.SameFileError</code></p>
<p>此异常会在 <code>copyfile()</code> 中的源和目标为同一文件时被引发。</p>
<p>3.4 新版功能.</p>
<p><code>shutil.copymode</code>(<em>src</em>, <em>dst</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>从 <em>src</em> 拷贝权限位到 <em>dst*。 文件的内容、所有者和分组将不受影响。 *src</em> 和 <em>dst</em> 均为路径类对象或字符串形式的路径名。 如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均为符号链接，<code>copymode()</code> 将尝试修改 <em>dst</em> 本身的模式（而非它所指向的文件）。 此功能并不是在所有平台上均可用；请参阅 <code>copystat()</code> 了解详情。 如果 <code>copymode()</code> 无法修改本机平台上的符号链接，而它被要求这样做，它将不做任何操作即返回。</p>
<p>引发一个 审计事件 <code>shutil.copymode</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 加入 <em>follow_symlinks</em> 参数。</p>
<p><code>shutil.copystat</code>(<em>src</em>, <em>dst</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>从 <em>src</em> 拷贝权限位、最近访问时间、最近修改时间以及旗标到 <em>dst*。 在 Linux上，<code>copystat()</code> 还会在可能的情况下拷贝“扩展属性”。 文件的内容、所有者和分组将不受影响。 *src</em> 和 <em>dst</em> 均为路径类对象或字符串形式的路径名。</p>
<p>如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均指向符号链接，<code>copystat()</code> 将作用于符号链接本身而非该符号链接所指向的文件 — 从 <em>src</em> 符号链接读取信息，并将信息写入 <em>dst</em> 符号链接。</p>
<p>注解</p>
<p>并非所有平台者提供检查和修改符号链接的功能。 Python 本身可以告诉你哪些功能是在本机上可用的。</p>
<ul>
<li>如果 <code>os.chmod in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <code>copystat()</code> 可以修改符号链接的权限位。</li>
<li>如果 <code>os.utime in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <code>copystat()</code> 可以修改符号链接的最近访问和修改时间。</li>
<li>如果 <code>os.chflags in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <code>copystat()</code> 可以修改符号链接的旗标。 (<code>os.chflags</code> 不是在所有平台上均可用。)</li>
</ul>
<p>在此功能部分或全部不可用的平台上，当被要求修改一个符号链接时，<code>copystat()</code> 将尽量拷贝所有内容。 <code>copystat()</code> 一定不会返回失败信息。</p>
<p>引发一个 审计事件 <code>shutil.copystat</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 添加了 <em>follow_symlinks</em> 参数并且支持 Linux 扩展属性。</p>
<p><code>shutil.copy</code>(<em>src</em>, <em>dst</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>将文件 <em>src</em> 拷贝到文件或目录 <em>dst*。 *src</em> 和 <em>dst</em> 应为 路径类对象 或字符串。 如果 <em>dst</em> 指定了一个目录，文件将使用 <em>src</em> 中的基准文件名拷贝到 <em>dst</em> 中。 将返回新创建文件所对应的路径。</p>
<p>如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则 <em>dst</em> 也将被创建为符号链接。 如果 <em>follow_symlinks</em> 为真值且 <em>src</em> 为符号链接，<em>dst</em> 将成为 <em>src</em> 所指向的文件的一个副本。</p>
<p><code>copy()</code> 会拷贝文件数据和文件的权限模式 (参见 <code>os.chmod()</code>)。 其他元数据，例如文件的创建和修改时间不会被保留。 要保留所有原有的元数据，请改用 <code>copy2()</code> 。</p>
<p>引发一个 审计事件 <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>引发一个 审计事件 <code>shutil.copymode</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 添加了 <em>follow_symlinks</em> 参数。 现在会返回新创建文件的路径。</p>
<p>在 3.8 版更改: 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 </p>
<p><code>shutil.copy2</code>(<em>src</em>, <em>dst</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>类似于 <code>copy()</code>，区别在于 <code>copy2()</code> 还会尝试保留文件的元数据。</p>
<p>当 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接时，<code>copy2()</code> 会尝试将来自 <em>src</em> 符号链接的所有元数据拷贝到新创建的 <em>dst</em> 符号链接。 但是，此功能不是在所有平台上均可用。 在此功能部分或全部不可用的平台上，<code>copy2()</code> 将尽量保留所有元数据；<code>copy2()</code> 一定不会由于无法保留文件元数据而引发异常。</p>
<p><code>copy2()</code> 会使用 <code>copystat()</code> 来拷贝文件元数据。 </p>
<p>引发一个 审计事件 <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>引发一个 审计事件 <code>shutil.copystat</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 添加了 <em>follow_symlinks</em> 参数，还会尝试拷贝扩展文件系统属性（目前仅限 Linux）。 现在会返回新创建文件的路径。</p>
<p>在 3.8 版更改: 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 </p>
<p><code>shutil.ignore_patterns</code>(<em>\</em>patterns*)</p>
<p>这个工厂函数会创建一个函数，它可被用作 <code>copytree()</code> 的 <em>ignore</em> 可调用对象参数，以忽略那些匹配所提供的 glob 风格的 <em>patterns</em> 之一的文件和目录。 参见以下示例。</p>
<p><code>shutil.copytree</code>(<em>src</em>, <em>dst</em>, <em>symlinks=False</em>, <em>ignore=None</em>, <em>copy_function=copy2</em>, <em>ignore_dangling_symlinks=False</em>, <em>dirs_exist_ok=False</em>)</p>
<p>将以 <em>src</em> 为根起点的整个目录树拷贝到名为 <em>dst</em> 的目录并返回目标目录。 <em>dirs_exist_ok</em> 指明是否要在 <em>dst</em> 或任何丢失的父目录已存在的情况下引发异常。</p>
<p>目录的权限和时间会通过 <code>copystat()</code> 来拷贝，单个文件则会使用 <code>copy2()</code> 来拷贝。</p>
<p>如果 <em>symlinks</em> 为真值，源目录树中的符号链接会在新目录树中表示为符号链接，并且原链接的元数据在平台允许的情况下也会被拷贝；如果为假值或省略，则会将被链接文件的内容和元数据拷贝到新目录树。</p>
<p>当 <em>symlinks</em> 为假值时，如果符号链接所指向的文件不存在，则会在拷贝进程的末尾将一个异常添加到 <code>Error</code> 异常中的错误列表。 如果你希望屏蔽此异常那就将可选的 <em>ignore_dangling_symlinks</em> 旗标设为真值。 请注意此选项在不支持 <code>os.symlink()</code> 的平台上将不起作用。</p>
<p>如果给出了 <em>ignore<em>，它必须是一个可调用对象，该对象将接受 <code>copytree()</code> 所访问的目录以及 <code>os.listdir()</code> 所返回的目录内容列表作为其参数。 由于 <code>copytree()</code> 是递归地被调用的，</em>ignore</em> 可调用对象对于每个被拷贝目录都将被调用一次。 该可调用对象必须返回一个相对于当前目录的目录和文件名序列（即其第二个参数的子集）；随后这些名称将在拷贝进程中被忽略。 <code>ignore_patterns()</code> 可被用于创建这种基于 glob 风格模式来忽略特定名称的可调用对象。</p>
<p>如果发生了（一个或多个）异常，将引发一个附带原因列表的 <code>Error</code>。</p>
<p>如果给出了 <em>copy_function</em>，它必须是一个将被用来拷贝每个文件的可调用对象。 它在被调用时会将源路径和目标路径作为参数传入。 默认情况下，<code>copy2()</code> 将被使用，但任何支持同样签名（与 <code>copy()</code> 一致）都可以使用。</p>
<p>引发一个 审计事件 <code>shutil.copytree</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 当 <em>symlinks</em> 为假值时拷贝元数据。 现在会返回 <em>dst</em>。</p>
<p>在 3.2 版更改: 添加了 <em>copy_function</em> 参数以允许提供定制的拷贝函数。 添加了 <em>ignore_dangling_symlinks</em> 参数以便在 <em>symlinks</em> 为假值时屏蔽符号链接错误。</p>
<p>在 3.8 版更改: 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 </p>
<p>3.8 新版功能: <em>dirs_exist_ok</em> 形参。</p>
<p><code>shutil.rmtree</code>(<em>path</em>, <em>ignore_errors=False</em>, <em>onerror=None</em>)</p>
<p>删除一个完整的目录树；<em>path</em> 必须指向一个目录（但不能是一个目录的符号链接）。 如果 <em>ignore_errors</em> 为真值，删除失败导致的错误将被忽略；如果为假值或是省略，此类错误将通过调用由 <em>onerror</em> 所指定的处理程序来处理，或者如果此参数被省略则将引发一个异常。</p>
<p>注解</p>
<p>在支持必要的基于 fd 的函数的平台上，默认会使用 <code>rmtree()</code> 的可防御符号链接攻击的版本。 在其他平台上，<code>rmtree()</code> 较易遭受符号链接攻击：给定适当的时间和环境，攻击者可以操纵文件系统中的符号链接来删除他们在其他情况下无法访问的文件。 应用程序可以使用 <code>rmtree.avoids_symlink_attacks</code> 函数属性来确定此类情况具体是哪一些。</p>
<p>如果提供了 <em>onerror*，它必须为接受三个形参的可调用对象: *function</em>, <em>path</em> 和 <em>excinfo</em>。</p>
<p>第一个形参 <em>function</em> 是引发异常的函数；它依赖于具体的平台和实现。 第二个形参 <em>path</em> 将是传递给 <em>function</em> 的路径名。 第三个形参 <em>excinfo</em> 将是由 <code>sys.exc_info()</code> 所返回的异常信息。 由 <em>onerror</em> 所引发的异常将不会被捕获。</p>
<p>引发一个 审计事件 <code>shutil.rmtree</code> 附带参数 <code>path</code>。</p>
<p>在 3.3 版更改: 添加了一个防御符号链接攻击的版本，如果平台支持基于 fd 的函数就会被使用。</p>
<p>在 3.8 版更改: 在 Windows 上将不会再在移除连接之前删除目录连接中的内容。</p>
<ul>
<li><p><code>rmtree.avoids_symlink_attacks</code></p>
<p>指明当前平台和实现是否提供防御符号链接攻击的 <code>rmtree()</code> 版本。 目前它仅在平台支持基于 fd 的目录访问函数时才返回真值。</p>
<p>3.3 新版功能.</p>
</li>
</ul>
<p><code>shutil.move</code>(<em>src</em>, <em>dst</em>, <em>copy_function=copy2</em>)</p>
<p>递归地将一个文件或目录 (<em>src</em>) 移至另一位置 (<em>dst</em>) 并返回目标位置。</p>
<p>如果目标是已存在的目录，则 <em>src</em> 会被移至该目录下。 如果目标已存在但不是目录，它可能会被覆盖，具体取决于 <code>os.rename()</code> 的语义。</p>
<p>如果目标是在当前文件系统中，则会使用 <code>os.rename()</code>。 在其他情况下，<em>src</em> 将被拷贝至 <em>dst<em>，使用的函数为 *copy_function</em>，然后目标会被移除。 对于符号链接，则将在 *dst</em> 之下或以其本身为名称创建一个指向 <em>src</em> 目标的新符号链接，并且 <em>src</em> 将被移除。</p>
<p>如果给出了 <em>copy_function*，则它必须为接受两个参数 *src</em> 和 <em>dst</em> 的可调用对象，并将在 <code>os.rename()</code> 无法使用时被用来将 <em>src</em> 拷贝到 <em>dst*。 如果源是一个目录，则会调用 <code>copytree()</code>，并向它传入 <code>copy_function()</code>。 默认的 *copy_function</em> 是 <code>copy2()</code>。 使用 <code>copy()</code> 作为 <em>copy_function</em> 允许在无法附带拷贝元数据时让移动操作成功执行，但其代价是不拷贝任何元数据。</p>
<p>引发一个 审计事件 <code>shutil.move</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 为异类文件系统添加了显式的符号链接处理，以便使它适应 GNU 的 <strong>mv</strong> 的行为。 现在会返回 <em>dst</em>。</p>
<p>在 3.5 版更改: 增加了 <em>copy_function</em> 关键字参数。</p>
<p>在 3.8 版更改: 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 </p>
<p>在 3.9 版更改: 接受一个 path-like object 作为 <em>src</em> 和 <em>dst</em>。</p>
<p><code>shutil.disk_usage</code>(<em>path</em>)</p>
<p>返回给定路径的磁盘使用统计数据，形式为一个 named tuple，其中包含 <em>total</em>, <em>used</em> 和 <em>free</em> 属性，分别表示总计、已使用和未使用空间的字节数。 <em>path</em> 可以是一个文件或是一个目录。</p>
<p>3.3 新版功能.</p>
<p>在 3.8 版更改: 在 Windows 上，<em>path</em> 现在可以是一个文件或目录。</p>
<p>可用性: Unix, Windows。</p>
<p><code>shutil.chown</code>(<em>path</em>, <em>user=None</em>, <em>group=None</em>)</p>
<p>修改给定 <em>path</em> 的所有者 <em>user</em> 和/或 <em>group</em>。</p>
<p><em>user</em> 可以是一个系统用户名或 uid；<em>group</em> 同样如此。 要求至少有一个参数。</p>
<p>另请参阅下层的函数 <code>os.chown()</code>。</p>
<p>引发一个 审计事件 <code>shutil.chown</code> 附带参数 <code>path</code>, <code>user</code>, <code>group</code>。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>shutil.which</code>(<em>cmd</em>, <em>mode=os.F_OK | os.X_OK</em>, <em>path=None</em>)</p>
<p>返回当给定的 <em>cmd</em> 被调用时将要运行的可执行文件的路径。 如果没有 <em>cmd</em> 会被调用则返回 <code>None</code>。</p>
<p><em>mode</em> 是一个传递给 <code>os.access()</code> 的权限掩码，在默认情况下将确定文件是否存在并且为可执行文件。</p>
<p>当未指定 <em>path</em> 时，将会使用 <code>os.environ()</code> 的结果，返回 “PATH” 的值或回退为 <code>os.defpath</code>。</p>
<p>在 Windows 上当前目录总是会被添加为 <em>path</em> 的第一项，无论你是否使用默认值或提供你自己的路径，这是命令行终端在查找可执行文件时所采用的行为方式。 此外，当在 <em>path</em> 中查找 <em>cmd</em> 时，还会检查 <code>PATHEXT</code> 环境变量。 例如，如果你调用 <code>shutil.which("python")</code>，<code>which()</code> 将搜索 <code>PATHEXT</code> 来确定它要在 <em>path</em> 目录中查找 <code>python.exe</code>。 例如，在 Windows 上:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> shutil<span class="token punctuation">.</span>which<span class="token punctuation">(</span><span class="token string">"python"</span><span class="token punctuation">)</span>
<span class="token string">'C:\\Python33\\python.EXE'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.3 新版功能.</p>
<p>在 3.8 版更改: 现在可以接受 <code>bytes</code> 类型。 如果 <em>cmd</em> 的类型为 <code>bytes</code>，结果的类型也将为 <code>bytes</code>。</p>
<p><em>exception</em> <code>shutil.Error</code></p>
<p>此异常会收集在多文件操作期间所引发的异常。 对于 <code>copytree()</code>，此异常参数将是一个由三元组 (<em>srcname</em>, <em>dstname</em>, <em>exception</em>) 构成的列表。</p>
<h4 id="依赖于具体平台的高效拷贝操作"><a href="#依赖于具体平台的高效拷贝操作" class="headerlink" title="依赖于具体平台的高效拷贝操作"></a>依赖于具体平台的高效拷贝操作</h4><p>从 Python 3.8 开始，所有涉及文件拷贝的函数 (<code>copyfile()</code>, <code>copy()</code>, <code>copy2()</code>, <code>copytree()</code> 以及 <code>move()</code>) 将会使用平台专属的 “fast-copy” 系统调用以便更高效地拷贝文件 。 “fast-copy” 意味着拷贝操作将发生于内核之中，避免像在 “<code>outfd.write(infd.read())</code>“ 中那样使用 Python 用户空间的缓冲区。</p>
<p>在 macOS 上将会使用 fcopyfile 来拷贝文件内容（不含元数据）。</p>
<p>在 Linux 上将会使用 <code>os.sendfile()</code>。</p>
<p>在 Windows 上 <code>shutil.copyfile()</code> 将会使用更大的默认缓冲区（1 MiB 而非 64 KiB）并且会使用基于 <code>memoryview()</code> 的 <code>shutil.copyfileobj()</code> 变种形式。</p>
<p>如果快速拷贝操作失败并且没有数据被写入目标文件，则 shutil 将在内部静默地回退到使用效率较低的 <code>copyfileobj()</code> 函数。</p>
<p>在 3.8 版更改.</p>
<h4 id="copytree-示例"><a href="#copytree-示例" class="headerlink" title="copytree 示例"></a>copytree 示例</h4><p>这个示例就是上面所描述的 <code>copytree()</code> 函数的实现，其中省略了文档字符串。 它还展示了此模块所提供的许多其他函数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">copytree</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> symlinks<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    names <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>src<span class="token punctuation">)</span>
    os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>dst<span class="token punctuation">)</span>
    errors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> name <span class="token keyword">in</span> names<span class="token punctuation">:</span>
        srcname <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>src<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
        dstname <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>dst<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> symlinks <span class="token operator">and</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>islink<span class="token punctuation">(</span>srcname<span class="token punctuation">)</span><span class="token punctuation">:</span>
                linkto <span class="token operator">=</span> os<span class="token punctuation">.</span>readlink<span class="token punctuation">(</span>srcname<span class="token punctuation">)</span>
                os<span class="token punctuation">.</span>symlink<span class="token punctuation">(</span>linkto<span class="token punctuation">,</span> dstname<span class="token punctuation">)</span>
            <span class="token keyword">elif</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>srcname<span class="token punctuation">)</span><span class="token punctuation">:</span>
                copytree<span class="token punctuation">(</span>srcname<span class="token punctuation">,</span> dstname<span class="token punctuation">,</span> symlinks<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                copy2<span class="token punctuation">(</span>srcname<span class="token punctuation">,</span> dstname<span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true"># XXX What about devices, sockets etc.?</span>
        <span class="token keyword">except</span> OSError <span class="token keyword">as</span> why<span class="token punctuation">:</span>
            errors<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>srcname<span class="token punctuation">,</span> dstname<span class="token punctuation">,</span> str<span class="token punctuation">(</span>why<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># catch the Error from the recursive copytree so that we can</span>
        <span class="token comment" spellcheck="true"># continue with other files</span>
        <span class="token keyword">except</span> Error <span class="token keyword">as</span> err<span class="token punctuation">:</span>
            errors<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>err<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        copystat<span class="token punctuation">(</span>src<span class="token punctuation">,</span> dst<span class="token punctuation">)</span>
    <span class="token keyword">except</span> OSError <span class="token keyword">as</span> why<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># can't copy file access times on Windows</span>
        <span class="token keyword">if</span> why<span class="token punctuation">.</span>winerror <span class="token keyword">is</span> None<span class="token punctuation">:</span>
            errors<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> str<span class="token punctuation">(</span>why<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> errors<span class="token punctuation">:</span>
        <span class="token keyword">raise</span> Error<span class="token punctuation">(</span>errors<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另一个使用 <code>ignore_patterns()</code> 辅助函数的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> shutil <span class="token keyword">import</span> copytree<span class="token punctuation">,</span> ignore_patterns
copytree<span class="token punctuation">(</span>source<span class="token punctuation">,</span> destination<span class="token punctuation">,</span> ignore<span class="token operator">=</span>ignore_patterns<span class="token punctuation">(</span><span class="token string">'*.pyc'</span><span class="token punctuation">,</span> <span class="token string">'tmp*'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这将会拷贝除 <code>.pyc</code> 文件和以 <code>tmp</code> 打头的文件或目录以外的所有条目.</p>
<p>另一个使用 <em>ignore</em> 参数来添加记录调用的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> shutil <span class="token keyword">import</span> copytree
<span class="token keyword">import</span> logging
<span class="token keyword">def</span> <span class="token function">_logpath</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> names<span class="token punctuation">)</span><span class="token punctuation">:</span>
    logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'Working in %s'</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># nothing will be ignored</span>
copytree<span class="token punctuation">(</span>source<span class="token punctuation">,</span> destination<span class="token punctuation">,</span> ignore<span class="token operator">=</span>_logpath<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="rmtree-示例"><a href="#rmtree-示例" class="headerlink" title="rmtree 示例"></a>rmtree 示例</h4><p>这个例子演示了如何在 Windows 上删除一个目录树，其中部分文件设置了只读属性位。 它会使用 onerror 回调函数来清除只读属性位并再次尝试删除。 任何后续的失败都将被传播。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token punctuation">,</span> stat
<span class="token keyword">import</span> shutil
<span class="token keyword">def</span> <span class="token function">remove_readonly</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> path<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">"Clear the readonly bit and reattempt the removal"</span>
    os<span class="token punctuation">.</span>chmod<span class="token punctuation">(</span>path<span class="token punctuation">,</span> stat<span class="token punctuation">.</span>S_IWRITE<span class="token punctuation">)</span>
    func<span class="token punctuation">(</span>path<span class="token punctuation">)</span>
shutil<span class="token punctuation">.</span>rmtree<span class="token punctuation">(</span>directory<span class="token punctuation">,</span> onerror<span class="token operator">=</span>remove_readonly<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="归档操作"><a href="#归档操作" class="headerlink" title="归档操作"></a>归档操作</h3><p>3.2 新版功能.</p>
<p>在 3.5 版更改: 添加了对 <em>xztar</em> 格式的支持。</p>
<p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <code>zipfile</code> 和 <code>tarfile</code> 模块。</p>
<p><code>shutil.make_archive</code>(<em>base_name</em>, <em>format</em>[, <em>root_dir</em>[, <em>base_dir</em>[, <em>verbose</em>[, <em>dry_run</em>[, <em>owner</em>[, <em>group</em>[, <em>logger</em>]]]]]]])</p>
<p>创建一个归档文件（例如 zip 或 tar）并返回其名称。</p>
<p><em>base_name</em> 是要创建的文件名称，包括路径，去除任何特定格式的扩展名。 <em>format</em> 是归档格式：为 “zip” (如果 <code>zlib</code> 模块可用), “tar”, “gztar” (如果 <code>zlib</code> 模块可用), “bztar” (如果 <code>bz2</code> 模块可用) 或 “xztar” (如果 <code>lzma</code> 模块可用) 中的一个。</p>
<p><em>root_dir</em> 是一个目录，它将作为归档文件的根目录，归档中的所有路径都将是它的相对路径；例如，我们通常会在创建归档之前用 chdir 命令切换到 <em>root_dir</em>。</p>
<p><em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档中所有文件和目录共有的路径前缀。 <em>base_dir</em> 必须相对于 <em>root_dir</em> 给出。</p>
<p><em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。</p>
<p>如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。</p>
<p><em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。</p>
<p><em>logger</em> 必须是一个兼容 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 的对象，通常为 <code>logging.Logger</code> 的实例。</p>
<p><em>verbose</em> 参数已不再使用并进入弃用状态。</p>
<p>引发一个 审计事件 <code>shutil.make_archive</code> 并附带参数 <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>。</p>
<p>注解</p>
<p>这个函数不是线程安全的。</p>
<p>在 3.8 版更改: 现在对于通过 <code>format="tar"</code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p>
<p><code>shutil.get_archive_formats</code>()</p>
<p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code>(name, description)</code>。</p>
<p>默认情况下 <code>shutil</code> 提供以下格式:</p>
<ul>
<li><em>zip</em>: ZIP 文件（如果 <code>zlib</code> 模块可用）。</li>
<li><em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。</li>
<li><em>gztar</em>: gzip 压缩的 tar 文件（如果 <code>zlib</code> 模块可用）。</li>
<li><em>bztar</em>: bzip2 压缩的 tar 文件（如果 <code>bz2</code> 模块可用）。</li>
<li><em>xztar</em>: xz 压缩的 tar 文件（如果 <code>lzma</code> 模块可用）。</li>
</ul>
<p>你可以通过使用 <code>register_archive_format()</code> 注册新的格式或为任何现有格式提供你自己的归档器。</p>
<p><code>shutil.register_archive_format</code>(<em>name</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p>
<p>为 <em>name</em> 格式注册一个归档器。</p>
<p><em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name*，再加上要归档内容的 *base_dir</em> (其默认值为 <code>os.curdir</code>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <code>make_archive()</code> 传入的参数一致)。</p>
<p>如果给出了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。</p>
<p><em>description</em> 由 <code>get_archive_formats()</code> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p>
<p><code>shutil.unregister_archive_format</code>(<em>name</em>)</p>
<p>从支持的格式中移除归档格式 <em>name</em>。</p>
<p><code>shutil.unpack_archive</code>(<em>filename</em>[, <em>extract_dir</em>[, <em>format</em>]])</p>
<p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。</p>
<p><em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。</p>
<p><em>format</em> 是归档格式：应为 “zip”, “tar”, “gztar”, “bztar” 或 “xztar” 之一。 或者任何通过 <code>register_unpack_format()</code> 注册的其他格式。 如果未提供，<code>unpack_archive()</code> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <code>ValueError</code>。</p>
<p>引发一个 审计事件 <code>shutil.unpack_archive</code> 附带参数 <code>filename</code>, <code>extract_dir</code>, <code>format</code>。</p>
<p>在 3.7 版更改: 接受一个 path-like object 作为 <em>filename</em> 和 <em>extract_dir</em>。</p>
<p><code>shutil.register_unpack_format</code>(<em>name</em>, <em>extensions</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p>
<p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code>.zip</code>。</p>
<p><em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接受归档文件的路径，加上该归档文件要被解包的目标目录。</p>
<p>如果提供了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 元组的序列，将被作为关键字参数传递给该可调用对象。</p>
<p>可以提供 <em>description</em> 来描述该格式，它将被 <code>get_unpack_formats()</code> 返回。</p>
<p><code>shutil.unregister_unpack_format</code>(<em>name</em>)</p>
<p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p>
<p><code>shutil.get_unpack_formats</code>()</p>
<p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code>(name, extensions, description)</code>。</p>
<p>默认情况下 <code>shutil</code> 提供以下格式:</p>
<ul>
<li><em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。</li>
<li><em>tar</em>: 未压缩的 tar 文件。</li>
<li><em>gztar</em>: gzip 压缩的 tar 文件（如果 <code>zlib</code> 模块可用）。</li>
<li><em>bztar</em>: bzip2 压缩的 tar 文件（如果 <code>bz2</code> 模块可用）。</li>
<li><em>xztar</em>: xz 压缩的 tar 文件（如果 <code>lzma</code> 模块可用）。</li>
</ul>
<p>你可以通过使用 <code>register_unpack_format()</code> 注册新的格式或为任何现有格式提供你自己的解包器。</p>
<h4 id="归档程序示例"><a href="#归档程序示例" class="headerlink" title="归档程序示例"></a>归档程序示例</h4><p>在这个示例中，我们创建了一个 gzip 压缩的 tar 归档文件，其中包含用户的 <code>.ssh</code> 目录下的所有文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> shutil <span class="token keyword">import</span> make_archive
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> archive_name <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'~'</span><span class="token punctuation">,</span> <span class="token string">'myarchive'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> root_dir <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'~'</span><span class="token punctuation">,</span> <span class="token string">'.ssh'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> make_archive<span class="token punctuation">(</span>archive_name<span class="token punctuation">,</span> <span class="token string">'gztar'</span><span class="token punctuation">,</span> root_dir<span class="token punctuation">)</span>
<span class="token string">'/Users/tarek/myarchive.tar.gz'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果归档文件中包含有:</p>
<pre><code>$ tar -tzvf /Users/tarek/myarchive.tar.gz
drwx------ tarek/staff       0 2010-02-01 16:23:40 ./
-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys
-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config
-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa
-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub
-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa
-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub
-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts</code></pre><h4 id="使用-base-dir-的归档程序示例"><a href="#使用-base-dir-的归档程序示例" class="headerlink" title="使用 base_dir 的归档程序示例"></a>使用 <em>base_dir</em> 的归档程序示例</h4><p>在这个例子中，与 上面的例子 类似，我们演示了如何使用 <code>make_archive()</code>，但这次是使用 <em>base_dir</em>。 我们现在具有如下的目录结构:</p>
<pre><code>$ tree tmp
tmp
└── root
    └── structure
        ├── content
            └── please_add.txt
        └── do_not_add.txt</code></pre><p>在最终的归档中，应当会包括 <code>please_add.txt</code>，但不应当包括 <code>do_not_add.txt</code>。 因此我们使用以下代码:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> shutil <span class="token keyword">import</span> make_archive
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> archive_name <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'~'</span><span class="token punctuation">,</span> <span class="token string">'myarchive'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> make_archive<span class="token punctuation">(</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     archive_name<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token string">'tar'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     root_dir<span class="token operator">=</span><span class="token string">'tmp/root'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     base_dir<span class="token operator">=</span><span class="token string">'structure/content'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span>
<span class="token string">'/Users/tarek/my_archive.tar'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>列出结果归档中的文件我们将会得到:</p>
<pre><code>$ python -m tarfile -l /Users/tarek/myarchive.tarstructure/content/structure/content/please_add.txt</code></pre><h3 id="查询输出终端的尺寸"><a href="#查询输出终端的尺寸" class="headerlink" title="查询输出终端的尺寸"></a>查询输出终端的尺寸</h3><p><code>shutil.get_terminal_size</code>(<em>fallback=columns, lines</em>)</p>
<p>获取终端窗口的尺寸。</p>
<p>对于两个维度中的每一个，会分别检查环境变量 <code>COLUMNS</code> 和 <code>LINES</code>。 如果定义了这些变量并且其值为正整数，则将使用这些值。</p>
<p>如果未定义 <code>COLUMNS</code> 或 <code>LINES</code>，这是通常的情况，则连接到 <code>sys.__stdout__</code> 的终端将通过发起调用 <code>os.get_terminal_size()</code> 被查询。</p>
<p>如果由于系统不支持查询，或是由于我们未连接到某个终端而导致查询终端尺寸不成功，则会使用在 <code>fallback</code> 形参中给出的值。 <code>fallback</code> 默认为 <code>(80, 24)</code>，这是许多终端模拟器所使用的默认尺寸。</p>
<p>返回的值是一个 <code>os.terminal_size</code> 类型的具名元组。</p>
<p>3.3 新版功能.</p>
<h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h1><p> <code>pickle</code> 和 <code>marshal</code> 模块可以将许多 Python 数据类型转换为字节流，然后从字节中重新创建对象。 各种与 DBM 相关的模块支持一系列基于散列的文件格式，这些格式存储字符串到其他字符串的映射。</p>
<p>本章中描述的模块列表是：</p>
<ul>
<li><code>pickle</code> —- Python 对象序列化<ul>
<li>与其他 Python 模块间的关系<ul>
<li>与 <code>marshal</code> 间的关系</li>
<li>与 <code>json</code> 模块的比较</li>
</ul>
</li>
<li>数据流格式</li>
<li>模块接口</li>
<li>可以被封存/解封的对象</li>
<li>封存类实例<ul>
<li>持久化外部对象</li>
<li>Dispatch 表</li>
<li>处理有状态的对象</li>
</ul>
</li>
<li>类型，函数和其他对象的自定义归约</li>
<li>外部缓冲区<ul>
<li>提供方 API</li>
<li>使用方 API</li>
<li>示例</li>
</ul>
</li>
<li>限制全局变量</li>
<li>性能</li>
<li>例子</li>
</ul>
</li>
<li><code>copyreg</code> —- 注册配合 <code>pickle</code> 模块使用的函数<ul>
<li>示例</li>
</ul>
</li>
<li><code>shelve</code> —- Python 对象持久化<ul>
<li>限制</li>
<li>示例</li>
</ul>
</li>
<li><code>marshal</code> —- 内部 Python 对象序列化</li>
<li><code>dbm</code> —- Unix “数据库” 接口<ul>
<li><code>dbm.gnu</code> —- GNU 对 dbm 的重解析</li>
<li><code>dbm.ndbm</code> —- 基于 ndbm 的接口</li>
<li><code>dbm.dumb</code> —- 便携式 DBM 实现</li>
</ul>
</li>
<li><code>sqlite3</code> —- SQLite 数据库 DB-API 2.0 接口模块<ul>
<li>模块函数和常量</li>
<li>连接对象（Connection）</li>
<li>Cursor 对象</li>
<li>行对象</li>
<li>异常</li>
<li>SQLite 与 Python 类型<ul>
<li>概述</li>
<li>使用适配器将额外的 Python 类型保存在 SQLite 数据库中。<ul>
<li>让对象自行适配</li>
<li>注册可调用的适配器</li>
</ul>
</li>
<li>将SQLite 值转换为自定义Python 类型</li>
<li>默认适配器和转换器</li>
</ul>
</li>
<li>控制事务</li>
<li>有效使用 <code>sqlite3</code><ul>
<li>使用快捷方式</li>
<li>通过名称而不是索引访问索引</li>
<li>使用连接作为上下文管理器</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="pickle-—-Python-对象序列化"><a href="#pickle-—-Python-对象序列化" class="headerlink" title="pickle —- Python 对象序列化"></a><code>pickle</code> —- Python 对象序列化</h2><p><strong>源代码：</strong><a href="https://github.com/python/cpython/tree/3.10/Lib/pickle.py" target="_blank" rel="noopener">Lib/pickle.py</a></p>
<hr>
<p>模块 <code>pickle</code> 实现了对一个 Python 对象结构的二进制序列化和反序列化。 <em>“pickling”</em> 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 <em>“unpickling”</em> 是相反的操作，会将（来自一个 binary file 或者 bytes-like object 的）字节流转化回一个对象层次结构。 pickling（和 unpickling）也被称为“序列化”, “编组” 或者 “平面化”。而为了避免混乱，此处采用术语 “封存 (pickling)” 和 “解封 (unpickling)”。</p>
<p>警告</p>
<p><code>pickle</code> 模块<strong>并不安全</strong>。你只应该对你信任的数据进行unpickle操作。</p>
<p>构建恶意的 pickle 数据来<strong>在解封时执行任意代码</strong>是可能的。绝对不要对不信任来源的数据和可能被篡改过的数据进行解封。</p>
<p>请考虑使用 <code>hmac</code> 来对数据进行签名，确保数据没有被篡改。</p>
<p>在你处理不信任数据时，更安全的序列化格式如 <code>json</code> 可能更为适合.</p>
<h3 id="与其他-Python-模块间的关系"><a href="#与其他-Python-模块间的关系" class="headerlink" title="与其他 Python 模块间的关系"></a>与其他 Python 模块间的关系</h3><h4 id="与-marshal-间的关系"><a href="#与-marshal-间的关系" class="headerlink" title="与 marshal 间的关系"></a>与 <code>marshal</code> 间的关系</h4><p>Python 有一个更原始的序列化模块称为 <code>marshal</code>，但一般地 <code>pickle</code> 应该是序列化 Python 对象时的首选。<code>marshal</code> 存在主要是为了支持 Python 的 <code>.pyc</code> 文件.</p>
<p><code>pickle</code> 模块与 <code>marshal</code> 在如下几方面显著地不同：</p>
<ul>
<li><p><code>pickle</code> 模块会跟踪已被序列化的对象，所以该对象之后再次被引用时不会再次被序列化。<code>marshal</code> 不会这么做。</p>
<p>这隐含了递归对象和共享对象。递归对象指包含对自己的引用的对象。这种对象并不会被 marshal 接受，并且实际上尝试 marshal 递归对象会让你的 Python 解释器崩溃。对象共享发生在对象层级中存在多处引用同一对象时。<code>pickle</code> 只会存储这些对象一次，并确保其他的引用指向同一个主副本。共享对象将保持共享，这可能对可变对象非常重要。</p>
</li>
<li><p><code>marshal</code> 不能被用于序列化用户定义类及其实例。<code>pickle</code> 能够透明地存储并保存类实例，然而此时类定义必须能够从与被存储时相同的模块被引入。</p>
</li>
<li><p>同样用于序列化的 <code>marshal</code> 格式不保证数据能移植到不同的 Python 版本中。因为它的主要任务是支持 <code>.pyc</code> 文件，必要时会以破坏向后兼容的方式更改这种序列化格式，为此 Python 的实现者保留了更改格式的权利。<code>pickle</code> 序列化格式可以在不同版本的 Python 中实现向后兼容，前提是选择了合适的 pickle 协议。如果你的数据要在 Python 2 与 Python 3 之间跨越传递，封存和解封的代码在 2 和 3 之间也是不同的。</p>
</li>
</ul>
<h4 id="与-json-模块的比较"><a href="#与-json-模块的比较" class="headerlink" title="与 json 模块的比较"></a>与 <code>json</code> 模块的比较</h4><p>Pickle 协议和 <a href="http://json.org/" target="_blank" rel="noopener">JSON (JavaScript Object Notation)</a> 间有着本质的不同：</p>
<ul>
<li>JSON 是一个文本序列化格式（它输出 unicode 文本，尽管在大多数时候它会接着以 <code>utf-8</code> 编码），而 pickle 是一个二进制序列化格式；</li>
<li>JSON 是我们可以直观阅读的，而 pickle 不是；</li>
<li>JSON是可互操作的，在Python系统之外广泛使用，而pickle则是Python专用的；</li>
<li>默认情况下，JSON 只能表示 Python 内置类型的子集，不能表示自定义的类；但 pickle 可以表示大量的 Python 数据类型（可以合理使用 Python 的对象内省功能自动地表示大多数类型，复杂情况可以通过实现 specific object APIs 来解决）。</li>
<li>不像pickle，对一个不信任的JSON进行反序列化的操作本身不会造成任意代码执行漏洞。</li>
</ul>
<h3 id="数据流格式"><a href="#数据流格式" class="headerlink" title="数据流格式"></a>数据流格式</h3><p><code>pickle</code> 所使用的数据格式仅可用于 Python。这样做的好处是没有外部标准给该格式强加限制，比如 JSON 或 XDR（不能表示共享指针）标准；但这也意味着非 Python 程序可能无法重新读取 pickle 封存的 Python 对象。</p>
<p>默认情况下，<code>pickle</code> 格式使用相对紧凑的二进制来存储。如果需要让文件更小，可以高效地 压缩 由 pickle 封存的数据。</p>
<p><code>pickletools</code> 模块包含了相应的工具用于分析 <code>pickle</code> 生成的数据流。<code>pickletools</code> 源码中包含了对 pickle 协议使用的操作码的大量注释。</p>
<p>当前共有 6 种不同的协议可用于封存操作。 使用的协议版本越高，读取所生成 pickle 对象所需的 Python 版本就要越新。</p>
<ul>
<li>v0 版协议是原始的“人类可读”协议，并且向后兼容早期版本的 Python。</li>
<li>v1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容。</li>
<li>v2 版协议是在 Python 2.3 中引入的。它为存储 new-style class 提供了更高效的机制。欲了解有关第 2 版协议带来的改进，请参阅 <a href="https://www.python.org/dev/peps/pep-0307" target="_blank" rel="noopener"><strong>PEP 307</strong></a>。</li>
<li>v3 版协议是在 Python 3.0 中引入的。 它显式地支持 <code>bytes</code> 字节对象，不能使用 Python 2.x 解封。这是 Python 3.0-3.7 的默认协议。</li>
<li>v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化。它是Python 3.8使用的默认协议。有关第 4 版协议带来改进的信息，请参阅 <a href="https://www.python.org/dev/peps/pep-3154" target="_blank" rel="noopener"><strong>PEP 3154</strong></a>。</li>
<li>第 5 版协议是在 Python 3.8 中加入的。 它增加了对带外数据的支持，并可加速带内数据处理。 请参阅 <a href="https://www.python.org/dev/peps/pep-0574" target="_blank" rel="noopener"><strong>PEP 574</strong></a> 了解第 5 版协议所带来的改进的详情。</li>
</ul>
<p>注解</p>
<p>序列化是一种比持久化更底层的概念，虽然 <code>pickle</code> 读取和写入的是文件对象，但它不处理持久对象的命名问题，也不处理对持久对象的并发访问（甚至更复杂）的问题。<code>pickle</code> 模块可以将复杂对象转换为字节流，也可以将字节流转换为具有相同内部结构的对象。处理这些字节流最常见的做法是将它们写入文件，但它们也可以通过网络发送或存储在数据库中。<code>shelve</code> 模块提供了一个简单的接口，用于在 DBM 类型的数据库文件上封存和解封对象。</p>
<h3 id="模块接口"><a href="#模块接口" class="headerlink" title="模块接口"></a>模块接口</h3><p>要序列化某个包含层次结构的对象，只需调用 <code>dumps()</code> 函数即可。同样，要反序列化数据流，可以调用 <code>loads()</code> 函数。但是，如果要对序列化和反序列化加以更多的控制，可以分别创建 <code>Pickler</code> 或 <code>Unpickler</code> 对象。</p>
<p><code>pickle</code> 模块包含了以下常量：</p>
<pre><code>pickle.HIGHEST_PROTOCOL</code></pre><p>整数，可用的最高 协议版本。此值可以作为 <em>协议</em> 值传递给 <code>dump()</code> 和 <code>dumps()</code> 函数，以及 <code>Pickler</code> 的构造函数。</p>
<pre><code>pickle.DEFAULT_PROTOCOL</code></pre><p>整数，用于 pickle 数据的默认 协议版本。它可能小于 <code>HIGHEST_PROTOCOL</code>。当前默认协议是 v4，它在 Python 3.4 中首次引入，与之前的版本不兼容。</p>
<p>在 3.0 版更改: 默认协议版本是 3。</p>
<p>在 3.8 版更改: 默认协议版本是 4。</p>
<p><code>pickle</code> 模块提供了以下方法，让封存过程更加方便：</p>
<p><code>pickle.dump</code>(<em>obj</em>, <em>file</em>, <em>protocol=None</em>, <em>**,</em> fix_imports=True<em>,</em> buffer_callback=None*)</p>
<p>将对象 <em>obj</em> 封存以后的对象写入已打开的 file object <em>file</em>。它等同于 <code>Pickler(file, protocol).dump(obj)</code>。</p>
<p>参数 <em>file<em>、</em>protocol<em>、</em>fix_imports</em> 和 <em>buffer_callback</em> 的含义与它们在 <code>Pickler</code> 的构造函数中的含义相同。</p>
<p>在 3.8 版更改: 加入了 <em>buffer_callback</em> 参数。</p>
<p><code>pickle.dumps</code>(<em>obj</em>, <em>protocol=None</em>, <em>**,</em> fix_imports=True<em>,</em> buffer_callback=None*)</p>
<p>将 <em>obj</em> 封存以后的对象作为 <code>bytes</code> 类型直接返回，而不是将其写入到文件。</p>
<p>参数 <em>protocol<em>、</em>fix_imports</em> 和 <em>buffer_callback</em> 的含义与它们在 <code>Pickler</code> 的构造函数中的含义相同。</p>
<p>在 3.8 版更改: 加入了 <em>buffer_callback</em> 参数。</p>
<p><code>pickle.load</code>(<em>file</em>, <em>**,</em> fix_imports=True<em>,</em> encoding=’ASCII’<em>,</em> errors=’strict’<em>,</em> buffers=None*)</p>
<p>从已打开的 file object<em>文件</em> 中读取封存后的对象，重建其中特定对象的层次结构并返回。它相当于 <code>Unpickler(file).load()</code>。</p>
<p>Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。封存对象以外的其他字节将被忽略。</p>
<p>参数 <em>file<em>、</em>fix_imports<em>、</em>encoding<em>、</em>errors<em>、</em>strict</em> 和 <em>buffers</em> 的含义与它们在 <code>Unpickler</code> 的构造函数中的含义相同。</p>
<p>在 3.8 版更改: 加入了 <em>buffers</em> 参数。</p>
<p><code>pickle.loads</code>(<em>data</em>, <em>/</em>, <em>**,</em> fix_imports=True<em>,</em> encoding=”ASCII”<em>,</em> errors=”strict”<em>,</em> buffers=None*)</p>
<p>重建并返回一个对象的封存表示形式 <em>data</em> 的对象层级结构。 <em>data</em> 必须为 bytes-like object。</p>
<p>Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。封存对象以外的其他字节将被忽略。</p>
<p>参数 <em>file<em>、</em>fix_imports<em>、</em>encoding<em>、</em>errors<em>、</em>strict</em> 和 <em>buffers</em> 的含义与它们在 <code>Unpickler</code> 的构造函数中的含义相同。</p>
<p>在 3.8 版更改: 加入了 <em>buffers</em> 参数。</p>
<p><code>pickle</code> 模块定义了以下 3 个异常：</p>
<p><em>exception</em><code>pickle.PickleError</code></p>
<p>其他 pickle 异常的基类。它是 <code>Exception</code> 的一个子类。</p>
<p><em>exception</em><code>pickle.PicklingError</code></p>
<p>当 <code>Pickler</code> 遇到无法解封的对象时抛出此错误。它是 <code>PickleError</code> 的子类。</p>
<p><em>exception</em><code>pickle.UnpicklingError</code></p>
<p>当解封出错时抛出此异常，例如数据损坏或对象不安全。它是 <code>PickleError</code> 的子类。</p>
<p>注意，解封时可能还会抛出其他异常，包括（但不限于） AttributeError、EOFError、ImportError 和 IndexError。</p>
<p><code>pickle</code> 模块包含了 3 个类，<code>Pickler</code>、<code>Unpickler</code> 和 <code>PickleBuffer</code>：</p>
<p><em>class<em><code>pickle.Pickler</code>(</em>file</em>, <em>protocol=None</em>, <em>**,</em> fix_imports=True<em>,</em> buffer_callback=None*)</p>
<p>它接受一个二进制文件用于写入 pickle 数据流。</p>
<p>可选参数 <em>protocol</em> 是一个整数，告知 pickler 使用指定的协议，可选择的协议范围从 0 到 <code>HIGHEST_PROTOCOL</code>。如果没有指定，这一参数默认值为 <code>DEFAULT_PROTOCOL</code>。指定一个负数就相当于指定 <code>HIGHEST_PROTOCOL</code>。</p>
<p>参数 <em>file</em> 必须有一个 write() 方法，该 write() 方法要能接收字节作为其唯一参数。因此，它可以是一个打开的磁盘文件（用于写入二进制内容），也可以是一个 <code>io.BytesIO</code> 实例，也可以是满足这一接口的其他任何自定义对象。</p>
<p>如果 <em>fix_imports</em> 为 True 且 <em>protocol</em> 小于 3，pickle 将尝试将 Python 3 中的新名称映射到 Python 2 中的旧模块名称，因此 Python 2 也可以读取封存的数据流。</p>
<p>如果 <em>buffer_callback</em> 为 None（默认情况），缓冲区视图（buffer view）将会作为 pickle 流的一部分被序列化到 <em>file</em> 中。</p>
<p>如果 <em>buffer_callback</em> 不为 None，那它可以用缓冲区视图调用任意次。如果某次调用返回了 False 值（例如 None），则给定的缓冲区是 带外的，否则缓冲区是带内的（例如保存在了 pickle 流里面）。</p>
<p>如果 <em>buffer_callback</em> 不是 None 且 <em>protocol</em> 是 None 或小于 5，就会出错。</p>
<p>在 3.8 版更改: 加入了 <em>buffer_callback</em> 参数。</p>
<ul>
<li><p><code>dump</code>(<em>obj</em>)</p>
<p>将 <em>obj</em> 封存后的内容写入已打开的文件对象，该文件对象已经在构造函数中指定。</p>
</li>
<li><p><code>persistent_id</code>(<em>obj</em>)</p>
<p>默认无动作，子类继承重载时使用。</p>
<p>如果 <code>persistent_id()</code> 返回 <code>None</code>，<em>obj</em> 会被照常 pickle。如果返回其他值，<code>Pickler</code> 会将这个函数的返回值作为 <em>obj</em> 的持久化 ID（Pickler 本应得到序列化数据流并将其写入文件，若此函数有返回值，则得到此函数的返回值并写入文件）。这个持久化 ID 的解释应当定义在 <code>Unpickler.persistent_load()</code> 中（该方法定义还原对象的过程，并返回得到的对象）。注意，<code>persistent_id()</code> 的返回值本身不能拥有持久化 ID。</p>
</li>
<li><p><code>dispatch_table</code></p>
<p>Pickler 对象的 dispatch 表是 <code>copyreg.pickle()</code> 中用到的 <em>reduction 函数</em> 的注册。dispatch 表本身是一个 class 到其 reduction 函数的映射键值对。一个 reduction 函数只接受一个参数，就是其关联的 class，函数行为应当遵守 <code>__reduce__()</code> 接口规范。</p>
<p>Pickler 对象默认并没有 <code>dispatch_table</code> 属性，该对象默认使用 <code>copyreg</code> 模块中定义的全局 dispatch 表。如果要为特定 Pickler 对象自定义序列化过程，可以将 <code>dispatch_table</code> 属性设置为类字典对象（dict-like object）。另外，如果 <code>Pickler</code> 的子类设置了 <code>dispatch_table</code> 属性，则该子类的实例会使用这个表作为默认的 dispatch 表。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>reducer_override</code>(<em>self</em>, <em>obj</em>)</p>
<p>可以在 <code>Pickler</code> 的子类中定义的特殊 reducer。此方法的优先级高于 <code>dispatch_table</code> 中的任何 reducer。它应该与 <code>__reduce__()</code> 方法遵循相同的接口，它也可以返回 <code>NotImplemented</code>，这将使用 <code>dispatch_table</code> 里注册的 reducer 来封存 <code>obj</code>。</p>
<p>3.8 新版功能.</p>
</li>
<li><p><code>fast</code></p>
<p>已弃用。设为 True 则启用快速模式。快速模式禁用了“备忘录” (memo) 的使用，即不生成多余的 PUT 操作码来加快封存过程。不应将其与自指 (self-referential) 对象一起使用，否则将导致 <code>Pickler</code> 无限递归。</p>
<p>如果需要进一步提高 pickle 的压缩率，请使用 <code>pickletools.optimize()</code>。</p>
</li>
</ul>
<p><em>class<em><code>pickle.Unpickler</code>(</em>file</em>, <em>**,</em> fix_imports=True<em>,</em> encoding=’ASCII’<em>,</em> errors=’strict’<em>,</em> buffers=None*)</p>
<p>它接受一个二进制文件用于读取 pickle 数据流。</p>
<p>Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。</p>
<p>参数 <em>file</em> 必须有三个方法，read() 方法接受一个整数参数，readinto() 方法接受一个缓冲区作为参数，readline() 方法不需要参数，这与 <code>io.BufferedIOBase</code> 里定义的接口是相同的。因此 <em>file</em> 可以是一个磁盘上用于二进制读取的文件，也可以是一个 <code>io.BytesIO</code> 实例，也可以是满足这一接口的其他任何自定义对象。</p>
<p>可选的参数是 <em>fix_imports</em>, <em>encoding</em> 和 <em>errors*，用于控制由Python 2 生成的 pickle 流的兼容性。如果 *fix_imports</em> 为 True，则 pickle 将尝试将旧的 Python 2 名称映射到 Python 3 中对应的新名称。<em>encoding</em> 和 <em>errors</em> 参数告诉 pickle 如何解码 Python 2 存储的 8 位字符串实例；这两个参数默认分别为 ‘ASCII’ 和 ‘strict’。<em>encoding</em> 参数可置为 ‘bytes’ 来将这些 8 位字符串实例读取为字节对象。读取 NumPy array 和 Python 2 存储的 <code>datetime</code>、<code>date</code> 和 <code>time</code> 实例时，请使用 <code>encoding='latin1'</code>。</p>
<p>如果 <em>buffers</em> 为 None（默认值），则反序列化所需的所有数据都必须包含在 pickle 流中。这意味着在实例化 <code>Pickler</code> 时（或调用 <code>dump()</code> 或 <code>dumps()</code> 时），参数 <em>buffer_callback</em> 为 None。</p>
<p>如果 <em>buffers</em> 不为 None，则每次 pickle 流引用 带外 缓冲区视图时，消耗的对象都应该是可迭代的启用缓冲区的对象。这样的缓冲区应该按顺序地提供给 Pickler 对象的 <em>buffer_callback</em> 方法。</p>
<p>在 3.8 版更改: 加入了 <em>buffers</em> 参数。</p>
<ul>
<li><p><code>load</code>()</p>
<p>从构造函数中指定的文件对象里读取封存好的对象，重建其中特定对象的层次结构并返回。封存对象以外的其他字节将被忽略。</p>
</li>
<li><p><code>persistent_load</code>(<em>pid</em>)</p>
<p>默认抛出 <code>UnpicklingError</code> 异常。</p>
<p>如果定义了此方法，<code>persistent_load()</code> 应当返回持久化 ID <em>pid</em> 所指定的对象。 如果遇到无效的持久化 ID，则应当引发 <code>UnpicklingError</code>。</p>
</li>
<li><p><code>find_class</code>(<em>module</em>, <em>name</em>)</p>
<p>如有必要，导入 <em>module</em> 模块并返回其中名叫 <em>name</em> 的对象，其中 <em>module</em> 和 <em>name</em> 参数都是 <code>str</code> 对象。注意，不要被这个函数的名字迷惑， <code>find_class()</code> 同样可以用来导入函数。</p>
<p>子类可以重载此方法，来控制加载对象的类型和加载对象的方式，从而尽可能降低安全风险。</p>
<p>引发一个 审计事件<code>pickle.find_class</code> 附带参数 <code>module</code>、<code>name</code>。</p>
</li>
</ul>
<p><em>class<em><code>pickle.PickleBuffer</code>(</em>buffer</em>)</p>
<p>缓冲区的包装器 (wrapper)，缓冲区中包含着可封存的数据。<em>buffer</em> 必须是一个 buffer-providing 对象，比如 bytes-like object 或多维数组。</p>
<p><code>PickleBuffer</code> 本身就可以生成缓冲区对象，因此可以将其传递给需要缓冲区生成器的其他 API，比如 <code>memoryview</code>。</p>
<p><code>PickleBuffer</code> 对象只能用 pickle 版本 5 及以上协议进行序列化。它们符合 带外序列化 的条件。</p>
<p>3.8 新版功能.</p>
<ul>
<li><p><code>raw</code>()</p>
<p>返回该缓冲区底层内存区域的 <code>memoryview</code>。 返回的对象是一维的、C 连续布局的 memoryview，格式为 <code>B</code> (无符号字节)。 如果缓冲区既不是 C 连续布局也不是 Fortran 连续布局的，则抛出 <code>BufferError</code> 异常。</p>
</li>
<li><p><code>release</code>()</p>
<p>释放由 PickleBuffer 占用的底层缓冲区。</p>
</li>
</ul>
<h3 id="可以被封存-解封的对象"><a href="#可以被封存-解封的对象" class="headerlink" title="可以被封存/解封的对象"></a>可以被封存/解封的对象</h3><p>下列类型可以被封存：</p>
<ul>
<li><code>None</code>、<code>True</code> 和 <code>False</code></li>
<li>整数、浮点数、复数</li>
<li>str、byte、bytearray</li>
<li>只包含可封存对象的集合，包括 tuple、list、set 和 dict</li>
<li>定义在模块最外层的函数（使用 <code>def</code> 定义，<code>lambda</code> 函数则不可以）</li>
<li>定义在模块最外层的内置函数</li>
<li>定义在模块最外层的类</li>
<li>某些类实例，这些类的 <code>__dict__</code> 属性值或 <code>__getstate__()</code> 函数的返回值可以被封存。</li>
</ul>
<p>尝试封存不能被封存的对象会抛出 <code>PicklingError</code> 异常，异常发生时，可能有部分字节已经被写入指定文件中。尝试封存递归层级很深的对象时，可能会超出最大递归层级限制，此时会抛出 <code>RecursionError</code> 异常，可以通过 <code>sys.setrecursionlimit()</code> 调整递归层级，不过请谨慎使用这个函数，因为可能会导致解释器崩溃。</p>
<p>注意，函数（内置函数或用户自定义函数）在被封存时，引用的是函数全名。这意味着只有函数所在的模块名，与函数名会被封存，函数体及其属性不会被封存。因此，在解封的环境中，函数所属的模块必须是可以被导入的，而且模块必须包含这个函数被封存时的名称，否则会抛出异常.</p>
<p>同样的，类也只封存名称，所以在解封环境中也有和函数相同的限制。注意，类体及其数据不会被封存，所以在下面的例子中类属性 <code>attr</code> 不会存在于解封后的环境中：</p>
<pre><code>classFoo:    attr ='A class attribute'picklestring = pickle.dumps(Foo)</code></pre><p>这些限制决定了为什么必须在一个模块的最外层定义可封存的函数和类。</p>
<p>类似的，在封存类的实例时，其类体和类数据不会跟着实例一起被封存，只有实例数据会被封存。这样设计是有目的的，在将来修复类中的错误、给类增加方法之后，仍然可以载入原来版本类实例的封存数据来还原该实例。如果你准备长期使用一个对象，可能会同时存在较多版本的类体，可以为对象添加版本号，这样就可以通过类的 <code>__setstate__()</code> 方法将老版本转换成新版本。</p>
<h3 id="封存类实例"><a href="#封存类实例" class="headerlink" title="封存类实例"></a>封存类实例</h3><p>在本节中，我们描述了可用于定义、自定义和控制如何封存和解封类实例的通用流程。</p>
<p>通常，使一个实例可被封存不需要附加任何代码。Pickle 默认会通过 Python 的内省机制获得实例的类及属性。而当实例解封时，它的 <code>__init__()</code> 方法通常 <em>不会</em> 被调用。其默认动作是：先创建一个未初始化的实例，然后还原其属性，下面的代码展示了这种行为的实现机制：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">save</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">return</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>__class__<span class="token punctuation">,</span> obj<span class="token punctuation">.</span>__dict__<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">load</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">:</span>
    obj <span class="token operator">=</span> cls<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>
    obj<span class="token punctuation">.</span>__dict__<span class="token punctuation">.</span>update<span class="token punctuation">(</span>attributes<span class="token punctuation">)</span>
<span class="token keyword">return</span> obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>类可以改变默认行为，只需定义以下一种或几种特殊方法：</p>
<p><code>object.__getnewargs_ex__</code>()</p>
<p>对于使用第 2 版或更高版协议的 pickle，实现了 <code>__getnewargs_ex__()</code> 方法的类可以控制在解封时传给 <code>__new__()</code> 方法的参数。本方法必须返回一对 <code>(args, kwargs)</code> 用于构建对象，其中 <em>args</em> 是表示位置参数的 tuple，而 <em>kwargs</em> 是表示命名参数的 dict。它们会在解封时传递给 <code>__new__()</code> 方法。</p>
<p>如果类的 <code>__new__()</code> 方法只接受关键字参数，则应当实现这个方法。否则，为了兼容性，更推荐实现 <code>__getnewargs__()</code> 方法。</p>
<p>在 3.6 版更改: <code>__getnewargs_ex__()</code> 现在可用于第 2 和第 3 版协议。</p>
<p><code>object.__getnewargs__</code>()</p>
<p>这个方法与上一个 <code>__getnewargs_ex__()</code> 方法类似，但仅支持位置参数。它要求返回一个 tuple 类型的 <code>args</code>，用于解封时传递给 <code>__new__()</code> 方法。</p>
<p>如果定义了 <code>__getnewargs_ex__()</code>，那么 <code>__getnewargs__()</code> 就不会被调用。</p>
<p>在 3.6 版更改: 在 Python 3.6 前，第 2、3 版协议会调用 <code>__getnewargs__()</code>，更高版本协议会调用 <code>__getnewargs_ex__()</code>。</p>
<p><code>object.__getstate__</code>()</p>
<p>类还可以进一步控制其实例的封存过程。如果类定义了 <code>__getstate__()</code>，它就会被调用，其返回的对象是被当做实例内容来封存的，否则封存的是实例的 <strong>dict</strong>。如果 <code>__getstate__()</code> 未定义，实例的 <code>__dict__</code> 会被照常封存。</p>
<p><code>object.__setstate__</code>(<em>state</em>)</p>
<p>当解封时，如果类定义了 <code>__setstate__()</code>，就会在已解封状态下调用它。此时不要求实例的 state 对象必须是 dict。没有定义此方法的话，先前封存的 state 对象必须是 dict，且该 dict 内容会在解封时赋给新实例的 <strong>dict</strong>。</p>
<p>注解</p>
<p>如果 <code>__getstate__()</code> 返回 False，那么在解封时就不会调用 <code>__setstate__()</code> 方法。</p>
<p>注解</p>
<p>在解封时，实例的某些方法例如 <code>__getattr__()</code>, <code>__getattribute__()</code> 或 <code>__setattr__()</code> 可能会被调用。 由于这些方法可能要求某些内部不变量为真值，因此该类型应当实现 <code>__new__()</code> 以建立这样的不变量，因为当解封一个实例时 <code>__init__()</code> 并不会被调用。</p>
<p>可以看出，其实 pickle 并不直接调用上面的几个函数。事实上，这几个函数是复制协议的一部分，它们实现了 <code>__reduce__()</code> 这一特殊接口。复制协议提供了统一的接口，用于在封存或复制对象的过程中取得所需数据.</p>
<p>尽管这个协议功能很强，但是直接在类中实现 <code>__reduce__()</code> 接口容易产生错误。因此，设计类时应当尽可能的使用高级接口（比如 <code>__getnewargs_ex__()</code>、<code>__getstate__()</code> 和 <code>__setstate__()</code>）。后面仍然可以看到直接实现 <code>__reduce__()</code> 接口的状况，可能别无他法，可能为了获得更好的性能，或者两者皆有之。</p>
<p><code>object.__reduce__</code>()</p>
<p>该接口当前定义如下。<code>__reduce__()</code> 方法不带任何参数，并且应返回字符串或最好返回一个元组（返回的对象通常称为“reduce 值”）。</p>
<p>如果返回字符串，该字符串会被当做一个全局变量的名称。它应该是对象相对于其模块的本地名称，pickle 模块会搜索模块命名空间来确定对象所属的模块。这种行为常在单例模式使用。</p>
<p>如果返回的是元组，则应当包含 2 到 6 个元素，可选元素可以省略或设置为 <code>None</code>。每个元素代表的意义如下：</p>
<ul>
<li><p>一个可调用对象，该对象会在创建对象的最初版本时调用。</p>
</li>
<li><p>可调用对象的参数，是一个元组。如果可调用对象不接受参数，必须提供一个空元组。</p>
</li>
<li><p>可选元素，用于表示对象的状态，将被传给前述的 <code>__setstate__()</code> 方法。 如果对象没有此方法，则这个元素必须是字典类型，并会被添加至 <code>__dict__</code> 属性中。</p>
</li>
<li><p>可选元素，一个返回连续项的迭代器（而不是序列）。这些项会被 <code>obj.append(item)</code> 逐个加入对象，或被 <code>obj.extend(list_of_items)</code> 批量加入对象。这个元素主要用于 list 的子类，也可以用于那些正确实现了 <code>append()</code> 和 <code>extend()</code> 方法的类。（具体是使用 <code>append()</code> 还是 <code>extend()</code> 取决于 pickle 协议版本以及待插入元素的项数，所以这两个方法必须同时被类支持。）</p>
</li>
<li><p>可选元素，一个返回连续键值对的迭代器（而不是序列）。这些键值对将会以 <code>obj[key] = value</code> 的方式存储于对象中。该元素主要用于 dict 子类，也可以用于那些实现了 <code>__setitem__()</code> 的类。</p>
</li>
<li><p>可选元素，一个带有 <code>(obj, state)</code> 签名的可调用对象。该可调用对象允许用户以编程方式控制特定对象的状态更新行为，而不是使用 <code>obj</code> 的静态 <code>__setstate__()</code> 方法。如果此处不是 <code>None</code>，则此可调用对象的优先级高于 <code>obj</code> 的 <code>__setstate__()</code>。</p>
<p>3.8 新版功能: 新增了元组的第 6 项，可选元素 <code>(obj, state)</code>。</p>
</li>
</ul>
<p><code>object.__reduce_ex__</code>(<em>protocol</em>)</p>
<p>作为替代选项，也可以实现 <code>__reduce_ex__()</code> 方法。 此方法的唯一不同之处在于它应接受一个整型参数用于指定协议版本。 如果定义了这个函数，则会覆盖 <code>__reduce__()</code> 的行为。 此外，<code>__reduce__()</code> 方法会自动成为扩展版方法的同义词。 这个函数主要用于为以前的 Python 版本提供向后兼容的 reduce 值。</p>
<h4 id="持久化外部对象"><a href="#持久化外部对象" class="headerlink" title="持久化外部对象"></a>持久化外部对象</h4><p>为了获取对象持久化的利益， <code>pickle</code> 模块支持引用已封存数据流之外的对象。 这样的对象是通过一个持久化 ID 来引用的，它应当是一个由字母数字类字符组成的字符串 (对于第 0 版协议) 或是一个任意对象 (用于任意新版协议)。</p>
<p><code>pickle</code> 模块不提供对持久化 ID 的解析工作，它将解析工作分配给用户定义的方法，分别是 pickler 中的 <code>persistent_id()</code> 方法和 unpickler 中的 <code>persistent_load()</code> 方法。</p>
<p>要通过持久化 ID 将外部对象封存，必须在 pickler 中实现 <code>persistent_id()</code> 方法，该方法接受需要被封存的对象作为参数，返回一个 <code>None</code> 或返回该对象的持久化 ID。如果返回 <code>None</code>，该对象会被按照默认方式封存为数据流。如果返回字符串形式的持久化 ID，则会封存这个字符串并加上一个标记，这样 unpickler 才能将其识别为持久化 ID。</p>
<p>要解封外部对象，Unpickler 必须实现 <code>persistent_load()</code> 方法，接受一个持久化 ID 对象作为参数并返回一个引用的对象。</p>
<p>下面是一个全面的例子，展示了如何使用持久化 ID 来封存外部对象。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Simple example presenting how persistent ID can be used to pickle</span>
<span class="token comment" spellcheck="true"># external objects by reference.</span>
<span class="token keyword">import</span> pickle
<span class="token keyword">import</span> sqlite3
<span class="token keyword">from</span> collections <span class="token keyword">import</span> namedtuple
<span class="token comment" spellcheck="true"># Simple class representing a record in our database.</span>
MemoRecord<span class="token operator">=</span> namedtuple<span class="token punctuation">(</span><span class="token string">"MemoRecord"</span><span class="token punctuation">,</span><span class="token string">"key, task"</span><span class="token punctuation">)</span>
classDBPickler<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>Pickler<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">persistent_id</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Instead of pickling MemoRecord as a regular class instance, we emit a</span>
<span class="token comment" spellcheck="true"># persistent ID.</span>
<span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>obj<span class="token punctuation">,</span>MemoRecord<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Here, our persistent ID is simply a tuple, containing a tag and a</span>
<span class="token comment" spellcheck="true"># key, which refers to a specific record in the database.</span>
<span class="token keyword">return</span><span class="token punctuation">(</span><span class="token string">"MemoRecord"</span><span class="token punctuation">,</span> obj<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># If obj does not have a persistent ID, return None. This means obj</span>
<span class="token comment" spellcheck="true"># needs to be pickled as usual.</span>
returnNone
classDBUnpickler<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>Unpickler<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> file<span class="token punctuation">,</span> connection<span class="token punctuation">)</span><span class="token punctuation">:</span>
super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>file<span class="token punctuation">)</span>
self<span class="token punctuation">.</span>connection <span class="token operator">=</span> connection
<span class="token keyword">def</span> <span class="token function">persistent_load</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pid<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># This method is invoked whenever a persistent ID is encountered.</span>
<span class="token comment" spellcheck="true"># Here, pid is the tuple returned by DBPickler.</span>
        cursor <span class="token operator">=</span>self<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
        type_tag<span class="token punctuation">,</span> key_id <span class="token operator">=</span> pid
<span class="token keyword">if</span> type_tag <span class="token operator">==</span><span class="token string">"MemoRecord"</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Fetch the referenced record from the database and return it.</span>
            cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"SELECT * FROM memos WHERE key=?"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>str<span class="token punctuation">(</span>key_id<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            key<span class="token punctuation">,</span> task <span class="token operator">=</span> cursor<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span>
returnMemoRecord<span class="token punctuation">(</span>key<span class="token punctuation">,</span> task<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Always raises an error if you cannot return the correct object.</span>
<span class="token comment" spellcheck="true"># Otherwise, the unpickler will think None is the object referenced</span>
<span class="token comment" spellcheck="true"># by the persistent ID.</span>
<span class="token keyword">raise</span> pickle<span class="token punctuation">.</span>UnpicklingError<span class="token punctuation">(</span><span class="token string">"unsupported persistent object"</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">import</span> io
<span class="token keyword">import</span> pprint
<span class="token comment" spellcheck="true"># Initialize and populate our database.</span>
    conn <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
    cursor <span class="token operator">=</span> conn<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
    cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)"</span><span class="token punctuation">)</span>
    tasks <span class="token operator">=</span><span class="token punctuation">(</span>
<span class="token string">'give food to fish'</span><span class="token punctuation">,</span>
<span class="token string">'prepare group meeting'</span><span class="token punctuation">,</span>
<span class="token string">'fight with a zebra'</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
<span class="token keyword">for</span> task <span class="token keyword">in</span> tasks<span class="token punctuation">:</span>
        cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"INSERT INTO memos VALUES(NULL, ?)"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Fetch the records to be pickled.</span>
    cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"SELECT * FROM memos"</span><span class="token punctuation">)</span>
    memos <span class="token operator">=</span><span class="token punctuation">[</span>MemoRecord<span class="token punctuation">(</span>key<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token keyword">for</span> key<span class="token punctuation">,</span> task <span class="token keyword">in</span> cursor<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># Save the records using our custom DBPickler.</span>
    file <span class="token operator">=</span> io<span class="token punctuation">.</span>BytesIO<span class="token punctuation">(</span><span class="token punctuation">)</span>
DBPickler<span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">.</span>dump<span class="token punctuation">(</span>memos<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Pickled records:"</span><span class="token punctuation">)</span>
    pprint<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>memos<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Update a record, just for good measure.</span>
    cursor<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"UPDATE memos SET task='learn italian' WHERE key=1"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Load the records from the pickle data stream.</span>
    file<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
    memos <span class="token operator">=</span>DBUnpickler<span class="token punctuation">(</span>file<span class="token punctuation">,</span> conn<span class="token punctuation">)</span><span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Unpickled records:"</span><span class="token punctuation">)</span>
    pprint<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>memos<span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>
    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Dispatch-表"><a href="#Dispatch-表" class="headerlink" title="Dispatch 表"></a>Dispatch 表</h4><p>如果想对某些类进行自定义封存，而又不想在类中增加用于封存的代码，就可以创建带有特殊 dispatch 表的 pickler。</p>
<p>在 <code>copyreg</code> 模块的 <code>copyreg.dispatch_table</code> 中定义了全局 dispatch 表。因此，可以使用 <code>copyreg.dispatch_table</code> 修改后的副本作为自有 dispatch 表。</p>
<p>例如</p>
<pre class="line-numbers language-python"><code class="language-python">f <span class="token operator">=</span> io<span class="token punctuation">.</span>BytesIO<span class="token punctuation">(</span><span class="token punctuation">)</span>
p <span class="token operator">=</span> pickle<span class="token punctuation">.</span>Pickler<span class="token punctuation">(</span>f<span class="token punctuation">)</span>
p<span class="token punctuation">.</span>dispatch_table <span class="token operator">=</span> copyreg<span class="token punctuation">.</span>dispatch_table<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>dispatch_table<span class="token punctuation">[</span>SomeClass<span class="token punctuation">]</span><span class="token operator">=</span> reduce_SomeClass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建了一个带有自有 dispatch 表的 <code>pickle.Pickler</code> 实例，它可以对 <code>SomeClass</code> 类进行特殊处理。另外，下列代码</p>
<pre class="line-numbers language-python"><code class="language-python">classMyPickler<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>Pickler<span class="token punctuation">)</span><span class="token punctuation">:</span>
    dispatch_table <span class="token operator">=</span> copyreg<span class="token punctuation">.</span>dispatch_table<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
    dispatch_table<span class="token punctuation">[</span>SomeClass<span class="token punctuation">]</span><span class="token operator">=</span> reduce_SomeClass
f <span class="token operator">=</span> io<span class="token punctuation">.</span>BytesIO<span class="token punctuation">(</span><span class="token punctuation">)</span>
p <span class="token operator">=</span>MyPickler<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>完成了相同的操作，但所有 <code>MyPickler</code> 的实例都会共用同一份 dispatch 表。使用 <code>copyreg</code> 模块实现的等效代码是</p>
<pre class="line-numbers language-python"><code class="language-python">copyreg<span class="token punctuation">.</span>pickle<span class="token punctuation">(</span>SomeClass<span class="token punctuation">,</span> reduce_SomeClass<span class="token punctuation">)</span>
f <span class="token operator">=</span> io<span class="token punctuation">.</span>BytesIO<span class="token punctuation">(</span><span class="token punctuation">)</span>
p <span class="token operator">=</span> pickle<span class="token punctuation">.</span>Pickler<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="处理有状态的对象"><a href="#处理有状态的对象" class="headerlink" title="处理有状态的对象"></a>处理有状态的对象</h4><p>下面的示例展示了如何修改类在封存时的行为。其中 <code>TextReader</code> 类打开了一个文本文件，每次调用其 <code>readline()</code> 方法则返回行号和该行的字符。 在封存这个 <code>TextReader</code> 的实例时，<em>除了</em> 文件对象，其他属性都会被保存。 当解封实例时，需要重新打开文件，然后从上次的位置开始继续读取。实现这些功能需要实现 <code>__setstate__()</code> 和 <code>__getstate__()</code> 方法。</p>
<pre class="line-numbers language-python"><code class="language-python">classTextReader<span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""Print and number lines in a text file."""</span>
<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">:</span>
self<span class="token punctuation">.</span>filename <span class="token operator">=</span> filename
self<span class="token punctuation">.</span>file <span class="token operator">=</span> open<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>
self<span class="token punctuation">.</span>lineno <span class="token operator">=</span><span class="token number">0</span>
<span class="token keyword">def</span> <span class="token function">readline</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
self<span class="token punctuation">.</span>lineno <span class="token operator">+=</span><span class="token number">1</span>
        line <span class="token operator">=</span>self<span class="token punctuation">.</span>file<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
ifnot line<span class="token punctuation">:</span>
returnNone
<span class="token keyword">if</span> line<span class="token punctuation">.</span>endswith<span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            line <span class="token operator">=</span> line<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token keyword">return</span><span class="token string">"%i: %s"</span><span class="token operator">%</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>lineno<span class="token punctuation">,</span> line<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">__getstate__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Copy the object's state from self.__dict__ which contains</span>
<span class="token comment" spellcheck="true"># all our instance attributes. Always use the dict.copy()</span>
<span class="token comment" spellcheck="true"># method to avoid modifying the original state.</span>
        state <span class="token operator">=</span>self<span class="token punctuation">.</span>__dict__<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Remove the unpicklable entries.</span>
<span class="token keyword">del</span> state<span class="token punctuation">[</span><span class="token string">'file'</span><span class="token punctuation">]</span>
<span class="token keyword">return</span> state
<span class="token keyword">def</span> <span class="token function">__setstate__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Restore instance attributes (i.e., filename and lineno).</span>
self<span class="token punctuation">.</span>__dict__<span class="token punctuation">.</span>update<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Restore the previously opened file's state. To do so, we need to</span>
<span class="token comment" spellcheck="true"># reopen it and read from it until the line count is restored.</span>
        file <span class="token operator">=</span> open<span class="token punctuation">(</span>self<span class="token punctuation">.</span>filename<span class="token punctuation">)</span>
<span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>self<span class="token punctuation">.</span>lineno<span class="token punctuation">)</span><span class="token punctuation">:</span>
            file<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Finally, save the file.</span>
self<span class="token punctuation">.</span>file <span class="token operator">=</span> file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用方法如下所示：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> reader <span class="token operator">=</span>TextReader<span class="token punctuation">(</span><span class="token string">"hello.txt"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> reader<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'1: Hello world!'</span>
<span class="token operator">>></span><span class="token operator">></span> reader<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'2: I am line number two.'</span>
<span class="token operator">>></span><span class="token operator">></span> new_reader <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>reader<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> new_reader<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'3: Goodbye!'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="类型，函数和其他对象的自定义归约"><a href="#类型，函数和其他对象的自定义归约" class="headerlink" title="类型，函数和其他对象的自定义归约"></a>类型，函数和其他对象的自定义归约</h3><p>3.8 新版功能.</p>
<p>有时，<code>dispatch_table</code> 可能不够灵活。 特别是当我们想要基于对象类型以外的其他规则来对封存进行定制，或是当我们想要对函数和类的封存进行定制的时候。</p>
<p>对于那些情况，可能要基于 <code>Pickler</code> 类进行子类化并实现 <code>reducer_override()</code> 方法。 此方法可返回任意的归约元组 (参见 <code>__reduce__()</code>)。 它也可以选择返回 <code>NotImplemented</code> 来回退到传统行为。</p>
<p>如果同时定义了 <code>dispatch_table</code> 和 <code>reducer_override()</code>，则 <code>reducer_override()</code> 方法具有优先权。</p>
<p>注解</p>
<p>出于性能理由，可能不会为以下对象调用 <code>reducer_override()</code>: <code>None</code>, <code>True</code>, <code>False</code>, 以及 <code>int</code>, <code>float</code>, <code>bytes</code>, <code>str</code>, <code>dict</code>, <code>set</code>, <code>frozenset</code>, <code>list</code> 和 <code>tuple</code> 的具体实例。</p>
<p>以下是一个简单的例子，其中我们允许封存并重新构建一个给定的类:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> io
<span class="token keyword">import</span> pickle
classMyClass<span class="token punctuation">:</span>
    my_attribute <span class="token operator">=</span><span class="token number">1</span>
classMyPickler<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>Pickler<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">reducer_override</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""Custom reducer for MyClass."""</span>
<span class="token keyword">if</span> getattr<span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token string">"__name__"</span><span class="token punctuation">,</span>None<span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">"MyClass"</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> type<span class="token punctuation">,</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span> obj<span class="token punctuation">.</span>__bases__<span class="token punctuation">,</span>
<span class="token punctuation">{</span><span class="token string">'my_attribute'</span><span class="token punctuation">:</span> obj<span class="token punctuation">.</span>my_attribute<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># For any other object, fallback to usual reduction</span>
returnNotImplemented
f <span class="token operator">=</span> io<span class="token punctuation">.</span>BytesIO<span class="token punctuation">(</span><span class="token punctuation">)</span>
p <span class="token operator">=</span>MyPickler<span class="token punctuation">(</span>f<span class="token punctuation">)</span>
p<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>MyClass<span class="token punctuation">)</span>
delMyClass
unpickled_class <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>f<span class="token punctuation">.</span>getvalue<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">assert</span> isinstance<span class="token punctuation">(</span>unpickled_class<span class="token punctuation">,</span> type<span class="token punctuation">)</span>
<span class="token keyword">assert</span> unpickled_class<span class="token punctuation">.</span>__name__ <span class="token operator">==</span><span class="token string">"MyClass"</span>
<span class="token keyword">assert</span> unpickled_class<span class="token punctuation">.</span>my_attribute <span class="token operator">==</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="外部缓冲区"><a href="#外部缓冲区" class="headerlink" title="外部缓冲区"></a>外部缓冲区</h3><p>3.8 新版功能.</p>
<p>在某些场景中，<code>pickle</code> 模块会被用来传输海量的数据。 因此，最小化内存复制次数以保证性能和节省资源是很重要的。 但是 <code>pickle</code> 模块的正常运作会将图类对象结构转换为字节序列流，因此在本质上就要从封存流中来回复制数据。</p>
<p>如果 <em>provider</em> (待传输对象类型的实现) 和 <em>consumer</em> (通信系统的实现) 都支持 pickle 第 5 版或更高版本所提供的外部传输功能，则此约束可以被撤销。</p>
<h4 id="提供方-API"><a href="#提供方-API" class="headerlink" title="提供方 API"></a>提供方 API</h4><p>大的待封存数据对象必须实现协议 5 及以上版本专属的 <code>__reduce_ex__()</code> 方法，该方法将为任意大的数据返回一个 <code>PickleBuffer</code> 实例（而不是 <code>bytes</code> 对象等）。</p>
<p><code>PickleBuffer</code> 对象会 <em>表明</em> 底层缓冲区可被用于外部数据传输。 那些对象仍将保持与 <code>pickle</code> 模块的正常用法兼容。 但是，使用方也可以选择告知 <code>pickle</code> 它们将自行处理那些缓冲区。</p>
<h4 id="使用方-API"><a href="#使用方-API" class="headerlink" title="使用方 API"></a>使用方 API</h4><p>当序列化一个对象图时，通信系统可以启用对所生成 <code>PickleBuffer</code> 对象的定制处理。</p>
<p>发送端需要传递 <em>buffer_callback</em> 参数到 <code>Pickler</code> (或是到 <code>dump()</code> 或 <code>dumps()</code> 函数)，该回调函数将在封存对象图时附带每个所生成的 <code>PickleBuffer</code> 被调用。 由 <em>buffer_callback</em> 所累积的缓冲区的数据将不会被拷贝到 pickle 流，而是仅插入一个简单的标记。</p>
<p>接收端需要传递 <em>buffers</em> 参数到 <code>Unpickler</code> (或是到 <code>load()</code> 或 <code>loads()</code> 函数)，其值是一个由缓冲区组成的可迭代对象，它会被传递给 <em>buffer_callback*。 该可迭代对象应当按其被传递给 *buffer_callback</em> 时的顺序产生缓冲区。 这些缓冲区将提供对象重构造器所期望的数据，对这些数据的封存产生了原本的 <code>PickleBuffer</code> 对象。</p>
<p>在发送端和接受端之间，通信系统可以自由地实现它自己用于外部缓冲区的传输机制。 潜在的优化包括使用共享内存或基于特定数据类型的压缩等。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>下面是一个小例子，在其中我们实现了一个 <code>bytearray</code> 的子类，能够用于外部缓冲区封存:</p>
<pre class="line-numbers language-python"><code class="language-python">classZeroCopyByteArray<span class="token punctuation">(</span>bytearray<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">__reduce_ex__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> protocol <span class="token operator">>=</span><span class="token number">5</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> type<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>_reconstruct<span class="token punctuation">,</span><span class="token punctuation">(</span>PickleBuffer<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>None
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># PickleBuffer is forbidden with pickle protocols &lt;= 4.</span>
<span class="token keyword">return</span> type<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>_reconstruct<span class="token punctuation">,</span><span class="token punctuation">(</span>bytearray<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span>
@classmethod
<span class="token keyword">def</span> <span class="token function">_reconstruct</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">with</span> memoryview<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token keyword">as</span> m<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Get a handle over the original buffer object</span>
            obj <span class="token operator">=</span> m<span class="token punctuation">.</span>obj
<span class="token keyword">if</span> type<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token keyword">is</span> cls<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Original buffer object is a ZeroCopyByteArray, return it</span>
<span class="token comment" spellcheck="true"># as-is.</span>
<span class="token keyword">return</span> obj
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> cls<span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>重构造器 (<code>_reconstruct</code> 类方法) 会在缓冲区的提供对象具有正确类型时返回该对象。 在此小示例中这是模拟零拷贝行为的便捷方式。</p>
<p>在使用方，我们可以按通常方式封存那些对象，它们在反序列化时将提供原始对象的一个副本:</p>
<pre class="line-numbers language-python"><code class="language-python">b <span class="token operator">=</span>ZeroCopyByteArray<span class="token punctuation">(</span>b<span class="token string">"abc"</span><span class="token punctuation">)</span>
data <span class="token operator">=</span> pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>b<span class="token punctuation">,</span> protocol<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span>
new_b <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>b <span class="token operator">==</span> new_b<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># True</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>b <span class="token keyword">is</span> new_b<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># False: a copy was made</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是如果我们传入 <em>buffer_callback</em> 然后在反序列化时给回累积的缓冲区，我们就能够取回原始对象:</p>
<pre class="line-numbers language-python"><code class="language-python">b <span class="token operator">=</span>ZeroCopyByteArray<span class="token punctuation">(</span>b<span class="token string">"abc"</span><span class="token punctuation">)</span>
buffers <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
data <span class="token operator">=</span> pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>b<span class="token punctuation">,</span> protocol<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> buffer_callback<span class="token operator">=</span>buffers<span class="token punctuation">.</span>append<span class="token punctuation">)</span>
new_b <span class="token operator">=</span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>data<span class="token punctuation">,</span> buffers<span class="token operator">=</span>buffers<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>b <span class="token operator">==</span> new_b<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># True</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>b <span class="token keyword">is</span> new_b<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># True: no copy was made</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个例子受限于 <code>bytearray</code> 会自行分配内存这一事实：你无法基于另一个对象的内存创建 <code>bytearray</code> 的实例。 但是，第三方数据类型例如 NumPy 数组则没有这种限制，允许在单独进程或系统间传输时使用零拷贝的封存（或是尽可能少地拷贝） 。</p>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0574" target="_blank" rel="noopener"><strong>PEP 574</strong></a> — 带有外部数据缓冲区的 pickle 协议 5</p>
<h3 id="限制全局变量"><a href="#限制全局变量" class="headerlink" title="限制全局变量"></a>限制全局变量</h3><p>默认情况下，解封将会导入在 pickle 数据中找到的任何类或函数。 对于许多应用来说，此行为是不可接受的，因为它会允许解封器导入并发起调用任意代码。 只须考虑当这个手工构建的 pickle 数据流被加载时会做什么:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span><span class="token keyword">import</span> pickle
<span class="token operator">>></span><span class="token operator">></span> pickle<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>b<span class="token string">"cos\nsystem\n(S'echo hello world'\ntR."</span><span class="token punctuation">)</span>
hello world
<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个例子里，解封器导入 <code>os.system()</code> 函数然后应用字符串参数 “echo hello world”。 虽然这个例子不具攻击性，但是不难想象别人能够通过此方式对你的系统造成损害。</p>
<p>出于这样的理由，你可能会希望通过定制 <code>Unpickler.find_class()</code> 来控制要解封的对象。 与其名称所提示的不同，<code>Unpickler.find_class()</code> 会在执行对任何全局对象（例如一个类或一个函数）的请求时被调用。 因此可以完全禁止全局对象或是将它们限制在一个安全的子集中。</p>
<p>下面的例子是一个解封器，它只允许某一些安全的来自 <code>builtins</code> 模块的类被加载:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> builtins
<span class="token keyword">import</span> io
<span class="token keyword">import</span> pickle
safe_builtins <span class="token operator">=</span><span class="token punctuation">{</span>
<span class="token string">'range'</span><span class="token punctuation">,</span>
<span class="token string">'complex'</span><span class="token punctuation">,</span>
<span class="token string">'set'</span><span class="token punctuation">,</span>
<span class="token string">'frozenset'</span><span class="token punctuation">,</span>
<span class="token string">'slice'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
classRestrictedUnpickler<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>Unpickler<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">def</span> <span class="token function">find_class</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>module<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Only allow safe classes from builtins.</span>
ifmodule<span class="token operator">==</span><span class="token string">"builtins"</span><span class="token operator">and</span> name <span class="token keyword">in</span> safe_builtins<span class="token punctuation">:</span>
<span class="token keyword">return</span> getattr<span class="token punctuation">(</span>builtins<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Forbid everything else.</span>
<span class="token keyword">raise</span> pickle<span class="token punctuation">.</span>UnpicklingError<span class="token punctuation">(</span><span class="token string">"global '%s.%s' is forbidden"</span><span class="token operator">%</span>
<span class="token punctuation">(</span>module<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">restricted_loads</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""Helper function analogous to pickle.loads()."""</span>
returnRestrictedUnpickler<span class="token punctuation">(</span>io<span class="token punctuation">.</span>BytesIO<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们这个解封器的一个示例用法所达成的目标:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> restricted_loads<span class="token punctuation">(</span>pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> restricted_loads<span class="token punctuation">(</span>b<span class="token string">"cos\nsystem\n(S'echo hello world'\ntR."</span><span class="token punctuation">)</span>
Traceback<span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
pickle<span class="token punctuation">.</span>UnpicklingError<span class="token punctuation">:</span><span class="token keyword">global</span><span class="token string">'os.system'</span><span class="token keyword">is</span> forbidden
<span class="token operator">>></span><span class="token operator">></span> restricted_loads<span class="token punctuation">(</span>b<span class="token string">'cbuiltins\neval\n'</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                  b<span class="token string">'(S\'getattr(__import__("os"), "system")'</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                  b<span class="token string">'("echo hello world")\'\ntR.'</span><span class="token punctuation">)</span>
Traceback<span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
pickle<span class="token punctuation">.</span>UnpicklingError<span class="token punctuation">:</span><span class="token keyword">global</span><span class="token string">'builtins.eval'</span><span class="token keyword">is</span> forbidden<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>正如我们这个例子所显示的，对于允许解封的对象你必须要保持谨慎。 因此如果要保证安全，你可以考虑其他选择例如 <code>xmlrpc.client</code> 中的编组 API 或是第三方解决方案。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>较新版本的 pickle 协议（第 2 版或更高）具有针对某些常见特性和内置类型的高效二进制编码格式。 此外，<code>pickle</code> 模块还拥有一个以 C 编写的透明优化器。</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>对于最简单的代码，请使用 <code>dump()</code> 和 <code>load()</code> 函数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> pickle
<span class="token comment" spellcheck="true"># An arbitrary collection of objects supported by pickle.</span>
data <span class="token operator">=</span><span class="token punctuation">{</span>
<span class="token string">'a'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2.0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token operator">+</span><span class="token number">6j</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token string">'b'</span><span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token string">"character string"</span><span class="token punctuation">,</span> b<span class="token string">"byte string"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token string">'c'</span><span class="token punctuation">:</span><span class="token punctuation">{</span>None<span class="token punctuation">,</span><span class="token boolean">True</span><span class="token punctuation">,</span><span class="token boolean">False</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'data.pickle'</span><span class="token punctuation">,</span><span class="token string">'wb'</span><span class="token punctuation">)</span><span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Pickle the 'data' dictionary using the highest protocol available.</span>
    pickle<span class="token punctuation">.</span>dump<span class="token punctuation">(</span>data<span class="token punctuation">,</span> f<span class="token punctuation">,</span> pickle<span class="token punctuation">.</span>HIGHEST_PROTOCOL<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以下示例读取之前封存的数据。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> pickle
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'data.pickle'</span><span class="token punctuation">,</span><span class="token string">'rb'</span><span class="token punctuation">)</span><span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># The protocol version used is detected automatically, so we do not</span>
<span class="token comment" spellcheck="true"># have to specify it.</span>
    data <span class="token operator">=</span> pickle<span class="token punctuation">.</span>load<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="copyreg-—-注册配合-pickle-模块使用的函数"><a href="#copyreg-—-注册配合-pickle-模块使用的函数" class="headerlink" title="copyreg —- 注册配合 pickle 模块使用的函数"></a><code>copyreg</code> —- 注册配合 <code>pickle</code> 模块使用的函数</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/copyreg.py" target="_blank" rel="noopener">Lib/copyreg.py</a></p>
<hr>
<p><code>copyreg</code> 模块提供了可在封存特定对象时使用的一种定义函数方式。 <code>pickle</code> 和 <code>copy</code> 模块会在封存/拷贝特定对象时使用这些函数。 此模块提供了非类对象构造器的相关配置信息。 这样的构造器可以是工厂函数或类实例。</p>
<p><code>copyreg.constructor</code>(<em>object</em>)</p>
<p>将 <em>object</em> 声明为一个有效的构造器。 如果 <em>object</em> 是不可调用的（因而不是一个有效的构造器）则会引发 <code>TypeError</code>。</p>
<p><code>copyreg.pickle</code>(<em>type</em>, <em>function</em>, <em>constructor=None</em>)</p>
<p>声明该 <em>function</em> 应当被用作 <em>type</em> 类型对象的“归约函数”。 <em>function</em> 应当返回字符串或包含两到三个元素的元组。</p>
<p>如果提供了可选的 <em>constructor</em> 形参，它应当是一个可用来重建相应对象的可调用对象，在调用该对象时应传入由 <em>function</em> 所返回的参数元组。 如果 <em>object</em> 是一个类或 <em>constructor</em> 是不可调用的则将引发 <code>TypeError</code>。</p>
<p>请查看 <code>pickle</code> 模块了解 <em>function</em> 和 <em>constructor</em> 所要求的接口的详情。 请注意一个 pickler 对象或 <code>pickle.Pickler</code> 的子类的 <code>dispatch_table</code> 属性也可以被用来声明归约函数。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>以下示例将会显示如何注册一个封存函数，以及如何来使用它：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> copyreg<span class="token punctuation">,</span> copy<span class="token punctuation">,</span> pickle
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>a <span class="token operator">=</span> a
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">pickle_c</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"pickling a C instance..."</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> C<span class="token punctuation">,</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span>a<span class="token punctuation">,</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> copyreg<span class="token punctuation">.</span>pickle<span class="token punctuation">(</span>C<span class="token punctuation">,</span> pickle_c<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> C<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>c<span class="token punctuation">)</span>  
pickling a C instance<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> pickle<span class="token punctuation">.</span>dumps<span class="token punctuation">(</span>c<span class="token punctuation">)</span>  
pickling a C instance<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="shelve-—-Python-对象持久化"><a href="#shelve-—-Python-对象持久化" class="headerlink" title="shelve —- Python 对象持久化"></a><code>shelve</code> —- Python 对象持久化</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/shelve.py" target="_blank" rel="noopener">Lib/shelve.py</a></p>
<hr>
<p>“Shelf” 是一种持久化的类似字典的对象。 与 “dbm” 数据库的区别在于 Shelf 中的值（不是键！）实际上可以为任意 Python 对象 —- 即 <code>pickle</code> 模块能够处理的任何东西。 这包括大部分类实例、递归数据类型，以及包含大量共享子对象的对象。 键则为普通的字符串。</p>
<p><code>shelve.open</code>(<em>filename</em>, <em>flag=’c’</em>, <em>protocol=None</em>, <em>writeback=False</em>)</p>
<p>打开一个持久化字典。 filename 指定下层数据库的基准文件名。 作为附带效果，会为 filename 添加一个扩展名并且可能创建更多的文件。 默认情况下，下层数据库会以读写模式打开。 可选的 <em>flag</em> 形参具有与 <code>dbm.open()</code> <em>flag</em> 形参相同的含义。</p>
<p>在默认情况下，会使用以 <code>pickle.DEFAULT_PROTOCOL</code> 创建的 pickle 来序列化值。 pickle 协议的版本可通过 <em>protocol</em> 形参来指定。</p>
<p>由于 Python 语义的限制，Shelf 对象无法确定一个可变的持久化字典条目在何时被修改。 默认情况下 <em>只有</em> 在被修改对象再赋值给 shelf 时才会写入该对象。 如果可选的 <em>writeback</em> 形参设为 <code>True</code>，则所有被访问的条目都将在内存中被缓存，并会在 <code>sync()</code> 和 <code>close()</code> 时被写入；这可以使得对持久化字典中可变条目的修改更方便，但是如果访问的条目很多，这会消耗大量内存作为缓存，并会使得关闭操作变得非常缓慢，因为所有被访问的条目都需要写回到字典（无法确定被访问的条目中哪个是可变的，也无法确定哪个被实际修改了）。</p>
<p>在 3.10 版更改: <code>pickle.DEFAULT_PROTOCOL</code> 现在会被用作默认的 pickle 协议。</p>
<p>注解</p>
<p>请不要依赖于 Shelf 的自动关闭功能；当你不再需要时应当总是显式地调用 <code>close()</code>，或者使用 <code>shelve.open()</code> 作为上下文管理器:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> shelve<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> db<span class="token punctuation">:</span>
    db<span class="token punctuation">[</span><span class="token string">'eggs'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'eggs'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>警告</p>
<p>由于 <code>shelve</code> 模块需要 <code>pickle</code> 的支持，因此从不可靠的来源载入 shelf 是不安全的。 与 pickle 一样，载入 Shelf 时可以执行任意代码。</p>
<p>Shelf 对象支持字典所支持的大多数方法和运算（除了拷贝、构造器以及 <code>|</code> 和 <code>|=</code> 运算符）。 这样就能方便地将基于字典的脚本转换为要求持久化存储的脚本。</p>
<p>额外支持的两个方法：</p>
<p><code>Shelf.sync</code>()</p>
<p>如果 Shelf 打开时将 <em>writeback</em> 设为 <code>True</code> 则写回缓存中的所有条目。 如果可行还会清空缓存并将持久化字典同步到磁盘。 此方法会在使用 <code>close()</code> 关闭 Shelf 时自动被调用。</p>
<p><code>Shelf.close</code>()</p>
<p>同步并关闭持久化 <em>dict</em> 对象。 对已关闭 Shelf 的操作将失败并引发 <code>ValueError</code>。</p>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><ul>
<li>可选择使用哪种数据库包 (例如 <code>dbm.ndbm</code> 或 <code>dbm.gnu</code>) 取决于支持哪种接口。 因此使用 <code>dbm</code> 直接打开数据库是不安全的。 如果使用了 <code>dbm</code>，数据库同样会（不幸地）受限于它 —- 这意味着存储在数据库中的（封存形式的）对象尺寸应当较小，并且在少数情况下键冲突有可能导致数据库拒绝更新。</li>
<li><code>shelve</code> 模块不支持对 Shelf 对象的 <em>并发</em> 读/写访问。 （多个同时读取访问则是安全的。） 当一个程序打开一个 shelve 对象来写入时，不应再有其他程序同时打开它来读取或写入。 Unix 文件锁定可被用来解决此问题，但这在不同 Unix 版本上会存在差异，并且需要有关所用数据库实现的细节知识。</li>
</ul>
<p><em>class</em> <code>shelve.Shelf</code>(<em>dict</em>, <em>protocol=None</em>, <em>writeback=False</em>, <em>keyencoding=’utf-8’</em>)</p>
<p><code>collections.abc.MutableMapping</code> 的一个子类，它会将封存的值保存在 <em>dict</em> 对象中。</p>
<p>在默认情况下，会使用以 <code>pickle.DEFAULT_PROTOCOL</code> 创建的 pickle 来序列化值。 pickle 协议的版本可通过 <em>protocol</em> 形参来指定。</p>
<p>如果 <em>writeback</em> 形参为 <code>True</code>，对象将为所有访问过的条目保留缓存并在同步和关闭时将它们写回到 <em>dict</em>。 这允许对可变的条目执行自然操作，但是会消耗更多内存并让同步和关闭花费更长时间。</p>
<p><em>keyencoding</em> 形参是在下层字典被使用之前用于编码键的编码格式。</p>
<p><code>Shelf</code> 对象还可以被用作上下文管理器，在这种情况下它将在 <code>with</code> 语句块结束时自动被关闭。</p>
<p>在 3.2 版更改: 添加了 <em>keyencoding</em> 形参；之前，键总是使用 UTF-8 编码。</p>
<p>在 3.4 版更改: 添加了上下文管理器支持。</p>
<p>在 3.10 版更改: <code>pickle.DEFAULT_PROTOCOL</code> 现在会被用作默认的 pickle 协议。</p>
<p><em>class</em> <code>shelve.BsdDbShelf</code>(<em>dict</em>, <em>protocol=None</em>, <em>writeback=False</em>, <em>keyencoding=’utf-8’</em>)</p>
<p><code>Shelf</code> 的一个子类，将 <code>first()</code>, <code>next()</code>, <code>previous()</code>, <code>last()</code> 和 <code>set_location()</code> 对外公开，在来自 pybsddb 的第三方 <code>bsddb</code> 模块中可用，但在其他数据库模块中不可用。 传给构造器的 <em>dict</em> 对象必须支持这些方法。 这通常是通过调用 <code>bsddb.hashopen()</code>, <code>bsddb.btopen()</code> 或 <code>bsddb.rnopen()</code> 之一来完成的。 可选的 <em>protocol</em>, <em>writeback</em> 和 <em>keyencoding</em> 形参具有与 <code>Shelf</code> 类相同的含义。</p>
<p><em>class</em> <code>shelve.DbfilenameShelf</code>(<em>filename</em>, <em>flag=’c’</em>, <em>protocol=None</em>, <em>writeback=False</em>)</p>
<p><code>Shelf</code> 的一个子类，它接受一个 <em>filename</em> 而非字典类对象。 下层文件将使用 <code>dbm.open()</code> 来打开。 默认情况下，文件将以读写模式打开。 可选的 <em>flag</em> 形参具有与 <code>open()</code> 函数相同的含义。 可选的 <em>protocol</em> 和 <em>writeback</em> 形参具有与 <code>Shelf</code> 类相同的含义。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>对接口的总结如下 (<code>key</code> 为字符串，<code>data</code> 为任意对象):</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> shelve
d <span class="token operator">=</span> shelve<span class="token punctuation">.</span>open<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># open -- file may get suffix added by low-level</span>
                           <span class="token comment" spellcheck="true"># library</span>
d<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> data              <span class="token comment" spellcheck="true"># store data at key (overwrites old data if</span>
                           <span class="token comment" spellcheck="true"># using an existing key)</span>
data <span class="token operator">=</span> d<span class="token punctuation">[</span>key<span class="token punctuation">]</span>              <span class="token comment" spellcheck="true"># retrieve a COPY of data at key (raise KeyError</span>
                           <span class="token comment" spellcheck="true"># if no such key)</span>
<span class="token keyword">del</span> d<span class="token punctuation">[</span>key<span class="token punctuation">]</span>                 <span class="token comment" spellcheck="true"># delete data stored at key (raises KeyError</span>
                           <span class="token comment" spellcheck="true"># if no such key)</span>
flag <span class="token operator">=</span> key <span class="token keyword">in</span> d            <span class="token comment" spellcheck="true"># true if the key exists</span>
klist <span class="token operator">=</span> list<span class="token punctuation">(</span>d<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># a list of all existing keys (slow!)</span>
<span class="token comment" spellcheck="true"># as d was opened WITHOUT writeback=True, beware:</span>
d<span class="token punctuation">[</span><span class="token string">'xx'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># this works as expected, but...</span>
d<span class="token punctuation">[</span><span class="token string">'xx'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># *this doesn't!* -- d['xx'] is STILL [0, 1, 2]!</span>
<span class="token comment" spellcheck="true"># having opened d without writeback=True, you need to code carefully:</span>
temp <span class="token operator">=</span> d<span class="token punctuation">[</span><span class="token string">'xx'</span><span class="token punctuation">]</span>             <span class="token comment" spellcheck="true"># extracts the copy</span>
temp<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># mutates the copy</span>
d<span class="token punctuation">[</span><span class="token string">'xx'</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp             <span class="token comment" spellcheck="true"># stores the copy right back, to persist it</span>
<span class="token comment" spellcheck="true"># or, d=shelve.open(filename,writeback=True) would let you just code</span>
<span class="token comment" spellcheck="true"># d['xx'].append(5) and have it work as expected, BUT it would also</span>
<span class="token comment" spellcheck="true"># consume more memory and make the d.close() operation slower.</span>
d<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true"># close it</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="marshal-—-内部-Python-对象序列化"><a href="#marshal-—-内部-Python-对象序列化" class="headerlink" title="marshal —- 内部 Python 对象序列化"></a><code>marshal</code> —- 内部 Python 对象序列化</h2><p>此模块包含一此能以二进制格式来读写 Python 值的函数。 这种格式是 Python 专属的，但是独立于特定的机器架构（即你可以在一台 PC 上写入某个 Python 值，将文件传到一台 Sun 上并在那里读取它）。 这种格式的细节有意不带文档说明；它可能在不同 Python 版本中发生改变（但这种情况极少发生）。</p>
<p>这不是一个通用的“持久化”模块。 <code>marshal</code> 模块主要是为了支持读写 <code>.pyc</code> 文件形式“伪编译”代码的 Python 模块。 因此，Python 维护者保留在必要时以不向下兼容的方式修改 marshal 格式的权利。 如果你要序列化和反序列化 Python 对象，请改用 <code>pickle</code> 模块 — 其执行效率相当，版本独立性有保证，并且 pickle 还支持比 marshal 更多样的对象类型。</p>
<p>警告</p>
<p><code>marshal</code> 模块对于错误或恶意构建的数据来说是不安全的。 永远不要 unmarshal 来自不受信任的或未经验证的来源的数据。</p>
<p>不是所有 Python 对象类型都受支持；一般来说，此模块只能写入和读取不依赖于特定 Python 调用的对象。 下列类型是受支持的：布尔值、整数、浮点数、复数、字符串、字节串、字节数组、元组、列表、集合、冻结集合、字典和代码对象，需要了解的一点是元组、列表、集合、冻结集合和字典只在其所包含的值也是这些值时才受支持。 单例对象 <code>None</code>, <code>Ellipsis</code> and <code>StopIteration</code> 也可以被 marshal 和 unmarshal。 对于 <em>version</em> 低于 3 的格式，递归列表、集合和字典无法被写入（见下文）。</p>
<p>有些函数可以读/写文件，还有些函数可以操作字节类对象。</p>
<p>这个模块定义了以下函数：</p>
<p><code>marshal.dump</code>(<em>value</em>, <em>file</em>[, <em>version</em>])</p>
<p>向打开的文件写入值。 值必须为受支持的类型。 文件必须为可写的 binary file。</p>
<p>如果值具有（或所包含的对象具有）不受支持的类型，则会引发 <code>ValueError</code> —- 但是将向文件写入垃圾数据。 对象也将不能正确地通过 <code>load()</code> 重新读取。</p>
<p><em>version</em> 参数指明 <code>dump</code> 应当使用的数据格式（见下文）。</p>
<p>引发一个 审计事件 <code>marshal.dumps</code>，附带参数 <code>value</code>, <code>version</code>。</p>
<p><code>marshal.load</code>(<em>file</em>)</p>
<p>从打开的文件读取一个值并返回。 如果读不到有效的值（例如由于数据为不同 Python 版本的不兼容 marshal 格式），则会引发 <code>EOFError</code>, <code>ValueError</code> 或 <code>TypeError</code>。 文件必须为可读的 binary file。</p>
<p>引发一个 审计事件 <code>marshal.load</code>，没有附带参数。</p>
<p>注解</p>
<p>如果通过 <code>dump()</code> marshal 了一个包含不受支持类型的对象，<code>load()</code> 将为不可 marshal 的类型替换 <code>None</code>。</p>
<p>在 3.10 版更改: 使用此调用为每个代码对象引发一个 <code>code.__new__</code> 审计事件。 现在它会为整个载入操作引发单个 <code>marshal.load</code> 事件。</p>
<p><code>marshal.dumps</code>(<em>value</em>[, <em>version</em>])</p>
<p>返回将通过 <code>dump(value, file)</code> 被写入一个文件的字节串对象。 值必须属于受支持的类型。 如果值属于（或包含的对象属于）不受支持的类型则会引发 <code>ValueError</code>。</p>
<p><em>version</em> 参数指明 <code>dumps</code> 应当使用的数据类型（见下文）。</p>
<p>引发一个 审计事件 <code>marshal.dumps</code>，附带参数 <code>value</code>, <code>version</code>。</p>
<p><code>marshal.loads</code>(<em>bytes</em>)</p>
<p>将 bytes-like object 转换为一个值。 如果找不到有效的值，则会引发 <code>EOFError</code>, <code>ValueError</code> 或 <code>TypeError</code>。 输入的额外字节串会被忽略。</p>
<p>引发一个 审计事件 <code>marshal.loads</code>，附带参数 <code>bytes</code>。</p>
<p>在 3.10 版更改: 使用此调用为每个代码对象引发一个 <code>code.__new__</code> 审计事件。 现在它会为整个载入操作引发单个 <code>marshal.loads</code> 事件。</p>
<p>此外，还定义了以下常量：</p>
<pre><code>marshal.version</code></pre><p>指明模块所使用的格式。 第 0 版为历史格式，第 1 版为共享固化的字符串，第 2 版对浮点数使用二进制格式。 第 3 版添加了对于对象实例化和递归的支持。 目前使用的为第 4 版。</p>
<p>此模块的名称来源于 Modula-3 (及其他语言) 的设计者所使用的术语，他们使用术语 “marshal” 来表示以自包含的形式传输数据。 严格地说，将数据从内部形式转换为外部形式 (例如用于 RPC 缓冲区) 称为 “marshal” 而其逆过程则称为 “unmarshal”。</p>
<h2 id="dbm-—-Unix-“数据库”-接口"><a href="#dbm-—-Unix-“数据库”-接口" class="headerlink" title="dbm —- Unix “数据库” 接口"></a><code>dbm</code> —- Unix “数据库” 接口</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/dbm/__init__.py" target="_blank" rel="noopener">Lib/dbm/<strong>init</strong>.py</a></p>
<hr>
<p><code>dbm</code> 是一种泛用接口，针对各种 DBM 数据库 —- 包括 <code>dbm.gnu</code> 或 <code>dbm.ndbm</code>。 如果未安装这些模块中的任何一种，则将使用 <code>dbm.dumb</code> 模块中慢速但简单的实现。 还有一个适用于 Oracle Berkeley DB 的 第三方接口。</p>
<p><em>exception</em> <code>dbm.error</code></p>
<p>一个元组，其中包含每个受支持的模块可引发的异常，另外还有一个名为 <code>dbm.error</code> 的特殊异常作为第一项 —- 后者最在引发 <code>dbm.error</code> 时被使用。</p>
<p><code>dbm.whichdb</code>(<em>filename</em>)</p>
<p>此函数会猜测各种简单数据库模块中的哪一个是可用的 —- <code>dbm.gnu</code>, <code>dbm.ndbm</code> 还是 <code>dbm.dumb</code> —- 应该被用来打开给定的文件。</p>
<p>返回下列值中的一个：如果文件由于不可读或不存在而无法打开则返回 <code>None</code>；如果文件的格式无法猜测则返回空字符串 (<code>''</code>)；或是包含所需模块名称的字符串，例如 <code>'dbm.ndbm'</code> 或 <code>'dbm.gnu'</code>。</p>
<p><code>dbm.open</code>(<em>file</em>, <em>flag=’r’</em>, <em>mode=438</em>)</p>
<p>打开数据库文件 <em>file</em> 并返回一个相应的对象。</p>
<p>如果数据库文件已存在，则使用 <code>whichdb()</code> 函数来确定其类型和要使用的适当模块；如果文件不存在，则会使用上述可导入模块中的第一个。</p>
<p>可选的 <em>flag</em> 参数可以是：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘r’</code></td>
<td align="left">以只读方式打开现有数据库（默认）</td>
</tr>
<tr>
<td align="left"><code>‘w’</code></td>
<td align="left">以读写方式打开现有数据库</td>
</tr>
<tr>
<td align="left"><code>‘c’</code></td>
<td align="left">以读写方式打开数据库，如果不存在则创建它</td>
</tr>
<tr>
<td align="left"><code>‘n’</code></td>
<td align="left">始终创建一个新的空数据库，以读写方式打开</td>
</tr>
</tbody></table>
<p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code> (并将被当前的 umask 所修改)。</p>
<p><code>open()</code> 所返回的对象支持与字典相同的基本功能；可以存储、获取和删除键及其对应的值，并可使用 <code>in</code> 运算符和 <code>keys()</code> 方法，以及 <code>get()</code> 和 <code>setdefault()</code>。</p>
<p>在 3.2 版更改: 现在 <code>get()</code> 和 <code>setdefault()</code> 在所有数据库模块中均可用。</p>
<p>在 3.8 版更改: 从只读数据库中删除键将引发数据库模块专属的错误而不是 <code>KeyError</code>。</p>
<p>键和值总是被存储为字节串。 这意味着当使用字符串时它们会在被存储之前隐式地转换至默认编码格式。</p>
<p>这些对象也支持在 <code>with</code> 语句中使用，当语句结束时将自动关闭它们。</p>
<p>在 3.4 版更改: 向 <code>open()</code> 所返回的对象添加了上下文管理协议的原生支持。</p>
<p>以下示例记录了一些主机名和对应的标题，随后将数据库的内容打印出来。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> dbm
<span class="token comment" spellcheck="true"># Open database, creating it if necessary.</span>
<span class="token keyword">with</span> dbm<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'cache'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> db<span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># Record some values</span>
    db<span class="token punctuation">[</span>b<span class="token string">'hello'</span><span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token string">'there'</span>
    db<span class="token punctuation">[</span><span class="token string">'www.python.org'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Python Website'</span>
    db<span class="token punctuation">[</span><span class="token string">'www.cnn.com'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Cable News Network'</span>
    <span class="token comment" spellcheck="true"># Note that the keys are considered bytes now.</span>
    <span class="token keyword">assert</span> db<span class="token punctuation">[</span>b<span class="token string">'www.python.org'</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token string">'Python Website'</span>
    <span class="token comment" spellcheck="true"># Notice how the value is now in bytes.</span>
    <span class="token keyword">assert</span> db<span class="token punctuation">[</span><span class="token string">'www.cnn.com'</span><span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token string">'Cable News Network'</span>
    <span class="token comment" spellcheck="true"># Often-used methods of the dict interface work too.</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>db<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'python.org'</span><span class="token punctuation">,</span> b<span class="token string">'not present'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># Storing a non-string key or value will raise an exception (most</span>
    <span class="token comment" spellcheck="true"># likely a TypeError).</span>
    db<span class="token punctuation">[</span><span class="token string">'www.yahoo.com'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span>
<span class="token comment" spellcheck="true"># db is automatically closed when leaving the with statement.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>存储非字符串数据的持久化模块。</p>
<p>以下部分描述了各个单独的子模块。</p>
<h3 id="dbm-gnu-—-GNU-对-dbm-的重解析"><a href="#dbm-gnu-—-GNU-对-dbm-的重解析" class="headerlink" title="dbm.gnu —- GNU 对 dbm 的重解析"></a><code>dbm.gnu</code> —- GNU 对 dbm 的重解析</h3><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/dbm/gnu.py" target="_blank" rel="noopener">Lib/dbm/gnu.py</a></p>
<hr>
<p>此模块与 <code>dbm</code> 模块很相似，但是改用 GNU 库 <code>gdbm</code> 来提供某些附加功能。 请注意由 <code>dbm.gnu</code> 与 <code>dbm.ndbm</code> 所创建的文件格式是不兼容的。</p>
<p><code>dbm.gnu</code> 模块提供了对 GNU DBM 库的接口。 <code>dbm.gnu.gdbm</code> 对象的行为类似于映射（字典），区别在于其键和值总是会在存储之前被转换为字节串。 打印 <code>gdbm</code> 对象不会打印出键和值，并且 <code>items()</code> 和 <code>values()</code> 等方法也不受支持。</p>
<p><em>exception</em> <code>dbm.gnu.error</code></p>
<p>针对 <code>dbm.gnu</code> 专属错误例如 I/O 错误引发。 <code>KeyError</code> 的引发则针对一般映射错误例如指定了不正确的键。</p>
<p><code>dbm.gnu.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p>
<p>打开一个 <code>gdbm</code> 数据库并返回 <code>gdbm</code> 对象。 <em>filename</em> 参数为数据库文件名称。</p>
<p>可选的 <em>flag</em> 参数可以是：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘r’</code></td>
<td align="left">以只读方式打开现有数据库（默认）</td>
</tr>
<tr>
<td align="left"><code>‘w’</code></td>
<td align="left">以读写方式打开现有数据库</td>
</tr>
<tr>
<td align="left"><code>‘c’</code></td>
<td align="left">以读写方式打开数据库，如果不存在则创建它</td>
</tr>
<tr>
<td align="left"><code>‘n’</code></td>
<td align="left">始终创建一个新的空数据库，以读写方式打开</td>
</tr>
</tbody></table>
<p>下列附加字符可被添加至旗标以控制数据库的打开方式：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘f’</code></td>
<td align="left">以快速模式打开数据库。写入数据库将不会同步。</td>
</tr>
<tr>
<td align="left"><code>‘s’</code></td>
<td align="left">同步模式。这将导致数据库的更改立即写入文件。</td>
</tr>
<tr>
<td align="left"><code>‘u’</code></td>
<td align="left">不要锁定数据库。</td>
</tr>
</tbody></table>
<p>不是所有旗标都可用于所有版本的 <code>gdbm</code>。 模块常量 <code>open_flags</code> 为包含受支持旗标字符的字符串。 如果指定了无效的旗标则会引发 <code>error</code>。</p>
<p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code>。</p>
<p>除了与字典类似的方法，<code>gdbm</code> 对象还有以下方法：</p>
<ul>
<li><p><code>gdbm.firstkey</code>()</p>
<p>使用此方法和 <code>nextkey()</code> 方法可以循环遍历数据库中的每个键。 遍历的顺序是按照 <code>gdbm</code> 的内部哈希值，而不会根据键的值排序。 此方法将返回起始键。</p>
</li>
<li><p><code>gdbm.nextkey</code>(<em>key</em>)</p>
<p>在遍历中返回 <em>key</em> 之后的的下一个键。 以下代码将打印数据库 <code>db</code> 中的每个键，而不会在内存中创建一个包含所有键的列表:</p>
<pre class="line-numbers language-python"><code class="language-python">k <span class="token operator">=</span> db<span class="token punctuation">.</span>firstkey<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> k <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span>
    k <span class="token operator">=</span> db<span class="token punctuation">.</span>nextkey<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>gdbm.reorganize</code>()</p>
<p>如果你进行了大量删除操作并且想要缩减 <code>gdbm</code> 文件所使用的空间，此例程将可重新组织数据库。 除非使用此重组功能否则 <code>gdbm</code> 对象不会缩减数据库文件大小；在其他情况下，被删除的文件空间将会保留并在添加新的 (键, 值) 对时被重用。</p>
</li>
<li><p><code>gdbm.sync</code>()</p>
<p>当以快速模式打开数据库时，此方法会将任何未写入数据强制写入磁盘。</p>
</li>
<li><p><code>gdbm.close</code>()</p>
<p>关闭 <code>gdbm</code> 数据库。</p>
</li>
</ul>
<h3 id="dbm-ndbm-—-基于-ndbm-的接口"><a href="#dbm-ndbm-—-基于-ndbm-的接口" class="headerlink" title="dbm.ndbm —- 基于 ndbm 的接口"></a><code>dbm.ndbm</code> —- 基于 ndbm 的接口</h3><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/dbm/ndbm.py" target="_blank" rel="noopener">Lib/dbm/ndbm.py</a></p>
<hr>
<p><code>dbm.ndbm</code> 模块提供了对 Unix “(n)dbm” 库的接口。 Dbm 对象的行为类似于映射（字典），区别在于其键和值总是被存储为字节串。 打印 <code>dbm</code> 对象不会打印出键和值，并且 <code>items()</code> 和 <code>values()</code> 等方法也不受支持。</p>
<p>此模块可与 “经典classic” ndbm 接口或 GNU GDBM 兼容接口一同使用。 在 Unix 上，<strong>configure</strong> 脚本将尝试定位适当的头文件来简化此模块的构建。</p>
<p><em>exception</em> <code>dbm.ndbm.error</code></p>
<p>针对 <code>dbm.ndbm</code> 专属错误例如 I/O 错误引发。 <code>KeyError</code> 的引发则针对一般映射错误例如指定了不正确的键。</p>
<pre><code>dbm.ndbm.library</code></pre><p>所使用的 <code>ndbm</code> 实现库的名称。</p>
<p><code>dbm.ndbm.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p>
<p>打开一个 dbm 数据库并返回 <code>ndbm</code> 对象。 <em>filename</em> 参数为数据库文件名称（不带 <code>.dir</code> 或 <code>.pag</code> 扩展名）。</p>
<p>可选的 <em>flag</em> 参数必须是下列值之一：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘r’</code></td>
<td align="left">以只读方式打开现有数据库（默认）</td>
</tr>
<tr>
<td align="left"><code>‘w’</code></td>
<td align="left">以读写方式打开现有数据库</td>
</tr>
<tr>
<td align="left"><code>‘c’</code></td>
<td align="left">以读写方式打开数据库，如果不存在则创建它</td>
</tr>
<tr>
<td align="left"><code>‘n’</code></td>
<td align="left">始终创建一个新的空数据库，以读写方式打开</td>
</tr>
</tbody></table>
<p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code> (并将被当前的 umask 所修改)。</p>
<p>除了与字典类似的方法，<code>ndbm</code> 对象还有以下方法：</p>
<ul>
<li><p><code>ndbm.close</code>()</p>
<p>关闭 <code>ndbm</code> 数据库。</p>
</li>
</ul>
<h3 id="dbm-dumb-—-便携式-DBM-实现"><a href="#dbm-dumb-—-便携式-DBM-实现" class="headerlink" title="dbm.dumb —- 便携式 DBM 实现"></a><code>dbm.dumb</code> —- 便携式 DBM 实现</h3><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/dbm/dumb.py" target="_blank" rel="noopener">Lib/dbm/dumb.py</a></p>
<p>注解</p>
<p><code>dbm.dumb</code> 模块的目的是在更健壮的模块不可用时作为 <code>dbm</code> 模块的最终回退项。 <code>dbm.dumb</code> 不是为高速运行而编写的，也不像其他数据库模块一样被经常使用。</p>
<hr>
<p><code>dbm.dumb</code> 模块提供了一个完全以 Python 编写的持久化字典类接口。 不同于 <code>dbm.gnu</code> 等其他模块，它不需要外部库。 与其他持久化映射一样，它的键和值也总是被存储为字节串。</p>
<p>该模块定义以下内容：</p>
<p><em>exception</em> <code>dbm.dumb.error</code></p>
<p>针对 <code>dbm.dumb</code> 专属错误例如 I/O 错误引发。 <code>KeyError</code> 的引发则针对一般映射例如指定了不正确的键。</p>
<p><code>dbm.dumb.open</code>(<em>filename</em>[, <em>flag</em>[, <em>mode</em>]])</p>
<p>打开一个 <code>dumbdbm</code> 数据库并返回 dumbdbm 对象。 <em>filename</em> 参数为数据库文件的主名称（不带任何特定扩展名）。 创建一个 dumbdbm 数据库时将创建多个带有 <code>.dat</code> 和 <code>.dir</code> 扩展名的文件。</p>
<p>可选的 <em>flag</em> 参数可以是：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘r’</code></td>
<td align="left">以只读方式打开现有数据库（默认）</td>
</tr>
<tr>
<td align="left"><code>‘w’</code></td>
<td align="left">以读写方式打开现有数据库</td>
</tr>
<tr>
<td align="left"><code>‘c’</code></td>
<td align="left">以读写方式打开数据库，如果不存在则创建它</td>
</tr>
<tr>
<td align="left"><code>‘n’</code></td>
<td align="left">始终创建一个新的空数据库，以读写方式打开</td>
</tr>
</tbody></table>
<p>可选的 <em>mode</em> 参数是文件的 Unix 模式，仅在要创建数据库时才会被使用。 其默认值为八进制数 <code>0o666</code> (并将被当前的 umask 所修改)。</p>
<p>警告</p>
<p>当载入包含足够巨大/复杂条目的数据库时有可能导致 Python 解释器的崩溃，这是由于 Python AST 编译器有栈深度限制。</p>
<p>在 3.5 版更改: <code>open()</code> 在 flag 值为 <code>'n'</code> 时将总是创建一个新的数据库。</p>
<p>在 3.8 版更改: 附带 <code>'r'</code> 旗标打开的数据库现在将是只读的。 附带 <code>'r'</code> 和 <code>'w'</code> 旗标的打开操作不会再创建数据库。</p>
<p>除了 <code>collections.abc.MutableMapping</code> 类所提供的方法，<code>dumbdbm</code> 对象还提供了以下方法：</p>
<ul>
<li><p><code>dumbdbm.sync</code>()</p>
<p>同步磁盘上的目录和数据文件。 此方法会由 <code>Shelve.sync()</code> 方法来调用。</p>
</li>
<li><p><code>dumbdbm.close</code>()</p>
<p>关闭 <code>dumbdbm</code> 数据库。</p>
</li>
</ul>
<h2 id="sqlite3-—-SQLite-数据库-DB-API-2-0-接口模块"><a href="#sqlite3-—-SQLite-数据库-DB-API-2-0-接口模块" class="headerlink" title="sqlite3 —- SQLite 数据库 DB-API 2.0 接口模块"></a><code>sqlite3</code> —- SQLite 数据库 DB-API 2.0 接口模块</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/sqlite3/" target="_blank" rel="noopener">Lib/sqlite3/</a></p>
<hr>
<p>SQLite 是一个C语言库，它可以提供一种轻量级的基于磁盘的数据库，这种数据库不需要独立的服务器进程，也允许需要使用一种非标准的 SQL 查询语言来访问它。一些应用程序可以使用 SQLite 作为内部数据存储。可以用它来创建一个应用程序原型，然后再迁移到更大的数据库，比如 PostgreSQL 或 Oracle。</p>
<p>sqlite3 模块由 Gerhard Häring 编写。 它提供了 <a href="https://www.python.org/dev/peps/pep-0249" target="_blank" rel="noopener"><strong>PEP 249</strong></a> 所描述的符合 DB-API 2.0 规范的 SQL 接口，并要求 SQLite 3.7.15 或更新的版本。</p>
<p>参见</p>
<p><a href="https://www.sqlite.org/" target="_blank" rel="noopener">https://www.sqlite.org</a></p>
<p>SQLite的主页；它的文档详细描述了它所支持的 SQL 方言的语法和可用的数据类型。</p>
<p><a href="https://www.w3schools.com/sql/" target="_blank" rel="noopener">https://www.w3schools.com/sql/</a></p>
<p>学习 SQL 语法的教程、参考和例子。</p>
<p><a href="https://www.python.org/dev/peps/pep-0249" target="_blank" rel="noopener"><strong>PEP 249</strong></a> - DB-API 2.0 规范</p>
<p>PEP 由 Marc-André Lemburg 撰写。</p>
<p><a href="https://blog.creativecc.cn/posts/Database-Sqlite.html#toc-heading-121" target="_blank" rel="noopener">SQLite 常规使用</a></p>
<h3 id="模块函数和常量"><a href="#模块函数和常量" class="headerlink" title="模块函数和常量"></a>模块函数和常量</h3><pre><code>sqlite3.version</code></pre><p>这个模块的版本号，是一个字符串。不是 SQLite 库的版本号。</p>
<pre><code>sqlite3.version_info</code></pre><p>这个模块的版本号，是一个由整数组成的元组。不是 SQLite 库的版本号。</p>
<pre><code>sqlite3.sqlite_version</code></pre><p>使用中的 SQLite 库的版本号，是一个字符串。</p>
<pre><code>sqlite3.sqlite_version_info</code></pre><p>使用中的 SQLite 库的版本号，是一个整数组成的元组。</p>
<pre><code>sqlite3.PARSE_DECLTYPES</code></pre><p>这个常量可以作为 <code>connect()</code> 函数的 <em>detect_types</em> 参数。</p>
<p>设置这个参数后，<code>sqlite3</code> 模块将解析它返回的每一列申明的类型。它会申明的类型的第一个单词，比如“integer primary key”，它会解析出“integer”，再比如“number(10)”，它会解析出“number”。然后，它会在转换器字典里查找那个类型注册的转换器函数，并调用它。</p>
<pre><code>sqlite3.PARSE_COLNAMES</code></pre><p>这个常量可以作为 <code>connect()</code> 函数的 <em>detect_types</em> 参数。</p>
<p>设置此参数可使得 SQLite 接口解析它所返回的每一列的列名。 它将在其中查找形式为 [mytype] 的字符串，然后将 ‘mytype’ 确定为列的类型。 它将尝试在转换器字典中查找 ‘mytype’ 条目，然后用找到的转换器函数来返回值。 在 <code>Cursor.description</code> 中找到的列名并不包括类型，举例来说，如果你在你的 SQL 中使用了像 <code>'as "Expiration date [datetime]"'</code> 这样的写法，那么我们将解析出在第一个 <code>'['</code> 之前的所有内容并去除前导空格作为列名：即列名将为 “Expiration date”。</p>
<p><code>sqlite3.connect</code>(<em>database</em>[, <em>timeout</em>, <em>detect_types</em>, <em>isolation_level</em>, <em>check_same_thread</em>, <em>factory</em>, <em>cached_statements</em>, <em>uri</em>])</p>
<p>连接 SQLite 数据库 <em>database*。默认返回 <code>Connection</code> 对象，除非使用了自定义的 *factory</em> 参数。</p>
<p><em>database</em> 是准备打开的数据库文件的路径（绝对路径或相对于当前目录的相对路径），它是 path-like object。你也可以用 <code>":memory:"</code> 在内存中打开一个数据库。</p>
<p>当一个数据库被多个连接访问的时候，如果其中一个进程修改这个数据库，在这个事务提交之前，这个 SQLite 数据库将会被一直锁定。<em>timeout</em> 参数指定了这个连接等待锁释放的超时时间，超时之后会引发一个异常。这个超时时间默认是 5.0（5秒）。</p>
<p><em>isolation_level</em> 参数，请查看 <code>Connection</code> 对象的 <code>isolation_level</code> 属性。</p>
<p>SQLite 原生只支持5种类型：TEXT，INTEGER，REAL，BLOB 和 NULL。如果你想用其它类型，你必须自己添加相应的支持。使用 <em>detect_types</em> 参数和模块级别的 <code>register_converter()</code> 函数注册<strong>转换器</strong> 可以简单的实现。</p>
<p><em>detect_types</em> 默认为 0 (即关闭，不进行类型检测)，你可以将其设为任意的 <code>PARSE_DECLTYPES</code> 和 <code>PARSE_COLNAMES</code> 组合来启用类型检测。 由于 SQLite 的行为，生成的字段类型 (例如 <code>max(data)</code>) 不能被检测，即使在设置了 <em>detect_types</em> 形参时也是如此。 在此情况下，返回的类型为 <code>str</code>。</p>
<p>默认情况下，<em>check_same_thread</em> 为 <code>True</code>，只有当前的线程可以使用该连接。 如果设置为 <code>False</code>，则多个线程可以共享返回的连接。 当多个线程使用同一个连接的时候，用户应该把写操作进行序列化，以避免数据损坏。</p>
<p>默认情况下，当调用 connect 方法的时候，<code>sqlite3</code> 模块使用了它的 <code>Connection</code> 类。当然，你也可以创建 <code>Connection</code> 类的子类，然后创建提供了 <em>factory</em> 参数的 <code>connect()</code> 方法。</p>
<p><code>sqlite3</code> 模块在内部使用语句缓存来避免 SQL 解析开销。 如果要显式设置当前连接可以缓存的语句数，可以设置 <em>cached_statements</em> 参数。 当前实现的默认值是缓存100条语句。</p>
<p>如果 <em>uri</em> 为真，则 <em>database</em> 被解释为 URI。 它允许您指定选项。 例如，以只读模式打开数据库：</p>
<pre class="line-numbers language-python"><code class="language-python">db <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">'file:path/to/database?mode=ro'</span><span class="token punctuation">,</span> uri<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>有关此功能的更多信息，包括已知选项的列表，可以在 <code>SQLite URI 文档 &lt;https://www.sqlite.org/uri.html&gt;</code>_ 中找到。</p>
<p>引发一个 审计事件 <code>sqlite3.connect</code>，附带参数 <code>database</code>。</p>
<p>引发一个 审计事件 <code>sqlite3.connect/handle</code>，附带参数 <code>connection_handle</code>。</p>
<p>在 3.4 版更改: 增加了 <em>uri</em> 参数。</p>
<p>在 3.7 版更改: <em>database</em> 现在可以是一个 path-like object 对象了，不仅仅是字符串。</p>
<p>在 3.10 版更改: 增加了 <code>sqlite3.connect/handle</code> 审计事件。</p>
<p><code>sqlite3.register_converter</code>(<em>typename</em>, <em>callable</em>)</p>
<p>注册一个回调对象 <em>callable</em>, 用来转换数据库中的字节串为自定的 Python 类型。所有类型为 <em>typename</em> 的数据库的值在转换时，都会调用这个回调对象。通过指定 <code>connect()</code> 函数的 <em>detect-types</em> 参数来设置类型检测的方式。注意，<em>typename</em> 与查询语句中的类型名进行匹配时不区分大小写。</p>
<p><code>sqlite3.register_adapter</code>(<em>type</em>, <em>callable</em>)</p>
<p>注册一个回调对象 <em>callable*，用来转换自定义Python类型为一个 SQLite 支持的类型。 这个回调对象 *callable</em> 仅接受一个 Python 值作为参数，而且必须返回以下某个类型的值：int，float，str 或 bytes。</p>
<p><code>sqlite3.complete_statement</code>(<em>sql</em>)</p>
<p>如果字符串 <em>sql</em> 包含一个或多个完整的 SQL 语句（以分号结束）则返回 <code>True</code>。它不会验证 SQL 语法是否正确，仅会验证字符串字面上是否完整，以及是否以分号结束。</p>
<p>它可以用来构建一个 SQLite shell，下面是一个例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># A minimal SQLite shell for experiments</span>
<span class="token keyword">import</span> sqlite3
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>isolation_level <span class="token operator">=</span> None
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
buffer <span class="token operator">=</span> <span class="token string">""</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Enter your SQL commands to execute in sqlite3."</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Enter a blank line to exit."</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    line <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> line <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">:</span>
        <span class="token keyword">break</span>
    buffer <span class="token operator">+=</span> line
    <span class="token keyword">if</span> sqlite3<span class="token punctuation">.</span>complete_statement<span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            buffer <span class="token operator">=</span> buffer<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
            cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span>buffer<span class="token punctuation">)</span>
            <span class="token keyword">if</span> buffer<span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">"SELECT"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchall<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">except</span> sqlite3<span class="token punctuation">.</span>Error <span class="token keyword">as</span> e<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"An error occurred:"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        buffer <span class="token operator">=</span> <span class="token string">""</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>sqlite3.enable_callback_tracebacks</code>(<em>flag</em>)</p>
<p>默认情况下，您不会获得任何用户定义函数中的回溯消息，比如聚合，转换器，授权器回调等。如果要调试它们，可以设置 <em>flag</em> 参数为 <code>True</code> 并调用此函数。 之后，回调中的回溯信息将会输出到 <code>sys.stderr</code>。 再次使用 <code>False</code> 来禁用该功能。</p>
<h3 id="连接对象（Connection）"><a href="#连接对象（Connection）" class="headerlink" title="连接对象（Connection）"></a>连接对象（Connection）</h3><p><em>class</em> <code>sqlite3.Connection</code></p>
<p>SQLite 数据库连接对象有如下的属性和方法：</p>
<ul>
<li><p><code>isolation_level</code></p>
<p>获取或设置当前默认的隔离级别。 表示自动提交模式的 <code>None</code> 以及 “DEFERRED”, “IMMEDIATE” 或 “EXCLUSIVE” 其中之一。 </p>
</li>
<li><p><code>in_transaction</code></p>
<p>如果是在活动事务中（还没有提交改变），返回 <code>True</code>，否则，返回 <code>False</code>。它是一个只读属性。</p>
<p>3.2 新版功能.</p>
</li>
<li><p><code>cursor</code>(<em>factory=Cursor</em>)</p>
<p>这个方法接受一个可选参数 <em>factory</em>，如果要指定这个参数，它必须是一个可调用对象，而且必须返回 <code>Cursor</code> 类的一个实例或者子类。</p>
</li>
<li><p><code>commit</code>()</p>
<p>这个方法提交当前事务。如果没有调用这个方法，那么从上一次提交 <code>commit()</code> 以来所有的变化在其他数据库连接上都是不可见的。如果你往数据库里写了数据，但是又查询不到，请检查是否忘记了调用这个方法。</p>
</li>
<li><p><code>rollback</code>()</p>
<p>这个方法回滚从上一次调用 <code>commit()</code> 以来所有数据库的改变。</p>
</li>
<li><p><code>close</code>()</p>
<p>关闭数据库连接。注意，它不会自动调用 <code>commit()</code> 方法。如果在关闭数据库连接之前没有调用 <code>commit()</code>，那么你的修改将会丢失！</p>
</li>
<li><p><code>execute</code>(<em>sql</em>[, <em>parameters</em>])</p>
<p>这是一个非标准的快捷方法，它会调用 <code>cursor()</code> 方法来创建一个游标对象，并使用给定的 <em>parameters</em> 参数来调用游标对象的 <code>execute()</code> 方法，最后返回这个游标对象。</p>
</li>
<li><p><code>executemany</code>(<em>sql</em>[, <em>parameters</em>])</p>
<p>这是一个非标准的快捷方法，它会调用 <code>cursor()</code> 方法来创建一个游标对象，并使用给定的 <em>parameters</em> 参数来调用游标对象的 <code>executemany()</code> 方法，最后返回这个游标对象。</p>
</li>
<li><p><code>executescript</code>(<em>sql_script</em>)</p>
<p>这是一个非标准的快捷方法，它会调用 <code>cursor()</code> 方法来创建一个游标对象，并使用给定的 <em>sql_script</em> 参数来调用游标对象的 <code>executescript()</code> 方法，最后返回这个游标对象。</p>
</li>
<li><p><code>create_function</code>(<em>name</em>, <em>num_params</em>, <em>func</em>, <em>**,</em> deterministic=False*)</p>
<p>创建一个可以在 SQL 语句中使用的用户自定义函数，函数名为 <em>name*。 *num_params</em> 为该函数所接受的形参个数（如果 <em>num_params</em> 为 -1，则该函数可接受任意数量的参数）， <em>func</em> 是一个 Python 可调用对象，它将作为 SQL 函数被调用。 如果 <em>deterministic</em> 为真值，则所创建的函数将被标记为 deterministic，这允许 SQLite 执行额外的优化。 此旗标在 SQLite 3.8.3 或更高版本中受到支持，如果在旧版本中使用将引发 <code>NotSupportedError</code>。</p>
<p>此函数可返回任何 SQLite 所支持的类型: bytes, str, int, float 和 <code>None</code>。</p>
<p>在 3.8 版更改: 增加了 <em>deterministic</em> 形参。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">import</span> hashlib
<span class="token keyword">def</span> <span class="token function">md5sum</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> hashlib<span class="token punctuation">.</span>md5<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span>hexdigest<span class="token punctuation">(</span><span class="token punctuation">)</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>create_function<span class="token punctuation">(</span><span class="token string">"md5"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> md5sum<span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select md5(?)"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>b<span class="token string">"foo"</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>create_aggregate</code>(<em>name</em>, <em>num_params</em>, <em>aggregate_class</em>)</p>
<p>创建一个自定义的聚合函数。</p>
<p>参数中 <em>aggregate_class</em> 类必须实现两个方法：<code>step</code> 和 <code>finalize</code>。<code>step</code> 方法接受 <em>num_params</em> 个参数（如果 <em>num_params</em> 为 -1，那么这个函数可以接受任意数量的参数）；<code>finalize</code> 方法返回最终的聚合结果。</p>
<p><code>finalize</code> 方法可以返回任何 SQLite 支持的类型：bytes，str，int，float 和 <code>None</code>。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">class</span> <span class="token class-name">MySum</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">def</span> <span class="token function">step</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>count <span class="token operator">+=</span> value
    <span class="token keyword">def</span> <span class="token function">finalize</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>count
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>create_aggregate<span class="token punctuation">(</span><span class="token string">"mysum"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> MySum<span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table test(i)"</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"insert into test(i) values (1)"</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"insert into test(i) values (2)"</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select mysum(i) from test"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>create_collation</code>(<em>name</em>, <em>callable</em>)</p>
<p>使用 <em>name</em> 和 <em>callable</em> 创建排序规则。这个 <em>callable</em> 接受两个字符串对象，如果第一个小于第二个则返回 -1， 如果两个相等则返回 0，如果第一个大于第二个则返回 1。注意，这是用来控制排序的（SQL 中的 ORDER BY），所以它不会影响其它的 SQL 操作。</p>
<p>注意，这个 <em>callable</em> 可调用对象会把它的参数作为 Python 字节串，通常会以 UTF-8 编码格式对它进行编码。</p>
<p>以下示例显示了使用“错误方式”进行排序的自定义排序规则：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">def</span> <span class="token function">collate_reverse</span><span class="token punctuation">(</span>string1<span class="token punctuation">,</span> string2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> string1 <span class="token operator">==</span> string2<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">0</span>
    <span class="token keyword">elif</span> string1 <span class="token operator">&lt;</span> string2<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>create_collation<span class="token punctuation">(</span><span class="token string">"reverse"</span><span class="token punctuation">,</span> collate_reverse<span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table test(x)"</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>executemany<span class="token punctuation">(</span><span class="token string">"insert into test(x) values (?)"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select x from test order by x collate reverse"</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> row <span class="token keyword">in</span> cur<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要移除一个排序规则，需要调用 <code>create_collation</code> 并设置 callable 参数为 <code>None</code>。</p>
<pre class="line-numbers language-python"><code class="language-python">con<span class="token punctuation">.</span>create_collation<span class="token punctuation">(</span><span class="token string">"reverse"</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><code>interrupt</code>()</p>
<p>可以从不同的线程调用这个方法来终止所有查询操作，这些查询操作可能正在连接上执行。此方法调用之后， 查询将会终止，而且查询的调用者会获得一个异常。</p>
</li>
<li><p><code>set_authorizer</code>(<em>authorizer_callback</em>)</p>
<p>此方法注册一个授权回调对象。每次在访问数据库中某个表的某一列的时候，这个回调对象将会被调用。如果要允许访问，则返回 <code>SQLITE_OK</code>，如果要终止整个 SQL 语句，则返回 <code>SQLITE_DENY</code>，如果这一列需要当做 NULL 值处理，则返回 <code>SQLITE_IGNORE</code>。这些常量可以在 <code>sqlite3</code> 模块中找到。</p>
<p>回调的第一个参数表示要授权的操作类型。 第二个和第三个参数将是参数或 <code>None</code>，具体取决于第一个参数的值。 第 4 个参数是数据库的名称（“main”，“temp”等），如果需要的话。 第 5 个参数是负责访问尝试的最内层触发器或视图的名称，或者如果此访问尝试直接来自输入 SQL 代码，则为 <code>None</code>。</p>
<p>请参阅 SQLite 文档，了解第一个参数的可能值以及第二个和第三个参数的含义，具体取决于第一个参数。 </p>
</li>
<li><p><code>set_progress_handler</code>(<em>handler</em>, <em>n</em>)</p>
<p>此例程注册回调。 对SQLite虚拟机的每个多指令调用回调。 如果要在长时间运行的操作期间从SQLite调用（例如更新用户界面），这非常有用。</p>
<p>如果要清除以前安装的任何进度处理程序，调用该方法时请将 <em>handler</em> 参数设置为 <code>None</code>。</p>
<p>从处理函数返回非零值将终止当前正在执行的查询并导致它引发 <code>OperationalError</code> 异常。</p>
</li>
<li><p><code>set_trace_callback</code>(<em>trace_callback</em>)</p>
<p>为每个 SQLite 后端实际执行的 SQL 语句注册要调用的 <em>trace_callback</em>。</p>
<p>The only argument passed to the callback is the statement (as <code>str</code>) that is being executed. The return value of the callback is ignored. Note that the backend does not only run statements passed to the <code>Cursor.execute()</code> methods. Other sources include the transaction management of the sqlite3 module and the execution of triggers defined in the current database.</p>
<p>将传入的 <em>trace_callback</em> 设为 <code>None</code> 将禁用跟踪回调。</p>
<p>注解</p>
<p>Exceptions raised in the trace callback are not propagated. As a development and debugging aid, use <code>enable_callback_tracebacks()</code> to enable printing tracebacks from exceptions raised in the trace callback.</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>enable_load_extension</code>(<em>enabled</em>)</p>
<p>此例程允许/禁止SQLite引擎从共享库加载SQLite扩展。 SQLite扩展可以定义新功能，聚合或全新的虚拟表实现。 一个众所周知的扩展是与SQLite一起分发的全文搜索扩展。</p>
<p>默认情况下禁用可加载扩展。 </p>
<p>引发一个 审计事件 <code>sqlite3.enable_load_extension</code>，附带参数 <code>connection</code>, <code>enabled</code>。</p>
<p>3.2 新版功能.</p>
<p>在 3.10 版更改: 增加了 <code>sqlite3.enable_load_extension</code> 审计事件。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># enable extension loading</span>
con<span class="token punctuation">.</span>enable_load_extension<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Load the fulltext search extension</span>
con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select load_extension('./fts3.so')"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># alternatively you can load the extension using an API call:</span>
<span class="token comment" spellcheck="true"># con.load_extension("./fts3.so")</span>
<span class="token comment" spellcheck="true"># disable extension loading again</span>
con<span class="token punctuation">.</span>enable_load_extension<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># example from SQLite wiki</span>
con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create virtual table recipe using fts3(name, ingredients)"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>executescript<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""
    insert into recipe (name, ingredients) values ('broccoli stew', 'broccoli peppers cheese tomatoes');
    insert into recipe (name, ingredients) values ('pumpkin stew', 'pumpkin onions garlic celery');
    insert into recipe (name, ingredients) values ('broccoli pie', 'broccoli cheese onions flour');
    insert into recipe (name, ingredients) values ('pumpkin pie', 'pumpkin sugar flour butter');
    """</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> row <span class="token keyword">in</span> con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select rowid, name, ingredients from recipe where name match 'pie'"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>load_extension</code>(<em>path</em>)</p>
<p>此例程从共享库加载SQLite扩展。 在使用此例程之前，必须使用 <code>enable_load_extension()</code> 启用扩展加载。</p>
<p>默认情况下禁用可加载扩展。</p>
<p>引发一个 审计事件 <code>sqlite3.load_extension</code>，附带参数 <code>connection</code>, <code>path</code>。</p>
<p>3.2 新版功能.</p>
<p>在 3.10 版更改: 增加了 <code>sqlite3.load_extension</code> 审计事件。</p>
</li>
<li><p><code>row_factory</code></p>
<p>您可以将此属性更改为可接受游标和原始行作为元组的可调用对象，并将返回实际结果行。 这样，您可以实现更高级的返回结果的方法，例如返回一个可以按名称访问列的对象。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">def</span> <span class="token function">dict_factory</span><span class="token punctuation">(</span>cursor<span class="token punctuation">,</span> row<span class="token punctuation">)</span><span class="token punctuation">:</span>
    d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">for</span> idx<span class="token punctuation">,</span> col <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>cursor<span class="token punctuation">.</span>description<span class="token punctuation">)</span><span class="token punctuation">:</span>
        d<span class="token punctuation">[</span>col<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> row<span class="token punctuation">[</span>idx<span class="token punctuation">]</span>
    <span class="token keyword">return</span> d
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>row_factory <span class="token operator">=</span> dict_factory
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select 1 as a"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果返回一个元组是不够的，并且你想要对列进行基于名称的访问，你应该考虑将 <code>row_factory</code> 设置为高度优化的 <code>sqlite3.Row</code> 类型。 <code>Row</code> 提供基于索引和不区分大小写的基于名称的访问，几乎没有内存开销。 它可能比您自己的基于字典的自定义方法甚至基于 db_row 的解决方案更好。</p>
</li>
<li><p><code>text_factory</code></p>
<p>Using this attribute you can control what objects are returned for the <code>TEXT</code> data type. By default, this attribute is set to <code>str</code> and the <code>sqlite3</code> module will return <code>str</code> objects for <code>TEXT</code>. If you want to return <code>bytes</code> instead, you can set it to <code>bytes</code>.</p>
<p>您还可以将其设置为接受单个 bytestring 参数的任何其他可调用对象，并返回结果对象。</p>
<p>请参阅以下示例代码以进行说明：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
AUSTRIA <span class="token operator">=</span> <span class="token string">"Österreich"</span>
<span class="token comment" spellcheck="true"># by default, rows are returned as str</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select ?"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>AUSTRIA<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
row <span class="token operator">=</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">assert</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> AUSTRIA
<span class="token comment" spellcheck="true"># but we can make sqlite3 always return bytestrings ...</span>
con<span class="token punctuation">.</span>text_factory <span class="token operator">=</span> bytes
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select ?"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>AUSTRIA<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
row <span class="token operator">=</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">assert</span> type<span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">is</span> bytes
<span class="token comment" spellcheck="true"># the bytestrings will be encoded in UTF-8, unless you stored garbage in the</span>
<span class="token comment" spellcheck="true"># database ...</span>
<span class="token keyword">assert</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> AUSTRIA<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># we can also implement a custom text_factory ...</span>
<span class="token comment" spellcheck="true"># here we implement one that appends "foo" to all strings</span>
con<span class="token punctuation">.</span>text_factory <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"foo"</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select ?"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
row <span class="token operator">=</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">assert</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"barfoo"</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>total_changes</code></p>
<p>返回自打开数据库连接以来已修改，插入或删除的数据库行的总数。</p>
</li>
<li><p><code>iterdump</code>()</p>
<p>返回以SQL文本格式转储数据库的迭代器。 保存内存数据库以便以后恢复时很有用。 此函数提供与 <strong>sqlite3</strong> shell 中的 .dump 命令相同的功能。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Convert file existing_db.db to SQL dump file dump.sql</span>
<span class="token keyword">import</span> sqlite3
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">'existing_db.db'</span><span class="token punctuation">)</span>
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'dump.sql'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> con<span class="token punctuation">.</span>iterdump<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'%s\n'</span> <span class="token operator">%</span> line<span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>backup</code>(<em>target</em>, <em>**,</em> pages=- 1<em>,</em> progress=None<em>,</em> name=’main’<em>,</em> sleep=0.25*)</p>
<p>即使在 SQLite 数据库被其他客户端访问时，或者同时由同一连接访问，该方法也会对其进行备份。 该副本将写入强制参数 <em>target</em>，该参数必须是另一个 <code>Connection</code> 实例。</p>
<p>默认情况下，或者当 <em>pages</em> 为 <code>0</code> 或负整数时，整个数据库将在一个步骤中复制；否则该方法一次循环复制 <em>pages</em> 规定数量的页面。</p>
<p>如果指定了 <em>progress<em>，则它必须为 <code>None</code> 或一个将在每次迭代时附带三个整数参数执行的可调用对象，这三个参数分别是前一次迭代的状态 *status</em>，将要拷贝的剩余页数 *remaining</em> 以及总页数 <em>total</em>。</p>
<p><em>name</em> 参数指定将被拷贝的数据库名称：它必须是一个字符串，其内容为表示主数据库的默认值 <code>"main"</code>，表示临时数据库的 <code>"temp"</code> 或是在 <code>ATTACH DATABASE</code> 语句的 <code>AS</code> 关键字之后指定表示附加数据库的名称。</p>
<p><em>sleep</em> 参数指定在备份剩余页的连续尝试之间要休眠的秒数，可以指定为一个整数或一个浮点数值。</p>
<p>示例一，将现有数据库复制到另一个数据库中：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">def</span> <span class="token function">progress</span><span class="token punctuation">(</span>status<span class="token punctuation">,</span> remaining<span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">'Copied {total-remaining} of {total} pages...'</span><span class="token punctuation">)</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">'existing_db.db'</span><span class="token punctuation">)</span>
bck <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">'backup.db'</span><span class="token punctuation">)</span>
<span class="token keyword">with</span> bck<span class="token punctuation">:</span>
    con<span class="token punctuation">.</span>backup<span class="token punctuation">(</span>bck<span class="token punctuation">,</span> pages<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> progress<span class="token operator">=</span>progress<span class="token punctuation">)</span>
bck<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>示例二，将现有数据库复制到临时副本中：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
source <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">'existing_db.db'</span><span class="token punctuation">)</span>
dest <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">':memory:'</span><span class="token punctuation">)</span>
source<span class="token punctuation">.</span>backup<span class="token punctuation">(</span>dest<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.7 新版功能.</p>
</li>
</ul>
<h3 id="Cursor-对象"><a href="#Cursor-对象" class="headerlink" title="Cursor 对象"></a>Cursor 对象</h3><p><em>class</em> <code>sqlite3.Cursor</code></p>
<p><code>Cursor</code> 游标实例具有以下属性和方法。</p>
<ul>
<li><p><code>execute</code>(<em>sql</em>[, <em>parameters</em>])</p>
<p>执行一条 SQL 语句。 可以使用 占位符 将值绑定到语句中。</p>
<p><code>execute()</code> 将只执行一条单独的 SQL 语句。 如果你尝试用它执行超过一条语句，将会引发 <code>Warning</code>。 如果你想要用一次调用执行多条 SQL 语句请使用 <code>executescript()</code>。</p>
</li>
<li><p><code>executemany</code>(<em>sql</em>, <em>seq_of_parameters</em>)</p>
<p>执行一条 带形参的 SQL 命令，使用所有形参序列或在序列 <em>seq_of_parameters</em> 中找到的映射。 <code>sqlite3</code> 模块还允许使用 iterator 代替序列来产生形参。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">class</span> <span class="token class-name">IterChars</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>count <span class="token operator">=</span> ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self
    <span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> self<span class="token punctuation">.</span>count <span class="token operator">></span> ord<span class="token punctuation">(</span><span class="token string">'z'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">raise</span> StopIteration
        self<span class="token punctuation">.</span>count <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>chr<span class="token punctuation">(</span>self<span class="token punctuation">.</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># this is a 1-tuple</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table characters(c)"</span><span class="token punctuation">)</span>
theIter <span class="token operator">=</span> IterChars<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>executemany<span class="token punctuation">(</span><span class="token string">"insert into characters(c) values (?)"</span><span class="token punctuation">,</span> theIter<span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select c from characters"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchall<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这是一个使用生成器 generator 的简短示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">import</span> string
<span class="token keyword">def</span> <span class="token function">char_generator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> c <span class="token keyword">in</span> string<span class="token punctuation">.</span>ascii_lowercase<span class="token punctuation">:</span>
        <span class="token keyword">yield</span> <span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token punctuation">)</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table characters(c)"</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>executemany<span class="token punctuation">(</span><span class="token string">"insert into characters(c) values (?)"</span><span class="token punctuation">,</span> char_generator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select c from characters"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchall<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>executescript</code>(<em>sql_script</em>)</p>
<p>这是用于一次性执行多条 SQL 语句的非标准便捷方法。 它会首先发出一条 <code>COMMIT</code> 语句，然后执行通过参数获得的 SQL 脚本。 此方法会忽略 <code>isolation_level</code>；任何事件控制都必须被添加到 <em>sql_script</em>。</p>
<p><em>sql_script</em> 可以是一个 <a href="https://www.bookstack.cn/read/python-3.10.0-zh/7adaf5f79c9e977a.md#str" target="_blank" rel="noopener"><code>str</code></a> 类的实例。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>executescript<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""
    create table person(
        firstname,
        lastname,
        age
    );
    create table book(
        title,
        author,
        published
    );
    insert into book(title, author, published)
    values (
        'Dirk Gently''s Holistic Detective Agency',
        'Douglas Adams',
        1987
    );
    """</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><code>fetchone</code>()</p>
<p>获取一个查询结果集的下一行，返回一个单独序列，或是在没有更多可用数据时返回 <code>None</code>。</p>
</li>
<li><p><code>fetchmany</code>(<em>size=cursor.arraysize</em>)</p>
<p>获取下一个多行查询结果集，返回一个列表。 当没有更多可用行时将返回一个空列表。</p>
<p>每次调用获取的行数由 <em>size</em> 形参指定。 如果没有给出该形参，则由 cursor 的 arraysize 决定要获取的行数。 此方法将基于 size 形参值尝试获取指定数量的行。 如果获取不到指定的行数，则可能返回较少的行。</p>
<p>请注意 <em>size</em> 形参会涉及到性能方面的考虑。为了获得优化的性能，通常最好是使用 arraysize 属性。 如果使用 <em>size</em> 形参，则最好在从一个 <code>fetchmany()</code> 调用到下一个调用之间保持相同的值。</p>
</li>
<li><p><code>fetchall</code>()</p>
<p>获取一个查询结果的所有（剩余）行，返回一个列表。 请注意 cursor 的 arraysize 属性会影响此操作的执行效率。 当没有可用行时将返回一个空列表。</p>
</li>
<li><p><code>close</code>()</p>
<p>立即关闭 cursor（而不是在当 <code>__del__</code> 被调用的时候）。</p>
<p>从这一时刻起该 cursor 将不再可用，如果再尝试用该 cursor 执行任何操作将引发 <code>ProgrammingError</code> 异常。</p>
</li>
<li><p><code>rowcount</code></p>
<p>虽然 <code>sqlite3</code> 模块的 <code>Cursor</code> 类实现了此属性，但数据库引擎本身对于确定 “受影响行”/“已选择行” 的支持并不完善。</p>
<p>对于 <code>executemany()</code> 语句，修改行数会被汇总至 <code>rowcount</code>。</p>
<p>根据 Python DB API 规格描述的要求，<code>rowcount</code> 属性 “当未在 cursor 上执行 <code>executeXX()</code> 或者上一次操作的 rowcount 不是由接口确定时为 -1”。 这包括 <code>SELECT</code> 语句，因为我们无法确定一次查询将产生的行计数，而要等获取了所有行时才会知道。</p>
</li>
<li><p><code>lastrowid</code></p>
<p>这个只读属性会提供最近修改行的 rowid。 它只在你使用 <code>execute()</code> 方法执行 <code>INSERT</code> 或 <code>REPLACE</code> 语句时会被设置。 对于 <code>INSERT</code> 或 <code>REPLACE</code> 以外的操作或者当 <code>executemany()</code> 被调用时，<code>lastrowid</code> 会被设为 <code>None</code>。</p>
<p>如果 <code>INSERT</code> 或 <code>REPLACE</code> 语句操作失败则将返回上一次成功操作的 rowid。</p>
<p>在 3.6 版更改: 增加了 <code>REPLACE</code> 语句的支持。</p>
</li>
<li><p><code>arraysize</code></p>
<p>用于控制 <code>fetchmany()</code> 返回行数的可读取/写入属性。 该属性的默认值为 1，表示每次调用将获取单独一行。</p>
</li>
<li><p><code>description</code></p>
<p>这个只读属性将提供上一次查询的列名称。 为了与 Python DB API 保持兼容，它会为每个列返回一个 7 元组，每个元组的最后六个条目均为 <code>None</code>。</p>
<p>对于没有任何匹配行的 <code>SELECT</code> 语句同样会设置该属性。</p>
</li>
<li><p><code>connection</code></p>
<p>这个只读属性将提供 <code>Cursor</code> 对象所使用的 SQLite 数据库 <code>Connection</code>。 通过调用 <code>con.cursor()</code> 创建的 <code>Cursor</code> 对象所包含的 <code>connection</code> 属性将指向 <em>con</em>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> cur<span class="token punctuation">.</span>connection <span class="token operator">==</span> con
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="行对象"><a href="#行对象" class="headerlink" title="行对象"></a>行对象</h3><p><em>class</em> <code>sqlite3.Row</code></p>
<p>一个 <code>Row</code> 实例，该实例将作为用于 <code>Connection</code> 对象的高度优化的 <code>row_factory</code>。 它的大部分行为都会模仿元组的特性。</p>
<p>它支持使用列名称的映射访问以及索引、迭代、文本表示、相等检测和 <code>len()</code> 等操作。</p>
<p>如果两个 <code>Row</code> 对象具有完全相同的列并且其成员均相等，则它们的比较结果为相等。</p>
<ul>
<li><p><code>keys</code>()</p>
<p>此方法会在一次查询之后立即返回一个列名称的列表，它是 <code>Cursor.description</code> 中每个元组的第一个成员。</p>
</li>
</ul>
<p>在 3.5 版更改: 添加了对切片操作的支持。</p>
<p>让我们假设我们如上面的例子所示初始化一个表:</p>
<pre class="line-numbers language-python"><code class="language-python">con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token triple-quoted-string string">'''create table stocks
(date text, trans text, symbol text,
 qty real, price real)'''</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token triple-quoted-string string">"""insert into stocks
            values ('2006-01-05','BUY','RHAT',100,35.14)"""</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>commit<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在我们将 <code>Row</code> 插入:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> con<span class="token punctuation">.</span>row_factory <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>Row
<span class="token operator">>></span><span class="token operator">></span> cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">'select * from stocks'</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>sqlite3<span class="token punctuation">.</span>Cursor object at <span class="token number">0x7f4e7dd8fa80</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> r <span class="token operator">=</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>r<span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'sqlite3.Row'</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> tuple<span class="token punctuation">(</span>r<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'2006-01-05'</span><span class="token punctuation">,</span> <span class="token string">'BUY'</span><span class="token punctuation">,</span> <span class="token string">'RHAT'</span><span class="token punctuation">,</span> <span class="token number">100.0</span><span class="token punctuation">,</span> <span class="token number">35.14</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>r<span class="token punctuation">)</span>
<span class="token number">5</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token string">'RHAT'</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'date'</span><span class="token punctuation">,</span> <span class="token string">'trans'</span><span class="token punctuation">,</span> <span class="token string">'symbol'</span><span class="token punctuation">,</span> <span class="token string">'qty'</span><span class="token punctuation">,</span> <span class="token string">'price'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> r<span class="token punctuation">[</span><span class="token string">'qty'</span><span class="token punctuation">]</span>
<span class="token number">100.0</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> member <span class="token keyword">in</span> r<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>member<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">2006</span><span class="token operator">-</span><span class="token number">01</span><span class="token operator">-</span><span class="token number">05</span>
BUY
RHAT
<span class="token number">100.0</span>
<span class="token number">35.14</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><em>exception</em> <code>sqlite3.Warning</code></p>
<p><code>Exception</code> 的一个子类。</p>
<p><em>exception</em> <code>sqlite3.Error</code></p>
<p>此模块中其他异常的基类。 它是 <code>Exception</code> 的一个子类。</p>
<p><em>exception</em> <code>sqlite3.DatabaseError</code></p>
<p>针对数据库相关错误引发的异常。</p>
<p><em>exception</em> <code>sqlite3.IntegrityError</code></p>
<p>当数据库的关系一致性受到影响时引发的异常。 例如外键检查失败等。 它是 <code>DatabaseError</code> 的子类。</p>
<p><em>exception</em> <code>sqlite3.ProgrammingError</code></p>
<p>编程错误引发的异常，例如表未找到或已存在，SQL 语句存在语法错误，指定的形参数量错误等。 它是 <code>DatabaseError</code> 的子类。</p>
<p><em>exception</em> <code>sqlite3.OperationalError</code></p>
<p>与数据库操作相关而不一定能受程序员掌控的错误引发的异常，例如发生非预期的连接中断，数据源名称未找到，事务无法被执行等。 它是 <code>DatabaseError</code> 的子类。</p>
<p><em>exception</em> <code>sqlite3.NotSupportedError</code></p>
<p>在使用了某个数据库不支持的方法或数据库 API 时引发的异常，例如在一个不支持事务或禁用了事务的连接上调用 <code>rollback()</code> 方法等。 它是 <code>DatabaseError</code> 的子类。</p>
<h3 id="SQLite-与-Python-类型"><a href="#SQLite-与-Python-类型" class="headerlink" title="SQLite 与 Python 类型"></a>SQLite 与 Python 类型</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>SQLite 原生支持如下的类型： <code>NULL</code>，<code>INTEGER</code>，<code>REAL</code>，<code>TEXT</code>，<code>BLOB</code>。</p>
<p>因此可以将以下Python类型发送到SQLite而不会出现任何问题：</p>
<table>
<thead>
<tr>
<th align="left">Python 类型</th>
<th align="left">SQLite 类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>None</code></td>
<td align="left"><code>NULL</code></td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left"><code>INTEGER</code></td>
</tr>
<tr>
<td align="left"><code>float</code></td>
<td align="left"><code>REAL</code></td>
</tr>
<tr>
<td align="left"><code>str</code></td>
<td align="left"><code>TEXT</code></td>
</tr>
<tr>
<td align="left"><code>bytes</code></td>
<td align="left"><code>BLOB</code></td>
</tr>
</tbody></table>
<p>这是SQLite类型默认转换为Python类型的方式：</p>
<table>
<thead>
<tr>
<th align="left">SQLite 类型</th>
<th align="left">Python 类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>NULL</code></td>
<td align="left"><code>None</code></td>
</tr>
<tr>
<td align="left"><code>INTEGER</code></td>
<td align="left"><code>int</code></td>
</tr>
<tr>
<td align="left"><code>REAL</code></td>
<td align="left"><code>float</code></td>
</tr>
<tr>
<td align="left"><code>TEXT</code></td>
<td align="left">取决于 <code>text_factory</code> , 默认为 <code>str</code></td>
</tr>
<tr>
<td align="left"><code>BLOB</code></td>
<td align="left"><code>bytes</code></td>
</tr>
</tbody></table>
<p><code>sqlite3</code> 模块的类型系统可通过两种方式来扩展：你可以通过对象适配将额外的 Python 类型保存在 SQLite 数据库中，你也可以让 <code>sqlite3</code> 模块通过转换器将 SQLite 类型转换为不同的 Python 类型。</p>
<h4 id="使用适配器将额外的-Python-类型保存在-SQLite-数据库中。"><a href="#使用适配器将额外的-Python-类型保存在-SQLite-数据库中。" class="headerlink" title="使用适配器将额外的 Python 类型保存在 SQLite 数据库中。"></a>使用适配器将额外的 Python 类型保存在 SQLite 数据库中。</h4><p>如上文所述，SQLite 只包含对有限类型集的原生支持。 要让 SQLite 能使用其他 Python 类型，你必须将它们 <strong>适配</strong> 至 sqlite3 模块所支持的 SQLite 类型中的一种：NoneType, int, float, str, bytes。</p>
<p>有两种方式能让 <code>sqlite3</code> 模块将某个定制的 Python 类型适配为受支持的类型。</p>
<h5 id="让对象自行适配"><a href="#让对象自行适配" class="headerlink" title="让对象自行适配"></a>让对象自行适配</h5><p>如果类是你自己编写的，这将是一个很好的方式。 假设你有这样一个类:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y <span class="token operator">=</span> x<span class="token punctuation">,</span> y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>现在你可将这种点对象保存在一个 SQLite 列中。 首先你必须选择一种受支持的类型用来表示点对象。 让我们就用 str 并使用一个分号来分隔坐标值。 然后你需要给你的类加一个方法 <code>__conform__(self, protocol)</code>，它必须返回转换后的值。 形参 <em>protocol</em> 将为 <code>PrepareProtocol</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y <span class="token operator">=</span> x<span class="token punctuation">,</span> y
    <span class="token keyword">def</span> <span class="token function">__conform__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> protocol<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> protocol <span class="token keyword">is</span> sqlite3<span class="token punctuation">.</span>PrepareProtocol<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token string">"%f;%f"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
p <span class="token operator">=</span> Point<span class="token punctuation">(</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.2</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select ?"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="注册可调用的适配器"><a href="#注册可调用的适配器" class="headerlink" title="注册可调用的适配器"></a>注册可调用的适配器</h5><p>另一种可能的做法是创建一个将该类型转换为字符串表示的函数并使用 <code>register_adapter()</code> 注册该函数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y <span class="token operator">=</span> x<span class="token punctuation">,</span> y
<span class="token keyword">def</span> <span class="token function">adapt_point</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token string">"%f;%f"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>point<span class="token punctuation">.</span>x<span class="token punctuation">,</span> point<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
sqlite3<span class="token punctuation">.</span>register_adapter<span class="token punctuation">(</span>Point<span class="token punctuation">,</span> adapt_point<span class="token punctuation">)</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
p <span class="token operator">=</span> Point<span class="token punctuation">(</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.2</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select ?"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>sqlite3</code> 模块有两个适配器可用于 Python 的内置 <code>datetime.date</code> 和 <code>datetime.datetime</code> 类型。 现在假设我们想要存储 <code>datetime.datetime</code> 对象，但不是表示为 ISO 格式，而是表示为 Unix 时间戳。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">import</span> datetime
<span class="token keyword">import</span> time
<span class="token keyword">def</span> <span class="token function">adapt_datetime</span><span class="token punctuation">(</span>ts<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> time<span class="token punctuation">.</span>mktime<span class="token punctuation">(</span>ts<span class="token punctuation">.</span>timetuple<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
sqlite3<span class="token punctuation">.</span>register_adapter<span class="token punctuation">(</span>datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">,</span> adapt_datetime<span class="token punctuation">)</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
now <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select ?"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>now<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="将SQLite-值转换为自定义Python-类型"><a href="#将SQLite-值转换为自定义Python-类型" class="headerlink" title="将SQLite 值转换为自定义Python 类型"></a>将SQLite 值转换为自定义Python 类型</h4><p>编写适配器让你可以将定制的 Python 类型发送给 SQLite。 但要令它真正有用，我们需要实现从 Python 到 SQLite 再回到 Python 的双向转换。</p>
<p>输入转换器。</p>
<p>让我们回到 <code>Point</code> 类。 我们以字符串形式在 SQLite 中存储了 x 和 y 坐标值。</p>
<p>首先，我们将定义一个转换器函数，它接受这样的字符串作为形参并根据该参数构造一个 <code>Point</code> 对象。</p>
<p>注解</p>
<p>转换器函数在调用时 <strong>总是</strong> 会附带一个 <code>bytes</code> 对象，无论你将何种数据类型的值发给 SQLite。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">convert_point</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    x<span class="token punctuation">,</span> y <span class="token operator">=</span> map<span class="token punctuation">(</span>float<span class="token punctuation">,</span> s<span class="token punctuation">.</span>split<span class="token punctuation">(</span>b<span class="token string">";"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> Point<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>现在你需要让 <code>sqlite3</code> 模块知道你从数据库中选取的其实是一个点对象。 有两种方式都可以做到这件事：</p>
<ul>
<li>隐式的声明类型</li>
<li>显式的通过列名</li>
</ul>
<p>下面的示例说明了这两种方法。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y <span class="token operator">=</span> x<span class="token punctuation">,</span> y
    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">"(%f;%f)"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>x<span class="token punctuation">,</span> self<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">adapt_point</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token string">"%f;%f"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>point<span class="token punctuation">.</span>x<span class="token punctuation">,</span> point<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'ascii'</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">convert_point</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
    x<span class="token punctuation">,</span> y <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>float<span class="token punctuation">,</span> s<span class="token punctuation">.</span>split<span class="token punctuation">(</span>b<span class="token string">";"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> Point<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Register the adapter</span>
sqlite3<span class="token punctuation">.</span>register_adapter<span class="token punctuation">(</span>Point<span class="token punctuation">,</span> adapt_point<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Register the converter</span>
sqlite3<span class="token punctuation">.</span>register_converter<span class="token punctuation">(</span><span class="token string">"point"</span><span class="token punctuation">,</span> convert_point<span class="token punctuation">)</span>
p <span class="token operator">=</span> Point<span class="token punctuation">(</span><span class="token number">4.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.2</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">#########################</span>
<span class="token comment" spellcheck="true"># 1) Using declared types</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">,</span> detect_types<span class="token operator">=</span>sqlite3<span class="token punctuation">.</span>PARSE_DECLTYPES<span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table test(p point)"</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"insert into test(p) values (?)"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select p from test"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"with declared types:"</span><span class="token punctuation">,</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">#######################</span>
<span class="token comment" spellcheck="true"># 1) Using column names</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">,</span> detect_types<span class="token operator">=</span>sqlite3<span class="token punctuation">.</span>PARSE_COLNAMES<span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table test(p)"</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"insert into test(p) values (?)"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>p<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">'select p as "p [point]" from test'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"with column names:"</span><span class="token punctuation">,</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="默认适配器和转换器"><a href="#默认适配器和转换器" class="headerlink" title="默认适配器和转换器"></a>默认适配器和转换器</h4><p>对于 datetime 模块中的 date 和 datetime 类型已提供了默认的适配器。 它们将会以 ISO 日期/ISO 时间戳的形式发给 SQLite。</p>
<p>默认转换器使用的注册名称是针对 <code>datetime.date</code> 的 “date” 和针对 <code>datetime.datetime</code> 的 “timestamp”。</p>
<p>通过这种方式，你可以在大多数情况下使用 Python 的 date/timestamp 对象而无须任何额外处理。 适配器的格式还与实验性的 SQLite date/time 函数兼容。</p>
<p>下面的示例演示了这一点。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
<span class="token keyword">import</span> datetime
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">,</span> detect_types<span class="token operator">=</span>sqlite3<span class="token punctuation">.</span>PARSE_DECLTYPES<span class="token operator">|</span>sqlite3<span class="token punctuation">.</span>PARSE_COLNAMES<span class="token punctuation">)</span>
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table test(d date, ts timestamp)"</span><span class="token punctuation">)</span>
today <span class="token operator">=</span> datetime<span class="token punctuation">.</span>date<span class="token punctuation">.</span>today<span class="token punctuation">(</span><span class="token punctuation">)</span>
now <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"insert into test(d, ts) values (?, ?)"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>today<span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select d, ts from test"</span><span class="token punctuation">)</span>
row <span class="token operator">=</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>today<span class="token punctuation">,</span> <span class="token string">"=>"</span><span class="token punctuation">,</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> <span class="token string">"=>"</span><span class="token punctuation">,</span> row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">'select current_date as "d [date]", current_timestamp as "ts [timestamp]"'</span><span class="token punctuation">)</span>
row <span class="token operator">=</span> cur<span class="token punctuation">.</span>fetchone<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"current_date"</span><span class="token punctuation">,</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"current_timestamp"</span><span class="token punctuation">,</span> row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果存储在 SQLite 中的时间戳的小数位多于 6 个数字，则时间戳转换器会将该值截断至微秒精度。</p>
<h3 id="控制事务"><a href="#控制事务" class="headerlink" title="控制事务"></a>控制事务</h3><p>底层的 <code>sqlite3</code> 库默认会以 <code>autocommit</code> 模式运行，但 Python 的 <code>sqlite3</code> 模块默认则不使用此模式。</p>
<p><code>autocommit</code> 模式意味着修改数据库的操作会立即生效。 <code>BEGIN</code> 或 <code>SAVEPOINT</code> 语句会禁用 <code>autocommit</code> 模式，而用于结束外层事务的 <code>COMMIT</code>, <code>ROLLBACK</code> 或 <code>RELEASE</code> 则会恢复 <code>autocommit</code> 模式。</p>
<p>Python 的 <code>sqlite3</code> 模块默认会在数据修改语言 (DML) 类语句 (即 <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>/<code>REPLACE</code>) 之前隐式地执行一条 <code>BEGIN</code> 语句。</p>
<p>你可以控制 <code>sqlite3</code> 隐式执行的 <code>BEGIN</code> 语句的种类，具体做法是通过将 <em>isolation_level</em> 形参传给 <code>connect()</code> 调用，或者通过指定连接的 <code>isolation_level</code> 属性。 如果你没有指定 <em>isolation_level</em>，将使用基本的 <code>BEGIN</code>，它等价于指定 <code>DEFERRED</code>。 其他可能的值为 <code>IMMEDIATE</code> 和 <code>EXCLUSIVE</code>。</p>
<p>你可以禁用 <code>sqlite3</code> 模块的隐式事务管理，具体做法是将 <code>isolation_level</code> 设为 <code>None</code>。 这将使得下层的 <code>sqlite3</code> 库采用 <code>autocommit</code> 模式。 随后你可以通过在代码中显式地使用 <code>BEGIN</code>, <code>ROLLBACK</code>, <code>SAVEPOINT</code> 和 <code>RELEASE</code> 语句来完全控制事务状态。</p>
<p>请注意 <code>executescript()</code> 会忽略 <code>isolation_level</code>；任何事务控制必要要显式地添加。</p>
<p>在 3.6 版更改: 以前 <code>sqlite3</code> 会在 DDL 语句之前隐式地提交未完成事务。 现在则不会再这样做。</p>
<h3 id="有效使用-sqlite3"><a href="#有效使用-sqlite3" class="headerlink" title="有效使用 sqlite3"></a>有效使用 <code>sqlite3</code></h3><h4 id="使用快捷方式"><a href="#使用快捷方式" class="headerlink" title="使用快捷方式"></a>使用快捷方式</h4><p>使用 <code>Connection</code> 对象的非标准 <code>execute()</code>, <code>executemany()</code> 和 <code>executescript()</code> 方法，可以更简洁地编写代码，因为不必显式创建（通常是多余的） <code>Cursor</code> 对象。相反， <code>Cursor</code> 对象是隐式创建的，这些快捷方法返回游标对象。这样，只需对 <code>Connection</code> 对象调用一次，就能直接执行 <code>SELECT</code> 语句并遍历对象。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
langs <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">(</span><span class="token string">"C++"</span><span class="token punctuation">,</span> <span class="token number">1985</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token string">"Objective-C"</span><span class="token punctuation">,</span> <span class="token number">1984</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Create the table</span>
con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table lang(name, first_appeared)"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Fill the table</span>
con<span class="token punctuation">.</span>executemany<span class="token punctuation">(</span><span class="token string">"insert into lang(name, first_appeared) values (?, ?)"</span><span class="token punctuation">,</span> langs<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Print the table contents</span>
<span class="token keyword">for</span> row <span class="token keyword">in</span> con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select name, first_appeared from lang"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"I just deleted"</span><span class="token punctuation">,</span> con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"delete from lang"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rowcount<span class="token punctuation">,</span> <span class="token string">"rows"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># close is not a shortcut method and it's not called automatically,</span>
<span class="token comment" spellcheck="true"># so the connection object should be closed manually</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="通过名称而不是索引访问索引"><a href="#通过名称而不是索引访问索引" class="headerlink" title="通过名称而不是索引访问索引"></a>通过名称而不是索引访问索引</h4><p><code>sqlite3</code> 模块的一个有用功能是内置的 <code>sqlite3.Row</code> 类，它被设计用作行对象的工厂。</p>
<p>该类的行装饰器可以用索引（如元组）和不区分大小写的名称访问：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>row_factory <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>Row
cur <span class="token operator">=</span> con<span class="token punctuation">.</span>cursor<span class="token punctuation">(</span><span class="token punctuation">)</span>
cur<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"select 'John' as name, 42 as age"</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> row <span class="token keyword">in</span> cur<span class="token punctuation">:</span>
    <span class="token keyword">assert</span> row<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> row<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span>
    <span class="token keyword">assert</span> row<span class="token punctuation">[</span><span class="token string">"name"</span><span class="token punctuation">]</span> <span class="token operator">==</span> row<span class="token punctuation">[</span><span class="token string">"nAmE"</span><span class="token punctuation">]</span>
    <span class="token keyword">assert</span> row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> row<span class="token punctuation">[</span><span class="token string">"age"</span><span class="token punctuation">]</span>
    <span class="token keyword">assert</span> row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> row<span class="token punctuation">[</span><span class="token string">"AgE"</span><span class="token punctuation">]</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="使用连接作为上下文管理器"><a href="#使用连接作为上下文管理器" class="headerlink" title="使用连接作为上下文管理器"></a>使用连接作为上下文管理器</h4><p>连接对象可以用来作为上下文管理器，它可以自动提交或者回滚事务。如果出现异常，事务会被回滚；否则，事务会被提交。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sqlite3
con <span class="token operator">=</span> sqlite3<span class="token punctuation">.</span>connect<span class="token punctuation">(</span><span class="token string">":memory:"</span><span class="token punctuation">)</span>
con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"create table lang (id integer primary key, name varchar unique)"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Successful, con.commit() is called automatically afterwards</span>
<span class="token keyword">with</span> con<span class="token punctuation">:</span>
    con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"insert into lang(name) values (?)"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"Python"</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># con.rollback() is called after the with block finishes with an exception, the</span>
<span class="token comment" spellcheck="true"># exception is still raised and must be caught</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
    <span class="token keyword">with</span> con<span class="token punctuation">:</span>
        con<span class="token punctuation">.</span>execute<span class="token punctuation">(</span><span class="token string">"insert into lang(name) values (?)"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"Python"</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> sqlite3<span class="token punctuation">.</span>IntegrityError<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"couldn't add Python twice"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Connection object used as context manager only commits or rollbacks transactions,</span>
<span class="token comment" spellcheck="true"># so the connection object should be closed manually</span>
con<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="数据压缩和存档"><a href="#数据压缩和存档" class="headerlink" title="数据压缩和存档"></a>数据压缩和存档</h1><ul>
<li><code>zlib</code> —- 与 <strong>gzip</strong> 兼容的压缩</li>
<li><code>gzip</code> —- 对 <strong>gzip</strong> 格式的支持<ul>
<li>用法示例</li>
<li>命令行界面<ul>
<li>命令行选项</li>
</ul>
</li>
</ul>
</li>
<li><code>bz2</code> —- 对 <strong>bzip2</strong> 压缩算法的支持<ul>
<li>文件压缩和解压</li>
<li>增量压缩和解压</li>
<li>一次性压缩或解压缩</li>
<li>用法示例</li>
</ul>
</li>
<li><code>lzma</code> —- 用 LZMA 算法压缩<ul>
<li>读写压缩文件</li>
<li>在内存中压缩和解压缩数据</li>
<li>杂项</li>
<li>指定自定义的过滤器链</li>
<li>例子</li>
</ul>
</li>
<li><code>zipfile</code> —- 使用ZIP存档<ul>
<li>ZipFile 对象</li>
<li>Path 对象</li>
<li>PyZipFile 对象</li>
<li>ZipInfo 对象</li>
<li>命令行接口<ul>
<li>命令行选项</li>
</ul>
</li>
<li>解压缩的障碍<ul>
<li>由于文件本身</li>
<li>文件系统限制</li>
<li>资源限制</li>
<li>中断</li>
<li>提取的默认行为</li>
</ul>
</li>
</ul>
</li>
<li><code>tarfile</code> —- 读写tar归档文件<ul>
<li>TarFile 对象</li>
<li>TarInfo 对象</li>
<li>命令行接口<ul>
<li>命令行选项</li>
</ul>
</li>
<li>例子</li>
<li>受支持的 tar 格式</li>
<li>Unicode 问题</li>
</ul>
</li>
</ul>
<h2 id="zlib-—-与-gzip-兼容的压缩"><a href="#zlib-—-与-gzip-兼容的压缩" class="headerlink" title="zlib —- 与 gzip 兼容的压缩"></a><code>zlib</code> —- 与 <strong>gzip</strong> 兼容的压缩</h2><p>对于需要数据压缩的应用，此模块中的函数允许使用 zlib 库进行压缩和解压缩。 zlib 库的项目主页是 <a href="https://www.zlib.net/" target="_blank" rel="noopener">https://www.zlib.net</a>。 已知此 Python 模块与 1.1.3 之前版本的 zlib 库存在不兼容；1.1.3 版则存在一个 <a href="https://zlib.net/zlib_faq.html#faq33" target="_blank" rel="noopener">安全缺陷</a>，因此我们推荐使用 1.1.4 或更新的版本。</p>
<p>zlib 的函数有很多选项，一般需要按特定顺序使用。本文档没有覆盖全部的用法。更多详细信息请于 <a href="http://www.zlib.net/manual.html" target="_blank" rel="noopener">http://www.zlib.net/manual.html</a> 参阅官方手册。</p>
<p>此模块中可用的异常和函数如下：</p>
<p><em>exception</em> <code>zlib.error</code></p>
<p>在压缩或解压缩过程中发生错误时的异常。</p>
<p><code>zlib.adler32</code>(<em>data</em>[, <em>value</em>])</p>
<p>计算 <em>data</em> 的 Adler-32 校验值。(Adler-32 校验的可靠性与 CRC32 基本相当，但比计算 CRC32 更高效。) 计算的结果是一个 32 位的整数。参数 <em>value</em> 是校验时的起始值，其默认值为 1。借助参数 <em>value</em> 可为分段的输入计算校验值。此算法没有加密强度，不应用于身份验证和数字签名。此算法的目的仅为验证数据的正确性，不适合作为通用散列算法。</p>
<p>在 3.0 版更改: 返回值永远是无符号数。要在所有的 Python 版本和平台上获得相同的值，请使用 <code>adler32(data) &amp; 0xffffffff</code>。</p>
<p><code>zlib.compress</code>(<em>data</em>, <em>/</em>, <em>level=-1</em>)</p>
<p>压缩 <em>data</em> 中的字节，返回含有已压缩内容的 bytes 对象。参数 <em>level</em> 为整数，可取值为 <code>0</code> 到 <code>9</code> 或 <code>-1</code>，用于指定压缩等级。<code>1</code> (Z_BEST_SPEED) 表示最快速度和最低压缩率，<code>9</code> (Z_BEST_COMPRESSION) 表示最慢速度和最高压缩率。<code>0</code> (Z_NO_COMPRESSION) 表示不压缩。参数默认值为 <code>-1</code> (Z_DEFAULT_COMPRESSION)。Z_DEFAULT_COMPRESSION 是速度和压缩率之间的平衡 (一般相当于设压缩等级为 6)。函数发生错误时抛出 <code>error</code> 异常。</p>
<p>在 3.6 版更改: 现在，<em>level</em> 可作为关键字参数。</p>
<p><code>zlib.compressobj</code>(<em>level=-1</em>, <em>method=DEFLATED</em>, <em>wbits=MAX_WBITS</em>, <em>memLevel=DEF_MEM_LEVEL</em>, <em>strategy=Z_DEFAULT_STRATEGY</em>[, <em>zdict</em>])</p>
<p>返回一个 压缩对象，用来压缩内存中难以容下的数据流。</p>
<p>参数 <em>level</em> 为压缩等级，是整数，可取值为 <code>0</code> 到 <code>9</code> 或 <code>-1</code>。<code>1</code> (Z_BEST_SPEED) 表示最快速度和最低压缩率，<code>9</code> (Z_BEST_COMPRESSION) 表示最慢速度和最高压缩率。<code>0</code> (Z_NO_COMPRESSION) 表示不压缩。参数默认值为 <code>-1</code> (Z_DEFAULT_COMPRESSION)。Z_DEFAULT_COMPRESSION 是速度和压缩率之间的平衡 (一般相当于设压缩等级为 6)。</p>
<p><em>method</em> 表示压缩算法。现在只支持 <code>DEFLATED</code> 这个算法。</p>
<p>参数 <em>wbits</em> 指定压缩数据时所使用的历史缓冲区的大小 (窗口大小)，并指定压缩输出是否包含头部或尾部。参数的默认值是 <code>15</code> (MAX_WBITS)。参数的值分为几个范围：</p>
<ul>
<li>+9 至 +15：窗口大小以二为底的对数。 即这些值对应着 512 至 32768 的窗口大小。 更大的值会提供更好的压缩，同时内存开销也会更大。 压缩输出会包含 zlib 特定格式的头部和尾部。</li>
<li>−9 至 −15：绝对值为窗口大小以二为底的对数。 压缩输出仅包含压缩数据，没有头部和尾部。</li>
<li>+25 至 +31 = 16 + (9 至 15)：后 4 个比特位为窗口大小以二为底的对数。 压缩输出包含一个基本的 <strong>gzip</strong> 头部，并以校验和为尾部。</li>
</ul>
<p>参数 <em>memLevel</em> 指定内部压缩操作时所占用内存大小。参数取 <code>1</code> 到 <code>9</code>。更大的值占用更多的内存，同时速度也更快输出也更小。</p>
<p>参数 <em>strategy</em> 用于调节压缩算法。可取值为 <code>Z_DEFAULT_STRATEGY</code>、<code>Z_FILTERED</code>、<code>Z_HUFFMAN_ONLY</code>、<code>Z_RLE</code> (zlib 1.2.0.1) 或 <code>Z_FIXED</code> (zlib 1.2.2.2)。</p>
<p>参数 <em>zdict</em> 指定预定义的压缩字典。它是一个字节序列 (如 <code>bytes</code> 对象)，其中包含用户认为要压缩的数据中可能频繁出现的子序列。频率高的子序列应当放在字典的尾部。</p>
<p>在 3.3 版更改: 添加关键字参数 <em>zdict</em>。</p>
<p><code>zlib.crc32</code>(<em>data</em>[, <em>value</em>])</p>
<p>计算 <em>data</em> 的 CRC (循环冗余校验) 值。计算的结果是一个 32 位的整数。参数 <em>value</em> 是校验时的起始值，其默认值为 0。借助参数 <em>value</em> 可为分段的输入计算校验值。此算法没有加密强度，不应用于身份验证和数字签名。此算法的目的仅为验证数据的正确性，不适合作为通用散列算法。</p>
<p>在 3.0 版更改: 返回值永远是无符号数。要在所有的 Python 版本和平台上获得相同的值，请使用 <code>crc32(data) &amp; 0xffffffff</code>。</p>
<p><code>zlib.decompress</code>(<em>data</em>, <em>/</em>, <em>wbits=MAX_WBITS</em>, <em>bufsize=DEF_BUF_SIZE</em>)</p>
<p>解压 <em>data</em> 中的字节，返回含有已解压内容的 bytes 对象。参数 <em>wbits</em> 取决于 <em>data</em> 的格式，具体参见下边的说明。<em>bufsize</em> 为输出缓冲区的起始大小。函数发生错误时抛出 <code>error</code> 异常。</p>
<p><em>wbits</em> 形参控制历史缓冲区的大小（或称“窗口大小”）以及所期望的头部和尾部格式。 它类似于 <code>compressobj()</code> 的形参，但可接受更大范围的值：</p>
<ul>
<li>+8 至 +15：窗口尺寸以二为底的对数。 输入必须包含 zlib 头部和尾部。</li>
<li>0：根据 zlib 头部自动确定窗口大小。 只从 zlib 1.2.3.5 版起受支持。</li>
<li>−8 至 −15：使用 <em>wbits</em> 的绝对值作为窗口大小以二为底的对数。 输入必须为原始数据流，没有头部和尾部。</li>
<li>+24 至 +31 = 16 + (8 至 15)：使用后 4 个比特位作为窗口大小以二为底的对数。 输入必须包括 gzip 头部和尾部。</li>
<li>+40 至 +47 = 32 + (8 至 15)：使用后 4 个比特位作为窗口大小以二为底的对数，并且自动接受 zlib 或 gzip 格式。</li>
</ul>
<p>当解压缩一个数据流时，窗口大小必须不小于用于压缩数据流的原始窗口大小；使用太小的值可能导致 <code>error</code> 异常。 默认 <em>wbits</em> 值对应于最大的窗口大小并且要求包括 zlib 头部和尾部。</p>
<p><em>bufsize</em> 是用于存放解压数据的缓冲区初始大小。 如果需要更大空间，缓冲区大小将按需增加，因此你不需要让这个值完全精确；对其进行调整仅会节省一点对 <code>malloc()</code> 的调用次数。</p>
<p>在 3.6 版更改: <em>wbits</em> 和 <em>bufsize</em> 可用作关键字参数。</p>
<p><code>zlib.decompressobj</code>(<em>wbits=MAX_WBITS</em>[, <em>zdict</em>])</p>
<p>返回一个解压对象，用来解压无法被一次性放入内存的数据流。</p>
<p><em>wbits</em> 形参控制历史缓冲区的大小（或称“窗口大小”）以及所期望的头部和尾部格式。 它的含义与 对 decompress() 的描述 相同。</p>
<p><em>zdict</em> 形参指定指定一个预定义的压缩字典。 如果提供了此形参，它必须与产生将解压数据的压缩器所使用的字典相同。</p>
<p>注解</p>
<p>如果 <em>zdict</em> 是一个可变对象 (例如 <code>bytearray</code>)，则你不可在对 <code>decompressobj()</code> 的调用和对解压器的 <code>decompress()</code> 方法的调用之间修改其内容。</p>
<p>在 3.3 版更改: 增加了 <em>zdict</em> 形参。</p>
<p>压缩对象支持以下方法：</p>
<p><code>Compress.compress</code>(<em>data</em>)</p>
<p>压缩 <em>data</em> 并返回 bytes 对象，这个对象含有 <em>data</em> 的部分或全部内容的已压缩数据。所得的对象必须拼接在上一次调用 <code>compress()</code> 方法所得数据的后面。缓冲区中可能留存部分输入以供下一次调用。</p>
<p><code>Compress.flush</code>([<em>mode</em>])</p>
<p>压缩所有缓冲区的数据并返回已压缩的数据。参数 <em>mode</em> 可以传入的常量为：<code>Z_NO_FLUSH</code>、<code>Z_PARTIAL_FLUSH</code>、<code>Z_SYNC_FLUSH</code>、<code>Z_FULL_FLUSH</code>、<code>Z_BLOCK</code> (zlib 1.2.3.4) 或 <code>Z_FINISH</code>。默认值为 <code>Z_FINISH</code>。<code>Z_FINISH</code> 关闭已压缩数据流并不允许再压缩其他数据，<code>Z_FINISH</code> 以外的值皆允许这个对象继续压缩数据。调用 <code>flush()</code> 方法并将 <em>mode</em> 设为 <code>Z_FINISH</code> 后会无法再次调用 <code>compress()</code>，此时只能删除这个对象。</p>
<p><code>Compress.copy</code>()</p>
<p>返回此压缩对象的一个拷贝。它可以用来高效压缩一系列拥有相同前缀的数据。</p>
<p>在 3.8 版更改: 添加了对压缩对象执行 <code>copy.copy()</code> 和 <code>copy.deepcopy()</code> 的支持。</p>
<p>解压缩对象支持以下方法：</p>
<pre><code>Decompress.unused_data</code></pre><p>一个 bytes 对象，其中包含压缩数据结束之后的任何字节数据。 也就是说，它将为 <code>b""</code> 直到包含压缩数据的末尾字节可用。 如果整个结果字节串都包含压缩数据，它将为一个空的 bytes 对象 <code>b""</code>。</p>
<pre><code>Decompress.unconsumed_tail</code></pre><p>一个 bytes 对象，其中包含未被上一次 <code>decompress()</code> 调用所消耗的任何数据。 此数据不能被 zlib 机制看到，因此你必须将其送回（可能要附带额外的数据拼接）到后续的 <code>decompress()</code> 方法调用以获得正确的输出。</p>
<pre><code>Decompress.eof</code></pre><p>一个布尔值，指明是否已到达压缩数据流的末尾。</p>
<p>这使得区分正确构造的压缩数据流和不完整或被截断的压缩数据流成为可能。</p>
<p>3.3 新版功能.</p>
<p><code>Decompress.decompress</code>(<em>data</em>, <em>max_length=0</em>)</p>
<p>解压缩 <em>data</em> 并返回 bytes 对象，其中包含对应于 <em>string</em> 中至少一部分数据的解压缩数据。 此数据应当被拼接到之前任何对 <code>decompress()</code> 方法的调用所产生的输出。 部分输入数据可能会被保留在内部缓冲区以供后续处理。</p>
<p>如果可选的形参 <em>max_length</em> 非零则返回值将不会长于 <em>max_length*。 这可能意味着不是所有已压缩输入都能被处理；并且未被消耗的数据将被保存在 <code>unconsumed_tail</code> 属性中。 如果要继续解压缩则这个字节串必须被传给对 <code>decompress()</code> 的后续调用。 如果 *max_length</em> 为零则整个输入都会被解压缩，并且 <code>unconsumed_tail</code> 将为空。</p>
<p>在 3.6 版更改: <em>max_length</em> 可用作关键字参数。</p>
<p><code>Decompress.flush</code>([<em>length</em>])</p>
<p>所有挂起的输入会被处理，并且返回包含剩余未压缩输出的 bytes 对象。 在调用 <code>flush()</code> 之后，<code>decompress()</code> 方法将无法被再次调用；唯一可行的操作是删除该对象。</p>
<p>可选的形参 <em>length</em> 设置输出缓冲区的初始大小。</p>
<p><code>Decompress.copy</code>()</p>
<p>返回解压缩对象的一个拷贝。 它可以用来在数据流的中途保存解压缩器的状态以便加快随机查找数据流后续位置的速度。</p>
<p>在 3.8 版更改: 添加了对解压缩对象执行 <code>copy.copy()</code> 和 <code>copy.deepcopy()</code> 的支持。</p>
<p>通过下列常量可获取模块所使用的 zlib 库的版本信息：</p>
<pre><code>zlib.ZLIB_VERSION</code></pre><p>构建此模块时所用的 zlib 库的版本字符串。它的值可能与运行时所加载的 zlib 不同。运行时加载的 zlib 库的版本字符串为 <code>ZLIB_RUNTIME_VERSION</code>。</p>
<pre><code>zlib.ZLIB_RUNTIME_VERSION</code></pre><p>解释器所加载的 zlib 库的版本字符串。</p>
<p>3.3 新版功能.</p>
<p>参见</p>
<p><a href="http://www.zlib.net/" target="_blank" rel="noopener">http://www.zlib.net</a></p>
<p>zlib 库项目主页。</p>
<p><a href="http://www.zlib.net/manual.html" target="_blank" rel="noopener">http://www.zlib.net/manual.html</a></p>
<p>zlib 库用户手册。提供了库的许多功能的解释和用法。</p>
<h2 id="gzip-—-对-gzip-格式的支持"><a href="#gzip-—-对-gzip-格式的支持" class="headerlink" title="gzip —- 对 gzip 格式的支持"></a><code>gzip</code> —- 对 <strong>gzip</strong> 格式的支持</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/gzip.py" target="_blank" rel="noopener">Lib/gzip.py</a></p>
<hr>
<p>此模块提供的简单接口帮助用户压缩和解压缩文件，功能类似于 GNU 应用程序 <strong>gzip</strong> 和 <strong>gunzip</strong>。</p>
<p>数据压缩由 <code>zlib</code> 模块提供。</p>
<p><code>gzip</code> 模块提供 <code>GzipFile</code> 类和 <code>open()</code>、<code>compress()</code>、<code>decompress()</code> 几个便利的函数。<code>GzipFile</code> 类可以读写 <strong>gzip</strong> 格式的文件，还能自动压缩和解压缩数据，这让操作压缩文件如同操作普通的 file object 一样方便。</p>
<p>注意，此模块不支持部分可以被 <strong>gzip</strong> 和 <strong>gunzip</strong> 解压的格式，如利用 <strong>compress</strong> 或 <strong>pack</strong> 压缩所得的文件。</p>
<p>这个模块定义了以下内容：</p>
<p><code>gzip.open</code>(<em>filename</em>, <em>mode=’rb’</em>, <em>compresslevel=9</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>)</p>
<p>以二进制方式或者文本方式打开一个 gzip 格式的压缩文件，返回一个 file object。</p>
<p><em>filename</em> 参数可以是一个实际的文件名(一个a <code>str</code> 对象或者 <code>bytes</code> 对象), 或者是一个用来读写的已存在的文件对象。</p>
<p><em>mode</em> 参数可以是二进制模式： <code>'r'</code>, <code>'rb'</code>, <code>'a'</code>, <code>'ab'</code>, <code>'w'</code>, <code>'wb'</code>, <code>'x'</code> or <code>'xb'</code> , 或者是文本模式 <code>'rt'</code>, <code>'at'</code>, <code>'wt'</code>, or <code>'xt'</code>。默认值是 <code>'rb'</code>。</p>
<p>The <em>compresslevel</em> argument is an integer from 0 to 9, as for the <code>GzipFile</code> constructor.</p>
<p>对于二进制模式，这个函数等价于 <code>GzipFile</code> 构造器：<code>GzipFile(filename, mode, compresslevel)</code>。在这个例子中，<em>encoding</em>, <em>errors</em> 和 <em>newline</em> 三个参数一定不要设置。</p>
<p>对于文本模式，将会创建一个 <code>GzipFile</code> 对象，并将它封装到一个 <code>io.TextIOWrapper</code> 实例中， 这个实例默认了指定编码，错误抓获行为和行。</p>
<p>在 3.3 版更改: 支持 <em>filename</em> 为一个文件对象，支持文本模式和 <em>encoding</em>, <em>errors</em> 和 <em>newline</em> 参数。</p>
<p>在 3.4 版更改: 支持 <code>'x'</code>, <code>'xb'</code> 和<code>‘xt’</code> 三种模式。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><em>exception</em> <code>gzip.BadGzipFile</code></p>
<p>针对无效 gzip 文件引发的异常。 它继承自 <code>OSError</code>。 针对无效 gzip 文件也可能引发 <code>EOFError</code> 和 <code>zlib.error</code>。</p>
<p>3.8 新版功能.</p>
<p><em>class</em> <code>gzip.GzipFile</code>(<em>filename=None</em>, <em>mode=None</em>, <em>compresslevel=9</em>, <em>fileobj=None</em>, <em>mtime=None</em>)</p>
<p><code>GzipFile</code> 类的构造器支持 <code>truncate()</code> 的异常，与 file object 的大多数方法非常相似。<em>fileobj</em> 和 <em>filename</em> 至少有一个不为空。</p>
<p>新的实例基于 <em>fileobj*，它可以是一个普通文件，一个 <code>io.BytesIO</code> 对象，或者任何一个与文件相似的对象。当 *filename</em> 是一个文件对象时，它的默认值是 <code>None</code>。</p>
<p>当 <em>fileobj</em> 为 <code>None</code> 时， <em>filename</em> 参数只用于 <strong>gzip</strong> 文件头中，这个文件有可能包含未压缩文件的源文件名。如果文件可以被识别，默认 <em>fileobj</em> 的文件名；否则默认为空字符串，在这种情况下文件头将不包含源文件名。</p>
<p><em>mode</em> 参数可以是 <code>'r'</code>, <code>'rb'</code>, <code>'a'</code>, <code>'ab'</code>, <code>'w'</code>, <code>'wb'</code>, <code>'x'</code> 或 <code>'xb'</code> 中的一个，具体取决于文件将被读取还是被写入。 如果可识别则默认为 <em>fileobj</em> 的模式；否则默认为 <code>'rb'</code>。 在未来的 Python 发布版中将不再使用 <em>fileobj</em> 的模式。 最好总是指定 <em>mode</em> 为写入模式。</p>
<p>需要注意的是，文件默认使用二进制模式打开。如果要以文本模式打开文件一个压缩文件，请使用 <code>open()</code> 方法(或者使用 <code>io.TextIOWrapper</code> 包装 <code>GzipFile</code> )。</p>
<p><em>compresslevel</em> 参数是一个从 <code>0</code> 到 <code>9</code> 的整数，用于控制压缩等级；<code>1</code> 最快但压缩比例最小，<code>9</code> 最慢但压缩比例最大。 <code>0</code> 不压缩。默认为 <code>9</code>。</p>
<p><em>mtime</em> 参数是一个可选的数字时间戳用于写入流的最后修改字段，。<em>mtime</em> 只在压缩模式中使用。如果省略或者值为 <code>None</code>，则使用当前时间。</p>
<p>调用 <code>GzipFile</code> 的 <code>close()</code> 方法不会关闭 <em>fileobj</em>，因为你可以希望增加其它内容到已经压缩的数中。你可以将一个 <code>io.BytesIO</code> 对象作为 <em>fileobj</em>，也可以使用 <code>io.BytesIO</code> 的 <code>getvalue()</code> 方法从内存缓存中恢复数据。</p>
<p><code>GzipFile</code> 支持 <code>io.BufferedIOBase</code> 类的接口, 包括迭代和 <code>with</code> 语句。只有 <code>truncate()</code> 方法没有实现。</p>
<p><code>GzipFile</code> 还提供了以下的方法和属性:</p>
<ul>
<li><p><code>peek</code>(<em>n</em>)</p>
<p>在不移动文件指针的情况下读取 <em>n</em> 个未压缩字节。最多只有一个单独的读取流来服务这个方法调用。返回的字节数不一定刚好等于要求的数量。</p>
<p>注解</p>
<p>调用 <code>peek()</code> 并没有改变 <code>GzipFile</code> 的文件指针，它可能改变潜在文件对象(例如： <code>GzipFile</code> 使用 <em>fileobj</em> 参数进行初始化)。</p>
<p>3.2 新版功能.</p>
</li>
<li><p><code>mtime</code></p>
<p>在解压的过程中，最后修改时间字段的值可能来自于这个属性，以整数的形式出现。在读取任何文件头信息前，初始值为 <code>None</code>。</p>
<p>所有 <strong>gzip</strong> 东方压缩流中必须包含时间戳这个字段。以便于像 <strong>gunzip</strong>这样的程序可以使用时间戳。格式与 <code>time.time()</code> 的返回值和 <code>os.stat()</code> 对象的 <code>st_mtime</code> 属性值一样。</p>
</li>
</ul>
<p>在 3.1 版更改: 支持 <code>with</code> 语句，构造器参数 <em>mtime</em> 和 <code>mtime</code> 属性。</p>
<p>在 3.2 版更改: 添加了对零填充和不可搜索文件的支持。</p>
<p>在 3.3 版更改: 实现 <code>io.BufferedIOBase.read1()</code> 方法。</p>
<p>在 3.4 版更改: 支持 <code>'x'</code> and <code>'xb'</code> 两种模式。</p>
<p>在 3.5 版更改: 支持写入任意 bytes-like objects。<code>read()</code> 方法可以接受<code>None</code>为参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>3.9 版后已移除: 打开 <code>GzipFile</code> 用于写入而不指定 <em>mode</em> 参数的做法已被弃用。</p>
<p><code>gzip.compress</code>(<em>data</em>, <em>compresslevel=9</em>, <em>**,</em> mtime=None*)</p>
<p>压缩 <em>data*，返回一个包含压缩数据的 <code>bytes</code> 对象。 *compresslevel</em> 和 <em>mtime</em> 的含义与上文中 <code>GzipFile</code> 构造器的相同。</p>
<p>3.2 新版功能.</p>
<p>在 3.8 版更改: 添加了 <em>mtime</em> 形参用于可重复的输出。</p>
<p><code>gzip.decompress</code>(<em>data</em>)</p>
<p>解压缩 <em>data</em>，返回一个包含未压缩数据的 <code>bytes</code> 对象。</p>
<p>3.2 新版功能.</p>
<h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><p>读取压缩文件示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> gzip
<span class="token keyword">with</span> gzip<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'/home/joe/file.txt.gz'</span><span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    file_content <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>创建GZIP 文件示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> gzip
content <span class="token operator">=</span> b<span class="token string">"Lots of content here"</span>
<span class="token keyword">with</span> gzip<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'/home/joe/file.txt.gz'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>content<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 GZIP 压缩已有的文件示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> gzip
<span class="token keyword">import</span> shutil
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'/home/joe/file.txt'</span><span class="token punctuation">,</span> <span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f_in<span class="token punctuation">:</span>
    <span class="token keyword">with</span> gzip<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'/home/joe/file.txt.gz'</span><span class="token punctuation">,</span> <span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f_out<span class="token punctuation">:</span>
        shutil<span class="token punctuation">.</span>copyfileobj<span class="token punctuation">(</span>f_in<span class="token punctuation">,</span> f_out<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 GZIP 压缩二进制字符串示例：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> gzip
s_in <span class="token operator">=</span> b<span class="token string">"Lots of content here"</span>
s_out <span class="token operator">=</span> gzip<span class="token punctuation">.</span>compress<span class="token punctuation">(</span>s_in<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="命令行界面"><a href="#命令行界面" class="headerlink" title="命令行界面"></a>命令行界面</h3><p><code>gzip</code> 模块提供了简单的命令行界面用于压缩和解压缩文件。</p>
<p>在执行后 <code>gzip</code> 模块会保留输入文件。</p>
<p>在 3.8 版更改: 添加一个带有用法说明的新命令行界面命令。 默认情况下，当你要执行 CLI 时，默认压缩等级为 6。</p>
<h4 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h4><pre><code>file</code></pre><p>如果 <em>file</em> 未指定，则从 <code>sys.stdin</code> 读取。</p>
<pre><code>--fast</code></pre><p>指明最快速的压缩方法（较低压缩率）。</p>
<pre><code>--best</code></pre><p>指明最慢速的压缩方法（最高压缩率）。</p>
<pre><code>-d``,` `--decompress</code></pre><p>解压缩给定的文件。</p>
<pre><code>-h``,` `--help</code></pre><p>显示帮助消息。</p>
<h2 id="bz2-—-对-bzip2-压缩算法的支持"><a href="#bz2-—-对-bzip2-压缩算法的支持" class="headerlink" title="bz2 —- 对 bzip2 压缩算法的支持"></a><code>bz2</code> —- 对 <strong>bzip2</strong> 压缩算法的支持</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/bz2.py" target="_blank" rel="noopener">Lib/bz2.py</a></p>
<hr>
<p>此模块提供了使用 bzip2 压缩算法压缩和解压数据的一套完整的接口。</p>
<p><code>bz2</code> 模块包含：</p>
<ul>
<li>用于读写压缩文件的 <code>open()</code> 函数和 <code>BZ2File</code> 类。</li>
<li>用于增量压缩和解压的 <code>BZ2Compressor</code> 和 <code>BZ2Decompressor</code> 类。</li>
<li>用于一次性压缩和解压的 <code>compress()</code> 和 <code>decompress()</code> 函数。</li>
</ul>
<h3 id="文件压缩和解压"><a href="#文件压缩和解压" class="headerlink" title="文件压缩和解压"></a>文件压缩和解压</h3><p><code>bz2.open</code>(<em>filename</em>, <em>mode=’rb’</em>, <em>compresslevel=9</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>)</p>
<p>以二进制或文本模式打开 bzip2 压缩文件，返回一个 file object。</p>
<p>和 <code>BZ2File</code> 的构造函数类似，<em>filename</em> 参数可以是一个实际的文件名（<code>str</code> 或 <code>bytes</code> 对象），或是已有的可供读取或写入的文件对象。</p>
<p><em>mode</em> 参数可设为二进制模式的 <code>'r'</code>、<code>'rb'</code>、<code>'w'</code>、<code>'wb'</code>、<code>'x'</code>、<code>'xb'</code>、<code>'a'</code> 或 <code>'ab'</code>，或者文本模式的 <code>'rt'</code>、<code>'wt'</code>、<code>'xt'</code> 或 <code>'at'</code>。默认是 <code>'rb'</code>。</p>
<p><em>compresslevel</em> 参数是 1 到 9 的整数，和 <code>BZ2File</code> 的构造函数一样。</p>
<p>对于二进制模式，这个函数等价于 <code>BZ2File</code> 构造器: <code>BZ2File(filename, mode, compresslevel=compresslevel)</code>。 在这种情况下，不可提供 <em>encoding</em>, <em>errors</em> 和 <em>newline</em> 参数。</p>
<p>对于文本模式，将会创建一个 <code>BZ2File</code> 对象，并将它包装到一个 <code>io.TextIOWrapper</code> 实例中，此实例带有指定的编码格式、错误处理行为和行结束符。</p>
<p>3.3 新版功能.</p>
<p>在 3.4 版更改: 添加了 <code>'x'</code> (单独创建) 模式。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><em>class</em> <code>bz2.BZ2File</code>(<em>filename</em>, <em>mode=’r’</em>, <em>**,</em> compresslevel=9*)</p>
<p>用二进制模式打开 bzip2 压缩文件。</p>
<p>如果 <em>filename</em> 是一个 <code>str</code> 或 <code>bytes</code> 对象，则打开名称对应的文件目录。 否则的话，<em>filename</em> 应当是一个 file object，它将被用来读取或写入压缩数据。</p>
<p><em>mode</em> 参数可以是表示读取的 <code>'r'</code> (默认值)，表示覆写的 <code>'w'</code>，表示单独创建的 <code>'x'</code>，或表示添加的 <code>'a'</code>。 这些模式还可分别以 <code>'rb'</code>, <code>'wb'</code>, <code>'xb'</code> 和 <code>'ab'</code> 的等价形式给出。</p>
<p>如果 <em>filename</em> 是一个文件对象（而不是实际的文件名），则 <code>'w'</code> 模式并不会截断文件，而是会等价于 <code>'a'</code>。</p>
<p>如果 <em>mode</em> 为 <code>'w'</code> 或 <code>'a'</code>，则 <em>compresslevel</em> 可以是 <code>1</code> 到 <code>9</code> 之间的整数，用于指定压缩等级: <code>1</code> 产生最低压缩率，而 <code>9</code> (默认值) 产生最高压缩率。</p>
<p>如果 <em>mode</em> 为 <code>'r'</code>，则输入文件可以为多个压缩流的拼接。</p>
<p><code>BZ2File</code> 提供了 <code>io.BufferedIOBase</code> 所指定的所有成员，但 <code>detach()</code> 和 <code>truncate()</code> 除外。 并支持迭代和 <code>with</code> 语句。</p>
<p><code>BZ2File</code> 还提供了以下方法：</p>
<ul>
<li><p><code>peek</code>([<em>n</em>])</p>
<p>返回缓冲的数据而不前移文件位置。 至少将返回一个字节的数据（除非为 EOF）。 实际返回的字节数不确定。</p>
<p>注解</p>
<p>虽然调用 <code>peek()</code> 不会改变 <code>BZ2File</code> 的文件位置，但它可能改变下层文件对象的位置（举例来说如果 <code>BZ2File</code> 是通过传入一个文件对象作为 <em>filename</em> 的话）。</p>
<p>3.3 新版功能.</p>
</li>
</ul>
<p>在 3.1 版更改: 添加了对 <code>with</code> 语句的支持。</p>
<p>在 3.3 版更改: 添加了 <code>fileno()</code>, <code>readable()</code>, <code>seekable()</code>, <code>writable()</code>, <code>read1()</code> 和 <code>readinto()</code> 方法。</p>
<p>在 3.3 版更改: 添加了对 <em>filename</em> 使用 file object 而非实际文件名的支持。</p>
<p>在 3.3 版更改: 添加了 <code>'a'</code> (append) 模式，以及对读取多数据流文件的支持。</p>
<p>在 3.4 版更改: 添加了 <code>'x'</code> (单独创建) 模式。</p>
<p>在 3.5 版更改: <code>read()</code> 方法现在接受 <code>None</code> 作为参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>在 3.9 版更改: <em>buffering</em> 形参已被移除。 它自 Python 3.0 起即被忽略并弃用。 请传入一个打开文件对象来控制文件的打开方式。</p>
<p><em>compresslevel</em> 形参成为仅限关键字参数。</p>
<p>在 3.10 版更改: 这个类在面对多个同时读取器和写入器时是线程安全的，就如它在 <code>gzip</code> 和 <code>lzma</code> 中的等价类所具有的特性一样。</p>
<h3 id="增量压缩和解压"><a href="#增量压缩和解压" class="headerlink" title="增量压缩和解压"></a>增量压缩和解压</h3><p><em>class</em> <code>bz2.BZ2Compressor</code>(<em>compresslevel=9</em>)</p>
<p>创建一个新的压缩器对象。 此对象可被用来执行增量数据压缩。 对于一次性压缩，请改用 <code>compress()</code> 函数。</p>
<p>如果给定 <em>compresslevel</em>，它必须为 <code>1</code> 至 <code>9</code> 之间的整数。 默认值为 <code>9</code>。</p>
<ul>
<li><p><code>compress</code>(<em>data</em>)</p>
<p>向压缩器对象提供数据。 在可能的情况下返回一段已压缩数据，否则返回空字节串。</p>
<p>当你已结束向压缩器提供数据时，请调用 <code>flush()</code> 方法来完成压缩进程。</p>
</li>
<li><p><code>flush</code>()</p>
<p>结束压缩进程，返回内部缓冲中剩余的压缩完成的数据。</p>
<p>调用此方法之后压缩器对象将不可再被使用。</p>
</li>
</ul>
<p><em>class</em> <code>bz2.BZ2Decompressor</code></p>
<p>创建一个新的解压缩器对象。 此对象可被用来执行增量数据解压缩。 对于一次性解压缩，请改用 <code>decompress()</code> 函数。</p>
<p>注解</p>
<p>这个类不会透明地处理包含多个已压缩数据流的输入，这不同于 <code>decompress()</code> 和 <code>BZ2File</code>。 如果你需要通过 <code>BZ2Decompressor</code> 来解压缩多个数据流输入，你必须为每个数据流都使用新的解压缩器。</p>
<ul>
<li><p><code>decompress</code>(<em>data</em>, <em>max_length=- 1</em>)</p>
<p>解压缩 <em>data</em> (一个 bytes-like object)，返回字节串形式的解压缩数据。 某些 <em>data</em> 可以在内部被缓冲，以便用于后续的 <code>decompress()</code> 调用。 返回的数据应当与之前任何 <code>decompress()</code> 调用的输出进行拼接。</p>
<p>如果 <em>max_length</em> 为非负数，将返回至多 <em>max_length</em> 个字节的解压缩数据。 如果达到此限制并且可以产生后续输出，则 <code>needs_input</code> 属性将被设为 <code>False</code>。 在这种情况下，下一次 <code>decompress()</code> 调用提供的 <em>data</em> 可以为 <code>b''</code> 以获取更多的输出。</p>
<p>如果所有输入数据都已被解压缩并返回（或是因为它少于 <em>max_length</em> 个字节，或是因为 <em>max_length</em> 为负数），则 <code>needs_input</code> 属性将被设为 <code>True</code>。</p>
<p>在到达数据流末尾之后再尝试解压缩数据会引发 EOFError。 在数据流末尾之后获取的任何数据都会被忽略并存储至 <code>unused_data</code> 属性。</p>
<p>在 3.5 版更改: 添加了 <em>max_length</em> 形参。</p>
</li>
<li><p><code>eof</code></p>
<p>若达到了数据流的末尾标记则为 <code>True</code>。</p>
<p>3.3 新版功能.</p>
</li>
<li><p><code>unused_data</code></p>
<p>在压缩数据流的末尾之后获取的数据。</p>
<p>如果在达到数据流末尾之前访问此属性，其值将为 <code>b''</code>。</p>
</li>
<li><p><code>needs_input</code></p>
<p>如果在要求新的未解压缩输入之前 <code>decompress()</code> 方法可以提供更多的解压缩数据则为 <code>False</code>。</p>
<p>3.5 新版功能.</p>
</li>
</ul>
<h3 id="一次性压缩或解压缩"><a href="#一次性压缩或解压缩" class="headerlink" title="一次性压缩或解压缩"></a>一次性压缩或解压缩</h3><p><code>bz2.compress</code>(<em>data</em>, <em>compresslevel=9</em>)</p>
<p>压缩 <em>data</em>，此参数为一个 字节类对象。</p>
<p>如果给定 <em>compresslevel</em>，它必须为 <code>1</code> 至 <code>9</code> 之间的整数。 默认值为 <code>9</code>。</p>
<p>对于增量压缩，请改用 <code>BZ2Compressor</code>。</p>
<p><code>bz2.decompress</code>(<em>data</em>)</p>
<p>解压缩 <em>data</em>，此参数为一个 字节类对象。</p>
<p>如果 <em>data</em> 是多个压缩数据流的拼接，则解压缩所有数据流。</p>
<p>对于增量解压缩，请改用 <code>BZ2Decompressor</code>。</p>
<p>在 3.3 版更改: 支持了多数据流的输入。</p>
<h3 id="用法示例-1"><a href="#用法示例-1" class="headerlink" title="用法示例"></a>用法示例</h3><p>以下是 <code>bz2</code> 模块典型用法的一些示例。</p>
<p>使用 <code>compress()</code> 和 <code>decompress()</code> 来显示往复式的压缩：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> bz2
<span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span> b<span class="token triple-quoted-string string">"""\
... Donec rhoncus quis sapien sit amet molestie. Fusce scelerisque vel augue
... nec ullamcorper. Nam rutrum pretium placerat. Aliquam vel tristique lorem,
... sit amet cursus ante. In interdum laoreet mi, sit amet ultrices purus
... pulvinar a. Nam gravida euismod magna, non varius justo tincidunt feugiat.
... Aliquam pharetra lacus non risus vehicula rutrum. Maecenas aliquam leo
... felis. Pellentesque semper nunc sit amet nibh ullamcorper, ac elementum
... dolor luctus. Curabitur lacinia mi ornare consectetur vestibulum."""</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> bz2<span class="token punctuation">.</span>compress<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> len<span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">/</span> len<span class="token punctuation">(</span>c<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># Data compression ratio</span>
<span class="token number">1.513595166163142</span>
<span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> bz2<span class="token punctuation">.</span>decompress<span class="token punctuation">(</span>c<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">==</span> d  <span class="token comment" spellcheck="true"># Check equality to original object after round-trip</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>BZ2Compressor</code> 进行增量压缩：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> bz2
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">gen_data</span><span class="token punctuation">(</span>chunks<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> chunksize<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token triple-quoted-string string">"""Yield incremental blocks of chunksize bytes."""</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>chunks<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">yield</span> b<span class="token string">"z"</span> <span class="token operator">*</span> chunksize
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> comp <span class="token operator">=</span> bz2<span class="token punctuation">.</span>BZ2Compressor<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> out <span class="token operator">=</span> b<span class="token string">""</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> chunk <span class="token keyword">in</span> gen_data<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token comment" spellcheck="true"># Provide data to the compressor object</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     out <span class="token operator">=</span> out <span class="token operator">+</span> comp<span class="token punctuation">.</span>compress<span class="token punctuation">(</span>chunk<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># Finish the compression process.  Call this once you have</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true"># finished providing data to the compressor.</span>
<span class="token operator">>></span><span class="token operator">></span> out <span class="token operator">=</span> out <span class="token operator">+</span> comp<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的示例使用了十分“非随机”的数据流（即 b”z” 块数据流）。 随机数据的压缩率通常很差，而有序、重复的数据通常会产生很高的压缩率。</p>
<p>用二进制模式写入和读取 bzip2 压缩文件：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> bz2
<span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span> b<span class="token triple-quoted-string string">"""\
... Donec rhoncus quis sapien sit amet molestie. Fusce scelerisque vel augue
... nec ullamcorper. Nam rutrum pretium placerat. Aliquam vel tristique lorem,
... sit amet cursus ante. In interdum laoreet mi, sit amet ultrices purus
... pulvinar a. Nam gravida euismod magna, non varius justo tincidunt feugiat.
... Aliquam pharetra lacus non risus vehicula rutrum. Maecenas aliquam leo
... felis. Pellentesque semper nunc sit amet nibh ullamcorper, ac elementum
... dolor luctus. Curabitur lacinia mi ornare consectetur vestibulum."""</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> bz2<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"myfile.bz2"</span><span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token comment" spellcheck="true"># Write compressed data to file</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     unused <span class="token operator">=</span> f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> bz2<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"myfile.bz2"</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token comment" spellcheck="true"># Decompress data from file</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     content <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> content <span class="token operator">==</span> data  <span class="token comment" spellcheck="true"># Check equality to original object after round-trip</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="lzma-—-用-LZMA-算法压缩"><a href="#lzma-—-用-LZMA-算法压缩" class="headerlink" title="lzma —- 用 LZMA 算法压缩"></a><code>lzma</code> —- 用 LZMA 算法压缩</h2><p>3.3 新版功能.</p>
<p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/lzma.py" target="_blank" rel="noopener">Lib/lzma.py</a></p>
<hr>
<p>此模块提供了可以压缩和解压缩使用 LZMA 压缩算法的数据的类和便携函数。 其中还包含支持 <strong>xz</strong> 工具所使用的 <code>.xz</code> 和旧式 <code>.lzma</code> 文件格式的文件接口，以及相应的原始压缩数据流。</p>
<p>此模块所提供了接口与 <code>bz2</code> 模块的非常类似。 请注意 <code>LZMAFile</code> 和 <code>bz2.BZ2File</code> 都 <em>不是</em> 线程安全的。，因此如果你需要在多个线程中使用单个 <code>LZMAFile</code> 实例，则需要通过锁来保护它。</p>
<p><em>exception</em> <code>lzma.LZMAError</code></p>
<p>当在压缩或解压缩期间或是在初始化压缩器/解压缩器的状态期间发生错误时此异常会被引发。</p>
<h3 id="读写压缩文件"><a href="#读写压缩文件" class="headerlink" title="读写压缩文件"></a>读写压缩文件</h3><p><code>lzma.open</code>(<em>filename</em>, <em>mode=’rb’</em>, <em>**,</em> format=None<em>,</em> check=- 1<em>,</em> preset=None<em>,</em> filters=None<em>,</em> encoding=None<em>,</em> errors=None<em>,</em> newline=None*)</p>
<p>以二进制或文本模式打开 LZMA 压缩文件，返回一个 file object。</p>
<p><em>filename</em> 参数可以是一个实际的文件名（以 <code>str</code>, <code>bytes</code> 或 路径类 对象的形式给出），在此情况下会打开指定名称的文件，或者可以是一个用于读写的现有文件对象。</p>
<p><em>mode</em> 参数可以是二进制模式的 <code>"r"</code>, <code>"rb"</code>, <code>"w"</code>, <code>"wb"</code>, <code>"x"</code>, <code>"xb"</code>, <code>"a"</code> 或 <code>"ab"</code>，或者文本模式的 <code>"rt"</code>, <code>"wt"</code>, <code>"xt"</code> 或 <code>"at"</code>。 默认值为 <code>"rb"</code>。</p>
<p>当打开一个文件用于读取时，<em>format</em> 和 <em>filters</em> 参数具有与 <code>LZMADecompressor</code> 的参数相同的含义。 在此情况下，<em>check</em> 和 <em>preset</em> 参数不应被使用。</p>
<p>当打开一个文件用于写入的，<em>format</em>, <em>check</em>, <em>preset</em> 和 <em>filters</em> 参数具有与 <code>LZMACompressor</code> 的参数相同的含义。</p>
<p>对于二进制模式，这个函数等价于 <code>LZMAFile</code> 构造器: <code>LZMAFile(filename, mode, ...)</code>。 在这种情况下，不可提供 <em>encoding</em>, <em>errors</em> 和 <em>newline</em> 参数。</p>
<p>对于文本模式，将会创建一个 <code>LZMAFile</code> 对象，并将它包装到一个 <code>io.TextIOWrapper</code> 实例中，此实例带有指定的编码格式、错误处理行为和行结束符。</p>
<p>在 3.4 版更改: 增加了对 <code>"x"</code>, <code>"xb"</code> 和 <code>"xt"</code> 模式的支持。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><em>class</em> <code>lzma.LZMAFile</code>(<em>filename=None</em>, <em>mode=’r’</em>, <em>**,</em> format=None<em>,</em> check=- 1<em>,</em> preset=None<em>,</em> filters=None*)</p>
<p>以二进制模式打开一个 LZMA 压缩文件。</p>
<p><code>LZMAFile</code> 可以包装在一个已打开的 file object 中，或者是在给定名称的文件上直接操作。 <em>filename</em> 参数指定所包装的文件对象，或是要打开的文件名称（类型为 <code>str</code>, <code>bytes</code> 或 路径类 对象）。 如果是包装现有的文件对象，被包装的文件在 <code>LZMAFile</code> 被关闭时将不会被关闭。</p>
<p><em>mode</em> 参数可以是表示读取的 <code>"r"</code> (默认值)，表示覆写的 <code>"w"</code>，表示单独创建的 <code>"x"</code>，或表示添加的 <code>"a"</code>。 这些模式还可以分别以 <code>"rb"</code>, <code>"wb"</code>, <code>"xb"</code> 和 <code>"ab"</code> 的等价形式给出。</p>
<p>如果 <em>filename</em> 是一个文件对象（而不是实际的文件名），则 <code>"w"</code> 模式并不会截断文件，而会等价于 <code>"a"</code>。</p>
<p>当打开一个文件用于读取时，输入文件可以为多个独立压缩流的拼接。 它们会被作为单个逻辑流被透明地解码。</p>
<p>当打开一个文件用于读取时，<em>format</em> 和 <em>filters</em> 参数具有与 <code>LZMADecompressor</code> 的参数相同的含义。 在此情况下，<em>check</em> 和 <em>preset</em> 参数不应被使用。</p>
<p>当打开一个文件用于写入的，<em>format</em>, <em>check</em>, <em>preset</em> 和 <em>filters</em> 参数具有与 <code>LZMACompressor</code> 的参数相同的含义。</p>
<p><code>LZMAFile</code> 支持 <code>io.BufferedIOBase</code> 所指定的所有成员，但 <code>detach()</code> 和 <code>truncate()</code> 除外。 并支持迭代和 <code>with</code> 语句。</p>
<p>也提供以下方法：</p>
<ul>
<li><p><code>peek</code>(<em>size=- 1</em>)</p>
<p>返回缓冲的数据而不前移文件位置。 至少将返回一个字节的数据，除非已经到达 EOF。 实际返回的字节数不确定（会忽略 <em>size</em> 参数）。</p>
<p>注解</p>
<p>虽然调用 <code>peek()</code> 不会改变 <code>LZMAFile</code> 的文件位置，但它可能改变下层文件对象的位置（举例来说如果 <code>LZMAFile</code> 是通过传入一个文件对象作为 <em>filename</em> 的话）。</p>
</li>
</ul>
<p>在 3.4 版更改: 增加了对 <code>"x"</code> 和 <code>"xb"</code> 模式的支持。</p>
<p>在 3.5 版更改: <code>read()</code> 方法现在接受 <code>None</code> 作为参数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<h3 id="在内存中压缩和解压缩数据"><a href="#在内存中压缩和解压缩数据" class="headerlink" title="在内存中压缩和解压缩数据"></a>在内存中压缩和解压缩数据</h3><p><em>class</em> <code>lzma.LZMACompressor</code>(<em>format=FORMAT_XZ</em>, <em>check=- 1</em>, <em>preset=None</em>, <em>filters=None</em>)</p>
<p>创建一个压缩器对象，此对象可被用来执行增量压缩。</p>
<p>压缩单个数据块的更便捷方式请参阅 <code>compress()</code>。</p>
<p><em>format</em> 参数指定应当使用哪种容器格式。 可能的值有：</p>
<ul>
<li><p><code>FORMAT_XZ</code>: <code>.xz</code> 容器格式。</p>
<p>这是默认格式。</p>
</li>
<li><p><code>FORMAT_ALONE</code>: 传统的 <code>.lzma</code> 容器格式。</p>
<p>这种格式相比 <code>.xz</code> 更为受限 — 它不支持一致性检查或多重过滤器。</p>
</li>
<li><p><code>FORMAT_RAW</code>: 原始数据流，不使用任何容器格式。</p>
<p>这个格式描述器不支持一致性检查，并且要求你必须指定一个自定义的过滤器链（用于压缩和解压缩）。 此外，以这种方式压缩的数据不可使用 <code>FORMAT_AUTO</code> 来解压缩 。</p>
</li>
</ul>
<p><em>check</em> 参数指定要包含在压缩数据中的一致性检查类型。 这种检查在解压缩时使用，以确保数据没有被破坏。 可能的值是：</p>
<ul>
<li><code>CHECK_NONE</code>: 没有一致性检查。 这是 <code>FORMAT_ALONE</code> 和 <code>FORMAT_RAW</code> 的默认值（也是唯一可接受的值）。</li>
<li><code>CHECK_CRC32</code>: 32 位循环冗余检查。</li>
<li><code>CHECK_CRC64</code>: 64 位循环冗余检查。 这是 <code>FORMAT_XZ</code> 的默认值。</li>
<li><code>CHECK_SHA256</code>: 256 位安全哈希算法。</li>
</ul>
<p>如果指定的检查不受支持，则会引发 <code>LZMAError</code>。</p>
<p>压缩设置可被指定为一个预设的压缩等级（通过 <em>preset</em> 参数）或以自定义过滤器链来详细设置（通过 <em>filters</em> 参数）。</p>
<p><em>preset</em> 参数（如果提供）应当为一个 <code>0</code> 到 <code>9</code> (包括边界) 之间的整数，可以选择与常数 <code>PRESET_EXTREME</code> 进行 OR 运算。 如果 <em>preset</em> 和 <em>filters</em> 均未给出，则默认行为是使用 <code>PRESET_DEFAULT</code> (预设等级 <code>6</code>)。 更高的预设等级会产生更小的输出，但会使得压缩过程更缓慢。</p>
<p>注解</p>
<p>除了更加 CPU 密集，使用更高的预设等级来压缩还需要更多的内存（并产生需要更多内存来解压缩的输出）。 例如使用预设等级 <code>9</code> 时，一个 <code>LZMACompressor</code> 对象的开销可以高达 800 MiB。 出于这样的原因，通常最好是保持使用默认预设等级。</p>
<p><em>filters</em> 参数（如果提供）应当指定一个过滤器链。</p>
<ul>
<li><p><code>compress</code>(<em>data</em>)</p>
<p>压缩 <em>data</em> (一个 <code>bytes</code> object)，返回包含针对输入的至少一部分已压缩数据的 <code>bytes</code> 对象。 一部 <em>data</em> 可能会被放入内部缓冲区，以便用于后续的 <code>compress()</code> 和 <code>flush()</code> 调用。 返回的数据应当与之前任何 <code>compress()</code> 调用的输出进行拼接。</p>
</li>
<li><p><code>flush</code>()</p>
<p>结束压缩进程，返回包含保存在压缩器的内部缓冲区中的任意数据的 <code>bytes</code> 对象。</p>
<p>调用此方法之后压缩器将不可再被使用。</p>
</li>
</ul>
<p><em>class</em> <code>lzma.LZMADecompressor</code>(<em>format=FORMAT_AUTO</em>, <em>memlimit=None</em>, <em>filters=None</em>)</p>
<p>创建一个压缩器对象，此对象可被用来执行增量解压缩。</p>
<p><em>format</em> 参数指定应当被使用的容器格式。 默认值为 <code>FORMAT_AUTO</code>，它可以解压缩 <code>.xz</code> 和 <code>.lzma</code> 文件。 其他可能的值为 <code>FORMAT_XZ</code>, <code>FORMAT_ALONE</code> 和 <code>FORMAT_RAW</code>。</p>
<p><em>memlimit</em> 参数指定解压缩器可以使用的内存上限（字节数）。 当使用此参数时，如果不可能在给定内存上限之内解压缩输入数据则解压缩将失败并引发 <code>LZMAError</code>。</p>
<p><em>filters</em> 参数指定用于创建被解压缩数据流的过滤器链。 此参数在 <em>format</em> 为 <code>FORMAT_RAW</code> 时要求提供，但对于其他格式不应使用。 </p>
<p>注解</p>
<p>这个类不会透明地处理包含多个已压缩数据流的输入，这不同于 <code>decompress()</code> 和 <code>LZMAFile</code>。 要通过 <code>LZMADecompressor</code> 来解压缩多个数据流输入，你必须为每个数据流都创建一个新的解压缩器。</p>
<ul>
<li><p><code>decompress</code>(<em>data</em>, <em>max_length=- 1</em>)</p>
<p>解压缩 <em>data</em> (一个 bytes-like object)，返回字节串形式的解压缩数据。 某些 <em>data</em> 可以在内部被缓冲，以便用于后续的 <code>decompress()</code> 调用。 返回的数据应当与之前任何 <code>decompress()</code> 调用的输出进行拼接。</p>
<p>如果 <em>max_length</em> 为非负数，将返回至多 <em>max_length</em> 个字节的解压缩数据。 如果达到此限制并且可以产生后续输出，则 <code>needs_input</code> 属性将被设为 <code>False</code>。 在这种情况下，下一次 <code>decompress()</code> 调用提供的 <em>data</em> 可以为 <code>b''</code> 以获取更多的输出。</p>
<p>如果所有输入数据都已被解压缩并返回（或是因为它少于 <em>max_length</em> 个字节，或是因为 <em>max_length</em> 为负数），则 <code>needs_input</code> 属性将被设为 <code>True</code>。</p>
<p>在到达数据流末尾之后再尝试解压缩数据会引发 EOFError。 在数据流末尾之后获取的任何数据都会被忽略并存储至 <code>unused_data</code> 属性。</p>
<p>在 3.5 版更改: 添加了 <em>max_length</em> 形参。</p>
</li>
<li><p><code>check</code></p>
<p>输入流使用的一致性检查的 ID。 这可能为 <code>CHECK_UNKNOWN</code> 直到已解压了足够的输入数据来确定它所使用的一致性检查。</p>
</li>
<li><p><code>eof</code></p>
<p>若达到了数据流的末尾标记则为 <code>True</code>。</p>
</li>
<li><p><code>unused_data</code></p>
<p>在压缩数据流的末尾之后获取的数据。</p>
<p>在达到数据流末尾之前，这个值将为 <code>b""</code>。</p>
</li>
<li><p><code>needs_input</code></p>
<p>如果在要求新的未解压缩输入之前 <code>decompress()</code> 方法可以提供更多的解压缩数据则为 <code>False</code>。</p>
<p>3.5 新版功能.</p>
</li>
</ul>
<p><code>lzma.compress</code>(<em>data</em>, <em>format=FORMAT_XZ</em>, <em>check=- 1</em>, <em>preset=None</em>, <em>filters=None</em>)</p>
<p>压缩 <em>data</em> (一个 <code>bytes</code> 对象)，返回包含压缩数据的 <code>bytes</code> 对象。</p>
<p>参见上文的 <code>LZMACompressor</code> 了解有关 <em>format</em>, <em>check</em>, <em>preset</em> 和 <em>filters</em> 参数的说明。</p>
<p><code>lzma.decompress</code>(<em>data</em>, <em>format=FORMAT_AUTO</em>, <em>memlimit=None</em>, <em>filters=None</em>)</p>
<p>解压缩 <em>data</em> (一个 <code>bytes</code> 对象)，返回包含解压缩数据的 <code>bytes</code> 对象。</p>
<p>如果 <em>data</em> 是多个单独压缩数据流的拼接，则解压缩所有相应数据流，并返回结果的拼接。</p>
<p>参见上文的 <code>LZMADecompressor</code> 了解有关 <em>format</em>, <em>memlimit</em> 和 <em>filters</em> 参数的说明。</p>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p><code>lzma.is_check_supported</code>(<em>check</em>)</p>
<p>如果本系统支持给定的一致性检查则返回 <code>True</code>。</p>
<p><code>CHECK_NONE</code> 和 <code>CHECK_CRC32</code> 总是受支持。 <code>CHECK_CRC64</code> 和 <code>CHECK_SHA256</code> 或许不可用，如果你正在使用基于受限制特性集编译的 <strong>liblzma</strong> 版本的话。</p>
<h3 id="指定自定义的过滤器链"><a href="#指定自定义的过滤器链" class="headerlink" title="指定自定义的过滤器链"></a>指定自定义的过滤器链</h3><p>过滤器链描述符是由字典组成的序列，其中每个字典包含单个过滤器的 ID 和选项。 每个字典必须包含键 <code>"id"</code>，并可能包含额外的键用来指定基于过滤器的选项。 有效的过滤器 ID 如下：</p>
<ul>
<li>压缩过滤器：<ul>
<li><code>FILTER_LZMA1</code> (配合 <code>FORMAT_ALONE</code> 使用)</li>
<li><code>FILTER_LZMA2</code> (配合 <code>FORMAT_XZ</code> 和 <code>FORMAT_RAW</code> 使用)</li>
</ul>
</li>
<li>Delta 过滤器：<ul>
<li><code>FILTER_DELTA</code></li>
</ul>
</li>
<li>Branch-Call-Jump (BCJ) 过滤器：<ul>
<li><code>FILTER_X86</code></li>
<li><code>FILTER_IA64</code></li>
<li><code>FILTER_ARM</code></li>
<li><code>FILTER_ARMTHUMB</code></li>
<li><code>FILTER_POWERPC</code></li>
<li><code>FILTER_SPARC</code></li>
</ul>
</li>
</ul>
<p>一个过滤器链最多可由 4 个过滤器组成，并且不能为空。 过滤器链中的最后一个过滤器必须为压缩过滤器，其他过滤器必须为 Delta 或 BCJ 过滤器。</p>
<p>压缩过滤器支持下列选项（指定为表示过滤器的字典中的附加条目）：</p>
<blockquote>
<ul>
<li><code>preset</code>: 压缩预设选项，用于作为未显式指定的选项的默认值的来源。</li>
<li><code>dict_size</code>: 以字节表示的字典大小。 这应当在 4 KiB 和 1.5 GiB 之间（包含边界）。</li>
<li><code>lc</code>: 字面值上下文的比特数。</li>
<li><code>lp</code>: 字面值位置的比特数。 总计值 <code>lc + lp</code> 必须不大于 4。</li>
<li><code>pb</code>: 位置的比特数；必须不大于 4。</li>
<li><code>mode</code>: <code>MODE_FAST</code> 或 <code>MODE_NORMAL</code>。</li>
<li><code>nice_len</code>: 对于一个匹配应当被视为“适宜长度”的值。 这应当小于或等于 273。</li>
<li><code>mf</code>: 要使用的匹配查找器 — <code>MF_HC3</code>, <code>MF_HC4</code>, <code>MF_BT2</code>, <code>MF_BT3</code> 或 <code>MF_BT4</code>。</li>
<li><code>depth</code>: 匹配查找器使用的最大查找深度。 0 (默认值) 表示基于其他过滤器选项自动选择。</li>
</ul>
</blockquote>
<p>Delta 过滤器保存字节数据之间的差值，在特定环境下可产生更具重复性的输入。 它支持一个 <code>dist</code> 选项，指明要减去的字节之间的差值大小。 默认值为 1，即相邻字节之间的差值。</p>
<p>BCJ 过滤器主要作用于机器码。 它们会转换机器码内的相对分支、调用和跳转以使用绝对寻址，其目标是提升冗余度以供压缩器利用。 这些过滤器支持一个 <code>start_offset</code> 选项，指明应当被映射到输入数据开头的地址。 默认值为 0。</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>在已压缩的数据中读取:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> lzma
<span class="token keyword">with</span> lzma<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"file.xz"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    file_content <span class="token operator">=</span> f<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>创建一个压缩文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> lzma
data <span class="token operator">=</span> b<span class="token string">"Insert Data Here"</span>
<span class="token keyword">with</span> lzma<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"file.xz"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在内存中压缩文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> lzma
data_in <span class="token operator">=</span> b<span class="token string">"Insert Data Here"</span>
data_out <span class="token operator">=</span> lzma<span class="token punctuation">.</span>compress<span class="token punctuation">(</span>data_in<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>增量压缩:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> lzma
lzc <span class="token operator">=</span> lzma<span class="token punctuation">.</span>LZMACompressor<span class="token punctuation">(</span><span class="token punctuation">)</span>
out1 <span class="token operator">=</span> lzc<span class="token punctuation">.</span>compress<span class="token punctuation">(</span>b<span class="token string">"Some data\n"</span><span class="token punctuation">)</span>
out2 <span class="token operator">=</span> lzc<span class="token punctuation">.</span>compress<span class="token punctuation">(</span>b<span class="token string">"Another piece of data\n"</span><span class="token punctuation">)</span>
out3 <span class="token operator">=</span> lzc<span class="token punctuation">.</span>compress<span class="token punctuation">(</span>b<span class="token string">"Even more data\n"</span><span class="token punctuation">)</span>
out4 <span class="token operator">=</span> lzc<span class="token punctuation">.</span>flush<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># Concatenate all the partial results:</span>
result <span class="token operator">=</span> b<span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">[</span>out1<span class="token punctuation">,</span> out2<span class="token punctuation">,</span> out3<span class="token punctuation">,</span> out4<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>写入已压缩数据到已打开的文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> lzma
<span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"file.xz"</span><span class="token punctuation">,</span> <span class="token string">"wb"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"This data will not be compressed\n"</span><span class="token punctuation">)</span>
    <span class="token keyword">with</span> lzma<span class="token punctuation">.</span>open<span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> lzf<span class="token punctuation">:</span>
        lzf<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"This *will* be compressed\n"</span><span class="token punctuation">)</span>
    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"Not compressed\n"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用自定义过滤器链创建一个已压缩文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> lzma
my_filters <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span><span class="token string">"id"</span><span class="token punctuation">:</span> lzma<span class="token punctuation">.</span>FILTER_DELTA<span class="token punctuation">,</span> <span class="token string">"dist"</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token string">"id"</span><span class="token punctuation">:</span> lzma<span class="token punctuation">.</span>FILTER_LZMA2<span class="token punctuation">,</span> <span class="token string">"preset"</span><span class="token punctuation">:</span> <span class="token number">7</span> <span class="token operator">|</span> lzma<span class="token punctuation">.</span>PRESET_EXTREME<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
<span class="token keyword">with</span> lzma<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"file.xz"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">,</span> filters<span class="token operator">=</span>my_filters<span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"blah blah blah"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="zipfile-—-使用ZIP存档"><a href="#zipfile-—-使用ZIP存档" class="headerlink" title="zipfile —- 使用ZIP存档"></a><code>zipfile</code> —- 使用ZIP存档</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/zipfile.py" target="_blank" rel="noopener">Lib/zipfile.py</a></p>
<hr>
<p>ZIP 文件格式是一个常用的归档与压缩标准。 这个模块提供了创建、读取、写入、添加及列出 ZIP 文件的工具。 任何对此模块的进阶使用都将需要理解此格式，其定义参见 <a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT" target="_blank" rel="noopener">PKZIP 应用程序笔记</a>。</p>
<p>此模块目前不能处理分卷 ZIP 文件。它可以处理使用 ZIP64 扩展（超过 4 GB 的 ZIP 文件）的 ZIP 文件。它支持解密 ZIP 归档中的加密文件，但是目前不能创建一个加密的文件。解密非常慢，因为它是使用原生 Python 而不是 C 实现的。</p>
<p>这个模块定义了以下内容：</p>
<p><em>exception</em> <code>zipfile.BadZipFile</code></p>
<p>为损坏的 ZIP 文件抛出的错误。</p>
<p>3.2 新版功能.</p>
<p><em>exception</em> <code>zipfile.BadZipfile</code></p>
<p><code>BadZipFile</code> 的别名，与旧版本 Python 保持兼容性。</p>
<p>3.2 版后已移除.</p>
<p><em>exception</em> <code>zipfile.LargeZipFile</code></p>
<p>当 ZIP 文件需要 ZIP64 功能但是未启用时会抛出此错误。</p>
<p><em>class</em> <code>zipfile.ZipFile</code></p>
<p>用于读写 ZIP 文件的类。</p>
<p><em>class</em> <code>zipfile.Path</code></p>
<p>用于 zip 文件的兼容 pathlib 的包装器。</p>
<p>3.8 新版功能.</p>
<p><em>class</em> <code>zipfile.PyZipFile</code></p>
<p>用于创建包含 Python 库的 ZIP 归档的类。</p>
<p><em>class</em> <code>zipfile.ZipInfo</code>(<em>filename=’NoName’</em>, <em>date_time=1980, 1, 1, 0, 0, 0</em>)</p>
<p>用于表示档案内一个成员信息的类。 此类的实例会由 <code>ZipFile</code> 对象的 <code>getinfo()</code> 和 <code>infolist()</code> 方法返回。 大多数 <code>zipfile</code> 模块的用户都不必创建它们，只需使用此模块所创建的实例。 <em>filename</em> 应当是档案成员的全名，<em>date_time</em> 应当是包含六个字段的描述最近修改时间的元组。</p>
<p><code>zipfile.is_zipfile</code>(<em>filename</em>)</p>
<p>根据文件的 Magic Number，如果 <em>filename</em> 是一个有效的 ZIP 文件则返回 <code>True</code>，否则返回 <code>False</code>。 <em>filename</em> 也可能是一个文件或类文件对象。</p>
<p>在 3.1 版更改: 支持文件或类文件对象。</p>
<pre><code>zipfile.ZIP_STORED</code></pre><p>未被压缩的归档成员的数字常数。</p>
<pre><code>zipfile.ZIP_DEFLATED</code></pre><p>常用的 ZIP 压缩方法的数字常数。需要 <code>zlib</code> 模块。</p>
<pre><code>zipfile.ZIP_BZIP2</code></pre><p>BZIP2 压缩方法的数字常数。需要 <code>bz2</code> 模块。</p>
<p>3.3 新版功能.</p>
<pre><code>zipfile.ZIP_LZMA</code></pre><p>LZMA 压缩方法的数字常数。需要 <code>lzma</code> 模块。</p>
<p>3.3 新版功能.</p>
<p>注解</p>
<p>ZIP 文件格式规范包括自 2001 年以来对 bzip2 压缩的支持，以及自 2006 年以来对 LZMA 压缩的支持。但是，一些工具（包括较旧的 Python 版本）不支持这些压缩方法，并且可能拒绝完全处理 ZIP 文件，或者无法提取单个文件。</p>
<p>参见</p>
<p><a href="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT" target="_blank" rel="noopener">PKZIP 应用程序笔记</a></p>
<p>Phil Katz 编写的 ZIP 文件格式文档，此格式和使用的算法的创建者。</p>
<p><a href="http://www.info-zip.org/" target="_blank" rel="noopener">Info-ZIP 主页</a></p>
<p>有关 Info-ZIP 项目的 ZIP 存档程序和开发库的信息。</p>
<h3 id="ZipFile-对象"><a href="#ZipFile-对象" class="headerlink" title="ZipFile 对象"></a>ZipFile 对象</h3><p><em>class</em> <code>zipfile.ZipFile</code>(<em>file</em>, <em>mode=’r’</em>, <em>compression=ZIP_STORED</em>, <em>allowZip64=True</em>, <em>compresslevel=None</em>, <em>**,</em> strict_timestamps=True*)</p>
<p>打开一个 ZIP 文件，<em>file</em> 为一个指向文件的路径（字符串），一个类文件对象或者一个 path-like object。</p>
<p>形参 <em>mode</em> 应当为 <code>'r'</code> 来读取一个存在的文件，<code>'w'</code> 来截断并写入新的文件， <code>'a'</code> 来添加到一个存在的文件，或者 <code>'x'</code> 来仅新建并写入新的文件。如果 <em>mode</em> 为 <code>'x'</code> 并且 <em>file</em> 指向已经存在的文件，则抛出 <code>FileExistsError</code>。如果 <em>mode</em> 为 <code>'a'</code> 且 <em>file</em> 为已存在的文件，则格外的文件将被加入。如果 <em>file</em> 不指向 ZIP 文件，之后一个新的 ZIP 归档将被追加为此文件。这是为了将 ZIP 归档添加到另一个文件（例如 <code>python.exe</code>）。如果 <em>mode</em> 为 <code>'a'</code> 并且文件不存在， 则会新建。如果 <em>mode</em> 为 <code>'r'</code> 或 <code>'a'</code>， 则文件应当可定位。</p>
<p><em>compression</em> 是在写入归档时要使用的 ZIP 压缩方法，应为 <code>ZIP_STORED</code>, <code>ZIP_DEFLATED</code>, <code>ZIP_BZIP2</code> 或 <code>ZIP_LZMA</code>；不可识别的值将导致引发 <code>NotImplementedError</code>。 如果指定了 <code>ZIP_DEFLATED</code>, <code>ZIP_BZIP2</code> 或 <code>ZIP_LZMA</code> 但相应的模块 (<code>zlib</code>, <code>bz2</code> 或 <code>lzma</code>) 不可用，则会引发 <code>RuntimeError</code>。 默认值为 <code>ZIP_STORED</code>。</p>
<p>如果 <em>allowZip64</em> 为 <code>True</code> (默认值) 则当 zipfile 大于 4 GiB 时 zipfile 将创建使用 ZIP64 扩展的 ZIP 文件。 如果该参数为 <code>false</code> 则当 ZIP 文件需要 ZIP64 扩展时 <code>zipfile</code> 将引发异常。</p>
<p><em>compresslevel</em> 形参控制在将文件写入归档时要使用的压缩等级。 当使用 <code>ZIP_STORED</code> 或 <code>ZIP_LZMA</code> 时无压缩效果。 当使用 <code>ZIP_DEFLATED</code> 时接受整数 <code>0</code> 至 <code>9</code>。 当使用 <code>ZIP_BZIP2</code> 时接受整数 <code>1</code> 至 <code>9</code>。</p>
<p><em>strict_timestamps</em> 参数在设为 <code>False</code> 时允许压缩早于 1980-01-01 的文件，代价时会将时间戳设为 1980-01-01。 类似的行为也会对晚于 2107-12-31 的文件发生，时间戳也会被设为该上限值。</p>
<p>如果创建文件时使用 <code>'w'</code>, <code>'x'</code> 或 <code>'a'</code> 模式并且未向归档添加任何文件就执行了 <code>closed</code>，则会将适当的空归档 ZIP 结构写入文件。</p>
<p>ZipFile 也是一个上下文管理器，因此支持 <code>with</code> 语句。 在这个示例中，<em>myzip</em> 将在 <code>with</code> 语句块执行完成之后被关闭 —- 即使是发生了异常:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> ZipFile<span class="token punctuation">(</span><span class="token string">'spam.zip'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> myzip<span class="token punctuation">:</span>
    myzip<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'eggs.txt'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.2 新版功能: 添加了将 <code>ZipFile</code> 用作上下文管理员的功能。</p>
<p>在 3.3 版更改: 添加了对 <code>bzip2</code> 和 <code>lzma</code> 压缩的支持。</p>
<p>在 3.4 版更改: 默认启用 ZIP64 扩展。</p>
<p>在 3.5 版更改: 添加了对不可查找数据流的支持。 并添加了对 <code>'x'</code> 模式的支持。</p>
<p>在 3.6 版更改: 在此之前，对于不可识别的压缩值将引发普通的 <code>RuntimeError</code>。</p>
<p>在 3.6.2 版更改: <em>file</em> 形参接受一个 path-like object。</p>
<p>在 3.7 版更改: 添加了 <em>compresslevel</em> 形参。</p>
<p>3.8 新版功能: <em>strict_timestamps</em> 仅限关键字参数</p>
<p><code>ZipFile.close</code>()</p>
<p>关闭归档文件。 你必须在退出程序之前调用 <code>close()</code> 否则将不会写入关键记录数据。</p>
<p><code>ZipFile.getinfo</code>(<em>name</em>)</p>
<p>返回一个 <code>ZipInfo</code> 对象，其中包含有关归档成员 <em>name</em> 的信息。 针对一个目前并不包含于归档中的名称调用 <code>getinfo()</code> 将会引发 <code>KeyError</code>。</p>
<p><code>ZipFile.infolist</code>()</p>
<p>返回一个列表，其中包含每个归档成员的 <code>ZipInfo</code> 对象。 如果是打开一个现有归档则这些对象的排列顺序与它们对应条目在磁盘上的实际 ZIP 文件中的顺序一致。</p>
<p><code>ZipFile.namelist</code>()</p>
<p>返回按名称排序的归档成员列表。</p>
<p><code>ZipFile.open</code>(<em>name</em>, <em>mode=’r’</em>, <em>pwd=None</em>, <em>**,</em> force_zip64=False*)</p>
<p>以二进制文件类对象的形式访问一个归档成员。 <em>name</em> 可以是归档内某个文件的名称也可以是某个 <code>ZipInfo</code> 对象。 如果包含了 <em>mode</em> 形参，则它必须为 <code>'r'</code> (默认值) 或 <code>'w'</code>。 <em>pwd</em> 为用于解密已加密 ZIP 文件的密码。</p>
<p><code>open()</code> 也是一个上下文管理器，因此支持 <code>with</code> 语句:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> ZipFile<span class="token punctuation">(</span><span class="token string">'spam.zip'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> myzip<span class="token punctuation">:</span>
    <span class="token keyword">with</span> myzip<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'eggs.txt'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> myfile<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>myfile<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>mode</em> 为 <code>'r'</code> 则文件类对象 (<code>ZipExtFile</code>) 将为只读并且提供下列方法: <code>read()</code>, <code>readline()</code>, <code>readlines()</code>, <code>seek()</code>, <code>tell()</code>, <code>__iter__()</code>, <code>__next__()</code>。 这些对象可独立于 ZipFile 进行操作。</p>
<p>如果 <code>mode='w'</code> 则返回一个可写入的文件句柄，它将支持 <code>write()</code> 方法。 当一个可写入的文件句柄被打开时，尝试读写 ZIP 文件中的其他文件将会引发 <code>ValueError</code>。</p>
<p>当写入一个文件时，如果文件大小不能预先确定但是可能超过 2 GiB，可传入 <code>force_zip64=True</code> 以确保标头格式能够支持超大文件。 如果文件大小可以预先确定，则在构造 <code>ZipInfo</code> 对象时应设置 <code>file_size</code>，并将其用作 <em>name</em> 形参。</p>
<p>注解</p>
<p><code>open()</code>, <code>read()</code> 和 <code>extract()</code> 方法可接受文件名或 <code>ZipInfo</code> 对象。 当尝试读取一个包含重复名称成员的 ZIP 文件时你将发现此功能很有好处。</p>
<p>在 3.6 版更改: 移除了对 <code>mode='U'</code> 的支持。 请使用 <code>io.TextIOWrapper</code> 以在 universal newlines 模式中读取已压缩的文本文件。</p>
<p>在 3.6 版更改: <code>open()</code> 现在可以被用来配合 <code>mode='w'</code> 选项来将文件写入归档。</p>
<p>在 3.6 版更改: 在已关闭的 ZipFile 上调用 <code>open()</code> 将引发 <code>ValueError</code>。 在之前的版本中则会引发 <code>RuntimeError</code>。</p>
<p><code>ZipFile.extract</code>(<em>member</em>, <em>path=None</em>, <em>pwd=None</em>)</p>
<p>从归档中提取出一个成员放入当前工作目录；<em>member</em> 必须为成员的完整名称或 <code>ZipInfo</code> 对象。 成员的文件信息会尽可能精确地被提取。 <em>path</em> 指定一个要提取到的不同目录。 <em>member</em> 可以是一个文件名或 <code>ZipInfo</code> 对象。 <em>pwd</em> 是用于解密文件的密码。</p>
<p>返回所创建的经正规化的路径（对应于目录或新文件）。</p>
<p>注解</p>
<p>如果一个成员文件名为绝对路径，则将去掉驱动器/UNC共享点和前导的（反）斜杠，例如: <code>///foo/bar</code> 在 Unix 上将变为 <code>foo/bar</code>，而 <code>C:\foo\bar</code> 在 Windows 上将变为 <code>foo\bar</code>。 并且一个成员文件名中的所有 <code>".."</code> 都将被移除，例如: <code>../../foo../../ba..r</code> 将变为 <code>foo../ba..r</code>。 在 Windows 上非法字符 (<code>:</code>, <code>&lt;</code>, <code>&gt;</code>, <code>|</code>, <code>"</code>, <code>?</code>, and <code>*</code>) 会被替换为下划线 (<code>_</code>)。</p>
<p>在 3.6 版更改: 在已关闭的 ZipFile 上调用 <code>extract()</code> 将引发 <code>ValueError</code>。 在之前的版本中则将引发 <code>RuntimeError</code>。</p>
<p>在 3.6.2 版更改: <em>path</em> 形参接受一个 path-like object。</p>
<p><code>ZipFile.extractall</code>(<em>path=None</em>, <em>members=None</em>, <em>pwd=None</em>)</p>
<p>从归档中提取出所有成员放入当前工作目录。 <em>path</em> 指定一个要提取到的不同目录。 <em>members</em> 为可选项且必须为 <code>namelist()</code> 所返回列表的一个子集。 <em>pwd</em> 是用于解密文件的密码。</p>
<p>警告</p>
<p>绝不要未经预先检验就从不可靠的源中提取归档文件。 这样有可能在 <em>path</em> 之外创建文件，例如某些成员具有以 <code>"/"</code> 开始的文件名或带有两个点号 <code>".."</code> 的文件名。 此模块会尝试防止这种情况。 </p>
<p>在 3.6 版更改: 在已关闭的 ZipFile 上调用 <code>extractall()</code> 将引发 <code>ValueError</code>。 在之前的版本中则将引发 <code>RuntimeError</code>。</p>
<p>在 3.6.2 版更改: <em>path</em> 形参接受一个 path-like object。</p>
<p><code>ZipFile.printdir</code>()</p>
<p>将归档的目录表打印到 <code>sys.stdout</code>。</p>
<p><code>ZipFile.setpassword</code>(<em>pwd</em>)</p>
<p>设置 <em>pwd</em> 为用于提取已加密文件的默认密码。</p>
<p><code>ZipFile.read</code>(<em>name</em>, <em>pwd=None</em>)</p>
<p>返回归档中文件 <em>name</em> 的字节数据。 <em>name</em> 是归档中文件的名称，或是一个 <code>ZipInfo</code> 对象。 归档必须以读取或追加方式打开。 <em>pwd</em> 为用于已加密文件的密码，并且如果指定该参数则它将覆盖通过 <code>setpassword()</code> 设置的默认密码。 on a ZipFile that uses a compression method 在使用 <code>ZIP_STORED</code> , <code>ZIP_DEFLATED</code>, <code>ZIP_BZIP2</code> 或 <code>ZIP_LZMA</code> 以外的压缩方法的 ZipFile 上调用 <code>read()</code> 将引发 <code>NotImplementedError</code>。 如果相应的压缩模块不可用也会引发错误。</p>
<p>在 3.6 版更改: 在已关闭的 ZipFile 上调用 <code>read()</code> 将引发 <code>ValueError</code>。 在之前的版本中则会引发 <code>RuntimeError</code>。</p>
<p><code>ZipFile.testzip</code>()</p>
<p>读取归档中的所有文件并检查它们的 CRC 和文件头。 返回第一个已损坏文件的名称，在其他情况下则返回 <code>None</code>。</p>
<p>在 3.6 版更改: 在已关闭的 ZipFile 上调用 <code>testzip()</code> 将引发 <code>ValueError</code>。 在之前的版本中则将引发 <code>RuntimeError</code>。</p>
<p><code>ZipFile.write</code>(<em>filename</em>, <em>arcname=None</em>, <em>compress_type=None</em>, <em>compresslevel=None</em>)</p>
<p>将名为 <em>filename</em> 的文件写入归档，给予的归档名为 <em>arcname</em> (默认情况下将与 <em>filename</em> 一致，但是不带驱动器盘符并会移除开头的路径分隔符)。 <em>compress_type</em> 如果给出，它将覆盖作为构造器 <em>compression</em> 形参对于新条目所给出的值。 类似地，<em>compresslevel</em> 如果给出也将覆盖构造器。 归档必须使用 <code>'w'</code>, <code>'x'</code> 或 <code>'a'</code> 模式打开。</p>
<p>注解</p>
<p>归档名称应当是基于归档根目录的相对路径，也就是说，它们不应以路径分隔符开头。</p>
<p>注解</p>
<p>如果 <code>arcname</code> (或 <code>filename</code>，如果 <code>arcname</code> 未给出) 包含一个空字节，则归档中该文件的名称将在空字节位置被截断。</p>
<p>注解</p>
<p>文件名开头有一个斜杠可能导致存档文件无法在 Windows 系统上的某些 zip 程序中打开。</p>
<p>在 3.6 版更改: 在使用 <code>'r'</code> 模式创建的 ZipFile 或已关闭的 ZipFile 上调用 <code>write()</code> 将引发 <code>ValueError</code>。 在之前的版本中则会引发 <code>RuntimeError</code>。</p>
<p><code>ZipFile.writestr</code>(<em>zinfo_or_arcname</em>, <em>data</em>, <em>compress_type=None</em>, <em>compresslevel=None</em>)</p>
<p>将一个文件写入归档。 内容为 <em>data*，它可以是一个 <code>str</code> 或 <code>bytes</code> 的实例；如果是 <code>str</code>，则会先使用 UTF-8 进行编码。 *zinfo_or_arcname</em> 可以是它在归档中将被给予的名称，或者是 <code>ZipInfo</code> 的实例。 如果它是一个实例，则至少必须给定文件名、日期和时间。 如果它是一个名称，则日期和时间会被设为当前日期和时间。 归档必须以 <code>'w'</code>, <code>'x'</code> 或 <code>'a'</code> 模式打开。</p>
<p>如果给定了 <em>compress_type*，它将会覆盖作为新条目构造器的 *compression</em> 形参或在 <em>zinfo_or_arcname</em> (如果是一个 <code>ZipInfo</code> 实例) 中所给出的值。 类似地，如果给定了 <em>compresslevel</em>，它将会覆盖构造器。</p>
<p>注解</p>
<p>当传入一个 <code>ZipInfo</code> 实例作为 <em>zinfo_or_arcname</em> 形参时，所使用的压缩方法将为在给定的 <code>ZipInfo</code> 实例的 <em>compress_type</em> 成员中指定的方法。 默认情况下，<code>ZipInfo</code> 构造器将将此成员设为 <code>ZIP_STORED</code>。</p>
<p>在 3.2 版更改: <em>compress_type</em> 参数。</p>
<p>在 3.6 版更改: 在使用 <code>'r'</code> 模式创建的 ZipFile 或已关闭的 ZipFile 上调用 <code>writestr()</code> 将引发 <code>ValueError</code>。 在之前的版本中则会引发 <code>RuntimeError</code>。</p>
<p>以下数据属性也是可用的:</p>
<pre><code>ZipFile.filename</code></pre><p>ZIP 文件的名称。</p>
<pre><code>ZipFile.debug</code></pre><p>要使用的调试输出等级。 这可以设为从 <code>0</code> (默认无输出) 到 <code>3</code> (最多输出) 的值。 调试信息会被写入 <code>sys.stdout</code>。</p>
<pre><code>ZipFile.comment</code></pre><p>关联到 ZIP 文件的 <code>bytes</code> 对象形式的说明。 如果将说明赋给以 <code>'w'</code>, <code>'x'</code> 或 <code>'a'</code> 模式创建的 <code>ZipFile</code> 实例，它的长度不应超过 65535 字节。 超过此长度的说明将被截断。</p>
<h3 id="Path-对象"><a href="#Path-对象" class="headerlink" title="Path 对象"></a>Path 对象</h3><p><em>class</em> <code>zipfile.Path</code>(<em>root</em>, <em>at=’’</em>)</p>
<p>根据 <code>root</code> zipfile (它可以是一个 <code>ZipFile</code> 实例或适合传给 <code>ZipFile</code> 构造器的 <code>file</code>) 构造一个 Path 对象。</p>
<p><code>at</code> 指定此 Path 在 zipfile 中的位置，例如 ‘dir/file.txt’, ‘dir/‘ 或 ‘’。 默认为空字符串，即指定跟目录。</p>
<p>Path 对象会公开 <code>pathlib.Path</code> 对象的下列特性:</p>
<p>Path 对象可以使用 <code>/</code> 运算符或 <code>joinpath</code> 来进行遍历。</p>
<pre><code>Path.name</code></pre><p>最终的路径组成部分。</p>
<p><code>Path.open</code>(<em>mode=’r’</em>, <strong><em>,</em> pwd<em>,</em> *</strong>)</p>
<p>在当前路径上发起调用 <code>ZipFile.open()</code>。 允许通过支持的模式打开用于读取或写入文本或二进制数据: ‘r’, ‘w’, ‘rb’, ‘wb’。 当以文本模式打开时位置和关键字参数会被传给 <code>io.TextIOWrapper</code>，在其他情况下则会被忽略。 <code>pwd</code> 是要传给 <code>ZipFile.open()</code> 的 <code>pwd</code> 形参。</p>
<p>在 3.9 版更改: 增加了对以文本和二进制模式打开的支持。 现在默认为文本模式。</p>
<p><code>Path.iterdir</code>()</p>
<p>枚举当前目录的子目录。</p>
<p><code>Path.is_dir</code>()</p>
<p>如果当前上下文引用了一个目录则返回 <code>True</code>。</p>
<p><code>Path.is_file</code>()</p>
<p>如果当前上下文引用了一个文件则返回 <code>True</code>。</p>
<p><code>Path.exists</code>()</p>
<p>如果当前上下文引用了 zip 文件内的一个文件或目录则返回 <code>True</code>。</p>
<p><code>Path.read_text</code>(<strong><em>,</em> *</strong>)</p>
<p>读取当前文件为 unicode 文本。 位置和关键字参数会被传递给 <code>io.TextIOWrapper</code> (<code>buffer</code> 除外，它将由上下文确定)。</p>
<p><code>Path.read_bytes</code>()</p>
<p>读取当前文件为字节串。</p>
<p><code>Path.joinpath</code>(<em>\</em>other*)</p>
<p>返回一个新的 Path 对象，其中合并了每个 <em>other</em> 参数。 以下代码是等价的:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">'child'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">'grandchild'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">'child'</span><span class="token punctuation">,</span> <span class="token string">'grandchild'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token string">'child'</span> <span class="token operator">/</span> <span class="token string">'grandchild'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 3.10 版更改: 在 3.10 之前，<code>joinpath</code> 未被写入文档并且只接受一个形参。</p>
<h3 id="PyZipFile-对象"><a href="#PyZipFile-对象" class="headerlink" title="PyZipFile 对象"></a>PyZipFile 对象</h3><p><code>PyZipFile</code> 构造器接受与 <code>ZipFile</code> 构造器相同的形参，以及一个额外的形参 <em>optimize</em>。</p>
<p><em>class</em> <code>zipfile.PyZipFile</code>(<em>file</em>, <em>mode=’r’</em>, <em>compression=ZIP_STORED</em>, <em>allowZip64=True</em>, <em>optimize=- 1</em>)</p>
<p>3.2 新版功能: <em>optimize</em> 形参。</p>
<p>在 3.4 版更改: 默认启用 ZIP64 扩展。</p>
<p>实例在 <code>ZipFile</code> 对象所具有的方法以外还附加了一个方法:</p>
<ul>
<li><p><code>writepy</code>(<em>pathname</em>, <em>basename=’’</em>, <em>filterfunc=None</em>)</p>
<p>查找 <code>*.py</code> 文件并将相应的文件添加到归档。</p>
<p>如果 <code>PyZipFile</code> 的 <em>optimize</em> 形参未给定或为 <code>-1</code>，则相应的文件为 <code>*.pyc</code> 文件，并在必要时进行编译。</p>
<p>如果 <code>PyZipFile</code> 的 <em>optimize</em> 形参为 <code>0</code>, <code>1</code> 或 <code>2</code>，则限具有相应优化级别的文件会被添加到归档，并在必要时进行编译。</p>
<p>如果 <em>pathname</em> 是文件，则文件名必须以 <code>.py</code> 为后缀，并且只有 (相应的 <code>*.pyc</code>) 文件会被添加到最高层级（不带路径信息）。 如果 <em>pathname</em> 不是以 <code>.py</code> 为后缀的文件，则将引发 <code>RuntimeError</code>。 如果它是目录，并且该目录不是一个包目录，则所有的 <code>*.pyc</code> 文件会被添加到最高层级。 如果目录是一个包目录，则所有的 <code>*.pyc</code> 会被添加到包名所表示的文件路径下，并且如果有任何子目录为包目录，则会以排好的顺序递归地添加这些目录。</p>
<p><em>basename</em> 仅限在内部使用。</p>
<p>如果给定 <em>filterfunc*，则它必须是一个接受单个字符串参数的函数。 在将其添加到归档之前它将被传入每个路径（包括每个单独的完整路径）。 如果 *filterfunc</em> 返回假值，则路径将不会被添加，而如果它是一个目录则其内容将被忽略。 例如，如果我们的测试文件全都位于 <code>test</code> 目录或以字符串 <code>test_</code> 打头，则我们可以使用一个 <em>filterfunc</em> 来排除它们:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> zf <span class="token operator">=</span> PyZipFile<span class="token punctuation">(</span><span class="token string">'myprog.zip'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">notests</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     fn <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>basename<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">not</span> <span class="token punctuation">(</span>fn <span class="token operator">==</span> <span class="token string">'test'</span> <span class="token operator">or</span> fn<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">'test_'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> zf<span class="token punctuation">.</span>writepy<span class="token punctuation">(</span><span class="token string">'myprog'</span><span class="token punctuation">,</span> filterfunc<span class="token operator">=</span>notests<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>writepy()</code> 方法会产生带有这样一些文件名的归档:</p>
<pre class="line-numbers language-python"><code class="language-python">string<span class="token punctuation">.</span>pyc                   <span class="token comment" spellcheck="true"># Top level name</span>
test<span class="token operator">/</span>__init__<span class="token punctuation">.</span>pyc            <span class="token comment" spellcheck="true"># Package directory</span>
test<span class="token operator">/</span>testall<span class="token punctuation">.</span>pyc             <span class="token comment" spellcheck="true"># Module test.testall</span>
test<span class="token operator">/</span>bogus<span class="token operator">/</span>__init__<span class="token punctuation">.</span>pyc      <span class="token comment" spellcheck="true"># Subpackage directory</span>
test<span class="token operator">/</span>bogus<span class="token operator">/</span>myfile<span class="token punctuation">.</span>pyc        <span class="token comment" spellcheck="true"># Submodule test.bogus.myfile</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.4 新版功能: <em>filterfunc</em> 形参。</p>
<p>在 3.6.2 版更改: <em>pathname</em> 形参接受一个 path-like object。</p>
<p>在 3.7 版更改: 递归排序目录条目。</p>
</li>
</ul>
<h3 id="ZipInfo-对象"><a href="#ZipInfo-对象" class="headerlink" title="ZipInfo 对象"></a>ZipInfo 对象</h3><p><code>ZipInfo</code> 类的实例会通过 <code>getinfo()</code> 和 <code>ZipFile</code> 对象的 <code>infolist()</code> 方法返回。 每个对象将存储关于 ZIP 归档的一个成员的信息。</p>
<p>有一个类方法可以为文件系统文件创建 <code>ZipInfo</code> 实例:</p>
<p><em>classmethod</em> <code>ZipInfo.from_file</code>(<em>filename</em>, <em>arcname=None</em>, <em>**,</em> strict_timestamps=True*)</p>
<p>为文件系统中的文件构造一个 <code>ZipInfo</code> 实例，并准备将其添加到一个 zip 文件。</p>
<p><em>filename</em> 应为文件系统中某个文件或目录的路径。</p>
<p>如果指定了 <em>arcname<em>，它会被用作归档中的名称。 如果未指定 *arcname</em>，则所用名称与 *filename</em> 相同，但将去除任何驱动器盘符和打头的路径分隔符。</p>
<p><em>strict_timestamps</em> 参数在设为 <code>False</code> 时允许压缩早于 1980-01-01 的文件，代价时会将时间戳设为 1980-01-01。 类似的行为也会对晚于 2107-12-31 的文件发生，时间戳也会被设为该上限值。</p>
<p>3.6 新版功能.</p>
<p>在 3.6.2 版更改: <em>filename</em> 形参接受一个 path-like object。</p>
<p>3.8 新版功能: <em>strict_timestamps</em> 仅限关键字参数</p>
<p>实例具有下列方法和属性:</p>
<p><code>ZipInfo.is_dir</code>()</p>
<p>如果此归档成员是一个目录则返回 <code>True</code>。</p>
<p>这会使用条目的名称：目录应当总是以 <code>/</code> 结尾。</p>
<p>3.6 新版功能.</p>
<pre><code>ZipInfo.filename</code></pre><p>归档中的文件名称。</p>
<pre><code>ZipInfo.date_time</code></pre><p>上次修改存档成员的时间和日期。这是六个值的元组：</p>
<table>
<thead>
<tr>
<th align="left">索引</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>0</code></td>
<td align="left">Year (&gt;= 1980)</td>
</tr>
<tr>
<td align="left"><code>1</code></td>
<td align="left">月（1为基数）</td>
</tr>
<tr>
<td align="left"><code>2</code></td>
<td align="left">月份中的日期（1为基数）</td>
</tr>
<tr>
<td align="left"><code>3</code></td>
<td align="left">小时（0为基数）</td>
</tr>
<tr>
<td align="left"><code>4</code></td>
<td align="left">分钟（0为基数）</td>
</tr>
<tr>
<td align="left"><code>5</code></td>
<td align="left">秒（0为基数）</td>
</tr>
</tbody></table>
<p>注解</p>
<p>ZIP文件格式不支持1980年以前的时间戳。</p>
<pre><code>ZipInfo.compress_type</code></pre><p>归档成员的压缩类型。</p>
<pre><code>ZipInfo.comment</code></pre><p><code>bytes</code> 对象形式的单个归档成员的注释。</p>
<pre><code>ZipInfo.extra</code></pre><p>扩展字段数据。 PKZIP Application Note 包含一些保存于该 <code>bytes</code> 对象中的内部结构的注释。</p>
<pre><code>ZipInfo.create_system</code></pre><p>创建 ZIP 归档所用的系统。</p>
<pre><code>ZipInfo.create_version</code></pre><p>创建 ZIP 归档所用的 PKZIP 版本。</p>
<pre><code>ZipInfo.extract_version</code></pre><p>需要用来提取归档的 PKZIP 版本。</p>
<pre><code>ZipInfo.reserved</code></pre><p>必须为零。</p>
<pre><code>ZipInfo.flag_bits</code></pre><p>ZIP 标志位。</p>
<pre><code>ZipInfo.volume</code></pre><p>文件头的分卷号。</p>
<pre><code>ZipInfo.internal_attr</code></pre><p>内部属性。</p>
<pre><code>ZipInfo.external_attr</code></pre><p>外部文件属性。</p>
<pre><code>ZipInfo.header_offset</code></pre><p>文件头的字节偏移量。</p>
<pre><code>ZipInfo.CRC</code></pre><p>未压缩文件的 CRC-32。</p>
<pre><code>ZipInfo.compress_size</code></pre><p>已压缩数据的大小。</p>
<pre><code>ZipInfo.file_size</code></pre><p>未压缩文件的大小。</p>
<h3 id="命令行接口"><a href="#命令行接口" class="headerlink" title="命令行接口"></a>命令行接口</h3><p><code>zipfile</code> 模块提供了简单的命令行接口用于与 ZIP 归档的交互。</p>
<p>如果你想要创建一个新的 ZIP 归档，请在 <code>-c</code> 选项后指定其名称然后列出应当被包含的文件名:</p>
<pre><code>$ python -m zipfile -c monty.zip spam.txt eggs.txt</code></pre><p>传入一个字典也是可接受的:</p>
<pre><code>$ python -m zipfile -c monty.zip life-of-brian_1979/</code></pre><p>如果你想要将一个 ZIP 归档提取到指定的目录，请使用 <code>-e</code> 选项:</p>
<pre><code>$ python -m zipfile -e monty.zip target-dir/</code></pre><p>要获取一个 ZIP 归档中的文件列表，请使用 <code>-l</code> 选项:</p>
<pre><code>$ python -m zipfile -l monty.zip</code></pre><h4 id="命令行选项-1"><a href="#命令行选项-1" class="headerlink" title="命令行选项"></a>命令行选项</h4><pre><code>-l` `&lt;zipfile&gt;
--list` `&lt;zipfile&gt;</code></pre><p>列出一个 zipfile 中的文件名。</p>
<pre><code>-c` `&lt;zipfile&gt; &lt;source1&gt; ... &lt;sourceN&gt;
--create` `&lt;zipfile&gt; &lt;source1&gt; ... &lt;sourceN&gt;</code></pre><p>基于源文件创建 zipfile。</p>
<pre><code>-e` `&lt;zipfile&gt; &lt;output_dir&gt;
--extract` `&lt;zipfile&gt; &lt;output_dir&gt;</code></pre><p>将 zipfile 提取到目标目录中。</p>
<pre><code>-t` `&lt;zipfile&gt;
--test` `&lt;zipfile&gt;</code></pre><p>检测 zipfile 是否有效。</p>
<h3 id="解压缩的障碍"><a href="#解压缩的障碍" class="headerlink" title="解压缩的障碍"></a>解压缩的障碍</h3><p>zipfile 模块的提取操作可能会由于下面列出的障碍而失败。</p>
<h4 id="由于文件本身"><a href="#由于文件本身" class="headerlink" title="由于文件本身"></a>由于文件本身</h4><p>解压缩可能由于不正确的密码 / CRC 校验和 / ZIP 格式或不受支持的压缩 / 解密方法而失败。</p>
<h4 id="文件系统限制"><a href="#文件系统限制" class="headerlink" title="文件系统限制"></a>文件系统限制</h4><p>超出特定文件系统上的限制可能会导致解压缩失败。 例如目录条目所允许的字符、文件名的长度、路径名的长度、单个文件的大小以及文件的数量等等。</p>
<h4 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h4><p>缺乏内存或磁盘空间将会导致解压缩失败。 例如，作用于 zipfile 库的解压缩炸弹 (即 <a href="https://en.wikipedia.org/wiki/Zip_bomb" target="_blank" rel="noopener">ZIP bomb</a>) 就可能造成磁盘空间耗尽。</p>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>在解压缩期间中断执行，例如按下 ctrl-C 或杀死解压缩进程可能会导致归档文件的解压缩不完整。</p>
<h4 id="提取的默认行为"><a href="#提取的默认行为" class="headerlink" title="提取的默认行为"></a>提取的默认行为</h4><p>不了解提取的默认行为可能导致不符合期望的解压缩结果。 例如，当提取相同归档两次时，它会不经询问地覆盖文件。</p>
<h2 id="tarfile-—-读写tar归档文件"><a href="#tarfile-—-读写tar归档文件" class="headerlink" title="tarfile —- 读写tar归档文件"></a><code>tarfile</code> —- 读写tar归档文件</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/tarfile.py" target="_blank" rel="noopener">Lib/tarfile.py</a></p>
<hr>
<p><code>tarfile</code> 模块可以用来读写 tar 归档，包括使用 gzip, bz2 和 lzma 压缩的归档。 请使用 <code>zipfile</code> 模块来读写 <code>.zip</code> 文件，或者使用 shutil 的高层级函数。</p>
<p>一些事实和数字:</p>
<ul>
<li>读写 <code>gzip</code>, <code>bz2</code> 和 <code>lzma</code> 解压的归档要求相应的模块可用。</li>
<li>支持读取 / 写入 POSIX.1-1988 (ustar) 格式。</li>
<li>对 GNU tar 格式的读/写支持，包括 <em>longname</em> 和 <em>longlink</em> 扩展，对所有种类 <em>sparse</em> 扩展的只读支持，包括 sparse 文件的恢复。</li>
<li>对 POSIX.1-2001 (pax) 格式的读/写支持。</li>
<li>处理目录、正常文件、硬链接、符号链接、fifo 管道、字符设备和块设备，并且能够获取和恢复文件信息例如时间戳、访问权限和所有者等。</li>
</ul>
<p>在 3.3 版更改: 添加了对 <code>lzma</code> 压缩的支持。</p>
<p><code>tarfile.open</code>(<em>name=None</em>, <em>mode=’r’</em>, <em>fileobj=None</em>, <em>bufsize=10240</em>, <em>**kwargs</em>)</p>
<p>针对路径名 <em>name</em> 返回 <code>TarFile</code> 对象。 </p>
<p><em>mode</em> 必须是 <code>'filemode[:compression]'</code> 形式的字符串，其默认值为 <code>'r'</code>。 以下是模式组合的完整列表:</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">action</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>‘r’ or ‘r:*’</code></td>
<td align="left">打开和读取使用透明压缩（推荐）。</td>
</tr>
<tr>
<td align="left"><code>‘r:’</code></td>
<td align="left">打开和读取不使用压缩。</td>
</tr>
<tr>
<td align="left"><code>‘r:gz’</code></td>
<td align="left">打开和读取使用gzip 压缩。</td>
</tr>
<tr>
<td align="left"><code>‘r:bz2’</code></td>
<td align="left">打开和读取使用bzip2 压缩。</td>
</tr>
<tr>
<td align="left"><code>‘r:xz’</code></td>
<td align="left">打开和读取使用lzma 压缩。</td>
</tr>
<tr>
<td align="left"><code>‘x’</code> 或 <code>‘x:’</code></td>
<td align="left">创建tarfile不进行压缩。如果文件已经存在，则抛出 <code>FileExistsError</code> 异常。</td>
</tr>
<tr>
<td align="left"><code>‘x:gz’</code></td>
<td align="left">使用gzip压缩创建tarfile。如果文件已经存在，则抛出 <code>FileExistsError</code> 异常。</td>
</tr>
<tr>
<td align="left"><code>‘x:bz2’</code></td>
<td align="left">使用bzip2 压缩创建tarfile。如果文件已经存在，则抛出 <code>FileExistsError</code> 异常。</td>
</tr>
<tr>
<td align="left"><code>‘x:xz’</code></td>
<td align="left">使用lzma 压缩创建tarfile。如果文件已经存在，则抛出 <code>FileExistsError</code> 异常。</td>
</tr>
<tr>
<td align="left"><code>‘a’ or ‘a:’</code></td>
<td align="left">打开以便在没有压缩的情况下追加。如果文件不存在，则创建该文件。</td>
</tr>
<tr>
<td align="left"><code>‘w’ or ‘w:’</code></td>
<td align="left">打开用于未压缩的写入。</td>
</tr>
<tr>
<td align="left"><code>‘w:gz’</code></td>
<td align="left">打开用于 gzip 压缩的写入。</td>
</tr>
<tr>
<td align="left"><code>‘w:bz2’</code></td>
<td align="left">打开用于 bzip2 压缩的写入。</td>
</tr>
<tr>
<td align="left"><code>‘w:xz’</code></td>
<td align="left">打开用于 lzma 压缩的写入。</td>
</tr>
</tbody></table>
<p>请注意 <code>'a:gz'</code>, <code>'a:bz2'</code> 或 <code>'a:xz'</code> 是不可能的组合。 如果 <em>mode</em> 不适用于打开特定（压缩的）文件用于读取，则会引发 <code>ReadError</code>。 请使用 <em>mode</em> <code>'r'</code> 来避免这种情况。 如果某种压缩方法不受支持，则会引发 <code>CompressionError</code>。</p>
<p>如果指定了 <em>fileobj*，它会被用作对应于 *name</em> 的以二进制模式打开的 file object 的替代。 它会被设定为处在位置 0。</p>
<p>对于 <code>'w:gz'</code>, <code>'r:gz'</code>, <code>'w:bz2'</code>, <code>'r:bz2'</code>, <code>'x:gz'</code>, <code>'x:bz2'</code> 等模式，<code>tarfile.open()</code> 接受关键字参数 <em>compresslevel</em> (默认值为 <code>9</code>) 来指定文件的压缩等级。</p>
<p>对于 <code>'w:xz'</code> 和 <code>'x:xz'</code> 模式，<code>tarfile.open()</code> 接受关键字参数 <em>preset</em> 来指定文件的压缩等级。</p>
<p>针对特殊的目的，还存在第二种 <em>mode</em> 格式: <code>'filemode|[compression]'</code>。 <code>tarfile.open()</code> 将返回一个将其数据作为数据块流来处理的 <code>TarFile</code> 对象。 对此文件将不能执行随机查找。 如果给定了 <em>fileobj*，它可以是任何具有 <code>read()</code> 或 <code>write()</code> 方法 (由 *mode</em> 确定) 的对象。 <em>bufsize</em> 指定块大小，默认值为 <code>20 * 512</code> 字节。 可与此格式组合使用的有 <code>sys.stdin</code>, 套接字 file object 或磁带设备等。 但是，对于这样的 <code>TarFile</code> 对象存在不允许随机访问的限制。 目前可用的模式如下:</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">动作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">`‘r</td>
<td align="left">*’`</td>
</tr>
<tr>
<td align="left">`‘r</td>
<td align="left">’`</td>
</tr>
<tr>
<td align="left">`‘r</td>
<td align="left">gz’`</td>
</tr>
<tr>
<td align="left">`‘r</td>
<td align="left">bz2’`</td>
</tr>
<tr>
<td align="left">`‘r</td>
<td align="left">xz’`</td>
</tr>
<tr>
<td align="left">`‘w</td>
<td align="left">’`</td>
</tr>
<tr>
<td align="left">`‘w</td>
<td align="left">gz’`</td>
</tr>
<tr>
<td align="left">`‘w</td>
<td align="left">bz2’`</td>
</tr>
<tr>
<td align="left">`‘w</td>
<td align="left">xz’`</td>
</tr>
</tbody></table>
<p>在 3.5 版更改: 添加了 <code>'x'</code> (单独创建) 模式。</p>
<p>在 3.6 版更改: <em>name</em> 形参接受一个 path-like object。</p>
<p><em>class</em> <code>tarfile.TarFile</code></p>
<p>用于读取和写入 tar 归档的类。 请不要直接使用这个类：而要使用 <code>tarfile.open()</code>。 </p>
<p><code>tarfile.is_tarfile</code>(<em>name</em>)</p>
<p>如果 <em>name</em> 是一个 <code>tarfile</code> 能读取的 tar 归档文件则返回 <code>True</code>。 <em>name</em> 可以为 <code>str</code>，文件或文件类对象。</p>
<p>在 3.9 版更改: 支持文件或类文件对象。</p>
<p><code>tarfile</code> 模块定义了以下异常:</p>
<p><em>exception</em> <code>tarfile.TarError</code></p>
<p>所有 <code>tarfile</code> 异常的基类。</p>
<p><em>exception</em> <code>tarfile.ReadError</code></p>
<p>当一个不能被 <code>tarfile</code> 模块处理或者因某种原因而无效的 tar 归档被打开时将被引发。</p>
<p><em>exception</em> <code>tarfile.CompressionError</code></p>
<p>当一个压缩方法不受支持或者当数据无法被正确解码时将被引发。</p>
<p><em>exception</em> <code>tarfile.StreamError</code></p>
<p>当达到流式 <code>TarFile</code> 对象的典型限制时将被引发。</p>
<p><em>exception</em> <code>tarfile.ExtractError</code></p>
<p>当使用 <code>TarFile.extract()</code> 时针对 <em>non-fatal</em> 所引发的异常，但是仅限 <code>TarFile.errorlevel``== 2</code>。</p>
<p><em>exception</em> <code>tarfile.HeaderError</code></p>
<p>如果获取的缓冲区无效则会由 <code>TarInfo.frombuf()</code> 引发的异常。</p>
<p>以下常量在模块层级上可用:</p>
<pre><code>tarfile.ENCODING</code></pre><p>默认的字符编码格式：在 Windows 上为 <code>'utf-8'</code>，其他系统上则为 <code>sys.getfilesystemencoding()</code> 所返回的值。</p>
<p>以下常量各自定义了一个 <code>tarfile</code> 模块能够创建的 tar 归档格式。 </p>
<pre><code>tarfile.USTAR_FORMAT</code></pre><p>POSIX.1-1988 (ustar) 格式。</p>
<pre><code>tarfile.GNU_FORMAT</code></pre><p>GNU tar 格式。</p>
<pre><code>tarfile.PAX_FORMAT</code></pre><p>POSIX.1-2001 (pax) 格式。</p>
<pre><code>tarfile.DEFAULT_FORMAT</code></pre><p>用于创建归档的默认格式。 目前为 <code>PAX_FORMAT</code>。</p>
<p>在 3.8 版更改: 新归档的默认格式已更改为 <code>PAX_FORMAT</code> 而不再是 <code>GNU_FORMAT</code>。</p>
<p>参见</p>
<p>归档操作</p>
<p>标准 <code>shutil</code> 模块所提供的高层级归档工具的文档。</p>
<p><a href="https://www.gnu.org/software/tar/manual/html_node/Standard.html" target="_blank" rel="noopener">GNU tar manual, Basic Tar Format</a></p>
<p>针对 tar 归档文件的文档，包含 GNU tar 扩展。</p>
<h3 id="TarFile-对象"><a href="#TarFile-对象" class="headerlink" title="TarFile 对象"></a>TarFile 对象</h3><p><code>TarFile</code> 对象提供了一个 tar 归档的接口。 一个 tar 归档就是数据块的序列。 一个归档成员（被保存文件）是由一个标头块加多个数据块组成的。 一个文件可以在一个 tar 归档中多次被保存。 每个归档成员都由一个 <code>TarInfo</code> 对象来代表。</p>
<p><code>TarFile</code> 对象可在 <code>with</code> 语句中作为上下文管理器使用。 当语句块结束时它将自动被关闭。 请注意在发生异常事件时被打开用于写入的归档将不会被终结；只有内部使用的文件对象将被关闭。 </p>
<p>3.2 新版功能: 添加了对上下文管理器协议的支持。</p>
<p><em>class</em> <code>tarfile.TarFile</code>(<em>name=None</em>, <em>mode=’r’</em>, <em>fileobj=None</em>, <em>format=DEFAULT_FORMAT</em>, <em>tarinfo=TarInfo</em>, <em>dereference=False</em>, <em>ignore_zeros=False</em>, <em>encoding=ENCODING</em>, <em>errors=’surrogateescape’</em>, <em>pax_headers=None</em>, <em>debug=0</em>, <em>errorlevel=0</em>)</p>
<p>下列所有参数都是可选项并且也可作为实例属性来访问。</p>
<p><em>name</em> 是归档的路径名称。 <em>name</em> 可以是一个 path-like object。 如果给定了 <em>fileobj</em> 则它可以被省略。 在此情况下，如果对象的 <code>name</code> 属性存在则它会被使用。</p>
<p><em>mode</em> 可以为 <code>'r'</code> 表示从现有归档读取，<code>'a'</code> 表示将数据追加到现有文件，<code>'w'</code> 表示创建新文件覆盖现有文件，或者 <code>'x'</code> 表示仅在文件不存在时创建新文件。</p>
<p>如果给定了 <em>fileobj*，它会被用于读取或写入数据。 如果可以被确定，则 *mode</em> 会被 <em>fileobj</em> 的模式所覆盖。 <em>fileobj</em> 的使用将从位置 0 开始。</p>
<p>注解</p>
<p>当 <code>TarFile</code> 被关闭时，<em>fileobj</em> 不会被关闭。</p>
<p><em>format</em> 控制用于写入的归档格式。 它必须为在模块层级定义的常量 <code>USTAR_FORMAT</code>, <code>GNU_FORMAT</code> 或 <code>PAX_FORMAT</code> 中的一个。 当读取时，格式将被自动检测，即使单个归档中存在不同的格式。</p>
<p><em>tarinfo</em> 参数可以被用来将默认的 <code>TarInfo</code> 类替换为另一个。</p>
<p>如果 <em>dereference</em> 为 <code>False</code>，则会将符号链接和硬链接添加到归档中。 如果为 <code>True</code>，则会将目标文件的内容添加到归档中。 在不支持符号链接的系统上参数将不起作用。</p>
<p>如果 <em>ignore_zeros</em> 为 <code>False</code>，则会将空的数据块当作归档的末尾来处理。 如果为 <code>True</code>，则会跳过空的（和无效的）数据块并尝试获取尽可能多的成员。 此参数仅适用于读取拼接的或损坏的归档。</p>
<p><em>debug</em> 可设为从 <code>0</code> (无调试消息) 到 <code>3</code> (全部调试消息)。 消息会被写入到 <code>sys.stderr</code>。</p>
<p>如果 <em>errorlevel</em> 为 <code>0</code>，则当使用 <code>TarFile.extract()</code> 时会忽略所有错误。 无论何种情况，当启用调试时它们都将被显示为调试输出的错误消息。 如果为 <code>1</code>，则所有 <em>fatal</em> 错误会被作为 <code>OSError</code> 异常被引发。 如果为 <code>2</code>，则所有 <em>non-fatal</em> 错误也会被作为 <code>TarError</code> 异常被引发。</p>
<p><em>encoding</em> 和 <em>errors</em> 参数定义了读取或写入归档所使用的字符编码格式以及要如何处理转换错误。 默认设置将适用于大多数用户。 </p>
<p>可选的 <em>pax_headers</em> 参数是字符串的字典，如果 <em>format</em> 为 <code>PAX_FORMAT</code> 它将被作为 pax 全局标头被添加。</p>
<p>在 3.2 版更改: 使用 <code>'surrogateescape'</code> 作为 <em>errors</em> 参数的默认值。</p>
<p>在 3.5 版更改: 添加了 <code>'x'</code> (单独创建) 模式。</p>
<p>在 3.6 版更改: <em>name</em> 形参接受一个 path-like object。</p>
<p><em>classmethod</em> <code>TarFile.open</code>(<em>…</em>)</p>
<p>作为替代的构造器。 <code>tarfile.open()</code> 函数实际上是这个类方法的快捷方式。</p>
<p><code>TarFile.getmember</code>(<em>name</em>)</p>
<p>返回成员 <em>name</em> 的 <code>TarInfo</code> 对象。 如果 <em>name</em> 在归档中找不到，则会引发 <code>KeyError</code>。</p>
<p>注解</p>
<p>如果一个成员在归档中出现超过一次，它的最后一次出现会被视为是最新的版本。</p>
<p><code>TarFile.getmembers</code>()</p>
<p>以 <code>TarInfo</code> 对象列表的形式返回归档的成员。 列表的顺序与归档中成员的顺序一致。</p>
<p><code>TarFile.getnames</code>()</p>
<p>以名称列表的形式返回成员。 它的顺序与 <code>getmembers()</code> 所返回列表的顺序一致。</p>
<p><code>TarFile.list</code>(<em>verbose=True</em>, <em>**,</em> members=None*)</p>
<p>将内容清单打印到 <code>sys.stdout</code>。 如果 <em>verbose</em> 为 <code>False</code>，则将只打印成员名称。 如果为 <code>True</code>，则输出将类似于 <strong>ls -l</strong> 的输出效果。 如果给定了可选的 <em>members</em>，它必须为 <code>getmembers()</code> 所返回的列表的一个子集。</p>
<p>在 3.5 版更改: 添加了 <em>members</em> 形参。</p>
<p><code>TarFile.next</code>()</p>
<p>当 <code>TarFile</code> 被打开用于读取时，以 <code>TarInfo</code> 对象的形式返回归档的下一个成员。 如果不再有可用对象则返回 <code>None</code>。</p>
<p><code>TarFile.extractall</code>(<em>path=’.’</em>, <em>members=None</em>, <em>**,</em> numeric_owner=False*)</p>
<p>将归档中的所有成员提取到当前工作目录或 <em>path</em> 目录。 如果给定了可选的 <em>members</em>，则它必须为 <code>getmembers()</code> 所返回的列表的一个子集。 字典信息例如所有者、修改时间和权限会在所有成员提取完毕后被设置。 这样做是为了避免两个问题：目录的修改时间会在每当在其中创建文件时被重置。 并且如果目录的权限不允许写入，提取文件到目录的操作将失败。</p>
<p>如果 <em>numeric_owner</em> 为 <code>True</code>，则将使用来自 tarfile 的 uid 和 gid 数值来设置被提取文件的所有者/用户组。 在其他情况下，则会使用来自 tarfile 的名称值。</p>
<p>警告</p>
<p>绝不要未经预先检验就从不可靠的源中提取归档文件。 这样有可能在 <em>path</em> 之外创建文件，例如某些成员具有以 <code>"/"</code> 开始的绝对路径文件名或带有两个点号 <code>".."</code> 的文件名。</p>
<p>在 3.5 版更改: 添加了 <em>numeric_owner</em> 形参。</p>
<p>在 3.6 版更改: <em>path</em> 形参接受一个 path-like object。</p>
<p><code>TarFile.extract</code>(<em>member</em>, <em>path=’’</em>, <em>set_attrs=True</em>, <em>**,</em> numeric_owner=False*)</p>
<p>从归档中提取出一个成员放入当前工作目录，将使用其完整名称。 成员的文件信息会尽可能精确地被提取。 <em>member</em> 可以是一个文件名或 <code>TarInfo</code> 对象。 你可以使用 <em>path</em> 指定一个不同的目录。 <em>path</em> 可以是一个 path-like object。 将会设置文件属性 (owner, mtime, mode) 除非 <em>set_attrs</em> 为假值。</p>
<p>如果 <em>numeric_owner</em> 为 <code>True</code>，则将使用来自 tarfile 的 uid 和 gid 数值来设置被提取文件的所有者/用户组。 在其他情况下，则会使用来自 tarfile 的名称值。</p>
<p>注解</p>
<p><code>extract()</code> 方法不会处理某些提取问题。 在大多数情况下你应当考虑使用 <code>extractall()</code> 方法。</p>
<p>警告</p>
<p>查看 <code>extractall()</code> 的警告信息。</p>
<p>在 3.2 版更改: 添加了 <em>set_attrs</em> 形参。</p>
<p>在 3.5 版更改: 添加了 <em>numeric_owner</em> 形参。</p>
<p>在 3.6 版更改: <em>path</em> 形参接受一个 path-like object。</p>
<p><code>TarFile.extractfile</code>(<em>member</em>)</p>
<p>将归档中的一个成员提取为文件对象。 <em>member</em> 可以是一个文件名或 <code>TarInfo</code> 对象。 如果 <em>member</em> 是一个常规文件或链接，则会返回一个 <code>io.BufferedReader</code> 对象。 对于所有其他现有成员，则都将返回 <code>None</code>。 如果 <em>member</em> 未在归档中出现，则会引发 <code>KeyError</code>。</p>
<p>在 3.3 版更改: 返回一个 <code>io.BufferedReader</code> 对象。</p>
<p><code>TarFile.add</code>(<em>name</em>, <em>arcname=None</em>, <em>recursive=True</em>, <em>**,</em> filter=None*)</p>
<p>将文件 <em>name</em> 添加到归档。 <em>name</em> 可以为任意类型的文件（目录、fifo、符号链接等等）。 如果给出 <em>arcname</em> 则它将为归档中的文件指定一个替代名称。 默认情况下会递归地添加目录。 这可以通过将 <em>recursive</em> 设为 <code>False</code> 来避免。 递归操作会按排序顺序添加条目。 如果给定了 <em>filter</em>，它应当为一个接受 <code>TarInfo</code> 对象并返回已修改 <code>TarInfo</code> 对象的函数。 如果它返回 <code>None</code> 则 <code>TarInfo</code> 对象将从归档中被排除。 </p>
<p>在 3.2 版更改: 添加了 <em>filter</em> 形参。</p>
<p>在 3.7 版更改: 递归操作按排序顺序添加条目。</p>
<p><code>TarFile.addfile</code>(<em>tarinfo</em>, <em>fileobj=None</em>)</p>
<p>将 <code>TarInfo</code> 对象 <em>tarinfo</em> 添加到归档。 如果给定了 <em>fileobj</em>，它应当是一个 binary file，并会从中读取 <code>tarinfo.size</code> 个字节添加到归档。 你可以直接创建 <code>TarInfo</code> 对象，或是使用 <code>gettarinfo()</code> 来创建。</p>
<p><code>TarFile.gettarinfo</code>(<em>name=None</em>, <em>arcname=None</em>, <em>fileobj=None</em>)</p>
<p>基于 <code>os.stat()</code> 的结果或者现有文件的相同数据创建一个 <code>TarInfo</code>。 文件或者是命名为 <em>name<em>，或者是使用文件描述符指定为一个 file object *fileobj</em>。 *name</em> 可以是一个 path-like object。 如果给定了 <em>arcname*，则它将为归档中的文件指定一个替代名称，在其他情况下，名称将从 *fileobj</em> 的 <code>name</code> 属性或 <em>name</em> 参数获取。 名称应当是一个文本字符串。</p>
<p>你可以在使用 <code>addfile()</code> 添加 <code>TarInfo</code> 的某些属性之前修改它们。 如果文件对象不是从文件开头进行定位的普通文件对象，<code>size</code> 之类的属性就可能需要修改。 例如 <code>GzipFile</code> 之类的文件就属于这种情况。 <code>name</code> 也可以被修改，在这种情况下 <em>arcname</em> 可以是一个占位字符串。</p>
<p>在 3.6 版更改: <em>name</em> 形参接受一个 path-like object。</p>
<p><code>TarFile.close</code>()</p>
<p>关闭 <code>TarFile</code>。 在写入模式下，会向归档添加两个表示结束的零数据块。</p>
<pre><code>TarFile.pax_headers</code></pre><p>一个包含 pax 全局标头的键值对的字典。</p>
<h3 id="TarInfo-对象"><a href="#TarInfo-对象" class="headerlink" title="TarInfo 对象"></a>TarInfo 对象</h3><p><code>TarInfo</code> 对象代表 <code>TarFile</code> 中的一个文件。 除了会存储所有必要的文件属性（例如文件类型、大小、时间、权限、所有者等），它还提供了一些确定文件类型的有用方法。 此对象 <em>并不</em> 包含文件数据本身。</p>
<p><code>TarInfo</code> 对象可通过 <code>TarFile</code> 的方法 <code>getmember()</code>, <code>getmembers()</code> 和 <code>gettarinfo()</code> 返回。</p>
<p><em>class</em> <code>tarfile.TarInfo</code>(<em>name=’’</em>)</p>
<p>创建一个 <code>TarInfo</code> 对象。</p>
<p><em>classmethod</em> <code>TarInfo.frombuf</code>(<em>buf</em>, <em>encoding</em>, <em>errors</em>)</p>
<p>基于字符串缓冲区 <em>buf</em> 创建并返回一个 <code>TarInfo</code> 对象。</p>
<p>如果缓冲区无效则会引发 <code>HeaderError</code>。</p>
<p><em>classmethod</em> <code>TarInfo.fromtarfile</code>(<em>tarfile</em>)</p>
<p>从 <code>TarFile</code> 对象 <em>tarfile</em> 读取下一个成员并将其作为 <code>TarInfo</code> 对象返回。</p>
<p><code>TarInfo.tobuf</code>(<em>format=DEFAULT_FORMAT</em>, <em>encoding=ENCODING</em>, <em>errors=’surrogateescape’</em>)</p>
<p>基于 <code>TarInfo</code> 对象创建一个字符串缓冲区。 </p>
<p>在 3.2 版更改: 使用 <code>'surrogateescape'</code> 作为 <em>errors</em> 参数的默认值。</p>
<p><code>TarInfo</code> 对象具有以下公有数据属性:</p>
<pre><code>TarInfo.name</code></pre><p>归档成员的名称。</p>
<pre><code>TarInfo.size</code></pre><p>以字节表示的大小。</p>
<pre><code>TarInfo.mtime</code></pre><p>上次修改的时间。</p>
<pre><code>TarInfo.mode</code></pre><p>权限位。</p>
<pre><code>TarInfo.type</code></pre><p>文件类型。 <em>type</em> 通常为以下常量之一: <code>REGTYPE</code>, <code>AREGTYPE</code>, <code>LNKTYPE</code>, <code>SYMTYPE</code>, <code>DIRTYPE</code>, <code>FIFOTYPE</code>, <code>CONTTYPE</code>, <code>CHRTYPE</code>, <code>BLKTYPE</code>, <code>GNUTYPE_SPARSE</code>。 要更方便地确定一个 <code>TarInfo</code> 对象的类型，请使用下述的 <code>is*()</code> 方法。</p>
<pre><code>TarInfo.linkname</code></pre><p>目标文件名的名称，该属性仅在类型为 <code>LNKTYPE</code> 和 <code>SYMTYPE</code> 的 <code>TarInfo</code> 对象中存在。</p>
<pre><code>TarInfo.uid</code></pre><p>最初保存该成员的用户的用户 ID。</p>
<pre><code>TarInfo.gid</code></pre><p>最初保存该成员的用户的分组 ID。</p>
<pre><code>TarInfo.uname</code></pre><p>用户名。</p>
<pre><code>TarInfo.gname</code></pre><p>分组名。</p>
<pre><code>TarInfo.pax_headers</code></pre><p>一个包含所关联的 pax 扩展标头的键值对的字典。</p>
<p><code>TarInfo</code> 对象还提供了一些便捷查询方法:</p>
<p><code>TarInfo.isfile</code>()</p>
<p>如果 <code>Tarinfo</code> 对象为普通文件则返回 <code>True</code>。</p>
<p><code>TarInfo.isreg</code>()</p>
<p>与 <code>isfile()</code> 相同。</p>
<p><code>TarInfo.isdir</code>()</p>
<p>如果为目录则返回 <code>True</code>。</p>
<p><code>TarInfo.issym</code>()</p>
<p>如果为符号链接则返回 <code>True</code>。</p>
<p><code>TarInfo.islnk</code>()</p>
<p>如果为硬链接则返回 <code>True</code>。</p>
<p><code>TarInfo.ischr</code>()</p>
<p>如果为字符设备则返回 <code>True</code>。</p>
<p><code>TarInfo.isblk</code>()</p>
<p>如果为块设备则返回 <code>True</code>。</p>
<p><code>TarInfo.isfifo</code>()</p>
<p>如果为 FIFO 则返回 <code>True</code>。.</p>
<p><code>TarInfo.isdev</code>()</p>
<p>如果为字符设备、块设备或 FIFO 之一则返回 <code>True</code>。</p>
<h3 id="命令行接口-1"><a href="#命令行接口-1" class="headerlink" title="命令行接口"></a>命令行接口</h3><p>3.4 新版功能.</p>
<p><code>tarfile</code> 模块提供了简单的命令行接口以便与 tar 归档进行交互。</p>
<p>如果你想要创建一个新的 tar 归档，请在 <code>-c</code> 选项后指定其名称然后列出应当被包含的文件名:</p>
<pre><code>$ python -m tarfile -c monty.tar  spam.txt eggs.txt</code></pre><p>传入一个字典也是可接受的:</p>
<pre><code>$ python -m tarfile -c monty.tar life-of-brian_1979/</code></pre><p>如果你想要将一个 tar 归档提取到指定的目录，请使用 <code>-e</code> 选项:</p>
<pre><code>$ python -m tarfile -e monty.tar</code></pre><p>你也可以通过传入目录名称将一个 tar 归档提取到不同的目录:</p>
<pre><code>$ python -m tarfile -e monty.tar  other-dir/</code></pre><p>要获取一个 tar 归档中文件的列表，请使用 <code>-l</code> 选项:</p>
<pre><code>$ python -m tarfile -l monty.tar</code></pre><h4 id="命令行选项-2"><a href="#命令行选项-2" class="headerlink" title="命令行选项"></a>命令行选项</h4><pre><code>-l` `&lt;tarfile&gt;
--list` `&lt;tarfile&gt;</code></pre><p>列出一个 tarfile 中的文件名。</p>
<pre><code>-c` `&lt;tarfile&gt; &lt;source1&gt; ... &lt;sourceN&gt;
--create` `&lt;tarfile&gt; &lt;source1&gt; ... &lt;sourceN&gt;</code></pre><p>基于源文件创建 tarfile。</p>
<pre><code>-e` `&lt;tarfile&gt; [&lt;output_dir&gt;]
--extract` `&lt;tarfile&gt; [&lt;output_dir&gt;]</code></pre><p>如果未指定 <em>output_dir</em> 则会将 tarfile 提取到当前目录。</p>
<pre><code>-t` `&lt;tarfile&gt;
--test` `&lt;tarfile&gt;</code></pre><p>检测 tarfile 是否有效。</p>
<pre><code>-v``,` `--verbose</code></pre><p>更详细地输出结果。</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>如何将整个 tar 归档提取到当前工作目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> tarfile
tar <span class="token operator">=</span> tarfile<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"sample.tar.gz"</span><span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>extractall<span class="token punctuation">(</span><span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如何通过 <code>TarFile.extractall()</code> 使用生成器函数而非列表来提取一个 tar 归档的子集:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os
<span class="token keyword">import</span> tarfile
<span class="token keyword">def</span> <span class="token function">py_files</span><span class="token punctuation">(</span>members<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> tarinfo <span class="token keyword">in</span> members<span class="token punctuation">:</span>
        <span class="token keyword">if</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>splitext<span class="token punctuation">(</span>tarinfo<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">".py"</span><span class="token punctuation">:</span>
            <span class="token keyword">yield</span> tarinfo
tar <span class="token operator">=</span> tarfile<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"sample.tar.gz"</span><span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>extractall<span class="token punctuation">(</span>members<span class="token operator">=</span>py_files<span class="token punctuation">(</span>tar<span class="token punctuation">)</span><span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如何基于一个文件名列表创建未压缩的 tar 归档:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> tarfile
tar <span class="token operator">=</span> tarfile<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"sample.tar"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> name <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token string">"quux"</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
    tar<span class="token punctuation">.</span>add<span class="token punctuation">(</span>name<span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>with</code> 语句的同一个示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> tarfile
<span class="token keyword">with</span> tarfile<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"sample.tar"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tar<span class="token punctuation">:</span>
    <span class="token keyword">for</span> name <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token string">"quux"</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        tar<span class="token punctuation">.</span>add<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如何读取一个 gzip 压缩的 tar 归档并显示一些成员信息:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> tarfile
tar <span class="token operator">=</span> tarfile<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"sample.tar.gz"</span><span class="token punctuation">,</span> <span class="token string">"r:gz"</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> tarinfo <span class="token keyword">in</span> tar<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>tarinfo<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">"is"</span><span class="token punctuation">,</span> tarinfo<span class="token punctuation">.</span>size<span class="token punctuation">,</span> <span class="token string">"bytes in size and is "</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> tarinfo<span class="token punctuation">.</span>isreg<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a regular file."</span><span class="token punctuation">)</span>
    <span class="token keyword">elif</span> tarinfo<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a directory."</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"something else."</span><span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如何创建一个归档并使用 <code>TarFile.add()</code> 中的 <em>filter</em> 形参来重置用户信息:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> tarfile
<span class="token keyword">def</span> <span class="token function">reset</span><span class="token punctuation">(</span>tarinfo<span class="token punctuation">)</span><span class="token punctuation">:</span>
    tarinfo<span class="token punctuation">.</span>uid <span class="token operator">=</span> tarinfo<span class="token punctuation">.</span>gid <span class="token operator">=</span> <span class="token number">0</span>
    tarinfo<span class="token punctuation">.</span>uname <span class="token operator">=</span> tarinfo<span class="token punctuation">.</span>gname <span class="token operator">=</span> <span class="token string">"root"</span>
    <span class="token keyword">return</span> tarinfo
tar <span class="token operator">=</span> tarfile<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">"sample.tar.gz"</span><span class="token punctuation">,</span> <span class="token string">"w:gz"</span><span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> filter<span class="token operator">=</span>reset<span class="token punctuation">)</span>
tar<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="受支持的-tar-格式"><a href="#受支持的-tar-格式" class="headerlink" title="受支持的 tar 格式"></a>受支持的 tar 格式</h3><p>通过 <code>tarfile</code> 模块可以创建三种 tar 格式:</p>
<ul>
<li><p>The POSIX.1-1988 ustar 格式 (<code>USTAR_FORMAT</code>)。 它支持最多 256 个字符的文件名长度和最多 100 个字符的链接名长度。 文件大小上限为 8 GiB。 这是一种老旧但广受支持的格式。</p>
</li>
<li><p>GNU tar 格式 (<code>GNU_FORMAT</code>)。 它支持长文件名和链接名、大于 8 GiB 的文件以及稀疏文件。 它是 GNU/Linux 系统上的事实标准。 <code>tarfile</code> 完全支持针对长名称的 GNU tar 扩展，稀疏文件支持则限制为只读。</p>
</li>
<li><p>POSIX.1-2001 pax 格式 (<code>PAX_FORMAT</code>)。 它是几乎无限制的最灵活格式。 它支持长文件名和链接名，大文件以及使用便捷方式存储路径名。 现代的 tar 实现，包括 GNU tar, bsdtar/libarchive 和 star，完全支持扩展 <em>pax</em> 特性；某些老旧或不维护的库可能不受支持，但应当会将 <em>pax</em> 归档视为广受支持的 <em>ustar</em> 格式。 这是目前新建归档的默认格式。</p>
<p>它扩展了现有的 <em>ustar</em> 格式，包括用于无法以其他方式存储的附加标头。 存在两种形式的 pax 标头：扩展标头只影响后续的文件标头，全局标头则适用于完整归档并会影响所有后续的文件。 为了便于移植，在 pax 标头中的所有数据均以 <em>UTF-8</em> 编码。</p>
</li>
</ul>
<p>还有一些 tar 格式的其他变种，它们可以被读取但不能被创建:</p>
<ul>
<li>古老的 V7 格式。 这是来自 Unix 第七版的第一个 tar 格式，它只存储常规文件和目录。 名称长度不能超过 100 个字符，并且没有用户/分组名信息。 某些归档在带有非 ASCII 字符字段的情况下会产生计算错误的标头校验和。</li>
<li>SunOS tar 扩展格式。 此格式是 POSIX.1-2001 pax 格式的一个变种，但并不保持兼容。</li>
</ul>
<h3 id="Unicode-问题"><a href="#Unicode-问题" class="headerlink" title="Unicode 问题"></a>Unicode 问题</h3><p>最初 tar 格式被设计用来在磁带机上生成备份，主要关注于保存文件系统信息。 现在 tar 归档通常用于文件分发和在网络上交换归档。 最初格式（它是所有其他格式的基础）的一个问题是它没有支持不同字符编码格式的概念。 例如，一个在 <em>UTF-8</em> 系统上创建的普通 tar 归档如果包含非 <em>ASCII</em> 字符则将无法在 <em>Latin-1</em> 系统上被正确读取。 文本元数据（例如文件名，链接名，用户/分组名）将变为损坏状态。 不幸的是，没有什么办法能够自动检测一个归档的编码格式。 pax 格式被设计用来解决这个问题。 它使用通用字符编码格式 <em>UTF-8</em> 来存储非 ASCII 元数据。</p>
<p>在 <code>tarfile</code> 中字符转换的细节由 <code>TarFile</code> 类的 <em>encoding</em> 和 <em>errors</em> 关键字参数控制。</p>
<p><em>encoding</em> 定义了用于归档中元数据的字符编码格式。 默认值为 <code>sys.getfilesystemencoding()</code> 或是回退选项 <code>'ascii'</code>。 根据归档是被读取还是被写入，元数据必须被解码或编码。 如果没有正确设置 <em>encoding</em>，转换可能会失败。</p>
<p><em>errors</em> 参数定义了不能被转换的字符将如何处理。 可能的取值在 错误处理方案 小节列出。 默认方案为 <code>'surrogateescape'</code>，它也被 Python 用于文件系统调用。</p>
<p>对于 <code>PAX_FORMAT</code> 归档（默认格式），<em>encoding</em> 通常是不必要的，因为所有元数据都使用 <em>UTF-8</em> 来存储。 <em>encoding</em> 仅在解码二进制 pax 标头或存储带有替代字符的字符串等少数场景下会被使用。</p>
<h1 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h1><ul>
<li><code>csv</code> —- CSV 文件读写<ul>
<li>模块内容</li>
<li>变种与格式参数</li>
<li>Reader 对象</li>
<li>Writer 对象</li>
<li>例子</li>
</ul>
</li>
<li><code>configparser</code> —- 配置文件解析器<ul>
<li>快速起步</li>
<li>支持的数据类型</li>
<li>回退值</li>
<li>受支持的 INI 文件结构</li>
<li>值的插值</li>
<li>映射协议访问</li>
<li>定制解析器行为</li>
<li>旧式 API 示例</li>
<li>ConfigParser 对象</li>
<li>RawConfigParser 对象</li>
<li>异常</li>
</ul>
</li>
<li><code>netrc</code> —- netrc 文件处理<ul>
<li>netrc 对象</li>
</ul>
</li>
<li><code>xdrlib</code> —- 编码与解码 XDR 数据<ul>
<li>Packer 对象</li>
<li>Unpacker 对象</li>
<li>异常</li>
</ul>
</li>
<li><code>plistlib</code> —- 生成与解析 Apple <code>.plist</code> 文件<ul>
<li>例子</li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io" rel="external nofollow noreferrer">杰克成</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io/posts/Language-Python-Lib2.html">https://jackhcc.github.io/posts/Language-Python-Lib2.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Python/">
                                    <span class="chip bg-color">Python</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/aliqr.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/wxqr.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '3821a0bbb773038a51fc',
        clientSecret: '4b30b507d67ec5497ec0e77f43f80cb3e0d7dd3a',
        repo: 'JackHCC.github.io',
        owner: 'JackHCC',
        admin: "JackHCC",
        id: '2021-11-04T18-42-52',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/dl-series17.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/8.jpg" class="responsive-img" alt="DL专栏17>网络可视化">
                        
                        <span class="card-title">DL专栏17>网络可视化</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            深度学习模型网络可视化概述
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-11-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Deep-Learning/" class="post-category">
                                    Deep Learning
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Deep-Learning/">
                        <span class="chip bg-color">Deep Learning</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/Language-Python-Lib1.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/7.jpg" class="responsive-img" alt="Python-Standard Library">
                        
                        <span class="card-title">Python-Standard Library</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Python标准库详解【1】
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Language/" class="post-category">
                                    Language
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Python/">
                        <span class="chip bg-color">Python</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('4'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">2600.3k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "2";
                    var startDate = "27";
                    var startHour = "6";
                    var startMinute = "30";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/JackHCC" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:jackcc0701@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://www.facebook.com/profile.php?id=100046343443643" class="tooltipped" target="_blank" data-tooltip="关注我的Facebook: https://www.facebook.com/profile.php?id=100046343443643" data-position="top" data-delay="50">
        <i class="fab fa-facebook-f"></i>
    </a>



    <a href="https://twitter.com/JackChe66021834" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/JackChe66021834" data-position="top" data-delay="50">
        <i class="fab fa-twitter"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2508074836" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2508074836" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/6885584679" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/6885584679" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/matery.js"></script>

    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script type="text/javascript" src="/js/fireworks.js"></script>

    <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>'); }
    </script>

    <!-- weather -->
	<script type="text/javascript">
	WIDGET = {FID: 'TToslpmkVO'}
	</script>
	<script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>


    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

    
    
    <script async src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    
        <script src="//code.tidio.co/kqhlkxviiccyoa0czpfpu4ijuey9hfre.js"></script>
        <script> 
            $(document).ready(function () {
                setInterval(change_Tidio, 50);  
                function change_Tidio() { 
                    var tidio=$("#tidio-chat iframe");
                    if(tidio.css("display")=="block"&& $(window).width()>977 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" &&$(window).width()>977)>0? "-40px" : ($("div.toc-title").length&&$(window).width()>977)>0?"85px":"20px";   
                        document.getElementById("tidio-chat-iframe").style.right="-15px";   
                        document.getElementById("tidio-chat-iframe").style.height=parseInt(tidio.css("height"))>=520?"520px":tidio.css("height");
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    } 
                    else if(tidio.css("display")=="block"&&$(window).width()>601 &&$(window).width()<992 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && 601< $(window).width()<992)>0? "-40px":"20px" ;   
                        document.getElementById("tidio-chat-iframe").style.right="-15px"; 
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    else if(tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))<230){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && $(window).width()<601)>0? "-10px":"45px" ;   
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    if( tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))>=230){
                        document.getElementById("tidio-chat-iframe").style.zIndex="998";
                    }
                } 
            }); 
        </script>
    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/instantpage/instantpage.js" type="module"></script>
    

        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        $('a').each(function() {
          const $this = $(this);
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'your_domain' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script><script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script></body>

</html>

