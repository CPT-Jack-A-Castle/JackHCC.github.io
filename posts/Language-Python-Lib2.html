<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Python-Standard Library, JackHCC">
    <meta name="description" content="Python标准库详解【2】">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Python-Standard Library | JackHCC</title>
    <link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/favicon.png">

    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/matery.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my.css">
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="JackHCC" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-hopscotch.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">JackHCC</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/me.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">JackHCC</div>
        <div class="logo-desc">
            
            Make the world betterrrr!!!
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/JackHCC/JackHCC.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/JackHCC/JackHCC.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/7.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Python-Standard Library</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 30px;
        bottom: 146px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Python/">
                                <span class="chip bg-color">Python</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Python/" class="post-category">
                                Python
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-11-04
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2021-11-13
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    42.5k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    175 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Python-标准库"><a href="#Python-标准库" class="headerlink" title="Python 标准库"></a>Python 标准库</h1><ul>
<li>函数式编程模块<ul>
<li><code>itertools</code> —- 为高效循环而创建迭代器的函数</li>
<li><code>functools</code> —- 高阶函数和可调用对象上的操作</li>
<li><code>operator</code> —- 标准运算符替代函数</li>
</ul>
</li>
<li>文件和目录访问<ul>
<li><code>pathlib</code> —- 面向对象的文件系统路径</li>
<li><code>os.path</code> —- 常用路径操作</li>
<li><code>fileinput</code> —- 迭代来自多个输入流的行</li>
<li><code>stat</code> —- 解析 <code>stat()</code> 结果</li>
<li><code>filecmp</code> —- 文件及目录的比较</li>
<li><code>tempfile</code> —- 生成临时文件和目录</li>
<li><code>glob</code> —- Unix 风格路径名模式扩展</li>
<li><code>fnmatch</code> —- Unix 文件名模式匹配</li>
<li><code>linecache</code> —- 随机读写文本行</li>
<li><code>shutil</code> —- 高阶文件操作</li>
</ul>
</li>
<li>数据持久化<ul>
<li><code>pickle</code> —- Python 对象序列化</li>
<li><code>copyreg</code> —- 注册配合 <code>pickle</code> 模块使用的函数</li>
<li><code>shelve</code> —- Python 对象持久化</li>
<li><code>marshal</code> —- 内部 Python 对象序列化</li>
<li><code>dbm</code> —- Unix “数据库” 接口</li>
<li><code>sqlite3</code> —- SQLite 数据库 DB-API 2.0 接口模块</li>
</ul>
</li>
<li>数据压缩和存档<ul>
<li><code>zlib</code> —- 与 <strong>gzip</strong> 兼容的压缩</li>
<li><code>gzip</code> —- 对 <strong>gzip</strong> 格式的支持</li>
<li><code>bz2</code> —- 对 <strong>bzip2</strong> 压缩算法的支持</li>
<li><code>lzma</code> —- 用 LZMA 算法压缩</li>
<li><code>zipfile</code> —- 使用ZIP存档</li>
<li><code>tarfile</code> —- 读写tar归档文件</li>
</ul>
</li>
<li>文件格式<ul>
<li><code>csv</code> —- CSV 文件读写</li>
<li><code>configparser</code> —- 配置文件解析器</li>
<li><code>netrc</code> —- netrc 文件处理</li>
<li><code>xdrlib</code> —- 编码与解码 XDR 数据</li>
<li><code>plistlib</code> —- 生成与解析 Apple <code>.plist</code> 文件</li>
</ul>
</li>
<li>加密服务<ul>
<li><code>hashlib</code> —- 安全哈希与消息摘要</li>
<li><code>hmac</code> —- 基于密钥的消息验证</li>
<li><code>secrets</code> —- 生成管理密码的安全随机数</li>
</ul>
</li>
<li>通用操作系统服务<ul>
<li><code>os</code> —- 多种操作系统接口</li>
<li><code>io</code> —- 处理流的核心工具</li>
<li><code>time</code> —- 时间的访问和转换</li>
<li><code>argparse</code> —- 命令行选项、参数和子命令解析器</li>
<li><code>getopt</code> —- C 风格的命令行选项解析器</li>
<li><code>logging</code> —- Python 的日志记录工具</li>
<li><code>logging.config</code> —- 日志记录配置</li>
<li><code>logging.handlers</code> —- 日志处理程序</li>
<li><code>getpass</code> —- 便携式密码输入工具</li>
<li><code>curses</code> —- 终端字符单元显示的处理</li>
<li><code>curses.textpad</code> —- 用于 curses 程序的文本输入控件</li>
<li><code>curses.ascii</code> —- 用于 ASCII 字符的工具</li>
<li><code>curses.panel</code> —- curses 的面板栈扩展</li>
<li><code>platform</code> —- 获取底层平台的标识数据</li>
<li><code>errno</code> —- 标准 errno 系统符号</li>
<li><code>ctypes</code> —- Python 的外部函数库</li>
</ul>
</li>
<li>并发执行<ul>
<li><code>threading</code> —- 基于线程的并行</li>
<li><code>multiprocessing</code> —- 基于进程的并行</li>
<li><code>multiprocessing.shared_memory</code> —- 可从进程直接访问的共享内存</li>
<li><code>concurrent</code> 包</li>
<li><code>concurrent.futures</code> —- 启动并行任务</li>
<li><code>subprocess</code> —- 子进程管理</li>
<li><code>sched</code> —- 事件调度器</li>
<li><code>queue</code> —- 一个同步的队列类</li>
<li><code>contextvars</code> —- 上下文变量</li>
<li><code>_thread</code> —- 底层多线程 API</li>
</ul>
</li>
<li>网络和进程间通信<ul>
<li><code>asyncio</code> —- 异步 I/O</li>
<li><code>socket</code> —- 底层网络接口</li>
<li><code>ssl</code> —- 套接字对象的 TLS/SSL 包装器</li>
<li><code>select</code> —- 等待 I/O 完成</li>
<li><code>selectors</code> —- 高级 I/O 复用库</li>
<li><code>asyncore</code> —- 异步套接字处理器</li>
<li><code>asynchat</code> —- 异步套接字指令/响应处理程序</li>
<li><code>signal</code> —- 设置异步事件处理程序</li>
<li><code>mmap</code> —- 内存映射文件支持</li>
</ul>
</li>
<li>互联网数据处理<ul>
<li><code>email</code> —- 电子邮件与 MIME 处理包</li>
<li><code>json</code> —- JSON 编码和解码器</li>
<li><code>mailcap</code> —- Mailcap 文件处理</li>
<li><code>mailbox</code> —- 操作多种格式的邮箱</li>
<li><code>mimetypes</code> —- 映射文件名到 MIME 类型</li>
<li><code>base64</code> —- Base16, Base32, Base64, Base85 数据编码</li>
<li><code>binhex</code> —- 对binhex4文件进行编码和解码</li>
<li><code>binascii</code> —- 二进制和 ASCII 码互转</li>
<li><code>quopri</code> —- 编码与解码经过 MIME 转码的可打印数据</li>
<li><code>uu</code> —- 对 uuencode 文件进行编码与解码</li>
</ul>
</li>
<li>结构化标记处理工具<ul>
<li><code>html</code> —- 超文本标记语言支持</li>
<li><code>html.parser</code> —- 简单的 HTML 和 XHTML 解析器</li>
<li><code>html.entities</code> —- HTML 一般实体的定义</li>
<li>XML处理模块</li>
<li><code>xml.etree.ElementTree</code> —- ElementTree XML API</li>
<li><code>xml.dom</code> —- 文档对象模型 API</li>
<li><code>xml.dom.minidom</code> —- 最小化的 DOM 实现</li>
<li><code>xml.dom.pulldom</code> —- 支持构建部分 DOM 树</li>
<li><code>xml.sax</code> —- 支持 SAX2 解析器</li>
<li><code>xml.sax.handler</code> —- SAX 处理句柄的基类</li>
<li><code>xml.sax.saxutils</code> —- SAX 工具集</li>
<li><code>xml.sax.xmlreader</code> —- 用于 XML 解析器的接口</li>
<li><code>xml.parsers.expat</code> —- 使用 Expat 的快速 XML 解析</li>
</ul>
</li>
<li>互联网协议和支持<ul>
<li><code>webbrowser</code> —- 方便的 Web 浏览器控制工具</li>
<li><code>cgi</code> —- 通用网关接口支持</li>
<li><code>cgitb</code> —- 用于 CGI 脚本的回溯管理器</li>
<li><code>wsgiref</code> —- WSGI 工具和参考实现</li>
<li><code>urllib</code> —- URL 处理模块</li>
<li><code>urllib.request</code> —- 用于打开 URL 的可扩展库</li>
<li><code>urllib.response</code> —- urllib 使用的 Response 类</li>
<li><code>urllib.parse</code> 用于解析 URL</li>
<li><code>urllib.error</code> —- urllib.request 引发的异常类</li>
<li><code>urllib.robotparser</code> —- robots.txt 语法分析程序</li>
<li><code>http</code> —- HTTP 模块</li>
<li><code>http.client</code> —- HTTP 协议客户端</li>
<li><code>ftplib</code> —- FTP 协议客户端</li>
<li><code>poplib</code> —- POP3 协议客户端</li>
<li><code>imaplib</code> —- IMAP4 协议客户端</li>
<li><code>nntplib</code> —- NNTP protocol client</li>
<li><code>smtplib</code> —-SMTP协议客户端</li>
<li><code>smtpd</code> —- SMTP 服务器</li>
<li><code>telnetlib</code> — Telnet 客户端</li>
<li><code>uuid</code> —- UUID objects according to <strong>RFC 4122</strong></li>
<li><code>socketserver</code> —- A framework for network servers</li>
<li><code>http.server</code> —- HTTP 服务器</li>
<li><code>http.cookies</code> —- HTTP状态管理</li>
<li><code>http.cookiejar</code> —— HTTP 客户端的 Cookie 处理</li>
<li><code>xmlrpc</code> —- XMLRPC 服务端与客户端模块</li>
<li><code>xmlrpc.client</code> —- XML-RPC 客户端访问</li>
<li><code>xmlrpc.server</code> —- 基本 XML-RPC 服务器</li>
<li><code>ipaddress</code> —- IPv4/IPv6 操作库</li>
</ul>
</li>
<li>多媒体服务<ul>
<li><code>audioop</code> —- 处理原始音频数据</li>
<li><code>aifc</code> —- 读写 AIFF 和 AIFC 文件</li>
<li><code>sunau</code> —- 读写 Sun AU 文件</li>
<li><code>wave</code> —- 读写WAV格式文件</li>
<li><code>chunk</code> —- 读取 IFF 分块数据</li>
<li><code>colorsys</code> —- 颜色系统间的转换</li>
<li><code>imghdr</code> —- 推测图像类型</li>
<li><code>sndhdr</code> —- 推测声音文件的类型</li>
<li><code>ossaudiodev</code> —- 访问兼容OSS的音频设备</li>
</ul>
</li>
<li>国际化<ul>
<li><code>gettext</code> —- 多语种国际化服务</li>
<li><code>locale</code> —- 国际化服务</li>
</ul>
</li>
<li>程序框架<ul>
<li><code>turtle</code> —- 海龟绘图</li>
<li><code>cmd</code> —- 支持面向行的命令解释器</li>
<li><code>shlex</code> —— 简单的词法分析</li>
</ul>
</li>
<li>Tk图形用户界面(GUI)<ul>
<li><code>tkinter</code> —- Tcl/Tk的Python接口</li>
<li><code>tkinter.colorchooser</code> —- 颜色选择对话框</li>
<li><code>tkinter.font</code> —- Tkinter 字体封装</li>
<li>Tkinter 对话框</li>
<li><code>tkinter.messagebox</code> —- Tkinter 消息提示</li>
<li><code>tkinter.scrolledtext</code> —- 滚动文字控件</li>
<li><code>tkinter.dnd</code> —- 拖放操作支持</li>
<li><code>tkinter.ttk</code> —- Tk主题部件</li>
<li><code>tkinter.tix</code> —- TK扩展包</li>
<li>IDLE</li>
</ul>
</li>
<li>开发工具<ul>
<li><code>typing</code> —- 类型提示支持</li>
<li><code>pydoc</code> —- 文档生成器和在线帮助系统</li>
<li>Python Development Mode</li>
<li>Effects of the Python Development Mode</li>
<li>ResourceWarning Example</li>
<li>Bad file descriptor error example</li>
<li><code>doctest</code> —- 测试交互性的Python示例</li>
<li><code>unittest</code> —- 单元测试框架</li>
<li><code>unittest.mock</code> —- 模拟对象库</li>
<li><code>unittest.mock</code> 上手指南</li>
<li>2to3 - 自动将 Python 2 代码转为 Python 3 代码</li>
<li><code>test</code> —- Python回归测试包</li>
<li><code>test.support</code> —- Utilities for the Python test suite</li>
<li><code>test.support.socket_helper</code> —- Utilities for socket tests</li>
<li><code>test.support.script_helper</code> —- Utilities for the Python execution tests</li>
<li><code>test.support.bytecode_helper</code> —- Support tools for testing correct bytecode generation</li>
<li><code>test.support.threading_helper</code> —- Utilities for threading tests</li>
<li><code>test.support.os_helper</code> —- Utilities for os tests</li>
<li><code>test.support.import_helper</code> —- Utilities for import tests</li>
<li><code>test.support.warnings_helper</code> —- Utilities for warnings tests</li>
</ul>
</li>
<li>调试和分析<ul>
<li>审计事件表</li>
<li><code>bdb</code> —- Debugger framework</li>
<li><code>faulthandler</code> —- Dump the Python traceback</li>
<li><code>pdb</code> —- Python 的调试器</li>
<li>Python Profilers 分析器</li>
<li><code>timeit</code> —- 测量小代码片段的执行时间</li>
<li><code>trace</code> —- 跟踪Python语句的执行</li>
<li><code>tracemalloc</code> —- 跟踪内存分配</li>
</ul>
</li>
<li>软件打包和分发<ul>
<li><code>distutils</code> —- 构建和安装 Python 模块</li>
<li><code>ensurepip</code> —- Bootstrapping the <code>pip</code> installer</li>
<li><code>venv</code> —- 创建虚拟环境</li>
<li><code>zipapp</code> —- Manage executable Python zip archives</li>
</ul>
</li>
<li>Python运行时服务<ul>
<li><code>sys</code> —- 系统相关的参数和函数</li>
<li><code>sysconfig</code> —- Provide access to Python’s configuration information</li>
<li><code>builtins</code> —- 内建对象</li>
<li><code>__main__</code> —- Top-level code environment</li>
<li><code>warnings</code> —— 警告信息的控制</li>
<li><code>dataclasses</code> —- 数据类</li>
<li><code>contextlib</code> —- 为 <code>with</code>语句上下文提供的工具</li>
<li><code>abc</code> —- 抽象基类</li>
<li><code>atexit</code> —- 退出处理器</li>
<li><code>traceback</code> —- 打印或检索堆栈回溯</li>
<li><code>__future__</code> —- Future 语句定义</li>
<li><code>gc</code> —- 垃圾回收器接口</li>
<li><code>inspect</code> —- 检查对象</li>
<li><code>site</code> —— 指定域的配置钩子</li>
</ul>
</li>
<li>自定义 Python 解释器<ul>
<li><code>code</code> —- 解释器基类</li>
<li><code>codeop</code> —- 编译Python代码</li>
</ul>
</li>
<li>导入模块<ul>
<li><code>zipimport</code> —- 从 Zip 存档中导入模块</li>
<li><code>pkgutil</code> —- 包扩展工具</li>
<li><code>modulefinder</code> —- 查找脚本使用的模块</li>
<li><code>runpy</code> ——查找并执行 Python 模块</li>
<li><code>importlib</code> —- <code>import</code> 的实现</li>
<li>Using <code>importlib.metadata</code></li>
</ul>
</li>
<li>Python 语言服务<ul>
<li><code>ast</code> —- 抽象语法树</li>
<li><code>symtable</code> —- Access to the compiler’s symbol tables</li>
<li><code>token</code> —- 与Python解析树一起使用的常量</li>
<li><code>keyword</code> —- 检验Python关键字</li>
<li><code>tokenize</code> —- 对 Python 代码使用的标记解析器</li>
<li><code>tabnanny</code> —- 模糊缩进检测</li>
<li><code>pyclbr</code> —- Python 模块浏览器支持</li>
<li><code>py_compile</code> —- 编译 Python 源文件</li>
<li><code>compileall</code> —- Byte-compile Python libraries</li>
<li><code>dis</code> —- Python 字节码反汇编器</li>
<li><code>pickletools</code> —- pickle 开发者工具集</li>
</ul>
</li>
<li>Windows系统相关模块<ul>
<li><code>msilib</code> —- Read and write Microsoft Installer files</li>
<li><code>msvcrt</code> —- 来自 MS VC++ 运行时的有用例程</li>
<li><code>winreg</code> —- 访问 Windows 注册表</li>
<li><code>winsound</code> —— Windows 系统的音频播放接口</li>
</ul>
</li>
<li>Unix 专有服务<ul>
<li><code>posix</code> —- 最常见的 POSIX 系统调用</li>
<li><code>pwd</code> —- 用户密码数据库</li>
<li><code>spwd</code> —- The shadow password database</li>
<li><code>grp</code> —- 组数据库</li>
<li><code>crypt</code> —— 验证 Unix 口令的函数</li>
<li><code>termios</code> —- POSIX 风格的 tty 控制</li>
<li><code>tty</code> —- 终端控制功能</li>
<li><code>pty</code> —- 伪终端工具</li>
<li><code>fcntl</code> —— 系统调用 <code>fcntl</code> 和 <code>ioctl</code></li>
<li><code>pipes</code> —- 终端管道接口</li>
<li><code>resource</code> —- Resource usage information</li>
<li><code>nis</code> —- Sun 的 NIS (黄页) 接口</li>
<li>Unix syslog 库例程</li>
</ul>
</li>
<li>被取代的模块<ul>
<li><code>optparse</code> —- 解析器的命令行选项</li>
<li><code>imp</code> —- Access the import internals</li>
</ul>
</li>
<li>未创建文档的模块<ul>
<li>平台特定模块</li>
</ul>
</li>
<li>Security Considerations</li>
</ul>
<h1 id="函数式编程模块"><a href="#函数式编程模块" class="headerlink" title="函数式编程模块"></a>函数式编程模块</h1><ul>
<li><code>itertools</code> —- 为高效循环而创建迭代器的函数<ul>
<li>Itertool函数</li>
<li>itertools 配方</li>
</ul>
</li>
<li><code>functools</code> —- 高阶函数和可调用对象上的操作<ul>
<li><code>partial</code> 对象</li>
</ul>
</li>
<li><code>operator</code> —- 标准运算符替代函数<ul>
<li>将运算符映射到函数</li>
<li>原地运算符</li>
</ul>
</li>
</ul>
<h2 id="itertools-—-为高效循环而创建迭代器的函数"><a href="#itertools-—-为高效循环而创建迭代器的函数" class="headerlink" title="itertools —- 为高效循环而创建迭代器的函数"></a><code>itertools</code> —- 为高效循环而创建迭代器的函数</h2><p>本模块实现一系列 iterator ，这些迭代器受到APL，Haskell和SML的启发。为了适用于Python，它们都被重新写过。</p>
<p>本模块标准化了一个快速、高效利用内存的核心工具集，这些工具本身或组合都很有用。它们一起形成了“迭代器代数”，这使得在纯Python中有可能创建简洁又高效的专用工具。</p>
<p>例如，SML有一个制表工具： <code>tabulate(f)</code>，它可产生一个序列 <code>f(0), f(1), ...</code>。在Python中可以组合 <code>map()</code> 和 <code>count()</code> 实现： <code>map(f, count())</code>。</p>
<p>这些内置工具同时也能很好地与 <code>operator</code> 模块中的高效函数配合使用。例如，我们可以将两个向量的点积映射到乘法运算符： <code>sum(map(operator.mul, vector1, vector2))</code> 。</p>
<p><strong>无穷迭代器：</strong></p>
<table>
<thead>
<tr>
<th align="left">迭代器</th>
<th align="left">实参</th>
<th align="left">结果</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>count()</code></td>
<td align="left">start, [step]</td>
<td align="left">start, start+step, start+2*step, …</td>
<td align="left"><code>count(10) —&gt; 10 11 12 13 14 …</code></td>
</tr>
<tr>
<td align="left"><code>cycle()</code></td>
<td align="left">p</td>
<td align="left">p0, p1, … plast, p0, p1, …</td>
<td align="left"><code>cycle(‘ABCD’) —&gt; A B C D A B C D …</code></td>
</tr>
<tr>
<td align="left"><code>repeat()</code></td>
<td align="left">elem [,n]</td>
<td align="left">elem, elem, elem, … 重复无限次或n次</td>
<td align="left"><code>repeat(10, 3) —&gt; 10 10 10</code></td>
</tr>
</tbody></table>
<p><strong>根据最短输入序列长度停止的迭代器：</strong></p>
<table>
<thead>
<tr>
<th align="left">迭代器</th>
<th align="left">实参</th>
<th align="left">结果</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>accumulate()</code></td>
<td align="left">p [,func]</td>
<td align="left">p0, p0+p1, p0+p1+p2, …</td>
<td align="left"><code>accumulate([1,2,3,4,5]) —&gt; 1 3 6 10 15</code></td>
</tr>
<tr>
<td align="left"><code>chain()</code></td>
<td align="left">p, q, …</td>
<td align="left">p0, p1, … plast, q0, q1, …</td>
<td align="left"><code>chain(‘ABC’, ‘DEF’) —&gt; A B C D E F</code></td>
</tr>
<tr>
<td align="left"><code>chain.from_iterable()</code></td>
<td align="left">iterable — 可迭代对象</td>
<td align="left">p0, p1, … plast, q0, q1, …</td>
<td align="left"><code>chain.from_iterable([‘ABC’, ‘DEF’]) —&gt; A B C D E F</code></td>
</tr>
<tr>
<td align="left"><code>compress()</code></td>
<td align="left">data, selectors</td>
<td align="left">(d[0] if s[0]), (d[1] if s[1]), …</td>
<td align="left"><code>compress(‘ABCDEF’, [1,0,1,0,1,1]) —&gt; A C E F</code></td>
</tr>
<tr>
<td align="left"><code>dropwhile()</code></td>
<td align="left">pred, seq</td>
<td align="left">seq[n], seq[n+1], … 从pred首次真值测试失败开始</td>
<td align="left"><code>dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) —&gt; 6 4 1</code></td>
</tr>
<tr>
<td align="left"><code>filterfalse()</code></td>
<td align="left">pred, seq</td>
<td align="left">seq中pred(x)为假值的元素，x是seq中的元素。</td>
<td align="left"><code>filterfalse(lambda x: x%2, range(10)) —&gt; 0 2 4 6 8</code></td>
</tr>
<tr>
<td align="left"><code>groupby()</code></td>
<td align="left">iterable[, key]</td>
<td align="left">根据key(v)值分组的迭代器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>islice()</code></td>
<td align="left">seq, [start,] stop [, step]</td>
<td align="left">seq[start:stop:step]中的元素</td>
<td align="left"><code>islice(‘ABCDEFG’, 2, None) —&gt; C D E F G</code></td>
</tr>
<tr>
<td align="left"><code>pairwise()</code></td>
<td align="left">iterable — 可迭代对象</td>
<td align="left">(p[0], p[1]), (p[1], p[2])</td>
<td align="left"><code>pairwise(‘ABCDEFG’) —&gt; AB BC CD DE EF FG</code></td>
</tr>
<tr>
<td align="left"><code>starmap()</code></td>
<td align="left">func, seq</td>
<td align="left">func(<em>seq[0]), func(</em>seq[1]), …</td>
<td align="left"><code>starmap(pow, [(2,5), (3,2), (10,3)]) —&gt; 32 9 1000</code></td>
</tr>
<tr>
<td align="left"><code>takewhile()</code></td>
<td align="left">pred, seq</td>
<td align="left">seq[0], seq[1], …, 直到pred真值测试失败</td>
<td align="left"><code>takewhile(lambda x: x&lt;5, [1,4,6,4,1]) —&gt; 1 4</code></td>
</tr>
<tr>
<td align="left"><code>tee()</code></td>
<td align="left">it, n</td>
<td align="left">it1, it2, … itn 将一个迭代器拆分为n个迭代器</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>zip_longest()</code></td>
<td align="left">p, q, …</td>
<td align="left">(p[0], q[0]), (p[1], q[1]), …</td>
<td align="left"><code>zip_longest(‘ABCD’, ‘xy’, fillvalue=’-‘) —&gt; Ax By C- D-</code></td>
</tr>
</tbody></table>
<p><strong>排列组合迭代器：</strong></p>
<table>
<thead>
<tr>
<th align="left">迭代器</th>
<th align="left">实参</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>product()</code></td>
<td align="left">p, q, … [repeat=1]</td>
<td align="left">笛卡尔积，相当于嵌套的for循环</td>
</tr>
<tr>
<td align="left"><code>permutations()</code></td>
<td align="left">p[, r]</td>
<td align="left">长度r元组，所有可能的排列，无重复元素</td>
</tr>
<tr>
<td align="left"><code>combinations()</code></td>
<td align="left">p, r</td>
<td align="left">长度r元组，有序，无重复元素</td>
</tr>
<tr>
<td align="left"><code>combinations_with_replacement()</code></td>
<td align="left">p, r</td>
<td align="left">长度r元组，有序，元素可重复</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">例子</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>product(‘ABCD’, repeat=2)</code></td>
<td align="left"><code>AA AB AC AD BA BB BC BD CA CB CC CD DA DB DC DD</code></td>
</tr>
<tr>
<td align="left"><code>permutations(‘ABCD’, 2)</code></td>
<td align="left"><code>AB AC AD BA BC BD CA CB CD DA DB DC</code></td>
</tr>
<tr>
<td align="left"><code>combinations(‘ABCD’, 2)</code></td>
<td align="left"><code>AB AC AD BC BD CD</code></td>
</tr>
<tr>
<td align="left"><code>combinations_with_replacement(‘ABCD’, 2)</code></td>
<td align="left"><code>AA AB AC AD BB BC BD CC CD DD</code></td>
</tr>
</tbody></table>
<h3 id="Itertool函数"><a href="#Itertool函数" class="headerlink" title="Itertool函数"></a>Itertool函数</h3><p>下列模块函数均创建并返回迭代器。有些迭代器不限制输出流长度，所以它们只应在能截断输出流的函数或循环中使用。</p>
<p><code>itertools.accumulate</code>(<em>iterable</em>[, <em>func</em>, <em>**,</em> initial=None*])</p>
<p>创建一个迭代器，返回累积汇总值或其他双目运算函数的累积结果值（通过可选的 <em>func</em> 参数指定）。</p>
<p>如果提供了 <em>func*，它应当为带有两个参数的函数。 输入 *iterable</em> 的元素可以是能被 <em>func</em> 接受为参数的任意类型。 （例如，对于默认的加法运算，元素可以是任何可相加的类型包括 <code>Decimal</code> 或 <code>Fraction</code>。）</p>
<p>通常，输出的元素数量与输入的可迭代对象是一致的。 但是，如果提供了关键字参数 <em>initial*，则累加会以 *initial</em> 值开始，这样输出就比输入的可迭代对象多一个元素。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> func<span class="token operator">=</span>operator<span class="token punctuation">.</span>add<span class="token punctuation">,</span><span class="token operator">*</span><span class="token punctuation">,</span> initial<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">'Return running totals'</span>
<span class="token comment" spellcheck="true"># accumulate([1,2,3,4,5]) --> 1 3 6 10 15</span>
<span class="token comment" spellcheck="true"># accumulate([1,2,3,4,5], initial=100) --> 100 101 103 106 110 115</span>
<span class="token comment" spellcheck="true"># accumulate([1,2,3,4,5], operator.mul) --> 1 2 6 24 120</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    total <span class="token operator">=</span> initial
<span class="token keyword">if</span> initial isNone<span class="token punctuation">:</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
            total <span class="token operator">=</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token keyword">return</span>
<span class="token keyword">yield</span> total
<span class="token keyword">for</span> element <span class="token keyword">in</span> it<span class="token punctuation">:</span>
        total <span class="token operator">=</span> func<span class="token punctuation">(</span>total<span class="token punctuation">,</span> element<span class="token punctuation">)</span>
<span class="token keyword">yield</span> total<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>func</em> 参数有几种用法。它可以被设为 <code>min()</code> 最终得到一个最小值，或者设为 <code>max()</code> 最终得到一个最大值，或设为 <code>operator.mul()</code> 最终得到一个乘积。摊销表可通过累加利息和支付款项得到。给iterable设置初始值并只将参数 <em>func</em> 设为累加总数可以对一阶 递归关系 建模。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> data <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>accumulate<span class="token punctuation">(</span>data<span class="token punctuation">,</span>operator<span class="token punctuation">.</span>mul<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># running product</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">72</span><span class="token punctuation">,</span><span class="token number">144</span><span class="token punctuation">,</span><span class="token number">144</span><span class="token punctuation">,</span><span class="token number">1296</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>accumulate<span class="token punctuation">(</span>data<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># running maximum</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># Amortize a 5% loan of 1000 with 4 annual payments of 90</span>
<span class="token operator">>></span><span class="token operator">></span> cashflows <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">90</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>accumulate<span class="token punctuation">(</span>cashflows<span class="token punctuation">,</span><span class="token keyword">lambda</span> bal<span class="token punctuation">,</span> pmt<span class="token punctuation">:</span> bal<span class="token operator">*</span><span class="token number">1.05</span><span class="token operator">+</span> pmt<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">960.0</span><span class="token punctuation">,</span><span class="token number">918.0</span><span class="token punctuation">,</span><span class="token number">873.9000000000001</span><span class="token punctuation">,</span><span class="token number">827.5950000000001</span><span class="token punctuation">]</span>
<span class="token comment" spellcheck="true"># Chaotic recurrence relation https://en.wikipedia.org/wiki/Logistic_map</span>
<span class="token operator">>></span><span class="token operator">></span> logistic_map <span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> _<span class="token punctuation">:</span>  r <span class="token operator">*</span> x <span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span> x<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> r <span class="token operator">=</span><span class="token number">3.8</span>
<span class="token operator">>></span><span class="token operator">></span> x0 <span class="token operator">=</span><span class="token number">0.4</span>
<span class="token operator">>></span><span class="token operator">></span> inputs <span class="token operator">=</span> repeat<span class="token punctuation">(</span>x0<span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># only the initial value is used</span>
<span class="token operator">>></span><span class="token operator">></span><span class="token punctuation">[</span>format<span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token string">'.2f'</span><span class="token punctuation">)</span><span class="token keyword">for</span> x <span class="token keyword">in</span> accumulate<span class="token punctuation">(</span>inputs<span class="token punctuation">,</span> logistic_map<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">'0.40'</span><span class="token punctuation">,</span><span class="token string">'0.91'</span><span class="token punctuation">,</span><span class="token string">'0.30'</span><span class="token punctuation">,</span><span class="token string">'0.81'</span><span class="token punctuation">,</span><span class="token string">'0.60'</span><span class="token punctuation">,</span><span class="token string">'0.92'</span><span class="token punctuation">,</span><span class="token string">'0.29'</span><span class="token punctuation">,</span><span class="token string">'0.79'</span><span class="token punctuation">,</span><span class="token string">'0.63'</span><span class="token punctuation">,</span>
<span class="token string">'0.88'</span><span class="token punctuation">,</span><span class="token string">'0.39'</span><span class="token punctuation">,</span><span class="token string">'0.90'</span><span class="token punctuation">,</span><span class="token string">'0.33'</span><span class="token punctuation">,</span><span class="token string">'0.84'</span><span class="token punctuation">,</span><span class="token string">'0.52'</span><span class="token punctuation">,</span><span class="token string">'0.95'</span><span class="token punctuation">,</span><span class="token string">'0.18'</span><span class="token punctuation">,</span><span class="token string">'0.57'</span><span class="token punctuation">,</span>
<span class="token string">'0.93'</span><span class="token punctuation">,</span><span class="token string">'0.25'</span><span class="token punctuation">,</span><span class="token string">'0.71'</span><span class="token punctuation">,</span><span class="token string">'0.79'</span><span class="token punctuation">,</span><span class="token string">'0.63'</span><span class="token punctuation">,</span><span class="token string">'0.88'</span><span class="token punctuation">,</span><span class="token string">'0.39'</span><span class="token punctuation">,</span><span class="token string">'0.91'</span><span class="token punctuation">,</span><span class="token string">'0.32'</span><span class="token punctuation">,</span>
<span class="token string">'0.83'</span><span class="token punctuation">,</span><span class="token string">'0.54'</span><span class="token punctuation">,</span><span class="token string">'0.95'</span><span class="token punctuation">,</span><span class="token string">'0.20'</span><span class="token punctuation">,</span><span class="token string">'0.60'</span><span class="token punctuation">,</span><span class="token string">'0.91'</span><span class="token punctuation">,</span><span class="token string">'0.30'</span><span class="token punctuation">,</span><span class="token string">'0.80'</span><span class="token punctuation">,</span><span class="token string">'0.60'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参考一个类似函数 <code>functools.reduce()</code> ，它只返回一个最终累积值。</p>
<p>3.2 新版功能.</p>
<p>在 3.3 版更改: 增加可选参数 <em>func</em> 。</p>
<p>在 3.8 版更改: 添加了可选的 <em>initial</em> 形参。</p>
<p><code>itertools.chain</code>(<em>\</em>iterables*)</p>
<p>创建一个迭代器，它首先返回第一个可迭代对象中所有元素，接着返回下一个可迭代对象中所有元素，直到耗尽所有可迭代对象中的元素。可将多个序列处理为单个序列。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">chain</span><span class="token punctuation">(</span><span class="token operator">*</span>iterables<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># chain('ABC', 'DEF') --> A B C D E F</span>
<span class="token keyword">for</span> it <span class="token keyword">in</span> iterables<span class="token punctuation">:</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> it<span class="token punctuation">:</span>
<span class="token keyword">yield</span> element<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>classmethod<em><code>chain.from_iterable</code>(</em>iterable</em>)</p>
<p>构建类似 <code>chain()</code> 迭代器的另一个选择。从一个单独的可迭代参数中得到链式输入，该参数是延迟计算的。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">from_iterable</span><span class="token punctuation">(</span>iterables<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># chain.from_iterable(['ABC', 'DEF']) --> A B C D E F</span>
<span class="token keyword">for</span> it <span class="token keyword">in</span> iterables<span class="token punctuation">:</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> it<span class="token punctuation">:</span>
<span class="token keyword">yield</span> element<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.combinations</code>(<em>iterable</em>, <em>r</em>)</p>
<p>返回由输入 <em>iterable</em> 中元素组成长度为 <em>r</em> 的子序列。</p>
<p>组合元组会以字典顺序根据所输入 <em>iterable</em> 的顺序发出。 因此，如果所输入 <em>iterable</em> 是已排序的，组合元组也将按已排序的顺序生成。</p>
<p>即使元素的值相同，不同位置的元素也被认为是不同的。如果元素各自不同，那么每个组合中没有重复元素。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">combinations</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># combinations('ABCD', 2) --> AB AC AD BC BD CD</span>
<span class="token comment" spellcheck="true"># combinations(range(4), 3) --> 012 013 023 123</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
<span class="token keyword">if</span> r <span class="token operator">></span> n<span class="token punctuation">:</span>
<span class="token keyword">return</span>
    indices <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span>
whileTrue<span class="token punctuation">:</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> reversed<span class="token punctuation">(</span>range<span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span> i <span class="token operator">+</span> n <span class="token operator">-</span> r<span class="token punctuation">:</span>
<span class="token keyword">break</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span>
        indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>
<span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
            indices<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span> indices<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>combinations()</code> 的代码可被改写为 <code>permutations()</code> 过滤后的子序列，（相对于元素在输入中的位置）元素不是有序的。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">combinations</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
<span class="token keyword">for</span> indices <span class="token keyword">in</span> permutations<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> sorted<span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token operator">==</span> list<span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 <code>0 &lt;= r &lt;= n</code> 时，返回项的个数是 <code>n! / r! / (n-r)!</code>；当 <code>r &gt; n</code> 时，返回项个数为0。</p>
<p><code>itertools.combinations_with_replacement</code>(<em>iterable</em>, <em>r</em>)</p>
<p>返回由输入 <em>iterable</em> 中元素组成的长度为 <em>r</em> 的子序列，允许每个元素可重复出现。</p>
<p>组合元组会以字典顺序根据所输入 <em>iterable</em> 的顺序发出。 因此，如果所输入 <em>iterable</em> 是已排序的，组合元组也将按已排序的顺序生成。</p>
<p>不同位置的元素是不同的，即使它们的值相同。因此如果输入中的元素都是不同的话，返回的组合中元素也都会不同。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">combinations_with_replacement</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
ifnot n <span class="token operator">and</span> r<span class="token punctuation">:</span>
<span class="token keyword">return</span>
    indices <span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span> r
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span>
whileTrue<span class="token punctuation">:</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> reversed<span class="token punctuation">(</span>range<span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span> n <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
<span class="token keyword">break</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span>
        indices<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span>indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>r <span class="token operator">-</span> i<span class="token punctuation">)</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>combinations_with_replacement()</code> 的代码可被改写为 <code>production()</code> 过滤后的子序列，（相对于元素在输入中的位置）元素不是有序的。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">combinations_with_replacement</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
<span class="token keyword">for</span> indices <span class="token keyword">in</span> product<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> repeat<span class="token operator">=</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> sorted<span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token operator">==</span> list<span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 <code>n &gt; 0</code> 时，返回项个数为 <code>(n+r-1)! / r! / (n-1)!</code>.</p>
<p>3.1 新版功能.</p>
<p><code>itertools.compress</code>(<em>data</em>, <em>selectors</em>)</p>
<p>创建一个迭代器，它返回 <em>data</em> 中经 <em>selectors</em> 真值测试为 <code>True</code> 的元素。迭代器在两者较短的长度处停止。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">compress</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> selectors<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># compress('ABCDEF', [1,0,1,0,1,1]) --> A C E F</span>
<span class="token keyword">return</span><span class="token punctuation">(</span>d <span class="token keyword">for</span> d<span class="token punctuation">,</span> s <span class="token keyword">in</span> zip<span class="token punctuation">(</span>data<span class="token punctuation">,</span> selectors<span class="token punctuation">)</span><span class="token keyword">if</span> s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3.1 新版功能.</p>
<p><code>itertools.count</code>(<em>start=0</em>, <em>step=1</em>)</p>
<p>创建一个迭代器，它从 <em>start</em> 值开始，返回均匀间隔的值。常用于 <code>map()</code> 中的实参来生成连续的数据点。此外，还用于 <code>zip()</code> 来添加序列号。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">count</span><span class="token punctuation">(</span>start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> step<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># count(10) --> 10 11 12 13 14 ...</span>
<span class="token comment" spellcheck="true"># count(2.5, 0.5) -> 2.5 3.0 3.5 ...</span>
    n <span class="token operator">=</span> start
whileTrue<span class="token punctuation">:</span>
<span class="token keyword">yield</span> n
        n <span class="token operator">+=</span> step<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当对浮点数计数时，替换为乘法代码有时精度会更好，例如： <code>(start + step * i for i in count())</code> 。</p>
<p>在 3.1 版更改: 增加参数 <em>step</em> ，允许非整型。</p>
<p><code>itertools.cycle</code>(<em>iterable</em>)</p>
<p>创建一个迭代器，返回 <em>iterable</em> 中所有元素并保存一个副本。当取完 <em>iterable</em> 中所有元素，返回副本中的所有元素。无限重复。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">cycle</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># cycle('ABCD') --> A B C D A B C D A B C D ...</span>
    saved <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
<span class="token keyword">yield</span> element
        saved<span class="token punctuation">.</span>append<span class="token punctuation">(</span>element<span class="token punctuation">)</span>
<span class="token keyword">while</span> saved<span class="token punctuation">:</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> saved<span class="token punctuation">:</span>
<span class="token keyword">yield</span> element<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，该函数可能需要相当大的辅助空间（取决于 <em>iterable</em> 的长度）。</p>
<p><code>itertools.dropwhile</code>(<em>predicate</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，如果 <em>predicate</em> 为true，迭代器丢弃这些元素，然后返回其他元素。注意，迭代器在 <em>predicate</em> 首次为false之前不会产生任何输出，所以可能需要一定长度的启动时间。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">dropwhile</span><span class="token punctuation">(</span>predicate<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) --> 6 4 1</span>
    iterable <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
ifnot predicate<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> x
<span class="token keyword">break</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
<span class="token keyword">yield</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.filterfalse</code>(<em>predicate</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，只返回 <em>iterable</em> 中 <em>predicate</em> 为 <code>False</code> 的元素。如果 <em>predicate</em> 是 <code>None</code>，返回真值测试为false的元素。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">filterfalse</span><span class="token punctuation">(</span>predicate<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># filterfalse(lambda x: x%2, range(10)) --> 0 2 4 6 8</span>
<span class="token keyword">if</span> predicate isNone<span class="token punctuation">:</span>
        predicate <span class="token operator">=</span>bool
<span class="token keyword">for</span> x <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
ifnot predicate<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.groupby</code>(<em>iterable</em>, <em>key=None</em>)</p>
<p>创建一个迭代器，返回 <em>iterable</em> 中连续的键和组。<em>key</em> 是一个计算元素键值函数。如果未指定或为 <code>None</code>，<em>key</em> 缺省为恒等函数（identity function），返回元素不变。一般来说，<em>iterable</em> 需用同一个键值函数预先排序。</p>
<p><code>groupby()</code> 操作类似于Unix中的 <code>uniq</code>。当每次 <em>key</em> 函数产生的键值改变时，迭代器会分组或生成一个新组（这就是为什么通常需要使用同一个键值函数先对数据进行排序）。这种行为与SQL的GROUP BY操作不同，SQL的操作会忽略输入的顺序将相同键值的元素分在同组中。</p>
<p>返回的组本身也是一个迭代器，它与 <code>groupby()</code> 共享底层的可迭代对象。因为源是共享的，当 <code>groupby()</code> 对象向后迭代时，前一个组将消失。因此如果稍后还需要返回结果，可保存为列表：</p>
<pre class="line-numbers language-python"><code class="language-python">groups <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
uniquekeys <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
data <span class="token operator">=</span> sorted<span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token operator">=</span>keyfunc<span class="token punctuation">)</span>
<span class="token keyword">for</span> k<span class="token punctuation">,</span> g <span class="token keyword">in</span> groupby<span class="token punctuation">(</span>data<span class="token punctuation">,</span> keyfunc<span class="token punctuation">)</span><span class="token punctuation">:</span>
    groups<span class="token punctuation">.</span>append<span class="token punctuation">(</span>list<span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Store group iterator as a list</span>
    uniquekeys<span class="token punctuation">.</span>append<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>groupby()</code> 大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">groupby</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># [k for k, g in groupby('AAAABBBCCDAABBB')] --> A B C D A B</span>
<span class="token comment" spellcheck="true"># [list(g) for k, g in groupby('AAAABBBCCD')] --> AAAA BBB CC D</span>
<span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> iterable<span class="token punctuation">,</span> key<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> key isNone<span class="token punctuation">:</span>
            key <span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x
self<span class="token punctuation">.</span>keyfunc <span class="token operator">=</span> key
self<span class="token punctuation">.</span>it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
self<span class="token punctuation">.</span>tgtkey <span class="token operator">=</span>self<span class="token punctuation">.</span>currkey <span class="token operator">=</span>self<span class="token punctuation">.</span>currvalue <span class="token operator">=</span>object<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
returnself
<span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
self<span class="token punctuation">.</span>id <span class="token operator">=</span>object<span class="token punctuation">(</span><span class="token punctuation">)</span>
whileself<span class="token punctuation">.</span>currkey <span class="token operator">==</span>self<span class="token punctuation">.</span>tgtkey<span class="token punctuation">:</span>
self<span class="token punctuation">.</span>currvalue <span class="token operator">=</span>next<span class="token punctuation">(</span>self<span class="token punctuation">.</span>it<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Exit on StopIteration</span>
self<span class="token punctuation">.</span>currkey <span class="token operator">=</span>self<span class="token punctuation">.</span>keyfunc<span class="token punctuation">(</span>self<span class="token punctuation">.</span>currvalue<span class="token punctuation">)</span>
self<span class="token punctuation">.</span>tgtkey <span class="token operator">=</span>self<span class="token punctuation">.</span>currkey
<span class="token keyword">return</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>currkey<span class="token punctuation">,</span>self<span class="token punctuation">.</span>_grouper<span class="token punctuation">(</span>self<span class="token punctuation">.</span>tgtkey<span class="token punctuation">,</span>self<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">_grouper</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> tgtkey<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">:</span>
whileself<span class="token punctuation">.</span>id <span class="token keyword">is</span> id andself<span class="token punctuation">.</span>currkey <span class="token operator">==</span> tgtkey<span class="token punctuation">:</span>
yieldself<span class="token punctuation">.</span>currvalue
<span class="token keyword">try</span><span class="token punctuation">:</span>
self<span class="token punctuation">.</span>currvalue <span class="token operator">=</span>next<span class="token punctuation">(</span>self<span class="token punctuation">.</span>it<span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token keyword">return</span>
self<span class="token punctuation">.</span>currkey <span class="token operator">=</span>self<span class="token punctuation">.</span>keyfunc<span class="token punctuation">(</span>self<span class="token punctuation">.</span>currvalue<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.islice</code>(<em>iterable</em>, <em>stop</em>)</p>
<p><code>itertools.islice</code>(<em>iterable</em>, <em>start</em>, <em>stop</em>[, <em>step</em>])</p>
<p>创建一个迭代器，返回从 <em>iterable</em> 里选中的元素。如果 <em>start</em> 不是0，跳过 <em>iterable</em> 中的元素，直到到达 <em>start</em> 这个位置。之后迭代器连续返回元素，除非 <em>step</em> 设置的值很高导致被跳过。如果 <em>stop</em> 为 <code>None</code>，迭代器耗光为止；否则，在指定的位置停止。与普通的切片不同，<code>islice()</code> 不支持将 <em>start</em> ， <em>stop</em> ，或 <em>step</em> 设为负值。可用来从内部数据结构被压平的数据中提取相关字段（例如一个多行报告，它的名称字段出现在每三行上）。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">islice</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># islice('ABCDEFG', 2) --> A B</span>
<span class="token comment" spellcheck="true"># islice('ABCDEFG', 2, 4) --> C D</span>
<span class="token comment" spellcheck="true"># islice('ABCDEFG', 2, None) --> C D E F G</span>
<span class="token comment" spellcheck="true"># islice('ABCDEFG', 0, None, 2) --> A C E G</span>
    s <span class="token operator">=</span> slice<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span>
    start<span class="token punctuation">,</span> stop<span class="token punctuation">,</span> step <span class="token operator">=</span> s<span class="token punctuation">.</span>start or0<span class="token punctuation">,</span> s<span class="token punctuation">.</span>stop <span class="token operator">or</span> sys<span class="token punctuation">.</span>maxsize<span class="token punctuation">,</span> s<span class="token punctuation">.</span>step or1
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>range<span class="token punctuation">(</span>start<span class="token punctuation">,</span> stop<span class="token punctuation">,</span> step<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
        nexti <span class="token operator">=</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Consume *iterable* up to the *start* position.</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> element <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">pass</span>
<span class="token keyword">return</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> element <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> i <span class="token operator">==</span> nexti<span class="token punctuation">:</span>
<span class="token keyword">yield</span> element
                nexti <span class="token operator">=</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Consume to *stop*.</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> element <span class="token keyword">in</span> zip<span class="token punctuation">(</span>range<span class="token punctuation">(</span>i <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> stop<span class="token punctuation">)</span><span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>start</em> 为 <code>None</code>，迭代从0开始。如果 <em>step</em> 为 <code>None</code> ，步长缺省为1。</p>
<p><code>itertools.pairwise</code>(<em>iterable</em>)</p>
<p>返回从输入 <em>iterable</em> 中获取的连续重叠对。</p>
<p>输出迭代器中 2 元组的数量将比输入的数量少一个。 如果输入可迭代对象中少于两个值则它将为空。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">pairwise</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># pairwise('ABCDEFG') --> AB BC CD DE EF FG</span>
    a<span class="token punctuation">,</span> b <span class="token operator">=</span> tee<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
next<span class="token punctuation">(</span>b<span class="token punctuation">,</span>None<span class="token punctuation">)</span>
<span class="token keyword">return</span> zip<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.10 新版功能.</p>
<p><code>itertools.permutations</code>(<em>iterable</em>, <em>r=None</em>)</p>
<p>连续返回由 <em>iterable</em> 元素生成长度为 <em>r</em> 的排列。</p>
<p>如果 <em>r</em> 未指定或为 <code>None</code> ，<em>r</em> 默认设置为 <em>iterable</em> 的长度，这种情况下，生成所有全长排列。</p>
<p>排列元组会以字典顺序根据所输入 <em>iterable</em> 的顺序发出。 因此，如果所输入 <em>iterable</em> 是已排序的，组合元组也将按已排序的顺序生成。</p>
<p>即使元素的值相同，不同位置的元素也被认为是不同的。如果元素值都不同，每个排列中的元素值不会重复。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">permutations</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC</span>
<span class="token comment" spellcheck="true"># permutations(range(3)) --> 012 021 102 120 201 210</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
    r <span class="token operator">=</span> n <span class="token keyword">if</span> r isNoneelse r
<span class="token keyword">if</span> r <span class="token operator">></span> n<span class="token punctuation">:</span>
<span class="token keyword">return</span>
    indices <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
    cycles <span class="token operator">=</span> list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">,</span> n<span class="token operator">-</span>r<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">[</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> n<span class="token punctuation">:</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> reversed<span class="token punctuation">(</span>range<span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            cycles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>
<span class="token keyword">if</span> cycles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">:</span>
                indices<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">=</span> indices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">+</span> indices<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span>
                cycles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span> n <span class="token operator">-</span> i
<span class="token keyword">else</span><span class="token punctuation">:</span>
                j <span class="token operator">=</span> cycles<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> indices<span class="token punctuation">[</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token operator">=</span> indices<span class="token punctuation">[</span><span class="token operator">-</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">[</span><span class="token punctuation">:</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">break</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">return</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>permutations()</code> 的代码也可被改写为 <code>product()</code> 的子序列，只要将含有重复元素（来自输入中同一位置的）的项排除。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">permutations</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
    r <span class="token operator">=</span> n <span class="token keyword">if</span> r isNoneelse r
<span class="token keyword">for</span> indices <span class="token keyword">in</span> product<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> repeat<span class="token operator">=</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> len<span class="token punctuation">(</span>set<span class="token punctuation">(</span>indices<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span> r<span class="token punctuation">:</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 <code>0 &lt;= r &lt;= n</code> ，返回项个数为 <code>n! / (n-r)!</code> ；当 <code>r &gt; n</code> ，返回项个数为0。</p>
<p><code>itertools.product</code>(<em>\</em>iterables<em>,</em> repeat=1*)</p>
<p>可迭代对象输入的笛卡儿积。</p>
<p>大致相当于生成器表达式中的嵌套循环。例如， <code>product(A, B)</code> 和 <code>((x,y) for x in A for y in B)</code> 返回结果一样。</p>
<p>嵌套循环像里程表那样循环变动，每次迭代时将最右侧的元素向后迭代。这种模式形成了一种字典序，因此如果输入的可迭代对象是已排序的，笛卡尔积元组依次序发出。</p>
<p>要计算可迭代对象自身的笛卡尔积，将可选参数 <em>repeat</em> 设定为要重复的次数。例如，<code>product(A, repeat=4)</code> 和 <code>product(A, A, A, A)</code> 是一样的。</p>
<p>该函数大致相当于下面的代码，只不过实际实现方案不会在内存中创建中间结果。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">product</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> repeat<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy</span>
<span class="token comment" spellcheck="true"># product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111</span>
    pools <span class="token operator">=</span><span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token keyword">for</span> pool <span class="token keyword">in</span> args<span class="token punctuation">]</span><span class="token operator">*</span> repeat
    result <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> pool <span class="token keyword">in</span> pools<span class="token punctuation">:</span>
        result <span class="token operator">=</span><span class="token punctuation">[</span>x<span class="token operator">+</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token keyword">for</span> x <span class="token keyword">in</span> result <span class="token keyword">for</span> y <span class="token keyword">in</span> pool<span class="token punctuation">]</span>
<span class="token keyword">for</span> prod <span class="token keyword">in</span> result<span class="token punctuation">:</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>prod<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>product()</code> 运行之前，它会完全耗尽输入的可迭代对象，在内存中保留值的临时池以生成结果积。 相应地，它只适用于有限的输入。</p>
<p><code>itertools.repeat</code>(<em>object</em>[, <em>times</em>])</p>
<p>创建一个迭代器，不断重复 <em>object</em> 。除非设定参数 <em>times</em> ，否则将无限重复。可用于 <code>map()</code> 函数中的参数，被调用函数可得到一个不变参数。也可用于 <code>zip()</code> 的参数以在元组记录中创建一个不变的部分。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">repeat</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> times<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># repeat(10, 3) --> 10 10 10</span>
<span class="token keyword">if</span> times isNone<span class="token punctuation">:</span>
whileTrue<span class="token punctuation">:</span>
yieldobject
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>times<span class="token punctuation">)</span><span class="token punctuation">:</span>
yieldobject<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>repeat</em> 最常见的用途就是在 <em>map</em> 或 <em>zip</em> 提供一个常量流：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>pow<span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> repeat<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">49</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">,</span><span class="token number">81</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>itertools.starmap</code>(<em>function</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，使用从可迭代对象中获取的参数来计算该函数。当参数对应的形参已从一个单独可迭代对象组合为元组时（数据已被“预组对”）可用此函数代替 <code>map()</code>。<code>map()</code> 与 <code>starmap()</code> 之间的区别可以类比 <code>function(a,b)</code> 与 <code>function(*c)</code> 的区别。大致相当于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">starmap</span><span class="token punctuation">(</span>function<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000</span>
<span class="token keyword">for</span> args <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
yieldfunction<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.takewhile</code>(<em>predicate</em>, <em>iterable</em>)</p>
<p>创建一个迭代器，只要 predicate 为真就从可迭代对象中返回元素。大致相当于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">takewhile</span><span class="token punctuation">(</span>predicate<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># takewhile(lambda x: x&lt;5, [1,4,6,4,1]) --> 1 4</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
<span class="token keyword">if</span> predicate<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> x
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">break</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>itertools.tee</code>(<em>iterable</em>, <em>n=2</em>)</p>
<p>从一个可迭代对象中返回 <em>n</em> 个独立的迭代器。</p>
<p>下面的Python代码能帮助解释 <em>tee</em> 做了什么（尽管实际的实现更复杂，而且仅使用了一个底层的 FIFO 队列）。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">tee</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    deques <span class="token operator">=</span><span class="token punctuation">[</span>collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">gen</span><span class="token punctuation">(</span>mydeque<span class="token punctuation">)</span><span class="token punctuation">:</span>
whileTrue<span class="token punctuation">:</span>
ifnot mydeque<span class="token punctuation">:</span><span class="token comment" spellcheck="true"># when the local deque is empty</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
                    newval <span class="token operator">=</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># fetch a new value and</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token keyword">return</span>
<span class="token keyword">for</span> d <span class="token keyword">in</span> deques<span class="token punctuation">:</span><span class="token comment" spellcheck="true"># load it to all the deques</span>
                    d<span class="token punctuation">.</span>append<span class="token punctuation">(</span>newval<span class="token punctuation">)</span>
<span class="token keyword">yield</span> mydeque<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>gen<span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token keyword">for</span> d <span class="token keyword">in</span> deques<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一旦 <code>tee()</code> 实施了一次分裂，原有的 <em>iterable</em> 不应再被使用；否则tee对象无法得知 <em>iterable</em> 可能已向后迭代。</p>
<p><code>tee</code> 迭代器不是线程安全的。当同时使用由同一个 <code>tee()</code> 调用所返回的迭代器时可能引发 <code>RuntimeError</code>，即使原本的 <em>iterable</em> 是线程安全的。</p>
<p>该迭代工具可能需要相当大的辅助存储空间（这取决于要保存多少临时数据）。通常，如果一个迭代器在另一个迭代器开始之前就要使用大部份或全部数据，使用 <code>list()</code> 会比 <code>tee()</code> 更快。</p>
<p><code>itertools.zip_longest</code>(<em>\</em>iterables<em>,</em> fillvalue=None*)</p>
<p>创建一个迭代器，从每个可迭代对象中收集元素。如果可迭代对象的长度未对齐，将根据 <em>fillvalue</em> 填充缺失值。迭代持续到耗光最长的可迭代对象。大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">zip_longest</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> fillvalue<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># zip_longest('ABCD', 'xy', fillvalue='-') --> Ax By C- D-</span>
    iterators <span class="token operator">=</span><span class="token punctuation">[</span>iter<span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token keyword">for</span> it <span class="token keyword">in</span> args<span class="token punctuation">]</span>
    num_active <span class="token operator">=</span> len<span class="token punctuation">(</span>iterators<span class="token punctuation">)</span>
ifnot num_active<span class="token punctuation">:</span>
<span class="token keyword">return</span>
whileTrue<span class="token punctuation">:</span>
        values <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> it <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>iterators<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
                value <span class="token operator">=</span>next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
                num_active <span class="token operator">-=</span><span class="token number">1</span>
ifnot num_active<span class="token punctuation">:</span>
<span class="token keyword">return</span>
                iterators<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span> repeat<span class="token punctuation">(</span>fillvalue<span class="token punctuation">)</span>
                value <span class="token operator">=</span> fillvalue
            values<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>values<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果其中一个可迭代对象有无限长度，<code>zip_longest()</code> 函数应封装在限制调用次数的场景中（例如 <code>islice()</code> 或 <code>takewhile()</code>）。除非指定， <em>fillvalue</em> 默认为 <code>None</code> 。</p>
<h3 id="itertools-配方"><a href="#itertools-配方" class="headerlink" title="itertools 配方"></a>itertools 配方</h3><p>本节将展示如何使用现有的 itertools 作为基础构件来创建扩展的工具集。</p>
<p>基本上所有这些西方和许许多多其他的配方都可以通过 Python Package Index 上的 more-itertools 项目 来安装:</p>
<pre><code>pip install more-itertools</code></pre><p>扩展的工具提供了与底层工具集相同的高性能。保持了超棒的内存利用率，因为一次只处理一个元素，而不是将整个可迭代对象加载到内存。代码量保持得很小，以函数式风格将这些工具连接在一起，有助于消除临时变量。速度依然很快，因为倾向于使用“矢量化”构件来取代解释器开销大的 for 循环和 generator 。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">take</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Return first n items of the iterable as a list"</span>
<span class="token keyword">return</span> list<span class="token punctuation">(</span>islice<span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">prepend</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> iterator<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Prepend a single value in front of an iterator"</span>
<span class="token comment" spellcheck="true"># prepend(1, [2, 3, 4]) -> 1 2 3 4</span>
<span class="token keyword">return</span> chain<span class="token punctuation">(</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">,</span> iterator<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">tabulate</span><span class="token punctuation">(</span>function<span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Return function(0), function(1), ..."</span>
<span class="token keyword">return</span> map<span class="token punctuation">(</span>function<span class="token punctuation">,</span> count<span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">tail</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Return an iterator over the last n items"</span>
<span class="token comment" spellcheck="true"># tail(3, 'ABCDEFG') --> E F G</span>
<span class="token keyword">return</span> iter<span class="token punctuation">(</span>collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> maxlen<span class="token operator">=</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">consume</span><span class="token punctuation">(</span>iterator<span class="token punctuation">,</span> n<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Advance the iterator n-steps ahead. If n is None, consume entirely."</span>
<span class="token comment" spellcheck="true"># Use functions that consume iterators at C speed.</span>
<span class="token keyword">if</span> n isNone<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># feed the entire iterator into a zero-length deque</span>
        collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span>iterator<span class="token punctuation">,</span> maxlen<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># advance to the empty slice starting at position n</span>
next<span class="token punctuation">(</span>islice<span class="token punctuation">(</span>iterator<span class="token punctuation">,</span> n<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span>None<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">nth</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">,</span>default<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Returns the nth item or a default value"</span>
returnnext<span class="token punctuation">(</span>islice<span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">,</span>None<span class="token punctuation">)</span><span class="token punctuation">,</span>default<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">all_equal</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Returns True if all the elements are equal to each other"</span>
    g <span class="token operator">=</span> groupby<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
returnnext<span class="token punctuation">(</span>g<span class="token punctuation">,</span><span class="token boolean">True</span><span class="token punctuation">)</span>andnotnext<span class="token punctuation">(</span>g<span class="token punctuation">,</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">quantify</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> pred<span class="token operator">=</span>bool<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Count how many times the predicate is true"</span>
<span class="token keyword">return</span> sum<span class="token punctuation">(</span>map<span class="token punctuation">(</span>pred<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">pad_none</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""Returns the sequence elements and then returns None indefinitely.
    Useful for emulating the behavior of the built-in map() function.
    """</span>
<span class="token keyword">return</span> chain<span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> repeat<span class="token punctuation">(</span>None<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">ncycles</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Returns the sequence elements n times"</span>
<span class="token keyword">return</span> chain<span class="token punctuation">.</span>from_iterable<span class="token punctuation">(</span>repeat<span class="token punctuation">(</span>tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">dotproduct</span><span class="token punctuation">(</span>vec1<span class="token punctuation">,</span> vec2<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">return</span> sum<span class="token punctuation">(</span>map<span class="token punctuation">(</span>operator<span class="token punctuation">.</span>mul<span class="token punctuation">,</span> vec1<span class="token punctuation">,</span> vec2<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">convolve</span><span class="token punctuation">(</span>signal<span class="token punctuation">,</span> kernel<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># See:  https://betterexplained.com/articles/intuitive-convolution/</span>
<span class="token comment" spellcheck="true"># convolve(data, [0.25, 0.25, 0.25, 0.25]) --> Moving average (blur)</span>
<span class="token comment" spellcheck="true"># convolve(data, [1, -1]) --> 1st finite difference (1st derivative)</span>
<span class="token comment" spellcheck="true"># convolve(data, [1, -2, 1]) --> 2nd finite difference (2nd derivative)</span>
    kernel <span class="token operator">=</span> tuple<span class="token punctuation">(</span>kernel<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>kernel<span class="token punctuation">)</span>
    window <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> maxlen<span class="token operator">=</span>n<span class="token punctuation">)</span><span class="token operator">*</span> n
<span class="token keyword">for</span> x <span class="token keyword">in</span> chain<span class="token punctuation">(</span>signal<span class="token punctuation">,</span> repeat<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        window<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token keyword">yield</span> sum<span class="token punctuation">(</span>map<span class="token punctuation">(</span>operator<span class="token punctuation">.</span>mul<span class="token punctuation">,</span> kernel<span class="token punctuation">,</span> window<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">flatten</span><span class="token punctuation">(</span>list_of_lists<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Flatten one level of nesting"</span>
<span class="token keyword">return</span> chain<span class="token punctuation">.</span>from_iterable<span class="token punctuation">(</span>list_of_lists<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">repeatfunc</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> times<span class="token operator">=</span>None<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""Repeat calls to func with specified arguments.
    Example:  repeatfunc(random.random)
    """</span>
<span class="token keyword">if</span> times isNone<span class="token punctuation">:</span>
<span class="token keyword">return</span> starmap<span class="token punctuation">(</span>func<span class="token punctuation">,</span> repeat<span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> starmap<span class="token punctuation">(</span>func<span class="token punctuation">,</span> repeat<span class="token punctuation">(</span>args<span class="token punctuation">,</span> times<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">grouper</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">,</span> fillvalue<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Collect data into non-overlapping fixed-length chunks or blocks"</span>
<span class="token comment" spellcheck="true"># grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx</span>
    args <span class="token operator">=</span><span class="token punctuation">[</span>iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">*</span> n
<span class="token keyword">return</span> zip_longest<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> fillvalue<span class="token operator">=</span>fillvalue<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">triplewise</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Return overlapping triplets from an iterable"</span>
<span class="token comment" spellcheck="true"># triplewise('ABCDEFG') -> ABC BCD CDE DEF EFG</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token keyword">in</span> pairwise<span class="token punctuation">(</span>pairwise<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c
<span class="token keyword">def</span> <span class="token function">sliding_window</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># sliding_window('ABCDEFG', 4) -> ABCD BCDE CDEF DEFG</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    window <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span>islice<span class="token punctuation">(</span>it<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span> maxlen<span class="token operator">=</span>n<span class="token punctuation">)</span>
<span class="token keyword">if</span> len<span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token operator">==</span> n<span class="token punctuation">:</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>window<span class="token punctuation">)</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> it<span class="token punctuation">:</span>
        window<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token keyword">yield</span> tuple<span class="token punctuation">(</span>window<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">roundrobin</span><span class="token punctuation">(</span><span class="token operator">*</span>iterables<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"roundrobin('ABC', 'D', 'EF') --> A D E B F C"</span>
<span class="token comment" spellcheck="true"># Recipe credited to George Sakkis</span>
    num_active <span class="token operator">=</span> len<span class="token punctuation">(</span>iterables<span class="token punctuation">)</span>
    nexts <span class="token operator">=</span> cycle<span class="token punctuation">(</span>iter<span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">.</span>__next__ <span class="token keyword">for</span> it <span class="token keyword">in</span> iterables<span class="token punctuation">)</span>
<span class="token keyword">while</span> num_active<span class="token punctuation">:</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
fornextin nexts<span class="token punctuation">:</span>
yieldnext<span class="token punctuation">(</span><span class="token punctuation">)</span>
exceptStopIteration<span class="token punctuation">:</span>
<span class="token comment" spellcheck="true"># Remove the iterator we just exhausted from the cycle.</span>
            num_active <span class="token operator">-=</span><span class="token number">1</span>
            nexts <span class="token operator">=</span> cycle<span class="token punctuation">(</span>islice<span class="token punctuation">(</span>nexts<span class="token punctuation">,</span> num_active<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Use a predicate to partition entries into false entries and true entries"</span>
<span class="token comment" spellcheck="true"># partition(is_odd, range(10)) --> 0 2 4 6 8   and  1 3 5 7 9</span>
    t1<span class="token punctuation">,</span> t2 <span class="token operator">=</span> tee<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
<span class="token keyword">return</span> filterfalse<span class="token punctuation">(</span>pred<span class="token punctuation">,</span> t1<span class="token punctuation">)</span><span class="token punctuation">,</span> filter<span class="token punctuation">(</span>pred<span class="token punctuation">,</span> t2<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">before_and_after</span><span class="token punctuation">(</span>predicate<span class="token punctuation">,</span> it<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">""" Variant of takewhile() that allows complete
        access to the remainder of the iterator.
        >>> it = iter('ABCdEfGhI')
        >>> all_upper, remainder = before_and_after(str.isupper, it)
        >>> ''.join(all_upper)
        'ABC'
        >>> ''.join(remainder)     # takewhile() would lose the 'd'
        'dEfGhI'
        Note that the first iterator must be fully
        consumed before the second iterator can
        generate valid results.
    """</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    transition <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">def</span> <span class="token function">true_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">for</span> elem <span class="token keyword">in</span> it<span class="token punctuation">:</span>
<span class="token keyword">if</span> predicate<span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token keyword">yield</span> elem
<span class="token keyword">else</span><span class="token punctuation">:</span>
                transition<span class="token punctuation">.</span>append<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>
<span class="token keyword">return</span>
<span class="token keyword">def</span> <span class="token function">remainder_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
yieldfrom transition
yieldfrom it
<span class="token keyword">return</span> true_iterator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> remainder_iterator<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">powerset</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)"</span>
    s <span class="token operator">=</span> list<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
<span class="token keyword">return</span> chain<span class="token punctuation">.</span>from_iterable<span class="token punctuation">(</span>combinations<span class="token punctuation">(</span>s<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token keyword">for</span> r <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">unique_everseen</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> key<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"List unique elements, preserving order. Remember all elements ever seen."</span>
<span class="token comment" spellcheck="true"># unique_everseen('AAAABBBCCDAABBB') --> A B C D</span>
<span class="token comment" spellcheck="true"># unique_everseen('ABBCcAD', str.lower) --> A B C D</span>
    seen <span class="token operator">=</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>
    seen_add <span class="token operator">=</span> seen<span class="token punctuation">.</span>add
<span class="token keyword">if</span> key isNone<span class="token punctuation">:</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> filterfalse<span class="token punctuation">(</span>seen<span class="token punctuation">.</span>__contains__<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>
            seen_add<span class="token punctuation">(</span>element<span class="token punctuation">)</span>
<span class="token keyword">yield</span> element
<span class="token keyword">else</span><span class="token punctuation">:</span>
<span class="token keyword">for</span> element <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>
            k <span class="token operator">=</span> key<span class="token punctuation">(</span>element<span class="token punctuation">)</span>
<span class="token keyword">if</span> k notin seen<span class="token punctuation">:</span>
                seen_add<span class="token punctuation">(</span>k<span class="token punctuation">)</span>
<span class="token keyword">yield</span> element
<span class="token keyword">def</span> <span class="token function">unique_justseen</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> key<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"List unique elements, preserving order. Remember only the element just seen."</span>
<span class="token comment" spellcheck="true"># unique_justseen('AAAABBBCCDAABBB') --> A B C D A B</span>
<span class="token comment" spellcheck="true"># unique_justseen('ABBCcAD', str.lower) --> A B C A D</span>
<span class="token keyword">return</span> map<span class="token punctuation">(</span>next<span class="token punctuation">,</span> map<span class="token punctuation">(</span>operator<span class="token punctuation">.</span>itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> groupby<span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">iter_except</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> exception<span class="token punctuation">,</span> first<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">""" Call a function repeatedly until an exception is raised.
    Converts a call-until-exception interface to an iterator interface.
    Like builtins.iter(func, sentinel) but uses an exception instead
    of a sentinel to end the loop.
    Examples:
        iter_except(functools.partial(heappop, h), IndexError)   # priority queue iterator
        iter_except(d.popitem, KeyError)                         # non-blocking dict iterator
        iter_except(d.popleft, IndexError)                       # non-blocking deque iterator
        iter_except(q.get_nowait, Queue.Empty)                   # loop over a producer Queue
        iter_except(s.pop, KeyError)                             # non-blocking set iterator
    """</span>
<span class="token keyword">try</span><span class="token punctuation">:</span>
<span class="token keyword">if</span> first isnotNone<span class="token punctuation">:</span>
<span class="token keyword">yield</span> first<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># For database APIs needing an initial cast to db.first()</span>
whileTrue<span class="token punctuation">:</span>
<span class="token keyword">yield</span> func<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">except</span> exception<span class="token punctuation">:</span>
<span class="token keyword">pass</span>
<span class="token keyword">def</span> <span class="token function">first_true</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span>default<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> pred<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token triple-quoted-string string">"""Returns the first true value in the iterable.
    If no true value is found, returns *default*
    If *pred* is not None, returns the first item
    for which pred(item) is true.
    """</span>
<span class="token comment" spellcheck="true"># first_true([a,b,c], x) --> a or b or c or x</span>
<span class="token comment" spellcheck="true"># first_true([a,b], x, f) --> a if f(a) else b if f(b) else x</span>
returnnext<span class="token punctuation">(</span>filter<span class="token punctuation">(</span>pred<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span><span class="token punctuation">,</span>default<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">random_product</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> repeat<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Random selection from itertools.product(*args, **kwds)"</span>
    pools <span class="token operator">=</span><span class="token punctuation">[</span>tuple<span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token keyword">for</span> pool <span class="token keyword">in</span> args<span class="token punctuation">]</span><span class="token operator">*</span> repeat
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>map<span class="token punctuation">(</span>random<span class="token punctuation">.</span>choice<span class="token punctuation">,</span> pools<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">random_permutation</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Random selection from itertools.permutations(iterable, r)"</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    r <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token keyword">if</span> r isNoneelse r
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>pool<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">random_combination</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Random selection from itertools.combinations(iterable, r)"</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
    indices <span class="token operator">=</span> sorted<span class="token punctuation">(</span>random<span class="token punctuation">.</span>sample<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">random_combination_with_replacement</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Random selection from itertools.combinations_with_replacement(iterable, r)"</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
    indices <span class="token operator">=</span> sorted<span class="token punctuation">(</span>random<span class="token punctuation">.</span>choices<span class="token punctuation">(</span>range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> k<span class="token operator">=</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>pool<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> indices<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">nth_combination</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> r<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token string">"Equivalent to list(combinations(iterable, r))[index]"</span>
    pool <span class="token operator">=</span> tuple<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    n <span class="token operator">=</span> len<span class="token punctuation">(</span>pool<span class="token punctuation">)</span>
<span class="token keyword">if</span> r <span class="token operator">&lt;</span>0or r <span class="token operator">></span> n<span class="token punctuation">:</span>
raiseValueError
    c <span class="token operator">=</span><span class="token number">1</span>
    k <span class="token operator">=</span> min<span class="token punctuation">(</span>r<span class="token punctuation">,</span> n<span class="token operator">-</span>r<span class="token punctuation">)</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        c <span class="token operator">=</span> c <span class="token operator">*</span><span class="token punctuation">(</span>n <span class="token operator">-</span> k <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token operator">//</span> i
<span class="token keyword">if</span> index <span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">:</span>
        index <span class="token operator">+=</span> c
<span class="token keyword">if</span> index <span class="token operator">&lt;</span>0or index <span class="token operator">>=</span> c<span class="token punctuation">:</span>
raiseIndexError
    result <span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">while</span> r<span class="token punctuation">:</span>
        c<span class="token punctuation">,</span> n<span class="token punctuation">,</span> r <span class="token operator">=</span> c<span class="token operator">*</span>r<span class="token operator">//</span>n<span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">,</span> r<span class="token number">-1</span>
<span class="token keyword">while</span> index <span class="token operator">>=</span> c<span class="token punctuation">:</span>
            index <span class="token operator">-=</span> c
            c<span class="token punctuation">,</span> n <span class="token operator">=</span> c<span class="token operator">*</span><span class="token punctuation">(</span>n<span class="token operator">-</span>r<span class="token punctuation">)</span><span class="token operator">//</span>n<span class="token punctuation">,</span> n<span class="token number">-1</span>
        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>pool<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> tuple<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="functools-—-高阶函数和可调用对象上的操作"><a href="#functools-—-高阶函数和可调用对象上的操作" class="headerlink" title="functools —- 高阶函数和可调用对象上的操作"></a><code>functools</code> —- 高阶函数和可调用对象上的操作</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/functools.py" target="_blank" rel="noopener">Lib/functools.py</a></p>
<hr>
<p><code>functools</code> 模块应用于高阶函数，即参数或（和）返回值为其他函数的函数。 通常来说，此模块的功能适用于所有可调用对象。</p>
<p><code>functools</code> 模块定义了以下函数:</p>
<p><code>@functools.cache</code>(<em>user_function</em>)</p>
<p>简单轻量级未绑定函数缓存。 有时称为 “memoize”。</p>
<p>返回值与 <code>lru_cache(maxsize=None)</code> 相同，创建一个查找函数参数的字典的简单包装器。 因为它不需要移出旧值，所以比带有大小限制的 <code>lru_cache()</code> 更小更快。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python">@cache
<span class="token keyword">def</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> factorial<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token keyword">if</span> n <span class="token keyword">else</span> <span class="token number">1</span>
<span class="token operator">>></span><span class="token operator">></span> factorial<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># no previously cached result, makes 11 recursive calls</span>
<span class="token number">3628800</span>
<span class="token operator">>></span><span class="token operator">></span> factorial<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># just looks up cached value result</span>
<span class="token number">120</span>
<span class="token operator">>></span><span class="token operator">></span> factorial<span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># makes two new recursive calls, the other 10 are cached</span>
<span class="token number">479001600</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>@functools.cached_property</code>(<em>func</em>)</p>
<p>将一个类方法转换为特征属性，一次性计算该特征属性的值，然后将其缓存为实例生命周期内的普通属性。 类似于 <code>property()</code> 但增加了缓存功能。 对于在其他情况下实际不可变的高计算资源消耗的实例特征属性来说该函数非常有用。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">DataSet</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sequence_of_numbers<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_data <span class="token operator">=</span> tuple<span class="token punctuation">(</span>sequence_of_numbers<span class="token punctuation">)</span>
    @cached_property
    <span class="token keyword">def</span> <span class="token function">stdev</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> statistics<span class="token punctuation">.</span>stdev<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>cached_property()</code> 的设定与 <code>property()</code> 有所不同。 常规的 property 会阻止属性写入，除非定义了 setter。 与之相反，<em>cached_property</em> 则允许写入。</p>
<p><em>cached_property</em> 装饰器仅在执行查找且不存在同名属性时才会运行。 当运行时，<em>cached_property</em> 会写入同名的属性。 后续的属性读取和写入操作会优先于 <em>cached_property</em> 方法，其行为就像普通的属性一样。</p>
<p>缓存的值可通过删除该属性来清空。 这允许 <em>cached_property</em> 方法再次运行。</p>
<p>注意，这个装饰器会影响 <a href="https://www.python.org/dev/peps/pep-0412" target="_blank" rel="noopener"><strong>PEP 412</strong></a> 键共享字典的操作。 这意味着相应的字典实例可能占用比通常时更多的空间。</p>
<p>而且，这个装饰器要求每个实例上的 <code>__dict__</code> 是可变的映射。 这意味着它将不适用于某些类型，例如元类（因为类型实例上的 <code>__dict__</code> 属性是类命名空间的只读代理），以及那些指定了 <code>__slots__</code> 但未包括 <code>__dict__</code> 作为所定义的空位之一的类（因为这样的类根本没有提供 <code>__dict__</code> 属性）。</p>
<p>如果可变的映射不可用或者如果想要节省空间的键共享，可以通过在 <code>cache()</code> 之上堆叠一个 <code>property()</code> 来实现类似 <code>cached_property()</code> 的效果:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">DataSet</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sequence_of_numbers<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>_data <span class="token operator">=</span> sequence_of_numbers
    @property
    @cache
    <span class="token keyword">def</span> <span class="token function">stdev</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> statistics<span class="token punctuation">.</span>stdev<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_data<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.8 新版功能.</p>
<p><code>functools.cmp_to_key</code>(<em>func</em>)</p>
<p>将(旧式的)比较函数转换为新式的 key function . 在类似于 <code>sorted()</code> ， <code>min()</code> ， <code>max()</code> ， <code>heapq.nlargest()</code> ， <code>heapq.nsmallest()</code> ， <code>itertools.groupby()</code> 等函数的 key 参数中使用。此函数主要用作将 Python 2 程序转换至新版的转换工具，以保持对比较函数的兼容。</p>
<p>比较函数意为一个可调用对象，该对象接受两个参数并比较它们，结果为小于则返回一个负数，相等则返回零，大于则返回一个正数。key function则是一个接受一个参数，并返回另一个用以排序的值的可调用对象。</p>
<p>示例:</p>
<pre><code>sorted(iterable, key=cmp_to_key(locale.strcoll))  # locale-aware sort order</code></pre><p>3.2 新版功能.</p>
<p><code>@``functools.lru_cache</code>(<em>user_function</em>)</p>
<p><code>@``functools.lru_cache</code>(<em>maxsize=128</em>, <em>typed=False</em>)</p>
<p>一个为函数提供缓存功能的装饰器，缓存 <em>maxsize</em> 组传入参数，在下次以相同参数调用时直接返回上一次的结果。用以节约高开销或I/O函数的调用时间。</p>
<p>由于使用了字典存储缓存，所以该函数的固定参数和关键字参数必须是可哈希的。</p>
<p>不同模式的参数可能被视为不同从而产生多个缓存项，例如, f(a=1, b=2) 和 f(b=2, a=1) 因其参数顺序不同，可能会被缓存两次。</p>
<p>如果指定了 <em>user_function*，它必须是一个可调用对象。 这允许 *lru_cache</em> 装饰器被直接应用于一个用户自定义函数，让 <em>maxsize</em> 保持其默认值 128:</p>
<pre class="line-numbers language-python"><code class="language-python">@lru_cache
<span class="token keyword">def</span> <span class="token function">count_vowels</span><span class="token punctuation">(</span>sentence<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">(</span>sentence<span class="token punctuation">.</span>count<span class="token punctuation">(</span>vowel<span class="token punctuation">)</span> <span class="token keyword">for</span> vowel <span class="token keyword">in</span> <span class="token string">'AEIOUaeiou'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>maxsize</em> 设为 <code>None</code>，LRU 特性将被禁用且缓存可无限增长。</p>
<p>如果 <em>typed</em> 被设为真值，则不同类型的函数参数将被分别缓存。 例如，<code>f(3)</code> 和 <code>f(3.0)</code> 将总是会被当作具有不同结果的不同调用。 如果 <em>typed</em> 为假值，则具体实现通常会把它们当作相同调用并且只缓存一个结果，虽然并不一定总是会这样做。</p>
<p>被包装的函数配有一个 <code>cache_parameters()</code> 函数，该函数返回一个新的 <code>dict</code> 用来显示 <em>maxsize</em> 和 <em>typed</em> 的值。 这只是出于显示信息的目的。 改变值没有任何效果。</p>
<p>为了帮助衡量缓存的有效性以及调整 <em>maxsize</em> 形参，被包装的函数会带有一个 <code>cache_info()</code> 函数，它返回一个 named tuple 以显示 <em>hits</em>, <em>misses</em>, <em>maxsize</em> 和 <em>currsize</em>。</p>
<p>该装饰器也提供了一个用于清理/使缓存失效的函数 <code>cache_clear()</code> 。</p>
<p>原始的未经装饰的函数可以通过 <code>__wrapped__</code> 属性访问。它可以用于检查、绕过缓存，或使用不同的缓存再次装饰原始函数。</p>
<p>缓存会保持对参数的引用并返回值，直到它们结束生命期退出缓存或者直到缓存被清空。</p>
<p><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)" target="_blank" rel="noopener">LRU（最久未使用算法）缓存</a> 在最近的调用是即将到来的调用的最佳预测值时性能最好（例如，新闻服务器上最热门文章倾向于每天更改）。 缓存的大小限制可确保缓存不会在长期运行进程如网站服务器上无限制地增长。</p>
<p>一般来说，LRU缓存只在当你想要重用之前计算的结果时使用。因此，用它缓存具有副作用的函数、需要在每次调用时创建不同、易变的对象的函数或者诸如time（）或random（）之类的不纯函数是没有意义的。</p>
<p>静态 Web 内容的 LRU 缓存示例:</p>
<pre class="line-numbers language-python"><code class="language-python">@lru_cache<span class="token punctuation">(</span>maxsize<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">get_pep</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">'Retrieve text of a Python Enhancement Proposal'</span>
    resource <span class="token operator">=</span> <span class="token string">'https://www.python.org/dev/peps/pep-%04d/'</span> <span class="token operator">%</span> num
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        <span class="token keyword">with</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>resource<span class="token punctuation">)</span> <span class="token keyword">as</span> s<span class="token punctuation">:</span>
            <span class="token keyword">return</span> s<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> urllib<span class="token punctuation">.</span>error<span class="token punctuation">.</span>HTTPError<span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token string">'Not Found'</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> n <span class="token keyword">in</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">290</span><span class="token punctuation">,</span> <span class="token number">308</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">218</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">279</span><span class="token punctuation">,</span> <span class="token number">289</span><span class="token punctuation">,</span> <span class="token number">320</span><span class="token punctuation">,</span> <span class="token number">9991</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     pep <span class="token operator">=</span> get_pep<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> len<span class="token punctuation">(</span>pep<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> get_pep<span class="token punctuation">.</span>cache_info<span class="token punctuation">(</span><span class="token punctuation">)</span>
CacheInfo<span class="token punctuation">(</span>hits<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> misses<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> maxsize<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span> currsize<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以下是使用缓存通过 <a href="https://zh.wikipedia.org/wiki/动态规划" target="_blank" rel="noopener">动态规划</a> 计算 <a href="https://zh.wikipedia.org/wiki/斐波那契数列" target="_blank" rel="noopener">斐波那契数列</a> 的例子。</p>
<pre class="line-numbers language-python"><code class="language-python">@lru_cache<span class="token punctuation">(</span>maxsize<span class="token operator">=</span>None<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">fib</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> n
    <span class="token keyword">return</span> fib<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fib<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>fib<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token keyword">for</span> n <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">144</span><span class="token punctuation">,</span> <span class="token number">233</span><span class="token punctuation">,</span> <span class="token number">377</span><span class="token punctuation">,</span> <span class="token number">610</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> fib<span class="token punctuation">.</span>cache_info<span class="token punctuation">(</span><span class="token punctuation">)</span>
CacheInfo<span class="token punctuation">(</span>hits<span class="token operator">=</span><span class="token number">28</span><span class="token punctuation">,</span> misses<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">,</span> maxsize<span class="token operator">=</span>None<span class="token punctuation">,</span> currsize<span class="token operator">=</span><span class="token number">16</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.2 新版功能.</p>
<p>在 3.3 版更改: 添加 <em>typed</em> 选项。</p>
<p>在 3.8 版更改: 添加了 <em>user_function</em> 选项。</p>
<p>3.9 新版功能: 新增函数 <code>cache_parameters()</code></p>
<pre><code>@``functools.total_ordering</code></pre><p>给定一个声明一个或多个全比较排序方法的类，这个类装饰器实现剩余的方法。这减轻了指定所有可能的全比较操作的工作。</p>
<p>此类必须包含以下方法之一：<code>__lt__()</code> 、<code>__le__()</code>、<code>__gt__()</code> 或 <code>__ge__()</code>。另外，此类必须支持 <code>__eq__()</code> 方法。</p>
<p>例如：</p>
<pre class="line-numbers language-python"><code class="language-python">@total_ordering
<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">_is_valid_operand</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>hasattr<span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token string">"lastname"</span><span class="token punctuation">)</span> <span class="token operator">and</span>
                hasattr<span class="token punctuation">(</span>other<span class="token punctuation">,</span> <span class="token string">"firstname"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__eq__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>_is_valid_operand<span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> NotImplemented
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>lastname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>firstname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span>
                <span class="token punctuation">(</span>other<span class="token punctuation">.</span>lastname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> other<span class="token punctuation">.</span>firstname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">def</span> <span class="token function">__lt__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>_is_valid_operand<span class="token punctuation">(</span>other<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> NotImplemented
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>lastname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>firstname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>
                <span class="token punctuation">(</span>other<span class="token punctuation">.</span>lastname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> other<span class="token punctuation">.</span>firstname<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>虽然此装饰器使得创建具有良好行为的完全有序类型变得非常容易，但它 <em>确实</em> 是以执行速度更缓慢和派生比较方法的堆栈回溯更复杂为代价的。 如果性能基准测试表明这是特定应用的瓶颈所在，则改为实现全部六个富比较方法应该会轻松提升速度。</p>
<p>注解</p>
<p>这个装饰器不会尝试重载类 <em>或其上级类</em> 中已经被声明的方法。 这意味着如果某个上级类定义了比较运算符，则 <em>total_ordering</em> 将不会再次实现它，即使原方法是抽象方法。</p>
<p>3.2 新版功能.</p>
<p>在 3.4 版更改: 现在已支持从未识别类型的下层比较函数返回 NotImplemented 异常。</p>
<p><code>functools.partial</code>(<em>func</em>, <em>/</em>, <em>\</em>args<em>,</em> <em>*keywords</em>)</p>
<p>返回一个新的 部分对象，当被调用时其行为类似于 <em>func</em> 附带位置参数 <em>args</em> 和关键字参数 <em>keywords</em> 被调用。 如果为调用提供了更多的参数，它们会被附加到 <em>args</em>。 如果提供了额外的关键字参数，它们会扩展并重载 <em>keywords</em>。 大致等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">partial</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>keywords<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">newfunc</span><span class="token punctuation">(</span><span class="token operator">*</span>fargs<span class="token punctuation">,</span> <span class="token operator">**</span>fkeywords<span class="token punctuation">)</span><span class="token punctuation">:</span>
        newkeywords <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">**</span>keywords<span class="token punctuation">,</span> <span class="token operator">**</span>fkeywords<span class="token punctuation">}</span>
        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">*</span>fargs<span class="token punctuation">,</span> <span class="token operator">**</span>newkeywords<span class="token punctuation">)</span>
    newfunc<span class="token punctuation">.</span>func <span class="token operator">=</span> func
    newfunc<span class="token punctuation">.</span>args <span class="token operator">=</span> args
    newfunc<span class="token punctuation">.</span>keywords <span class="token operator">=</span> keywords
    <span class="token keyword">return</span> newfunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>partial()</code> 会被“冻结了”一部分函数参数和/或关键字的部分函数应用所使用，从而得到一个具有简化签名的新对象。 例如，<code>partial()</code> 可用来创建一个行为类似于 <code>int()</code> 函数的可调用对象，其中 <em>base</em> 参数默认为二：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> functools <span class="token keyword">import</span> partial
<span class="token operator">>></span><span class="token operator">></span> basetwo <span class="token operator">=</span> partial<span class="token punctuation">(</span>int<span class="token punctuation">,</span> base<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> basetwo<span class="token punctuation">.</span>__doc__ <span class="token operator">=</span> <span class="token string">'Convert base 2 string to an int.'</span>
<span class="token operator">>></span><span class="token operator">></span> basetwo<span class="token punctuation">(</span><span class="token string">'10010'</span><span class="token punctuation">)</span>
<span class="token number">18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><em>class</em> <code>functools.partialmethod</code>(<em>func</em>, <em>/</em>, <em>\</em>args<em>,</em> <em>*keywords</em>)</p>
<p>返回一个新的 <code>partialmethod</code> 描述器，其行为类似 <code>partial</code> 但它被设计用作方法定义而非直接用作可调用对象。</p>
<p><em>func</em> 必须是一个 descriptor 或可调用对象（同属两者的对象例如普通函数会被当作描述器来处理）。</p>
<p>当 <em>func</em> 是一个描述器（例如普通 Python 函数, <code>classmethod()</code>, <code>staticmethod()</code>, <code>abstractmethod()</code> 或其他 <code>partialmethod</code> 的实例）时, 对 <code>__get__</code> 的调用会被委托给底层的描述器，并会返回一个适当的 部分对象 作为结果。</p>
<p>当 <em>func</em> 是一个非描述器类可调用对象时，则会动态创建一个适当的绑定方法。 当用作方法时其行为类似普通 Python 函数：将会插入 <em>self</em> 参数作为第一个位置参数，其位置甚至会处于提供给 <code>partialmethod</code> 构造器的 <em>args</em> 和 <em>keywords</em> 之前。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">Cell</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>_alive <span class="token operator">=</span> <span class="token boolean">False</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     @property
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">alive</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> self<span class="token punctuation">.</span>_alive
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">set_state</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         self<span class="token punctuation">.</span>_alive <span class="token operator">=</span> bool<span class="token punctuation">(</span>state<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     set_alive <span class="token operator">=</span> partialmethod<span class="token punctuation">(</span>set_state<span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     set_dead <span class="token operator">=</span> partialmethod<span class="token punctuation">(</span>set_state<span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> Cell<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>alive
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>set_alive<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> c<span class="token punctuation">.</span>alive
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.4 新版功能.</p>
<p><code>functools.reduce</code>(<em>function</em>, <em>iterable</em>[, <em>initializer</em>])</p>
<p>将两个参数的 <em>function</em> 从左至右积累地应用到 <em>iterable</em> 的条目，以便将该可迭代对象缩减为单一的值。 例如，<code>reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])</code> 是计算 <code>((((1+2)+3)+4)+5)</code> 的值。 左边的参数 <em>x</em> 是积累值而右边的参数 <em>y</em> 则是来自 <em>iterable</em> 的更新值。 如果存在可选项 <em>initializer*，它会被放在参与计算的可迭代对象的条目之前，并在可迭代对象为空时作为默认值。 如果没有给出 *initializer</em> 并且 <em>iterable</em> 仅包含一个条目，则将返回第一项。</p>
<p>大致相当于：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">reduce</span><span class="token punctuation">(</span>function<span class="token punctuation">,</span> iterable<span class="token punctuation">,</span> initializer<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>
    it <span class="token operator">=</span> iter<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>
    <span class="token keyword">if</span> initializer <span class="token keyword">is</span> None<span class="token punctuation">:</span>
        value <span class="token operator">=</span> next<span class="token punctuation">(</span>it<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        value <span class="token operator">=</span> initializer
    <span class="token keyword">for</span> element <span class="token keyword">in</span> it<span class="token punctuation">:</span>
        value <span class="token operator">=</span> function<span class="token punctuation">(</span>value<span class="token punctuation">,</span> element<span class="token punctuation">)</span>
    <span class="token keyword">return</span> value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>请参阅 <code>itertools.accumulate()</code> 了解有关可产生所有中间值的迭代器。</p>
<pre><code>@``functools.singledispatch</code></pre><p>将一个函数转换为 单分派 generic function。</p>
<p>要定义一个泛型函数，应使用 <code>@singledispatch</code> 装饰器进行装饰。 请注意分派是作用于第一个参数的类型，要相应地创建你的函数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> functools <span class="token keyword">import</span> singledispatch
<span class="token operator">>></span><span class="token operator">></span> @singledispatch
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Let me just say,"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要将重载的实现添加到函数中，请使用泛型函数的 <code>register()</code> 属性。 它是一个装饰器。 对于带有类型标注的函数，该装饰器将自动推断第一个参数的类型:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> @fun<span class="token punctuation">.</span>register
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> int<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Strength in numbers, eh?"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> @fun<span class="token punctuation">.</span>register
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> list<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Enumerate this:"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> i<span class="token punctuation">,</span> elem <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于不使用类型标注的代码，可以将适当的类型参数显式地传给装饰器本身:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> @fun<span class="token punctuation">.</span>register<span class="token punctuation">(</span>complex<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Better than complicated."</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>real<span class="token punctuation">,</span> arg<span class="token punctuation">.</span>imag<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要启用注册 lambda 和现有函数，可以使用函数形式的 <code>register()</code> 属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">nothing</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Nothing."</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>register<span class="token punctuation">(</span>type<span class="token punctuation">(</span>None<span class="token punctuation">)</span><span class="token punctuation">,</span> nothing<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>register()</code> 属性将返回启用了装饰器堆栈、封存的未装饰函数，并会为每个变量单独创建单元测试:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> @fun<span class="token punctuation">.</span>register<span class="token punctuation">(</span>float<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> @fun<span class="token punctuation">.</span>register<span class="token punctuation">(</span>Decimal<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">fun_num</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Half of your number:"</span><span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>arg <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun_num <span class="token keyword">is</span> fun
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在调用时，泛型函数会根据第一个参数的类型进行分派:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token string">"Hello, world."</span><span class="token punctuation">)</span>
Hello<span class="token punctuation">,</span> world<span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token string">"test."</span><span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
Let me just say<span class="token punctuation">,</span> test<span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
Strength <span class="token keyword">in</span> numbers<span class="token punctuation">,</span> eh? <span class="token number">42</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">,</span> <span class="token string">'eggs'</span><span class="token punctuation">,</span> <span class="token string">'spam'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
Enumerate this<span class="token punctuation">:</span>
<span class="token number">0</span> spam
<span class="token number">1</span> spam
<span class="token number">2</span> eggs
<span class="token number">3</span> spam
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span>None<span class="token punctuation">)</span>
Nothing<span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token number">1.23</span><span class="token punctuation">)</span>
<span class="token number">0.615</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在没有用于特定类型的已注册实现的情况下，则会使用其方法解析顺序来查找更通用的实现。 以 <code>@singledispatch</code> 装饰的原始函数将为最基本的 <code>object</code> 类型进行注册，这意味着它将在找不到更好的实现时被使用。</p>
<p>如果一个实现注册到了 abstract base class，虚拟子类将会被发送到该实现:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> collections<span class="token punctuation">.</span>abc <span class="token keyword">import</span> Mapping
<span class="token operator">>></span><span class="token operator">></span> @fun<span class="token punctuation">.</span>register
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>arg<span class="token punctuation">:</span> Mapping<span class="token punctuation">,</span> verbose<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">if</span> verbose<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Keys &amp; Values"</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> arg<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">"=>"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token string">"b"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
a <span class="token operator">=</span><span class="token operator">></span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要检查泛型函数将为给定类型选择哪个实现，请使用 <code>dispatch()</code> 属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>dispatch<span class="token punctuation">(</span>float<span class="token punctuation">)</span>
<span class="token operator">&lt;</span>function fun_num at <span class="token number">0x1035a2840</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>dispatch<span class="token punctuation">(</span>dict<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># note: default implementation</span>
<span class="token operator">&lt;</span>function fun at <span class="token number">0x103fe0000</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>要访问所有忆注册实现，请使用只读的 <code>registry</code> 属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>
dict_keys<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'NoneType'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'int'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'object'</span><span class="token operator">></span><span class="token punctuation">,</span>
          <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'decimal.Decimal'</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'list'</span><span class="token operator">></span><span class="token punctuation">,</span>
          <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'float'</span><span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>registry<span class="token punctuation">[</span>float<span class="token punctuation">]</span>
<span class="token operator">&lt;</span>function fun_num at <span class="token number">0x1035a2840</span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> fun<span class="token punctuation">.</span>registry<span class="token punctuation">[</span>object<span class="token punctuation">]</span>
<span class="token operator">&lt;</span>function fun at <span class="token number">0x103fe0000</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.4 新版功能.</p>
<p>在 3.7 版更改: <code>register()</code> 属性支持使用类型标注。</p>
<p><em>class</em> <code>functools.singledispatchmethod</code>(<em>func</em>)</p>
<p>将一个方法转换为 单分派 generic function。</p>
<p>要定义一个泛型方法，应使用 <code>@singledispatchmethod</code> 装饰器进行装饰。 请注意分派是作用于第一个非 self 或非 cls 参数的类型，要相应地创建你的函数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Negator</span><span class="token punctuation">:</span>
    @singledispatchmethod
    <span class="token keyword">def</span> <span class="token function">neg</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> NotImplementedError<span class="token punctuation">(</span><span class="token string">"Cannot negate a"</span><span class="token punctuation">)</span>
    @neg<span class="token punctuation">.</span>register
    <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arg<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>arg
    @neg<span class="token punctuation">.</span>register
    <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arg<span class="token punctuation">:</span> bool<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">not</span> arg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>@singledispatchmethod</code> 支持与其他装饰器如 <code>@classmethod</code> 相嵌套。 请注意如果要允许 <code>dispatcher.register</code>，则 <code>singledispatchmethod</code> 必须是 <em>最外层</em> 的装饰器。 下面的示例定义了 <code>Negator</code> 类，其中包含绑定到类的 <code>neg</code> 方法:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Negator</span><span class="token punctuation">:</span>
    @singledispatchmethod
    @classmethod
    <span class="token keyword">def</span> <span class="token function">neg</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> NotImplementedError<span class="token punctuation">(</span><span class="token string">"Cannot negate a"</span><span class="token punctuation">)</span>
    @neg<span class="token punctuation">.</span>register
    @classmethod
    <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> arg<span class="token punctuation">:</span> int<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">-</span>arg
    @neg<span class="token punctuation">.</span>register
    @classmethod
    <span class="token keyword">def</span> <span class="token function">_</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> arg<span class="token punctuation">:</span> bool<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token operator">not</span> arg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同样的模式也被用于其他类似的装饰器: <code>staticmethod</code>, <code>abstractmethod</code> 等等。</p>
<p>3.8 新版功能.</p>
<p><code>functools.update_wrapper</code>(<em>wrapper</em>, <em>wrapped</em>, <em>assigned=WRAPPER_ASSIGNMENTS</em>, <em>updated=WRAPPER_UPDATES</em>)</p>
<p>更新一个 <em>wrapper</em> 函数以使其类似于 <em>wrapped</em> 函数。 可选参数为指明原函数的哪些属性要直接被赋值给 wrapper 函数的匹配属性的元组，并且这些 wrapper 函数的属性将使用原函数的对应属性来更新。 这些参数的默认值是模块级常量 <code>WRAPPER_ASSIGNMENTS</code> (它将被赋值给 wrapper 函数的 <code>__module__</code>, <code>__name__</code>, <code>__qualname__</code>, <code>__annotations__</code> 和 <code>__doc__</code> 即文档字符串) 以及 <code>WRAPPER_UPDATES</code> (它将更新 wrapper 函数的 <code>__dict__</code> 即实例字典)。</p>
<p>为了允许出于内省和其他目的访问原始函数（例如绕过 <code>lru_cache()</code> 之类的缓存装饰器），此函数会自动为 wrapper 添加一个指向被包装函数的 <code>__wrapped__</code> 属性。</p>
<p>此函数的主要目的是在 decorator 函数中用来包装被装饰的函数并返回包装器。 如果包装器函数未被更新，则被返回函数的元数据将反映包装器定义而不是原始函数定义，这通常没有什么用处。</p>
<p><code>update_wrapper()</code> 可以与函数之外的可调用对象一同使用。 在 <em>assigned</em> 或 <em>updated</em> 中命名的任何属性如果不存在于被包装对象则会被忽略（即该函数将不会尝试在包装器函数上设置它们）。 如果包装器函数自身缺少在 <em>updated</em> 中命名的任何属性则仍将引发 <code>AttributeError</code>。</p>
<p>3.2 新版功能: 自动添加 <code>__wrapped__</code> 属性。</p>
<p>3.2 新版功能: 默认拷贝 <code>__annotations__</code> 属性。</p>
<p>在 3.2 版更改: 不存在的属性将不再触发 <code>AttributeError</code>。</p>
<p>在 3.4 版更改: <code>__wrapped__</code> 属性现在总是指向被包装的函数，即使该函数定义了 <code>__wrapped__</code> 属性。 (参见 <a href="https://bugs.python.org/issue17482" target="_blank" rel="noopener">bpo-17482</a>)</p>
<p><code>@``functools.wraps</code>(<em>wrapped</em>, <em>assigned=WRAPPER_ASSIGNMENTS</em>, <em>updated=WRAPPER_UPDATES</em>)</p>
<p>这是一个便捷函数，用于在定义包装器函数时发起调用 <code>update_wrapper()</code> 作为函数装饰器。 它等价于 <code>partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated)</code>。 例如:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> functools <span class="token keyword">import</span> wraps
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">my_decorator</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     @wraps<span class="token punctuation">(</span>f<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwds<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Calling decorated function'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">return</span> f<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwds<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> wrapper
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> @my_decorator
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">def</span> <span class="token function">example</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token triple-quoted-string string">"""Docstring"""</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Called example function'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> example<span class="token punctuation">(</span><span class="token punctuation">)</span>
Calling decorated function
Called example function
<span class="token operator">>></span><span class="token operator">></span> example<span class="token punctuation">.</span>__name__
<span class="token string">'example'</span>
<span class="token operator">>></span><span class="token operator">></span> example<span class="token punctuation">.</span>__doc__
<span class="token string">'Docstring'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果不使用这个装饰器工厂函数，则 example 函数的名称将变为 <code>'wrapper'</code>，并且 <code>example()</code> 原本的文档字符串将会丢失。</p>
<h3 id="partial-对象"><a href="#partial-对象" class="headerlink" title="partial 对象"></a><code>partial</code> 对象</h3><p><code>partial</code> 对象是由 <code>partial()</code> 创建的可调用对象。 它们具有三个只读属性：</p>
<pre><code>partial.func</code></pre><p>一个可调用对象或函数。 对 <code>partial</code> 对象的调用将被转发给 <code>func</code> 并附带新的参数和关键字。</p>
<pre><code>partial.args</code></pre><p>最左边的位置参数将放置在提供给 <code>partial</code> 对象调用的位置参数之前。</p>
<pre><code>partial.keywords</code></pre><p>当调用 <code>partial</code> 对象时将要提供的关键字参数。</p>
<p><code>partial</code> 对象与 <code>function</code> 对象的类似之处在于它们都是可调用、可弱引用的对象并可拥有属性。 但两者也存在一些重要的区别。 例如前者不会自动创建 <code>__name__</code> 和 <code>__doc__</code> 属性。 而且，在类中定义的 <code>partial</code> 对象的行为类似于静态方法，并且不会在实例属性查找期间转换为绑定方法。</p>
<h2 id="operator-—-标准运算符替代函数"><a href="#operator-—-标准运算符替代函数" class="headerlink" title="operator —- 标准运算符替代函数"></a><code>operator</code> —- 标准运算符替代函数</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/operator.py" target="_blank" rel="noopener">Lib/operator.py</a></p>
<hr>
<p><code>operator</code> 模块提供了一套与Python的内置运算符对应的高效率函数。例如，<code>operator.add(x, y)</code> 与表达式 <code>x+y</code> 相同。 许多函数名与特殊方法名相同，只是没有双下划线。为了向后兼容性，也保留了许多包含双下划线的函数。为了表述清楚，建议使用没有双下划线的函数。</p>
<p>函数包含的种类有：对象的比较运算、逻辑运算、数学运算以及序列运算。</p>
<p>对象比较函数适用于所有的对象，函数名根据它们对应的比较运算符命名。</p>
<p><code>operator.lt</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.le</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.eq</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.ne</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.ge</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.gt</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__lt__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__le__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__eq__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ne__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ge__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__gt__</code>(<em>a</em>, <em>b</em>)</p>
<p>在 <em>a</em> 和 <em>b</em> 之间进行全比较。具体的，<code>lt(a, b)</code> 与 <code>a &lt; b</code> 相同， <code>le(a, b)</code> 与 <code>a &lt;= b</code> 相同，<code>eq(a, b)</code> 与 <code>a == b</code> 相同，<code>ne(a, b)</code> 与 <code>a != b</code> 相同，<code>gt(a, b)</code> 与 <code>a &gt; b</code> 相同，<code>ge(a, b)</code>与 <code>a &gt;= b</code> 相同。注意这些函数可以返回任何值，无论它是否可当作布尔值。</p>
<p>逻辑运算通常也适用于所有对象，并且支持真值检测、标识检测和布尔运算：</p>
<p><code>operator.not_</code>(<em>obj</em>)</p>
<p><code>operator.__not__</code>(<em>obj</em>)</p>
<p>返回 <code>not</code> <em>obj</em> 的结果。 （请注意对象实例并没有 <code>__not__()</code> 方法；只有解释器核心可定义此操作。 结果会受 <code>__bool__()</code> 和 <code>__len__()</code> 方法影响。）</p>
<p><code>operator.truth</code>(<em>obj</em>)</p>
<p>如果 <em>obj</em> 为真值则返回 <code>True</code>，否则返回 <code>False</code>。 这等价于使用 <code>bool</code> 构造器。</p>
<p><code>operator.is_</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a is b</code>。 检测对象标识。</p>
<p><code>operator.is_not</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a is not b</code>。 检测对象标识。</p>
<p>数学和按位运算的种类是最多的：</p>
<p><code>operator.abs</code>(<em>obj</em>)</p>
<p><code>operator.__abs__</code>(<em>obj</em>)</p>
<p>返回 <em>obj</em> 的绝对值。</p>
<p><code>operator.add</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__add__</code>(<em>a</em>, <em>b</em>)</p>
<p>对于数字 <em>a</em> 和 <em>b</em>，返回 <code>a + b</code>。</p>
<p><code>operator.and_</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__and__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>x</em> 和 <em>y</em> 按位与的结果。</p>
<p><code>operator.floordiv</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__floordiv__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a // b</code>。</p>
<p><code>operator.index</code>(<em>a</em>)</p>
<p><code>operator.__index__</code>(<em>a</em>)</p>
<p>返回 <em>a</em> 转换为整数的结果。 等价于 <code>a.__index__()</code>。</p>
<p>在 3.10 版更改: 结果总是为 <code>int</code> 类型。 在之前版本中，结果可能为 <code>int</code> 的子类的实例。</p>
<p><code>operator.inv</code>(<em>obj</em>)</p>
<p><code>operator.invert</code>(<em>obj</em>)</p>
<p><code>operator.__inv__</code>(<em>obj</em>)</p>
<p><code>operator.__invert__</code>(<em>obj</em>)</p>
<p>返回数字 <em>obj</em> 按位取反的结果。 这等价于 <code>~obj</code>。</p>
<p><code>operator.lshift</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__lshift__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>a</em> 左移 <em>b</em> 位的结果。</p>
<p><code>operator.mod</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__mod__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a % b</code>。</p>
<p><code>operator.mul</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__mul__</code>(<em>a</em>, <em>b</em>)</p>
<p>对于数字 <em>a</em> 和 <em>b</em>，返回 <code>a * b</code>。</p>
<p><code>operator.matmul</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__matmul__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a @ b</code>。</p>
<p>3.5 新版功能.</p>
<p><code>operator.neg</code>(<em>obj</em>)</p>
<p><code>operator.__neg__</code>(<em>obj</em>)</p>
<p>返回 <em>obj</em> 取负的结果 (<code>-obj</code>)。</p>
<p><code>operator.or_</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__or__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>a</em> 和 <em>b</em> 按位或的结果。</p>
<p><code>operator.pos</code>(<em>obj</em>)</p>
<p><code>operator.__pos__</code>(<em>obj</em>)</p>
<p>返回 <em>obj</em> 取正的结果 (<code>+obj</code>)。</p>
<p><code>operator.pow</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__pow__</code>(<em>a</em>, <em>b</em>)</p>
<p>对于数字 <em>a</em> 和 <em>b</em>，返回 <code>a ** b</code>。</p>
<p><code>operator.rshift</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__rshift__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>a</em> 右移 <em>b</em> 位的结果。</p>
<p><code>operator.sub</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__sub__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a - b</code>。</p>
<p><code>operator.truediv</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__truediv__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>a / b</code> 例如 2/3 将等于 .66 而不是 0。 这也被称为“真”除法。</p>
<p><code>operator.xor</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__xor__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>a</em> 和 <em>b</em> 按位异或的结果。</p>
<p>适用于序列的操作（其中一些也适用于映射）包括：</p>
<p><code>operator.concat</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__concat__</code>(<em>a</em>, <em>b</em>)</p>
<p>对于序列 <em>a</em> 和 <em>b</em>，返回 <code>a + b</code>。</p>
<p><code>operator.contains</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__contains__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <code>b in a</code> 检测的结果。 请注意操作数是反序的。</p>
<p><code>operator.countOf</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>b</em> 在 <em>a</em> 中的出现次数。</p>
<p><code>operator.delitem</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__delitem__</code>(<em>a</em>, <em>b</em>)</p>
<p>移除 <em>a</em> 中索引号为 <em>b</em> 的值。</p>
<p><code>operator.getitem</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__getitem__</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>a</em> 中索引为 <em>b</em> 的值。</p>
<p><code>operator.indexOf</code>(<em>a</em>, <em>b</em>)</p>
<p>返回 <em>b</em> 在 <em>a</em> 中首次出现所在的索引号。</p>
<p><code>operator.setitem</code>(<em>a</em>, <em>b</em>, <em>c</em>)</p>
<p><code>operator.__setitem__</code>(<em>a</em>, <em>b</em>, <em>c</em>)</p>
<p>将 <em>a</em> 中索引号为 <em>b</em> 的值设为 <em>c</em>。</p>
<p><code>operator.length_hint</code>(<em>obj</em>, <em>default=0</em>)</p>
<p>返回对象 <em>o</em> 的估计长度。 首先尝试返回其实际长度，再使用 <code>object.__length_hint__()</code> 得出估计值，最后返回默认值。</p>
<p>3.4 新版功能.</p>
<p><code>operator</code> 模块还定义了一些用于常规属性和条目查找的工具。 这些工具适合用来编写快速字段提取器作为 <code>map()</code>, <code>sorted()</code>, <code>itertools.groupby()</code> 或其他需要相应函数参数的函数的参数。</p>
<p><code>operator.attrgetter</code>(<em>attr</em>)</p>
<p><code>operator.attrgetter</code>(<em>\</em>attrs*)</p>
<p>返回一个可从操作数中获取 <em>attr</em> 的可调用对象。 如果请求了一个以上的属性，则返回一个属性元组。 属性名称还可包含点号。 例如：</p>
<ul>
<li>在 <code>f = attrgetter('name')</code> 之后，调用 <code>f(b)</code> 将返回 <code>b.name</code>。</li>
<li>在 <code>f = attrgetter('name', 'date')</code> 之后，调用 <code>f(b)</code> 将返回 <code>(b.name, b.date)</code>。</li>
<li>在 <code>f = attrgetter('name.first', 'name.last')</code> 之后，调用 <code>f(b)</code> 将返回 <code>(b.name.first, b.name.last)</code>。</li>
</ul>
<p>等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">attrgetter</span><span class="token punctuation">(</span><span class="token operator">*</span>items<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> any<span class="token punctuation">(</span><span class="token operator">not</span> isinstance<span class="token punctuation">(</span>item<span class="token punctuation">,</span> str<span class="token punctuation">)</span> <span class="token keyword">for</span> item <span class="token keyword">in</span> items<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span><span class="token string">'attribute name must be a string'</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> len<span class="token punctuation">(</span>items<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        attr <span class="token operator">=</span> items<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">g</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> resolve_attr<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> attr<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">g</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> tuple<span class="token punctuation">(</span>resolve_attr<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> attr<span class="token punctuation">)</span> <span class="token keyword">for</span> attr <span class="token keyword">in</span> items<span class="token punctuation">)</span>
    <span class="token keyword">return</span> g
<span class="token keyword">def</span> <span class="token function">resolve_attr</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> attr<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> name <span class="token keyword">in</span> attr<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        obj <span class="token operator">=</span> getattr<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
    <span class="token keyword">return</span> obj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>operator.itemgetter</code>(<em>item</em>)</p>
<p><code>operator.itemgetter</code>(<em>\</em>items*)</p>
<p>返回一个使用操作数的 <code>__getitem__()</code> 方法从操作数中获取 <em>item</em> 的可调用对象。 如果指定了多个条目，则返回一个查找值的元组。 例如：</p>
<ul>
<li>在 <code>f = itemgetter(2)</code> 之后，调用 <code>f(r)</code> 将返回 <code>r[2]</code>。</li>
<li>在 <code>g = itemgetter(2, 5, 3)</code> 之后，调用 <code>g(r)</code> 将返回 <code>(r[2], r[5], r[3])</code>。</li>
</ul>
<p>等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">itemgetter</span><span class="token punctuation">(</span><span class="token operator">*</span>items<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> len<span class="token punctuation">(</span>items<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>
        item <span class="token operator">=</span> items<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">def</span> <span class="token function">g</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">def</span> <span class="token function">g</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> tuple<span class="token punctuation">(</span>obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span> <span class="token keyword">for</span> item <span class="token keyword">in</span> items<span class="token punctuation">)</span>
    <span class="token keyword">return</span> g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>传入的条目可以为操作数的 <code>__getitem__()</code> 所接受的任何类型。 字典接受任意可哈希的值。 列表、元组和字符串接受 index 或 slice 对象：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'ABCDEFG'</span><span class="token punctuation">)</span>
<span class="token string">'B'</span>
<span class="token operator">>></span><span class="token operator">></span> itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'ABCDEFG'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'F'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> itemgetter<span class="token punctuation">(</span>slice<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> None<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'ABCDEFG'</span><span class="token punctuation">)</span>
<span class="token string">'CDEFG'</span>
<span class="token operator">>></span><span class="token operator">></span> soldier <span class="token operator">=</span> dict<span class="token punctuation">(</span>rank<span class="token operator">=</span><span class="token string">'captain'</span><span class="token punctuation">,</span> name<span class="token operator">=</span><span class="token string">'dotterbart'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> itemgetter<span class="token punctuation">(</span><span class="token string">'rank'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>soldier<span class="token punctuation">)</span>
<span class="token string">'captain'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用 <code>itemgetter()</code> 从元组的记录中提取特定字段的例子：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> inventory <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> getcount <span class="token operator">=</span> itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span>getcount<span class="token punctuation">,</span> inventory<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>inventory<span class="token punctuation">,</span> key<span class="token operator">=</span>getcount<span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'orange'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'banana'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'pear'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>operator.methodcaller</code>(<em>name</em>, <em>/</em>, <em>\</em>args<em>,</em> <em>*kwargs</em>)</p>
<p>返回一个在操作数上调用 <em>name</em> 方法的可调用对象。 如果给出额外的参数和/或关键字参数，它们也将被传给该方法。 例如：</p>
<ul>
<li>在 <code>f = methodcaller('name')</code> 之后，调用 <code>f(b)</code> 将返回 <code>b.name()</code>。</li>
<li>在 <code>f = methodcaller('name', 'foo', bar=1)</code> 之后，调用 <code>f(b)</code> 将返回 <code>b.name('foo', bar=1)</code>。</li>
</ul>
<p>等价于:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">methodcaller</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token operator">/</span><span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">caller</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> getattr<span class="token punctuation">(</span>obj<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>
    <span class="token keyword">return</span> caller<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="将运算符映射到函数"><a href="#将运算符映射到函数" class="headerlink" title="将运算符映射到函数"></a>将运算符映射到函数</h3><p>以下表格显示了抽象运算是如何对应于 Python 语法中的运算符和 <code>operator</code> 模块中的函数的。</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">语法</th>
<th align="left">函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">加法</td>
<td align="left"><code>a + b</code></td>
<td align="left"><code>add(a, b)</code></td>
</tr>
<tr>
<td align="left">字符串拼接</td>
<td align="left"><code>seq1 + seq2</code></td>
<td align="left"><code>concat(seq1, seq2)</code></td>
</tr>
<tr>
<td align="left">包含测试</td>
<td align="left"><code>obj in seq</code></td>
<td align="left"><code>contains(seq, obj)</code></td>
</tr>
<tr>
<td align="left">除法</td>
<td align="left"><code>a / b</code></td>
<td align="left"><code>truediv(a, b)</code></td>
</tr>
<tr>
<td align="left">除法</td>
<td align="left"><code>a // b</code></td>
<td align="left"><code>floordiv(a, b)</code></td>
</tr>
<tr>
<td align="left">按位与</td>
<td align="left"><code>a &amp; b</code></td>
<td align="left"><code>and*(a, b)*</code></td>
</tr>
<tr>
<td align="left">按位异或</td>
<td align="left"><code>a ^ b</code></td>
<td align="left"><code>xor(a, b)</code></td>
</tr>
<tr>
<td align="left">按位取反</td>
<td align="left"><code>~ a</code></td>
<td align="left"><code>invert(a)</code></td>
</tr>
<tr>
<td align="left">按位或</td>
<td align="left">`a</td>
<td align="left">b`</td>
</tr>
<tr>
<td align="left">取幂</td>
<td align="left"><code>a ** b*</code></td>
<td align="left"><code>pow(a, b)</code></td>
</tr>
<tr>
<td align="left">标识</td>
<td align="left"><code>a is b</code></td>
<td align="left"><code>is_(a, b)</code></td>
</tr>
<tr>
<td align="left">标识</td>
<td align="left"><code>a is not b</code></td>
<td align="left"><code>is_not(a, b)</code></td>
</tr>
<tr>
<td align="left">索引赋值</td>
<td align="left"><code>obj[k] = v</code></td>
<td align="left"><code>setitem(obj, k, v)</code></td>
</tr>
<tr>
<td align="left">索引删除</td>
<td align="left"><code>del obj[k]</code></td>
<td align="left"><code>delitem(obj, k)</code></td>
</tr>
<tr>
<td align="left">索引取值</td>
<td align="left"><code>obj[k]</code></td>
<td align="left"><code>getitem(obj, k)</code></td>
</tr>
<tr>
<td align="left">左移</td>
<td align="left"><code>a &lt;&lt; b</code></td>
<td align="left"><code>lshift(a, b)</code></td>
</tr>
<tr>
<td align="left">取模</td>
<td align="left"><code>a % b</code></td>
<td align="left"><code>mod(a, b)</code></td>
</tr>
<tr>
<td align="left">乘法</td>
<td align="left"><code>a b</code></td>
<td align="left"><code>mul(a, b)</code></td>
</tr>
<tr>
<td align="left">矩阵乘法</td>
<td align="left"><code>a @ b</code></td>
<td align="left"><code>matmul(a, b)</code></td>
</tr>
<tr>
<td align="left">取反（算术）</td>
<td align="left"><code>- a</code></td>
<td align="left"><code>neg(a)</code></td>
</tr>
<tr>
<td align="left">取反（逻辑）</td>
<td align="left"><code>not a</code></td>
<td align="left"><code>not_(a)</code></td>
</tr>
<tr>
<td align="left">正数</td>
<td align="left"><code>+ a</code></td>
<td align="left"><code>pos(a)</code></td>
</tr>
<tr>
<td align="left">右移</td>
<td align="left"><code>a &gt;&gt; b</code></td>
<td align="left"><code>rshift(a, b)</code></td>
</tr>
<tr>
<td align="left">切片赋值</td>
<td align="left"><code>seq[i:j] = values</code></td>
<td align="left"><code>setitem(seq, slice(i, j), values)</code></td>
</tr>
<tr>
<td align="left">切片删除</td>
<td align="left"><code>del seq[i:j]</code></td>
<td align="left"><code>delitem(seq, slice(i, j))</code></td>
</tr>
<tr>
<td align="left">切片取值</td>
<td align="left"><code>seq[i:j]</code></td>
<td align="left"><code>getitem(seq, slice(i, j))</code></td>
</tr>
<tr>
<td align="left">字符串格式化</td>
<td align="left"><code>s % obj</code></td>
<td align="left"><code>mod(s, obj)</code></td>
</tr>
<tr>
<td align="left">减法</td>
<td align="left"><code>a - b</code></td>
<td align="left"><code>sub(a, b)</code></td>
</tr>
<tr>
<td align="left">真值测试</td>
<td align="left"><code>obj</code></td>
<td align="left"><code>truth(obj)</code></td>
</tr>
<tr>
<td align="left">比较</td>
<td align="left"><code>a &lt; b</code></td>
<td align="left"><code>lt(a, b)</code></td>
</tr>
<tr>
<td align="left">比较</td>
<td align="left"><code>a &lt;= b</code></td>
<td align="left"><code>le(a, b)</code></td>
</tr>
<tr>
<td align="left">相等</td>
<td align="left"><code>a == b</code></td>
<td align="left"><code>eq(a, b)</code></td>
</tr>
<tr>
<td align="left">不等</td>
<td align="left"><code>a != b</code></td>
<td align="left"><code>ne(a, b)</code></td>
</tr>
<tr>
<td align="left">比较</td>
<td align="left"><code>a &gt;= b</code></td>
<td align="left"><code>ge(a, b)</code></td>
</tr>
<tr>
<td align="left">比较</td>
<td align="left"><code>a &gt; b</code></td>
<td align="left"><code>gt(a, b)</code></td>
</tr>
</tbody></table>
<h3 id="原地运算符"><a href="#原地运算符" class="headerlink" title="原地运算符"></a>原地运算符</h3><p>许多运算都有“原地”版本。 以下列出的是提供对原地运算符相比通常语法更底层访问的函数，例如 statement <code>x += y</code> 相当于 <code>x = operator.iadd(x, y)</code>。 换一种方式来讲就是 <code>z = operator.iadd(x, y)</code> 等价于语句块 <code>z = x; z += y</code>。</p>
<p>在这些例子中，请注意当调用一个原地方法时，运算和赋值是分成两个步骤来执行的。 下面列出的原地函数只执行第一步即调用原地方法。 第二步赋值则不加处理。</p>
<p>对于不可变的目标例如字符串、数字和元组，更新的值会被计算，但不会被再被赋值给输入变量：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token string">'hello'</span>
<span class="token operator">>></span><span class="token operator">></span> iadd<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">' world'</span><span class="token punctuation">)</span>
<span class="token string">'hello world'</span>
<span class="token operator">>></span><span class="token operator">></span> a
<span class="token string">'hello'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于可变的目标例如列表和字典，原地方法将执行更新，因此不需要后续赋值操作：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> iadd<span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> s
<span class="token punctuation">[</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>operator.iadd</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__iadd__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = iadd(a, b)</code> 等价于 <code>a += b</code>。</p>
<p><code>operator.iand</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__iand__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = iand(a, b)</code> 等价于 <code>a &amp;= b</code>。</p>
<p><code>operator.iconcat</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__iconcat__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = iconcat(a, b)</code> 等价于 <code>a += b</code> 其中 <em>a</em> 和 <em>b</em> 为序列。</p>
<p><code>operator.ifloordiv</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ifloordiv__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = ifloordiv(a, b)</code> 等价于 <code>a //= b</code>。</p>
<p><code>operator.ilshift</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ilshift__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = ilshift(a, b)</code> 等价于 <code>a &lt;&lt;= b</code>。</p>
<p><code>operator.imod</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__imod__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = imod(a, b)</code> 等价于 <code>a %= b</code>。</p>
<p><code>operator.imul</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__imul__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = imul(a, b)</code> 等价于 <code>a *= b</code>。</p>
<p><code>operator.imatmul</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__imatmul__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = imatmul(a, b)</code> 等价于 <code>a @= b</code>。</p>
<p>3.5 新版功能.</p>
<p><code>operator.ior</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ior__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = ior(a, b)</code> 等价于 <code>a |= b</code>。</p>
<p><code>operator.ipow</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ipow__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = ipow(a, b)</code> 等价于 <code>a **= b</code>。</p>
<p><code>operator.irshift</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__irshift__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = irshift(a, b)</code> 等价于 <code>a &gt;&gt;= b</code>。</p>
<p><code>operator.isub</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__isub__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = isub(a, b)</code> 等价于 <code>a -= b</code>。</p>
<p><code>operator.itruediv</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__itruediv__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = itruediv(a, b)</code> 等价于 <code>a /= b</code>。</p>
<p><code>operator.ixor</code>(<em>a</em>, <em>b</em>)</p>
<p><code>operator.__ixor__</code>(<em>a</em>, <em>b</em>)</p>
<p><code>a = ixor(a, b)</code> 等价于 <code>a ^= b</code>。</p>
<h1 id="文件和目录访问"><a href="#文件和目录访问" class="headerlink" title="文件和目录访问"></a>文件和目录访问</h1><ul>
<li><code>pathlib</code> —- 面向对象的文件系统路径<ul>
<li>基础使用</li>
<li>纯路径<ul>
<li>通用性质</li>
<li>运算符</li>
<li>访问个别部分</li>
<li>方法和特征属性</li>
</ul>
</li>
<li>具体路径<ul>
<li>方法</li>
</ul>
</li>
<li>对应的 <code>os</code> 模块的工具</li>
</ul>
</li>
<li><code>os.path</code> —- 常用路径操作</li>
<li><code>fileinput</code> —- 迭代来自多个输入流的行</li>
<li><code>stat</code> —- 解析 <code>stat()</code> 结果</li>
<li><code>filecmp</code> —- 文件及目录的比较<ul>
<li><code>dircmp</code> 类</li>
</ul>
</li>
<li><code>tempfile</code> —- 生成临时文件和目录<ul>
<li>例子</li>
<li>已弃用的函数和变量</li>
</ul>
</li>
<li><code>glob</code> —- Unix 风格路径名模式扩展</li>
<li><code>fnmatch</code> —- Unix 文件名模式匹配</li>
<li><code>linecache</code> —- 随机读写文本行</li>
<li><code>shutil</code> —- 高阶文件操作<ul>
<li>目录和文件操作<ul>
<li>依赖于具体平台的高效拷贝操作</li>
<li>copytree 示例</li>
<li>rmtree 示例</li>
</ul>
</li>
<li>归档操作<ul>
<li>归档程序示例</li>
<li>使用 <em>base_dir</em> 的归档程序示例</li>
</ul>
</li>
<li>查询输出终端的尺寸</li>
</ul>
</li>
</ul>
<h2 id="pathlib-—-面向对象的文件系统路径"><a href="#pathlib-—-面向对象的文件系统路径" class="headerlink" title="pathlib —- 面向对象的文件系统路径"></a><code>pathlib</code> —- 面向对象的文件系统路径</h2><p>3.4 新版功能.</p>
<p><strong>源代码</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/pathlib.py" target="_blank" rel="noopener">Lib/pathlib.py</a></p>
<hr>
<p>该模块提供表示文件系统路径的类，其语义适用于不同的操作系统。路径类被分为提供纯计算操作而没有 I/O 的 纯路径，以及从纯路径继承而来但提供 I/O 操作的 具体路径。</p>
<p><img src="/images/loading.gif" data-original="../images/basic/7630eaca04bc0113c9884a446d903e20.png" alt=""></p>
<p>如果以前从未用过此模块，或不确定哪个类适合完成任务，那要用的可能就是 <code>Path</code>。它在运行代码的平台上实例化为 具体路径。</p>
<p>在一些用例中纯路径很有用，例如：</p>
<ol>
<li>如果你想要在 Unix 设备上操作 Windows 路径（或者相反）。你不应在 Unix 上实例化一个 <code>WindowsPath</code>，但是你可以实例化 <code>PureWindowsPath</code>。</li>
<li>你只想操作路径但不想实际访问操作系统。在这种情况下，实例化一个纯路径是有用的，因为它们没有任何访问操作系统的操作。</li>
</ol>
<p>参见</p>
<p><a href="https://www.python.org/dev/peps/pep-0428" target="_blank" rel="noopener"><strong>PEP 428</strong></a>：pathlib 模块 — 面向对象的的文件系统路径。</p>
<p>参见</p>
<p>对于底层的路径字符串操作，你也可以使用 <code>os.path</code> 模块。</p>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p>导入主类:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> pathlib <span class="token keyword">import</span> Path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>列出子目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> p<span class="token punctuation">.</span>iterdir<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> x<span class="token punctuation">.</span>is_dir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'.hg'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'docs'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'__pycache__'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'build'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>列出当前目录树下的所有 Python 源代码文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>p<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'**/*.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'test_pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'docs/conf.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'build/lib/pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在目录树中移动:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> q <span class="token operator">=</span> p <span class="token operator">/</span> <span class="token string">'init.d'</span> <span class="token operator">/</span> <span class="token string">'reboot'</span>
<span class="token operator">>></span><span class="token operator">></span> q
PosixPath<span class="token punctuation">(</span><span class="token string">'/etc/init.d/reboot'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">.</span>resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/etc/rc.d/init.d/halt'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查询路径的属性:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">.</span>is_dir<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>打开一个文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> q<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span> f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token string">'#!/bin/bash\n'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="纯路径"><a href="#纯路径" class="headerlink" title="纯路径"></a>纯路径</h3><p>纯路径对象提供了不实际访问文件系统的路径处理操作。有三种方式来访问这些类，也是不同的风格：</p>
<p><em>class</em> <code>pathlib.PurePath</code>(<em>\</em>pathsegments*)</p>
<p>一个通用的类，代表当前系统的路径风格（实例化为 <code>PurePosixPath</code> 或者 <code>PureWindowsPath</code>）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true"># Running on a Unix machine</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>每一个 <em>pathsegments</em> 的元素可能是一个代表路径片段的字符串，一个返回字符串的实现了 <code>os.PathLike</code> 接口的对象，或者另一个路径对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token string">'some/path'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/some/path/bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Path<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/bar'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 <em>pathsegments</em> 为空的时候，假定为当前目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>当给出一些绝对路径，最后一位将被当作锚（模仿 <code>os.path.join()</code> 的行为）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">,</span> <span class="token string">'/usr'</span><span class="token punctuation">,</span> <span class="token string">'lib64'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/usr/lib64'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Windows'</span><span class="token punctuation">,</span> <span class="token string">'d:bar'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'d:bar'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是，在 Windows 路径中，改变本地根目录并不会丢弃之前盘符的设置:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Windows'</span><span class="token punctuation">,</span> <span class="token string">'/Program Files'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>假斜线和单独的点都会被消除，但是双点 （<code>‘..’</code>） 不会，以防改变符号链接的含义。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'foo//bar'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'foo/./bar'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'foo/../bar'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/../bar'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（一个很 naïve 的做法是让 <code>PurePosixPath('foo/../bar')</code> 等同于 <code>PurePosixPath('bar')</code>，如果 <code>foo</code> 是一个指向其他目录的符号链接那么这个做法就将出错）</p>
<p>纯路径对象实现了 <code>os.PathLike</code> 接口，允许它们在任何接受此接口的地方使用。</p>
<p>在 3.6 版更改: 添加了 <code>os.PathLike</code> 接口支持。</p>
<p><em>class</em> <code>pathlib.PurePosixPath</code>(<em>\</em>pathsegments*)</p>
<p>一个 <code>PurePath</code> 的子类，路径风格不同于 Windows 文件系统:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>pathsegments</em> 参数的指定和 <code>PurePath</code> 相同。</p>
<p><em>class</em> <code>pathlib.PureWindowsPath</code>(<em>\</em>pathsegments*)</p>
<p><code>PurePath</code> 的一个子类，路径风格为 Windows 文件系统路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>pathsegments</em> 参数的指定和 <code>PurePath</code> 相同。</p>
<p>无论你正运行什么系统，你都可以实例化这些类，因为它们提供的操作不做任何系统调用。</p>
<h4 id="通用性质"><a href="#通用性质" class="headerlink" title="通用性质"></a>通用性质</h4><p>路径是不可变并可哈希的。相同风格的路径可以排序与比较。这些性质尊重对应风格的大小写转换语义:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token operator">==</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'FOO'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token operator">==</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'FOO'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'FOO'</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token punctuation">{</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'C:'</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'d:'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不同风格的路径比较得到不等的结果并且无法被排序:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token operator">==</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
TypeError<span class="token punctuation">:</span> <span class="token string">'&lt;'</span> <span class="token operator">not</span> supported between instances of <span class="token string">'PureWindowsPath'</span> <span class="token operator">and</span> <span class="token string">'PurePosixPath'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>斜杠 <code>/</code> 操作符有助于创建子路径，就像 <code>os.path.join()</code> 一样:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">/</span> <span class="token string">'init.d'</span> <span class="token operator">/</span> <span class="token string">'apache2'</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/init.d/apache2'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> q <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'bin'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token string">'/usr'</span> <span class="token operator">/</span> q
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/usr/bin'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>文件对象可用于任何接受 <code>os.PathLike</code> 接口实现的地方。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>fspath<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token string">'/etc'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>路径的字符串表示法为它自己原始的文件系统路径（以原生形式，例如在 Windows 下使用反斜杠）。你可以传递给任何需要字符串形式路径的函数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token string">'/etc'</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token string">'c:\\Program Files'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>类似地，在路径上调用 <code>bytes</code> 将原始文件系统路径作为字节对象给出，就像被 <code>os.fsencode()</code> 编码一样:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> bytes<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
b<span class="token string">'/etc'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注解</p>
<p>只推荐在 Unix 下调用 <code>bytes</code>。在 Windows， unicode 形式是文件系统路径的规范表示法。</p>
<h4 id="访问个别部分"><a href="#访问个别部分" class="headerlink" title="访问个别部分"></a>访问个别部分</h4><p>为了访问路径独立的部分 （组件），使用以下特征属性：</p>
<pre><code>PurePath.parts</code></pre><p>一个元组，可以访问路径的多个组件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'/usr/bin/python3'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parts
<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'usr'</span><span class="token punctuation">,</span> <span class="token string">'bin'</span><span class="token punctuation">,</span> <span class="token string">'python3'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/PSF'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parts
<span class="token punctuation">(</span><span class="token string">'c:\\'</span><span class="token punctuation">,</span> <span class="token string">'Program Files'</span><span class="token punctuation">,</span> <span class="token string">'PSF'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（注意盘符和本地根目录是如何重组的）</p>
<h4 id="方法和特征属性"><a href="#方法和特征属性" class="headerlink" title="方法和特征属性"></a>方法和特征属性</h4><p>纯路径提供以下方法和特征属性：</p>
<pre><code>PurePath.drive</code></pre><p>一个表示驱动器盘符或命名的字符串，如果存在:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>drive
<span class="token string">'c:'</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'/Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>drive
<span class="token string">''</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>drive
<span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>UNC 分享也被认作驱动器:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//host/share/foo.txt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>drive
<span class="token string">'\\\\host\\share'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>PurePath.root</code></p>
<p>一个表示（本地或全局）根的字符串，如果存在:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>root
<span class="token string">'\\'</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>root
<span class="token string">''</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>root
<span class="token string">'/'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>UNC 分享一样拥有根:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//host/share'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>root
<span class="token string">'\\'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>PurePath.anchor</code></p>
<p>驱动器和根的联合:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>anchor
<span class="token string">'c:\\'</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:Program Files/'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>anchor
<span class="token string">'c:'</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>anchor
<span class="token string">'/'</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//host/share'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>anchor
<span class="token string">'\\\\host\\share\\'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>An immutable sequence providing access to the logical ancestors of the path:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/foo/bar/setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/foo/bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/foo'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parents<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.10 版更改: parents 序列现在支持 切片 负的索引值。</p>
<pre><code>PurePath.parent</code></pre><p>此路径的逻辑父路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/a/b/c/d'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parent
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/a/b/c'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>你不能超过一个 anchor 或空路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parent
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parent
PurePosixPath<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>这是一个单纯的词法操作，因此有以下行为:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo/..'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>parent
PurePosixPath<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果你想要向上移动任意文件系统路径，推荐先使用 <code>Path.resolve()</code> 来解析符号链接以及消除 <code>".."</code> 组件。</p>
<pre><code>PurePath.name</code></pre><p>一个表示最后路径组件的字符串，排除了驱动器与根目录，如果存在的话:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library/setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name
<span class="token string">'setup.py'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>UNC 驱动器名不被考虑:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//some/share/setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name
<span class="token string">'setup.py'</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//some/share'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name
<span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.suffix</code></p>
<p>最后一个组件的文件扩展名，如果存在:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library/setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffix
<span class="token string">'.py'</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library.tar.gz'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffix
<span class="token string">'.gz'</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffix
<span class="token string">''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.suffixes</code></p>
<p>路径的文件扩展名列表:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library.tar.gar'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffixes
<span class="token punctuation">[</span><span class="token string">'.tar'</span><span class="token punctuation">,</span> <span class="token string">'.gar'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library.tar.gz'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffixes
<span class="token punctuation">[</span><span class="token string">'.tar'</span><span class="token punctuation">,</span> <span class="token string">'.gz'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>suffixes
<span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.stem</code></p>
<p>最后一个路径组件，除去后缀:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library.tar.gz'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>stem
<span class="token string">'library.tar'</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library.tar'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>stem
<span class="token string">'library'</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'my/library'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>stem
<span class="token string">'library'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.as_posix</code>()</p>
<p>返回使用正斜杠（<code>/</code>）的路径字符串:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:\\windows'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token string">'c:\\windows'</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>as_posix<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'c:/windows'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.as_uri</code>()</p>
<p>将路径表示为 <code>file</code> URL。如果并非绝对路径，抛出 <code>ValueError</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>as_uri<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'file:///etc/passwd'</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Windows'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>as_uri<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'file:///c:/Windows'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.is_absolute</code>()</p>
<p>返回此路径是否为绝对路径。如果路径同时拥有驱动器符与根路径（如果风格允许）则将被认作绝对路径。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/a/b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'a/b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/a/b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'/a/b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'//some/share'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_absolute<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.is_relative_to</code>(<em>\</em>other*)</p>
<p>返回此路径是否相对于 <em>other</em> 的路径。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePath<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>is_relative_to<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>is_relative_to<span class="token punctuation">(</span><span class="token string">'/usr'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>PurePath.is_reserved</code>()</p>
<p>在 <code>PureWindowsPath</code>，如果路径是被 Windows 保留的则返回 <code>True</code>，否则 <code>False</code>。在 <code>PurePosixPath</code>，总是返回 <code>False</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'nul'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_reserved<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'nul'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>is_reserved<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当保留路径上的文件系统被调用，则可能出现玄学失败或者意料之外的效应。</p>
<p><code>PurePath.joinpath</code>(<em>\</em>other*)</p>
<p>调用此方法等同于将每个 <em>other</em> 参数中的项目连接在一起:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">'passwd'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span>PurePosixPath<span class="token punctuation">(</span><span class="token string">'passwd'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">'init.d'</span><span class="token punctuation">,</span> <span class="token string">'apache2'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/init.d/apache2'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>joinpath<span class="token punctuation">(</span><span class="token string">'/Program Files'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.match</code>(<em>pattern</em>)</p>
<p>将此路径与提供的通配符风格的模式匹配。如果匹配成功则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>如果 <em>pattern</em> 是相对的，则路径可以是相对路径或绝对路径，并且匹配是从右侧完成的：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'a/b.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'*.py'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'/a/b/c.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'b/*.py'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'/a/b/c.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'a/*.py'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <em>pattern</em> 是绝对的，则路径必须是绝对的，并且路径必须完全匹配:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'/a.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'/*.py'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> PurePath<span class="token punctuation">(</span><span class="token string">'a/b.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'/*.py'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>与其他方法一样，是否大小写敏感遵循平台的默认规则:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'b.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'*.PY'</span><span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'b.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'*.PY'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.relative_to</code>(<em>\</em>other*)</p>
<p>计算此路径相对 <em>other</em> 表示路径的版本。如果不可计算，则抛出 ValueError:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PurePosixPath<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>relative_to<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'etc/passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>relative_to<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
PurePosixPath<span class="token punctuation">(</span><span class="token string">'passwd'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>relative_to<span class="token punctuation">(</span><span class="token string">'/usr'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"pathlib.py"</span><span class="token punctuation">,</span> line <span class="token number">694</span><span class="token punctuation">,</span> <span class="token keyword">in</span> relative_to
    <span class="token punctuation">.</span>format<span class="token punctuation">(</span>str<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">,</span> str<span class="token punctuation">(</span>formatted<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ValueError<span class="token punctuation">:</span> <span class="token string">'/etc/passwd'</span> <span class="token keyword">is</span> <span class="token operator">not</span> <span class="token keyword">in</span> the subpath of <span class="token string">'/usr'</span> OR one path <span class="token keyword">is</span> relative <span class="token operator">and</span> the other absolute<span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意：此函数是 <code>PurePath</code> 的一部分并且适用于字符串。 它不会检查或访问下层的文件结构。</p>
<p><code>PurePath.with_name</code>(<em>name</em>)</p>
<p>返回一个新的路径并修改 <code>name</code>。如果原本路径没有 name，ValueError 被抛出:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/pathlib.tar.gz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_name<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_name<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"/home/antoine/cpython/default/Lib/pathlib.py"</span><span class="token punctuation">,</span> line <span class="token number">751</span><span class="token punctuation">,</span> <span class="token keyword">in</span> with_name
    <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">"%r has an empty name"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ValueError<span class="token punctuation">:</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/'</span><span class="token punctuation">)</span> has an empty name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>PurePath.with_stem</code>(<em>stem</em>)</p>
<p>返回一个带有修改后 <code>stem</code> 的新路径。 如果原路径没有名称，则会引发 ValueError:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/draft.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_stem<span class="token punctuation">(</span><span class="token string">'final'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/final.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/pathlib.tar.gz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_stem<span class="token punctuation">(</span><span class="token string">'lib'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/lib.gz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_stem<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"/home/antoine/cpython/default/Lib/pathlib.py"</span><span class="token punctuation">,</span> line <span class="token number">861</span><span class="token punctuation">,</span> <span class="token keyword">in</span> with_stem
    <span class="token keyword">return</span> self<span class="token punctuation">.</span>with_name<span class="token punctuation">(</span>stem <span class="token operator">+</span> self<span class="token punctuation">.</span>suffix<span class="token punctuation">)</span>
  File <span class="token string">"/home/antoine/cpython/default/Lib/pathlib.py"</span><span class="token punctuation">,</span> line <span class="token number">851</span><span class="token punctuation">,</span> <span class="token keyword">in</span> with_name
    <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">"%r has an empty name"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>self<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
ValueError<span class="token punctuation">:</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/'</span><span class="token punctuation">)</span> has an empty name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>PurePath.with_suffix</code>(<em>suffix</em>)</p>
<p>返回一个新的路径并修改 <code>suffix</code>。如果原本的路径没有后缀，新的 <em>suffix</em> 则被追加以代替。如果 <em>suffix</em> 是空字符串，则原本的后缀被移除:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/pathlib.tar.gz'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_suffix<span class="token punctuation">(</span><span class="token string">'.bz2'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Downloads/pathlib.tar.bz2'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'README'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_suffix<span class="token punctuation">(</span><span class="token string">'.txt'</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'README.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PureWindowsPath<span class="token punctuation">(</span><span class="token string">'README.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>with_suffix<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
PureWindowsPath<span class="token punctuation">(</span><span class="token string">'README'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="具体路径"><a href="#具体路径" class="headerlink" title="具体路径"></a>具体路径</h3><p>具体路径是纯路径的子类。除了后者提供的操作之外，它们还提供了对路径对象进行系统调用的方法。有三种方法可以实例化具体路径:</p>
<p><em>class</em> <code>pathlib.Path</code>(<em>\</em>pathsegments*)</p>
<p>一个 <code>PurePath</code> 的子类，此类以当前系统的路径风格表示路径（实例化为 <code>PosixPath</code> 或 <code>WindowsPath</code>）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>pathsegments</em> 参数的指定和 <code>PurePath</code> 相同。</p>
<p><em>class</em> <code>pathlib.PosixPath</code>(<em>\</em>pathsegments*)</p>
<p>一个 <code>Path</code> 和 <code>PurePosixPath</code> 的子类，此类表示一个非 Windows 文件系统的具体路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> PosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>pathsegments</em> 参数的指定和 <code>PurePath</code> 相同。</p>
<p><em>class</em> <code>pathlib.WindowsPath</code>(<em>\</em>pathsegments*)</p>
<p><code>Path</code> 和 <code>PureWindowsPath</code> 的子类，从类表示一个 Windows 文件系统的具体路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> WindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files/'</span><span class="token punctuation">)</span>
WindowsPath<span class="token punctuation">(</span><span class="token string">'c:/Program Files'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>pathsegments</em> 参数的指定和 <code>PurePath</code> 相同。</p>
<p>你只能实例化与当前系统风格相同的类（允许系统调用作用于不兼容的路径风格可能在应用程序中导致缺陷或失败）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>name
<span class="token string">'posix'</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> WindowsPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>
  File <span class="token string">"pathlib.py"</span><span class="token punctuation">,</span> line <span class="token number">798</span><span class="token punctuation">,</span> <span class="token keyword">in</span> __new__
    <span class="token operator">%</span> <span class="token punctuation">(</span>cls<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
NotImplementedError<span class="token punctuation">:</span> cannot instantiate <span class="token string">'WindowsPath'</span> on your system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>除纯路径方法外，实体路径还提供以下方法。 如果系统调用失败（例如因为路径不存在）这些方法中许多都会引发 <code>OSError</code>。</p>
<p>在 3.8 版更改: 对于包含 OS 层级无法表示字符的路径，<code>exists()</code>, <code>is_dir()</code>, <code>is_file()</code>, <code>is_mount()</code>, <code>is_symlink()</code>, <code>is_block_device()</code>, <code>is_char_device()</code>, <code>is_fifo()</code>, <code>is_socket()</code> 现在将返回 <code>False</code> 而不是引发异常。</p>
<p><em>classmethod</em> <code>Path.cwd</code>()</p>
<p>返回一个新的表示当前目录的路径对象（和 <code>os.getcwd()</code> 返回的相同）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">.</span>cwd<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/antoine/pathlib'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><em>classmethod</em> <code>Path.home</code>()</p>
<p>返回一个表示用户家目录的新路径对象（与带 <code>~</code> 构造的 <code>os.path.expanduser()</code> 所返回的相同）。 如果无法解析家目录，则会引发 <code>RuntimeError</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">.</span>home<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/antoine'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p><code>Path.stat</code>(<em>**,</em> follow_symlinks=True*)</p>
<p>返回一个 <code>os.stat_result</code> 对象，其中包含有关此路径的信息，例如 <code>os.stat()</code>。 结果会在每次调用此方法时重新搜索。</p>
<p>此方法通常会跟随符号链接；要对 symlink 使用 stat 请添加参数 <code>follow_symlinks=False</code>，或者使用 <code>lstat()</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_size
<span class="token number">956</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_mtime
<span class="token number">1327883547.852554</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.10 版更改: 增加了 <em>follow_symlinks</em> 形参。</p>
<p><code>Path.chmod</code>(<em>mode</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>改变文件模式和权限，和 <code>os.chmod()</code> 一样。</p>
<p>此方法通常会跟随符号链接。 某些 Unix 变种支持改变 symlink 本身的权限；在这些平台上你可以添加参数 <code>follow_symlinks=False</code>，或者使用 <code>lchmod()</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_mode
<span class="token number">33277</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>chmod<span class="token punctuation">(</span><span class="token number">0o444</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_mode
<span class="token number">33060</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.10 版更改: 增加了 <em>follow_symlinks</em> 形参。</p>
<p><code>Path.exists</code>()</p>
<p>此路径是否指向一个已存在的文件或目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'/etc'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">True</span>
<span class="token operator">>></span><span class="token operator">></span> Path<span class="token punctuation">(</span><span class="token string">'nonexistentfile'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>如果路径指向一个符号链接， <code>exists()</code> 返回此符号链接是否指向存在的文件或目录。</p>
<p><code>Path.expanduser</code>()</p>
<p>返回带有扩展 <code>~</code> 和 <code>~user</code> 构造的新路径，与 <code>os.path.expanduser()</code> 所返回的相同。 如果无法解析家目录，则会引发 <code>RuntimeError</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> PosixPath<span class="token punctuation">(</span><span class="token string">'~/films/Monty Python'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/eric/films/Monty Python'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p><code>Path.glob</code>(<em>pattern</em>)</p>
<p>解析相对于此路径的通配符 <em>pattern</em>，产生所有匹配的文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'*.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PosixPath<span class="token punctuation">(</span><span class="token string">'test_pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'*/*.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'docs/conf.py'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>pattern 的形式与 <code>fnmatch</code> 的相同，还增加了 “<code>**</code>“ 表示 “此目录以及所有子目录，递归”。 换句话说，它启用递归通配:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'**/*.py'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'build/lib/pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'docs/conf.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'test_pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>在一个较大的目录树中使用 “<code>**</code>“ 模式可能会消耗非常多的时间。</p>
<p>引发一个 审计事件 <code>pathlib.Path.glob</code> 附带参数 <code>self</code>, <code>pattern</code>。</p>
<p><code>Path.group</code>()</p>
<p>返回拥有此文件的用户组。如果文件的 GID 无法在系统数据库中找到，将抛出 <code>KeyError</code> 。</p>
<p><code>Path.is_dir</code>()</p>
<p>如果路径指向一个目录（或者一个指向目录的符号链接）则返回 <code>True</code>，如果指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_file</code>()</p>
<p>如果路径指向一个正常的文件（或者一个指向正常文件的符号链接）则返回 <code>True</code>，如果指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_mount</code>()</p>
<p>如果路径是一个 <em>挂载点 &lt;mount point&gt;*：在文件系统中被其他不同的文件系统挂载的地点。在 POSIX 系统，此函数检查 *path</em> 的父级 —— <code>path/..</code> 是否处于一个和 <em>path</em> 不同的设备中，或者 file:path/.. 和 <em>path</em> 是否指向相同设备的相同 i-node —— 这能检测所有 Unix 以及 POSIX 变种上的挂载点。 Windows 上未实现。</p>
<p>3.7 新版功能.</p>
<p><code>Path.is_symlink</code>()</p>
<p>如果路径指向符号链接则返回 <code>True</code>， 否则 <code>False</code>。</p>
<p>如果路径不存在也返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_socket</code>()</p>
<p>如果路径指向一个 Unix socket 文件（或者指向 Unix socket 文件的符号链接）则返回 <code>True</code>，如果指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_fifo</code>()</p>
<p>如果路径指向一个先进先出存储（或者指向先进先出存储的符号链接）则返回 <code>True</code> ，指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_block_device</code>()</p>
<p>如果文件指向一个块设备（或者指向块设备的符号链接）则返回 <code>True</code>，指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.is_char_device</code>()</p>
<p>如果路径指向一个字符设备（或指向字符设备的符号链接）则返回 <code>True</code>，指向其他类型的文件则返回 <code>False</code>。</p>
<p>当路径不存在或者是一个破损的符号链接时也会返回 <code>False</code>；其他错误（例如权限错误）被传播。</p>
<p><code>Path.iterdir</code>()</p>
<p>当路径指向一个目录时，产生该路径下的对象的路径:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'docs'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> child <span class="token keyword">in</span> p<span class="token punctuation">.</span>iterdir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> child
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/conf.py'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/_templates'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/make.bat'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/index.rst'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/_build'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/_static'</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'docs/Makefile'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>子条目会以任意顺序生成，并且不包括特殊条目 <code>'.'</code> 和 <code>'..'</code>。 如果有文件在迭代器创建之后在目录中被移除或添加，是否要包括该文件对应的路径对象并没有规定。</p>
<p><code>Path.lchmod</code>(<em>mode</em>)</p>
<p>就像 <code>Path.chmod()</code> 但是如果路径指向符号链接则是修改符号链接的模式，而不是修改符号链接的目标。</p>
<p><code>Path.lstat</code>()</p>
<p>就和 <code>Path.stat()</code> 一样，但是如果路径指向符号链接，则是返回符号链接而不是目标的信息。</p>
<p><code>Path.mkdir</code>(<em>mode=511</em>, <em>parents=False</em>, <em>exist_ok=False</em>)</p>
<p>新建给定路径的目录。如果给出了 <em>mode</em> ，它将与当前进程的 <code>umask</code> 值合并来决定文件模式和访问标志。如果路径已经存在，则抛出 <code>FileExistsError</code>。</p>
<p>如果 <em>parents</em> 为 true，任何找不到的父目录都会伴随着此路径被创建；它们会以默认权限被创建，而不考虑 <em>mode</em> 设置（模仿 POSIX 的 <code>mkdir -p</code> 命令）。</p>
<p>如果 <em>parents</em> 为 false（默认），则找不到的父级目录会导致 <code>FileNotFoundError</code> 被抛出。</p>
<p>如果 <em>exist_ok</em> 为 false（默认），则在目标已存在的情况下抛出 <code>FileExistsError</code>。</p>
<p>如果 <em>exist_ok</em> 为 true， 则 <code>FileExistsError</code> 异常将被忽略（和 POSIX <code>mkdir -p</code> 命令行为相同），但是只有在最后一个路径组件不是现存的非目录文件时才生效。</p>
<p>在 3.5 版更改: <em>exist_ok</em> 形参被加入。</p>
<p><code>Path.open</code>(<em>mode=’r’</em>, <em>buffering=- 1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>)</p>
<p>打开路径指向的文件，就像内置的 <code>open()</code> 函数所做的一样:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> p<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     f<span class="token punctuation">.</span>readline<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token string">'#!/usr/bin/env python3\n'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Path.owner</code>()</p>
<p>返回拥有此文件的用户名。如果文件的 UID 无法在系统数据库中找到，则抛出 <code>KeyError</code>。</p>
<p><code>Path.read_bytes</code>()</p>
<p>以字节对象的形式返回路径指向的文件的二进制内容:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'my_binary_file'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>write_bytes<span class="token punctuation">(</span>b<span class="token string">'Binary file contents'</span><span class="token punctuation">)</span>
<span class="token number">20</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>read_bytes<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'Binary file contents'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p><code>Path.read_text</code>(<em>encoding=None</em>, <em>errors=None</em>)</p>
<p>以字符串形式返回路径指向的文件的解码后文本内容。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'my_text_file'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>write_text<span class="token punctuation">(</span><span class="token string">'Text file contents'</span><span class="token punctuation">)</span>
<span class="token number">18</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>read_text<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'Text file contents'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>文件先被打开然后关闭。有和 <code>open()</code> 一样的可选形参。</p>
<p>3.5 新版功能.</p>
<p><code>Path.readlink</code>()</p>
<p>返回符号链接所指向的路径（即 <code>os.readlink()</code> 的返回值）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'mylink'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>symlink_to<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>readlink<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.9 新版功能.</p>
<p><code>Path.rename</code>(<em>target</em>)</p>
<p>将文件或目录重命名为给定的 <em>target*，并返回一个新的指向 *target</em> 的 Path 实例。 在 Unix 上，如果 <em>target</em> 存在且为一个文件，如果用户有足够权限，则它将被静默地替换。 <em>target</em> 可以是一个字符串或者另一个路径对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'w'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'some text'</span><span class="token punctuation">)</span>
<span class="token number">9</span>
<span class="token operator">>></span><span class="token operator">></span> target <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>rename<span class="token punctuation">(</span>target<span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> target<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'some text'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>目标路径可能为绝对或相对路径。 相对路径将被解释为相对于当前工作目录，而 <em>不是</em> 相对于 Path 对象的目录。</p>
<p>在 3.8 版更改: 添加了返回值，返回新的 Path 实例。</p>
<p><code>Path.replace</code>(<em>target</em>)</p>
<p>将文件名目录重命名为给定的 <em>target*，并返回一个新的指向 *target</em> 的 Path 实例。 如果 <em>target</em> 指向一个现有文件或目录，则它将被无条件地替换。</p>
<p>目标路径可能为绝对或相对路径。 相对路径将被解释为相对于当前工作目录，而 <em>不是</em> 相对于 Path 对象的目录。</p>
<p>在 3.8 版更改: 添加了返回值，返回新的 Path 实例。</p>
<p><code>Path.resolve</code>(<em>strict=False</em>)</p>
<p>将路径绝对化，解析任何符号链接。返回新的路径对象:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p
PosixPath<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/antoine/pathlib'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>“<code>..</code>“ 组件也将被消除（只有这一种方法这么做）:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'docs/../setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/antoine/pathlib/setup.py'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果路径不存在并且 <em>strict</em> 设为 <code>True</code>，则抛出 <code>FileNotFoundError</code>。如果 <em>strict</em> 为 <code>False</code>，则路径将被尽可能地解析并且任何剩余部分都会被不检查是否存在地追加。如果在解析路径上发生无限循环，则抛出 <code>RuntimeError</code>。</p>
<p>3.6 新版功能: 加入<em>strict</em> 参数（3.6之前的版本相当于strict值为True）</p>
<p><code>Path.rglob</code>(<em>pattern</em>)</p>
<p>这就像调用 <code>Path.glob</code>时在给定的相对 <em>pattern</em> 前面添加了”``**/<code>()</code>“</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> sorted<span class="token punctuation">(</span>Path<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rglob<span class="token punctuation">(</span><span class="token string">"*.py"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>PosixPath<span class="token punctuation">(</span><span class="token string">'build/lib/pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'docs/conf.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 PosixPath<span class="token punctuation">(</span><span class="token string">'test_pathlib.py'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>引发一个 审计事件 <code>pathlib.Path.rglob</code> 附带参数 <code>self</code>, <code>pattern</code>。</p>
<p><code>Path.rmdir</code>()</p>
<p>移除此目录。此目录必须为空的。</p>
<p><code>Path.samefile</code>(<em>other_path</em>)</p>
<p>返回此目录是否指向与可能是字符串或者另一个路径对象的 <em>other_path</em> 相同的文件。语义类似于 <code>os.path.samefile()</code> 与 <code>os.path.samestat()</code>。</p>
<p>如果两者都以同一原因无法访问，则抛出 <code>OSError</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> q <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'eggs'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>samefile<span class="token punctuation">(</span>q<span class="token punctuation">)</span>
<span class="token boolean">False</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>samefile<span class="token punctuation">(</span><span class="token string">'spam'</span><span class="token punctuation">)</span>
<span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p><code>Path.symlink_to</code>(<em>target</em>, <em>target_is_directory=False</em>)</p>
<p>将此路径创建为指向 <em>target</em> 的符号链接。在 Windows 下，如果链接的目标是一个目录则 <em>target_is_directory</em> 必须为 true （默认为 <code>False</code>）。在 POSIX 下， <em>target_is_directory</em> 的值将被忽略。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'mylink'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>symlink_to<span class="token punctuation">(</span><span class="token string">'setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>resolve<span class="token punctuation">(</span><span class="token punctuation">)</span>
PosixPath<span class="token punctuation">(</span><span class="token string">'/home/antoine/pathlib/setup.py'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>stat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_size
<span class="token number">956</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>lstat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>st_size
<span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注解</p>
<p>参数的顺序（link, target) 和 <code>os.symlink()</code> 是相反的。</p>
<p><code>Path.hardlink_to</code>(<em>target</em>)</p>
<p>将此路径设为一个指向与 <em>target</em> 相同文件的硬链接。</p>
<p>注解</p>
<p>参数顺序 (link, target) 和 <code>os.link()</code> 是相反的。</p>
<p>3.10 新版功能.</p>
<p><code>Path.link_to</code>(<em>target</em>)</p>
<p>创建硬链接 <em>target</em> 指向此路径。</p>
<p>警告</p>
<p>此函数不会将此路径设为指向 <em>target</em> 的硬链接，尽管此函数名和参数名有此含义。 参数顺序 (target, link) 与 <code>Path.symlink_to()</code> 和 <code>Path.hardlink_to()</code> 相反，而与 <code>os.link()</code> 的一致。</p>
<p>3.8 新版功能.</p>
<p>3.10 版后已移除: 此方法已被弃用而建议改用 <code>Path.hardlink_to()</code>，因为 <code>Path.link_to()</code> 的参数顺序与 <code>Path.symlink_to()</code> 的不相匹配。</p>
<p><code>Path.touch</code>(<em>mode=438</em>, <em>exist_ok=True</em>)</p>
<p>将给定的路径创建为文件。如果给出了 <em>mode</em> 它将与当前进程的 <code>umask</code> 值合并以确定文件的模式和访问标志。如果文件已经存在，则当 <em>exist_ok</em> 为 true 则函数仍会成功（并且将它的修改事件更新为当前事件），否则抛出 <code>FileExistsError</code>。</p>
<p><code>Path.unlink</code>(<em>missing_ok=False</em>)</p>
<p>移除此文件或符号链接。如果路径指向目录，则用 <code>Path.rmdir()</code> 代替。</p>
<p>如果 <em>missing_ok</em> 为假值（默认），则如果路径不存在将会引发 <code>FileNotFoundError</code>。</p>
<p>如果 <em>missing_ok</em> 为真值，则 <code>FileNotFoundError</code> 异常将被忽略（和 POSIX <code>rm -f</code> 命令的行为相同）。</p>
<p>在 3.8 版更改: 增加了 <em>missing_ok</em> 形参。</p>
<p><code>Path.write_bytes</code>(<em>data</em>)</p>
<p>将文件以二进制模式打开，写入 <em>data</em> 并关闭:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'my_binary_file'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>write_bytes<span class="token punctuation">(</span>b<span class="token string">'Binary file contents'</span><span class="token punctuation">)</span>
<span class="token number">20</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>read_bytes<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'Binary file contents'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个同名的现存文件将被覆盖。</p>
<p>3.5 新版功能.</p>
<p><code>Path.write_text</code>(<em>data</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>)</p>
<p>将文件以文本模式打开，写入 <em>data</em> 并关闭:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> p <span class="token operator">=</span> Path<span class="token punctuation">(</span><span class="token string">'my_text_file'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>write_text<span class="token punctuation">(</span><span class="token string">'Text file contents'</span><span class="token punctuation">)</span>
<span class="token number">18</span>
<span class="token operator">>></span><span class="token operator">></span> p<span class="token punctuation">.</span>read_text<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token string">'Text file contents'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同名的现有文件会被覆盖。 可选形参的含义与 <code>open()</code> 的相同。</p>
<p>3.5 新版功能.</p>
<p>在 3.10 版更改: 增加了 <em>newline</em> 形参。</p>
<h3 id="对应的-os-模块的工具"><a href="#对应的-os-模块的工具" class="headerlink" title="对应的 os 模块的工具"></a>对应的 <code>os</code> 模块的工具</h3><p>以下是一个映射了 <code>os</code> 与 <code>PurePath</code>/<code>Path</code> 对应相同的函数的表。</p>
<p>注解</p>
<p>以下函数/方法对并不完全等价。 它们有些虽然具有相互重叠的使用场景，但语义并不相同。 这包括了 <code>os.path.abspath()</code> 和 <code>Path.resolve()</code>，以及 <code>os.path.relpath()</code> 和 <code>PurePath.relative_to()</code>。</p>
<table>
<thead>
<tr>
<th align="left"><code>os</code> 和 <code>os.path</code></th>
<th align="left"><code>pathlib</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>os.path.abspath()</code></td>
<td align="left"><code>Path.resolve()</code></td>
</tr>
<tr>
<td align="left"><code>os.chmod()</code></td>
<td align="left"><code>Path.chmod()</code></td>
</tr>
<tr>
<td align="left"><code>os.mkdir()</code></td>
<td align="left"><code>Path.mkdir()</code></td>
</tr>
<tr>
<td align="left"><code>os.makedirs()</code></td>
<td align="left"><code>Path.mkdir()</code></td>
</tr>
<tr>
<td align="left"><code>os.rename()</code></td>
<td align="left"><code>Path.rename()</code></td>
</tr>
<tr>
<td align="left"><code>os.replace()</code></td>
<td align="left"><code>Path.replace()</code></td>
</tr>
<tr>
<td align="left"><code>os.rmdir()</code></td>
<td align="left"><code>Path.rmdir()</code></td>
</tr>
<tr>
<td align="left"><code>os.remove()</code>, <code>os.unlink()</code></td>
<td align="left"><code>Path.unlink()</code></td>
</tr>
<tr>
<td align="left"><code>os.getcwd()</code></td>
<td align="left"><code>Path.cwd()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.exists()</code></td>
<td align="left"><code>Path.exists()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.expanduser()</code></td>
<td align="left"><code>Path.expanduser()</code> 和 <code>Path.home()</code></td>
</tr>
<tr>
<td align="left"><code>os.listdir()</code></td>
<td align="left"><code>Path.iterdir()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.isdir()</code></td>
<td align="left"><code>Path.is_dir()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.isfile()</code></td>
<td align="left"><code>Path.is_file()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.islink()</code></td>
<td align="left"><code>Path.is_symlink()</code></td>
</tr>
<tr>
<td align="left"><code>os.link()</code></td>
<td align="left"><code>Path.hardlink_to()</code></td>
</tr>
<tr>
<td align="left"><code>os.symlink()</code></td>
<td align="left"><code>Path.symlink_to()</code></td>
</tr>
<tr>
<td align="left"><code>os.readlink()</code></td>
<td align="left"><code>Path.readlink()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.relpath()</code></td>
<td align="left"><code>Path.relative_to()</code></td>
</tr>
<tr>
<td align="left"><code>os.stat()</code></td>
<td align="left"><code>Path.stat()</code>, <code>Path.owner()</code>, <code>Path.group()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.isabs()</code></td>
<td align="left"><code>PurePath.is_absolute()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.join()</code></td>
<td align="left"><code>PurePath.joinpath()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.basename()</code></td>
<td align="left"><code>PurePath.name</code></td>
</tr>
<tr>
<td align="left"><code>os.path.dirname()</code></td>
<td align="left"><code>PurePath.parent</code></td>
</tr>
<tr>
<td align="left"><code>os.path.samefile()</code></td>
<td align="left"><code>Path.samefile()</code></td>
</tr>
<tr>
<td align="left"><code>os.path.splitext()</code></td>
<td align="left"><code>PurePath.suffix</code></td>
</tr>
</tbody></table>
<h2 id="os-path-—-常用路径操作"><a href="#os-path-—-常用路径操作" class="headerlink" title="os.path —- 常用路径操作"></a><code>os.path</code> —- 常用路径操作</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/posixpath.py" target="_blank" rel="noopener">Lib/posixpath.py</a> （用于 POSIX）和 <a href="https://github.com/python/cpython/tree/3.10/Lib/ntpath.py" target="_blank" rel="noopener">Lib/ntpath.py</a> （用于 Windows NT）</p>
<hr>
<p>该模块在路径名上实现了一些有用的功能。路径参数可以字符串或字节形式传递。我们鼓励应用程序将文件名表示为（Unicode）字符串。不幸的是，某些文件名在Unix上可能无法用字符串表示，因此在Unix上平台上需要支持任意文件名的应用程序，应使用字节对象来表示路径名。反之亦然，在Windows平台上仅使用字节对象，不能表示的所有文件名（以标准 <code>mbcs</code> 编码），因此Windows应用程序应使用字符串对象来访问所有文件。</p>
<p>与unix shell不同，Python不执行任何 <em>自动</em> 路径扩展。当应用程序需要类似shell的路径扩展时，可以显式调用诸如 <code>expanduser()</code> 和 <code>expandvars()</code> 之类的函数。 </p>
<p>参见</p>
<p><code>pathlib</code> 模块提供高级路径对象。</p>
<p>注解</p>
<p>所有这些函数都仅接受字节或字符串对象作为其参数。如果返回路径或文件名，则结果是相同类型的对象。</p>
<p>注解</p>
<p>由于不同的操作系统具有不同的路径名称约定，因此标准库中有此模块的几个版本。<code>os.path</code> 模块始终是适合 Python 运行的操作系统的路径模块，因此可用于本地路径。但是，如果操作的路径 <em>总是</em> 以一种不同的格式显示，那么也可以分别导入和使用各个模块。它们都具有相同的接口：</p>
<ul>
<li><code>posixpath</code> 用于Unix 样式的路径</li>
<li><code>ntpath</code> 用于 Windows 路径</li>
</ul>
<p>在 3.8 版更改: <code>exists()</code>、<code>lexists()</code>、<code>isdir()</code>、<code>isfile()</code>、<code>islink()</code> 和 <code>ismount()</code> 现在遇到系统层面上不可表示的字符或字节的路径时，会返回 <code>False</code>，而不是抛出异常。</p>
<p><code>os.path.abspath</code>(<em>path</em>)</p>
<p>返回路径 <em>path</em> 的绝对路径（标准化的）。在大多数平台上，这等同于用 <code>normpath(join(os.getcwd(), path))</code> 的方式调用 <code>normpath()</code> 函数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.basename</code>(<em>path</em>)</p>
<p>返回路径 <em>path</em> 的基本名称。这是将 <em>path</em> 传入函数 <code>split()</code> 之后，返回的一对值中的第二个元素。请注意，此函数的结果与Unix <strong>basename</strong> 程序不同。<strong>basename</strong> 在 <code>'/foo/bar/'</code> 上返回 <code>'bar'</code>，而 <code>basename()</code> 函数返回一个空字符串 (<code>''</code>)。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.commonpath</code>(<em>paths</em>)</p>
<p>接受包含多个路径的序列 <em>paths*，返回 *paths</em> 的最长公共子路径。如果 <em>paths</em> 同时包含绝对路径和相对路径，或 <em>paths</em> 在不同的驱动器上，或 <em>paths</em> 为空，则抛出 <code>ValueError</code> 异常。与 <code>commonprefix()</code> 不同，本方法返回有效路径。</p>
<p>可用性: Unix, Windows。</p>
<p>3.5 新版功能.</p>
<p>在 3.6 版更改: 接受一个 类路径对象 序列。</p>
<p><code>os.path.commonprefix</code>(<em>list</em>)</p>
<p>接受包含多个路径的 <em>列表*，返回所有路径的最长公共前缀（逐字符比较）。如果 *列表</em> 为空，则返回空字符串 (<code>''</code>)。</p>
<p>注解</p>
<p>此函数是逐字符比较，因此可能返回无效路径。要获取有效路径，参见 <code>commonpath()</code>。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>commonprefix<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'/usr/lib'</span><span class="token punctuation">,</span> <span class="token string">'/usr/local/lib'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">'/usr/l'</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>commonpath<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'/usr/lib'</span><span class="token punctuation">,</span> <span class="token string">'/usr/local/lib'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token string">'/usr'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.dirname</code>(<em>path</em>)</p>
<p>返回路径 <em>path</em> 的目录名称。这是将 <em>path</em> 传入函数 <code>split()</code> 之后，返回的一对值中的第一个元素。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.exists</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 指向一个已存在的路径或已打开的文件描述符，返回 <code>True</code>。对于失效的符号链接，返回 <code>False</code>。在某些平台上，如果使用 <code>os.stat()</code> 查询到目标文件没有执行权限，即使 <em>path</em> 确实存在，本函数也可能返回 <code>False</code>。</p>
<p>在 3.3 版更改: <em>path</em> 现在可以是一个整数：如果该整数是一个已打开的文件描述符，返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.lexists</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 指向一个已存在的路径，返回 <code>True</code>。对于失效的符号链接，也返回 <code>True</code>。在缺失 <code>os.lstat()</code> 的平台上等同于 <code>exists()</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.expanduser</code>(<em>path</em>)</p>
<p>在 Unix 和 Windows 上，将参数中开头部分的 <code>~</code> 或 <code>~user</code> 替换为当前 <em>用户</em> 的家目录并返回。</p>
<p>在 Unix 上，开头的 <code>~</code> 会被环境变量 <code>HOME</code> 代替，如果变量未设置，则通过内置模块 <code>pwd</code> 在 password 目录中查找当前用户的主目录。以 <code>~user</code> 开头则直接在 password 目录中查找。</p>
<p>在 Windows 上，如果 <code>USERPROFILE</code> 已设置将会被使用，否则 <code>HOMEPATH</code> 和 <code>HOMEDRIVE</code> 将被组合起来使用。 初始的 <code>~user</code> 会通过检查当前用户的家目录中匹配 <code>USERNAME</code> 的最后一部分目录名并执行替换来处理。</p>
<p>如果展开路径失败，或者路径不是以波浪号开头，则路径将保持不变。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>在 3.8 版更改: Windows 不再使用 <code>HOME</code>。</p>
<p><code>os.path.expandvars</code>(<em>path</em>)</p>
<p>输入带有环境变量的路径作为参数，返回展开变量以后的路径。<code>$name</code> 或 <code>${name}</code> 形式的子字符串被环境变量 <em>name</em> 的值替换。格式错误的变量名称和对不存在变量的引用保持不变。</p>
<p>在 Windows 上，除了 <code>$name</code> 和 <code>${name}</code> 外，还可以展开 <code>%name%</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.getatime</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 的最后访问时间。返回值是一个浮点数，为纪元秒数。如果该文件不存在或不可访问，则抛出 <code>OSError</code> 异常。</p>
<p><code>os.path.getmtime</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 的最后修改时间。返回值是一个浮点数，为纪元秒数。如果该文件不存在或不可访问，则抛出 <code>OSError</code> 异常。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.getctime</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 在系统中的 ctime，在有些系统（比如 Unix）上，它是元数据的最后修改时间，其他系统（比如 Windows）上，它是 <em>path</em> 的创建时间。返回值是一个数，为纪元秒数。如果该文件不存在或不可访问，则抛出 <code>OSError</code> 异常。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.getsize</code>(<em>path</em>)</p>
<p>返回 <em>path</em> 的大小，以字节为单位。如果该文件不存在或不可访问，则抛出 <code>OSError</code> 异常。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.isabs</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 是一个绝对路径，则返回 <code>True</code>。在 Unix 上，它就是以斜杠开头，而在 Windows 上，它可以是去掉驱动器号后以斜杠（或反斜杠）开头。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.isfile</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 是 <code>现有的</code> 常规文件，则返回 <code>True</code>。本方法会跟踪符号链接，因此，对于同一路径，<code>islink()</code> 和 <code>isfile()</code> 都可能为 <code>True</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.isdir</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 是 <code>现有的</code> 目录，则返回 <code>True</code>。本方法会跟踪符号链接，因此，对于同一路径，<code>islink()</code> 和 <code>isdir()</code> 都可能为 <code>True</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.islink</code>(<em>path</em>)</p>
<p>如果 <em>path</em> 指向的 <code>现有</code> 目录条目是一个符号链接，则返回 <code>True</code>。如果 Python 运行时不支持符号链接，则总是返回 <code>False</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.ismount</code>(<em>path</em>)</p>
<p>如果路径 <em>path</em> 是 <em>挂载点</em> （文件系统中挂载其他文件系统的点），则返回 <code>True</code>。在 POSIX 上，该函数检查 <em>path</em> 的父目录 <code>*path*/..</code> 是否在与 <em>path</em> 不同的设备上，或者 <code>*path*/..</code> 和 <em>path</em> 是否指向同一设备上的同一 inode（这一检测挂载点的方法适用于所有 Unix 和 POSIX 变体）。本方法不能可靠地检测同一文件系统上的绑定挂载 (bind mount)。在 Windows 上，盘符和共享 UNC 始终是挂载点，对于任何其他路径，将调用 <code>GetVolumePathName</code> 来查看它是否与输入的路径不同。</p>
<p>3.4 新版功能: 支持在 Windows 上检测非根挂载点。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.join</code>(<em>path</em>, <em>\</em>paths*)</p>
<p>智能地拼接一个或多个路径部分。 返回值是 <em>path</em> 和 <em>\</em>paths* 的所有成员的拼接，其中每个非空部分后面都紧跟一个目录分隔符，最后一个部分除外，这意味着如果最后一个部分为空，则结果将以分隔符结尾。 如果某个部分为绝对路径，则之前的所有部分会被丢弃并从绝对路径部分开始继续拼接。</p>
<p>在 Windows 上，遇到绝对路径部分（例如 <code>r'\foo'</code>）时，不会重置盘符。如果某部分路径包含盘符，则会丢弃所有先前的部分，并重置盘符。请注意，由于每个驱动器都有一个“当前目录”，所以 <code>os.path.join("c:", "foo")</code> 表示驱动器 <code>C:</code> 上当前目录的相对路径 (<code>c:foo</code>)，而不是 <code>c:\foo</code>。</p>
<p>在 3.6 版更改: 接受一个 类路径对象 用于 <em>path</em> 和 <em>paths</em> 。</p>
<p><code>os.path.normcase</code>(<em>path</em>)</p>
<p>规范路径的大小写。在 Windows 上，将路径中的所有字符都转换为小写，并将正斜杠转换为反斜杠。在其他操作系统上返回原路径。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.normpath</code>(<em>path</em>)</p>
<blockquote>
<p>通过折叠多余的分隔符和对上级目录的引用来标准化路径名，所以 <code>A//B</code>、<code>A/B/</code>、<code>A/./B</code> 和 <code>A/foo/../B</code> 都会转换成 <code>A/B</code>。这个字符串操作可能会改变带有符号链接的路径的含义。在 Windows 上，本方法将正斜杠转换为反斜杠。要规范大小写，请使用 <code>normcase()</code>。</p>
</blockquote>
<p>注解</p>
<blockquote>
<p>在 POSIX 系统上，根据 <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_13" target="_blank" rel="noopener">IEEE Std 1003.1 2013 Edition; 4.13 Pathname Resolution</a>，如果一个路径名称以两个斜杠开始，则开始字符之后的第一个部分将以具体实现所定义的方式来解读，但是超过两个开始字符则将被视为单个字符。</p>
</blockquote>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.realpath</code>(<em>path</em>, <em>**,</em> strict=False*)</p>
<p>返回指定文件的规范路径，消除路径中存在的任何符号链接（如果操作系统支持）。</p>
<p>如果一个路径不存在或是遇到了符号链接循环，并且 <em>strict</em> 为 <code>True</code>，则会引发 <code>OSError</code>。 如果 <em>strict</em> 为 <code>False</code>，则会尽可能地解析路径并添加结果而不检查路径是否存在。</p>
<p>注解</p>
<p>这个函数会模拟操作系统生成规范路径的过程，Windows 与 UNIX 的这个过程在处理链接和后续路径组成部分的交互方式上有所差异。</p>
<p>操作系统 API 会根据需要来规范化路径，因此通常不需要调用此函数。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p>在 3.8 版更改: 在 Windows 上现在可以正确解析符号链接和交接点 (junction point)。</p>
<p>在 3.10 版更改: 增加了 <em>strict</em> 形参。</p>
<p><code>os.path.relpath</code>(<em>path</em>, <em>start=os.curdir</em>)</p>
<p>返回从当前目录或可选的 <em>start</em> 目录至 <em>path</em> 的相对文件路径。 这只是一个路径计算：不会访问文件系统来确认 <em>path</em> 或 <em>start</em> 是否存在或其性质。 在 Windows 上，当 <em>path</em> 和 <em>start</em> 位于不同驱动器时将引发 <code>ValueError</code>。</p>
<p><em>start</em> 默认为 <code>os.curdir</code>。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.samefile</code>(<em>path1</em>, <em>path2</em>)</p>
<p>如果两个路径都指向相同的文件或目录，则返回 <code>True</code>。这由设备号和 inode 号确定，在任一路径上调用 <code>os.stat()</code> 失败则抛出异常。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.2 版更改: 添加了对 Windows 的支持。</p>
<p>在 3.4 版更改: Windows现在使用与其他所有平台相同的实现。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.sameopenfile</code>(<em>fp1</em>, <em>fp2</em>)</p>
<p>如果文件描述符 <em>fp1</em> 和 <em>fp2</em> 指向相同文件，则返回 <code>True</code>。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.2 版更改: 添加了对 Windows 的支持。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.samestat</code>(<em>stat1</em>, <em>stat2</em>)</p>
<p>如果 stat 元组 <em>stat1</em> 和 <em>stat2</em> 指向相同文件，则返回 <code>True</code>。这些 stat 元组可能是由 <code>os.fstat()</code>、<code>os.lstat()</code> 或 <code>os.stat()</code> 返回的。本函数实现了 <code>samefile()</code> 和 <code>sameopenfile()</code> 底层所使用的比较过程。</p>
<p>可用性: Unix, Windows。</p>
<p>在 3.4 版更改: 添加了对 Windows 的支持。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.split</code>(<em>path</em>)</p>
<p>将路径 <em>path</em> 拆分为一对，即 <code>(head, tail)</code>，其中，<em>tail</em> 是路径的最后一部分，而 <em>head</em> 里是除最后部分外的所有内容。<em>tail</em> 部分不会包含斜杠，如果 <em>path</em> 以斜杠结尾，则 <em>tail</em> 将为空。如果 <em>path</em> 中没有斜杠，<em>head</em> 将为空。如果 <em>path</em> 为空，则 <em>head</em> 和 <em>tail</em> 均为空。<em>head</em> 末尾的斜杠会被去掉，除非它是根目录（即它仅包含一个或多个斜杠）。在所有情况下，<code>join(head, tail)</code> 指向的位置都与 <em>path</em> 相同（但字符串可能不同）。另请参见函数 <code>dirname()</code> 和 <code>basename()</code>。</p>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.splitdrive</code>(<em>path</em>)</p>
<p>将路径 <em>path</em> 拆分为一对，即 <code>(drive, tail)</code>，其中 <em>drive</em> 是挂载点或空字符串。在没有驱动器概念的系统上，<em>drive</em> 将始终为空字符串。在所有情况下，<code>drive + tail</code> 都与 <em>path</em> 相同。</p>
<p>在 Windows 上，本方法将路径拆分为驱动器/UNC 根节点和相对路径。</p>
<p>如果路径 path 包含盘符，则 drive 将包含冒号之前的所有内容包括冒号本身:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> splitdrive<span class="token punctuation">(</span><span class="token string">"c:/dir"</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">"c:"</span><span class="token punctuation">,</span> <span class="token string">"/dir"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果路径 path 包含 UNC 路径，则 drive 将包含主机名和 share，直至第四个分隔符但不包括该分隔符:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> splitdrive<span class="token punctuation">(</span><span class="token string">"//host/computer/dir"</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">"//host/computer"</span><span class="token punctuation">,</span> <span class="token string">"/dir"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<p><code>os.path.splitext</code>(<em>path</em>)</p>
<p>将路径名称 <em>path</em> 拆分为 <code>(root, ext)</code> 对使得 <code>root + ext == path</code>，并且扩展名 <em>ext</em> 为空或以句点打头并最多只包含一个句点。</p>
<p>如果路径 path 不包含扩展名，则 <em>ext</em> 将为 <code>''</code>:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> splitext<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果路径 path 包含扩展名，则 <em>ext</em> 将被设为该扩展名，包括打头的句点。 请注意在其之前的句点将被忽略:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> splitext<span class="token punctuation">(</span><span class="token string">'foo.bar.exe'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'foo.bar'</span><span class="token punctuation">,</span> <span class="token string">'.exe'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>基本名中打头的句点会被忽略:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> splitext<span class="token punctuation">(</span><span class="token string">'.cshrc'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">'.cshrc'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.6 版更改: 接受一个 path-like object。</p>
<pre><code>os.path.supports_unicode_filenames</code></pre><h2 id="fileinput-—-迭代来自多个输入流的行"><a href="#fileinput-—-迭代来自多个输入流的行" class="headerlink" title="fileinput —- 迭代来自多个输入流的行"></a><code>fileinput</code> —- 迭代来自多个输入流的行</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/fileinput.py" target="_blank" rel="noopener">Lib/fileinput.py</a></p>
<hr>
<p>此模块实现了一个辅助类和一些函数用来快速编写访问标准输入或文件列表的循环。 </p>
<p>典型用法为:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> fileinput
<span class="token keyword">for</span> line <span class="token keyword">in</span> fileinput<span class="token punctuation">.</span>input<span class="token punctuation">(</span>encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    process<span class="token punctuation">(</span>line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>此程序会迭代 <code>sys.argv[1:]</code> 中列出的所有文件内的行，如果列表为空则会使用 <code>sys.stdin</code>。 如果有一个文件名为 <code>'-'</code>，它也会被替换为 <code>sys.stdin</code> 并且可选参数 <em>mode</em> 和 <em>openhook</em> 会被忽略。 要指定替代文件列表，请将其作为第一个参数传给 <code>input()</code>。 也允许使用单个文件。</p>
<p>所有文件都默认以文本模式打开，但你可以通过在调用 <code>input()</code> 或 <code>FileInput</code> 时指定 <em>mode</em> 形参来重载此行为。 如果在打开或读取文件时发生了 I/O 错误，将会引发 <code>OSError</code>。</p>
<p>在 3.3 版更改: 原来会引发 <code>IOError</code>；现在它是 <code>OSError</code> 的别名。</p>
<p>如果 <code>sys.stdin</code> 被使用超过一次，则第二次之后的使用将不返回任何行，除非是被交互式的使用，或都是被显式地重置 (例如使用 <code>sys.stdin.seek(0)</code>)。</p>
<p>空文件打开后将立即被关闭；它们在文件列表中会被注意到的唯一情况只有当最后打开的文件为空的时候。</p>
<p>反回的行不会对换行符做任何处理，这意味着文件中的最后一行可能不带换行符。</p>
<p>You can control how files are opened by providing an opening hook via the <em>openhook</em> parameter to <code>fileinput.input()</code> or <code>FileInput()</code>. The hook must be a function that takes two arguments, <em>filename</em> and <em>mode</em>, and returns an accordingly opened file-like object. If <em>encoding</em> and/or <em>errors</em> are specified, they will be passed to the hook as aditional keyword arguments. This module provides a <code>hook_compressed()</code> to support compressed files.</p>
<p>以下函数是此模块的初始接口：</p>
<p><code>fileinput.input</code>(<em>files=None</em>, <em>inplace=False</em>, <em>backup=’’</em>, <em>**,</em> mode=’r’<em>,</em> openhook=None<em>,</em> encoding=None<em>,</em> errors=None*)</p>
<p>创建一个 <code>FileInput</code> 类的实例。 该实例将被用作此模块中函数的全局状态，并且还将在迭代期间被返回使用。 此函数的形参将被继续传递给 <code>FileInput</code> 类的构造器。</p>
<p><code>FileInput</code> 实例可以在 <code>with</code> 语句中被用作上下文管理器。 在这个例子中，<em>input</em> 在 <code>with</code> 语句结束后将会被关闭，即使发生了异常也是如此:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> fileinput<span class="token punctuation">.</span>input<span class="token punctuation">(</span>files<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'spam.txt'</span><span class="token punctuation">,</span> <span class="token string">'eggs.txt'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>
        process<span class="token punctuation">(</span>line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在 3.2 版更改: 可以被用作上下文管理器。</p>
<p>在 3.8 版更改: 关键字形参 <em>mode</em> 和 <em>openhook</em> 现在是仅限关键字形参。</p>
<p>在 3.10 版更改: 增加了仅限关键字形参 <em>encoding</em> 和 <em>errors</em>。</p>
<p>下列函数会使用 <code>fileinput.input()</code> 所创建的全局状态；如果没有活动的状态，则会引发 <code>RuntimeError</code>。</p>
<p><code>fileinput.filename</code>()</p>
<p>返回当前被读取的文件名。 在第一行被读取之前，返回 <code>None</code>。</p>
<p><code>fileinput.fileno</code>()</p>
<p>返回以整数表示的当前文件“文件描述符”。 当未打开文件时（处在第一行和文件之间），返回 <code>-1</code>。</p>
<p><code>fileinput.lineno</code>()</p>
<p>返回已被读取的累计行号。 在第一行被读取之前，返回 <code>0</code>。 在最后一个文件的最后一行被读取之后，返回该行的行号。</p>
<p><code>fileinput.filelineno</code>()</p>
<p>返回当前文件中的行号。 在第一行被读取之前，返回 <code>0</code>。 在最后一个文件的最后一行被读取之后，返回此文件中该行的行号。</p>
<p><code>fileinput.isfirstline</code>()</p>
<p>如果刚读取的行是其所在文件的第一行则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p><code>fileinput.isstdin</code>()</p>
<p>如果最后读取的行来自 <code>sys.stdin</code> 则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p><code>fileinput.nextfile</code>()</p>
<p>关闭当前文件以使下次迭代将从下一个文件（如果存在）读取第一行；不是从该文件读取的行将不会被计入累计行数。 直到下一个文件的第一行被读取之后文件名才会改变。 在第一行被读取之前，此函数将不会生效；它不能被用来跳过第一个文件。 在最后一个文件的最后一行被读取之后，此函数将不再生效。</p>
<p><code>fileinput.close</code>()</p>
<p>关闭序列。</p>
<p>此模块所提供的实现了序列行为的类同样也可用于子类化：</p>
<p><em>class</em> <code>fileinput.FileInput</code>(<em>files=None</em>, <em>inplace=False</em>, <em>backup=’’</em>, <em>**,</em> mode=’r’<em>,</em> openhook=None<em>,</em> encoding=None<em>,</em> errors=None*)</p>
<p>类 <code>FileInput</code> 是一个实现；它的方法 <code>filename()</code>, <code>fileno()</code>, <code>lineno()</code>, <code>filelineno()</code>, <code>isfirstline()</code>, <code>isstdin()</code>, <code>nextfile()</code> 和 <code>close()</code> 对应于此模块中具有相同名称的函数。 此外它还有一个 <code>readline()</code> 方法可返回下一个输入行，以及一个 <code>__getitem__()</code> 方法，该方法实现了序列行为。 这种序列必须以严格的序列顺序来读写；随机读写和 <code>readline()</code> 不可以被混用。</p>
<p>通过 <em>mode</em> 你可以指定要传给 <code>open()</code> 的文件模式。 它必须为 <code>'r'</code>, <code>'rU'</code>, <code>'U'</code> 和 <code>'rb'</code> 中的一个。</p>
<p><em>openhook</em> 如果给出则必须为一个函数，它接受两个参数 <em>filename</em> 和 <em>mode*，并相应地返回一个打开的文件类对象。 你不能同时使用 *inplace</em> 和 <em>openhook</em>。</p>
<p>你可以指定 <em>encoding</em> 和 <em>errors</em> 来将其传给 <code>open()</code> 或 <em>openhook</em>。</p>
<p><code>FileInput</code> 实例可以在 <code>with</code> 语句中被用作上下文管理器。 在这个例子中，<em>input</em> 在 <code>with</code> 语句结束后将会被关闭，即使发生了异常也是如此:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> FileInput<span class="token punctuation">(</span>files<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'spam.txt'</span><span class="token punctuation">,</span> <span class="token string">'eggs.txt'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">as</span> input<span class="token punctuation">:</span>
    process<span class="token punctuation">(</span>input<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在 3.2 版更改: 可以被用作上下文管理器。</p>
<p>3.4 版后已移除: <code>'rU'</code> 和 <code>'U'</code> 模式。</p>
<p>3.8 版后已移除: 对 <code>__getitem__()</code> 方法的支持已弃用。</p>
<p>在 3.8 版更改: 关键字形参 <em>mode</em> 和 <em>openhook</em> 现在是仅限关键字形参。</p>
<p>在 3.10 版更改: 增加了仅限关键字形参 <em>encoding</em> 和 <em>errors</em>。</p>
<p><strong>可选的原地过滤:</strong> 如果传递了关键字参数 <code>inplace=True</code> 给 <code>fileinput.input()</code> 或 <code>FileInput</code> 构造器，则文件会被移至备份文件并将标准输出定向到输入文件（如果已存在与备份文件同名的文件，它将被静默地替换）。 这使得编写一个能够原地重写其输入文件的过滤器成为可能。 如果给出了 <em>backup</em> 形参 (通常形式为 <code>backup='.&lt;some extension&gt;'</code>)，它将指定备份文件的扩展名，并且备份文件会被保留；默认情况下扩展名为 <code>'.bak'</code> 并且它会在输出文件关闭时被删除。 在读取标准输入时原地过滤会被禁用。</p>
<p>此模块提供了以下两种打开文件钩子：</p>
<p><code>fileinput.hook_compressed</code>(<em>filename</em>, <em>mode</em>, <em>**,</em> encoding=None<em>,</em> errors=None*)</p>
<p>使用 <code>gzip</code> 和 <code>bz2</code> 模块透明地打开 gzip 和 bzip2 压缩的文件（通过扩展名 <code>'.gz'</code> 和 <code>'.bz2'</code> 来识别）。 如果文件扩展名不是 <code>'.gz'</code> 或 <code>'.bz2'</code>，文件会以正常方式打开（即使用 <code>open()</code> 并且不带任何解压操作）。</p>
<p><em>encoding</em> 和 <em>errors</em> 值会被传给 <code>io.TextIOWrapper</code> 用于压缩文件以及打开普通文件。</p>
<p>用法示例: <code>fi = fileinput.FileInput(openhook=fileinput.hook_compressed, encoding="utf-8")</code></p>
<p>在 3.10 版更改: 增加了仅限关键字形参 <em>encoding</em> 和 <em>errors</em>。</p>
<p><code>fileinput.hook_encoded</code>(<em>encoding</em>, <em>errors=None</em>)</p>
<p>返回一个通过 <code>open()</code> 打开每个文件的钩子，使用给定的 <em>encoding</em> 和 <em>errors</em> 来读取文件。</p>
<p>使用示例: <code>fi = fileinput.FileInput(openhook=fileinput.hook_encoded("utf-8", "surrogateescape"))</code></p>
<p>在 3.6 版更改: 添加了可选的 <em>errors</em> 形参。</p>
<p>3.10 版后已移除: 此函数已被弃用，因为 <code>input()</code> 和 <code>FileInput</code> 现在有了 <em>encoding</em> 和 <em>errors</em> 形参。</p>
<h2 id="stat-—-解析-stat-结果"><a href="#stat-—-解析-stat-结果" class="headerlink" title="stat —- 解析 stat() 结果"></a><code>stat</code> —- 解析 <code>stat()</code> 结果</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/stat.py" target="_blank" rel="noopener">Lib/stat.py</a></p>
<hr>
<p><code>stat</code> 模块定义了一些用于解析 <code>os.stat()</code>, <code>os.fstat()</code> 和 <code>os.lstat()</code> (如果它们存在) 输出结果的常量和函数。 有关 <code>stat()</code>, <code>fstat()</code> 和 <code>lstat()</code> 调用的完整细节，请参阅你的系统文档。</p>
<p>在 3.4 版更改: stat 模块是通过 C 实现来支持的。</p>
<p><code>stat</code> 模块定义了以下函数来检测特定文件类型：</p>
<p><code>stat.S_ISDIR</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个目录则返回非零值。</p>
<p><code>stat.S_ISCHR</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个字符特殊设备文件则返回非零值。</p>
<p><code>stat.S_ISBLK</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个块特殊设备文件则返回非零值。</p>
<p><code>stat.S_ISREG</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个常规文件则返回非零值。</p>
<p><code>stat.S_ISFIFO</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个 FIFO (命名管道) 则返回非零值。</p>
<p><code>stat.S_ISLNK</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个符号链接则返回非零值。</p>
<p><code>stat.S_ISSOCK</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个套接字则返回非零值。</p>
<p><code>stat.S_ISDOOR</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个门则返回非零值。</p>
<p>3.4 新版功能.</p>
<p><code>stat.S_ISPORT</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个事件端口则返回非零值。</p>
<p>3.4 新版功能.</p>
<p><code>stat.S_ISWHT</code>(<em>mode</em>)</p>
<p>如果 mode 来自一个白输出则返回非零值。</p>
<p>3.4 新版功能.</p>
<p>定义了两个附加函数用于对文件模式进行更一般化的操作：</p>
<p><code>stat.S_IMODE</code>(<em>mode</em>)</p>
<p>返回文件模式中可由 <code>os.chmod()</code> 进行设置的部分 —- 即文件的 permission 位，加上 sticky 位、set-group-id 以及 set-user-id 位（在支持这些部分的系统上）。</p>
<p><code>stat.S_IFMT</code>(<em>mode</em>)</p>
<p>返回文件模式中描述文件类型的部分（供上面的 <code>S_IS*()</code> 函数使用）。</p>
<p>通常，你应当使用 <code>os.path.is*()</code> 函数来检测文件的类型；这里提供的函数则适用于当你要对同一文件执行多项检测并且希望避免每项检测的 <code>stat()</code> 系统调用开销的情况。 这些函数也适用于检测有关未被 <code>os.path</code> 处理的信息，例如检测块和字符设备等。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token punctuation">,</span> sys
<span class="token keyword">from</span> stat <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token keyword">def</span> <span class="token function">walktree</span><span class="token punctuation">(</span>top<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token triple-quoted-string string">'''recursively descend the directory tree rooted at top,
       calling the callback function for each regular file'''</span>
    <span class="token keyword">for</span> f <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>top<span class="token punctuation">)</span><span class="token punctuation">:</span>
        pathname <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>top<span class="token punctuation">,</span> f<span class="token punctuation">)</span>
        mode <span class="token operator">=</span> os<span class="token punctuation">.</span>stat<span class="token punctuation">(</span>pathname<span class="token punctuation">)</span><span class="token punctuation">.</span>st_mode
        <span class="token keyword">if</span> S_ISDIR<span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># It's a directory, recurse into it</span>
            walktree<span class="token punctuation">(</span>pathname<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
        <span class="token keyword">elif</span> S_ISREG<span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># It's a file, call the callback function</span>
            callback<span class="token punctuation">(</span>pathname<span class="token punctuation">)</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment" spellcheck="true"># Unknown file type, print a message</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Skipping %s'</span> <span class="token operator">%</span> pathname<span class="token punctuation">)</span>
<span class="token keyword">def</span> <span class="token function">visitfile</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'visiting'</span><span class="token punctuation">,</span> file<span class="token punctuation">)</span>
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    walktree<span class="token punctuation">(</span>sys<span class="token punctuation">.</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> visitfile<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另外还提供了一个附加的辅助函数用来将文件模式转换为人类易读的字符串：</p>
<p><code>stat.filemode</code>(<em>mode</em>)</p>
<p>将文件模式转换为 ‘-rwxrwxrwx’ 形式的字符串。</p>
<p>3.3 新版功能.</p>
<p>在 3.4 版更改: 此函数支持 <code>S_IFDOOR</code>, <code>S_IFPORT</code> and <code>S_IFWHT</code>。</p>
<p>以下所有变量是一些简单的符号索引，用于访问 <code>os.stat()</code>, <code>os.fstat()</code> 或 <code>os.lstat()</code> 所返回的 10 条目元组。</p>
<pre><code>stat.ST_MODE</code></pre><p>inode 保护模式。</p>
<pre><code>stat.ST_INO</code></pre><p>Inode 号</p>
<pre><code>stat.ST_DEV</code></pre><p>Inode 所在的设备。</p>
<pre><code>stat.ST_NLINK</code></pre><p>Inode 拥有的链接数量。</p>
<pre><code>stat.ST_UID</code></pre><p>所有者的用户 ID。</p>
<pre><code>stat.ST_GID</code></pre><p>所有者的用户组ID。</p>
<pre><code>stat.ST_SIZE</code></pre><p>以字节为单位的普通文件大小；对于某些特殊文件则是所等待的数据量。</p>
<pre><code>stat.ST_ATIME</code></pre><p>上次访问的时间。</p>
<pre><code>stat.ST_MTIME</code></pre><p>上次修改的时间。</p>
<pre><code>stat.ST_CTIME</code></pre><p>操作系统所报告的 “ctime”。 在某些系统上（例如 Unix）是元数据的最后修改时间，而在其他系统上（例如 Windows）则是创建时间（请参阅系统平台的文档了解相关细节）。</p>
<p>对于“文件大小”的解析可因文件类型的不同而变化。 对于普通文件就是文件的字节数。 对于大部分种类的 Unix（特别包括 Linux）的 FIFO 和套接字来说，“大小”则是指在调用 <code>os.stat()</code>, <code>os.fstat()</code> 或 <code>os.lstat()</code> 时等待读取的字节数；这在某些时候很有用处，特别是在一个非阻塞的打开后轮询这些特殊文件中的一个时。 其他字符和块设备的文件大小字段的含义还会有更多变化，具体取决于底层系统调用的实现方式。</p>
<p>以下变量定义了在 <code>ST_MODE</code> 字段中使用的旗标。</p>
<p>使用上面的函数会比使用第一组旗标更容易移植：</p>
<pre><code>stat.S_IFSOCK</code></pre><p>套接字。</p>
<pre><code>stat.S_IFLNK</code></pre><p>符号链接。</p>
<pre><code>stat.S_IFREG</code></pre><p>普通文件。</p>
<pre><code>stat.S_IFBLK</code></pre><p>块设备。</p>
<pre><code>stat.S_IFDIR</code></pre><p>目录。</p>
<pre><code>stat.S_IFCHR</code></pre><p>字符设备。</p>
<pre><code>stat.S_IFIFO</code></pre><p>先进先出。</p>
<pre><code>stat.S_IFDOOR</code></pre><p>门。</p>
<p>3.4 新版功能.</p>
<pre><code>stat.S_IFPORT</code></pre><p>事件端口。</p>
<p>3.4 新版功能.</p>
<pre><code>stat.S_IFWHT</code></pre><p>白输出。</p>
<p>3.4 新版功能.</p>
<p>注解</p>
<p><code>S_IFDOOR</code>, <code>S_IFPORT</code> or <code>S_IFWHT</code> 等文件类型在不受系统平台支持时会被定义为 0。</p>
<p>以下旗标还可以 <code>os.chmod()</code> 的在 <em>mode</em> 参数中使用：</p>
<pre><code>stat.S_ISUID</code></pre><p>设置 UID 位。</p>
<pre><code>stat.S_ISGID</code></pre><p>设置分组 ID 位。 这个位有几种特殊用途。 对于目录它表示该目录将使用 BSD 语义：在其中创建的文件将从目录继承其分组 ID，而不是从创建进程的有效分组 ID 继承，并且在其中创建的目录也将设置 <code>S_ISGID</code> 位。 对于没有设置分组执行位 (<code>S_IXGRP</code>) 的文件，设置分组 ID 位表示强制性文件/记录锁定。</p>
<pre><code>stat.S_ISVTX</code></pre><p>固定位。 当对目录设置该位时则意味着此目录中的文件只能由文件所有者、目录所有者或特权进程来重命名或删除。</p>
<pre><code>stat.S_IRWXU</code></pre><p>文件所有者权限的掩码。</p>
<pre><code>stat.S_IRUSR</code></pre><p>所有者具有读取权限。</p>
<pre><code>stat.S_IWUSR</code></pre><p>所有者具有写入权限。</p>
<pre><code>stat.S_IXUSR</code></pre><p>所有者具有执行权限。</p>
<pre><code>stat.S_IRWXG</code></pre><p>组权限的掩码。</p>
<pre><code>stat.S_IRGRP</code></pre><p>组具有读取权限。</p>
<pre><code>stat.S_IWGRP</code></pre><p>组具有写入权限。</p>
<pre><code>stat.S_IXGRP</code></pre><p>组具有执行权限。</p>
<pre><code>stat.S_IRWXO</code></pre><p>其他人（不在组中）的权限掩码。</p>
<pre><code>stat.S_IROTH</code></pre><p>其他人具有读取权限。</p>
<pre><code>stat.S_IWOTH</code></pre><p>其他人具有写入权限。</p>
<pre><code>stat.S_IXOTH</code></pre><p>其他人具有执行权限。</p>
<pre><code>stat.S_ENFMT</code></pre><p>System V 执行文件锁定。 此旗标是与 <code>S_ISGID</code> 共享的：文件/记录锁定会针对未设置分组执行位 (<code>S_IXGRP</code>) 的文件强制执行。</p>
<pre><code>stat.S_IREAD</code></pre><p>Unix V7 中 <code>S_IRUSR</code> 的同义词。</p>
<pre><code>stat.S_IWRITE</code></pre><p>Unix V7 中 <code>S_IWUSR</code> 的同义词。</p>
<pre><code>stat.S_IEXEC</code></pre><p>Unix V7 中 <code>S_IXUSR</code> 的同义词。</p>
<p>以下旗标可以在 <code>os.chflags()</code> 的 <em>flags</em> 参数中使用：</p>
<pre><code>stat.UF_NODUMP</code></pre><p>不要转储文件。</p>
<pre><code>stat.UF_IMMUTABLE</code></pre><p>文件不能被更改。</p>
<pre><code>stat.UF_APPEND</code></pre><p>文件只能被附加。</p>
<pre><code>stat.UF_OPAQUE</code></pre><p>当通过联合堆栈查看时，目录是不透明的。</p>
<pre><code>stat.UF_NOUNLINK</code></pre><p>文件不能重命名或删除。</p>
<pre><code>stat.UF_COMPRESSED</code></pre><p>The file is stored compressed (macOS 10.6+).</p>
<pre><code>stat.UF_HIDDEN</code></pre><p>The file should not be displayed in a GUI (macOS 10.5+).</p>
<pre><code>stat.SF_ARCHIVED</code></pre><p>文件可能已存档。</p>
<pre><code>stat.SF_IMMUTABLE</code></pre><p>文件不能被更改。</p>
<pre><code>stat.SF_APPEND</code></pre><p>文件只能被附加。</p>
<pre><code>stat.SF_NOUNLINK</code></pre><p>文件不能重命名或删除。</p>
<pre><code>stat.SF_SNAPSHOT</code></pre><p>文件有一个快照文件</p>
<p>See the <em>BSD or macOS systems man page *<a href="https://manpages.debian.org/chflags(2)" target="_blank" rel="noopener">chflags(2)</a></em> for more information.</p>
<p>在 Windows 上，以下文件属性常量可被用来检测 <code>os.stat()</code> 所返回的 <code>st_file_attributes</code> 成员中的位。 请参阅 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/gg258117.aspx" target="_blank" rel="noopener">Windows API 文档</a> 了解有关这些常量含义的详情。</p>
<pre class="line-numbers language-python"><code class="language-python">stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_ARCHIVE
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_COMPRESSED
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_DEVICE
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_DIRECTORY
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_ENCRYPTED
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_HIDDEN
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_INTEGRITY_STREAM
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_NORMAL
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_NO_SCRUB_DATA
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_OFFLINE
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_READONLY
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_REPARSE_POINT
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_SPARSE_FILE
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_SYSTEM
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_TEMPORARY
stat<span class="token punctuation">.</span>FILE_ATTRIBUTE_VIRTUAL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.5 新版功能.</p>
<p>在 Windows 上，以下常量可被用来与 <code>os.lstat()</code> 所返回的 <code>st_reparse_tag</code> 成员进行比较。 这些是最主要的常量，而不是详尽的清单。</p>
<pre class="line-numbers language-python"><code class="language-python">stat<span class="token punctuation">.</span>IO_REPARSE_TAG_SYMLINK
stat<span class="token punctuation">.</span>IO_REPARSE_TAG_MOUNT_POINT
stat<span class="token punctuation">.</span>IO_REPARSE_TAG_APPEXECLINK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>3.8 新版功能.</p>
<h2 id="filecmp-—-文件及目录的比较"><a href="#filecmp-—-文件及目录的比较" class="headerlink" title="filecmp —- 文件及目录的比较"></a><code>filecmp</code> —- 文件及目录的比较</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/filecmp.py" target="_blank" rel="noopener">Lib/filecmp.py</a></p>
<hr>
<p><code>filecmp</code> 模块定义了用于比较文件及目录的函数，并且可以选取多种关于时间和准确性的折衷方案。</p>
<p><code>filecmp</code> 模块定义了如下函数：</p>
<p><code>filecmp.cmp</code>(<em>f1</em>, <em>f2</em>, <em>shallow=True</em>)</p>
<p>比较名为 <em>f1</em> 和 <em>f2</em> 的文件，如果它们似乎相等则返回 <code>True</code> ，否则返回 <code>False</code> 。</p>
<p>如果 <em>shallow</em> 为真值且两个文件的 <code>os.stat()</code> 签名信息（文件类型、大小和修改时间）一致，则文件会被视为相同。</p>
<p>在其他情况下，如果文件大小或内容不同则它们会被视为不同。</p>
<p>需要注意，没有外部程序被该函数调用，这赋予了该函数可移植性与效率。</p>
<p>该函数会缓存过去的比较及其结果，且在文件的 <code>os.stat()</code> 信息变化后缓存条目失效。所有的缓存可以通过使用 <code>clear_cache()</code> 来清除。</p>
<p><code>filecmp.cmpfiles</code>(<em>dir1</em>, <em>dir2</em>, <em>common</em>, <em>shallow=True</em>)</p>
<p>比较在两个目录 <em>dir1</em> 和 <em>dir2</em> 中，由 <em>common</em> 所确定名称的文件。</p>
<p>返回三组文件名列表： <em>match</em>, <em>mismatch</em>, <em>errors</em> 。 <em>match</em> 含有相匹配的文件， <em>mismatch</em> 含有那些不匹配的，然后 <em>errors</em> 列出那些未被比较文件的名称。如果文件不存在于两目录中的任一个，或者用户缺少读取它们的权限，又或者因为其他的一些原因而无法比较，那么这些文件将会被列在 <em>errors</em> 中。</p>
<p>参数 <em>shallow</em> 具有同 <code>filecmp.cmp()</code> 一致的含义与默认值。</p>
<p>例如， <code>cmpfiles('a', 'b', ['c', 'd/e'])</code> 将会比较 <code>a/c</code> 与 <code>b/c</code> 以及 <code>a/d/e</code> 与 <code>b/d/e</code> 。 <code>'c'</code> 和 <code>'d/e'</code> 将会各自出现在返回的三个列表里的某一个列表中。</p>
<p><code>filecmp.clear_cache</code>()</p>
<p>清除 filecmp 缓存。如果一个文件过快地修改，以至于超过底层文件系统记录修改时间的精度，那么该函数可能有助于比较该类文件。</p>
<p>3.4 新版功能.</p>
<h2 id="dircmp-类"><a href="#dircmp-类" class="headerlink" title="dircmp 类"></a><code>dircmp</code> 类</h2><p><em>class</em> <code>filecmp.dircmp</code>(<em>a</em>, <em>b</em>, <em>ignore=None</em>, <em>hide=None</em>)</p>
<p>创建一个用于比较目录 <em>a</em> 和 <em>b</em> 的新的目录比较对象。 <em>ignore</em> 是需要忽略的文件名列表，且默认为 <code>filecmp.DEFAULT_IGNORES</code> 。 <em>hide</em> 是需要隐藏的文件名列表，且默认为 <code>[os.curdir, os.pardir]</code> 。</p>
<p><code>dircmp</code> 类如 <code>filecmp.cmp()</code> 中所描述的那样对文件进行 <em>shallow</em> 比较。</p>
<p><code>dircmp</code> 类提供以下方法：</p>
<ul>
<li><p><code>report</code>()</p>
<p>将 <em>a</em> 与 <em>b</em> 之间的比较结果打印（到 <code>sys.stdout</code> ）。</p>
</li>
<li><p><code>report_partial_closure</code>()</p>
<p>打印 <em>a</em> 与 <em>b</em> 及共同直接子目录的比较结果。</p>
</li>
<li><p><code>report_full_closure</code>()</p>
<p>打印 <em>a</em> 与 <em>b</em> 及共同子目录比较结果（递归地）。</p>
</li>
</ul>
<p><code>dircmp</code> 类提供了一些有趣的属性，用以得到关于参与比较的目录树的各种信息。</p>
<p>需要注意，通过 <code>__getattr__()</code> 钩子，所有的属性将会惰性求值，因此如果只使用那些计算简便的属性，将不会有速度损失。</p>
<ul>
<li><p><code>left</code></p>
<p>目录 <em>a</em> 。</p>
</li>
<li><p><code>right</code></p>
<p>目录 <em>b</em> 。</p>
</li>
<li><p><code>left_list</code></p>
<p>经 <em>hide</em> 和 <em>ignore</em> 过滤，目录 <em>a</em> 中的文件与子目录。</p>
</li>
<li><p><code>right_list</code></p>
<p>经 <em>hide</em> 和 <em>ignore</em> 过滤，目录 <em>b</em> 中的文件与子目录。</p>
</li>
<li><p><code>common</code></p>
<p>同时存在于目录 <em>a</em> 和 <em>b</em> 中的文件和子目录。</p>
</li>
<li><p><code>left_only</code></p>
<p>仅在目录 <em>a</em> 中的文件和子目录。</p>
</li>
<li><p><code>right_only</code></p>
<p>仅在目录 <em>b</em> 中的文件和子目录。</p>
</li>
<li><p><code>common_dirs</code></p>
<p>同时存在于目录 <em>a</em> 和 <em>b</em> 中的子目录。</p>
</li>
<li><p><code>common_files</code></p>
<p>同时存在于目录 <em>a</em> 和 <em>b</em> 中的文件。</p>
</li>
<li><p><code>common_funny</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中类型不同的名字，或者那些 <code>os.stat()</code> 报告错误的名字。</p>
</li>
<li><p><code>same_files</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中，使用类的文件比较操作符判定相等的文件。</p>
</li>
<li><p><code>diff_files</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中，根据类的文件比较操作符判定内容不等的文件。</p>
</li>
<li><p><code>funny_files</code></p>
<p>在目录 <em>a</em> 和 <em>b</em> 中无法比较的文件。</p>
</li>
<li><p><code>subdirs</code></p>
<p>一个将 <code>common_dirs</code> 中的名称映射到 <code>dircmp</code> 实例（或者 MyDirCmp 实例，如果该实例类型为 <code>dircmp</code> 的子类 MyDirCmp 的话）的字典。</p>
<p>在 3.10 版更改: 在之前版本中字典条目总是为 <code>dircmp</code> 实例。 现在条目将与 <em>self</em> 的类型相同，如果 <em>self</em> 为 <code>dircmp</code> 的子类的话。</p>
</li>
</ul>
<pre><code>filecmp.DEFAULT_IGNORES</code></pre><p>3.4 新版功能.</p>
<p>默认被 <code>dircmp</code> 忽略的目录列表。</p>
<p>下面是一个简单的例子，使用 <code>subdirs</code> 属性递归搜索两个目录以显示公共差异文件：</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> filecmp <span class="token keyword">import</span> dircmp
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">print_diff_files</span><span class="token punctuation">(</span>dcmp<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> name <span class="token keyword">in</span> dcmp<span class="token punctuation">.</span>diff_files<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"diff_file %s found in %s and %s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> dcmp<span class="token punctuation">.</span>left<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>               dcmp<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">for</span> sub_dcmp <span class="token keyword">in</span> dcmp<span class="token punctuation">.</span>subdirs<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>         print_diff_files<span class="token punctuation">(</span>sub_dcmp<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">>></span><span class="token operator">></span> dcmp <span class="token operator">=</span> dircmp<span class="token punctuation">(</span><span class="token string">'dir1'</span><span class="token punctuation">,</span> <span class="token string">'dir2'</span><span class="token punctuation">)</span> 
<span class="token operator">>></span><span class="token operator">></span> print_diff_files<span class="token punctuation">(</span>dcmp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="tempfile-—-生成临时文件和目录"><a href="#tempfile-—-生成临时文件和目录" class="headerlink" title="tempfile —- 生成临时文件和目录"></a><code>tempfile</code> —- 生成临时文件和目录</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/tempfile.py" target="_blank" rel="noopener">Lib/tempfile.py</a></p>
<hr>
<p>该模块用于创建临时文件和目录，它可以跨平台使用。<code>TemporaryFile</code>、<code>NamedTemporaryFile</code>、<code>TemporaryDirectory</code> 和 <code>SpooledTemporaryFile</code> 是带有自动清理功能的高级接口，可用作上下文管理器。<code>mkstemp()</code> 和 <code>mkdtemp()</code> 是低级函数，使用完毕需手动清理。</p>
<p>所有由用户调用的函数和构造函数都带有参数，这些参数可以设置临时文件和临时目录的路径和名称。该模块生成的文件名包括一串随机字符，在公共的临时目录中，这些字符可以让创建文件更加安全。为了保持向后兼容性，参数的顺序有些奇怪。所以为了代码清晰，建议使用关键字参数。</p>
<p>这个模块定义了以下内容供用户调用：</p>
<p><code>tempfile.TemporaryFile</code>(<em>mode=’w+b’</em>, <em>buffering=- 1</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>**,</em> errors=None*)</p>
<p>返回一个 file-like object （文件类对象）作为临时存储区域。创建该文件使用了与 <code>mkstemp()</code> 相同的安全规则。它将在关闭后立即销毁（包括垃圾回收机制关闭该对象时）。在 Unix 下，该文件在目录中的条目根本不创建，或者创建文件后立即就被删除了，其他平台不支持此功能。您的代码不应依赖使用此功能创建的临时文件名称，因为它在文件系统中的名称可能是可见的，也可能是不可见的。</p>
<p>生成的对象可以用作上下文管理器。完成上下文或销毁临时文件对象后，临时文件将从文件系统中删除。</p>
<p><em>mode</em> 参数默认值为 <code>'w+b'</code>，所以创建的文件不用关闭，就可以读取或写入。因为用的是二进制模式，所以无论存的是什么数据，它在所有平台上都表现一致。<em>buffering<em>、</em>encoding<em>、</em>errors</em> 和 <em>newline</em> 的含义与 <code>open()</code> 中的相同。</p>
<p>参数 <em>dir<em>、</em>prefix</em> 和 <em>suffix</em> 的含义和默认值都与它们在 <code>mkstemp()</code> 中的相同。</p>
<p>在 POSIX 平台上，它返回的对象是真实的文件对象。在其他平台上，它是一个文件类对象 (file-like object)，它的 <code>file</code> 属性是底层的真实文件对象。</p>
<p>如果可用，则使用 <code>os.O_TMPFILE</code> 标志（仅限于 Linux，需要 3.11 及更高版本的内核）。</p>
<p>引发一个 <code>tempfile.mkstemp</code> 审计事件，附带参数 <code>fullpath</code>。</p>
<p>在 3.5 版更改: 如果可用，现在用的是 <code>os.O_TMPFILE</code> 标志。</p>
<p>在 3.8 版更改: 添加了 <em>errors</em> 参数。</p>
<p><code>tempfile.NamedTemporaryFile</code>(<em>mode=’w+b’</em>, <em>buffering=- 1</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>delete=True</em>, <em>**,</em> errors=None*)</p>
<p>此函数执行的操作与 <code>TemporaryFile()</code> 完全相同，但确保了该临时文件在文件系统中具有可见的名称（在 Unix 上表现为目录条目不取消链接）。从返回的文件类对象的 <code>name</code> 属性中可以检索到文件名。在临时文件仍打开时，是否允许用文件名第二次打开文件，在各个平台上是不同的（在 Unix 上可以，但在 Windows NT 或更高版本上不行）。如果 <em>delete</em> 为 true（默认值），则文件会在关闭后立即被删除。该函数返回的对象始终是文件类对象 (file-like object)，它的 <code>file</code> 属性是底层的真实文件对象。文件类对象可以像普通文件一样在 <code>with</code> 语句中使用。</p>
<p>引发一个 <code>tempfile.mkstemp</code> 审计事件，附带参数 <code>fullpath</code>。</p>
<p>在 3.8 版更改: 添加了 <em>errors</em> 参数。</p>
<p><code>tempfile.SpooledTemporaryFile</code>(<em>max_size=0</em>, <em>mode=’w+b’</em>, <em>buffering=- 1</em>, <em>encoding=None</em>, <em>newline=None</em>, <em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>**,</em> errors=None*)</p>
<p>此函数执行的操作与 <code>TemporaryFile()</code> 完全相同，但会将数据缓存在内存中，直到文件大小超过 <em>max_size</em>，或调用文件的 <code>fileno()</code> 方法为止，此时数据会被写入磁盘，并且写入操作与 <code>TemporaryFile()</code> 相同。</p>
<p>此函数生成的文件对象有一个额外的方法——<code>rollover()</code>，可以忽略文件大小，让文件立即写入磁盘。</p>
<p>返回的对象是文件类对象 (file-like object)，它的 <code>_file</code> 属性是 <code>io.BytesIO</code> 或 <code>io.TextIOWrapper</code> 对象（取决于指定的是二进制模式还是文本模式）或真实的文件对象（取决于是否已调用 <code>rollover()</code>）。文件类对象可以像普通文件一样在 <code>with</code> 语句中使用。</p>
<p>在 3.3 版更改: 现在，文件的 truncate 方法可接受一个 <code>size</code> 参数。</p>
<p>在 3.8 版更改: 添加了 <em>errors</em> 参数。</p>
<p><code>tempfile.TemporaryDirectory</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>ignore_cleanup_errors=False</em>)</p>
<p>此函数会使用与 <code>mkdtemp()</code> 相同的规则安全地创建一个临时目录。 结果对象可被用作上下文管理器。 在完成上下文或销毁临时目录对象时，新创建的临时目录及其所有内容会从文件系统中被移除。</p>
<p>可以从返回对象的 <code>name</code> 属性中找到临时目录的名称。当返回的对象用作上下文管理器时，这个 <code>name</code> 会作为 <code>with</code> 语句中 <code>as</code> 子句的目标（如果有 as 的话）。</p>
<p>此目录可通过调用 <code>cleanup()</code> 方法来显式地清理。 如果 <em>ignore_cleanup_errors</em> 为真值，则在显式或隐式清理（例如在 Windows 上 <code>PermissionError</code> 移除打开的文件）期间出现的未处理异常将被忽略，并且剩余的可移除条目会被“尽可能”地删除。 在其他情况下，错误将在任何上下文清理发生时被引发 (<code>cleanup()</code> 调用、退出上下文管理器、对象被作为垃圾回收或解释器关闭等)。</p>
<p>引发一个 <code>tempfile.mkdtemp</code> 审计事件，附带参数 <code>fullpath</code>。</p>
<p>3.2 新版功能.</p>
<p>在 3.10 版更改: 添加了 <em>ignore_cleanup_errors</em> 形参。</p>
<p><code>tempfile.mkstemp</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>, <em>text=False</em>)</p>
<p>以最安全的方式创建一个临时文件。假设所在平台正确实现了 <code>os.open()</code> 的 <code>os.O_EXCL</code> 标志，则创建文件时不会有竞争的情况。该文件只能由创建者读写，如果所在平台用权限位来标记文件是否可执行，那么没有人有执行权。文件描述符不会过继给子进程。</p>
<p>与 <code>TemporaryFile()</code> 不同，<code>mkstemp()</code> 用户用完临时文件后需要自行将其删除。</p>
<p>如果 <em>suffix</em> 不是 <code>None</code> 则文件名将以该后缀结尾，是 <code>None</code> 则没有后缀。<code>mkstemp()</code> 不会在文件名和后缀之间加点，如果需要加一个点号，请将其放在 <em>suffix</em> 的开头。</p>
<p>如果 <em>prefix</em> 不是 <code>None</code>，则文件名将以该前缀开头，是 <code>None</code> 则使用默认前缀。默认前缀是 <code>gettempprefix()</code> 或 <code>gettempprefixb()</code> 函数的返回值（自动调用合适的函数）。</p>
<p>如果 <em>dir</em> 不为 <code>None</code>，则在指定的目录创建文件，是 <code>None</code> 则使用默认目录。默认目录是从一个列表中选择出来的，这个列表不同平台不一样，但是用户可以设置 <em>TMPDIR<em>、</em>TEMP</em> 或 <em>TMP</em> 环境变量来设置目录的位置。因此，不能保证生成的临时文件路径很规范，比如，通过 <code>os.popen()</code> 将路径传递给外部命令时仍需要加引号。</p>
<p>如果 <em>suffix<em>、</em>prefix</em> 和 <em>dir</em> 中的任何一个不是 <code>None</code>，就要保证它们是同一数据类型。如果它们是 bytes，则返回的名称的类型就是 bytes 而不是 str。如果确实要用默认参数，但又想要返回值是 bytes 类型，请传入 <code>suffix=b''</code>。</p>
<p>如果指定了 <em>text</em> 且为真值，文件会以文本模式打开。 否则，文件（默认）会以二进制模式打开。</p>
<p><code>mkstemp()</code> 返回一个元组，元组中第一个元素是句柄，它是一个系统级句柄，指向一个打开的文件（等同于 <code>os.open()</code> 的返回值），第二元素是该文件的绝对路径。</p>
<p>引发一个 <code>tempfile.mkstemp</code> 审计事件，附带参数 <code>fullpath</code>。</p>
<p>在 3.5 版更改: 现在，<em>suffix<em>、</em>prefix</em> 和 <em>dir</em> 可以以 bytes 类型按顺序提供，以获得 bytes 类型的返回值。之前只允许使用 str。<em>suffix</em> 和 <em>prefix</em> 现在可以接受 <code>None</code>，并且默认为 <code>None</code> 以使用合适的默认值。</p>
<p>在 3.6 版更改: <em>dir</em> 参数现在可接受一个路径类对象 (path-like object)。</p>
<p><code>tempfile.mkdtemp</code>(<em>suffix=None</em>, <em>prefix=None</em>, <em>dir=None</em>)</p>
<p>以最安全的方式创建一个临时目录，创建该目录时不会有竞争的情况。该目录只能由创建者读取、写入和搜索。</p>
<p><code>mkdtemp()</code> 用户用完临时目录后需要自行将其删除。</p>
<p><em>prefix<em>、</em>suffix</em> 和 <em>dir</em> 的含义与它们在 <code>mkstemp()</code> 中的相同。</p>
<p><code>mkdtemp()</code> 返回新目录的绝对路径。</p>
<p>引发一个 <code>tempfile.mkdtemp</code> 审计事件，附带参数 <code>fullpath</code>。</p>
<p>在 3.5 版更改: 现在，<em>suffix<em>、</em>prefix</em> 和 <em>dir</em> 可以以 bytes 类型按顺序提供，以获得 bytes 类型的返回值。之前只允许使用 str。<em>suffix</em> 和 <em>prefix</em> 现在可以接受 <code>None</code>，并且默认为 <code>None</code> 以使用合适的默认值。</p>
<p>在 3.6 版更改: <em>dir</em> 参数现在可接受一个路径类对象 (path-like object)。</p>
<p><code>tempfile.gettempdir</code>()</p>
<p>返回放置临时文件的目录的名称。这个方法的返回值就是本模块所有函数的 <em>dir</em> 参数的默认值。</p>
<p>Python 搜索标准目录列表，以找到调用者可以在其中创建文件的目录。这个列表是：</p>
<ol>
<li><code>TMPDIR</code> 环境变量指向的目录。</li>
<li><code>TEMP</code> 环境变量指向的目录。</li>
<li><code>TMP</code> 环境变量指向的目录。</li>
<li>与平台相关的位置：<ul>
<li>在 Windows 上，依次为 <code>C:\TEMP</code>、<code>C:\TMP</code>、<code>\TEMP</code> 和 <code>\TMP</code>。</li>
<li>在所有其他平台上，依次为 <code>/tmp</code>、<code>/var/tmp</code> 和 <code>/usr/tmp</code>。</li>
</ul>
</li>
<li>不得已时，使用当前工作目录。</li>
</ol>
<p>在 3.10 版更改: 总是返回一个字符串。 在之前的版本中它会返回任意 <code>tempdir</code> 值而不考虑它的类型，只要它不为 <code>None</code>。</p>
<p><code>tempfile.gettempdirb</code>()</p>
<p>与 <code>gettempdir()</code> 相同，但返回值为字节类型。</p>
<p>3.5 新版功能.</p>
<p><code>tempfile.gettempprefix</code>()</p>
<p>返回用于创建临时文件的文件名前缀，它不包含目录部分。</p>
<p><code>tempfile.gettempprefixb</code>()</p>
<p>与 <code>gettempprefix()</code> 相同，但返回值为字节类型。</p>
<p>3.5 新版功能.</p>
<p>本模块使用一个全局变量来存储由 <code>gettempdir()</code> 返回的临时文件使用的目录路径。 它可被直接设置以覆盖选择过程，但不建议这样做。 本模块中的所有函数都接受一个 <em>dir</em> 参数，它可被用于指定目录。 这是不会通过改变全局 API 行为对其他无准备代码造成影响的推荐做法。</p>
<pre><code>tempfile.tempdir</code></pre><p>当设为 <code>None</code> 以外的值时，此变量会为本模块中定义的函数的 <em>dir</em> 参数定义默认值，包括确定其类型为字节串还是字符串。 它不可以为 path-like object。</p>
<p>如果在调用除 <code>gettempprefix()</code> 外的上述任何函数时 <code>tempdir</code> 为 <code>None</code> (默认值) 则它会按照 <code>gettempdir()</code> 中所描述的算法来初始化。</p>
<p>注解</p>
<p>请注意如果你将 <code>tempdir</code> 设为字节串值，会有一个麻烦的副作用: <code>mkstemp()</code> 和 <code>mkdtemp()</code> 的全局默认返回类型会在没有显式提供字符串类型的when no explicit <code>prefix</code>, <code>suffix</code> 或 <code>dir</code> 的时候被改为字节串。 请不要编写预期或依赖于此入围的代码。 这个笨拙行为是为了保持与历史实现的兼容性。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>以下是 <code>tempfile</code> 模块典型用法的一些示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> tempfile
<span class="token comment" spellcheck="true"># create a temporary file and write some data to it</span>
<span class="token operator">>></span><span class="token operator">></span> fp <span class="token operator">=</span> tempfile<span class="token punctuation">.</span>TemporaryFile<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> fp<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">'Hello world!'</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># read data from file</span>
<span class="token operator">>></span><span class="token operator">></span> fp<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> fp<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'Hello world!'</span>
<span class="token comment" spellcheck="true"># close the file, it will be removed</span>
<span class="token operator">>></span><span class="token operator">></span> fp<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># create a temporary file using a context manager</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> tempfile<span class="token punctuation">.</span>TemporaryFile<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> fp<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     fp<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">'Hello world!'</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     fp<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     fp<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
b<span class="token string">'Hello world!'</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token comment" spellcheck="true"># file is now closed and removed</span>
<span class="token comment" spellcheck="true"># create a temporary directory using the context manager</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">with</span> tempfile<span class="token punctuation">.</span>TemporaryDirectory<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tmpdirname<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'created temporary directory'</span><span class="token punctuation">,</span> tmpdirname<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span>
<span class="token comment" spellcheck="true"># directory and contents have been removed</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="已弃用的函数和变量"><a href="#已弃用的函数和变量" class="headerlink" title="已弃用的函数和变量"></a>已弃用的函数和变量</h3><p>创建临时文件有一种历史方法，首先使用 <code>mktemp()</code> 函数生成一个文件名，然后使用该文件名创建文件。不幸的是，这是不安全的，因为在调用 <code>mktemp()</code> 与随后尝试创建文件的进程之间的时间里，其他进程可能会使用该名称创建文件。解决方案是将两个步骤结合起来，立即创建文件。这个方案目前被 <code>mkstemp()</code> 和上述其他函数所采用。</p>
<p><code>tempfile.mktemp</code>(<em>suffix=’’</em>, <em>prefix=’tmp’</em>, <em>dir=None</em>)</p>
<p>2.3 版后已移除: 使用 <code>mkstemp()</code> 来代替。</p>
<p>返回一个绝对路径，这个路径指向的文件在调用本方法时不存在。<em>prefix<em>、</em>suffix</em> 和 <em>dir</em> 参数与 <code>mkstemp()</code> 中的同名参数类似，不同之处在于不支持字节类型的文件名，不支持 <code>suffix=None</code> 和 <code>prefix=None</code>。</p>
<p>警告</p>
<p>使用此功能可能会在程序中引入安全漏洞。当你开始使用本方法返回的文件执行任何操作时，可能有人已经捷足先登了。<code>mktemp()</code> 的功能可以很轻松地用 <code>NamedTemporaryFile()</code> 代替，当然需要传递 <code>delete=False</code> 参数:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> NamedTemporaryFile<span class="token punctuation">(</span>delete<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>name
<span class="token string">'/tmp/tmptjujjt'</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>b<span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span>
<span class="token number">13</span>
<span class="token operator">>></span><span class="token operator">></span> f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>unlink<span class="token punctuation">(</span>f<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>exists<span class="token punctuation">(</span>f<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="glob-—-Unix-风格路径名模式扩展"><a href="#glob-—-Unix-风格路径名模式扩展" class="headerlink" title="glob —- Unix 风格路径名模式扩展"></a><code>glob</code> —- Unix 风格路径名模式扩展</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/glob.py" target="_blank" rel="noopener">Lib/glob.py</a></p>
<hr>
<p><code>glob</code> 模块可根据 Unix 终端所用规则找出所有匹配特定模式的路径名，但会按不确定的顺序返回结果。 波浪号扩展不会生效，但 <code>*</code>, <code>?</code> 以及表示为 <code>[]</code> 的字符范围将被正确地匹配。 这是通过配合使用 <code>os.scandir()</code> 和 <code>fnmatch.fnmatch()</code> 函数来实现的，而不是通过实际发起调用子终端。 请注意不同于 <code>fnmatch.fnmatch()</code>，<code>glob</code> 会将以点号 (<code>.</code>) 开头的文件名作为特殊情况来处理。 （对于波浪号和终端变量扩展，请使用 <code>os.path.expanduser()</code> 和 <code>os.path.expandvars()</code>。）</p>
<p>对于字面值匹配，请将原字符用方括号括起来。 例如，<code>'[?]'</code> 将匹配字符 <code>'?'</code>。</p>
<p>参见</p>
<p><code>pathlib</code> 模块提供高级路径对象。</p>
<p><code>glob.glob</code>(<em>pathname</em>, <em>**,</em> root_dir=None<em>,</em> dir_fd=None<em>,</em> recursive=False*)</p>
<p>返回匹配 <em>pathname</em> 的可能为空的路径名列表，其中的元素必须为包含路径信息的字符串。 <em>pathname</em> 可以是绝对路径 (如 <code>/usr/src/Python-1.5/Makefile</code>) 或相对路径 (如 <code>../../Tools/*/*.gif</code>)，并且可包含 shell 风格的通配符。 结果也将包含无效的符号链接（与在 shell 中一样）。 结果是否排序取决于具体文件系统。 如果某个符合条件的文件在调用此函数期间被移除或添加，是否包括该文件的路径是没有规定的。</p>
<p>如果 <em>root_dir</em> 不为 <code>None</code>，则它应当是指明要搜索的根目录的 path-like object。 它用在 <code>glob()</code> 上与在调用它之前改变当前目录有相同的效果。 如果 <em>pathname</em> 为相对路径，结果将包含相对于 <em>root_dir</em> 的路径。</p>
<p>本函数带有 <em>dir_fd</em> 参数，支持 基于目录描述符的相对路径。</p>
<p>如果 <em>recursive</em> 为真值，则模式 “<code>**</code>“ 将匹配目录中的任何文件以及零个或多个目录、子目录和符号链接。 如果模式加了一个 <code>os.sep</code> 或 <code>os.altsep</code> 则将不匹配文件。</p>
<p>引发一个 审计事件 <code>glob.glob</code> 附带参数 <code>pathname</code>, <code>recursive</code>。</p>
<p>引发一个 审计事件 <code>glob.glob/2</code>，附带参数 <code>pathname</code>, <code>recursive</code>, <code>root_dir</code>, <code>dir_fd</code>。</p>
<p>注解</p>
<p>在一个较大的目录树中使用 “<code>**</code>“ 模式可能会消耗非常多的时间。</p>
<p>在 3.5 版更改: 支持使用 “<code>**</code>“ 的递归 glob。</p>
<p>在 3.10 版更改: 添加了 <em>root_dir</em> 和 <em>dir_fd</em> 形参。</p>
<p><code>glob.iglob</code>(<em>pathname</em>, <em>**,</em> root_dir=None<em>,</em> dir_fd=None<em>,</em> recursive=False*)</p>
<p>返回一个 iterator，它会产生与 <code>glob()</code> 相同的结果，但不会实际地同时保存它们。</p>
<p>引发一个 审计事件 <code>glob.glob</code> 附带参数 <code>pathname</code>, <code>recursive</code>。</p>
<p>引发一个 审计事件 <code>glob.glob/2</code>，附带参数 <code>pathname</code>, <code>recursive</code>, <code>root_dir</code>, <code>dir_fd</code>。</p>
<p>在 3.5 版更改: 支持使用 “<code>**</code>“ 的递归 glob。</p>
<p>在 3.10 版更改: 添加了 <em>root_dir</em> 和 <em>dir_fd</em> 形参。</p>
<p><code>glob.escape</code>(<em>pathname</em>)</p>
<p>转义所有特殊字符 (<code>'?'</code>, <code>'*'</code> 和 <code>'['</code>)。 这适用于当你想要匹配可能带有特殊字符的任意字符串字面值的情况。 在 drive/UNC 共享点中的特殊字符不会被转义，例如在 Windows 上 <code>escape('//?/c:/Quo vadis?.txt')</code> 将返回 <code>'//?/c:/Quo vadis[?].txt'</code>。</p>
<p>3.4 新版功能.</p>
<p>例如，考虑一个包含以下内容的目录：文件 <code>1.gif</code>, <code>2.txt</code>, <code>card.gif</code> 以及一个子目录 <code>sub</code> 其中只包含一个文件 <code>3.txt</code>. <code>glob()</code> 将产生如下结果。 请注意路径的任何开头部分都将被保留。:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> glob
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'./[0-9].*'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'./1.gif'</span><span class="token punctuation">,</span> <span class="token string">'./2.txt'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'*.gif'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1.gif'</span><span class="token punctuation">,</span> <span class="token string">'card.gif'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'?.gif'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'1.gif'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'**/*.txt'</span><span class="token punctuation">,</span> recursive<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'2.txt'</span><span class="token punctuation">,</span> <span class="token string">'sub/3.txt'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'./**/'</span><span class="token punctuation">,</span> recursive<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'./'</span><span class="token punctuation">,</span> <span class="token string">'./sub/'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果目录包含以 <code>.</code> 打头的文件，它们默认将不会被匹配。 例如，考虑一个包含 <code>card.gif</code> 和 <code>.card.gif</code> 的目录:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> glob
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'*.gif'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'card.gif'</span><span class="token punctuation">]</span>
<span class="token operator">>></span><span class="token operator">></span> glob<span class="token punctuation">.</span>glob<span class="token punctuation">(</span><span class="token string">'.c*'</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">'.card.gif'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="fnmatch-—-Unix-文件名模式匹配"><a href="#fnmatch-—-Unix-文件名模式匹配" class="headerlink" title="fnmatch —- Unix 文件名模式匹配"></a><code>fnmatch</code> —- Unix 文件名模式匹配</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/fnmatch.py" target="_blank" rel="noopener">Lib/fnmatch.py</a></p>
<hr>
<p>此模块提供了 Unix shell 风格的通配符，它们 <em>并不</em> 等同于正则表达式。 shell 风格通配符所使用的特殊字符如下：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">含意</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>*</code></td>
<td align="left">匹配所有</td>
</tr>
<tr>
<td align="left"><code>?</code></td>
<td align="left">匹配任何单个字符</td>
</tr>
<tr>
<td align="left"><code>[seq]</code></td>
<td align="left">匹配 <em>seq</em> 中的任何字符</td>
</tr>
<tr>
<td align="left"><code>[!seq]</code></td>
<td align="left">匹配任何不在 <em>seq</em> 中的字符</td>
</tr>
</tbody></table>
<p>对于字面值匹配，请将原字符用方括号括起来。 例如，<code>'[?]'</code> 将匹配字符 <code>'?'</code>。</p>
<p>注意文件名分隔符 (Unix 上为 <code>'/'</code>) <em>不是</em> 此模块所特有的。 请参见 <code>glob</code> 模块了解文件名扩展 (<code>glob</code> 使用 <code>filter()</code> 来匹配文件名的各个部分)。 类似地，以一个句点打头的文件名也不是此模块所特有的，可以通过 <code>*</code> 和 <code>?</code> 模式来匹配。</p>
<p><code>fnmatch.fnmatch</code>(<em>filename</em>, <em>pattern</em>)</p>
<p>检测 <em>filename</em> 字符串是否匹配 <em>pattern</em> 字符串，返回 <code>True</code> 或 <code>False</code>。 两个形参都会使用 <code>os.path.normcase()</code> 进行大小写正规化。 <code>fnmatchcase()</code> 可被用于执行大小写敏感的比较，无论这是否为所在操作系统的标准。</p>
<p>这个例子将打印当前目录下带有扩展名 <code>.txt</code> 的所有文件名:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> fnmatch
<span class="token keyword">import</span> os
<span class="token keyword">for</span> file <span class="token keyword">in</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> fnmatch<span class="token punctuation">.</span>fnmatch<span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">'*.txt'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>fnmatch.fnmatchcase</code>(<em>filename</em>, <em>pattern</em>)</p>
<p>检测 <em>filename</em> 是否匹配 <em>pattern</em>，返回 <code>True</code> 或 <code>False</code>；此比较是大小写敏感的，并且不会应用 <code>os.path.normcase()</code>。</p>
<p><code>fnmatch.filter</code>(<em>names</em>, <em>pattern</em>)</p>
<p>基于可迭代对象 <em>names</em> 中匹配 <em>pattern</em> 的元素构造一个列表。 它等价于 <code>[n for n in names if fnmatch(n, pattern)]</code>，但实现得更有效率。</p>
<p><code>fnmatch.translate</code>(<em>pattern</em>)</p>
<p>返回 shell 风格 <em>pattern</em> 转换成的正则表达式以便用于 <code>re.match()</code>。</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> fnmatch<span class="token punctuation">,</span> re
<span class="token operator">>></span><span class="token operator">></span>
<span class="token operator">>></span><span class="token operator">></span> regex <span class="token operator">=</span> fnmatch<span class="token punctuation">.</span>translate<span class="token punctuation">(</span><span class="token string">'*.txt'</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> regex
<span class="token string">'(?s:.*\\.txt)\\Z'</span>
<span class="token operator">>></span><span class="token operator">></span> reobj <span class="token operator">=</span> re<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>regex<span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> reobj<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'foobar.txt'</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span>re<span class="token punctuation">.</span>Match object<span class="token punctuation">;</span> span<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> match<span class="token operator">=</span><span class="token string">'foobar.txt'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="linecache-—-随机读写文本行"><a href="#linecache-—-随机读写文本行" class="headerlink" title="linecache —- 随机读写文本行"></a><code>linecache</code> —- 随机读写文本行</h2><p><strong>源代码:</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/linecache.py" target="_blank" rel="noopener">Lib/linecache.py</a></p>
<hr>
<p><code>linecache</code> 模块允许从一个 Python 源文件中获取任意的行，并会尝试使用缓存进行内部优化，常应用于从单个文件读取多行的场合。 此模块被 <code>traceback</code> 模块用来提取源码行以便包含在格式化的回溯中。</p>
<p><code>tokenize.open()</code> 函数被用于打开文件。 此函数使用 <code>tokenize.detect_encoding()</code> 来获取文件的编码格式；如果未指明编码格式，则默认编码为 UTF-8。</p>
<p><code>linecache</code> 模块定义了下列函数：</p>
<p><code>linecache.getline</code>(<em>filename</em>, <em>lineno</em>, <em>module_globals=None</em>)</p>
<p>从名为 <em>filename</em> 的文件中获取 <em>lineno</em> 行，此函数绝不会引发异常 —- 出现错误时它将返回 <code>''</code> (所有找到的行都将包含换行符作为结束)。</p>
<p>如果找不到名为 <em>filename</em> 的文件，此函数会先在 <em>module_globals</em> 中检查 <a href="https://www.python.org/dev/peps/pep-0302" target="_blank" rel="noopener"><strong>PEP 302</strong></a> <code>__loader__</code>。 如果存在这样的加载器并且它定义了 <code>get_source</code> 方法，则由该方法来确定源行 (如果 <code>get_source()</code> 返回 <code>None</code>，则该函数返回 <code>''</code>)。 最后，如果 <em>filename</em> 是一个相对路径文件名，则它会在模块搜索路径 <code>sys.path</code> 中按条目的相对位置进行查找。</p>
<p><code>linecache.clearcache</code>()</p>
<p>清空缓存。 如果你不再需要之前使用 <code>getline()</code> 从文件读取的行即可使用此函数。</p>
<p><code>linecache.checkcache</code>(<em>filename=None</em>)</p>
<p>检查缓存有效性。 如果缓存中的文件在磁盘上发生了改变，而你需要更新后的版本即可使用此函数。 如果省略了 <em>filename</em>，它会检查缓存中的所有条目。</p>
<p><code>linecache.lazycache</code>(<em>filename</em>, <em>module_globals</em>)</p>
<p>捕获有关某个非基于文件的模块的足够细节信息，以允许稍后再通过 <code>getline()</code> 来获取其中的行，即使当稍后调用时 <em>module_globals</em> 为 <code>None</code>。 这可以避免在实际需要读取行之前执行 I/O，也不必始终保持模块全局变量。</p>
<p>3.5 新版功能.</p>
<p>示例:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> linecache
<span class="token operator">>></span><span class="token operator">></span> linecache<span class="token punctuation">.</span>getline<span class="token punctuation">(</span>linecache<span class="token punctuation">.</span>__file__<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>
<span class="token string">'import sys\n'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="shutil-—-高阶文件操作"><a href="#shutil-—-高阶文件操作" class="headerlink" title="shutil —- 高阶文件操作"></a><code>shutil</code> —- 高阶文件操作</h2><p><strong>源代码：</strong> <a href="https://github.com/python/cpython/tree/3.10/Lib/shutil.py" target="_blank" rel="noopener">Lib/shutil.py</a></p>
<hr>
<p><code>shutil</code> 模块提供了一系列对文件和文件集合的高阶操作。 特别是提供了一些支持文件拷贝和删除的函数。 </p>
<p>警告</p>
<p>即便是高阶文件拷贝函数 (<code>shutil.copy()</code>, <code>shutil.copy2()</code>) 也无法拷贝所有的文件元数据。</p>
<p>在 POSIX 平台上，这意味着将丢失文件所有者和组以及 ACL 数据。 在 Mac OS 上，资源钩子和其他元数据不被使用。 这意味着将丢失这些资源并且文件类型和创建者代码将不正确。 在 Windows 上，将不会拷贝文件所有者、ACL 和替代数据流。</p>
<h3 id="目录和文件操作"><a href="#目录和文件操作" class="headerlink" title="目录和文件操作"></a>目录和文件操作</h3><p><code>shutil.copyfileobj</code>(<em>fsrc</em>, <em>fdst</em>[, <em>length</em>])</p>
<p>将文件类对象 <em>fsrc</em> 的内容拷贝到文件类对象 <em>fdst*。 整数值 *length</em> 如果给出则为缓冲区大小。 特别地， <em>length</em> 为负值表示拷贝数据时不对源数据进行分块循环处理；默认情况下会分块读取数据以避免不受控制的内存消耗。 请注意如果 <em>fsrc</em> 对象的当前文件位置不为 0，则只有从当前文件位置到文件末尾的内容会被拷贝。</p>
<p><code>shutil.copyfile</code>(<em>src</em>, <em>dst</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>将名为 <em>src</em> 的文件的内容（不包括元数据）拷贝到名为 <em>dst</em> 的文件并以尽可能高效的方式返回 <em>dst*。 *src</em> 和 <em>dst</em> 均为路径类对象或以字符串形式给出的路径名。</p>
<p><em>dst</em> 必须是完整的目标文件名。 如果 <em>src</em> 和 <em>dst</em> 指定了同一个文件，则将引发 <code>SameFileError</code>。</p>
<p>目标位置必须是可写的；否则将引发 <code>OSError</code> 异常。 如果 <em>dst</em> 已经存在，它将被替换。 特殊文件如字符或块设备以及管道无法用此函数来拷贝。</p>
<p>如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则将创建一个新的符号链接而不是拷贝 <em>src</em> 所指向的文件。</p>
<p>引发一个 审计事件 <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 曾经是引发 <code>IOError</code> 而不是 <code>OSError</code>。 增加了 <em>follow_symlinks</em> 参数。 现在是返回 <em>dst</em>。</p>
<p>在 3.4 版更改: 引发 <code>SameFileError</code> 而不是 <code>Error</code>。 由于前者是后者的子类，此改变是向后兼容的。</p>
<p>在 3.8 版更改: 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 </p>
<p><em>exception</em> <code>shutil.SameFileError</code></p>
<p>此异常会在 <code>copyfile()</code> 中的源和目标为同一文件时被引发。</p>
<p>3.4 新版功能.</p>
<p><code>shutil.copymode</code>(<em>src</em>, <em>dst</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>从 <em>src</em> 拷贝权限位到 <em>dst*。 文件的内容、所有者和分组将不受影响。 *src</em> 和 <em>dst</em> 均为路径类对象或字符串形式的路径名。 如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均为符号链接，<code>copymode()</code> 将尝试修改 <em>dst</em> 本身的模式（而非它所指向的文件）。 此功能并不是在所有平台上均可用；请参阅 <code>copystat()</code> 了解详情。 如果 <code>copymode()</code> 无法修改本机平台上的符号链接，而它被要求这样做，它将不做任何操作即返回。</p>
<p>引发一个 审计事件 <code>shutil.copymode</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 加入 <em>follow_symlinks</em> 参数。</p>
<p><code>shutil.copystat</code>(<em>src</em>, <em>dst</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>从 <em>src</em> 拷贝权限位、最近访问时间、最近修改时间以及旗标到 <em>dst*。 在 Linux上，<code>copystat()</code> 还会在可能的情况下拷贝“扩展属性”。 文件的内容、所有者和分组将不受影响。 *src</em> 和 <em>dst</em> 均为路径类对象或字符串形式的路径名。</p>
<p>如果 <em>follow_symlinks</em> 为假值，并且 <em>src</em> 和 <em>dst</em> 均指向符号链接，<code>copystat()</code> 将作用于符号链接本身而非该符号链接所指向的文件 — 从 <em>src</em> 符号链接读取信息，并将信息写入 <em>dst</em> 符号链接。</p>
<p>注解</p>
<p>并非所有平台者提供检查和修改符号链接的功能。 Python 本身可以告诉你哪些功能是在本机上可用的。</p>
<ul>
<li>如果 <code>os.chmod in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <code>copystat()</code> 可以修改符号链接的权限位。</li>
<li>如果 <code>os.utime in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <code>copystat()</code> 可以修改符号链接的最近访问和修改时间。</li>
<li>如果 <code>os.chflags in os.supports_follow_symlinks</code> 为 <code>True</code>，则 <code>copystat()</code> 可以修改符号链接的旗标。 (<code>os.chflags</code> 不是在所有平台上均可用。)</li>
</ul>
<p>在此功能部分或全部不可用的平台上，当被要求修改一个符号链接时，<code>copystat()</code> 将尽量拷贝所有内容。 <code>copystat()</code> 一定不会返回失败信息。</p>
<p>引发一个 审计事件 <code>shutil.copystat</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 添加了 <em>follow_symlinks</em> 参数并且支持 Linux 扩展属性。</p>
<p><code>shutil.copy</code>(<em>src</em>, <em>dst</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>将文件 <em>src</em> 拷贝到文件或目录 <em>dst*。 *src</em> 和 <em>dst</em> 应为 路径类对象 或字符串。 如果 <em>dst</em> 指定了一个目录，文件将使用 <em>src</em> 中的基准文件名拷贝到 <em>dst</em> 中。 将返回新创建文件所对应的路径。</p>
<p>如果 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接，则 <em>dst</em> 也将被创建为符号链接。 如果 <em>follow_symlinks</em> 为真值且 <em>src</em> 为符号链接，<em>dst</em> 将成为 <em>src</em> 所指向的文件的一个副本。</p>
<p><code>copy()</code> 会拷贝文件数据和文件的权限模式 (参见 <code>os.chmod()</code>)。 其他元数据，例如文件的创建和修改时间不会被保留。 要保留所有原有的元数据，请改用 <code>copy2()</code> 。</p>
<p>引发一个 审计事件 <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>引发一个 审计事件 <code>shutil.copymode</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 添加了 <em>follow_symlinks</em> 参数。 现在会返回新创建文件的路径。</p>
<p>在 3.8 版更改: 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 </p>
<p><code>shutil.copy2</code>(<em>src</em>, <em>dst</em>, <em>**,</em> follow_symlinks=True*)</p>
<p>类似于 <code>copy()</code>，区别在于 <code>copy2()</code> 还会尝试保留文件的元数据。</p>
<p>当 <em>follow_symlinks</em> 为假值且 <em>src</em> 为符号链接时，<code>copy2()</code> 会尝试将来自 <em>src</em> 符号链接的所有元数据拷贝到新创建的 <em>dst</em> 符号链接。 但是，此功能不是在所有平台上均可用。 在此功能部分或全部不可用的平台上，<code>copy2()</code> 将尽量保留所有元数据；<code>copy2()</code> 一定不会由于无法保留文件元数据而引发异常。</p>
<p><code>copy2()</code> 会使用 <code>copystat()</code> 来拷贝文件元数据。 </p>
<p>引发一个 审计事件 <code>shutil.copyfile</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>引发一个 审计事件 <code>shutil.copystat</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 添加了 <em>follow_symlinks</em> 参数，还会尝试拷贝扩展文件系统属性（目前仅限 Linux）。 现在会返回新创建文件的路径。</p>
<p>在 3.8 版更改: 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 </p>
<p><code>shutil.ignore_patterns</code>(<em>\</em>patterns*)</p>
<p>这个工厂函数会创建一个函数，它可被用作 <code>copytree()</code> 的 <em>ignore</em> 可调用对象参数，以忽略那些匹配所提供的 glob 风格的 <em>patterns</em> 之一的文件和目录。 参见以下示例。</p>
<p><code>shutil.copytree</code>(<em>src</em>, <em>dst</em>, <em>symlinks=False</em>, <em>ignore=None</em>, <em>copy_function=copy2</em>, <em>ignore_dangling_symlinks=False</em>, <em>dirs_exist_ok=False</em>)</p>
<p>将以 <em>src</em> 为根起点的整个目录树拷贝到名为 <em>dst</em> 的目录并返回目标目录。 <em>dirs_exist_ok</em> 指明是否要在 <em>dst</em> 或任何丢失的父目录已存在的情况下引发异常。</p>
<p>目录的权限和时间会通过 <code>copystat()</code> 来拷贝，单个文件则会使用 <code>copy2()</code> 来拷贝。</p>
<p>如果 <em>symlinks</em> 为真值，源目录树中的符号链接会在新目录树中表示为符号链接，并且原链接的元数据在平台允许的情况下也会被拷贝；如果为假值或省略，则会将被链接文件的内容和元数据拷贝到新目录树。</p>
<p>当 <em>symlinks</em> 为假值时，如果符号链接所指向的文件不存在，则会在拷贝进程的末尾将一个异常添加到 <code>Error</code> 异常中的错误列表。 如果你希望屏蔽此异常那就将可选的 <em>ignore_dangling_symlinks</em> 旗标设为真值。 请注意此选项在不支持 <code>os.symlink()</code> 的平台上将不起作用。</p>
<p>如果给出了 <em>ignore<em>，它必须是一个可调用对象，该对象将接受 <code>copytree()</code> 所访问的目录以及 <code>os.listdir()</code> 所返回的目录内容列表作为其参数。 由于 <code>copytree()</code> 是递归地被调用的，</em>ignore</em> 可调用对象对于每个被拷贝目录都将被调用一次。 该可调用对象必须返回一个相对于当前目录的目录和文件名序列（即其第二个参数的子集）；随后这些名称将在拷贝进程中被忽略。 <code>ignore_patterns()</code> 可被用于创建这种基于 glob 风格模式来忽略特定名称的可调用对象。</p>
<p>如果发生了（一个或多个）异常，将引发一个附带原因列表的 <code>Error</code>。</p>
<p>如果给出了 <em>copy_function</em>，它必须是一个将被用来拷贝每个文件的可调用对象。 它在被调用时会将源路径和目标路径作为参数传入。 默认情况下，<code>copy2()</code> 将被使用，但任何支持同样签名（与 <code>copy()</code> 一致）都可以使用。</p>
<p>引发一个 审计事件 <code>shutil.copytree</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 当 <em>symlinks</em> 为假值时拷贝元数据。 现在会返回 <em>dst</em>。</p>
<p>在 3.2 版更改: 添加了 <em>copy_function</em> 参数以允许提供定制的拷贝函数。 添加了 <em>ignore_dangling_symlinks</em> 参数以便在 <em>symlinks</em> 为假值时屏蔽符号链接错误。</p>
<p>在 3.8 版更改: 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 </p>
<p>3.8 新版功能: <em>dirs_exist_ok</em> 形参。</p>
<p><code>shutil.rmtree</code>(<em>path</em>, <em>ignore_errors=False</em>, <em>onerror=None</em>)</p>
<p>删除一个完整的目录树；<em>path</em> 必须指向一个目录（但不能是一个目录的符号链接）。 如果 <em>ignore_errors</em> 为真值，删除失败导致的错误将被忽略；如果为假值或是省略，此类错误将通过调用由 <em>onerror</em> 所指定的处理程序来处理，或者如果此参数被省略则将引发一个异常。</p>
<p>注解</p>
<p>在支持必要的基于 fd 的函数的平台上，默认会使用 <code>rmtree()</code> 的可防御符号链接攻击的版本。 在其他平台上，<code>rmtree()</code> 较易遭受符号链接攻击：给定适当的时间和环境，攻击者可以操纵文件系统中的符号链接来删除他们在其他情况下无法访问的文件。 应用程序可以使用 <code>rmtree.avoids_symlink_attacks</code> 函数属性来确定此类情况具体是哪一些。</p>
<p>如果提供了 <em>onerror*，它必须为接受三个形参的可调用对象: *function</em>, <em>path</em> 和 <em>excinfo</em>。</p>
<p>第一个形参 <em>function</em> 是引发异常的函数；它依赖于具体的平台和实现。 第二个形参 <em>path</em> 将是传递给 <em>function</em> 的路径名。 第三个形参 <em>excinfo</em> 将是由 <code>sys.exc_info()</code> 所返回的异常信息。 由 <em>onerror</em> 所引发的异常将不会被捕获。</p>
<p>引发一个 审计事件 <code>shutil.rmtree</code> 附带参数 <code>path</code>。</p>
<p>在 3.3 版更改: 添加了一个防御符号链接攻击的版本，如果平台支持基于 fd 的函数就会被使用。</p>
<p>在 3.8 版更改: 在 Windows 上将不会再在移除连接之前删除目录连接中的内容。</p>
<ul>
<li><p><code>rmtree.avoids_symlink_attacks</code></p>
<p>指明当前平台和实现是否提供防御符号链接攻击的 <code>rmtree()</code> 版本。 目前它仅在平台支持基于 fd 的目录访问函数时才返回真值。</p>
<p>3.3 新版功能.</p>
</li>
</ul>
<p><code>shutil.move</code>(<em>src</em>, <em>dst</em>, <em>copy_function=copy2</em>)</p>
<p>递归地将一个文件或目录 (<em>src</em>) 移至另一位置 (<em>dst</em>) 并返回目标位置。</p>
<p>如果目标是已存在的目录，则 <em>src</em> 会被移至该目录下。 如果目标已存在但不是目录，它可能会被覆盖，具体取决于 <code>os.rename()</code> 的语义。</p>
<p>如果目标是在当前文件系统中，则会使用 <code>os.rename()</code>。 在其他情况下，<em>src</em> 将被拷贝至 <em>dst<em>，使用的函数为 *copy_function</em>，然后目标会被移除。 对于符号链接，则将在 *dst</em> 之下或以其本身为名称创建一个指向 <em>src</em> 目标的新符号链接，并且 <em>src</em> 将被移除。</p>
<p>如果给出了 <em>copy_function*，则它必须为接受两个参数 *src</em> 和 <em>dst</em> 的可调用对象，并将在 <code>os.rename()</code> 无法使用时被用来将 <em>src</em> 拷贝到 <em>dst*。 如果源是一个目录，则会调用 <code>copytree()</code>，并向它传入 <code>copy_function()</code>。 默认的 *copy_function</em> 是 <code>copy2()</code>。 使用 <code>copy()</code> 作为 <em>copy_function</em> 允许在无法附带拷贝元数据时让移动操作成功执行，但其代价是不拷贝任何元数据。</p>
<p>引发一个 审计事件 <code>shutil.move</code> 附带参数 <code>src</code>, <code>dst</code>。</p>
<p>在 3.3 版更改: 为异类文件系统添加了显式的符号链接处理，以便使它适应 GNU 的 <strong>mv</strong> 的行为。 现在会返回 <em>dst</em>。</p>
<p>在 3.5 版更改: 增加了 <em>copy_function</em> 关键字参数。</p>
<p>在 3.8 版更改: 可能会在内部使用平台专属的快速拷贝系统调用以更高效地拷贝文件。 </p>
<p>在 3.9 版更改: 接受一个 path-like object 作为 <em>src</em> 和 <em>dst</em>。</p>
<p><code>shutil.disk_usage</code>(<em>path</em>)</p>
<p>返回给定路径的磁盘使用统计数据，形式为一个 named tuple，其中包含 <em>total</em>, <em>used</em> 和 <em>free</em> 属性，分别表示总计、已使用和未使用空间的字节数。 <em>path</em> 可以是一个文件或是一个目录。</p>
<p>3.3 新版功能.</p>
<p>在 3.8 版更改: 在 Windows 上，<em>path</em> 现在可以是一个文件或目录。</p>
<p>可用性: Unix, Windows。</p>
<p><code>shutil.chown</code>(<em>path</em>, <em>user=None</em>, <em>group=None</em>)</p>
<p>修改给定 <em>path</em> 的所有者 <em>user</em> 和/或 <em>group</em>。</p>
<p><em>user</em> 可以是一个系统用户名或 uid；<em>group</em> 同样如此。 要求至少有一个参数。</p>
<p>另请参阅下层的函数 <code>os.chown()</code>。</p>
<p>引发一个 审计事件 <code>shutil.chown</code> 附带参数 <code>path</code>, <code>user</code>, <code>group</code>。</p>
<p>可用性: Unix。</p>
<p>3.3 新版功能.</p>
<p><code>shutil.which</code>(<em>cmd</em>, <em>mode=os.F_OK | os.X_OK</em>, <em>path=None</em>)</p>
<p>返回当给定的 <em>cmd</em> 被调用时将要运行的可执行文件的路径。 如果没有 <em>cmd</em> 会被调用则返回 <code>None</code>。</p>
<p><em>mode</em> 是一个传递给 <code>os.access()</code> 的权限掩码，在默认情况下将确定文件是否存在并且为可执行文件。</p>
<p>当未指定 <em>path</em> 时，将会使用 <code>os.environ()</code> 的结果，返回 “PATH” 的值或回退为 <code>os.defpath</code>。</p>
<p>在 Windows 上当前目录总是会被添加为 <em>path</em> 的第一项，无论你是否使用默认值或提供你自己的路径，这是命令行终端在查找可执行文件时所采用的行为方式。 此外，当在 <em>path</em> 中查找 <em>cmd</em> 时，还会检查 <code>PATHEXT</code> 环境变量。 例如，如果你调用 <code>shutil.which("python")</code>，<code>which()</code> 将搜索 <code>PATHEXT</code> 来确定它要在 <em>path</em> 目录中查找 <code>python.exe</code>。 例如，在 Windows 上:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> shutil<span class="token punctuation">.</span>which<span class="token punctuation">(</span><span class="token string">"python"</span><span class="token punctuation">)</span>
<span class="token string">'C:\\Python33\\python.EXE'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>3.3 新版功能.</p>
<p>在 3.8 版更改: 现在可以接受 <code>bytes</code> 类型。 如果 <em>cmd</em> 的类型为 <code>bytes</code>，结果的类型也将为 <code>bytes</code>。</p>
<p><em>exception</em> <code>shutil.Error</code></p>
<p>此异常会收集在多文件操作期间所引发的异常。 对于 <code>copytree()</code>，此异常参数将是一个由三元组 (<em>srcname</em>, <em>dstname</em>, <em>exception</em>) 构成的列表。</p>
<h4 id="依赖于具体平台的高效拷贝操作"><a href="#依赖于具体平台的高效拷贝操作" class="headerlink" title="依赖于具体平台的高效拷贝操作"></a>依赖于具体平台的高效拷贝操作</h4><p>从 Python 3.8 开始，所有涉及文件拷贝的函数 (<code>copyfile()</code>, <code>copy()</code>, <code>copy2()</code>, <code>copytree()</code> 以及 <code>move()</code>) 将会使用平台专属的 “fast-copy” 系统调用以便更高效地拷贝文件 。 “fast-copy” 意味着拷贝操作将发生于内核之中，避免像在 “<code>outfd.write(infd.read())</code>“ 中那样使用 Python 用户空间的缓冲区。</p>
<p>在 macOS 上将会使用 fcopyfile 来拷贝文件内容（不含元数据）。</p>
<p>在 Linux 上将会使用 <code>os.sendfile()</code>。</p>
<p>在 Windows 上 <code>shutil.copyfile()</code> 将会使用更大的默认缓冲区（1 MiB 而非 64 KiB）并且会使用基于 <code>memoryview()</code> 的 <code>shutil.copyfileobj()</code> 变种形式。</p>
<p>如果快速拷贝操作失败并且没有数据被写入目标文件，则 shutil 将在内部静默地回退到使用效率较低的 <code>copyfileobj()</code> 函数。</p>
<p>在 3.8 版更改.</p>
<h4 id="copytree-示例"><a href="#copytree-示例" class="headerlink" title="copytree 示例"></a>copytree 示例</h4><p>这个示例就是上面所描述的 <code>copytree()</code> 函数的实现，其中省略了文档字符串。 它还展示了此模块所提供的许多其他函数。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">copytree</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> symlinks<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    names <span class="token operator">=</span> os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>src<span class="token punctuation">)</span>
    os<span class="token punctuation">.</span>makedirs<span class="token punctuation">(</span>dst<span class="token punctuation">)</span>
    errors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> name <span class="token keyword">in</span> names<span class="token punctuation">:</span>
        srcname <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>src<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
        dstname <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>dst<span class="token punctuation">,</span> name<span class="token punctuation">)</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> symlinks <span class="token operator">and</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>islink<span class="token punctuation">(</span>srcname<span class="token punctuation">)</span><span class="token punctuation">:</span>
                linkto <span class="token operator">=</span> os<span class="token punctuation">.</span>readlink<span class="token punctuation">(</span>srcname<span class="token punctuation">)</span>
                os<span class="token punctuation">.</span>symlink<span class="token punctuation">(</span>linkto<span class="token punctuation">,</span> dstname<span class="token punctuation">)</span>
            <span class="token keyword">elif</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>isdir<span class="token punctuation">(</span>srcname<span class="token punctuation">)</span><span class="token punctuation">:</span>
                copytree<span class="token punctuation">(</span>srcname<span class="token punctuation">,</span> dstname<span class="token punctuation">,</span> symlinks<span class="token punctuation">)</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                copy2<span class="token punctuation">(</span>srcname<span class="token punctuation">,</span> dstname<span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true"># XXX What about devices, sockets etc.?</span>
        <span class="token keyword">except</span> OSError <span class="token keyword">as</span> why<span class="token punctuation">:</span>
            errors<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>srcname<span class="token punctuation">,</span> dstname<span class="token punctuation">,</span> str<span class="token punctuation">(</span>why<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true"># catch the Error from the recursive copytree so that we can</span>
        <span class="token comment" spellcheck="true"># continue with other files</span>
        <span class="token keyword">except</span> Error <span class="token keyword">as</span> err<span class="token punctuation">:</span>
            errors<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>err<span class="token punctuation">.</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        copystat<span class="token punctuation">(</span>src<span class="token punctuation">,</span> dst<span class="token punctuation">)</span>
    <span class="token keyword">except</span> OSError <span class="token keyword">as</span> why<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true"># can't copy file access times on Windows</span>
        <span class="token keyword">if</span> why<span class="token punctuation">.</span>winerror <span class="token keyword">is</span> None<span class="token punctuation">:</span>
            errors<span class="token punctuation">.</span>extend<span class="token punctuation">(</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> dst<span class="token punctuation">,</span> str<span class="token punctuation">(</span>why<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> errors<span class="token punctuation">:</span>
        <span class="token keyword">raise</span> Error<span class="token punctuation">(</span>errors<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另一个使用 <code>ignore_patterns()</code> 辅助函数的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> shutil <span class="token keyword">import</span> copytree<span class="token punctuation">,</span> ignore_patterns
copytree<span class="token punctuation">(</span>source<span class="token punctuation">,</span> destination<span class="token punctuation">,</span> ignore<span class="token operator">=</span>ignore_patterns<span class="token punctuation">(</span><span class="token string">'*.pyc'</span><span class="token punctuation">,</span> <span class="token string">'tmp*'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这将会拷贝除 <code>.pyc</code> 文件和以 <code>tmp</code> 打头的文件或目录以外的所有条目.</p>
<p>另一个使用 <em>ignore</em> 参数来添加记录调用的例子:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> shutil <span class="token keyword">import</span> copytree
<span class="token keyword">import</span> logging
<span class="token keyword">def</span> <span class="token function">_logpath</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> names<span class="token punctuation">)</span><span class="token punctuation">:</span>
    logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'Working in %s'</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token comment" spellcheck="true"># nothing will be ignored</span>
copytree<span class="token punctuation">(</span>source<span class="token punctuation">,</span> destination<span class="token punctuation">,</span> ignore<span class="token operator">=</span>_logpath<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="rmtree-示例"><a href="#rmtree-示例" class="headerlink" title="rmtree 示例"></a>rmtree 示例</h4><p>这个例子演示了如何在 Windows 上删除一个目录树，其中部分文件设置了只读属性位。 它会使用 onerror 回调函数来清除只读属性位并再次尝试删除。 任何后续的失败都将被传播。</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token punctuation">,</span> stat
<span class="token keyword">import</span> shutil
<span class="token keyword">def</span> <span class="token function">remove_readonly</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> path<span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token string">"Clear the readonly bit and reattempt the removal"</span>
    os<span class="token punctuation">.</span>chmod<span class="token punctuation">(</span>path<span class="token punctuation">,</span> stat<span class="token punctuation">.</span>S_IWRITE<span class="token punctuation">)</span>
    func<span class="token punctuation">(</span>path<span class="token punctuation">)</span>
shutil<span class="token punctuation">.</span>rmtree<span class="token punctuation">(</span>directory<span class="token punctuation">,</span> onerror<span class="token operator">=</span>remove_readonly<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="归档操作"><a href="#归档操作" class="headerlink" title="归档操作"></a>归档操作</h3><p>3.2 新版功能.</p>
<p>在 3.5 版更改: 添加了对 <em>xztar</em> 格式的支持。</p>
<p>本模块也提供了用于创建和读取压缩和归档文件的高层级工具。 它们依赖于 <code>zipfile</code> 和 <code>tarfile</code> 模块。</p>
<p><code>shutil.make_archive</code>(<em>base_name</em>, <em>format</em>[, <em>root_dir</em>[, <em>base_dir</em>[, <em>verbose</em>[, <em>dry_run</em>[, <em>owner</em>[, <em>group</em>[, <em>logger</em>]]]]]]])</p>
<p>创建一个归档文件（例如 zip 或 tar）并返回其名称。</p>
<p><em>base_name</em> 是要创建的文件名称，包括路径，去除任何特定格式的扩展名。 <em>format</em> 是归档格式：为 “zip” (如果 <code>zlib</code> 模块可用), “tar”, “gztar” (如果 <code>zlib</code> 模块可用), “bztar” (如果 <code>bz2</code> 模块可用) 或 “xztar” (如果 <code>lzma</code> 模块可用) 中的一个。</p>
<p><em>root_dir</em> 是一个目录，它将作为归档文件的根目录，归档中的所有路径都将是它的相对路径；例如，我们通常会在创建归档之前用 chdir 命令切换到 <em>root_dir</em>。</p>
<p><em>base_dir</em> 是我们要执行归档的起始目录；也就是说 <em>base_dir</em> 将成为归档中所有文件和目录共有的路径前缀。 <em>base_dir</em> 必须相对于 <em>root_dir</em> 给出。</p>
<p><em>root_dir</em> 和 <em>base_dir</em> 默认均为当前目录。</p>
<p>如果 <em>dry_run</em> 为真值，则不会创建归档文件，但将要被执行的操作会被记录到 <em>logger</em>。</p>
<p><em>owner</em> 和 <em>group</em> 将在创建 tar 归档文件时被使用。 默认会使用当前的所有者和分组。</p>
<p><em>logger</em> 必须是一个兼容 <a href="https://www.python.org/dev/peps/pep-0282" target="_blank" rel="noopener"><strong>PEP 282</strong></a> 的对象，通常为 <code>logging.Logger</code> 的实例。</p>
<p><em>verbose</em> 参数已不再使用并进入弃用状态。</p>
<p>引发一个 审计事件 <code>shutil.make_archive</code> 并附带参数 <code>base_name</code>, <code>format</code>, <code>root_dir</code>, <code>base_dir</code>。</p>
<p>注解</p>
<p>这个函数不是线程安全的。</p>
<p>在 3.8 版更改: 现在对于通过 <code>format="tar"</code> 创建的归档文件将使用新式的 pax (POSIX.1-2001) 格式而非旧式的 GNU 格式。</p>
<p><code>shutil.get_archive_formats</code>()</p>
<p>返回支持的归档格式列表。 所返回序列中的每个元素为一个元组 <code>(name, description)</code>。</p>
<p>默认情况下 <code>shutil</code> 提供以下格式:</p>
<ul>
<li><em>zip</em>: ZIP 文件（如果 <code>zlib</code> 模块可用）。</li>
<li><em>tar</em>: 未压缩的 tar 文件。 对于新归档文件将使用 POSIX.1-2001 pax 格式。</li>
<li><em>gztar</em>: gzip 压缩的 tar 文件（如果 <code>zlib</code> 模块可用）。</li>
<li><em>bztar</em>: bzip2 压缩的 tar 文件（如果 <code>bz2</code> 模块可用）。</li>
<li><em>xztar</em>: xz 压缩的 tar 文件（如果 <code>lzma</code> 模块可用）。</li>
</ul>
<p>你可以通过使用 <code>register_archive_format()</code> 注册新的格式或为任何现有格式提供你自己的归档器。</p>
<p><code>shutil.register_archive_format</code>(<em>name</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p>
<p>为 <em>name</em> 格式注册一个归档器。</p>
<p><em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接收要创建文件的 <em>base_name*，再加上要归档内容的 *base_dir</em> (其默认值为 <code>os.curdir</code>)。 更多参数会被作为关键字参数传入: <em>owner</em>, <em>group</em>, <em>dry_run</em> 和 <em>logger</em> (与向 <code>make_archive()</code> 传入的参数一致)。</p>
<p>如果给出了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 对的序列，将在归档器可调用对象被使用时作为附加的关键字参数。</p>
<p><em>description</em> 由 <code>get_archive_formats()</code> 使用，它将返回归档器的列表。 默认值为一个空字符串。</p>
<p><code>shutil.unregister_archive_format</code>(<em>name</em>)</p>
<p>从支持的格式中移除归档格式 <em>name</em>。</p>
<p><code>shutil.unpack_archive</code>(<em>filename</em>[, <em>extract_dir</em>[, <em>format</em>]])</p>
<p>解包一个归档文件。 <em>filename</em> 是归档文件的完整路径。</p>
<p><em>extract_dir</em> 是归档文件解包的目标目录名称。 如果未提供，则将使用当前工作目录。</p>
<p><em>format</em> 是归档格式：应为 “zip”, “tar”, “gztar”, “bztar” 或 “xztar” 之一。 或者任何通过 <code>register_unpack_format()</code> 注册的其他格式。 如果未提供，<code>unpack_archive()</code> 将使用归档文件的扩展名来检查是否注册了对应于该扩展名的解包器。 在未找到任何解包器的情况下，将引发 <code>ValueError</code>。</p>
<p>引发一个 审计事件 <code>shutil.unpack_archive</code> 附带参数 <code>filename</code>, <code>extract_dir</code>, <code>format</code>。</p>
<p>在 3.7 版更改: 接受一个 path-like object 作为 <em>filename</em> 和 <em>extract_dir</em>。</p>
<p><code>shutil.register_unpack_format</code>(<em>name</em>, <em>extensions</em>, <em>function</em>[, <em>extra_args</em>[, <em>description</em>]])</p>
<p>注册一个解包格式。 <em>name</em> 为格式名称而 <em>extensions</em> 为对应于该格式的扩展名列表，例如 Zip 文件的扩展名为 <code>.zip</code>。</p>
<p><em>function</em> 是将被用来解包归档文件的可调用对象。 该可调用对象将接受归档文件的路径，加上该归档文件要被解包的目标目录。</p>
<p>如果提供了 <em>extra_args</em>，则其应为一个 <code>(name, value)</code> 元组的序列，将被作为关键字参数传递给该可调用对象。</p>
<p>可以提供 <em>description</em> 来描述该格式，它将被 <code>get_unpack_formats()</code> 返回。</p>
<p><code>shutil.unregister_unpack_format</code>(<em>name</em>)</p>
<p>撤销注册一个解包格式。 <em>name</em> 为格式的名称。</p>
<p><code>shutil.get_unpack_formats</code>()</p>
<p>返回所有已注册的解包格式列表。 所返回序列中的每个元素为一个元组 <code>(name, extensions, description)</code>。</p>
<p>默认情况下 <code>shutil</code> 提供以下格式:</p>
<ul>
<li><em>zip</em>: ZIP 文件（只有在相应模块可用时才能解包压缩文件）。</li>
<li><em>tar</em>: 未压缩的 tar 文件。</li>
<li><em>gztar</em>: gzip 压缩的 tar 文件（如果 <code>zlib</code> 模块可用）。</li>
<li><em>bztar</em>: bzip2 压缩的 tar 文件（如果 <code>bz2</code> 模块可用）。</li>
<li><em>xztar</em>: xz 压缩的 tar 文件（如果 <code>lzma</code> 模块可用）。</li>
</ul>
<p>你可以通过使用 <code>register_unpack_format()</code> 注册新的格式或为任何现有格式提供你自己的解包器。</p>
<h4 id="归档程序示例"><a href="#归档程序示例" class="headerlink" title="归档程序示例"></a>归档程序示例</h4><p>在这个示例中，我们创建了一个 gzip 压缩的 tar 归档文件，其中包含用户的 <code>.ssh</code> 目录下的所有文件:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> shutil <span class="token keyword">import</span> make_archive
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> archive_name <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'~'</span><span class="token punctuation">,</span> <span class="token string">'myarchive'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> root_dir <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'~'</span><span class="token punctuation">,</span> <span class="token string">'.ssh'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> make_archive<span class="token punctuation">(</span>archive_name<span class="token punctuation">,</span> <span class="token string">'gztar'</span><span class="token punctuation">,</span> root_dir<span class="token punctuation">)</span>
<span class="token string">'/Users/tarek/myarchive.tar.gz'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果归档文件中包含有:</p>
<pre><code>$ tar -tzvf /Users/tarek/myarchive.tar.gz
drwx------ tarek/staff       0 2010-02-01 16:23:40 ./
-rw-r--r-- tarek/staff     609 2008-06-09 13:26:54 ./authorized_keys
-rwxr-xr-x tarek/staff      65 2008-06-09 13:26:54 ./config
-rwx------ tarek/staff     668 2008-06-09 13:26:54 ./id_dsa
-rwxr-xr-x tarek/staff     609 2008-06-09 13:26:54 ./id_dsa.pub
-rw------- tarek/staff    1675 2008-06-09 13:26:54 ./id_rsa
-rw-r--r-- tarek/staff     397 2008-06-09 13:26:54 ./id_rsa.pub
-rw-r--r-- tarek/staff   37192 2010-02-06 18:23:10 ./known_hosts</code></pre><h4 id="使用-base-dir-的归档程序示例"><a href="#使用-base-dir-的归档程序示例" class="headerlink" title="使用 base_dir 的归档程序示例"></a>使用 <em>base_dir</em> 的归档程序示例</h4><p>在这个例子中，与 上面的例子 类似，我们演示了如何使用 <code>make_archive()</code>，但这次是使用 <em>base_dir</em>。 我们现在具有如下的目录结构:</p>
<pre><code>$ tree tmp
tmp
└── root
    └── structure
        ├── content
            └── please_add.txt
        └── do_not_add.txt</code></pre><p>在最终的归档中，应当会包括 <code>please_add.txt</code>，但不应当包括 <code>do_not_add.txt</code>。 因此我们使用以下代码:</p>
<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">from</span> shutil <span class="token keyword">import</span> make_archive
<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> os
<span class="token operator">>></span><span class="token operator">></span> archive_name <span class="token operator">=</span> os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>expanduser<span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token string">'~'</span><span class="token punctuation">,</span> <span class="token string">'myarchive'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> make_archive<span class="token punctuation">(</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     archive_name<span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token string">'tar'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     root_dir<span class="token operator">=</span><span class="token string">'tmp/root'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     base_dir<span class="token operator">=</span><span class="token string">'structure/content'</span><span class="token punctuation">,</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span>
<span class="token string">'/Users/tarek/my_archive.tar'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>列出结果归档中的文件我们将会得到:</p>
<pre><code>$ python -m tarfile -l /Users/tarek/myarchive.tarstructure/content/structure/content/please_add.txt</code></pre><h3 id="查询输出终端的尺寸"><a href="#查询输出终端的尺寸" class="headerlink" title="查询输出终端的尺寸"></a>查询输出终端的尺寸</h3><p><code>shutil.get_terminal_size</code>(<em>fallback=columns, lines</em>)</p>
<p>获取终端窗口的尺寸。</p>
<p>对于两个维度中的每一个，会分别检查环境变量 <code>COLUMNS</code> 和 <code>LINES</code>。 如果定义了这些变量并且其值为正整数，则将使用这些值。</p>
<p>如果未定义 <code>COLUMNS</code> 或 <code>LINES</code>，这是通常的情况，则连接到 <code>sys.__stdout__</code> 的终端将通过发起调用 <code>os.get_terminal_size()</code> 被查询。</p>
<p>如果由于系统不支持查询，或是由于我们未连接到某个终端而导致查询终端尺寸不成功，则会使用在 <code>fallback</code> 形参中给出的值。 <code>fallback</code> 默认为 <code>(80, 24)</code>，这是许多终端模拟器所使用的默认尺寸。</p>
<p>返回的值是一个 <code>os.terminal_size</code> 类型的具名元组。</p>
<p>3.3 新版功能.</p>
<h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h1><p> <code>pickle</code> 和 <code>marshal</code> 模块可以将许多 Python 数据类型转换为字节流，然后从字节中重新创建对象。 各种与 DBM 相关的模块支持一系列基于散列的文件格式，这些格式存储字符串到其他字符串的映射。</p>
<p>本章中描述的模块列表是：</p>
<ul>
<li><code>pickle</code> —- Python 对象序列化<ul>
<li>与其他 Python 模块间的关系<ul>
<li>与 <code>marshal</code> 间的关系</li>
<li>与 <code>json</code> 模块的比较</li>
</ul>
</li>
<li>数据流格式</li>
<li>模块接口</li>
<li>可以被封存/解封的对象</li>
<li>封存类实例<ul>
<li>持久化外部对象</li>
<li>Dispatch 表</li>
<li>处理有状态的对象</li>
</ul>
</li>
<li>类型，函数和其他对象的自定义归约</li>
<li>外部缓冲区<ul>
<li>提供方 API</li>
<li>使用方 API</li>
<li>示例</li>
</ul>
</li>
<li>限制全局变量</li>
<li>性能</li>
<li>例子</li>
</ul>
</li>
<li><code>copyreg</code> —- 注册配合 <code>pickle</code> 模块使用的函数<ul>
<li>示例</li>
</ul>
</li>
<li><code>shelve</code> —- Python 对象持久化<ul>
<li>限制</li>
<li>示例</li>
</ul>
</li>
<li><code>marshal</code> —- 内部 Python 对象序列化</li>
<li><code>dbm</code> —- Unix “数据库” 接口<ul>
<li><code>dbm.gnu</code> —- GNU 对 dbm 的重解析</li>
<li><code>dbm.ndbm</code> —- 基于 ndbm 的接口</li>
<li><code>dbm.dumb</code> —- 便携式 DBM 实现</li>
</ul>
</li>
<li><code>sqlite3</code> —- SQLite 数据库 DB-API 2.0 接口模块<ul>
<li>模块函数和常量</li>
<li>连接对象（Connection）</li>
<li>Cursor 对象</li>
<li>行对象</li>
<li>异常</li>
<li>SQLite 与 Python 类型<ul>
<li>概述</li>
<li>使用适配器将额外的 Python 类型保存在 SQLite 数据库中。<ul>
<li>让对象自行适配</li>
<li>注册可调用的适配器</li>
</ul>
</li>
<li>将SQLite 值转换为自定义Python 类型</li>
<li>默认适配器和转换器</li>
</ul>
</li>
<li>控制事务</li>
<li>有效使用 <code>sqlite3</code><ul>
<li>使用快捷方式</li>
<li>通过名称而不是索引访问索引</li>
<li>使用连接作为上下文管理器</li>
</ul>
</li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io" rel="external nofollow noreferrer">杰克成</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jackhcc.github.io/posts/Language-Python-Lib2.html">https://jackhcc.github.io/posts/Language-Python-Lib2.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Python/">
                                    <span class="chip bg-color">Python</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/aliqr.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/reward/wxqr.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '3821a0bbb773038a51fc',
        clientSecret: '4b30b507d67ec5497ec0e77f43f80cb3e0d7dd3a',
        repo: 'JackHCC.github.io',
        owner: 'JackHCC',
        admin: "JackHCC",
        id: '2021-11-04T18-42-52',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/dl-series17.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/8.jpg" class="responsive-img" alt="DL专栏17>网络可视化">
                        
                        <span class="card-title">DL专栏17>网络可视化</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            深度学习模型网络可视化概述
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-11-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Deep-Learning/" class="post-category">
                                    Deep Learning
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Deep-Learning/">
                        <span class="chip bg-color">Deep Learning</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/Language-Python-Lib1.html">
                    <div class="card-image">
                        
                        
                        <img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/medias/featureimages/7.jpg" class="responsive-img" alt="Python-Standard Library">
                        
                        <span class="card-title">Python-Standard Library</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Python标准库详解【1】
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-11-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Language/" class="post-category">
                                    Language
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Python/">
                        <span class="chip bg-color">Python</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('4'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2020</span>
            <a href="https://jackhcc.github.io" target="_blank">杰克成</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">2549.9k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2020";
                    var startMonth = "2";
                    var startDate = "27";
                    var startHour = "6";
                    var startMinute = "30";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/JackHCC" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:jackcc0701@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="https://www.facebook.com/profile.php?id=100046343443643" class="tooltipped" target="_blank" data-tooltip="关注我的Facebook: https://www.facebook.com/profile.php?id=100046343443643" data-position="top" data-delay="50">
        <i class="fab fa-facebook-f"></i>
    </a>



    <a href="https://twitter.com/JackChe66021834" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/JackChe66021834" data-position="top" data-delay="50">
        <i class="fab fa-twitter"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2508074836" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2508074836" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/6885584679" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/6885584679" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/8f8482f01f0d6a04e844efe32e0f0710" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/materialize/materialize.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/aos/aos.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/js/matery.js"></script>

    <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
    <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
    <script type="text/javascript" src="/js/fireworks.js"></script>

    <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>'); }
    </script>

    <!-- weather -->
	<script type="text/javascript">
	WIDGET = {FID: 'TToslpmkVO'}
	</script>
	<script type="text/javascript" src="https://apip.weatherdt.com/float/static/js/r.js?v=1111"></script>


    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

    
    
    <script async src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/others/busuanzi.pure.mini.js"></script>
    

    
        <script src="//code.tidio.co/kqhlkxviiccyoa0czpfpu4ijuey9hfre.js"></script>
        <script> 
            $(document).ready(function () {
                setInterval(change_Tidio, 50);  
                function change_Tidio() { 
                    var tidio=$("#tidio-chat iframe");
                    if(tidio.css("display")=="block"&& $(window).width()>977 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" &&$(window).width()>977)>0? "-40px" : ($("div.toc-title").length&&$(window).width()>977)>0?"85px":"20px";   
                        document.getElementById("tidio-chat-iframe").style.right="-15px";   
                        document.getElementById("tidio-chat-iframe").style.height=parseInt(tidio.css("height"))>=520?"520px":tidio.css("height");
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    } 
                    else if(tidio.css("display")=="block"&&$(window).width()>601 &&$(window).width()<992 ){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && 601< $(window).width()<992)>0? "-40px":"20px" ;   
                        document.getElementById("tidio-chat-iframe").style.right="-15px"; 
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    else if(tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))<230){
                        document.getElementById("tidio-chat-iframe").style.bottom= ($("div#backTop.top-scroll").css("display")=="none" && $(window).width()<601)>0? "-10px":"45px" ;   
                        document.getElementById("tidio-chat-iframe").style.zIndex="997";
                    }
                    if( tidio.css("display")=="block"&&$(window).width()<601 && parseInt(tidio.css("height"))>=230){
                        document.getElementById("tidio-chat-iframe").style.zIndex="998";
                    }
                } 
            }); 
        </script>
    

    

    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/canvas-nest.js"></script>
    

    

    
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="https://cdn.jsdelivr.net/gh/JackHCC/JackHCC.github.io/libs/instantpage/instantpage.js" type="module"></script>
    
<script>!function(e){var c=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function i(){for(var r=0;r<c.length;r++)t=c[r],0<=(n=t.getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(e.innerHeight||document.documentElement.clientHeight)&&function(){var t,n,e,i,o=c[r];t=o,n=function(){c=c.filter(function(t){return o!==t})},e=new Image,i=t.getAttribute("data-original"),e.onload=function(){t.src=i,n&&n()},e.src=i}();var t,n}i(),e.addEventListener("scroll",function(){var t,n;t=i,n=e,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(n)},500)})}(this);</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script>
        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        $('a').each(function() {
          const $this = $(this);
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'your_domain' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script></body>

</html>

